@ -*- mode: org; -*-
..title   > El lenguaje de programacion Go
..author  > Alan A. A. Donovan
..author  > Brian W. Kernighan
..date    > 29/09/2015
..id      > isbn-13 978-0-13-419044-0
..id      > isbn-10 0-13-419044-0
..style   > worg-data/worg.css
..options > toc pygments

@ revision 3b600c, date 29 Sep 2015

..center >
  Para Leila y Meg
< center..

* Prefacio

  ..quote >
    @"(Go es un lenguaje de programacion de codigo abierto, que facilita la
    creacion de software simple, confiable y eficiente.)

    --(Desde el sitio web de Go en  @l(https://golang.org/<>golang.org))
  < quote..

  Go fue concebido en septiembre de 2007 por Robert Griesemer, Rob Pike y Ken
  Thompson, todos de Google, y fue anunciado en noviembre de 2009. La meta del
  lenguaje y sus herramientas acompañantes es ser expresivos, eficientes en la
  compilacion y ejecucion, y eficaz en la escritura de programas fiables y
  robustos.

  Go tiene una similitud superficial con C y, como C, es una herramienta para
  programadores profesionales, logrando el maximo efecto con un minimo de
  medios. Pero es mucho mas que una version actualizada de C. Obtiene y adapta
  buenas ideas de muchos otros idiomas, evitando caracteristicas que han llevado
  a la complejidad y a un codigo poco confiable. Sus comodidades para la
  concurrencia son nuevas y eficientes, y su enfoque hacia la abstraccion de
  datos y la programacion orientada a objetos es inusualmente flexible. Tambien
  cuenta con gestion automatica de memoria o @e(recoleccion de basura).

  Go es especialmente adecuado para la construccion de infraestructura como
  servidores en red, y herramientas y sistemas para programadores, pero es
  realmente un lenguaje de uso general y se utiliza en dominios tan diversos
  como graficos, aplicaciones moviles y aprendizaje automatico. Se ha vuelto
  popular como un reemplazo para los lenguajes de scripting no tipados porque
  equilibra la expresividad con la seguridad: Los programas Go suelen funcionar
  mas rapido que los programas escritos en lenguajes dinamicos y sufren muchos
  menos accidentes debido a errores de tipado.

  Go es un proyecto de codigo abierto, por lo que el codigo fuente de su
  compilador, librerias y herramientas esta disponible gratuitamente para
  cualquiera. Las contribuciones al proyecto provienen de una activa comunidad
  mundial. Go se ejecuta en sistemas tipo Unix–GNU/Linux, FreeBSD, OpenBSD,
  Mac OS X–y en Plan 9 y Microsoft Windows. Los programas escritos en uno de
  estos entornos generalmente funcionan sin modificacion en los otros.

  Este libro esta diseñado para ayudarle a comenzar a usar Go efectivamente, de
  inmediato y utilizarlo bien, aprovechando al maximo las caracteristicas
  lingüisticas de Go y las librerias estandar para escribir programas claros,
  idiomaticos y eficientes.

** Los origenes de Go

   Como las especies biologicas, las lenguas exitosas engendran hijos que
   incorporan las ventajas de sus antepasados; El entrecruzamiento a veces
   conduce a fortalezas sorprendentes; Y, muy ocasionalmente, surge un nuevo
   rasgo radical sin precedentes. Podemos aprender mucho sobre por que un
   lenguaje es como es y a que entorno se ha adaptado para ver estas
   influencias.

   La siguiente figura muestra las influencias mas importantes de los lenguajes
   de programacion anteriores en el diseño de Go.

   ..img > img/go-influences.jpg


   En ocaciones Go se describe como un @"(lenguaje de tipo C,) o como @"(C para
   el siglo 21.) De C, Go heredo su sintaxis de expresiones, instrucciones de
   flujo de control, tipos de datos basicos, paso parametros por valor, punteros
   y, sobre todo, el enfasis de C en programas que compilan codigo maquina
   eficiente y cooperan naturalmente con las abstracciones de los sistemas
   operativos actuales.

   Pero hay otros antepasados ​​en el arbol genealogico de Go. Una importante
   corriente de influencia proviene de lenguajes de Niklaus Wirth, comenzando
   con Pascal. Modula-2 inspiro el concepto de paquete. Oberon elimino la
   distincion entre los archivos de interfaz del modulo y los archivos de
   implementacion del modulo. Oberon-2 influyo en la sintaxis de paquetes,
   importaciones y declaraciones, y Object Oberon proporciono la sintaxis para
   la declararcion de metodos.

   Otro linaje entre los antepasados de Go, y uno que hace a Go distinto entre
   los lenguajes de programacion mas recientes, es una secuencia de lenguajes de
   investigacion poco conocidos desarrollados en los Laboratorios Bell, todos
   ellos inspiradas en el concepto de comunicacion de procesos secuenciales
   (CSP) del seminal articulo de 1978 de Tony Hoare en los cimientos de la
   concurrencia. En CSP, un programa es una composicion paralela de procesos que
   no tienen estado compartido; Los procesos se comunican y sincronizan
   utilizando canales. Pero el CSP de Hoare era un lenguaje formal para
   describir los conceptos fundamentales de la concurrencia, no un lenguaje de
   programacion para escribir programas ejecutables.

   Rob Pike y otros comenzaron a experimentar con implementaciones CSP como
   lenguajes reales. El primero fue llamado Squeak (@"(Un Lenguaje para
   comunicarce con ratones)), que proporcionaron un lenguaje para el manejo de
   eventos de raton y teclado, con canales estaticamente creados. Esto fue
   seguido por Newsqueak, que ofrecia declaraciones y sintaxis de expresion como
   C y la notacion de tipo Pascal. Se trataba de un lenguaje puramente funcional
   con recoleccion de basura, dirigido nuevamente a administrar eventos de
   teclado, raton y ventanas. Los canales se convirtieron en valores de primera
   clase, creados dinamicamente y almacenados en variables.

   El sistema operativo Plan 9 llevo adelante estas ideas en un lenguaje llamado
   Alef. Alef trato de hacer de Newsqueak un lenguaje viable para la
   programacion de sistemas, pero su omision de un recoleccion de basura hizo
   que la concurrencia fuera demasiado dolorosa.

   Otras construcciones en Go muestran la influencia de genes no ancestrales
   aqui y alla; Por ejemplo @c(iota) es tomado libremente de APL, y el ambito
   lexico con funciones anidadas es de Scheme (y la mayoria de lenguajes desde
   entonces). Aqui tambien encontramos mutaciones novedosas. Go innova
   proporcionando slices (arreglos dinamicos) con acceso aleatorio eficiente,
   pero tambien permite sofisticados arreglos compartidos que recuerdan a las
   listas enlazadas. Y la declaracion @c(defer) es con Go.

** El proyecto Go

   Todos los lenguajes de programacion reflejan la filosofia de programacion de
   sus creadores, que a menudo incluye un componente significativo de la
   reaccion a las deficiencias percibidas de los idiomas anteriores. El proyecto
   Go fue frustrado con varios sistemas de software de Google que estaban
   sufriendo una explosion de complejidad. (Este problema no es exclusivo de
   Google.)

   Como Rob Pike dijo, @"(la complejidad es multiplicativa): solucionar un
   problema al hacer una parte del sistema mas compleja, lenta pero seguramente
   añade complejidad a otras partes. Con la presion constante para agregar
   caracteristicas y opciones y configuraciones, y para enviar codigo
   rapidamente, es facil olvidar la sencillez, aunque a la larga la simplicidad
   es la clave para un buen software.

   La simplicidad requiere mas trabajo al comienzo de un proyecto para reducir
   una idea a su esencia y mas disciplina durante la vida de un proyecto para
   distinguir los buenos cambios, de los malos o perniciosos. Con un esfuerzo
   suficiente, un buen cambio se puede acomodar sin comprometer lo que Fred
   Brooks llamo la @"(integridad conceptual) del diseño, pero un mal cambio no
   puede, un cambio pernicioso negocia la sencillez por uno conveniencia
   superficial. Solo a traves de la simplicidad del diseño un sistema puede
   permanecer estable, seguro y coherente a medida que crece.

   El proyecto Go incluye el lenguaje mismo, sus herramientas y librerias
   estandar, y por ultimo, pero no menos importante, una agenda cultural de
   simplicidad radical. Como un lenguaje reciente de alto nivel, Go tiene el
   beneficio de la retrospectiva, y los fundamentos se hacen bien: tiene
   recoleccion de basura, un sistema de paquetes, funciones de primera clase,
   alcance lexico, una interfaz de llamadas de sistema y cadenas inmutables en
   las que el texto es generalmente codificado en UTF-8. Pero tiene
   comparativamente pocas caracteristicas y es poco probable que agregue
   mas. Por ejemplo, no tiene conversiones numericas implicitas, no hay
   constructores o destructores, no hay sobrecarga de operadores, no hay valores
   de parametros predeterminados, no hay herencia, no hay genericos, no hay
   excepciones, no hay macros, no hay anotaciones de funcion y no hay
   almacenamiento local de subprocesos. El lenguaje es maduro y estable y
   garantiza la compatibilidad con versiones anteriores: los programas Go mas
   antiguos se pueden compilar y ejecutar con versiones mas recientes de
   compiladores y librerias estandar.

   Go tiene un sistema de tipado para evitar la mayoria de los errores
   descuidados que afectan a los programadores en lenguajes dinamicos, pero
   tiene un sistema de tipado mas simple que los lenguajes tipados
   comparables. Este enfoque puede conducir en ocaciones a baches de
   programacion @"(sin tipo) dentro de un marco mas amplio de tipos, y los
   programadores Go no van a las longitudes que hacen a los programadores C++ o
   Haskell expresar propiedades de seguridad como pruebas basadas en tipo. Pero
   en la practica, Go da a los programadores gran parte de los beneficios de
   seguridad y rendimiento en tiempo de ejecucion de un sistema de tipado
   relativamente fuerte sin la carga de complejidad.

   Go fomenta una conciencia del diseño de sistemas informaticos contemporaneos,
   particularmente la importancia de la localidad. Sus tipos de datos
   incorporados y la mayoria de las estructuras de datos de la libreria estan
   diseñados para funcionar naturalmente sin inicializacion explicita o
   constructores implicitos, por lo que relativamente pocas asignaciones de
   memoria y escrituras de memoria estan ocultas en el codigo. Los tipos
   agregados de Go (estructuras y matrices) mantienen sus elementos
   directamente, requiriendo menos almacenamiento y menos asignaciones e
   indireccion de punteros, que los idiomas que utilizan campos indirectos. Y
   como la computadora moderna es una maquina paralela, Go tiene caracteristicas
   de concurrencia basadas en CSP, como se menciono anteriormente. Los stacs de
   tamaño variable de los hilos ligeros de Go o @e(goroutines) son inicialmente
   lo suficientemente pequeñas como para que crear una goroutine sea barato y
   crear un millon sea practico.

   La libreria estandar de Go, a menudo descrita como con @"(baterias
   incluidas,) proporciona bloques de construccion limpios y APIs de E/S,
   procesamiento de texto, graficos, criptografia, redes y aplicaciones
   distribuidas, con soporte para muchos formatos de archivos y protocolos
   estandar. Las librerias y las herramientas hacen uso extensivo de la
   convencion para reducir la necesidad de configuracion y explicaciones,
   simplificando asi la logica del programa y haciendo que diversos programas Go
   sean mas similares entre si y, por lo tanto, mas faciles de aprender. Los
   proyectos creados con la herramienta @$(go) solo utilizan nombres de archivos
   e identificadores y un comentario especial ocasional para determinar todas
   las librerias, ejecutables, pruebas, referencias, ejemplos, variantes
   especificas de la plataforma y documentacion para un proyecto; El codigo
   fuente de Go en si contiene la especificacion de compilacion.

** Organizacion del Libro

   Asumimos que usted ha programado en uno o mas lenguajes, compilados como C,
   C++ y Java, o interpretados como Python, Ruby y JavaScript, por lo que no
   solemos explicar todo como si fuera un completo principiante. La sintaxis
   superficial sera familiar, al igual que variables y constantes, expresiones,
   flujo de control y funciones.

   El capitulo 1 es un tutorial sobre las construcciones basicas de Go,
   introducido a traves de una docena de programas para tareas cotidianas como
   leer y escribir archivos, formatear texto, crear imagenes y comunicarse con
   clientes y servidores de Internet.

   El capitulo 2 describe los elementos estructurales de un programa
   Go–declaraciones, variables, nuevos tipos, paquetes y archivos, y alcance. El
   capitulo 3 analiza numeros, booleanos, cadenas y constantes, y explica como
   procesar Unicode. El capitulo 4 describe los tipos compuestos, es decir, los
   tipos construidos a partir de los mas sencillos utilizando arreglos, mapas,
   estructuras y slices, la aproximacion de Go para listas dinamicas. El
   capitulo 5 cubre las funciones y discute el manejo de errores,
   @c(panic) y @c(recover), y la sentencia @c(defer).

   Los capitulos 1 a 5 son, son por lo tanto, lo basico, las cosas que forman
   parte de cualquier lenguaje imperativo popular. La sintaxis y el estilo de Go
   a veces difieren de otros lenguajes, pero la mayoria de los programadores los
   recogeran rapidamente. Los capitulos restantes se centran en temas en los que
   el enfoque de Go es menos convencional: metodos, interfaces, concurrencia,
   paquetes, pruebas y reflexion.

   Go tiene un acercamiento inusual a la programacion orientada a objetos. No
   hay jerarquias de clase, o de hecho ninguna clase; Los comportamientos de
   objetos complejos se crean a partir de los mas simples por composicion, no
   por herencia. Los metodos pueden ser asociados con cualquier tipo definido
   por el usuario, no solo las estructuras, y la relacion entre tipos concretos
   y tipos abstractos (@e(interfaces)) es implicita, por lo que un tipo concreto
   puede satisfacer una interfaz que el diseñador del tipo desconocia. Los
   metodos estan cubiertos en el capitulo 6, las interfaces en el capitulo 7.

   El capitulo 8 presenta el enfoque de Go a la concurrencia, que se basa en la
   idea de comunicar procesos secuenciales (CSP), incorporados por goroutines y
   canales. El Capitulo 9 explica los aspectos mas tradicionales de la
   concurrencia basados ​​en variables compartidas.

   El capitulo 10 describe los paquetes, el mecanismo para organizar las
   librerias. Este capitulo tambien muestra como hacer un uso efectivo de la
   herramienta @$(go), provista para la compilacion, pruebas, benchmarking,
   formateo del programa, documentacion y muchas otras tareas, todo dentro de un
   solo comando.

   El capitulo 11 trata de las pruebas, donde Go adopta un enfoque notablemente
   ligero, evitando framewoks cargados de abstraccion en favor de librerias y
   herramientas simples. Las librerias de pruebas proporcionan una base sobre
   la que se pueden construir abstracciones mas complejas si es necesario.

   El capitulo 12 discute la reflexion, la capacidad de un programa para
   examinar su propia representacion durante la ejecucion. La reflexion es una
   herramienta poderosa, aunque debe ser usada con cuidado; Este capitulo
   explica como encontrar el equilibrio correcto, mostrando como se utiliza para
   implementar algunas librerias importantes en Go. El capitulo 13 explica los
   detalles morbosos de programacion a bajo nivel que utiliza el paquete
   @c(unsafe) para dar un paso alrededor del sistema de tipado de Go, y cuando
   es apropiada eso.

   Cada capitulo tiene una serie de ejercicios que puedes usar para probar tu
   comprension de Go, y para explorar extensiones y alternativas a los ejemplos
   del libro.

   Todos menos los ejemplos de codigo mas triviales en el libro estan
   disponibles para su descarga desde un repositorio Git publico en
   @l(http://www.gopl.io/<>gopl.io). Cada ejemplo se identifica por su ruta de
   importacion paquete y puede ser convenientemente localizado, construido e
   instalado utilizando el comando @$(go get). tendra que elegir un directorio
   para ser su espacio de trabajo y establecer la variable de entorno @c(GOPATH)
   apuntando a este. La herramienta @$(go) creara el directorio si es necesario.
   Por ejemplo:

   ..src > sh
     $ export GOPATH=$HOME/gobook        # Elegir el directorio de trabajo
     $ go get gopl.io/ch1/helloworld     # buscar, construir, instalar
     $ $GOPATH/bin/helloworld            # ejecutar
     Hello, 世界
   < src..

   Para ejecutar los ejemplos, necesitara al menos la version 1.5 de Go.

   ..src > sh
     $ go version
     go version go1.5 linux/amd64
   < src..

   Siga las instrucciones en @l(https://golang.org/doc/install) si en su equipo
   la herramienta @$(go) esta ausente o es anterior.

** Donde encontrar mas informacion

   La mejor fuente para obtener mas informacion sobre Go es el sitio web
   oficial, @l(https://golang.org) , que proporciona acceso a la documentacion,
   incluyendo la @e(Especificacion del Lenguaje de Programacion Go), los
   paquetes estandar, y similares. Tambien hay tutoriales sobre como escribir Go
   y como escribirlo bien, y una amplia variedad de recursos de texto y video en
   linea que seran complementos valiosos para este libro. El Blog de Go se
   encuentra en @l(https://blog.golang.org<>blog.golang.org) donde se publican
   algunos de los mejores escritos en Go, con articulos sobre el estado del
   lenguaje, los planes a futuro, los informes sobre conferencias y
   explicaciones en profundidad de una amplia variedad de temas relacionados.

   Uno de los aspectos mas utiles del acceso en linea a Go (y una limitacion
   lamentable de un libro de papel) es la capacidad de ejecutar programas de Go
   desde las paginas web que los describen. Esta funcionalidad es proporcionada
   por Go Playground en @l(https://play.golang.org<>play.golang.org), y puede
   ser embebido dentro de otras paginas, como la pagina de inicio en
   @l(https://golang.org<>golang.org) o las paginas de documentacion provistas
   por la herramienta @$(godoc).

   Playground hace que sea conveniente llevar a cabo experimentos sencillos para
   comprobar la propia comprension de la sintaxis, la semantica, o paquetes de
   librerias con programas cortos, y en muchos sentidos toma el lugar de un
   @e(bucle leer-evaluar-imprimir) (@e(read-eval-print loop) o REPL) en otros
   lenguajes. Sus URLs persistentes son ideales para compartir fragmentos de
   codigo con otros, para informar sobre errores o hacer sugerencias.

   Construido sobre Playground, el Tour Go en @l(https://tour.golang.org<>tour.golang.org)
   es una secuencia de breves lecciones interactivas sobre las ideas basicas y
   construcciones de Go, un paseo ordenado por atraves del lenguaje.

   El principal inconveniente del Playground y del Tour es que permiten que solo
   se importen librerias estandar, y muchas funciones de la libreria–por
   ejemplo, redes–estan restringidas por razones practicas o de
   seguridad. Tambien requiere de acceso a Internet para compilar y ejecutar
   cada programa. Asi que para experimentos mas elaborados, tendra que ejecutar
   programas Go en su propia computadora. Afortunadamente, el proceso de
   descarga es sencillo, por lo que no debe tomar mas de unos minutos para
   buscar la Go distribucion desde @l(https://golang.org<>golang.org) y empezar
   a escribir y ejecutar programas por su cuenta.

   Ya que Go es un proyecto de codigo abierto, se puede leer el codigo fuente de
   cualquier tipo o funcion en la libreria estandar en
   @l(https://golang.org/pkg); el mismo codigo forma parte de la distribucion
   descargada. Utilice esto para averiguar como funciona algo, o para responder
   a preguntas sobre los detalles, o simplemente para ver como los expertos
   escriben bueno Go.

** Agradecimientos

   Rob Pike y Russ Cox, miembros centrales del equipo de Go, leyeron el
   manuscrito varias veces con mucho cuidado; Sus comentarios sobre todo, desde
   la eleccion de palabras hasta la estructura general y la organizacion han
   sido invaluables. Mientras preparaba la traduccion japonesa, Yoshiki Shibata
   iba mucho mas alla del llamado del deber; Su ojo meticuloso observo numerosas
   inconsistencias en el texto ingles y errores en el codigo. Apreciamos
   grandemente revisiones completas y comentarios criticos en el manuscrito
   entero de Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, y
   Peter Weinberger.

   Agradecemos a Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue,
   Jonathan Feinberg, Andrew Gerrand, Roberto Griesemer, John Linderman, Minux
   Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao,
   y a Howard Trickey para muchas sugerencias utiles. Tambien damos las gracias
   a David Brailsford y Raph Levien por los consejos sobre composicion
   tipografica.

   Nuestro redactor Greg Doench de Addison-Wesley consiguio hacer rodar la bola
   originalmente y ha estado ayunando continuamente desde entonces. El equipo de
   produccion de AW–John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith y
   Barbara Wood–ha sido excepcional; Los autores no podrian esperar un mejor
   apoyo.

   Alan Donovan desea agradecer a: Sameer Ajmani, Chris Demetriou, Walt
   Drummond, y Reid Tatge en Google por permitirle tiempo para escribir; Stephen
   Donovan, por su consejo y oportuno estimulo; Y sobre todo a su esposa Leila
   Kazemi, por su entusiasmo y apoyo inquebrantable a este proyecto, a pesar de
   las largas horas de distraccion y ausentismo de la vida familiar que ello
   conllevaba.

   Brian Kernighan esta profundamente agradecido a sus amigos y colegas por su
   paciencia y autodominio mientras avanzaba lentamente por el camino hacia la
   comprension, y especialmente a su esposa Meg, que ha sido infaliblemente
   favorable a la escritura de libros y mucho mas.

   ..quote >
     --Nueva York
     --Octubre 2015
   < quote..

* Capitulo 1 <> Tutorial

  Este capitulo es un recorrido por los componentes basicos de Go. Esperamos
  proporcionar suficiente informacion y ejemplos para sacarle del barro y hacer
  cosas utiles lo mas rapido posible. Los ejemplos aqui, y de hecho en todo el
  libro, estan dirigidos a tareas que usted podria tener que hacer en el mundo
  real. En este capitulo intentaremos darle una muestra de la diversidad de
  programas que uno podria escribir en Go, que van desde el simple procesamiento
  de archivos y un poco de graficos, a clientes y servidores de Internet
  concurrentes. Ciertamente no vamos a explicar todo en el primer capitulo, pero
  el estudio de estos programas en un nuevo lenguaje puede ser una manera eficaz
  de empezar.

  Cuando estas aprendiendo un nuevo lenguaje, hay una tendencia natural a
  escribir codigo como lo habrias escrito en un idioma que ya conoces. Este
  consciente de este sesgo a medida que aprende Go y trate de evitarlo. Hemos
  tratado de ilustrar y explicar como escribir buen Go, asi que utilice el
  codigo aqui como guia cuando este escribiendo el suyo propio.

** Seccion 1.1 <> Hola, Mundo

   Vamos a empezar con la ya tradicional ejemplo del @"(hola, mundo), que
   aparece al comienzo de @e(El lenguaje de programacion C), publicado
   en 1978. C es una de las influencias mas directas sobre el Go, y @"(hola,
   mundo) ilustra una serie de ideas centrales.

   ..figure > @l(gopl.io/ch1/helloworld/main.go<>gopl.io/ch1/helloworld)

     ..src > go
       package main

       import "fmt"

       func main() {
         fmt.Println("Hello, 世界")
       }
     < src..

   Go es un lenguaje compilado. El conjunto de herramienta de Go convierte un el
   codigo fuente de un programa y las cosas de las que depende, en instrucciones
   en el lenguaje maquina nativo de una computadora. Se puede acceder a estas
   herramientas a traves de un unico comando llamado @$(go) que tiene una serie
   de subcomandos. El mas simple de estos subcomandos es @$(run) , que compila
   el codigo fuente de uno o mas archivos de origen cuyos nombres terminan en
   @f(.go), lo vincula con las librerias, y a continuacion, ejecuta el archivo
   ejecutable resultante. (Utilizaremos @$($) como el simbolo del sistema en
   todo el libro.)

   ..src > sh
     $ go run helloworld.go
   < src..

   No es sorprendente que esto imprima

   ..src > sh
     Hello, 世界
   < src..


   Go maneja Unicode de forma nativa, por lo que puede procesar texto en todos
   los idiomas del mundo.

   Si el programa es mas que un experimento de un solo disparo, es probable que
   quiera compilarlo una vez y guardar el resultado compilado para su uso
   posterior. Esto se hace con @$(go build):

   ..src > sh
     $ go build helloworld.go
   < src..

   Esto crea un archivo binario ejecutable llamado @$(helloworld) que se pueden
   ejecutar en cualquier momento sin procesamiento adicional:

   ..src > sh
     $ ./helloworld
     Hello, 世界
   < src..

   Hemos etiquetado cada ejemplo significativo como un recordatorio de que
   puede obtener el codigo fuente del libro desde el repositorio en
   @l(http://www.gopl.io/<>(gopl.io): @l(http://www.gopl.io/ch1/helloworld<>gopl.io/ch1/helloworld)

   Si ejecuta @$(go get gopl.io/ch1/helloworld), se obtendra el codigo fuente y
   lo coloca en el directorio correspondiente. Hay mas informacion sobre este
   tema en la @l(#Seccion 2.6) y la @l(#Seccion 10.7).

   Hablemos ahora del programa en si. El codigo Go esta organizado en paquetes,
   que son similares a librerias o modulos en otros lenguajes. Un paquete se
   compone de uno o mas archivos de codigo @f(.go) en un unico directorio que
   definen lo que hace el paquete. Cada archivo de codigo inicia con una
   declaracion del paquete, aqui es @c(package main), que declara a que paquete
   pertenece el archivo, seguido de una lista de otros paquetes que importa, y
   luego las declaraciones del programa que se almacena en el archivo.

   La libreria estandar de Go tiene mas de 100 paquetes para tareas comunes como
   entrada y salida, clasificacion y manipulacion de texto. Por ejemplo, el
   paquete @c(fmt) contiene funciones para la impresion y entrada de datos con
   formato. @c(Println) es una de las funciones de basicas de salida en @c(fmt);
   esta imprime uno o mas valores, separados por espacios, con un caracter de
   nueva linea al final para que los valores aparezcan como una sola linea de
   salida.

   El paquete @c(main) es especial. Define un programa ejecutable independiente,
   no una libreria. Dentro del paquete @c(main) la @e(funcion) @c(main) tambien
   es especial–es donde comienza la ejecucion del programa. Cualquier cosa que
   haga @c(main) es lo que hara el programa. Por supuesto, @c(main) sera
   normalmente un llamado a las funciones de otros paquetes que hacen gran parte
   del trabajo, tales como la funcion @c(fmt.Println).

   Debemos decirle al compilador que paquetes son necesarios por este archivo de
   codigo fuente; ese es el papel de la declaracion @c(import) seguida por la
   declaracion del @c(paquete). El programa @"(hola, mundial) utiliza solo una
   funcion de otro paquete, pero en la mayoria de los programas se importaran
   mas paquetes.

   Debe importar exactamente los paquetes que necesita. Un programa no compilara
   si hay importaciones que faltan o si son innecesarias. Este estricto
   requisito impide que las referencias a paquetes no utilizados se acumulen a
   medida que los programas evolucionan.

   Las declaraciones @c(import) deben ir luego de la declaracion
   @c(package). Despues de eso, un programa consiste en la declaracion de
   funciones, variables, constantes y tipos (introducidos por las palabras clave
   @c(func), @c(var), @c(const), y @c(type)); En su mayor parte, el orden de las
   declaraciones no importa. Este programa es lo mas corto posible, ya que
   declara solo una funcion, que a su vez solo llama a otra funcion. Para
   ahorrar espacio en la presentacion de ejemplos, a veces no mostramos las
   declaraciones @c(package) e @c(import), pero estaran en el codigo del archivo
   y debemos estar alli para compilar el codigo.

   Una declaracion de funcion consiste en la palabra clave @c(func), el nombre
   de la funcion, una lista de parametros (vacia para @c(main)), una lista de
   resultados (aqui tambien vacia), y el cuerpo de la funcion–las declaraciones
   que definen lo que hace–encerradas entre llaves. Vamos a echar un vistazo mas
   de cerca a las funciones en el @l(#Capitulo 5).

   Go no requiere punto y coma al final de las sentencias o declaraciones,
   excepto donde aparecen dos o mas en la misma linea. En efecto, las nuevas
   lineas que siguen ciertas palabras se convierten en punto y coma, por lo que
   cuando se colocan nuevas lineas se colocan en funcion del correcto analisis
   del codigo Go. Por ejemplo, la llave de apertura @c({) de la funcion, debe
   estar en la misma linea, que el final de la declaracion @c(func), no en una
   linea distinta, y en la expresion @c(x + y), se permite un salto de linea
   despues, pero no antes del operador @c(+).

   Go toma una fuerte postura en el formato del codigo. La herramienta @$(gofmt)
   reescribe el codigo en el formato estandar, y el subcomando @$(fmt) de la
   herramienta @$(go) aplica @$(gofmt) a todos los archivos en el paquete
   especificado, o por defecto, a los que estan en el directorio actual.  Se ha
   ejecutado @$(gofmt) sobre todos los archivos de codigo fuente en el libro, y
   usted debe optener el habito de hacer lo mismo con su propio codigo. Declarar
   un formato estandar por mandato elimina un monton de debate inutil sobre
   trivialidades y, lo que es mas importante, permite una variedad de
   transformaciones automatizadas de codigo fuente que serian imposibles si se
   permitiera el formato arbitrario.

   Muchos editores de texto pueden ser configurados para ejecutar @$(gofmt) cada
   vez que se guarda un archivo, por lo que su codigo fuente siempre tendra el
   formato apropiado. Una herramienta relacionada, @$(goimports) , ademas,
   gestiona la insercion y extraccion de las declaraciones de importacion, segun
   sea necesario. No es parte de la distribucion estandar pero se puede obtener
   con este comando:

   ..src > sh
     $ go get golang.org/x/tools/cmd/goimports
   < src..

   Para la mayoria de los usuarios, la forma habitual de descargar y construir
   paquetes, ejecutar pruebas, mostrar su documentacion, y asi sucesivamente, es
   con la herramienta @$(go), que vamos a ver en la @l(#Seccion 10.7).

** Seccion 1.2 <> Argumentos de la linea de comandos

   La mayoria de los programas procesan alguna entrada para producir alguna
   salida; Que es mas o menos la definicion de la computacion. Pero, ¿como un
   programa obtiene datos de entrada para operar? Algunos programas generan sus
   propios datos, pero mas a menudo, la entrada proviene de una fuente externa:
   un archivo, una conexion de red, la salida de otro programa, un usuario en un
   teclado, argumentos de linea de comandos o similares. Los siguientes ejemplos
   discutiran algunas de estas alternativas, comenzando con argumentos de linea
   de comandos.

   El paquete @c(os) proporciona funciones y otros valores para relacionarse con
   el sistema operativo de una manera independiente de la plataforma. Los
   argumentos de linea de comandos estan disponibles para un programa en una
   variable denominada @c(Args) que forma parte del paquete @c(os); por lo tanto
   su nombre en cualquier lugar fuera del paquete @c(os) es @c(os.Args).

   Las variables @c(os.Args) es una @e(slice) de strings. Los slices son una
   nocion fundamental en Go, y hablaremos mucho mas sobre ellos pronto. Por
   ahora, piensa en un slice como una secuencia @c(s) de elementos de un arreglo
   de tamaño dinamico, donde los elementos individuales pueden accederse como
   @c(s[i]) y una subsecuencia contigua como @c(s[m:n]). El numero de elementos esta
   dado por @c[len(s)]. Como en la la mayoria de los otros lenguajes de
   programacion, toda  indexacion en Go utiliza intervalos @e(semiabiertos)
   que incluyen el primer indice, pero no incluyen el ultimo, ya que simplifica
   la logica. Por ejemplo, el slice  @c(s[m:n]), donde @c[0 ≤ m ≤ n ≤ len(s)],
   contiene @c(n-m) elementos.

   El primer elemento de @c(os.Args), @c(os.Args[0]), es el nombre del comando
   en si; Los otros elementos son los argumentos que se ofresieron al programa
   cuando se inicio la ejecucion. Una expresion de la forma @c(s[m:n]) produce
   un slice que hace referencia a los elementos entre @c(m) y @c(n-1), por lo
   que los elementos que necesitamos para nuestro siguiente ejemplo corresponden
   al slice @c{os.Args[1:len(os.Args)]}. Si @c(m) o @c(n) se omite, el valor
   predeterminado es 0 o @c[len(s)], respectivamente, por lo que se puede
   abreviar el slice deseado como @c(os.Args[1:]).

   Aqui esta una implementacion del comando @$(echo) de Unix, que imprime sus
   argumentos de linea de comandos en una sola linea. Importa dos paquetes, que
   se dan como una lista entre parentesis en lugar de como declaraciones de
   importacion individuales. Cualquiera de las formas es legal, pero
   convencionalmente se utiliza el formato de lista. El orden de las
   importaciones no importa; la herramienta @$(gofmt) ordena los nombres de los
   paquetes en orden alfabetico. (Cuando hay varias versiones de un ejemplo, a
   menudo las numeraremos para que pueda estar seguro de cual estamos hablando.)

   ..figure > @l(gopl.io/ch1/echo1/main.go<>gopl.io/ch1/echo1)

     ..src > go
       // Echo1 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         var s, sep string
         for i := 1; i < len(os.Args); i++ {
           s += sep + os.Args[i]
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


   Los comentarios comienzan con @c(//). Todo el texto desde @c(//) hasta el
   final de la linea es el comentario para los programadores y es ignorado por
   el compilador. Por convencion, describimos cada paquete en un comentario
   inmediatamente anterior a su declaracion del paquete; para un paquete
   @c(main), este comentario es una o varias frases completas que describen el
   programa en su conjunto.

   La declaracion @c(var) declara dos variables @c(s) y @c(sep), de tipo
   @c(string). Una variable se puede inicializar como parte de su
   declaracion. Si no se inicia de forma explicita, se inicializa de forma
   implicita al @e(valor cero) para su tipo, que es 0 para los tipos numericos y
   la cadena vacia "" para strings. Asi, en este ejemplo, la declaracion
   implicita inicializa @c(s) y @c(sep) como cadenas vacias. Tendremos mas que
   decir acerca de las variables y las declaraciones en el @l(#Capitulo 2).

   Para los numeros, Go proporciona los operadores aritmeticos y logicos
   habituales. Cuando se aplica a las cadenas, sin embargo, el operador @c(+)
   @e(concatena) los valores, por lo que la expresion

   ..src > go
     sep + os.Args[i]
   < src..

   representa la concatenacion de las cadenas @c(sep) y @c(os.Args[i]) . La
   declaracion que usamos en el programa,

   ..src > go
     s += sep + os.Args[i]
   < src..

   es una @e(sencencia de asignacion) que concatena el antiguo valor de @c(s) con @c(sep)
   y @c(os.Args[i]) y lo asigna de nuevo a @c(s); Es equivalente a

   ..src > go
     s = s + sep + os.Args[i]
   < src..

   El operador @c(+=) es un operador de asignacion. Cada operador aritmetico y
   logico como @c(+) o @c(*) tiene un operador de asignacion correspondiente.

   El programa @$(echo) podria haber impreso su salida en un bucle de una sola
   pieza a la vez, pero en esta version, en su lugar se acumula una cadena
   añadiendo repetidamente nuevo texto hasta el final. La cadena de @c(s)
   comienza su vida vacia, es decir, con el valor "", y cada ciclo a traves del
   bucle añade un poco de texto a ella; Despues de la primera iteracion, tambien
   se inserta un espacio para que cuando el bucle este terminado, haya un
   espacio entre cada argumento. Este es un proceso cuadratico que podria ser
   costoso si el numero de argumentos es grande, pero para @$(echo), eso es poco
   probable. Vamos a mostrar una serie de versiones mejoradas de @$(echo) en
   este capitulo y el siguiente para hacer frente a cualquier ineficiencia real.

   El indice variable @c(i) de bucle se declara en la primera parte del bucle
   @c(for). El @c(:=) simbolo es parte de una @e(declaracion de variables
   compacta), una sentencia que declara una o mas variables y les da los tipos
   apropiados basados en los valores del inicializador; Hay mas informacion al
   respecto en el proximo capitulo.

   La declaracion de incremento @c(i++) añade 1 a @c(i); que es equivalente a
   @c(i += 1), que es a su vez equivalente a @c(i = i + 1). Hay una declaracion
   de decremento correspondiente @c(i--) que resta 1. Estas son declaraciones,
   no expresiones como lo son en la mayoria de los lenguajes en la familia C,
   por lo que @c(j = i++) es ilegal, y solamente son de sufijo, asi @c(--i)
   tampoco es legal.

   El bucle @c(for) es la unica sentencia de bucle en Go. Tiene una serie de formas,
   una de las cuales se ilustra aqui:

   ..src > go
     for inicializacion; condicion; incremento {
         // zero or more statements
     }
   < src..

   Los parentesis no se utilizan nunca alrededor de los tres componentes de un
   bucle @c(for). Las llaves son obligatorios, sin embargo, y la llave de apertura
   deben estar en la misma linea que la declaracion @c(incremento).

   La declaracion opcional @c(inicializacion) se ejecuta antes de que comience
   el bucle. Si esta presente, debe ser una simple declaracion, es decir, una
   declaracion de variables compacta, una declaracion de incremento o asignacion, o
   una llamada a funcion. La @c(condition) es una expresion booleana que se
   evalua en al inicio de cada iteracion del bucle; si se evalua como @c(true),
   las declaraciones controladas por el bucle se ejecutan. La declaracion
   @c(incremento) se ejecuta despues del cuerpo del bucle, luego la
   @c(condicion) se evalua de nuevo. El bucle termina cuando la condicion se
   convierte en falsa.

   Cualquiera de estas partes puede omitirse. Si no hay @c(inicializacion) y
   ningun @c(incremento), el punto y coma tambien pueden omitirse:

   ..src > go
     // un tradicional bucle "while"
     for condicion {
         // ...
     }
   < src..

   Si la condicion se omite totalmente en cualquiera de estas formas, por
   ejemplo en

   ..src > go
     // un tradicional bucle infinito
     for {
         // ...
     }
   < src..

   el bucle es infinito, aunque los bucles de esta forma se pueden terminar de
   alguna otra forma, como una declaracion @c(break) o @c(return).

   Otra forma en que el bucle @c(for) itera, es sobre un @e(rango) de valores de
   un tipo de datos como un string o un slice. Para ilustrar esto, he aqui una
   segunda version de @$(echo):

   ..figure > @l(gopl.io/ch1/echo2/main.go<>gopl.io/ch1/echo2)

     ..src > go
       // Echo2 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         s, sep := "", ""
         for _, arg := range os.Args[1:] {
           s += sep + arg
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


   En cada iteracion del bucle, @c(range) produce un par de valores: el indice y
   el valor del elemento en ese indice. En este ejemplo, no necesitamos el
   indice, pero la sintaxis de un bucle @c(range) requiere que si tratamos con
   el elemento, debemos tratar tambien con el indice. Una idea seria asignar el
   indice a una variable temporal, como @c(temp) y pasar por alto su valor, pero
   Go no permite tener variables locales sin utilizar, por lo que esto daria
   lugar a un error de compilacion.

   La solucion es utilizar el @e(identificador en blanco), cuyo nombre es @c(_)
   (esto es, un guion bajo). El identificador en blanco puede utilizarse siempre
   que la sintaxis requiera un nombre de variable, pero la logica del programa
   no lo haga, por ejemplo para descartar un indice no deseado del bucle cuando
   solo necesitamos el valor del elemento. La mayoria de los programadores Go
   probablemente usarian @c(range) y @c(_) para escribir el programa @$(echo)
   anterior, ya que la indexacion sobre @c(os.Args) es implicita, no explicita,
   y por lo tanto mas facil de hacerlo bien.

   Esta version del programa utiliza una breve declaracion de variables para
   declarar e inicializar @c(s) y @c(sep), pero podria igualmente haber declarado las
   variables por separado. Hay varias maneras de declarar una variable de
   cadena; Todas estas son equivalentes:

   ..src > go
     s := ""
     var s string
     var s = ""
     var s string = ""
   < src..

   Por que usted deberia preferir una forma sobre otra? El primer formato, una
   declaracion de variable compacta, es el mas compacto, pero puede ser utilizado
   solo dentro de una funcion, no para variables de nivel de paquete. La segunda
   forma se basa en la inicializacion por defecto al valor cero para strings,
   que es @c("") . La tercera forma se utiliza raramente excepto cuando se
   declaran multiples variables. La cuarta forma es explicita sobre el tipo de
   la variable, que es redundante cuando es el mismo que el del valor inicial
   pero necesario en otros casos donde no son del mismo tipo. En la practica,
   generalmente debe utilizar una de las dos primeras formas, con inicializacion
   explicita para decir que el valor inicial es importante e implicita para
   decir que el valor inicial no importa.

   Como se señalo anteriormente, cada iteracion alrededor del bucle, la cadena
   @c(s) obtiene contenidos completamente nuevos. La declaracion @c(+=) crea una
   nueva cadena mediante la concatenacion de la cadena antigua, un caracter de
   espacio, y el siguiente argumento, a continuacion, asigna la nueva cadena a
   @c(s). El contenido antiguo del @c(s) ya no estan en uso, por lo que sera
   recolectado por el recolector de basura en su debido momento.

   Si la cantidad de datos involucrados es grande, esto podria ser costoso. Una
   solucion mas simple y mas eficiente seria utilizar la funcion @c(Join) del
   paquete @c(strings):

   ..figure > @l(gopl.io/ch1/echo3/main.go<>gopl.io/ch1/echo3)

     ..src > go
       func main() {
         fmt.Println(strings.Join(os.Args[1:], " "))
       }
     < src..


   Por ultimo, si no nos interesa el formato, pero solo queremos ver los
   valores, tal vez para depurar, podemos dejar que @c(Println) formatee el
   resultado por nosotros:

   ..src > go
     fmt.Println(os.Args[1:])
   < src..

   El resultado de esta sentencia es como la que se pueden conseguir mediante
   @c(strings.Join), pero con corchetes al rededor. Cualquier slice se puede
   imprimir de esta manera.

   @b(Ejercicio 1.1): Modificar el programa @$(echo) para imprimir tambien
   @c(os.Args[0]), el nombre del comando que lo invoco.

   @b(Ejercicio 1.2): Modificar el programa @$(echo) para imprimir el indice y el
   valor de cada uno de sus argumentos, uno por linea.

   @b(Ejercicio 1.3): Experimento para medir la diferencia en el tiempo de
   funcionamiento entre nuestras versiones potencialmente ineficientes y el que
   utiliza @c(strings.Join). ( La @l(#Seccion 1.6) ilustra parte del paquete
   @c(time), y la @l(#Seccion 11.4) muestra como escribir pruebas de referencia
   para la evaluacion sistematica del rendimiento.)

** Seccion 1.3 <> Encontrar lineas duplicadas

   Los programas para copiar archivos, imprimir, buscar, clasificar, contar y
   similares tienen una estructura similar: un bucle sobre la entrada, algun
   calculo sobre cada elemento y generacion de salida al vuelo o al
   final. Mostraremos tres variantes de un programa llamado @$(dup); se inspira
   en parte por el comando Unix @$(uniq), que mira las lineas duplicadas
   adyacentes. Las estructuras y paquetes utilizados son modelos que se pueden
   adaptar facilmente.

   La primer version del @$(dup) imprime cada linea que aparece mas de una vez en
   la entrada estandar, precedido por su recuento. Este programa presenta la declaracion
   @c(if), el  tipo de datos @c(map) y el paquete @c(bufio).

   ..figure > @l(gopl.io/ch1/dup1/main.go<>gopl.io/ch1/dup1)

     ..src > go
       // Dup1 imprime el texto de cada linea que aparece mas de
       // una vez en la entrada estandar, precedida por su recuento.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         input := bufio.NewScanner(os.Stdin)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTA: ignorando posibles errores de input.Err ()
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


   Al igual que con @c(for), nunca se usan parentesis alrededor de la
   declaracion de la condicion @c(if), pero se requieren llaves para el
   cuerpo. Puede haber una parte @c(else) opcional que se ejecute si la
   condicion es falsa.

   Un @e(mapa) contiene un conjunto de pares clave/valor y proporciona
   operaciones de tiempo constante para almacenar, recuperar, o comprobar un
   elemento en el conjunto. La clave puede ser de cualquier tipo cuyos valores
   puedan compararse con @c(==), siendo strings el ejemplo mas comun; El valor
   puede ser de cualquier tipo en absoluto. En este ejemplo, las claves son
   @c(string)s, y los valores son @c(int)s. La funcion incorporada @c(make) crea
   un nuevo mapa vacio; Tiene otros usos tambien. Los mapas se discuten
   extensamente en la @l(#Seccion 4.3).

   Cada vez @$(dup) lee una linea de entrada, la linea se utiliza como una clave
   en el mapa y se incrementa el valor correspondiente. La declaracion
   @c{counts[input.Text()]++} es equivalente a estas dos afirmaciones:

   ..src > go
     line := input.Text()
     counts[line] = counts[line] + 1
   < src..

   No es un problema, si el mapa aun no contiene esa clave. La primera vez que
   se ve una nueva linea, la expresion @c(counts[line]) en el lado derecho se
   evalua al valor cero para su tipo, que es 0 para @c(int).

   Para imprimir los resultados, utilizamos otro bucle de repeticion @c(for)
   basado en @c(range), esta vez sobre el mapa @c(counts). Como antes, cada
   iteracion produce dos resultados, una clave y el valor del elemento del mapa
   para esa clave. El orden de la iteracion del mapa no es especifico, en la
   practica es aleatorio, variando de una ejecucion a otra. Este diseño es
   intencional, ya que impide que los programas se basen en cualquier orden
   particular donde no se garantiza ninguno.

   El paquete @c(bufio), ayuda a que la entrada y salida sea eficiente y
   conveniente. Una de sus caracteristicas mas utiles es un tipo llamado
   @c(Scanner) que lee la entrada y la rompe en lineas o palabras; A menudo es
   la manera mas facil de procesar la entrada que llega naturalmente en lineas.

   El programa utiliza una breve declaracion de variables para crear una nueva
   variable de entrada que hace referencia a @c(bufio.Scanner):

   ..src > go
     input := bufio.NewScanner(os.Stdin)
   < src..

   El escaner lee de la entrada estandar del programa. Cada llamada a
   @c[input.Scan()] lee la siguiente linea y elimina el caracter de nueva linea
   al final; el resultado puede ser recuperado llamando a @c[input.Text()]. La
   funcion @c(Scan) devuelve @c(true) si hay una linea y @c(false) cuando no hay
   mas entrada.

   La funcion @c(fmt.Printf), como @c(printf) en C y otros lenguajes, produce
   una salida con formato de una lista de expresiones. Su primer argumento es
   una cadena de formato que especifica como deben formatearse los argumentos
   posteriores. El formato de cada argumento esta determinado por un caracter de
   conversion, una letra siguiendo un signo de porcentaje. Por ejemplo, @c(%d)
   formatea un operando entero usando la notacion decimal, y @c(%s) se expande
   para el valor de un operando de cadena.

   @c(Printf) tiene mas de una docena de estas conversiones, que los
   programadores de Go llaman @e(verbos). Esta tabla esta lejos de ser una
   especificacion completa, pero ilustra muchas de las caracteristicas que estan
   disponibles:

   | @c(%d)                 | entero decimal                                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%x), @c(%o), @c(%b) | entero en hexadecimal, octal, binario                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%f), @c(%g), @c(%e) | numero de coma flotante: 3.141593 3.141592653589793 3.141593e + 00 |
   |------------------------|--------------------------------------------------------------------|
   | @c(%t)                 | booleano: @c(true) o @c(false)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%c)                 | runa (punto de codigo Unicode)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%s)                 | string                                                             |
   |------------------------|--------------------------------------------------------------------|
   | @c(%q)                 | citar string @c("abc") o runa @c('c')                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%v)                 | cualquier valor en un formato natural                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%T)                 | cualquier tipo de valor                                            |
   |------------------------|--------------------------------------------------------------------|
   | @c(%%)                 | signo literal de porcentaje (sin operando)                         |

   El formato de cadena en @c(dup1) tambien contiene una tabulacion @c(\t) y un
   salto de linea @c(\n). Los literales de cadena pueden contener tales
   @e(secuencias de escape) para la representacion de caracteres de otra manera
   invisibles. @c(Printf) no escribe una nueva linea por defecto. Por
   convencion, las funciones de formato cuyos nombres terminan en f, tales como
   @c(log.Printf) y @c(fmt.Errorf), utilizan las reglas de formato de
   @c(fmt.Printf), mientras que aquellas cuyos nombres terminan en @c(ln) como
   @c(Println), formatean sus argumentos con %v, seguido por una nueva linea.

   Muchos programas leen ya sea a partir de su entrada estandar, como
   anteriormente, o de una secuencia de archivos con nombre. La proxima version
   de @$(dup) puede leer desde la entrada estandar o manejar una lista de
   nombres de archivos, utilizando @c(os.Open) para abrir cada uno de ellos:

   ..figure > @l(gopl.io/ch1/dup2/main.go<>gopl.io/ch1/dup2)

     ..src > go
       // Dup2 imprime el recuento y el texto de las lineas que aparecen mas de una vez
       // en la entrada.  Se lee desde stdin o desde una lista de archivos con nombre.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         files := os.Args[1:]
         if len(files) == 0 {
           countLines(os.Stdin, counts)
         } else {
           for _, arg := range files {
             f, err := os.Open(arg)
             if err != nil {
               fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
               continue
             }
             countLines(f, counts)
             f.Close()
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }

       func countLines(f *os.File, counts map[string]int) {
         input := bufio.NewScanner(f)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTE: Ignora errores potenciales de input.Err()
       }
     < src..


   La funcion @c(os.Open) devuelve dos valores. El primero es un archivo abierto
   (@c(*os.File)) que se utiliza en lecturas posteriores por @c(Scanner).

   El segundo resultado de @c(os.Open) es un valor nativo de tipo @c(error). Si
   @c(err) es igual al valor especial nativo @c(nil), el archivo fue abierto
   correctamente. El archivo se lee, y cuando se llega al final de la entrada,
   @c(Close) cierra el archivo y libera cualquier recurso. Por otro lado, si
   @c(err) no es @c(nil), algo salio mal. En ese caso, el valor de error
   describe el problema. Nuestra sencillo manejo de errores imprime un mensaje
   en el flujo de error estandar utilizando @c(Fprintf) y el verbo @c(%v), que
   muestra un valor de cualquier tipo en un formato predeterminado, y luego
   @c(dup) continua con el siguiente archivo; la instruccion @c(continue) va a
   la siguiente iteracion del bucle @c(for).

   Con el fin de mantener los ejemplos de codigo de un tamaño razonable,
   nuestros primeros ejemplos son intencionalmente un tanto descuidados en el
   manejo de errores. Es evidente que hay que comprobar si hay un error de parte
   de @c(os.Open); Sin embargo, estamos ignorando la menos probable posibilidad
   de que pueda producirse un error al leer el archivo con @c(input.Scan).
   Anotaremos los lugares donde hemos omitido la comprobacion de errores,
   entraremos en detalles sobre el manejo de errores en la @l(#Seccion 5.4).

   Observe que la llamada a @c(countLines) precede a su declaracion. Las
   funciones y otras entidades a nivel de paquete se pueden declarar en
   cualquier orden.

   Un mapa es una referencia a la estructura de datos creada por @c(make).
   Cuando un mapa se pasa a una funcion, la funcion recibe una copia de la
   referencia, De modo que cualquier cambio que haga la funcion llamada en la
   estructura de datos subyacente, sera tambien visible a traves de la
   referencia del mapa del llamador. En nuestro ejemplo, los valores insertados
   en el mapa @c(counts) por @c(countLines) son vistos por @c(main).

   Las versiones anteriores de @$(dup) operan en un modo @"(streaming) en el que
   la entrada se lee y divide en lineas segun sea necesario, por lo que, en
   principio, estos programas pueden manejar una cantidad arbitraria de
   entrada. Un enfoque alternativo es leer la entrada entera en la memoria de un
   solo trago, dividirlo en lineas a la vez, y luego procesar las lineas. La
   siguiente version, @$(dup3), funciona de esa manera. Se introduce la funcion
   @c(ReadFile) (del paquete @c(io/ioutil)), que lee todo el contenido de un
   archivo, y @c(strings.Split), que divide una cadena en una slice de
   subcadenas. ( @c(Split) es lo contrario de @c(strings.Join), que vimos
   anteriormente.)

   Hemos simplificado un poco @$(dup3). En primer lugar, solo lee archivos por
   su nombre, no la entrada estandar, ya que @c(ReadFile) requiere como
   argumento un nombre de archivo. En segundo lugar, se paso el conteo de las
   lineas de nuevo a @c(main), ya que ahora solo es necesario un solo lugar.

   ..figure > @l(gopl.io/ch1/dup3/main.go<>gopl.io/ch1/dup3)

     ..src > go
       package main

       import (
         "fmt"
         "io/ioutil"
         "os"
         "strings"
       )

       func main() {
         counts := make(map[string]int)
         for _, filename := range os.Args[1:] {
           data, err := ioutil.ReadFile(filename)
           if err != nil {
             fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
             continue
           }
           for _, line := range strings.Split(string(data), "\n") {
             counts[line]++
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


   @c(ReadFile) devuelve un slice de @c(byte)s que se debe convertirse en un
   @c(string) para que pueda ser dividido por @c(strings.Split). Vamos a
   discutir los strings y slices de bytes en detalle en la @l(#Seccion 3.5.4).

   Bajo la cubierta, @c(bufio.Scanner), @c(ioutil.ReadFile) y
   @c(ioutil.WriteFile) utilizan los metodos @c(Read) y @c(Write) de
   @c(*os.File), pero es raro que la mayoria de los programadores necesiten
   acceder directamente a las rutinas de bajo nivel. Las funciones de nivel
   superior como @c(bufio) y @c(io/ioutil) son mas faciles de usar.

   @b(Ejercicio 1.4): Modificar @$(dup2) para imprimir los nombres de todos los
   archivos en los que se produce cada linea duplicada.

** Seccion 1.4 <> GIF animados

   El siguiente programa demuestra el uso basico de los paquetes de imagenes
   estandar en Go, que usaremos para crear una secuencia de imagenes de mapa de
   bits y luego codificar la secuencia como una animacion GIF. Las imagenes,
   llamadas @e(figuras de Lissajous), eran un efecto visual basico en peliculas
   de ciencia ficcion de la decada de 1960. Son las curvas parametricas
   producidas por oscilacion armonica en dos dimensiones, tales como dos ondas
   sinusoidales alimentados en el entradas @m(x) e @m(y) de un osciloscopio. La
   Figura 1.1 muestra algunos ejemplos.

   ..figure > Figura 1.1. Cuatro figuras de Lissajous.

     ..img > img/Figure-1.1.jpg


     Hay varias nuevas construcciones en este codigo, incluyendo declaraciones
     const, tipos de estructura, y literales compuestos. A diferencia de la
     mayoria de nuestros ejemplos, este tambien implica calculos de punto
     flotante.  Aqui vamos a discutir estos temas solo brevemente, desplazando
     la mayoria de los detalles a los capitulos posteriores, ya que el objetivo
     principal en este momento es darle una idea de como se ve Go y el tipo de
     cosas que se pueden hacer facilmente con el lenguaje y sus librerias.

   ..figure > @l(gopl.io/ch1/lissajous/main.go<>gopl.io/ch1/lissajous)

     ..src > go
       // Lissajous genera GIF animados de figuras Lissajous aleatorias.
       package main

       import (
         "image"
         "image/color"
         "image/gif"
         "io"
         "math"
         "math/rand"
         "os"
       )

       var palette = []color.Color{color.White, color.Black}

       const (
         whiteIndex = 0 // primer color en la paleta
         blackIndex = 1 // siguiente color en la paleta
       )

       func main() {
         lissajous(os.Stdout)
       }

       func lissajous(out io.Writer) {
         const (
           cycles  = 5     // numero de revoluciones completas del oscilador x
           res     = 0.001 // resolucion angular
           size    = 100   // dimencion de la imagen [-size..+size]
           nframes = 64    // numero de cuadros de animacion
           delay   = 8     // retardo entre fotogramas en unidades de 10ms
         )
         freq := rand.Float64() * 3.0 // frecuencia relativa del oscilador y
         anim := gif.GIF{LoopCount: nframes}
         phase := 0.0 // diferencia de fase
         for i := 0; i < nframes; i++ {
           rect := image.Rect(0, 0, 2*size+1, 2*size+1)
           img := image.NewPaletted(rect, palette)
           for t := 0.0; t < cycles*2*math.Pi; t += res {
             x := math.Sin(t)
             y := math.Sin(t*freq + phase)
             img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
               blackIndex)
           }
           phase += 0.1
           anim.Delay = append(anim.Delay, delay)
           anim.Image = append(anim.Image, img)
         }
         gif.EncodeAll(out, &anim) // NOTA: Ignorados errores de codificacion
       }
     < src..


   Despues de importar un paquete cuya ruta tiene multiples componentes, como
   @c(image/color), nos referimos al paquete con el nombre que procede del
   ultimo componente. Por lo tanto la variable @c(color.White) pertenece al
   paquete @c(image/color) y @c(gif.GIF) pertenece a @c(image/gif).

   Una declaracion @c(const) (@l(#Seccion 3.6<>§3.6)) da nombres a las
   constantes, es decir, valores que se establecen en tiempo de compilacion,
   tales como los parametros numericos para ciclos, cuadros, y el retardo. Igual
   a las declaraciones @c(var), las declaraciones @c(const) pueden aparecer a
   nivel de paquete (por lo que los nombres son visibles en todo el paquete) o
   dentro de una funcion (por lo que los nombres son visibles solo dentro de esa
   funcion). El valor de una constante debe ser un numero, una cadena o un
   booleano.

   Las expresiones @c([]color.Color{...}) y @c(gif.GIF{...}) son @e(literales
   compuestos) (@l(#Seccion 4.2<>§4.2), @l(#Seccion 4.4.1<>§4.4.1)), una
   notacion compacta de Go para instanciar cualquiera de los tipos compuestos de
   una secuencia de valores de los elementos. Aqui, la primera es un slice y
   la segunda es una @e(estructura).

   El tipo @c(gif.GIF) es de tipo struct (@l(#Seccion 4.4<>§4.4)). Una
   estructura es un grupo de valores denominados @e(campos), a menudo de
   diferentes tipos, que se recogen juntos en un unico objeto que puede tratarse
   como una unidad. La variable @c(anim) es una estructura de tipo
   @c(gif.GIF). La estructura literal crea un valor estructura cuyo campo
   @c(LoopCount) se establece en @c(nframes); Todos los demas campos tienen el
   valor cero para su tipo. Los campos individuales de una estructura se puede
   acceder usando la notacion punto, al igual que en las dos ultimas
   asignaciones que actualizan de forma explicita los campos @c(Delay) e
   @c(Image) de @c(anim).

   La funcion @c(lissajous) tiene dos bucles anidados. El bucle exterior se
   ejecuta 64 iteraciones, cada una produciendo un solo fotograma de la
   animacion. Crea una nueva imagen de 201x201 con una paleta de dos colores,
   blanco y negro. Todos los pixeles se ajustan inicialmente al valor cero de la
   paleta (el color cero de la paleta), que se establece en blanco. Cada paso a
   traves del bucle interno genera una nueva imagen estableciendo algunos
   pixeles en negro. El resultado se añade a una lista de cuadros en @c(anim)
   utilizando la funcion incorporada @c(append) (@l(#Seccion 4.2.1<>§4.2.1)),
   junto con un retardo especificado de 80 ms. Por ultimo, la secuencia de
   cuadros y los retrasos se codifica en formato GIF y se escribe en la salida
   de fluje @c(out). El tipo de @c(out) es @c(io.Writer), lo que nos permite
   escribir a una amplia gama de posibles destinos, como vamos a mostrar pronto.

   El bucle interior ejecuta los dos osciladores. El oscilador @c(x) es
   simplemente la funcion sinusoidal. El oscilador @c(y) es tambien una
   sinusoide, pero su frecuencia es relativa a la del oscilador @c(x) un numero
   aleatorio entre 0 y 3, y su fase relativa al oscilador @c(x) es inicialmente
   cero, pero aumenta con cada fotograma de la animacion. El bucle se ejecuta
   hasta que el oscilador @c(x) ha completado cinco ciclos completos. En cada
   paso, que llaman a @c(SetColorIndex) para colorear el pixel correspondiente
   en (@c(x), @c(y)) negro, que es en la posicion 1 de la paleta.

   La funcion @c(main) llama a la funcion @c(lissajous), dirigiendola a escribir en la
   salida estandar, por lo que este comando produce un GIF animado con marcos
   como los de la Figura 1.1:

   ..src > sh
     $ go build gopl.io/ch1/lissajous
     $ ./lissajous >out.gif
   < src..

   @b(Ejercicio 1.5): Cambiar la paleta de colores del programa Lissajous a
   verde sobre negro, para mayor autenticidad. Para crear el color web
   @c(#RRGGBB), utilice @c(color.RGBA{0xRR, 0xGG, 0xBB, 0xff}), donde cada par
   de digitos hexadecimales representa la intensidad del componente de color
   rojo, verde o azul del pixel.

   @b(Ejercicio 1.6): Modificar el programa Lissajous para producir imagenes de
   multiples colores mediante la adicion de mas valores a la paleta y luego
   mostrarlos cambiando el tercer argumento de @c(SetColorIndex) de alguna
   manera interesante.

** Seccion 1.5 <> Obtener una URL

   Para muchas aplicaciones, el acceso a la informacion de Internet es tan
   importante como el acceso al sistema de archivos local. Go ofrece una
   coleccion de paquetes, agrupados bajo @c(net), que hacen que sea facil de
   enviar y recibir informacion a traves de Internet, realizar conexiones de red
   de bajo nivel, y configurar servidores, por lo que las caracteristicas de
   concurrencia de Go (introducidas en el @l(#Capitulo 8)) son particularmente
   utiles.

   Para ilustrar el minimo necesario para recuperar la informacion a traves de
   HTTP, aqui esta un programa simple llamado @$(fetch) que recupera el
   contenido de cada URL y lo imprime como texto sin interpretar; esta inspirado
   en la invaluable utilidad @$(curl) . Obviamente uno normalmente haria mas con
   tales datos, pero esto muestra la idea basica. Usaremos este programa con
   frecuencia en el libro.

   ..figure > @l(gopl.io/ch1/fetch/main.go<>gopl.io/ch1/fetch)

     ..src > go
       // Fetch imprime el contenido encontrado en cada URL especificada.
       package main

       import (
         "fmt"
         "io/ioutil"
         "net/http"
         "os"
       )

       func main() {
         for _, url := range os.Args[1:] {
           resp, err := http.Get(url)
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
             os.Exit(1)
           }
           b, err := ioutil.ReadAll(resp.Body)
           resp.Body.Close()
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
             os.Exit(1)
           }
           fmt.Printf("%s", b)
         }
       }
     < src..


   Este programa introduce funciones a partir de dos paquetes, @c(net/http) y
   @c(io/ioutil). La funcion @c(http.Get) realiza una peticion HTTP y, si no hay
   error, devuelve el resultado en la estructura @c(resp) . El campo @c(Body) de
   @c(resp) contiene la respuesta del servidor como un flujo legible. A
   continuacion, @c(ioutil.ReadAll) lee toda la respuesta; el resultado se
   almacena en @c(b). El flujo @c(Body) es cerrado para evitar fuga de recursos
   y @c(Printf) escribe la respuesta a la salida estandar.

   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://gopl.io
     <html>
     <head>
     <title>The Go Programming Language</title>
     ...
   < src..

   Si la solicitud HTTP falla, en su lugar, @$(fetch) reportara el error:

   ..src > sh
     $ ./fetch http://bad.gopl.io
     fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
   < src..

   En cualquiera de los casos de error, @c[os.Exit(1)] hace que el proceso
   termine con un codigo de estado de valor 1.

   @b(Ejercicio 1.7): La funcion @c[io.Copy(dst, src)] lee desde @c(src) y
   escribe en @c(dst). Utilicelo en lugar de @c(ioutil.ReadAll) para copiar el
   cuerpo de la respuesta a @c(os.Stdout) sin requerir un buffer lo
   suficientemente grande como para contener todo el fluje de datos. Asegurese
   de comprobar el resultado del error de @c(io.Copy).

   @b(Ejercicio 1.8): Modificar @$(fetch) para agregar el prefijo @c(http://) a
   cada argumento URL si este so se proporciona. Es posible que desee utilizar
   @c(strings.HasPrefix).

   @b(Ejercicio 1.9): Modificar @$(fetch) para imprimir tambien el codigo de
   estado HTTP, que se encuentra en @c(resp.Status).

** Seccion 1.6 <> Obteniendo URL Concurrentemente

   Uno de los aspectos mas interesantes y novedosos de Go es su soporte para la
   programacion concurrente. Este es un tema muy amplio, al que se dedican el
   @l(#Capitulo 8) y el @l(#Capitulo 9), asi que por ahora le daremos solo una
   muestra de los principales mecanismos de la concurrencia en Go, @e(gorutinas)
   y @e(canales).

   El siguiente programa, @$(fetchall), realiza la misma busqueda del contenido
   de una URL como en el ejemplo anterior, pero obtiene muchas URL, todas al
   mismo tiempo, de modo que el proceso no tardara mas que la busqueda mas
   prolongada en lugar de la suma de todos los tiempos de busqueda. Esta version
   de @$(fetchall) descarta las respuestas, pero indica el tamaño y el tiempo
   transcurrido de cada una:

   ..figure > @l(gopl.io/ch1/fetchall/main.go<>gopl.io/ch1/fetchall)

     ..src > go
       // Fetchall busca URLs en paralelo e informa de sus tiempos y tamaños.
       package main

       import (
         "fmt"
         "io"
         "io/ioutil"
         "net/http"
         "os"
         "time"
       )

       func main() {
         start := time.Now()
         ch := make(chan string)
         for _, url := range os.Args[1:] {
           go fetch(url, ch) // inicia una gorutina
         }
         for range os.Args[1:] {
           fmt.Println(<-ch) // recibir desde el canal ch
         }
         fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
       }

       func fetch(url string, ch chan<- string) {
         start := time.Now()
         resp, err := http.Get(url)
         if err != nil {
           ch <- fmt.Sprint(err) // enviar al canal ch
           return
         }

         nbytes, err := io.Copy(ioutil.Discard, resp.Body)
         resp.Body.Close() // no pierdas recursos
         if err != nil {
           ch <- fmt.Sprintf("while reading %s: %v", url, err)
           return
         }
         secs := time.Since(start).Seconds()
         ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
       }
     < src..


   He aqui un ejemplo:

   ..src > sh
     $ go build gopl.io/ch1/fetchall
     $ ./fetchall https://golang.org http://gopl.io https://godoc.org
     0.14s     6852 https://godoc.org
     0.16s     7261 https://golang.org
     0.48s     2475 http://gopl.io
     0.48s elapsed
   < src..

   Una @e(gorutina) es una funcion de ejecucion concurrente. Un @e(canal) es un
   mecanismo de comunicacion que permite a una @e(gorutina) para pasar valores
   de un tipo especificado a otra @e(gorutina). La funcion @e(main) se ejecuta
   en una gorutina y la sentencia @c(go) crea gorutinas adicionales.

   La funcion @c(main) crea un canal de strings utilizando @c(make) . Para cada
   argumento de linea de comandos, la sentencia @c(go) en el primer bucle inicia
   una nueva gorutina que llama a @c(fetch) asincronamente para buscar la URL
   usando @c(http.Get). La funcion @c(io.Copy) lee el cuerpo de la respuesta y
   la descarta escribiendo en el flujo de salida @c(ioutil.Discard). @c(Copy)
   devuelve el numero de bytes, junto con cualquier error que prodicido. A
   medida que llega cada resultado, @c(fetch) envia una linea de resumen en el
   canal @c(ch). El segundo bucle en @c(main) recibe e imprime esas lineas.

   Cuando una gorutina intenta enviar o recibir en un canal, se bloquea hasta
   que otra gorutina intente la operacion correspondiente de recepcion o envio,
   momento en el cual se transfiere el valor y ambas gorutinas continuan. En
   este ejemplo, cada @c(fetch) envia un valor (@e(expresion) @c(ch <-)) en el
   canal @c(ch), y @c(main) recibe todos ellos (@c(<-ch)). Tener a @c(main)
   haciendo toda la impresion, asegura que la salida de cada gorutina se procesa
   como una unidad, sin el peligro de entrelazado si dos gorutinas terminan al
   mismo tiempo.

   @b(Ejercicio 1.10): Encontrar un sitio web que produce una gran cantidad de
   datos. Investiga el almacenamiento en cache mediante la ejecucion de
   @$(fetchall) dos veces consecutivas para ver si el tiempo reportado cambia
   mucho. ¿Obtienes el mismo contenido cada vez? Modificar @$(fetchall) para
   imprimir su salida a un archivo para que pueda ser examinado.

   @b(Ejercicio 1.11): Pruebe @$(fetchall) con listas de argumentos mas
   extensas, como muestras de los mejores sitios web disponibles en
   @l(http://www.alexa.com/<>alexa.com). ¿Como se comporta el programa si un
   sitio web simplemente no responde? (La @l(#Seccion 8.9) describe los
   mecanismos para hacer frente en estos casos.)

** Seccion 1.7 <> Un servidor Web

   Las Librerias de Go hacen que sea facil escribir un servidor web que responde
   a las solicitudes de los clientes, como las realizadas por @$(fetch). En esta
   seccion, mostraremos un servidor minimo que devuelve el componente de ruta de
   la URL utilizada para acceder al servidor. Es decir, si la solicitud es
   @c(http://localhost:8000/hello), la respuesta sera @c(URL.Path = "/hello").

   ..figure > @l(gopl.io/ch1/server1/main.go<>gopl.io/ch1/server1)

     ..src > go
       // Server1 es un servidor de "eco" minimo.
       package main

       import (
         "fmt"
         "log"
         "net/http"
       )

       func main() {
         http.HandleFunc("/", handler) // cada solicitud llama a handler
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }
     < src..


   El programa esta formado por solo un puñado de lineas, porque las funciones
   de la libreria hacen la mayor parte del trabajo. La funcion @c(main) conecta
   una funcion de manejo a las direcciones URL entrantes que comienzan con
   @c(/), que son todas las direcciones URL, e inicia un servidor que escucha
   las peticiones entrantes en el puerto 8000. La solicitud se representa como
   una estructura de tipo @c(http.Request), que contiene una serie de campos
   relacionados, uno de los cuales es la URL de la solicitud entrante. Cuando
   llega una peticion, se le da a la funcion de manejo, que extrae el componente
   de ruta (@c(/hello)) a partir de la URL de solicitud y la envia de vuelta
   como la respuesta, utilizando @c(fmt.Fprintf). Los servidores web se
   explicaran en detalle en la @l(#Seccion 7.7).

   Iniciemos el servidor en segundo plano. En Mac OS X o GNU/Linux, añadir un
   simbolo ampersand (@c(&)) al comando; En Microsoft Windows, necesitara
   ejecutar el comando sin el signo ampersand en una ventana de comandos
   distinta.

   ..src > sh
     $ go run src/gopl.io/ch1/server1/main.go &
   < src..

   A continuacion, podemos hacer solicitudes desde la linea de comandos:

   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://localhost:8000
     URL.Path = "/"
     $ ./fetch http://localhost:8000/help
     URL.Path = "/help"
   < src..

   Como alternativa, podemos acceder al servidor desde un navegador web, como se
   muestra en la Figura 1.2.

   ..figure > Figura 1.2. Una respuesta del servidor de eco.

     ..img > img/Figure-1.2.jpg


   Es facil agregar funciones al servidor. Una adicion util es una URL
   especifica que devuelve un estado de algun tipo. Por ejemplo, esta version
   hace eco, pero tambien cuenta el numero de peticiones; una peticion a la URL
   @c(/count) devuelve el recuento hasta el momento, excluyendo la solicitud
   @c(/count) a si misma:

   ..figure > @l(gopl.io/ch1/server2/main.go<>gopl.io/ch1/server2)

     ..src > go
       // Server2 es un servidor de eco y conteo minimo
       package main

       import (
         "fmt"
         "log"
         "net/http"
         "sync"
       )

       var mu sync.Mutex
       var count int

       func main() {
         http.HandleFunc("/", handler)
         http.HandleFunc("/count", counter)
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         count++
         mu.Unlock()
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }

       // counter hace eco del numero de lamadas hasta ahora.
       func counter(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         fmt.Fprintf(w, "Count %d\n", count)
         mu.Unlock()
       }
     < src..


   El servidor tiene dos manejadores, y la URL de la solicitud determina cual se
   llama: una solicitud por @c(/count) invoca a @c(counter) y todas los demas
   invocan a @c(handler). Un patron de manejo que termina con una barra diagonal
   coincide con cualquier URL que tenga el patron como prefijo. Detras de
   escena, el servidor ejecuta el controlador para cada solicitud entrante en
   una gorutina separada para que pueda servir multiples solicitudes
   simultaneamente. Sin embargo, si dos solicitudes simultaneas intentan
   actualizar @c(count) al mismo tiempo, es posible que no se incremente
   consistentemente; El programa tendria un error grave llamado @e(condicion de
   carrera) (@l(#Seccion 9.1<>§9.1)). Para evitar este problema, debemos
   asegurarnos de que a lo sumo solo una gorutina accede a la variable a la vez,
   que es el proposito de las llamadas a @c[mu.Lock()] y @c[mu.Unlock()] que
   rodean el acceso a @c(count). Examinaremos mas de cerca a la concurrencia con
   variables compartidas en el @l(#Capitulo 9).

   Como un ejemplo mas rico, la funcion de manejo puede informar sobre los
   encabezados y datos de formulario que recibe, haciendo que el servidor sea
   util para inspeccionar y depurar peticiones:

   ..figure > @l(gopl.io/ch1/server3/main.go<>gopl.io/ch1/server3)

     ..src > go
       // handler responde a la peticion HTTP.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
         for k, v := range r.Header {
           fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
         }
         fmt.Fprintf(w, "Host = %q\n", r.Host)
         fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
         if err := r.ParseForm(); err != nil {
           log.Print(err)
         }
         for k, v := range r.Form {
           fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
         }
       }
     < src..


   Este utiliza los campos de la estructura @c(http.Request) para producir una
   salida como esta:

   ..pre >
     GET /?q=query HTTP/1.1
     Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
     Header["Accept-Language"] = ["en-US,en;q=0.8"]
     Header["Connection"] = ["keep-alive"]
     Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
     Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
     Host = "localhost:8000"
     RemoteAddr = "127.0.0.1:59911"
     Form["q"] = ["query"]
   < pre..

   Observe como la llamada a @c(ParseForm) esta anidada dentro de una sentencia
   @c(if). Go permite una declaracion simple, como una declaracion de variable
   local para preceder la sentencia @c(if), lo que es particularmente util para
   el tratamiento de errores como en este ejemplo. Podriamos haberlo escrito
   como

   ..src > go
     err := r.ParseForm()
     if err != nil {
       log.Print(err)
     }
   < src..

   la combinacion de las sentencias es mas corta y reduce el alcance de la
   variable @c(err), que es una buena practica. Vamos a definir el alcance en la
   @l(#Seccion 2.7).

   En estos programas, hemos visto tres tipos muy diferentes utilizados como
   flujos de salida. El programa @$(fetch) copia datos de la respuesta HTTP a
   @c(os.Stdout), a un archivo, al igual que el programa @$(lissajous). El
   programa @$(fetchall) arroja la respuesta copiando el flujo (mientras cuenta
   su longitud) de forma trivial en @c(ioutil.Discard). Y el anterior servidor
   web utiliza @c(fmt.Fprintf) para escribir una representacion del navegador
   @c(http.ResponseWriter).

   Aunque estos tres tipos difieren en los detalles de lo que hacen, todos ellos
   satisfacen una interfaz comun, permitiendo que cualquiera pueda ser utilizado
   cuando sea necesario crear un flujo de salida. Esa interfaz, llamada
   @c(io.Writer), se discute en la @l(#Seccion 7.1).

   El mecanismo de interfaz de Go es el tema del @l(#Capitulo 7), pero para dar
   una idea de lo que es capaz de hacer, vamos a ver lo facil que es combinar el
   servidor web con la funcion @c(lissajous) para que los archivos GIF animados
   se escriben no en la salida estandar, en su lugar en el cliente
   HTTP. Simplemente agregue estas lineas al servidor web:

   ..src > go
     handler := func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     }
     http.HandleFunc("/", handler)
   < src..

   o su equivalente:

   ..src > go
     http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     })
   < src..

   El segundo argumento de la funcion @c(HandleFunc) se conoce como una
   e(funcion literal), es decir, una funcion anonima definida en su punto de
   uso. Vamos a explicar mas a fondo en la @l(#Seccion 5.6).

   Una vez que haya realizado este cambio, visite @l(http://localhost:8000) en su
   navegador. Cada vez que cargue la pagina, vera una nueva animacion como la de
   la Figura 1.3.

   @b(Ejercicio 1.12): Modificar el servidor de Lissajous para leer valores de
   los parametros de la URL. Por ejemplo, es posible disponer de forma que una
   URL como @c(http://localhost:8000/?cycles=20) establece el numero de ciclos a
   20 en lugar del predeterminado 5. Utilice la funcion @c(strconv.Atoi) para
   convertir el parametro de string a un entero. Puede ver su mediante con @$(go
   doc strconv.Atoi).

   ..figure > Figura 1.3. Figuras animadas de Lissajous en un navegador.

     ..img > img/Figure-1.3.jpg

** Seccion 1.8 <> Cabos sueltos

   Hay mucho mas de Go de lo que hemos cubierto en esta introduccion rapida.
   Aqui hay algunos temas que apenas hemos tocado o omitido por completo, con
   tratamiento suficiente para empezar a familiarizarse con ellos antes de un
   tratamiento completo.

   - Control flow :: Cubrimos los dos estados de flujos de control fundamentales,
     @c(if) y @c(for), pero no la sentencia @c(switch), que es una via de
     multiples ramas. Aqui hay un pequeño ejemplo:

     ..src > go
       switch coinflip() {
       case "heads":
         heads++
       case "tails":
         tails++
       default:
         fmt.Println("landed on edge!")
       }
     < src..

     El resultado de llamar a @c(coinflip) se compara con el valor de cada
     caso. Los casos se evaluan de arriba a abajo, por lo que se ejecuta la
     primera coincidencia. El caso opcional @c(default) coincide si ninguno de
     los otros casos lo hace; Puede colocarse en cualquier lugar. Los casos no
     caigan uno sobre otro, como en lenguajes tipo C (aunque hay una poco
     utilizada declaracion @c(fallthrough) que anula este comportamiento).

     Un @c(switch) no necesita un operando; Solo puede enumerar los casos, cada
     uno de los cuales es una expresion booleana:

     ..src > go
       func Signum(x int) int {
         switch {
         case x > 0:
           return +1
         default:
           return 0
         case x < 0:
           return -1
         }
       }
     < src..

     Esta forma se llama @e(switch sin etiquetas); que es equivalente a
     @c(switch true).

     Al igual que las sentencias @c(for) e @c(if), un @c(switch) puede incluir
     una declaracion, una unica declaracion de variables compacta opcional, una
     declaracion de incremento o asignacion, o una funcion de llamada que se
     puede utilizar para establecer un valor antes de ser puesto a prueba.

     Las declaraciones @c(break) y @c(continue) modifican el flujo de
     control. Un @c(break) proboca control se reanude la siguiente sentencia
     despues de la secuenca @c(for), @c(switch), o @c(select) (que veremos mas
     adelante) mas anidada, y como hemos visto en la @l(#Seccion 1.3), un
     @c(continue) proboca que el bucle @c(for) mas interno inicie su proxima
     iteracion. Las declaraciones pueden etiquetarse de forma que un @c(break) y
     @c(continue) pueden referirse a ellos, por ejemplo, para salir de varios
     bucles anidados a la vez o para iniciar la siguiente iteracion del bucle
     mas externo. Hay incluso una sentencia @c(goto), aunque esta destinada para
     el codigo generado por la maquina, sin el uso regular por los
     programadores.

   - Tipos con nombre :: Una declaracion @c(type) hace que sea posible dar un
     nombre a un tipo existente. Puesto que los tipos de la estructura son a
     menudo largos, se nombran casi siempre. Un ejemplo conocido es la
     definicion de un tipo para un sistema de graficos 2-D @c(Point):

     ..src > go
       type Point struct {
         X, Y int
       }
       var p Point
     < src..

     Las declaracion de tipos y tipos con nombre se trata en el @l(#Capitulo 2).

   - Punteros :: Go proporciona punteros, es decir, los valores que contienen
     la direccion de una variable. En algunos lenguajes, notablemente C, los
     punteros son relativamente sin restricciones. En otros lenguajes, los
     punteros son disfrazados como @"(referencias), y no hay mucho que se
     pueda hacer con ellos, excepto pasar a su alrededor. Go toma una posicion
     en algun lugar en el medio. Los punteros son explicitamente
     visibles. operador @c(&) obtiene la direccion de una variable, y el
     operador @c(*) recupera la variable a la que se refiere el puntero, pero
     no hay aritmetica de punteros. Vamos a explicar los punteros en la
     @l(#Seccion 2.3.2).

   - Metodos e interfaces :: Un metodo es una funcion asociada con un tipo de
     dato; Go es inusual en el echo que los metodos se pueden vincular a casi
     cualquier tipo nombrado. Los Metodos son cubiertos en el @l(#Capitulo
     6). Las interfaces son tipos abstractos que nos permiten manejar tipos
     concretos diferentes de la misma manera basados ​​en que metodos tienen, no
     como se representan o implementan. Las interfaces son el tema del
     @l(#Capitulo 7).

   - Paquetes :: Go llega con una extensa libreria de paquetes utiles estandar,
     y la comunidad Go ha creado y compartido muchas mas. La programacion es a
     menudo mas sobre el uso de paquetes existentes que sobre la escritura de
     codigo propio original. A lo largo del libro, vamos a señalar un par de
     docenas de los paquetes estandar mas importantes, pero hay muchos mas que
     no tenemos espacio para mencionar, y no podemos proporcionar nada
     remotamente cercana a una referencia completa para cualquier paquete.

     Antes de embarcarse en cualquier programa nuevo, es una buena idea ver si
     ya existen paquetes que podrian ayudarle a hacer su trabajo mas
     facilmente. Puede encontrar un indice de los paquetes de librerias estandar
     en @l(https://golang.org/pkg) y los paquetes aportados por la comunidad en
     @l(https://godoc.org). La herramienta @$(go doc) hace que estos documentos
     sean facilmente accesibles desde la linea de comandos:

     ..src > sh
       $ go doc http.ListenAndServe
       package http // import "net/http"

       func ListenAndServe(addr string, handler Handler) error
           ListenAndServe listens on the TCP network address addr and then
           calls Serve with handler to handle requests on incoming connections.
       ...
     < src..

   - Comentarios :: Ya hemos mencionado los comentarios de documentacion al
     inicio de un programa o paquete. Tambien es un buen estilo escribir un
     comentario antes de la declaracion de cada funcion para especificar su
     comportamiento. Estas convenciones son importantes, ya que se utilizan por
     herramientas como @$(go doc) y @$(godoc) para localizar y monstrar la
     documentacion en pantalla (@l(#Seccion 10.7.4<>§10.7.4)).

     Para los comentarios que abarcan varias lineas o aparecen dentro de una
     expresion o declaracion, tambien existe la conocida notacion @c(/* ... */)
     de otros lenguajes. Este tipo de comentarios se utilizan a veces al
     principio de un archivo en un gran bloque de texto explicativo para evitar
     un @c(//) en cada linea. Dentro de un comentario, @c(//) y @c(/*) no tienen
     ningun significado especial, por que los comentarios no se anidan.

* Capitulo 2 <> Estructura del programa

  En Go, como en cualquier otro lenguaje de programacion, se construyen grandes
  programas a partir de un pequeño conjunto de construcciones basicas. Las
  variables almacenan los valores. Las expresiones simples se combinan en las
  mas grandes con operaciones como suma y resta. Los tipos basicos se reunen en
  agregados como matrices y estructuras. Las expresiones se utilizan en
  declaraciones cuyo orden de ejecucion es determinado por instrucciones de
  control de flujo como @c(if) y @c(for). Las declaraciones se agrupan en
  funciones por aislamiento y reutilizacion. Las funciones se agrupan en
  archivos de codigo fuente y paquetes.

  Vimos ejemplos de la mayoria de estos en el capitulo anterior. En este
  capitulo, vamos a entrar en mas detalles sobre los elementos estructurales
  basicos de un programa Go. Los programas de ejemplo son intencionalmente
  simples, por lo que podemos centrarnos en el lenguaje sin desviarnos de
  complicados algoritmos o estructuras de datos.

** Seccion 2.1 <> Nombres

   Los nombres de las funciones Go, variables, constantes, tipos, etiquetas de
   instrucciones y paquetes siguen una regla simple: un nombre comienza con una
   letra (es decir, cualquier cosa que Unicode considera una letra) o un guion
   bajo y puede tener cualquier numero de letras adicionales, Digitos y giones
   bajos. Las mayusculas importan: @c(heapSort) y @c(Heapsort) son nombres
   diferentes.

   Go tiene 25 @e(palabras claves) como @c(if) y @c(switch) que solo puede
   utilizarse cuando la sintaxis lo permita; No pueden usarse como nombres.

   ..pre >
     break      default       func     interface   select
     case       defer         go       map         struct
     chan       else          goto     package     switch
     const      fallthrough   if       range       type
     continue   for           import   return      var
   < pre..

   Ademas, hay cerca de tres docenas de nombres @e(predeclarados) como @c(int) y
   @c(true) para las constantes, tipos y funciones incorporadas:

   - Constantes ::

     ..pre >
       true false iota nil

   - Tipos      ::

     ..pre >
       int int8 int16 int32 int64
       uint uint8 uint16 uint32 uint64 uintptr
       float32 float64 complex128 complex64
       bool byte rune string error

   - Functions  ::

     ..pre >
       make len cap new append copy close delete
       complex real imag
       panic recover


   Estos nombres no estan reservados, por lo que puede utilizarlos en
   declaraciones. Vamos a ver un puñado de lugares donde redeclarar uno de
   ellos tiene sentido, pero tenga cuidado con la potencial confusion.

   Si una entidad se declara dentro de una funcion, esta es @e(local) a esa
   funcion. Si se declara fuera de una funcion, sin embargo, es visible en todos
   los archivos del paquete al que pertenece. La primer letra de un nombre
   determina su visibilidad a traves de los limites del paquete. Si el nombre
   comienza con una letra mayuscula, se exporta, lo que significa que es visible
   y accesible fuera de su propio paquete y puede hacer referencia a otras
   partes del programa, al igual que con @c(Printf) en el paquete @c(fmt). Los
   nombres de los paquetes estan siempre en minusculas.

   No hay limite en la longitud del nombre, pero la convencion y el estilo en
   los programas de Go se inclinan hacia nombres cortos, especialmente para
   variables locales con ambitos pequeños; es mucho mas probable ver variables
   con nombre @c(i) que @c(indiceDelBucle). Generalmente, cuanto mayor es el
   alcance de un nombre, mas largo y mas significativo debe ser.

   Estilisticamente, los programadores Go utilizan la @"(notacion camello)
   cuando se forma nombres mediante la combinacion de palabras; Es decir, las
   letras mayusculas internas se prefieren sobre los subrayados interiores. Por
   lo tanto las librerias estandar tienen funciones con nombres como
   @c(QuoteRuneToASCII) y @c(parseRequestLine) pero nunca @c(quote_rune_to_ASCII)
   o @c(parse_request_line). Las letras de acronimos y siglas como @A(ASCII) y
   @A(HTML) siempre se prestan en el mismo tipo, por lo que una funcion sera
   llamada @c(htmlEscape), @c(HTMLEscape) o @c(escapeHTML), pero no
   @c(escapeHtml).

** Seccion 2.2 <> Declaraciones

   Una @e(declaracion) nombra una entidad del programa y especifica todas o
   algunas de sus propiedades. Hay cuatro tipos principales de declaraciones:
   @c(var), @c(const), @c(type) y @c(func). Hablaremos sobre variables y tipos
   en este capitulo, constantes en el @l(#Capitulo 3), y funciones en el
   @l(#Capitulo 5).

   Un programa Go se almacena en uno o mas archivos cuyos nombres terminan en
   @f(.go). Cada archivo comienza con una declaracion @c(package) que indica de
   que paquete forma parte el archivo. La declaracion @c(package) es seguido por
   cualquier declaraciones @c(import), y luego una secuencia de declaraciones a
   nivel de paquete de tipos, variables, constantes y funciones, en cualquier
   orden. Por ejemplo, este programa declara una constante, una funcion y un par
   de variables:

   ..figure > @l(gopl.io/ch2/boiling/main.go<>gopl.io/ch2/boiling)

     ..src > go
       // Boiling imprime el punto de ebullicion del agua.
       package main

       import "fmt"

       const boilingF = 212.0

       func main() {
         var f = boilingF
         var c = (f - 32) * 5 / 9
         fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
         // Salida:
         // boiling point = 212°F or 100°C
       }
     < src..


   La constante @c(boilingF) es una declaracion de nivel de paquete (como es
   @c(main)), mientras que las variables @c(f) y @c(c) son locales a la funcion
   @c(main). El nombre de cada entidad de nivel de paquete es visible no solo en
   todo el archivo de origen que contiene su declaracion, sino en todos los
   archivos del paquete. Por el contrario, las declaraciones locales son
   visibles solo dentro de la funcion en la que se declaran y tal vez solo
   dentro de una pequeña parte de ella.

   Una declaracion de funcion tiene un nombre, una lista de parametros (las
   variables cuyos valores se proporcionan por quien llama a la funcion), una
   lista opcional de resultados y el cuerpo de la funcion, que contiene las
   sentencias que definen lo que hace la funcion. La lista de resultados se
   omite si la funcion no devuelve nada. La ejecucion de la funcion comienza con
   la primer instruccion y continua hasta que encuentra una instruccion de
   retorno o llega al final de una funcion que no tiene resultados. El control y
   los resultados se devuelven a quien hiso la llamada.

   Hemos visto un buen numero de funciones ya y hay muchas mas por venir,
   incluyendo una extenso tratamiento en el @l(#Capitulo 5), asi que esto es
   solo un esbozo. La funcion @c(fToC) a continuacion, encapsula la logica de
   conversion de temperatura de manera que se define solo una vez, pero puede
   utilizarse desde multiples lugares. Aqui @c(main) llama dos veces, utilizando
   los valores de las constantes de dos locales diferentes:

   ..figure > @l(gopl.io/ch2/ftoc/main.go<>gopl.io/ch2/ftoc)

     ..src > go
       // Ftoc imprime dos conversiones de Fahrenheit a Celsius.
       package main

       import "fmt"

       func main() {
         const freezingF, boilingF = 32.0, 212.0
         fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
         fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
       }

       func fToC(f float64) float64 {
         return (f - 32) * 5 / 9
       }
     < src..

** Seccion 2.3 <> Variables

   Un declaracion @c(var) crea una variable de un tipo particular, vinculando un
   nombre a la misma, y se define su valor inicial. Cada declaracion tiene la
   forma general

   ..src > go
     var nombre tipo = expresion
   < src..

   O bien el tipo o la parte @c(= expresion) pueden omitirse, pero no ambos. Si
   se omite el tipo, se determina mediante la expresion del inicializador. Si se
   omite la expresion, el valor inicial es el @e(valor cero) para el tipo, que
   es 0 para los numeros, @c(false) para booleanos, @c("") para string, y
   @c(nil) para interfaces y tipos de referencia (slices, punteros, mapa, canal,
   funcion). El valor cero de un tipo agregado como una matriz o una estructura
   tiene el valor cero de todos sus elementos o campos.

   El mecanismo de valor cero asegura que una variable siempre tenga un valor
   bien definido de su tipo; En Go no hay tal cosa como una variable no
   inicializada. Esto simplifica el codigo y, a menudo, asegura un
   comportamiento sensible de las condiciones limite sin trabajo adicional. Por
   ejemplo,

   ..src > go
     var s string
     fmt.Println(s) // ""
   < src..

   Imprime una cadena vacia, en lugar de causar algun tipo de error o
   comportamiento impredecible. Los programadores Go, suelen hacer algun
   esfuerzo por hacer el valor cero de un tipo mas complicado significativo, por
   lo que las variables comienzan su vida en un estado util.

   Es posible declarar y opcionalmente inicializar un conjunto de variables en
   una sola declaracion, con una lista de expresiones correspondiente. Omitir el
   tipo permite la declaracion de multiples variables de diferentes tipos:

   ..src > go
     var i, j, k int                 // int, int, int
     var b, f, s = true, 2.3, "four" // bool, float64, string
   < src..

   Los inicializadores pueden ser valores literales o expresiones
   arbitrarias. Las variables a nivel de paquete se inicializan antes del inicio
   de @c(main) (@l(#Seccion 2.6.2<>§2.6.2)), y las variables locales se
   inicializan a medida que se encuentran sus declaraciones durante la ejecucion
   de la funcion.

   Tambien se puede inicializar un conjunto de variables llamando a una funcion
   que devuelve valores multiples:

   ..src > go
     var f, err = os.Open(name) // os.Open returns a file and an error
   < src..

*** Seccion 2.3.1 <> Declaraciones de Variables Compacta

    Dentro de una funcion, una forma alternativa llamada @e(declaracion de
    variables compacta) se puede usar para declarar e inicializar las variables
    locales. Toma la forma @c(nombre := expresion), y el tipo de @c(nombre) esta
    determinada por el tipo de @c(expresion). Aqui estan tres de las muchas
    declaraciones de variables compacta en la funcion @c(lissajous) (@l(#Seccion
    1.4<>§1.4)):

    ..src > go
      anim := gif.GIF{LoopCount: nframes}
      freq := rand.Float64() * 3.0
      t := 0.0
    < src..

    Debido a su brevedad y flexibilidad, la declaracion compacta de variables se
    utilizan para declarar e inicializar la mayoria de las variables
    locales. Una sentencia @c(var) tiende a ser reservado para las variables
    locales que necesitan un tipo explicito que difiere de la de la expresion de
    inicializacion, o para cuando se le asignara un valor mas adelante la
    variable y su valor inicial no es importante.

    ..src > go
      i := 100                  // an int
      var boiling float64 = 100 // a float64

      var names []string
      var err error
      var p Point
    < src..

    Como con las sentencias @c(var), multiples variables pueden ser declaradas e
    inicializadas en la misma declaracion compacta de variables,

    ..src > go
      i, j := 0, 1
    < src..

    pero las declaraciones con multiples expresiones de inicializador deben
    utilizarse solo cuando ayudan a la legibilidad, como en agrupaciones cortas
    y naturales, como la parte de inicializacion de un bucle @c(for).

    Tenga en cuenta que @c(:=) es una declaracion, mientras que @c(=) es una
    asignacion. Una declaracion de multiples variables no debe confundirse con
    una asignacion de tuplas (@l(#Seccion 2.4.1<>§2.4.1)), en la que se asigna a
    cada variable en el lado de la izquierda el valor correspondiente de la
    parte derecha:

    ..src > go
      i, j = j, i // swap values of i and j
    < src..

    Al igual que en declaraciones @c(var) ordinarias, la declaraciones de
    variables compacta se puede utilizar para las llamadas a funciones como
    @c(os.Open) que devuelve dos o mas valores:

    ..src > go
      f, err := os.Open(name)
      if err != nil {
        return err
      }
      // ...use f...
      f.Close()
    < src..

    Un punto sutil pero importante: una declaracion de variables compacta no
    declara necesariamente todas las variables en su lado izquierdo. Si algunos
    de ellos ya fueron declarados en el @e(mismo) bloque lexico (@l(#Seccion
    2.7<>§2.7)), entonces la declaracion de variables compacta se comporta como
    una asignacion a esas variables.

    En el codigo siguiente, la primera sentencia declara tanto @c(in) como
    @c(err). El segundo declara @c(out) pero solo asigna un valor a la variable
    @c(err) existente.

    ..src > go
      in, err := os.Open(infile)
      // ...
      out, err := os.Create(outfile)
    < src..

    Sin embargo, una declaracion de variable corta debe declarar al menos una
    variable nueva, por lo que este codigo no compilara:

    ..src > go
      f, err := os.Open(infile)
      // ...
      f, err := os.Create(outfile) // error de compilacion: no hay nuevas variables
    < src..


    La correccion consiste en utilizar una asignacion ordinaria para la segunda
    instruccion.

    Una declaracion de variable compacta actua como una asignacion solo a
    variables que ya estaban declaradas en el mismo bloque lexico; Las
    declaraciones en un bloque externo se ignoran. Veremos ejemplos de esto al
    final del capitulo.

*** Seccion 2.3.2 <> Punteros

    Una variable es una pieza de almacenamiento que contiene un valor. Las
    variables creadas por las declaraciones se identifican por un nombre, como
    @c(x), pero muchas variables se idientifican solo por expresion como
    @c(x[i]) o @c(x.f). Todas estas expresiones leen el valor de una variable,
    excepto cuando aparecen en el lado izquierdo de una asignacion, en cuyo caso
    se asigna un nuevo valor a la variable.

    El valor de un @e(puntero) es la @e(direccion) de una variable. Un puntero
    es, por tanto, la ubicacion en la que se almacena un valor. No todos los
    valores tienen una direccion, pero todas las variables si. Con un puntero,
    podemos leer o actualizar el valor de una variable @e(indirectamente), sin
    utilizar o incluso saber el nombre de la variable, si es que tiene un
    nombre.

    Si se declara una variable @c(var x int), la expresion @c(&x) (@"(direccion
    de @c(x))) produce un puntero a una variable de de tipo entero, es decir, un
    valor de tipo @c(*int), que se pronuncia @"(puntero a int.) Si este valor se
    llama @c(p), decimos @"(@c(p) apunta a @c(x),)" o equivalentemente @"(@c(p)
    contiene la direccion de @c(x).) La variable a la que @c(p) apunta se
    escribe @c(*p). La expresion @c(*p) produce el valor de dicha variable, un
    @c(int), pero desde @c(*p) indica una variable, tambien puede aparecer en la
    parte izquierda de una asignacion, en cuyo caso la asignacion actualiza la
    variable.

    ..src > go
      x := 1
      p := &x         // p, of type *int, points to x
      fmt.Println(*p) // "1"
      *p = 2          // equivalent to x = 2
      fmt.Println(x)  // "2"
    < src..

    Cada componente de una variable de tipo agregado–un campo de una estructura
    o un elemento de una matriz– es tambien una variable y por lo tanto tiene
    una direccion tambien.

    Las variables se describen a veces como valores @e(direccionables).
    Expresiones que denotan variables son las unicas expresiones a las que el
    operador de direccion @c(&) se puede aplicar.

    El valor cero de un puntero de cualquier tipo es @c(nil). La prueba de @c(p
    != nil) es verdadera si @c(p) apunta a una variable. Los punteros son
    comparables; Dos punteros son iguales si y solo si apuntan a la misma
    variable o ambos son @c(nil).

    ..src > go
      var x, y int
      fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
    < src..

    Es perfectamente seguro para una funcion devolver la direccion de una
    variable local. Por ejemplo, en el codigo siguiente, la variable local @c(v)
    creada por la llamada a @c(f) seguira existiendo incluso despues de devolver
    la llamada, y el puntero @c(p) todavia se referira a ella:

    ..src > go
      var p = f()

      func f() *int {
        v := 1
        return &v
      }
    < src..

    Cada llamada a @c(f) devuelve un valor distinto:

    ..src > go
      fmt.Println(f() == f()) // "false"
    < src..

    Debido a que un puntero contiene la direccion de una variable, pasar un
    argumento de puntero a una funcion hace posible que la funcion actualice la
    variable que se paso indirectamente. Por ejemplo, esta funcion incrementa la
    variable a la que apunta su argumento y devuelve el nuevo valor de la
    variable para que pueda ser utilizada en una expresion:

    ..src > go
      func incr(p *int) int {
        *p++ // incrementa a lo que apunta p; no cambia p
        return *p
      }

      v := 1
      incr(&v)              // efecto secundario: ahora v es 2
      fmt.Println(incr(&v)) // "3" (y v es 3)
    < src..

    Cada vez que se toma la direccion de una variable o se copia un puntero,
    creamos nuevos @e(alias) o maneras de identificar a la misma variable. Por
    ejemplo, @c(*p) es un alias para @c(v). Los punteros como alias son utiles
    porque nos permite acceder a una variable sin usar su nombre, pero esto es
    una espada de doble filo: para encontrar todas las sentencias que acceden a
    una variable, tenemos que conocer todos sus alias. No son solo los punteros
    que crean alias; los alias tambien se crean cuando copiamos valores de otros
    tipos de referencia como slices, mapas y canales, e incluso estructuras,
    matrices e interfaces que contienen estos tipos.

    Los punteros son clave para el paquete @c(flag), que utiliza los argumentos
    de linea de comandos de un programa, para establecer los valores de ciertas
    variables distribuidas a lo largo del programa. Para ilustrar, esta
    variacion en el anterior comando @$(echo) tiene dos indicadores opcionales:
    @c(-n) provaca que @$(echo) omita el salto de linea final que normalmente se
    imprime, y @c(-s sep) hace que se separe los argumentos de salida por el
    contenido de la cadena @c(sep) en lugar de El espacio unico
    predeterminado. Como esta es nuestra cuarta version, el paquete se llama
    @f(gopl.io/ch2/echo4).

    ..figure > @l(gopl.io/ch2/echo4/main.go<>gopl.io/ch2/echo4)

      ..src > go
        // Echo4 imprime sus argumentos de linea de comandos.
        package main

        import (
          "flag"
          "fmt"
          "strings"
        )

        var n = flag.Bool("n", false, "omit trailing newline")
        var sep = flag.String("s", " ", "separator")

        func main() {
          flag.Parse()
          fmt.Print(strings.Join(flag.Args(), *sep))
          if !*n {
            fmt.Println()
          }
        }
      < src..


    La funcion @c(flag.Bool) crea una nueva variable bandera de tipo @c(bool).
    Toma tres argumentos: el nombre de la bandera (@c("n")), el valor por
    defecto de la variable (@c(false)), y un mensaje que se imprimira si el
    usuario proporciona un argumento invalido, una bandera invalida, o @c(-h) o
    @c(-help). Del mismo modo, @c(flag.String) toma un nombre, un valor por
    defecto, y un mensaje, y crea una variable @c(string). Las variables @c(sep)
    y @c(n) son punteros a las variables de la bandera, que deben accederse
    indirectamente como @c(*sep) y @c(*n).

    Cuando se ejecuta el programa, debe llamar a @c(flag.Parse) antes de
    utilizar las banderas, para actualizar las variables bandera de sus valores
    por defecto. Los argumentos que no sean banderas estan disponibles mediante
    @c[flag.Args()] como un slice de strings. Si @c(flag.Parse) encuentra un
    error, se imprime un mensaje sobre el uso y llama a @c[os.Exit(2)] para terminar
    el programa.

    Vamos a ejecutar algunos casos de prueba a @$(echo):

    ..src > sh
      $ go build gopl.io/ch2/echo4
      $ ./echo4 a bc def
      a bc def
      $ ./echo4 -s / a bc def
      a/bc/def
      $ ./echo4 -n a bc def
      a bc def$
      $ ./echo4 -help
      Usage of ./echo4:
        -n    omit trailing newline
        -s string
              separator (default " ")
    < src..

*** Seccion 2.3.3 <> La Funcion @c(new)

    Otra forma de crear una variable es utilizar la funcion nativa de @c(new).
    La expresion @c[new(T)] crea una @e(variable sin nombre) del tipo @c(T), la
    inicializa al valor cero de @c(T), y devuelve su direccion, que es un valor
    de tipo @c(*T).

    ..src > go
      p := new(int)   //  p, de tipo *int, apunta a una varible int sin nombre
      fmt.Println(*p) //  "0"
      *p = 2          //  establece el int sin nombre a 2
      fmt.Println(*p) //  "2"
    < src..

    Una variable creada con @c(new) no es diferente de una variable local
    ordinaria cuya direccion es tomada, excepto que no hay necesidad de inventar
    (y declarar) un nombre ficticio, y podemos usar @c[new(T)] en una expresion.
    De este modo @c(new) es solo una conveniencia sintactica, no es una idea
    fundamental:

    las dos funciones @c(newInt) a continuacion tienen comportamientos
    identicos.

    ..cols >

      ..src > go
        func newInt() *int {
          return new(int)
        }
      < src..

      ::

      ..src > go
        func newInt() *int {
          var dummy int
          return &dummy
        }
      < src..

    Cada llamada a @c(new) devuelve una variable distinta con una direccion
    unica:

    ..src > go
      p := new(int)
      q := new(int)
      fmt.Println(p == q) // "false"
    < src..

    Hay una excepcion a esta regla: dos variables cuyo tipo no lleva ninguna
    informacion y por lo tanto es de tamaño cero, como @c(struct{}) o
    @c([0]int), puede, dependiendo de la aplicacion, tener la misma direccion.

    La funcion @c(new) se utiliza relativamente rara vez porque las variables
    sin nombre mas comunes son de tipo estructura, para el que la sintaxis
    literal @c(struct) (@l(#Seccion 4.4.1<>§4.4.1)) es mas flexible.

    Dado que @c(new) es una funcion nativa, no una palabra clave, es posible
    redefinir el nombre para algo distinto dentro de una funcion, por ejemplo:

    ..src > go
      func delta(old, new int) int { return new - old }
    < src..

    Por supuesto, dentro de @c(delta), la funcion nativa @c(new) no esta
    disponible.

*** Seccion 2.3.4 <> Tiempo de Vida de las Variables

    La @e(vida util) de una variable es el intervalo de tiempo durante el cual
    existe a medida que el programa se ejecuta. La duracion de una variable a
    nivel de paquete, es la ejecucion completa del programa. Por el contrario,
    las variables locales tienen una vida util dinamica: una nueva instancia se
    crea cada vez que se ejecuta la instruccion de declaracion, y la variable
    vive hasta que se vuelve @e(inaccesible), momento en el que su
    almacenamiento se puede reciclar. Los parametros de funcion y los resultados
    tambien son variables locales; Se crean cada vez que se llama a la funcion
    que las encierra.

    Por ejemplo, en este extracto del programa de Lissajous de la @l(#Seccion 1.4),

    ..src > go
      for t := 0.0; t < cycles*2*math.Pi; t += res {
        x := math.Sin(t)
        y := math.Sin(t*freq + phase)
        img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
          blackIndex)
      }
    < src..

    la variable @c(t) se crea cada vez que el bucle @c(for) comienza, y nuevas
    variables @c(x) y @c(y) se crean en cada iteracion del bucle.

    ¿Como sabe el recolector de basura que el almacenamiento de una variable
    puede ser recuperado? La historia completa es mucho mas detallada de lo que
    necesitamos aqui, pero la idea basica es que cada variable a nivel de
    paquete, y cada variable local de cada funcion actualmente activa, puede ser
    el inicio o la raiz de una ruta a la variable en cuestion, sugiendo punteros
    y otros tipos de referencias que finalmente conducen a la variable. Si no
    existe tal ruta, la variable se ha vuelto inaccesible, por lo que ya no
    puede afectar el resto del calculo.

    Debido a que el tiempo de vida de una variable se determina por ser o no
    accesible, una variable local puede sobrevivir a una sola iteracion del
    bucle que lo rodea. Puede seguir existiendo incluso despues de que su
    funcion de inclusion ha regresado.

    Un compilador puede elegir por asignar las variables locales en el monticulo
    o en la pila, pero, tal vez sorprendentemente, esta eleccion no depende de
    si se utiliza @c(var) o @c(new) para declarar la variable.

    ..cols >

      ..src > go
        var global *int

        func f() {
          var x int
          x = 1
          global = &x
        }
      < src..

      ::

      ..src > go
        func g() {
          y := new(int)
          *y = 1
        }
      < src..

    Aqui, @c(x) debe ser asignado al monticulo porque todavia es accesible desde
    la variable @c(global) despues de haber devuelto @c(f), a pesar de ser
    declarado como una variable local; decimos que @c(x) escapa de @c(f). Por el
    contrario, cuando @c(g) regresa la variable @c(*y) se vuelve inaccesible y
    se pueden reciclar. Dado que @c(*y) no escapa de @c(g), es seguro para el
    compilador asignar @c(*y) en la pila, a pesar de que se asigno con @c(new).
    En cualquier caso, la nocion de escapar no es algo de lo que tengas que
    preocuparte para escribir codigo correcto, aunque es bueno tenerlo en cuenta
    durante la optimizacion de rendimiento, ya que cada variable que escapa
    requiere una asignacion de memoria adicional.

    La recoleccion de basura es una tremenda ayuda para escribir programas
    correctos, pero no elimina la carga de pensar en la memoria. No es necesario
    asignar y liberar memoria de forma explicita, pero para escribir programas
    eficientes es necesario tener en cuenta la duracion de las variables. Por
    ejemplo, mantener punteros innecesarios a objetos de corta duracion dentro
    de objetos de larga vida, especialmente variables globales, evitara que el
    recolector de basura recupere los objetos de corta duracion.

** Seccion 2.4 <> Asignaciones

   El valor contenido en una variable es actualizado por una instruccion de
   asignacion, que en su forma mas simple tiene una variable a la izquierda del
   signo @c(=) y una expresion a la derecha.

   ..src > go
     x = 1                       // variable con nombre
     *p = true                   // variable indirecta
     person.name = "bob"         // campo de ustructura
     count[x] = count[x] * scale // elemento de arreglo, slice o mapa
   < src..

   Cada uno de los operadores aritmeticos y operadores binarios a nivel de bits
   tiene su correspondiente @e(operador de asignacion) permitiendo, por ejemplo,
   reescribir la ultima instruccion como

   ..src > go
     count[x] *= scale
   < src..

   Lo que nos ahorra tener que repetir (y reevaluar) la expresion de la
   variable.

   Las variables numericas tambien se pueden incrementar y disminuir con las
   declaraciones @c(++) y @c(--):

   ..src > go
     v := 1
     v++    // igual a v = v + 1; v es 2
     v--    // igual a v = v - 1; v es 1 de nuevo
   < src..

*** seccion 2.4.1 <> Asignacion de Tuplas

    Otra forma de asignacion, conocida como @e(asignacion de tuplas), permite
    asignar varias variables a la vez. Todas las expresiones del lado derecho se
    evaluan antes de actualizar cualquiera de las variables, haciendo que este
    formato sea mas util cuando algunas de las variables aparecen en ambos lados
    de la asignacion, como sucede, por ejemplo, al intercambiar los valores de
    dos variables:

    ..src > go
      x, y = y, x
      a[i], a[j] = a[j], a[i]
    < src..

    O cuando se calcula el mayor comun divisor de dos enteros:

    ..src > go
      func gcd(x, y int) int {
        for y != 0 {
          x, y = y, x%y
        }
        return x
      }
    < src..

    O al calcular el n-esimo numero de Fibonacci iterativamente:

    ..src > go
      func fib(n int) int {
        x, y := 0, 1
        for i := 0; i < n; i++ {
          x, y = y, x+y
        }
        return x
      }
    < src..

    La asignacion de tuplas tambien puede hacer una secuencia de tareas
    triviales mas compacta,

    ..src > go
      i, j, k = 2, 3, 5
    < src..

    Aunque por una cuestion de estilo, evite la forma de tupla si las
    expresiones son complejas; una secuencia de declaraciones separadas es mas
    facil de leer.

    Ciertas expresiones, como una llamada a una funcion con resultados
    multiples, producen varios valores. Cuando se utiliza una llamada de este
    tipo en una instruccion de asignacion, el lado izquierdo debe tener tantas
    variables como la funcion tenga resultados.

    ..src > go
      f, err = os.Open("foo.txt") // Llamada de funcion devuelve dos valores
    < src..

    A menudo, las funciones utilizan estos resultados adicionales para indicar
    algun tipo de error, ya sea devolviendo un @c(error) como en la llamada a
    @c(os.Open), o un @c(bool), generalmente llamado @c(ok). Como veremos en
    capitulos posteriores, hay tres operadores que a veces se comportan de esta
    manera tambien. Si la busqueda en un mapa (@l(#Seccion 4.3<>§4.3)), un tipo
    de asercion (@l(#Seccion 7.10<>§7.10)), o la recepcion de un canal
    (@l(#Seccion 8.4.2<>§8.4.2)) aparece en una asignacion en la que se esperan
    dos resultados, cada una produce un resultado booleano adicional:

    ..src > go
      v, ok = m[key]         // map lookup
      v, ok = x.(T)          // type assertion
      v, ok = <-ch           // channel receive
    < src..

    Al igual que con la declaracion de variables, podemos asignar valores no
    deseados al identificador en blanco:

    ..src > go
      _, err = io.Copy(dst, src) // discard byte count
      _, ok = x.(T)              // check type but discard result
    < src..

*** Seccion 2.4.2 <> Asignacion

    Las sentencias de asignacion son una forma explicita de asignacion, pero hay
    muchos lugares en un programa donde se produce una asignacion @e(implicita):
    una llamada de funcion asigna implicitamente los valores de los argumentos a
    las variables de parametros correspondientes; una instruccion @c(return)
    asigna implicitamente los operandos de retorno a las variables de resultado
    correspondientes; y una expresion literal para un tipo compuesto
    (@l(#Seccion 4.2<>§4.2)), tal como esta slice:

    ..src > go
      medallas := []string{"oro", "plata", "bronce"}
    < src..

    Implicitamente asigna cada elemento, como si se hubiera escrito asi:

    ..src > go
      medallas[0] = "oro"
      medallas[1] = "plata"
      medallas[2] = "bronce"
    < src..

    Los elementos de mapas y canales, aunque no son variables ordinarias,
    tambien estan sujetos a asignaciones implicitas similares.

    Una asignacion, explicita o implicita, siempre es legal si el lado izquierdo
    (la variable) y el lado derecho (el valor) tienen el mismo tipo. En terminos
    mas generales, la asignacion es legal solo si el valor es @e(asignable) al
    tipo de la variable.

    La regla para la @e(asignabilidad) tiene casos para varios tipos, por lo que
    vamos a explicar el caso relevante a medida que introducimos cada nuevo
    tipo. Para los tipos que hemos discutido hasta ahora, las reglas son
    simples: los tipos deben coincidir exactamente, y @c(nil) puede ser asignado
    a cualquier variable de interfaz o tipo de referencia. Las constantes
    (@l(#Seccion 3.6<>§3.6)) tienen reglas mas flexibles para la asignacion que
    evitan la necesidad de conversiones mas explicitos.

    Si dos valores pueden compararse con @c(==) y @c(!=) se relaciona con la
    asignacion: en cualquier comparacion, el primer operando debe ser asignable
    al tipo del segundo operando, o viceversa. Al igual que con la
    asignabilidad, vamos a explicar los casos relevantes para la comparabilidad
    cuando presentamos cada nuevo tipo.

** Seccion 2.5 <> Declaraciones de tipo

   El tipo de una variable o expresion define las caracteristicas de los valores
   que puede tomar, como su tamaño (numero de bits o numero de elementos, tal
   vez), como se representan internamente, las operaciones intrinsecas que se
   pueden realizar en ellos, Y los metodos asociados con ellos.

   En cualquier programa hay variables que comparten la misma representacion
   pero que significan conceptos muy diferentes. Por ejemplo, un @c(int) podria
   ser usado para representar un indice de bucle, una marca de tiempo, un
   descriptor de archivo, o un mes; un @c(float64) podria representar una
   velocidad en metros por segundo o una temperatura en una de varias escalas; y
   un @c(string) podria representar una contraseña o el nombre de un color.

   Una declaracion @c(type) define un nuevo @e(tipo con nombre) que tiene el
   mismo @e(tipo subyacente) como un tipo existente. El tipo nombrado
   proporciona una manera de separar los diferentes usos y quizas incompatibles
   del tipo subyacente para que no puedan ser mezclados involuntariamente.

   ..src > go
     type name underlying-type
   < src..

   Las declaraciones de tipo aparecen mas a menudo en el nivel de paquete, donde
   el tipo nombrado es visible en todo el paquete, y si el nombre se exporta
   (inicia con una letra mayuscula), es accesible desde otros paquetes tambien.

   Para ilustrar la declaracion de tipos, vamos a convertir las diferentes
   escalas de temperatura en tipos distintos:

   ..figure > @l(gopl.io/ch2/tempconv0/celsius.go<>gopl.io/ch2/tempconv0)

     ..src > go
       // Paquete tempconv realiza calculos de temperatura Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
         AbsoluteZeroC Celsius = -273.15
         FreezingC     Celsius = 0
         BoilingC      Celsius = 100
       )

       func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
       func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
     < src..


   Este paquete define dos tipos, @c(Celsius) y @c(Fahrenheit), para las dos
   unidades de temperatura. A pesar de que ambos tienen el mismo tipo
   subyacente, @c(float64), no son del mismo tipo, por lo que no pueden
   compararse o ser combinados en expresiones aritmeticas. Distinguir los tipos
   hace posible evitar errores como combinar inadvertidamente temperaturas en
   las dos escalas diferentes; una conversion de tipo explicita como
   @c[Celsius(t)] o @c[Fahrenheit(t)] es necesario para convertir desde un
   @c(float64). @c[Celsius(t)] y @c[Fahrenheit(t)] son conversiones, no llamadas
   a funcion. No cambian el valor o la representacion de ninguna manera, pero
   hacen que el cambio de significado sea explicito. Por otro lado, las
   funciones @c(CToF) y @c(FToC) convertir entre las dos escalas; Estas
   devuelven valores diferentes.

   Para cada tipo @c(T), hay una operacion de conversion correspondiente
   @c[T(x)] que convierte el valor @c(x) al tipo @c(T). Se permite una
   conversion de un tipo a otro si ambos tienen el mismo tipo subyacente, o si
   ambos son tipos apuntador sin nombre que apuntan a variables del mismo tipo
   subyacente; Estas conversiones cambian el tipo pero no la representacion del
   valor. Si @c(x) es asignable a @c(T), se permite una conversion, pero suele
   ser redundante,

   Las conversiones tambien se permiten entre tipos numericos, y entre la cadena
   y algunos tipos de slices, como veremos en el siguiente capitulo. Estas
   conversiones pueden cambiar la representacion del valor. Por ejemplo, la
   conversion de un numero de coma flotante a un entero descarta cualquier parte
   fraccionaria, y la conversion de una cadena a un slice @c([]byte) asigna una
   copia de los datos de cadena. En cualquier caso, una conversion nunca falla
   en tiempo de ejecucion.

   El tipo subyacente de un tipo con nombre determina su estructura y
   representacion, asi como el conjunto de operaciones intrinsecas que admite,
   que son iguales que si el tipo subyacente se hubiera utilizado
   directamente. Eso significa que los operadores aritmeticos funcionan igual
   para @c(Celsius) y @c(Fahrenheit) como lo hacen para @c(float64), como se
   podria esperar.

   ..src > go
     fmt.Printf("%g\n", BoilingC-FreezingC)       // "100" °C
     boilingF := CToF(BoilingC)
     fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
     fmt.Printf("%g\n", boilingF-FreezingC)       // error de compilacion: tipo incorrecto
   < src..

   Los operadores de comparacion como @c(==) y @c(<) tambien se puede utilizar
   para comparar un valor de un tipo con nombre a otro del mismo tipo, o a un
   valor del tipo subyacente. Pero dos valores de diferentes tipos con nombre no
   pueden compararse directamente:

   ..src > go
     var c Celsius
     var f Fahrenheit
     fmt.Println(c == 0)          // "true"
     fmt.Println(f >= 0)          // "true"
     fmt.Println(c == f)          // error de compilacion: tipo incorrecto
     fmt.Println(c == Celsius(f)) // "true"!
   < src..

   Anote cuidadosamente el ultimo caso. A pesar de su nombre, la conversion de
   tipo @c[Celsius(f)] no cambia el valor de su argumento, a su tipo. La prueba
   es cierto porque @c(c) y @c(f) son ambos cero.

   Un tipo con nombre puede proporcionar conveniencia de notacion si ayuda a
   evitar escribir tipos complejos una y otra vez. La ventaja es pequeña cuando
   el tipo subyacente es tan simple como @c(float64), pero grande para los tipos
   complicados, como veremos cuando hablemos de estructuras.

   Los tipos nombrados tambien permiten definir nuevos comportamientos para los
   valores del tipo. Estos comportamientos se expresan como un conjunto de
   funciones asociadas con el tipo, llamado @e(metodos) del tipo. Veremos los
   metodos en detalle en el capitulo 6, pero daremos una idea del mecanismo
   aqui.

   La siguiente declaracion, en la que el parametro @c(Celsius) @c(c) aparece
   antes del nombre de la funcion, se asocia con el tipo @c(Celsius) un metodo
   llamado @c(String) que devuelve @c(c) como un valor numerico seguido por
   @c(°C):

   ..src > go
     func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
   < src..


   Muchos tipos declarar un metodo @c(String) de esta forma debido a que controla
   como aparecen los valores del tipo cuando se imprimen en una cadena con el
   paquete @c(fmt), como veremos en la @l(#Seccion 7.1).

   ..src > go
     c := FToC(212.0)
     fmt.Println(c.String()) // "100°C"
     fmt.Printf("%v\n", c)   // "100°C"; no es necesario llamar a String explicitamente
     fmt.Printf("%s\n", c)   // "100°C"
     fmt.Println(c)          // "100°C"
     fmt.Printf("%g\n", c)   // "100"; no llama a String
     fmt.Println(float64(c)) // "100"; no llama a String
   < src..

** Seccion 2.6 <> Paquetes y Ficheros

   Los paquetes en Go sirven a los mismos propositos que las librerias o modulos
   en otros lenguajes, soportando modularidad, encapsulacion, compilacion
   separada y reutilizacion. El codigo fuente de un paquete reside en uno o mas
   archivos @f(.go), por lo general en un directorio cuyo nombre termina con la
   ruta de importacion; por ejemplo, los archivos del paquete
   @c(gopl.io/ch1/helloworld) se almacenan en el directorio
   @c($GOPATH/src/gopl.io/ch1/helloworld).

   Cada paquete sirve como un @e(espacio de nombres) separado para sus
   declaraciones. Dentro del paquete @c(image), por ejemplo, el identificador
   @c(Decode) se refiere a una funcion diferente de la que el mismo
   identificador en el paquete @c(unicode/utf16). Para hacer referencia a una
   funcion desde fuera de su paquete, debemos @e(calificar) el identificador
   para hacer explicito si nos referimos a @c(image.Decode) o @c(utf16.Decode).

   Los paquetes tambien nos permiten ocultar informacion controlando que nombres
   son visibles fuera del paquete, o @e(exportados). En Go, una regla simple
   regula que identificadores se exportan y cuales no: los identificadores
   exportados comienzan con una letra mayuscula.

   Para ilustrar los fundamentos, supongamos que nuestro software de conversion
   de temperatura se ha vuelto popular y queremos ponerlo a disposicion de la
   comunidad Go como un nuevo paquete. ¿Como hacemos eso?

   Vamos a crear un paquete llamado @c(gopl.io/ch2/tempconv), una variacion del
   ejemplo anterior. (Aqui hemos hecho una excepcion a nuestra regla habitual de
   ejemplos de numeracion en secuencia, de modo que la ruta del paquete puede
   ser mas realista.) El propio paquete se almacena en dos archivos para mostrar
   como se accede a las declaraciones en archivos separados de un paquete; En la
   vida real, un pequeño paquete como este solo necesitaria un archivo.

   Hemos puesto las declaraciones de los tipos, sus constantes y sus metodos en
   @f(tempconv.go):

   ..figure > @l(gopl.io/ch2/tempconv/tempconv.go<>gopl.io/ch2/tempconv)

     ..src > go
       // El paquete tempconv realiza conversiones Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
       	AbsoluteZeroC Celsius = -273.15
       	FreezingC     Celsius = 0
       	BoilingC      Celsius = 100
       )

       func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
       func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
     < src..


   y las funciones de conversion en @f(conv.go):

   ..src > go
     package tempconv

     // CToF convierte una temperatura Celsius a Fahrenheit.
     func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

     // FToC convierte una temperatura Fahrenheit a Celsius.
     func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
   < src..

   Cada archivo comienza con una declaracion @c(package) que define el nombre
   del paquete. Cuando se importa el paquete, sus miembros se conocen como
   @c(tempconv.CToF) y asi. Los nombres a nivel de paquete como los tipos y las
   constantes declaradas en un archivo de un paquete son visibles para todos los
   otros archivos del paquete, como si el codigo fuente estuviera todo en un
   solo archivo. Observe que @f(tempconv.go) importa @c(fmt), pero @f(conv.go)
   no lo hace, ya que no utiliza nada de @c(fmt).

   Debido a que los nombres @c(const) de nivel de paquete comienzan con letras
   mayusculas, tambien son accesibles con nombres calificados, por ejemplo,
   @c(tempconv.AbsoluteZeroC):

   ..src > go
     fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
   < src..

   Para convertir una temperatura Celsius a Fahrenheit en un paquete que importa
   @c(gopl.io/ch2/tempconv), podemos escribir el siguiente codigo:

   ..src > go
     fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
   < src..

   El @c(comentario de documentacion) (@l(#Seccion 10.7.4<>§10.7.4))
   inmediatamente anterior a la declaracion del paquete, documenta el paquete en
   su conjunto. Convencionalmente, debe comenzar con una oracion de resumen en
   el estilo ilustrado. Solo un archivo en cada paquete debe tener un comentario
   de documentacion del paquete. Los comentarios de documentacion extensos, a
   menudo se colocan en su propio fichero, convencionalmente llamado @f(doc.go).

   @b(Ejercicio 2.1): Añadir tipos, constantes y funciones a @c(tempconv) para
   el procesamiento de temperaturas en la escala Kelvin, donde cero Kelvin es
   -273,15°C y una diferencia de 1K tiene la misma magnitud de 1°C.

*** Seccion 2.6.1 <> Importaciones

    Dentro de un programa Go, cada paquete se identifica por una cadena unica
    llamada la @e(ruta de importacion). Estas son las cadenas que aparecen en
    una declaracion @c(import) como @c("gopl.io/ch2/tempconv"). La
    especificacion del lenguaje no define de donde provienen estas cadenas o lo
    que significan; Depende de las herramientas para interpretarlas. Cuando se
    utiliza la herramienta @$(go) de (@l(#Capitulo 10)), una ruta de importacion
    denota un directorio que contiene uno o mas archivos de codigo fuento Go que
    juntos componen el paquete.

    Ademas de su ruta de importacion, cada paquete tiene un nombre de paquete,
    que es corto (y no necesariamente unico) nombre que aparece en su
    declaracion @c(package). Por convencion, el nombre de un paquete coincide
    con el ultimo segmento de la ruta de importacion, por lo que es facil
    predecir que el nombre del paquete de @c(gopl.io/ch2/tempconv) es
    @c(tempconv).

    Para utilizar @c(gopl.io/ch2/tempconv), hay que importarlo:

    ..figure > @l(gopl.io/ch2/cf/main.go<>gopl.io/ch2/cf)

      ..src > go
        // Cf conviente su argumento numerico en Celsius y Fahrenheit.
        package main

        import (
          "fmt"
          "os"
          "strconv"

          "gopl.io/ch2/tempconv"
        )

        func main() {
          for _, arg := range os.Args[1:] {
            t, err := strconv.ParseFloat(arg, 64)
            if err != nil {
              fmt.Fprintf(os.Stderr, "cf: %v\n", err)
              os.Exit(1)
            }
            f := tempconv.Fahrenheit(t)
            c := tempconv.Celsius(t)
            fmt.Printf("%s = %s, %s = %s\n",
              f, tempconv.FToC(f), c, tempconv.CToF(c))
          }
        }
      < src..

    La declaracion de importacion vincula un nombre corto al paquete importado
    que se puede utilizar para referirse a su contenido en todo el archivo. El
    @c(import) anterior nos permite referimos a nombres dentro de
    @c(gopl.io/ch2/tempconv) mediante el uso de un identificador calificado como
    @c(tempconv.CToF). Por defecto, el nombre corto es el nombre del paquete–en
    este caso @c(tempconv), pero una declaracion de importacion puede
    especificar un nombre alternativo para evitar un conflicto (@l(#Seccion
    10.3<>§10.3)).

    El programa @$(cf) convierte un unico argumento numerico de la linea de
    comando a su valor en grados Celsius y Fahrenheit:

    ..src > sh
      $ go build gopl.io/ch2/cf
      $ ./cf 32
      32°F = 0°C, 32°C = 89.6°F
      $ ./cf 212
      212°F = 100°C, 212°C = 413.6°F
      $ ./cf -40
      -40°F = -40°C, -40°C = -40°F
    < src..

    Es un error importar un paquete y luego no hacer referencia a el. Esta
    verificacion ayuda a eliminar las dependencias que se hacen innecesarias,
    cuando el codigo evoluciona, aunque puede ser una molestia durante la
    depuracion, ya que al comentar una linea de codigo como @c[log.Print("got
    here!")] puede eliminar la unica referencia al de nombre de paquete @c(log),
    probocando que el compilador emita un error. En esta situacion, es necesario
    comentar o eliminar el @c(import) innecesario.

    Mejor aun, utilice la herramienta @c(golang.org/x/tools/cmd/goimports), que
    inserta y elimina paquetes de la declaracion de importacion, segun sea
    necesario de forma automatica; la mayoria de los editores pueden
    configurarse para ejecutar @$(goimports) cada vez que se guarda un fichero.
    Al igual que la herramienta @$(gofmt), tambien imprime bonitos ficheros de
    codigo fuene en el formato canonico.

   @b(Ejercicio 2.2): Escribir un programa de proposito general para conversion
   de unidades analogo a @$(cf) que leea los numeros de sus argumentos de linea
   de comando o de la entrada estandar si no hay argumentos, y convierta cada
   numero en unidades como la temperatura en grados Celsius y Fahrenheit,
   longitud en Pies y metros, peso en libras y kilogramos y similares.

*** Seccion 2.6.2 <> Inicializacion del paquete

    La inicializacion del paquete comienza inicializando las variables a nivel
    de paquete en el orden en que se declaran, excepto que las dependencias se
    resuelven primero:

    ..src > go
      var a = b + c      // a inicializado tercero, a 3
      var b = f()        // b inicializado segundo, a 2, llamando a f
      var c = 1          // c inicializado primero, a 1

      func f() int { return c + 1 }
    < src..

    Si el paquete tiene multiples ficheros @f(.go), se inicializan en el orden
    en que se dan los archivos al compilador; La herramienta @$(go) ordena los
    ficheros @f(.go) archivos por nombre antes de invocar el compilador.

    Cada variable declarada en el nivel del paquete comienza su vida con el
    valor de su expresion de inicializador, pero para algunas variables, como
    tablas de datos, una expresion del inicializador no puede ser la manera mas
    simple de establecer su valor inicial. En ese caso, el mecanismo de la
    funcion @c(init) puede ser mas simple. Cualquier archivo puede contener
    cualquier numero de funciones cuya declaracion sea

    ..src > go
      func init() { /* ... */ }
    < src..

    No se puede llamar o hacer referencia a estas funciones @c(init), pero por
    lo demas son funciones normales. Dentro de cada archivo, las funciones
    @c(init) se ejecutan automaticamente cuando se inicia el programa, en el
    orden en que se declaran.

    Los paquetes se inician uno a la vez, en el orden de las importaciones en el
    programa, las dependencias en primer lugar, por lo que un paquete @c(p) que
    importa a @c(q) puede estar seguro de que @c(q) se inicializa completamente
    antes de la inicialiacion de @c(p). La inicializacion procede de abajo hacia
    arriba; el paquete @c(main) es el ultimo en ser inicializado. De esta
    manera, todos los paquetes se inicializan completamente antes de que inicie
    la funcion @c(main).

    El paquete a continuacion define una funcion @c(PopCount) que devuelve el
    numero de bits establecidos, es decir, los bits cuyo valor es 1, en un valor
    @c(uint64), que se llama @e(conteo de poblacion). Utiliza una funcion
    @c(init) para calcular previamente una tabla de resultados, @c(pc), para
    cada posible valor de 8 bits de modo que la funcion @c(PopCount) no necesite
    tomar 64 pasos, pero solo puede devolver la suma de ocho consultas de
    tabla. (Esto definitivamente no es el algoritmo mas rapido para el recuento
    de bits, pero es conveniente para ilustrar las funciones @c(init), y para
    mostrar como calcular previamente una tabla de valores, que a menudo es una
    tecnica de programacion util).

    ..figure > @l(gopl.io/ch2/popcount/main.go<>gopl.io/ch2/popcount)

      ..src > go
        package popcount

        // pc[i] es el recuento de poblacion de i.
        var pc [256]byte

        func init() {
          for i := range pc {
            pc[i] = pc[i/2] + byte(i&1)
          }
        }

        // PopCount regresa el conteo de la poblacion (numero de bist establecidos) de x.
        func PopCount(x uint64) int {
          return int(pc[byte(x>>(0*8))] +
            pc[byte(x>>(1*8))] +
            pc[byte(x>>(2*8))] +
            pc[byte(x>>(3*8))] +
            pc[byte(x>>(4*8))] +
            pc[byte(x>>(5*8))] +
            pc[byte(x>>(6*8))] +
            pc[byte(x>>(7*8))])
        }
      < src..


    Observe que el rango del bucle en @c(init) utiliza solo el indice; El valor
    es innecesario y por lo tanto no necesita ser incluido. El bucle tambien
    podria haber sido escrito como

    ..src > go
      i, _ := range pc {
    < src..

    Veremos otros usos de funciones @c(init) en la siguiente seccion y en la seccion
    @l(#Seccion 10.5).

    @b(Ejercicio 2.3): Vuelve a escribir @c(PopCount) para utilizar un bucle en
    lugar de una sola expresion. Compare el rendimiento de las dos versiones. La
    (@l(#Seccion 11.4) muestra como comparar el rendimiento de diferentes
    implementaciones de forma sistematica.)

    @b(Ejercicio 2.4): Escribe una version de @c(PopCount) que cuenta los bits
    desplazando su argumento a traves de posiciones de 64 bits, poniendo a
    prueba el bit mas a la derecha cada vez. Compare su rendimiento con la
    version de buesqueda por la tabla.

    @b(Ejercicio 2.5): La expresion @c&x&(x-1)] despeja el bit mas a la derecha
    no-cero de @c(x). Escribe una version de @c(PopCount) que cuente bits
    mediante este hecho, y evalua su rendimiento.

** Seccion 2.7 <> Alcance

   Una declaracion asocia un nombre a una entidad de programa, como una funcion
   o una variable. El @e(alcance) de una declaracion es la parte del codigo
   fuente, donde el uso de un nombre declarado hace referencia a esa
   declaracion.

   No confunda el alcance con el tiempo de vida. El alcance de una declaracion
   es una region del texto del programa; Es una propiedad de tiempo de
   compilacion. La vida util de una variable es el intervalo de tiempo durante
   la ejecucion cuando la variable puede ser referida por otras partes del
   programa; Es una propiedad en tiempo de ejecucion.

   Un @e(bloque) sintactico es una secuencia de sentencias encerradas entre
   llaves como las que rodean el cuerpo de una funcion o bucle. Un nombre
   declarado dentro de un bloque sintactico no es visible fuera de ese
   bloque. El bloque incluye sus declaraciones y determina su alcance. Podemos
   generalizar esta nocion de bloques para incluir otras agrupaciones de
   declaraciones que no estan explicitamente rodeadas por llaves en el codigo
   fuente; los llamaremos a todos @e(bloques lexicos). Hay un bloque lexico para
   todo el codigo fuente, llamado @e(bloque del universo); para cada paquete;
   para cada archivo; para cada sentencia @c(for), @c(if), y @c(switch); para
   cada caso en una sentencia @c(switch) o @c(select); Y, por supuesto, para
   cada bloque sintactico explicito.

   El bloque lexico de una declaracion determina su alcance, que puede ser
   grande o pequeño. Las declaracion de tipos nativos, funciones y constantes,
   por ejemplo @c(int), @c(len), y @c(true) estan en el bloque universo y pueden
   ser referidos a lo largo de todo el programa. Declaraciones fuera de
   cualquier funcion, es decir, a @e(nivel de paquete), puede ser refenciadas en
   cualquier archivo en el mismo paquete. Paquetes importados, como @c(fmt) en
   el ejemplo @c(tempconv), se declaran a @e(nivel de archivo), por lo que se
   puede hacer referencia a partir del mismo archivo, pero no desde otro archivo
   en el mismo paquete sin otro @c(import). Muchas declaraciones, como la de la
   variable @c(c) en la funcion @c(tempconv.CToF), son @e(locales), por lo que
   puden ser referidos solo desde dentro de la misma funcion o tal vez solo en
   una parte de ella.

   El alcance de una etiqueta de flujo de control, tal como se utiliza por las
   sentencias @c(break), @c(continue), y @c(goto), es toda la funcion que la
   rodea.

   Un programa puede contener varias declaraciones del mismo nombre, siempre y
   cuando cada declaracion este en un bloque lexico diferente. Por ejemplo,
   puede declarar una variable local con el mismo nombre que una variable a
   nivel de paquete. O, como se muestra en la @l(#Seccion 2.3.3), se puede
   declarar un parametro de funcion llamado @c(new), a pesar de tener una
   funcion con este nombre declarada con anterioridad en el bloque universo. No
   exagere, cuanto mayor sea el alcance de la redeclaracion, mas probable es que
   sorprenda al lector.

   Cuando el compilador encuentra una referencia a un nombre, busca una
   declaracion, comenzando con el bloque lexico interno mas cercano y explorando
   hasta el bloque universo. Si el compilador no encuentra ninguna declaracion,
   se informa de un error de @"(nombre no declarado.) Si se declara un nombre
   tanto en un bloque externo como en un bloque interno, se encontrara primero
   la declaracion interna. En ese caso, se dice que la declaracion interna
   @e(obscurese) u @e(ocultar) la exterior, por lo que es inaccesible:

   ..src > go
     func f() {}
     var g = "g"
     func main() {
       f := "f"
       fmt.Println(f) // "f"; la variable f local oculta la funcion f a nivel de paquete
       fmt.Println(g) // "g"; variable a nivel de paquete
       fmt.Println(h) // error de compilacion: sin definir: h
     }
   < src..

   Dentro de una funcion, los bloques lexicos pueden anidarse en una profundidad
   arbitraria, por lo que una declaracion local puede sombrear a otra. La
   mayoria de los bloques son creados por construcciones de flujo de control,
   como las declaraciones @c(if) y los bucles @c(for). El programa siguiente
   tiene tres variables distintas llamadas @c(x), ya que cada declaracion
   aparece en un bloque lexico diferente. (Este ejemplo ilustra las reglas de
   alcance, no es un buen estilo de programacion!)

   ..src > go
     func main() {
       x := "hello!"
       for i := 0; i < len(x); i++ {
         x := x[i]
         if x != '!' {
           x := x + 'A' - 'a'
           fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
         }
       }
     }
   < src..

   Las expresiones @c(x[i]) y @c(x + 'A' - 'a') se refieren cada una a una
   declaracion de @c(x) a partir de un bloque exterior; Lo explicaremos en un
   momento. (Tenga en cuenta que esta ultima expresion @e(no) es equivalente a
   @c(unicode.ToUpper)).

   Como se menciono anteriormente, no todos los bloques lexicos corresponden con
   secuencias delimitadas explicitamente por llaves; Algunos simplemente son
   implicitos. El bucle @c(for) anterior crea dos bloques lexicos: el bloque
   explicito para el cuerpo del bucle, y un bloque implicito que adicionalmente
   encierra las variables declaradas por la clausula de inicializacion, como
   @c(i). El alcance de una variable declarada en el bloque implicito es la
   condicion, post-declaracion (@c(i++)), y el cuerpo del comunicado @c(for).

   El siguiente ejemplo tambien tiene tres variables denominadas @c(x), cada una
   declarada en un bloque distinto–una en el cuerpo de la funcion, una en un
   bloque de sentencia @c(for) y uno en el cuerpo del bucle–pero solo dos de los
   bloques son explicitos:

   ..src > go
     func main() {
       x := "hello"
       for _, x := range x {
         x := x + 'A' - 'a'
         fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
       }
     }
   < src..

   Al igual que bucle @c(for), las declaraciones @c(if) y @c(switch) tambien
   crean un bloque implicito que, ademas del cuerpo de sus bloques. El codigo en
   la siguiente cadena @c(if)-@c(else) muestra el alcance de @c(x) y @c(y):

   ..src > go
     if x := f(); x == 0 {
       fmt.Println(x)
     } else if y := g(x); x == y {
       fmt.Println(x, y)
     } else {
       fmt.Println(x, y)
     }
     fmt.Println(x, y) // error de compilacion: x y y no son visibles aqui
   < src..

   La segunda declaracion @c(if) esta anidada dentro de la primera, por lo que
   las variables declaradas dentro de la inicializacion de la primer declaracion
   son visibles dentro de la segunda. Reglas similares se aplican a cada caso de
   una sentencia @c(switch): hay un bloque para la condicion y un bloque para
   cada cuerpo de caso.

   En el nivel de paquete, el orden en el que aparecen las declaraciones no
   tiene ningun efecto en su alcance, por lo que una declaracion puede referirse
   a si misma, o a otra que le sigue, permitiendonos declarar tipos y funciones
   recursivos o recursivos mutuamente. Sin embargo, el compilador reportara un
   error si una declaracion constante o variable se refiere a si misma.

   En este programa:

   ..src > go
     if f, err := os.Open(fname); err != nil { // error de compilacion: sin usar: f
       return err
     }
     f.ReadByte() // error de compilacion: f sin definir
     f.Close()    // error de compilacion: f sin definir
   < src..

   el alcance de @c(f) es solo la sentencia @c(if), por lo que @c(f) no es
   accesible a los estados que despues de enta, lo que resulta en errores de
   compilacion. Dependiendo del compilador, puede obtener un informe de errores
   adicional de que la variable local @c(f) nunca fue utilizada.

   Por lo tanto, a menudo es necesario declarar @c(f) antes de la condicion de modo
   que sea accesible mas tarde:

   ..src > go
     f, err := os.Open(fname)
     if err != nil {
       return err
     }
     f.ReadByte()
     f.Close()
   < src..

   Es posible que se sienta tentado a evitar declarar @c(f) y @c(err) en el
   bloque externo moviendo las llamadas a @c(ReadByte) y @c(Close) dentro del
   bloque @c(else):

   ..src > go
     if f, err := os.Open(fname); err != nil {
       return err
     } else {
       // f and err are visible here too
       f.ReadByte()
       f.Close()
     }
   < src..

   pero una practica normal en Go es tratar con el error en el bloque @c(if) y
   luego regresar, de modo que la ruta de ejecucion exitosa no este indentada.

   Las declaracion de variables compacta exige un conocimiento del
   alcance. Considere el siguiente programa, que comienza obteniendo su
   directorio de trabajo actual y guardandolo en una variable a nivel de
   paquete. Esto podria hacerse llamando a @c(os.Getwd) en la funcion @c(main),
   pero podria ser mejor separar esta preocupacion de la logica primaria, sobre
   todo si no podemos conseguir el directorio, es un error fatal. La funcion
   @c(log.Fatalf) imprime un mensaje y llama @c[os.Exit(1)].

   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // error de compilacion: sin usar: cwd
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..
  var cadena cwd

  Dado que ni @c(cwd) ni @c(err) se declaran en el bloque de la funcion
  @c(init), la sentencia @c(:=) declara ambas como variables locales. La
  declaracion interna de @c(cwd) hace que la externa sea inaccesible, por lo que
  la sentencia no actualiza la variable @c(cdw) de nivel de paquete como se
  pretende.

  Los compiladores de Go actuales detectan que la variable local @c(cwd) nunca
  se utilza e informar de esto como un error, pero no son estrictamente
  necesarias para llevar a cabo esta comprobacion. Por otra parte, un cambio
  menor, como la adicion de una declaracion de registro que se hace referencia a
  la @c(cwd) local, anularia la comprobacion.

   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // NOTA: incorrecto!
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
       log.Printf("Working directory = %s", cwd)
     }
   < src..

   La variable global @c(cwd) permanece sin inicializar, y la salida del
   registro aparentemente normal ofusca el fallo.

   Hay un numero de maneras de lidiar con este problema potencial. La mas
   directa es evitar @c(:=) declarando @c(err) en una declaracion @c(var)
   separada:

   ..src > go
     var cwd string

     func init() {
       var err error
       cwd, err = os.Getwd()
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..

   Hemos visto como los paquetes, archivos, declaraciones y declaraciones
   expresan la estructura de los programas. En los proximos dos capitulos,
   veremos la estructura de los datos.

* Capitulo 3 <> Tipos de datos basicos

  En el fondo todo son solo bits, por supuesto, pero las computadoras operan
  fundamentalmente en numeros de tamaño fijo llamados palabras, que se
  interpretan como numeros enteros, numeros de punto flotante, conjuntos de
  bits, o direcciones de memoria, que luego se combinana en agregados mas
  grandes que representan paquetes, pixeles, carteras, poesia y todo lo
  demas. Go ofrece una variedad de formas de organizar los datos, con un
  espectro de tipos de datos que en un extremo coinciden con las caracteristicas
  del hardware y en el otro extremo proporcionan lo que los programadores
  necesitan para representar convenientemente estructuras de datos complicadas.

  Los tipos de datos de Go se dividen en cuatro categorias: @e(tipos basicos),
  @e(tipos de agregados), @e(tipos de referencia), y @e(tipos de interfaz). Los
  tipos basicos, el tema de este capitulo, incluyen numeros, cadenas y
  booleanos. Los tipos agregados–arreglos (@l(#Seccion 4.1<>§4.1)) y estructuras
  (@l(#Seccion 4.4<>§4.4))–forma tipos de datos mas complejos mediante la
  combinacion de otros valores mas simples. Los tipos de referencia son un grupo
  diverso, que incluye punteros (@l(#Seccion 2.3.2<>§2.3.2)), slices
  (@l(#Seccion 4.2<>§4.2)), mapas (@l(#Seccion 4.3<>§4.3)), funciones
  (@l(#Capitulo 5)), y canales (@l(#Capitulo 8)), pero lo que tienen en comun es
  que se todos ellos se refieren a variables del programa o estados
  indirectamente, por lo que el efecto de una operacion que se aplica a una
  referencia es observado por todas las copias de esa referencia. Por ultimo,
  hablaremos de los tipos de interfaz en el @l(#Capitulo 7).

** Seccion 3.1 <> Enteros

   Los tipos de datos numericos de Go incluyen varios tamaños de enteros,
   numeros de coma flotante y numeros complejos. Cada tipo numerico determina el
   tamaño y la firma de sus valores. Comencemos con numeros enteros.

   Go proporciona tanto aritmetica con y sin signo. Hay cuatro tamaños distintos
   de numeros enteros–8, 16, 32 y 64 bits–representados por los tipos @c(int8),
   @c(int16), @c(int32), y @c(int64), y las correspondientes versiones sin signo
   @c(uint8), @c(uint16), @c(uint32), y @c(uint64).

   Tambien hay dos tipos llamados simplemente @c(int) y @c(uint) que son del
   tamaño natural o mas eficiente para los numeros enteros con y sin signo en
   una plataforma en particular; @c(int) es de lejos el tipo numerico mas
   utilizado. Ambos tipos tienen el mismo tamaño, 32 o 64 bits, pero uno no debe
   hacer suposiciones sobre cual es; Diferentes compiladores pueden tomar
   diferentes opciones incluso en hardware identico.

   El tipo @c(rune) es un sinonimo de @c(int32) y convencionalmente indica que
   un valor es un punto de codigo Unicode. Los dos nombres pueden utilizarse
   indistintamente. Del mismo modo, el tipo de @c(byte) es un sinonimo de
   @c(uint8), y hace hincapie en que el valor es una pieza de datos en bruto mas
   que una pequeña cantidad numerica.

   Por ultimo, existe un tipo entero sin signo @c(uintptr), cuya anchura no se
   especifica, pero es suficiente para contener todos los bits de un valor de
   puntero. El tipo @c(uintptr) solo se utiliza para la programacion a bajo
   nivel, por ejemplo, en el limite de un programa Go con una libreria C o un
   sistema operativo. Veremos ejemplos de esto cuando nos ocupemos del paquete
   @c(unsafe) en el @l(#Capitulo 13).

   Independientemente de su tamaño, @c(int), @c(uint) y @c(uintptr) son
   diferentes tipos de sus hermanos de tamaño de forma explicita. Por lo tanto
   @c(int) no es el mismo tipo que @c(int32), incluso si el tamaño natural de
   enteros es de 32 bits, y requiere una conversion explicita utilizar un valor
   @c(int) donde se necesita un @c(int32), y viceversa.

   Numeros con signo se representan en forma de complemento a 2, en el que el
   bit de orden superior esta reservado para el signo del numero y la gama de
   valores de un numero de @m(n) bits es de -2ⁿ⁻¹ a 2ⁿ⁻¹-1. Los numeros enteros
   sin signo usan el rango completo de bits para valores no negativos y por lo
   tanto tienen el rango de 0 a 2ⁿ-1. Por ejemplo, la gama de @c(int8) entre
   -128 y 127, mientras que la gama de @c(uint8) es de 0 a 255.

   En Go Los operadores binarios de aritmetica, logica y comparacion se enumeran
   aqui en orden decreciente de precedencia:

   ..pre >
     *   /   %  <<  >>  &   &^
     +   -   |  ^
     ==  !=  <  <=  >   >=
     &&
     ||
   < pre..

   Solo hay cinco niveles de precedencia para los operadores binarios. Los
   operadores en el mismo nivel se asocian a la izquierda, por lo que pueden ser
   necesarios parentesis, para mayor claridad, o para hacer que los operadores
   evaluan en el orden deseado en una expresion como @c[mask & (1 << 28)].

   Cada operador en las dos primeras lineas de la tabla anterior, por ejemplo
   @c(+), tiene un operador de asignacion correspondiente como @c(+=) que pueden
   utilizarse para abreviar una instruccion de asignacion.

   Los operadores aritmetica enteros @c(+), @c(-), @c(*), y @c(/) pueden
   aplicarse a numeros enteros, de coma flotante, y numeros complejos, pero el
   operador @c(%) solo se aplica a numeros enteros. El comportamiento de @c(%)
   para los numeros negativos varia a traves de los lenguajes de
   programacion. En Go, el signo del resto es siempre el mismo que el signo del
   dividendo, por lo @c(-5%3) y @c(-5%-3) son ambos @c(-2). El comportamiento de
   @c(/) depende de si sus operandos son numeros enteros, por lo que @c(5.0/4.0)
   es @c(1.25), pero @c(5/4) es @c(1) porque la division entera trunca el
   resultado hacia cero.

   Si el resultado de una operacion aritmetica, ya sea con o sin signo, tiene
   mas bits de los que pueden ser representados en el tipo del resultado, se
   dice que se @e(desborda). Los bits de orden superior que no encajan se
   descartan silenciosamente. Si el numero original es un tipo con signo, el
   resultado podria ser negativo si el bit mas a la izquierda es un 1, como en
   el @c(int8) ejemplo aqui:

   ..src > go
     var u uint8 = 255
     fmt.Println(u, u+1, u*u) // "255 0 1"

     var i int8 = 127
     fmt.Println(i, i+1, i*i) // "127 -128 1"
   < src..

   Dos numeros enteros del mismo tipo pueden compararse usando los operadores de
   comparacion binarios siguientes; El tipo de una expresion de comparacion es
   un booleano.

   | @c(==) | igual a             |
   |--------|---------------------|
   | @c(!=) | no igual a          |
   |--------|---------------------|
   | @c(<)  | menor que           |
   |--------|---------------------|
   | @c(<=) | Menor que o igual a |
   |--------|---------------------|
   | @c(>)  | mayor que           |
   |--------|---------------------|
   | @c(>=) | Mayor que o igual a |

   De hecho, todos los valores de tipo basico–booleanos, numeros y cadenas–son
   comparables, lo que significa que dos valores del mismo tipo pueden ser
   comparados con los operadores @c(==) y @c(!=). Por otra parte, los numeros
   enteros, numeros de punto flotante y cadenas son @e(ordenados) por los
   operadores de comparacion. Los valores de muchos otros tipos no son
   comparables y no se ordenan otros tipos. A medida que nos encontramos cada
   tipo, vamos a presentar las normas que rigen la comparacion de sus valores.

   Tambien hay operadores unarios de suma y resta:

   | @c(+) | Unario positivo (sin efecto) |
   |-------|------------------------------|
   | @c(-) | Negacion unaria              |

   Para enteros, @c(+x) es una abreviatura de @c(0+x) y @c(-x) es una
   abreviatura de @c(0-x); para los numeros de punto flotante y complejos,
   @c(+x) es @c(x) y @c(-x) es la negacion de @c(x).

   Go tambien proporciona los siguientes operadores binarios a nivel de bits,
   cuyos cuatro primeros tratan a sus operandos como patrones de bits sin ningun
   concepto aritmetico o signo:

   | @c(&)  | AND bit a bit                 |
   |--------|-------------------------------|
   | @c(|)  | OR bit a bit                  |
   |--------|-------------------------------|
   | @c(^)  | XOR bit a bit                 |
   |--------|-------------------------------|
   | @c(&^) | AND NOT                       |
   |--------|-------------------------------|
   | @c(<<) | desplazamiento a la izquierdo |
   |--------|-------------------------------|
   | @c(>>) | desplazamiento a la derecha   |

   El operador bit a bit @c(^) es un OR exclusivo (XOR) cuando se utiliza como
   un operador binario (coloca un uno en cada posicion en donde sus operandos
   tienen bits distintos, y un cero en donde son iguales), pero cuando se
   utiliza como un operador de prefijo unario es el complemento a uno; es decir,
   devuelve un valor con cada bit en su operando invertido. El operador @c(&^)
   es para lipiar bits (AND NOT): en la expresion @c(z = x &^ y), cada bit de
   @c(z) es 0 si el bit correspondiente de @c(y) es 1; de lo contrario es igual
   al bit correspondiente de @c(x).

   El siguiente codigo muestra como se pueden utilizar las operaciones a nivel
   de bit para interpretar un valor @c(uint8) como un conjunto compacto y
   eficiente de 8 bits independientes. Se utiliza el verbo @c(%b) de @c(Printf)
   para imprimir los digitos binarios de un numero; @c(08) modifica @c(%b) (un
   adverbio!)  para rellenar el resultado con ceros a exactamente 8 digitos.

   ..src > go
     package main

     import "fmt"

     func main(){
       var x uint8 = 1<<1 | 1<<5
       var y uint8 = 1<<1 | 1<<2

       fmt.Printf("%08b\n", x)    // "00100010", el conjunto {1, 5}
       fmt.Printf("%08b\n", y)    // "00000110", el conjunto {1, 2}
       fmt.Printf("%08b\n", x&y)  // "00000010", la interseccion {1}
       fmt.Printf("%08b\n", x|y)  // "00100110", la union {1, 2, 5}
       fmt.Printf("%08b\n", x^y)  // "00100100", la diferencia simetrica {2, 5}
       fmt.Printf("%08b\n", x&^y) // "00100000", la diferencia {5}

       for i := uint(0); i < 8; i++ {
         if x&(1<<i) != 0 { // prueba de pertenencia
           fmt.Println(i)   // "1", "5"
         }
       }

       fmt.Printf("%08b\n", x<<1) // "01000100", el conjunto {2, 6}
       fmt.Printf("%08b\n", x>>1) // "00010001", el conjunto {0, 4}
     }
   < src..

   (La @l(#Seccion 6.5) muestra una implementacion de conjuntos de numeros
   enteros que pueden ser mucho mas grande que un byte).

   En las operaciones de desplazamiento @c(x<<n) y @c(x>>n), el operando @c(n)
   determina el numero de posiciones de bits a cambiar y debe ser sin signo; el
   operando @c(x) puede tener o no signo. Aritmeticamente, el desplazamiento a
   la izquierda @c(x<<n) es equivalente a la multiplicacion por 2ⁿ y un
   desplazamiento a la derecha @c(x>>n) es equivalente a dividir por 2ⁿ.

   Los desplazamientos a la izquierda o derecha en enteros sin singno llenan los
   bits desocupados con ceros, pero los desplazamientos a la derecha de numeros
   con signo llenan los bits desocupados con copias del bit de signo. Por esta
   razon, es importante utilizar aritmetica sin signo cuando se esta tratando un
   entero como un patron de bits.

   Aunque Go proporciona aritmetica y numeros sin signo, se tiende a utilizar un
   int con signo incluso para cantidades que no pueden ser negativas, tales como
   la longitud de un arreglo, aunque @c(uint) puede parecer una eleccion mas
   obvia. De hecho, la funcion nativa @c(len) devuelve un @c(int) con signo,
   como en este bucle que anuncia medallas de premio en el orden inverso:

   ..src > go
     medallas := []string{"oro", "plata", "bronce"}
     for i := len(medallas) - 1; i >= 0; i-- {
       fmt.Println(medallas[i]) // "bornce", "plata", "oro"
     }
   < src..

   La alternativa seria calamitosa. Si @c(len) devuelve un numero sin signo,
   entonces @c(i) tambien seria un @c(uint), y la condicion @c(i >= 0) siempre
   seria verdadera por definicion. Despues de la tercera iteracion, en la cual
   @c(i == 0), la instruccion @c(i--) no haria que @c(i) se volviera -1, en
   cambion seria el valor maximo de @c(uint) (es decir, 2⁶⁴-1), y la evaluacion
   de @c(medallas[i]) fallaria en tiempo de ejecucion, o de @e(panico)
   (@l(#Seccion 5.9<>§5.9)), al tratar de acceder a un elemento fuera de los
   limites del slice.

   Por esta razon, los numeros sin signo tienden a utilizarse solo cuando se
   requieren sus operadores bit a bit u operadores aritmeticos peculiares, como
   cuando se implementan conjuntos de bits, se analizan formatos binarios de
   archivos o se usan hash y criptografia. Normalmente no se usan para
   cantidades meramente no negativas.

   En general, se requiere una conversion explicita para convertir un valor de
   un tipo a otro, y los operadores binarios para aritmetica y logica (excepto
   los desplazamientos) deben tener operandos del mismo tipo. Aunque esto
   resulta ocasionalmente en expresiones mas largas, tambien elimina toda una
   clase de problemas y hace que los programas sean mas faciles de entender.

   Como ejemplo familiar de otros contextos, considere esta secuencia:

   ..src > go
     var manzanas int32 = 1
     var naranjas int16 = 2
     var compota int = manzanas + naranjas // Error de compiacion
   < src..

   Al intentar compilar estas tres declaraciones se genera un mensaje de error:

   ..pre >
     invalid operation: manzanas + naranjas (mismatched types int32 and int16)
   < pre..

   Este tipo de incompatibilidad se puede corregir de varias maneras, mas
   directamente convirtiendo todo a un tipo comun:

   ..src > go
     var compota = int(manzanas) + int(naranjas)
   < src..

   Como se describe en la @l(#Seccion 2.5), para cada tipo @c(T), la operacion
   de conversion @c[T(x)] convierte el valor @c(x) a tipo @c(T) si se permite la
   conversion. Muchas conversiones de entero a entero no implican ningun cambio
   en el valor; Solo le dicen al compilador como interpretar un valor. Pero una
   conversion que reduce un entero grande a uno mas pequeño o una conversion de
   entero a punto flotante o viceversa, puede cambiar el valor o perder
   precision:

   ..src > go
     f := 3.141          // un float64
     i := int(f)
     fmt.Println(f, i)   // "3.141 3"
     f = 1.99
     fmt.Println(int(f)) // "1"
   < src..

   La conversion de float a entero descarta cualquier parte fraccional,
   truncando hacia cero. Debe evitar las conversiones en las que el operando
   este fuera del rango del tipo destino, ya que el comportamiento depende de la
   implementacion:

   ..src > go
     f := 1e100  // un float64
     i := int(f) // el resultado depende de la implementacion
   < src..

   Los literales enteros de cualquier tamaño y tipo se pueden escribir como
   numeros decimales ordinarios, o bien con numeros octales si comienzan con
   @c(0), como en @c(0666), o como hexadecimal si comienzan con @c(0x) o @c(0X),
   como en @c(0xdeadbeef). Los digitos hexadecimales pueden ser mayusculas o
   minusculas. Hoy en dia los numeros octales parecen ser utilizados para
   exactamente un proposito–permisos de archivo en sistemas POSIX–pero los
   numeros hexadecimales se utilizan ampliamente para enfatizar el patron de
   bits de un numero sobre su valor numerico.

   Al imprimir numeros usando el paquete @c(fmt), podemos controlar la base y el
   formato con los verbos @c(%d), @c(%o), y @c(%x), como se muestra en este
   ejemplo:

   ..src > go
     o := 0666
     fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
     x := int64(0xdeadbeef)
     fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
     // Salida:
     // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
   < src..

   Observe el uso de dos trucos de @c(fmt). Por lo general, una cadena de
   formato @c(Printf) que contiene multiples verbos @c(%) requeriria el mismo
   numero de operandos adicionales, pero los @"(adverbios) @c([1]) despues de
   @c(%) le indican a @c(Printf) utilizar el primer operando una y otra vez. En
   segundo lugar, el adverbio @c(#) enr @c(%o) o @c(%x) o @c(%X) indica a
   @c(Printf) emitir un prefijo @c(0) o @c(0x) o @c(0X) respectivamente.

   Las literales de runa se escriben como un caracter entre comillas
   simples. El ejemplo mas simple es un caracter ASCII como @c('a'), pero es
   posible escribir cualquier punto de codigo Unicode directamente o con escapes
   numericos, como veremos en breve.

   Las runas se imprimen con @c(%c), o con @c(%q) si se desea citar:

   ..src > go
     ascii := 'a'
     unicode := '𢉩'
     newline := '\n'
     fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 un 'a'"
     fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 𢉩 '𢉩'"
     fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
   < src..

** Seccion 3.2 <> Numeros de punto flotante

   Go ofrece dos tamaños de numeros de punto flotante, @c(float32) y
   @c(float64). Sus propiedades aritmeticas se rigen por el estandar IEEE 754
   implementado por todas las CPUs modernas.

   Los valores de estos tipos numericos varian de pequeño a enorme. Los limites
   de valores de coma flotante se pueden encontrar en el paquete @c(math). La
   constante @c(math.MaxFloat32), el mayor valor de @c(float32), es cerca de
   @c(3.4e38) y @c(math.MaxFloat64) es @c(1.8e308). Los valores positivos mas
   pequeños son @c(1.4e-45) y @c(4.9e-324), respectivamente.

   Un @c(float32) proporciona aproximadamente seis digitos decimales de
   precision, mientras que un @c(float64) proporciona alrededor de 15 digitos;
   @c(float64) debe ser preferido para la mayoria de los propositos porque los
   calculos sobre @c(float32) acumulan errores rapidamente a menos que sea
   bastante cuidadoso, y el numero entero positivo mas pequeño que no se puede
   representar exactamente como @c(float32) no es grande:

   ..src > go
     var f float32 = 16777216 // 1 << 24
     fmt.Println(f == f+1)    // "true"!
   < src..

   Los numeros de punto flotante se pueden escribir literalmente usando
   decimales, asi:

   ..src > go
     const e = 2.71828 // (aproximadamente)
   < src..

   Pueden omitirse los digitos antes del punto decimal (@c(.707)) o despues de
   el (@c(1.)). Es mejor escribir numeros muy pequeños o muy grandes en notacion
   cientifica, con la letra @c(e) o @c(E) precediendo el exponente decimal:

   ..src > go
     const Avogadro = 6.02214129e23
     const Planck   = 6.62606957e-34
   < src..

   Los Valores de coma flotante se imprimen convenientemente con el verbo @c(%g)
   de @c(Printf), que elige la representacion mas compacta con la precision
   adecuada, pero para las tablas de datos, es mas adecuado el formato @c(%e)
   (exponente) o %f (sin exponente). Los tres verbos permiten controlar el ancho
   del campo y la precision numerica.

   ..src > go
     for x := 0; x < 8; x++ {
       fmt.Printf("x = %d eˣ = %8.3f\n", x, math.Exp(float64(x)))
     }
   < src..

   El codigo anterior imprime las potencias de @e(e) con tres digitos decimales
   de precision, alineados en un campo de ocho caracteres:

   ..pre >
     x = 0 eˣ =    1.000
     x = 1 eˣ =    2.718
     x = 2 eˣ =    7.389
     x = 3 eˣ =   20.086
     x = 4 eˣ =   54.598
     x = 5 eˣ =  148.413
     x = 6 eˣ =  403.429
     x = 7 eˣ = 1096.633

   Ademas de una gran coleccion de las funciones matematicas comunes, el paquete
   @c(math) tiene funciones para crear y detectar los valores especiales
   definidas por IEEE 754: los infinitos positivo y negativo, que representan
   los numeros de magnitud excesiva y el resultado de la division por cero; y
   NaN (@"(not a number)), el resultado de operaciones matematicamente dudosas
   como @c(0/0) o @[Sqrt(-1)].

   ..src > go
     var z float64
     fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
   < src..

   La funcion @c(math.IsNaN) prueba si su argumento es un valor no-numerico, y
   @c(math.NaN) devuelve ese valor. Es tentador utilizar NaN como un valor
   centinela en un calculo numerico, pero probar si el resultado de un calculo
   especifico es igual NaN esta lleno de peligros, ya que cualquier comparacion
   con NaN @e(siempre) produce @c(false):

   ..src > go
     nan := math.NaN()
     fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
   < src..

   Si una funcion que devuelve un resultado de coma flotante puede fallar, es
   mejor informar el error por separado, como aqui:

   ..src > go
     func compute() (value float64, ok bool) {
       // ...
       if failed {
         return 0, false
       }
       return result, true
     }
   < src..

   El siguiente programa ilustra el calculo de graficos en coma flotante. Se
   traza una funcion de dos variables @c[z = f(x, y)] como una superficie de
   malla de alambre 3-D, utilizando graficos vectoriales escalables (SVG), en
   notacion XML estandar para dibujos lineales. La Figura 3.1 muestra un ejemplo
   de salida de la funcion @c[sin(r)/r], donde @c(r) es @c[sqrt(x*x+y*y)].

   ..figure > Figura 3.1. Un grafico superficial de la funcion @c[sin(r)/r].

     ..img > img/Figure-3.1.jpg


   ..figure > @l(gopl.io/ch3/surface/main.go<>gopl.io/ch3/surface)

     ..src > go
       // Surface calcula una representacion SVG de una funcion de superficie 3D
       package main

       import (
         "fmt"
         "math"
       )

       const (
         width, height = 600, 320            // tamaño de la superficie en pixeles
         cells         = 100                 // numero de celdas de la cuadricula
         xyrange       = 30.0                // ejes (-xyrange..+xyrange)
         xyscale       = width / 2 / xyrange // pixeles por unidad x o y
         zscale        = height * 0.4        // pixeles por unidad z
         angle         = math.Pi / 6         // angulo de ejes x, y (=30°)
       )

       var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)

       func main() {
         fmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+
           "style='stroke: grey; fill: white; stroke-width: 0.7' "+
           "width='%d' height='%d'>", width, height)
         for i := 0; i < cells; i++ {
           for j := 0; j < cells; j++ {
             ax, ay := corner(i+1, j)
             bx, by := corner(i, j)
             cx, cy := corner(i, j+1)
             dx, dy := corner(i+1, j+1)
             fmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
               ax, ay, bx, by, cx, cy, dx, dy)
           }
         }
         fmt.Println("</svg>")
       }

       func corner(i, j int) (float64, float64) {
         // Hallar el punto (x,y) en la esquina de la celda (i,j).
         x := xyrange * (float64(i)/cells - 0.5)
         y := xyrange * (float64(j)/cells - 0.5)

         // Calcular la altura de la superficie z.
         z := f(x, y)

         // Proyeccion isometrica (x,y,z) sobre superficie SVG 2-D (sx,sy).
         sx := width/2 + (x-y)*cos30*xyscale
         sy := height/2 + (x+y)*sin30*xyscale - z*zscale
         return sx, sy
       }

       func f(x, y float64) float64 {
         r := math.Hypot(x, y) // distancia de (0,0)
         return math.Sin(r) / r
       }
     < src..


   Observe que la esquina de funcion devuelve dos valores, las coordenadas de la
   esquina de la celda.

   La explicacion de como funciona el programa requiere solo geometria basica,
   pero esta bien pasarla por alto, ya que el punto es ilustrar la computacion
   de punto flotante. La esencia del programa es el mapeo entre tres sistemas de
   coordenadas diferentes, como se muestra en la Figura 3.2. La primera es una
   red de 2D de 100 y 100 celdas identificadas por coordenadas enteras @m[(i,
   j)], a partir de @m[(0, 0)] en la esquina mas lejanas. Trazamos desde la
   parte posterior al frente de modo que los poligonos del fondo puedan ser
   oscurecidos por los primeros.

   El segundo sistema de coordenadas es una malla de coordenadas 3-D de punto
   flotante @m[(x, y, z)], donde @m(x) e @m(y) son funciones lineales de @m(i) y
   @m(j), traducido de manera que el origen esta en el centro, y escalado por la
   constante @c(xyrange). La altura @m(z) es el valor de la funcion de
   superficie @m[ƒ(x, y)].

   El tercer sistema de coordenadas es la superficie 2-D de la imagen, con
   @m[(0, 0)] en la esquina superior izquierda. Los puntos en este plano se
   denotan @m[(sx, sy)]. Utilizamos una proyeccion isometrica para correlacionar
   cada punto 3D

   ..figure > Figura 3.2. Tres sistemas de coordenadas diferentes.

     ..img > img/Figure-3.2.jpg


   @m[(x, y, z)] sobre la superficie 2-D. Un punto aparece mas a la derecha en
   la superficie cuanto mayor sera su valor @m(x) o menor sea su valor @m(y). Y
   un punto aparece mas abajo en la superficie cuanto mayor sera su valor @m(x)
   o el valor @m(y), y cuanto menor sea su valor @m(z). Los factores de escala
   horizontal o vertical para @m(x) e @m(y) se derivan del seno y coseno de un
   angulo de 30°. El factor de escala para @m(z), 0.4, es un parametro
   arbitrario.

   Para cada celda de la cuadricula 2-D, la funcion principal calcula las
   coordenadas en la superficie de imagen de las cuatro esquinas del poligono
   ABCD, donde B corresponde a @m[(i, j)] y A, C, y D son sus vecinos, entonces
   imprime una instruccion SVG para dibujarla.

   @b(Ejercicio 3.1): Si la funcion @c(f) devuelve un valor @c(float64)
   no-finito, el archivo SVG contendra elementos @c(<polygon>) no validos
   (aunque muchos procesadores SVG manejan esto con gracia). Modifique el
   programa para omitir poligonos no validos.

   @b(Ejercicio 3.2): Experimente con visualizaciones de otras funciones del
   paquete @c(math). ¿Puede usted producir una caja de huevos, moguls, o una
   montura?

   @b(Ejercicio 3.3): El color de cada poligono en funcion de su altura, por lo
   que los picos son de color rojo (@c(#ff0000)) y los valles azul
   (@c(#0000ff)).

   @b(Ejercicio 3.4): Siguiendo el enfoque del ejemplo Lissajous en la
   @l(#Seccion 1.7), construya un servidor web que calcule superficies y escriba
   los datos SVG al cliente. El servidor debe establecer el manejador
   @c(Content-Type) asi:

   ..src > go
     w.Header().Set("Content-Type", "image/svg+xml")
   < src..

   (Este paso no era necesario en el ejemplo de Lissajous porque el servidor
   utiliza la heuristica estandar para reconocer formatos comunes como PNG de
   los primeros 512 bytes de la respuesta y generar el encabezado
   adecuado). Permitir al cliente especificar valores como altura, ancho y color
   como parametros de peticion HTTP.

** Seccion 3.3 <> Numeros complejos

   Go proporciona dos tamaños de numeros complejos, @c(complex64) y
   @c(complex128), cuyos componentes son @c(float32) y @c(float64)
   respectivamente. La funcion nativa @c(complex) crea un numero complejo a
   partir de sus componentes real e imaginario, e incorpora funciones @c(real) y
   @c(imag) para extraer estos componentes:

   ..src > go
     var x complex128 = complex(1, 2) // 1+2i
     var y complex128 = complex(3, 4) // 3+4i
     fmt.Println(x*y)                 // "(-5+10i)"
     fmt.Println(real(x*y))           // "-5"
     fmt.Println(imag(x*y))           // "10"
   < src..

   Si un punto flotante literal entero o decimal literal es seguido
   inmediatamente por @c(i), como @c(3.141592i) o @c(2i), se convierte en un
   literal imaginario, que denota un numero complejo con un componente real
   cero:

   ..src > go
     fmt.Println(1i * 1i) // "(-1+0i)", i² = -1
   < src..

   Bajo las reglas de la aritmetica constante, constantes complejas se pueden
   añadir a otras constantes (enteras o de coma flotante, real o imaginarias),
   lo que nos permite escribir numeros complejos de forma natural, como
   @c(1+2i), o equivalentemente, @c(2i+1) . Las anteriores declaraciones @c(x) y
   @c(y) se pueden simplificar:

   ..src > go
     x := 1 + 2i
     y := 3 + 4i
   < src..

   Los numeros complejos se pueden comparar por igualdad con @c(==) y
   @c(!=). Dos numeros complejos son iguales si sus partes reales son iguales y
   sus partes imaginarias son iguales.

   El paquete @c(math/cmplx) proporciona funciones de libreria para trabajar con
   numeros complejos, tales como las raiz cuadrada compleja y las funciones de
   exponenciacion.

   ..src > go
     fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"
   < src..

   El siguiente programa utiliza aritmetica @c(complex128) para generar un
   conjunto de Mandelbrot.

   ..figure > @l(gopl.io/ch3/mandelbrot/main.go<>gopl.io/ch3/mandelbrot)

     ..src > go
       // Mandelbrot emite una imagen PNG del fractal de Mandelbrot.
       package main

       import (
         "image"
         "image/color"
         "image/png"
         "math/cmplx"
         "os"
       )

       func main() {
         const (
           xmin, ymin, xmax, ymax = -2, -2, +2, +2
           width, height          = 1024, 1024
         )

         img := image.NewRGBA(image.Rect(0, 0, width, height))
         for py := 0; py < height; py++ {
           y := float64(py)/height*(ymax-ymin) + ymin
           for px := 0; px < width; px++ {
             x := float64(px)/width*(xmax-xmin) + xmin
             z := complex(x, y)
             // El punto de imagen (px, py) representa el valor complejo z.
             img.Set(px, py, mandelbrot(z))
           }
         }
         png.Encode(os.Stdout, img) // NOTA: ignorando errores
       }

       func mandelbrot(z complex128) color.Color {
         const iterations = 200
         const contrast = 15

         var v complex128
         for n := uint8(0); n < iterations; n++ {
           v = v*v + z
           if cmplx.Abs(v) > 2 {
             return color.Gray{255 - contrast*n}
           }
         }
         return color.Black
       }
     < src..


   Los dos bucles anidados iteran sobre cada punto en una imagen en cuadricula
   de escala de grises de 1024x1024 que representa la porcion de -2 a +2 del
   plano complejo. El programa prueba si repetidamente cuadrando y añadiendo el
   numero del punto representado eventualmente @"(escapa) el circulo de
   radio 2. Si es asi, el punto es sombreado por el numero de iteraciones que se
   tardo en escapar. Si no, el valor pertenece al conjunto de Mandelbrot, y el
   punto permanece negro. Finalmente, el programa escribe en su salida estandar
   la imagen codificada en PNG del iconico fractal, que se muestra en la Figura
   3.3.

   ..figure > Figura 3.3. El conjunto de Mandelbrot.

     ..img > img/Figure-3.3.jpg


   @b(Ejercicio 3.5): Implementar a todo color el cojunto de Mandelbrot usando
   la funcion @c(image.NewRGBA) y el tipo @c(color.RGBA) o @c(color.YCbCr).

   @b(Ejercicio 3.6): Supermuestreo es una tecnica para reducir el efecto de
   pixelacion calculando el valor del color en varios puntos dentro de cada
   pixel y tomando el promedio. El metodo mas simple consiste en dividir cada
   pixel en cuatro @"(subpixeles.) Implementalo.

   @b(Ejercicio 3.7): Otro fractal sencillo utiliza el metodo Newton para
   encontrar soluciones complejas a una funcion como @m(z⁴-1 = 0). Sombrea cada
   punto de partida por el numero de iteraciones necesarias para acercarse a una
   de las cuatro raices. Colorea cada punto por la raiz que se aproxima.

   @b(Ejercicio 3.8): La Representacion de fractales con altos niveles de zoom
   exige una gran precision aritmetica. Implementa el mismo fractal utilizando
   cuatro representaciones diferentes de numeros: @c(complex64), @c(complex128),
   @c(big.Float), y @c(big.Rat). (Los ultimos dos tipos se encuentran en el
   paquete @c(math/big). @c(Float) utiliza arbitraria, pero delimitada precision
   de punto flotante; @c(Rat) utiliza numeros racionales sin limites de
   precision.)  ¿Como se comparan en el rendimiento y uso de memoria? ¿A que
   niveles de zoom se hacen visibles los artefactos de renderizacion?

   @b(Ejercicio 3.9): Escriba un servidor web que procese fractales y escribe
   los datos de imagen al cliente. Permita que el cliente especifique las
   coordenadas @c(x), @c(y), y los valores de zoom como parametros en la
   peticion HTTP.

** Seccion 3.4 <> Booleanos

   Un valor de tipo @c(bool), o @e(booleano), tiene solo dos valores posibles,
   @c(true) y @c(false). Las condiciones en @c(if) y @c(for) son declaraciones
   booleanas, y los operadores de comparacion como @c(==) y @c(<) producen un
   resultado booleano. El operador unario @c(!) es la negacion logica, de modo
   que @c(!true) es @c(false), o, por decirlo asi, @c[(!true==false)==true],
   aunque por cuestion de estilo, siempre simplificamos las expresiones
   booleanas redundantes como @c(x==true) a @c(x).

   Los valores booleanos pueden ser combinados con los operadores @c(&&) (AND) y
   @c(||) (OR), que tienen un comportamiento de @e(cortocircuito): si la
   respuesta ya esta determinada por el valor del operando de la izquierda, el
   operando de la derecha no se evalua, por lo que es seguro para escribir
   expresiones como esta:

   ..src > go
     s != "" && s[0] == 'x'
   < src..

   donde @c(s[0]) produciria un panico si se aplica a una cadena vacia.

   Ya que @c(&&) tiene mayor precedencia que @c(||) (mnemonico: @c(&&) es la
   multiplicacion booleana, @c(||) es la adicion boolean), no se requieren
   parentesis para las condiciones de esta forma:

   ..src > go
     if 'a' <= c && c <= 'z' ||
       'A' <= c && c <= 'Z' ||
       '0' <= c && c <= '9' {
       // ...letra o digito ASCII...
     }
   < src..

   No hay una conversion implicita de un valor booleano a un valor numerico como
   0 o 1, o viceversa. Es necesario utilizar un @c(if) explicito, como en

   ..src > go
     i := 0
     if b {
       i = 1
     }
   < src..

   Podria valer la pena escribir una funcion de conversion si esta operacion se
   necesita a menudo:

   ..src > go
     // btoi regresa 1 si b es verdadero y 0 sy es falso.
     func btoi(b bool) int {
       if b {
         return 1
       }
       return 0
     }
   < src..

   La operacion inversa es tan simple que no necesita una funcion, pero por
   simetria aqui esta:

   ..src > go
     // itob reporta cuando i no es cero.
     func itob(i int) bool { return i != 0 }
   < src..

** Seccion 3.5 <> Cadenas

   Una cadena es una secuencia inmutable de bytes. Las cadenas pueden contener
   datos arbitrarios, incluyendo bytes con valor 0, pero normalmente contienen
   texto legible por humanos. Las cadenas de texto se interpretan de forma
   convencional como secuencias codificadas en UTF-8 de puntos de codigo Unicode
   (runas), que exploraremos en detalle muy pronto.

   La funcion nativa @c(len) devuelve el numero de bytes (no runas) en una
   cadena, y la operacion de indice @c(s[i]) recupera el @m(n)-esimo byte de la
   cadena @c(s), donde @c(0) ≤ @c(i) < @c[len(s)].

   ..src > go
     s := "hello, world"
     fmt.Println(len(s))     // "12"
     fmt.Println(s[0], s[7]) // "104 119"  ('h' and 'w')
   < src..

   Intentar acceder a un byte fuera de este rango produce un panico:

   ..src > go
     c := s[len(s)] // panico: indice fuera de rango
   < src..

   El @m(n)-esimo byte de una cadena no es necesariamente el @m(n)-esimo
   caracter de una cadena, porque la codificacion UTF-8 de un punto de codigo no
   ASCII requiere dos o mas bytes. Como Trabajar con caracteres se discutira en
   breve.

   La operacion de subcadena @c(s[i:j]) produce una nueva cadena que consta de
   los bytes de la cadena original a partir del indice @c(i) y continua hasta,
   pero no incluyendo, el byte en el indice @c(j). El resultado contiene @c(j-i)
   bytes.

   ..src > go
     fmt.Println(s[0:5]) // "hello"
   < src..

   De nuevo, se produce un panico si cualquiera de los indices esta fuera de
   limite o si @c(j) es menor que @c(i).

   Cualquiera o ambos operandos @c(i) y @c(j) pueden omitirse, en cuyo caso los
   valores por defecto son 0 (el inicio de la cadena) y @c[len(s)] (su final),
   respectivamente.

   ..src > go
     fmt.Println(s[:5]) // "hello"
     fmt.Println(s[7:]) // "world"
     fmt.Println(s[:])  // "hello, world"
   < src..

   El operador c(+) crea una nueva cadena mediante la concatenacion de dos
   cadenas:

   ..src > go
     fmt.Println("goodbye" + s[5:]) // "goodbye, world"
   < src..

   Las cadenas pueden compararse con los operadores de comparacion como @c(==) y
   @c(<); La comparacion se realiza byte a byte, por lo que el resultado es el
   orden lexicografico natural.

   Los valores de cadena son inmutables: la secuencia de bytes contenidos en un
   valor de cadena no se puede cambiar, aunque, por supuesto, podemos asignar un
   nuevo valor a una variable de cadena. Para añadir una cadena a otra, por
   ejemplo, podemos escribir

   ..src > go
     s := "left foot"
     t := s
     s += ", right foot"
   < src..

   Esto no modifica la cadena que retenia @c(s) originalmente, pero hace que
   @c(s) contenga la nueva cadena formada por la sentencia @c(+=); Mientras
   tanto, @c(t) aun contiene la cadena antigua.

   ..src > go
     fmt.Println(s) // "left foot, right foot"
     fmt.Println(t) // "left foot"
   < src..

   Dado que las cadenas son inmutables, no se permiten las construcciones que
   intentan modificar los datos de una cadena en su lugar:

   ..src > go
     s[0] = 'L' // error de compilacion: no se puede asignar a s[0]
   < src..

   Inmutabilidad significa que es seguro que dos copias de una cadena compartan
   la misma memoria subyacente, por lo que es barato copiar cadenas de cualquier
   longitud. Del mismo modo, una cadena @c(s) y una subcadena como @c(s[7:])
   pueden compartir de forma segura los mismos datos, por lo que la operacion
   subcadena tambien es barata. No se asigna ninguna memoria nueva en ningun
   caso. La Figura 3.4 ilustra la disposicion de una cadena y dos de sus
   subcadenas que comparten el mismo arreglo de bytes subyacente.

   ..figure > Figura 3.4. La cadena @c("hello, world") y dos subcadenas.

     ..img > img/Figure-3.4.jpg

*** Seccion 3.5.1 <> Cadenas Literales

    Un valor de cadena se puede escribir como una @e(cadena literal), una
    secuencia de bytes entre comillas dobles:

    ..src > go
      "Hello, 世界"
    < src..

    Debido a que los archivos fuente de Go siempre estan codificados en UTF-8 y
    las cadenas de texto Go son interpretadas convencionalmente como UTF-8,
    podemos incluir puntos de codigo Unicode en literales de cadena.

    Dentro de una literal de cadena entre comillas dobles, las secuencias de
    escape que comienzan con una barra invertida @c(\) se pueden utilizar para
    insertar valores arbitrarios de bytes en la cadena. Un conjunto de escape
    maneja codigos de control ASCII como newline, retorno de carro y tabulacion:

    | @c(\a) | @"(alerta) o  campana                            |
    |--------|--------------------------------------------------|
    | @c(\b) | retroceso                                        |
    |--------|--------------------------------------------------|
    | @c(\f) | form feed                                        |
    |--------|--------------------------------------------------|
    | @c(\n) | linea nueva                                      |
    |--------|--------------------------------------------------|
    | @c(\r) | retorno de carro                                 |
    |--------|--------------------------------------------------|
    | @c(\t) | tabulador                                        |
    |--------|--------------------------------------------------|
    | @c(\v) | tabulador vertical                               |
    |--------|--------------------------------------------------|
    | @c(\') | comilla simple (solo en la runa literal '\'')    |
    |--------|--------------------------------------------------|
    | @c(\") | comillas dobles (solo dentro de "..." literales) |
    |--------|--------------------------------------------------|
    | @c(\\) | barra invertida                                  |

    Los bytes arbitrarios tambien se pueden incluir en cadenas literales usando
    escapes hexadecimales u octales. Un escape hexadecimal se escribe
    @c(\x)@e(hh), con exactamente dos digitos hexadecimales @e(h) (en mayusculas
    o minusculas). Un escape octal se escribe @e(\ooo) con exactamente tres
    digitos octales @e(o) (0 a 7) no superior a @c(\377). Ambos denotan un solo
    byte con el valor especificado. Mas adelante, veremos como codificar
    numericamente los puntos de codigo Unicode en literales de cadena.

    Una @e(literal de cadena sin formato) se escribe @c(`...`), utilizando
    comillas inversas en lugar de comillas dobles. Dentro de una literal de
    cadena sin formato, no se procesan secuencias de escape; Los contenidos se
    toman literalmente, incluyendo barras invertidas y lineas nuevas, por lo que
    un literal de cadena sin formato puede extenderse por varias lineas en el
    codigo del programa. El unico procesamiento es que los retornos de carro se
    eliminan para que el valor de la cadena sea el mismo en todas las
    plataformas, incluidas aquellas que convencionalmente ponen retornos de
    carro en archivos de texto.

    Las literales de cadenas sin formato son una manera conveniente de escribir
    expresiones regulares, que tienden a tener un monton de barras
    inversas. Tambien son utiles para plantillas HTML, literales JSON, mensajes
    de uso de comandos y similares, que a menudo se extienden sobre varias
    lineas.

    ..src > go
      const GoUsage = `Go is a tool for managing Go source code.

      Usage:
          go command [arguments]
      ...`
    < src..

*** Seccion 3.5.2 <> Unicode

    Hace mucho tiempo, la vida era simple y habia, por lo menos un punto de
    vista parroquial, solo un conjunto de caracteres a manejar: ASCII, el codigo
    estandar americano para el intercambio de la informacion (@e(American
    Standard Code for Information Interchange)). ASCII, o mas precisamente
    US-ASCII, utiliza 7 bits para representar 128 @"(caracteres): las letras
    mayusculas y minusculas del ingles, digitos y una variedad de caracteres de
    puntuacion y control de dispositivo. Durante gran parte de los primeros dias
    de la informatica, esto fue adecuado, pero dejo a una gran parte de la
    poblacion mundial incapaz de utilizar sus propios sistemas de escritura en
    las computadoras. Con el crecimiento de Internet, los datos en innumerables
    idiomas se han vuelto mucho mas comunes. ¿Como puede manejarse esta rica
    variedad y, si es posible, de forma eficiente?

    La respuesta es Unicode (@l(http://unicode.org/<>unicode.org)), que recoge
    todos los caracteres de todos los sistemas de escritura del mundo, ademas de
    acentos y otros signos diacriticos, codigos de control como tabulador y
    retorno de carro, y plenty of esoterica, y asigna a cada uno un numero
    estandar denominado @e(punto de codigo Unicode) o, en la terminologia Go,
    una runa.

    Unicode version 8 define puntos de codigo para mas de 120.000 caracteres en
    mas de 100 idiomas y scripts. ¿Como se representan esto en los datos y
    programas de computadora? El tipo de datos naturales para almacenar una sola
    runa es @c(int32), y eso es lo utiliza Go; tiene el sinonimo @c(rune)
    precisamente para este proposito.

    Podriamos representar una secuencia de runas como una secuencia de valores
    @c(int32). Esta representacion, se llama UTF-32 o UCS-4, la codificacion de
    cada punto de codigo Unicode tiene el mismo tamaño, 32 bits. Esto es simple
    y uniforme, pero utiliza mucho mas espacio de lo necesario, ya que la
    mayoria de texto legible por computadora esta en ASCII, que requiere solo 8
    bits o 1 byte por caracter. Todos los caracteres en uso generalizado todavia
    aun son menos de 65.536, que cabrian en 16 bits. ¿Podemos hacerlo mejor?

*** Seccion 3.5.3 <> UTF-8

    UTF-8 es una codificacion de longitud variable de puntos de codigo Unicode
    como bytes. UTF-8 fue inventado por Ken Thompson y Rob Pike, dos de los
    creadores de Go, y ahora es un estandar Unicode. Utiliza entre 1 y 4 bytes
    para representar cada runa, pero solo 1 byte para caracteres ASCII y solo 2
    o 3 bytes para la mayoria de runas en uso comun. Los bits de orden alto del
    primer byte de la codificacion de una runa indican cuantos bytes siguen. Un
    alto orden 0 indica ASCII de 7 bits, donde cada runa toma solo 1 byte, por
    lo que es identica a ASCII convencional. Un alto orden @c(110) indica que la
    runa toma 2 bytes; el segundo byte comienza con @c(10). Las runas mas
    grandes tienen codificaciones analogas.

    | @c(0xxxxxx)                            | runas 0−127    | (ASCII)                       |
    |----------------------------------------|----------------|-------------------------------|
    | @c(11xxxxx 10xxxxxx)                   | 128−2047       | (valores <128 no utilizados)  |
    |----------------------------------------|----------------|-------------------------------|
    | @c(110xxxx 10xxxxxx 10xxxxxx)          | 2048−65535     | (valores <2048 no utilizados) |
    |----------------------------------------|----------------|-------------------------------|
    | @c(1110xxx 10xxxxxx 10xxxxxx 10xxxxxx) | 65536−0x10ffff | (otros valores no utiliados)  |

    Una codificacion de longitud variable impide la indexacion directa para
    acceder al @m(n)-esimo caracter de una cadena, pero UTF-8 tiene muchas
    propiedades deseables para compensar. La codificacion es compacta,
    compatible con ASCII y auto-sincronizada: es posible encontrar el inicio de
    un caracter al realizar una copia de seguridad de no mas de tres
    bytes. Tambien es un prefijo de codigo, por lo que se puede decodificar de
    izquierda a derecha sin ninguna ambigüedad o lookahead. La codificacion de
    ninguna runa es una subcadena de cualquier otra, o incluso de una secuencia
    de otras, por lo que puedes buscar una runa simplemente buscando sus bytes,
    sin preocuparte por el contexto anterior. El orden de bytes lexicografico es
    igual al orden de los puntos de codigo Unicode, por lo que la ordenacion de
    UTF-8 funciona de forma natural. No hay ningun NUL incrustado (cero) bytes,
    que es conveniente para los lenguajes de programacion que utilizan NUL para
    terminar cadenas.

    Los archivos de codigo fuente de Go siempre estan codificados en UTF-8 y
    UTF-8 es la codificacion preferida para las cadenas de texto manipuladas por
    los programas Go. El paquete @c(unicode) proporciona funciones para trabajar
    con runas individuales (como distinguir letras de numeros, o la conversion
    de una letra mayuscula a una minuscula), y el paquete @c(unicode/utf8)
    proporciona funciones para codificar y decodificar runas como bytes usando
    UTF-8.

    Muchos caracteres Unicode son dificiles de escribir en un teclado o
    distinguir visualmente de otros de similar aspecto; Algunos son incluso
    invisibles. Go nos permite el escape de literales Unicode en una cadena Go
    al especificarlos por su valor numerico. Hay dos formas, @c(\u)@e(hhhh) para
    un valor de 16 bits y @c(\U)@e(hhhhhhhh) para un valor de 32 bits, donde
    cada @e(h) es un digito hexadecimal; La necesidad de la forma de 32 bits se
    presenta con poca frecuencia. Cada uno denota la codificacion UTF-8 del
    punto de codigo especificado. Asi, por ejemplo, los siguientes literales de
    cadena representan la misma cadena de seis bytes:

    ..src > go
      "世界"
      "\xe4\xb8\x96\xe7\x95\x8c"
      "\u4e16\u754c"
      "\U00004e16\U0000754c"
    < src..

    Las tres secuencias de escape anteriores proporcionan notaciones
    alternativas para la primera cadena, pero los valores que denotan son
    identicos. Los escapes Unicode tambien se puede utilizar en runas
    literales. Estos tres literales son equivalentes:

    ..pre >
      '世' '\u4e16' '\U00004e16'

    Una runa cuyo valor es menor que 256 se puede escribir con una sola de
    escape hexadecimal, por ejemplo @c('\x41') para @c('A'), pero para los
    valores mas altos, debe utilizar un @c(\u) o @c(\U) de escape. En
    consecuencia, @c('\xe4\xb8\x96') no es una runa literal legal, a pesar de
    que esos tres bytes son un UTF-8 valido de un unico punto de codigo.

    Gracias a las buenas propiedades de UTF-8, muchas operaciones de cadena no
    requieren decodificacion. Podemos probar si una cadena contiene otra como
    prefijo:

    ..src > go
      func HasPrefix(s, prefix string) bool {
        return len(s) >= len(prefix) && s[:len(prefix)] == prefix
      }
    < src..

    O como sufijo:

    ..src > go
      func HasSuffix(s, suffix string) bool {
        return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
      }
    < src..

    O como una subcadena:

    ..src > go
      func Contains(s, substr string) bool {
        for i := 0; i < len(s); i++ {
          if HasPrefix(s[i:], substr) {
            return true
          }
        }
        return false
      }
    < src..

    Utilizando la misma logica para un texto codificado en UTF-8 como para bytes
    sin procesar. Esto no es cierto para otras codificaciones. (Las funciones
    anteriores se han extraido del paquete @c(strings), aunque su implementacion
    de @c(Contains) utiliza una tecnica de hash para buscar de manera mas
    eficiente.)

    Por otro lado, si realmente nos preocupamos por los caracteres Unicode
    individuales, tenemos que usar otros mecanismos. Consideremos la cadena de
    nuestro primer ejemplo, la cual incluye dos caracteres asiaticos. La Figura
    3.5 ilustra su representacion en la memoria. La cadena contiene 13 bytes,
    pero interpretada como UTF-8, codifica solo nueve puntos de codigo o runas:

    ..src > go
      import "unicode/utf8"

      s := "Hello, 世界"
      fmt.Println(len(s))                    // "13"
      fmt.Println(utf8.RuneCountInString(s)) // "9"
    < src..

    Para procesar esos caracteres, necesitamos un decodificador UTF-8. El
    paquete @c(unicode/utf8) proporciona uno que podemos utilizar de la
    siguiente manera:

    ..src > go
      for i := 0; i < len(s); {
        r, size := utf8.DecodeRuneInString(s[i:])
        fmt.Printf("%d\t%c\n", i, r)
        i += size
      }
    < src..

    Cada llamada a @c(DecodeRuneInString) regresa @c(r), la runa en si, y
    @c(size), el numero de bytes ocupados por la codificacion UTF-8 de @c(r). El
    tamaño se utiliza para actualizar el indice del byte @c(i) de la siguiente
    runa en la cadena. Pero esto es torpe, y necesitamos bucles de este tipo
    todo el tiempo. Afortunadamente, Go tiene los bucles @c(range), cuando se
    aplica a una cadena, realiza decodificacion UTF-8 de forma implicita. La
    salida del bucle de siguiente se muestra en la Figura 3.5; Observe como el
    indice salta en mas de 1 para cada runa no ASCII.

    ..src > go
      for i, r := range "Hello, 世界" {
        fmt.Printf("%d\t%q\t%d\n", i, r, r)
      }
    < src..

    ..figure > Figura 3.5. Un bucle @c(range) descodifica una cadena UTF-8-codificado.

      ..img  > img/Figure-3.5.jpg


    Podriamos usar un simple bucle @c(range) para contar el numero de runas en
    una cadena, como aqui:

    ..src > go
      n := 0
      for _, _ = range s {
        n++
      }
    < src..

    Al igual que con las otras formas de bucle @c(range), podemos omitir las
    variables que no necesitamos:

    ..src > go
      n := 0
      for range s {
        n++
      }
    < src..

    O podemos simplemente llamar a @c[utf8.RuneCountInString(s)].

    Ya hemos mencionado que es sobre todo una cuestion de convencion en Go que
    las cadenas de texto se interpretan como secuencias codificadas en UTF-8 de
    puntos de codigo Unicode, pero para el uso correcto de bucles @c(range) de
    cadenas, es mas que una convencion, es una necesidad. ¿Que sucede si
    aplicamos @c(range) en cadena que contiene datos binarios arbitrarios o, de
    hecho, datos UTF-8 que contienen errores?

    Cada vez que un decodificador UTF-8, ya sea explicito en una llamada a
    @c(utf8.DecodeRuneInString) o implicito en un bucle @c(range), consume un
    byte de entrada inesperado, se genera un caracter Unicode de reemplazo
    especial, @c('\uFFFD'), que generalmente se impreme como un signo de
    interrogacion dentro de una forma hexagonal o un diamante negro �. Cuando un
    programa encuentra este valor de runa, a menudo es un signo de que parte del
    sistema que genero los datos de cadena ha sido descuidado en su tratamiento
    de las codificaciones de texto.

    UTF-8 es excepcionalmente conveniente como un formato de intercambio, pero
    dentro de un programa las runas puede ser mas conveniente porque son de
    tamaño uniforme y por lo tanto, de facil indexado en arreglos y slices.

    Una conversion @c([]rune) aplicada a una cadena codificada en UTF-8 devuelve la
    secuencia de codigos Unicode:

    ..src > go
      // "programa" en katakana
      s := "プログラム"
      fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
      r := []rune(s)
      fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
    < src..

    (El verbo @c(% x) en el primer @c(Printf) inserta un espacio entre cada par
    de digitos hexadecimales.)

    Si un slice de runas se convierte en una cadena, produce la concatenacion de
    las codificaciones UTF-8 de cada runa:

    ..src > go
      fmt.Println(string(r)) // "プログラム"
    < src..

    Convertir un valor entero en una cadena interpre el entero como un valor
    de runa, y produce la representacion UTF-8 de esa runa:

    ..src > go
      fmt.Println(string(65))     // "A", not "65"
      fmt.Println(string(0x4eac)) // "京"
    < src..

    Si la runa no es valida, se reemplasa por el caracter de sustitucion:

    ..src > go
      fmt.Println(string(1234567)) // "�"
    < src..

*** Seccion 3.5.4 <> Cadenas y Slices de Bytes

    cuatro paquetes estandar son particularmente importantes para la
    manipulacion de cadenas: @c(bytes), @c(strings), @c(strconv) y
    @c(unicode). El paquete @c(strings) ofrece muchas funciones para busqueda,
    reemplazo, comparacion, recorte, division, y union en cadenas.

    El paquete @c(bytes) tiene funciones similares para manipular slices de
    bytes, de tipo @c([]byte), que comparten algunas propiedades con
    @c(strings). Debido a que las cadenas son inmutables, la construccion de
    cadenas de forma incremental puede implicar una gran cantidad de asignacion
    y copiado. En tales casos, es mas eficaz utilizar el tipo @c(bytes.Buffer),
    que vamos a mostrar en un momento.

    El paquete @c(strconv) proporciona funciones para convertir booleanos,
    enteros, y valores de coma flotante hacia y desde sus representaciones en
    cadenas, y funciones para citar y des-citar cadenas.

    El paquete @c(unicode) proporciona funciones como @c(IsDigit), @c(IsLetter),
    @c(IsUpper) y @c(IsLower) para la clasificacion de runas. Cada funcion toma
    un unico argumento de tipo runa y devuelve un booleano. Las funciones de
    conversion como @c(ToUpper) y @c(ToLower) convierten una runa en el caso
    concreto si se trata de una letra. Todas estas funciones utilizan las
    categorias estandar de Unicode para las letras, los digitos, etc. El paquete
    @c(strings) tiene funciones similares, tambien llamadas @c(ToUpper) y
    @c(ToLower), que devuelven una nueva cadena con la transformacion
    especificada aplicada a cada caracter de la cadena original.

    La siguiente funcion @c(basename) se inspiro en la utilidad de shell Unix
    del mismo nombre. En nuestra version, @c[basename(s)] elimina cualquier
    prefijo de @c(s) que paresca una ruta de sistema con componentes separados
    por barras, y elimina cualquier sufijo que se parece a un tipo de archivo:

    ..src > go
      fmt.Println(basename("a/b/c.go")) // "c"
      fmt.Println(basename("c.d.go"))   // "c.d"
      fmt.Println(basename("abc"))      // "abc"
    < src..

    La primer version de basename hace todo el trabajo sin la ayuda de
    librerias:

    ..figure > @l(gopl.io/ch3/basename1/main.go<>gopl.io/ch3/basename1)

      ..src > go
        // basename elimina los .subfijos y componentes de directorios.
        // e.g., a => a, a.go => a, a/b/c.go => c, a/b.c.go => b.c
        func basename(s string) string {
          // Descarta el ultimo '/' y todo lo anterior.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '/' {
              s = s[i+1:]
              break
            }
          }
          // Conserva todo antes del ultimo '.'.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '.' {
              s = s[:i]
              break
            }
          }
          return s
        }
      < src..


    Una version mas simple utiliza la funcion de libreria @c(strings.LastIndex):

    ..figure > @l(gopl.io/ch3/basename2/main.go<>gopl.io/ch3/basename2)

      ..src > go
        func basename(s string) string {
          slash := strings.LastIndex(s, "/") // -1 si no se encuentra "/"
          s = s[slash+1:]
          if dot := strings.LastIndex(s, "."); dot >= 0 {
            s = s[:dot]
          }
          return s
        }
      < src..


    Los paquetes @c(path) y @c(path/filepath) proporcionan un conjunto general
    de funciones para manipular nombres jerarquicos. El paquete @c(path)
    funciona con rutas delimitada por barras en cualquier plataforma. No se debe
    utilizar para nombres de archivo, pero es apropiado para otros dominios,
    como los componente de ruta de una URL. Por el contrario, @c(path/filepath)
    manipula los nombres de archivos usando las reglas para la plataforma
    huesped, tales como @c(/foo/bar) para POSIX o @c(c:\foo\bar) en Microsoft
    Windows.

    Vamos a continuar con otro ejemplo de subcadena. La tarea es tomar una
    representacion de cadena de un entero, como @c("12345"), e insertar comas
    cada tres posiciones, como en @c("12,345") . Esta version solo funciona para
    enteros; El manejo de numeros de coma flotante se deja como un ejercicio.

    ..figure > @l(gopl.io/ch3/comma/main.go<>gopl.io/ch3/comma)

      ..src > go
        // comma inserta comas en una cadena de numeros enteros decimales negativos.
        func comma(s string) string {
          n := len(s)
          if n <= 3 {
            return s
          }
          return comma(s[:n-3]) + "," + s[n-3:]
        }
      < src..


    El argumento de @c(comma) es una cadena. Si su longitud es menor o igual a
    3, no es necesaria una coma. De lo contrario, comma se llama a si misma de
    forma recursiva con una subcadena formada por todos menos los tres ultimos
    caracteres, y añåde una coma y los tres ultimos caracteres en el resultado
    de la llamada recursiva.

    Una cadena contiene un arreglo de bytes que, una vez creado, es
    inmutable. Por el contrario, los elementos de una slice de bytes se pueden
    modificar libremente.

    Las cadenas se pueden convertir en slices de bytes y viceversa:

    ..src > go
      s := "abc"
      b := []byte(s)
      s2 := string(b)
    < src..

    Conceptualmente, la conversion @c{[]byte(s)} asigna un nuevo arreglo de
    bytes que guarda una copia de bytes de @c(s), y produce un slice que hace
    referencia a la totalidad del arreglo. Un compilador optimizado puede ser
    capaz de evitar la asignacion y la copia en algunos casos, pero en general,
    la copia es necesaria para asegurar que los bytes de @c(s) se mantienen sin
    cambios incluso si los de @c(b) son modificados posteriormente. La
    conversion de slice de byte de nuevo a cadena con @c[string(b)] tambien
    genera una copia, para asegurar inmutabilidad de la cadena resultante
    @c(s2).

    Para evitar conversiones y asignacion de memoria innecesaria, muchas
    de las funciones de utilidad en el paquete @c(bytes) directamente paralelos a
    sus contrapartes en el paquete @c(strings). Por ejemplo, aqui hay una media
    docena de funciones en @c(strings):

    ..src > go
      func Contains(s, substr string) bool
      func Count(s, sep string) int
      func Fields(s string) []string
      func HasPrefix(s, prefix string) bool
      func Index(s, sep string) int
      func Join(a []string, sep string) string
    < src..

    y las correspondientes en bytes :

    ..src > go
      func Contains(b, subslice []byte) bool
      func Count(s, sep []byte) int
      func Fields(s []byte) [][]byte
      func HasPrefix(s, prefix []byte) bool
      func Index(s, sep []byte) int
      func Join(s [][]byte, sep []byte) []byte
    < src..

    La unica diferencia es que las cadenas han sido reemplazadas por slices de
    bytes.

    El paquete @c(bytes) proporciona el tipo @c(Buffer) para la manipulacion
    eficiente de slices de @c(byte). Un @c(Buffer) comienza vacio, pero crece a
    medida que los datos de tipos como @c(string), @c(byte), y @c([]byte) se
    escriben en el. Como muestra el siguiente ejemplo, una variable
    @c(bytes.Buffer) no requiere inicializacion porque su valor cero es
    utilizable:

    ..figure > @l(gopl.io/ch3/printints/main.go<>gopl.io/ch3/printints)

      ..src > go
        // intsToString es como fmt.Sprint(values) pero agrega comas.
        func intsToString(values []int) string {
          var buf bytes.Buffer
          buf.WriteByte('[')
          for i, v := range values {
            if i > 0 {
              buf.WriteString(", ")
            }
            fmt.Fprintf(&buf, "%d", v)
          }
          buf.WriteByte(']')
          return buf.String()
        }

        func main() {
          fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
        }
      < src..


    Cuando se agrega la codificacion UTF-8 de un runa arbitraria a un
    @c(bytes.Buffer), lo mejor es utilizar el metodo @c(WriteRune) de
    @c(bytes.Buffer), pero @c(WriteByte) esta bien para caracteres ASCII como
    @c('[') y @c(']').

    El tipo @c(bytes.Buffer) es extremadamente versatil, y cuando hablemos de
    interfaces en el @l(#Capitulo 7), vamos a ver como se puede utilizar como un
    sustituto de un archivo cada vez que una funcion de E/S requiere un poso de
    bytes (@c(io.Writer)) como @c(Fprintf), o una fuente de bytes
    (@c(io.Reader)).

   @b(Ejercicio 3.10): Escribir una version no recursiva de @c(comma),
   utilizando @c(bytes.Buffer) en lugar de la concatenacion de cadenas.

   @b(Ejercicio 3.11): Mejorar @c(comma) para que se maneje correctamente los
   numeros de punto flotante y un opcionalmente con signo.

   @b(Ejercicio 3.12): Escribir una funcion que informa de si dos cadenas son
   anagramas entre si, es decir, que contienen las mismas letras en un orden
   diferente.

*** Seccion 3.5.5 <> Conversiones entre cadenas y numeros

    Ademas de las conversiones entre cadenas, runas y bytes, a menudo es
    necesario convertir entre valores numericos y sus representaciones de
    cadena. Esto se realiza con las funciones del paquete @c(strconv).

    Para convertir un entero a una cadena, una opcion es utilizar @c(fmt.Sprintf);
    otra es utilizar la funcion @c(strconv.Itoa) (@"(entero a ASCII)):

    ..src > go
      x := 123
      y := fmt.Sprintf("%d", x)
      fmt.Println(y, strconv.Itoa(x)) // "123 123"
    < src..

    @c(FormatInt) y @c(FormatUint) se pueden utilizar para dar formato a numeros
    en una base diferente:

    ..src > go
      fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
    < src..

    Los verbos @c(%b), @c(%d), @c(%u) y @c(%x) de @c(fmt.Printf) a menudo son
    mas conveniente que las funciones @c(Format), sobre todo si queremos incluir
    informacion adicional ademas del numero:

    ..src > go
      s := fmt.Sprintf("x=%b", x) // "x=1111011"
    < src..

    Para analizar una cadena que representa un numero entero, utilice las
    funciones de @c(strconv) como @c(Atoi) o @c(ParseInt), o @c(ParseUint) para
    enteros sin signo:

    ..src > go
      x, err := strconv.Atoi("123")             // x es un entero
      y, err := strconv.ParseInt("123", 10, 64) // base 10, hasta 64 bits
    < src..

    El tercer argumento de @c(ParseInt) da el tamaño del tipo de entero que debe
    ser el resultado; por ejemplo, 16 implica @c(int16), y el valor especial 0
    implica @c(int) . En cualquier caso, el tipo del resultado @c(y) es siempre
    @c(int64), que luego se puede convertir a un tipo mas pequeño.

    A veces es util @c(fmt.Scanf) para el analisis de entrada que consta de
    mezclas ordenadas de cadenas y numeros todo en una sola linea, pero puede
    ser inflexible, especialmente cuando se maneja una entrada incompleta o
    irregular.

** Seccion 3.6 <> Constantes

   Las constantes son expresiones cuyo valor es conocido por el compilador y
   cuya evaluacion se garantiza que se produzca en tiempo de compilacion, no en
   tiempo de ejecucion. El tipo subyacente de cada constante es un tipo basico:
   booleano, cadena o numero.

   Una declaracion @c(const) define los valores que se ven sintacticamente como
   variables con nombre pero cuyo valor es constante, lo que evita cambios
   accidentales (o nefastos) durante la ejecucion del programa. Por ejemplo, una
   constante es mas apropiada que una variable para una constante matematica
   como @c(pi), ya que su valor no cambiara:

   ..src > go
     const pi = 3.14159 // aproximadamente; math.Pi un una mejor aproximacion
   < src..

   Al igual que con las variables, una secuencia de constantes puede aparecer en
   una declaracion; Esto seria apropiado para un grupo de valores relacionados:

   ..src > go
     const (
       e  = 2.71828182845904523536028747135266249775724709369995957496696763
       pi = 3.14159265358979323846264338327950288419716939937510582097494459
     )
   < src..

   Muchos calculos de constantes pueden evaluarse completamente en tiempo de
   compilacion, reduciendo el trabajo necesario en tiempo de ejecucion y
   habilitando otras optimizaciones de compilador. Los errores ordinariamente
   detectados en tiempo de ejecucion pueden ser reportados en tiempo de
   compilacion cuando sus operandos son constantes, como la division entera por
   cero, una cadena de indexacion fuera de limites y cualquier operacion de
   punto flotante que daria lugar a un valor no finito.

   Los resultados de toda la aritmetica, y operaciones de comparacion logicos
   aplicados a operandos constantes son en si mismas constantes, como son los
   resultados de las conversiones y las llamadas a ciertas funciones nativas
   como @c(len), @c(cap), @c(real), @c(imag), @c(complex), y @c(unsafe.Sizeof)
   (@l(#Seccion 13.1<>§13.1)).

   Ya que sus valores son conocidos por el compilador, las expresiones
   constantes pueden aparecer en los tipos, especificamente como la longitud de
   un tipo de arreglo:

   ..src > go
     const IPv4Len = 4

     // parseIPv4 analiza una direccion IPv4 (d.d.d.d).
     func parseIPv4(s string) IP {
       var p [IPv4Len]byte
       // ...
     }
   < src..

   Una declaracion constante puede especificar un tipo como un valor, pero en
   ausencia de un tipo explicito, el tipo se infiere de la expresion en el lado
   derecho. En el siguiente ejemplo, @c(time.Duration) es un tipo con nombre
   cuyo tipo subyacente es @c(int64), y @c(time.Minute) es una constante de ese
   tipo. Por lo tanto las dos constantes declaradas a continuacion tienen el
   tipo @c(time.Duration), como lo revela @c(%T):

   ..src > go
     const noDelay time.Duration = 0
     const timeout = 5 * time.Minute

     fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
     fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s
     fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
   < src..

   Cuando una secuencia de constantes se declara como un grupo, la expresion del
   lado derecho se puede omitir para todas excepto para la primera del grupo, lo
   que implica que la expresion anterior y su tipo deben ser utilizados de
   nuevo. Por ejemplo:

   ..src > go
     const (
       a = 1
       b
       c = 2
       d
     )

     fmt.Println(a, b, c, d) // "1 1 2 2"
   < src..

   Esto no es muy util si la expresion del lado derecho implicitamente copiada
   se evalua siempre con el mismo valor. Pero, ¿y si pudiera variar? Esto nos
   lleva a @c(iota).

*** Seccion 3.6.1 <> El Generador Constante @c(iota)

    Una declaracion @c(const) puede utilizar el generador de constante @c(iota),
    que se utiliza para crear una secuencia de valores relacionados sin escribir
    cada uno de forma explicita. En una declaracion @c(const), el valor de
    @c(iota) comienza en cero y se incrementa en uno en cada elemento de la
    secuencia.

    He aqui un ejemplo del paquete @c(time), que define constantes de tipo
    @c(Weekday) de los dias de la semana, a partir de cero para @c(Sunday).
    Tipos de esta clase a menudo se conocen como @e(enumeraciones), o @e(enums),
    para abreviar.

    ..src > go
      type Weekday int

      const (
        Sunday Weekday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
      )
    < src..

    Esto declara que @c(Sunday) debe ser 0, @c(Monday) debe ser 1, y asi
    sucesivamente.

    Podemos utilizar @c(iota) en expresiones mas complejas, como en este ejemplo
    del paquete @c(net) en el que se le da a cada uno de los 5 bits mas bajos de
    un entero sin signo un nombre distinto e interpretacion booleana:

    ..src > go
      type Flags uint

      const (
        FlagUp Flags = 1 << iota // esta arriba
        FlagBroadcast            // soporta acceso broadcast
        FlagLoopback             // es una interface loopback
        FlagPointToPoint         // pertenece a un enlace punto-a-punto
        FlagMulticast            // soporta acceso multicast
      )
    < src..

    Como @c(iota) incrementa, a cada constante se le asigna el valor de @c(1 <<
    iota), que evalua a potencias consecutivas de dos, cada un corresponde a un
    solo bit. Podemos utilizar estas constantes dentro de funciones que prueban,
    establecen o borran uno o mas de estos bits:

    ..figure > @l(gopl.io/ch3/netflag/netflag.go<>gopl.io/ch3/netflag)

      ..src > go
        func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
        func TurnDown(v *Flags)     { *v &^= FlagUp }
        func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
        func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }

        func main() {
          var v Flags = FlagMulticast | FlagUp
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10001 true"
          TurnDown(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10000 false"
          SetBroadcast(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
          fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
        }
      < src..


    Como un ejemplo mas complejo de @c(iota), esta declaracion nombra las
    potencias de 1024:

    ..src > go
      const (
        _ = 1 << (10 * iota)
        KiB // 1024
        MiB // 1048576
        GiB // 1073741824
        TiB // 1099511627776              (exede 1 << 32)
        PiB // 1125899906842624
        EiB // 1152921504606846976
        ZiB // 1180591620717411303424     (exede 1 << 64)
        YiB // 1208925819614629174706176
      )
    < src..

    El mecanismo @c(iota) tiene sus limites. Por ejemplo, no es posible generar
    las potencias mas familiares de 1000 (KB, MB, etc.) porque no hay un
    operador de exponenciacion.

   @b(Ejercicio 3.13): Escribir declaraciones @c(const) para KB, MB, hasta YB lo
   mas compacto como sea posible.

*** Seccion 3.6.2 <> Constantes Sin Tipo

    Las constantes en Go son un poco inusuales. Aunque una constante puede tener
    cualquiera de los tipos de datos basicos como @c(int) o @c(float64),
    incluyendo tipos basicos con nombre como @c(time.Duration), muchas
    constantes no estan comprometidas con un tipo particular. El compilador
    representa estas constantes no comprometidas con una precision numerica
    mucho mayor que los valores de tipos basicos, y la aritmetica en ellas es
    mas precisa que la aritmetica de la maquina; Puede suponer al menos 256 bits
    de precision. Hay seis sabores de estas constantes no comprometidos, llamado
    booleanos @e(sin tipo), enteros sin tipo, runas sin tipo, punto flotante sin
    tipo, complejos sin tipo y cadenas sin tipo.

    Al aplazar este compromiso, las constantes no tipificadas no solo conservan
    su mayor precision hasta mas tarde, sino que pueden participar en muchas mas
    expresiones que las constantes comprometidas sin requerir conversiones. Por
    ejemplo, los valores @c(ZiB) y @c(YiB) en el ejemplo anterior son demasiado
    grandes para almacenase en cualquier variable entera, pero son legitimas
    constantes que pueden utilizarse en las expresiones como esta:

    ..src > go
      fmt.Println(YiB/ZiB) // "1024"
    < src..

    Como otro ejemplo, la constante de coma flotante @c(math.Pi) puede
    utilizarse alli donde se necesite cualquier valor de coma flotante o
    complejo:

    ..src > go
      var x float32 = math.Pi
      var y float64 = math.Pi
      var z complex128 = math.Pi
    < src..

    Si @c(math.Pi) entubiera comprometido con un tipo especifico, como
    @c(float64), el resultado no seria tan preciso, y se requerira de conversion
    de tipos para usarlo con valores @c(float32) o @c(complex128):

    ..src > go
      const Pi64 float64 = math.Pi

      var x float32 = float32(Pi64)
      var y float64 = Pi64
      var z complex128 = complex128(Pi64)
    < src..

    Para literales, la sintaxis determina el sabor. Los literales de @c(0),
    @c(0.0), @c(0i), y @c('\u0000') representan constantes del mismo valor pero
    diferentes sabores: entero sin tipo, sin tipo de punto flotante, complejo
    sin tipo, y runa sin tipo, respectivamente. Del mismo modo, @c(true) y
    @c(false) son booleanos sin tipo y literales de cadena son cadenas sin tipo.

    Recordemos que @c(/) puede representar un numero entero o division de punto
    flotante dependiendo de sus operandos. En consecuencia, la eleccion de
    literal puede afectar el resultado de una expresion de division constante:

    ..src > go
      var f float64 = 212
      fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 es un float64
      fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 es un entero sin tipo, 0
      fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 es un float sin tipo
    < src..

    Solo las constantes pueden no tener tipo. Cuando una constante no tipificada
    se asigna a una variable, como en la primer instruccion a continuacion, o
    aparece en el lado derecho de una declaracion de variable con un tipo
    explicito, como en las otras tres sentencias, la constante se convierte
    implicitamente en el tipo de esa variable si es posible.

    ..src > go
      var f float64 = 3 + 0i // complejo sin tipo -> float64
      f = 2                  // entero sin tipo -> float64
      f = 1e123              // punto flotante sin tipo -> float64
      f = 'a'                // runa sin tipo -> float64
    < src..

    Las afirmaciones anteriores son, pues, equivalentes a estas:

    ..src > go
      var f float64 = float64(3 + 0i)
      f = float64(2)
      f = float64(1e123)
      f = float64('a')
    < src..

    Ya sea implicita o explicitamente, la conversion de una constante de un tipo
    a otro requiere que el tipo de destino pueda representar el valor
    original. Se permite el redondeo para numeros reales y complejos de coma
    flotante:

    ..src > go
      const (
        deadbeef = 0xdeadbeef // int sin tipo con valor 3735928559
        a = uint32(deadbeef)  // uint32 con valor 3735928559
        b = float32(deadbeef) // float32 con valor 3735928576 (rounded up)
        c = float64(deadbeef) // float64 con valor 3735928559 (exact)
        d = int32(deadbeef)   // error de compilacion: desbordamiento constante int32
        e = float64(1e309)    // error de compilacion: desbordamiento constante float64
        f = uint(-1)          // error de compilacion: subdesbordamiento constante uint
      )
    < src..

    En una declaracion de variable sin un tipo explicito (incluyendo declaracion
    de variables compacto), el sabor de la constante no tipificada determina
    implicitamente el tipo predeterminado de la variable, como en estos
    ejemplos:

    ..src > go
      i := 0      // entero sin tipo;         int(0) implicitio
      r := '\000' // runa sin tipo;           rune('\000') implicitio
      f := 0.0    // punto flotante sin tipo; float64(0.0) implicitio
      c := 0i     // complejo sin tipo;       complex128(0i) implicitio
    < src..

    Observese la asimetria: los enteros sin tipo se convierten en @c(int), cuyo
    tamaño no esta garantizado, pero los numeros de punto flotante y numeros
    complejos se convierten a los tipos de tamaño @c(float64) y @c(complex128)
    de forma explicita. El lenguaje no cuenta con tipos @c(float) y @c(complex)
    sin tamaño, analogos a @c(int) sin tamaño, porque es muy dificil escribir
    algoritmos numericos correctos sin conocer el tamaño de uno de los tipos de
    datos de punto flotante.

    Para dar un tipo diferente a la variable, debemos convertir explicitamente
    la constante no tipificada en el tipo deseado o indicar el tipo deseado en
    la declaracion de variables, como en estos ejemplos:

    ..src > go
      var i = int8(0)
      var i int8 = 0
    < src..

    Estos valores predeterminados son particularmente importantes cuando se
    convierte una constante sin tipo a un valor de interfaz (ver @l(#Capitulo
    7)) ya que determinan su tipo dinamico.

    ..src > go
      fmt.Printf("%T\n", 0)      // "int"
      fmt.Printf("%T\n", 0.0)    // "float64"
      fmt.Printf("%T\n", 0i)     // "complex128"
      fmt.Printf("%T\n", '\000') // "int32" (rune)
    < src..

    Ahora hemos cubierto los tipos de datos basicos de Go. El siguiente paso es
    mostrar como se pueden combinar en agrupaciones mas grandes como arreglos y
    estructuras, y luego en estructuras de datos para resolver problemas de
    programacion real; ese es el tema del @l(#Capitulo 4).

* Capitulo 4 <> Tipos Compuestos

  En el @l(#Capitulo 3) hablamos de los tipos basicos que sirven como bloques de
  construccion para estructuras de datos en un programa Go; Son los atomos de
  nuestro universo. En este capitulo, vamos a echar un vistazo a los tipos
  @e(compuestos), las moleculas creadas mediante la combinacion de los tipos
  basicos de diversas maneras. Hablaremos de cuatro de estos tipos–arreglos,
  slices, mapas y estructuras–y al final del capitulo mostraremos como los datos
  estructurados que utilizan estos tipos pueden ser codificados y analizados a
  partir de datos JSON y usados ​​para generar HTML desde plantillas.

  Arreglos y estructuras son tipos de @e(agregados); Sus valores son
  concatenaciones de otros valores en la memoria. Los arreglos son homogeneos,
  sus elementos tienen el mismo tipo, mientras que las estructuras son
  heterogeneas. Los arreglos y las estructuras son de tamaño fijo. Por el
  contrario, slices y mapas son estructuras de datos dinamicas que crecen a
  medida que se agregan valores.

** Seccion 4.1 <> Arreglos

   Un arreglo es una secuencia de longitud fija de cero o mas elementos de un
   tipo particular. Debido a su longitud fija, en Go raramente se utilizan
   arreglos directamente. Los slices, pueden crecer y encogerse, son mucho mas
   versatiles, pero para entender los slices primero debemos entender los
   arreglos.

   Los elementos individuales de arreglo se acceden con la notacion de
   subindices convencional, donde los subindices abarcan desde cero a uno menos
   que la longitud de la arreglo. La funcion nativa @c(len) devuelve el numero
   de elementos de la arreglo.

   ..src > go
     var a [3]int             // arreglo de 3 enteros
     fmt.Println(a[0])        // imprime el primer elemento
     fmt.Println(a[len(a)-1]) // imprime el ultime elemento, a[2]

     // imprimir los indices y elementos.
     for i, v := range a {
       fmt.Printf("%d %d\n", i, v)
     }

     // imprimir solo los elementos.
     for _, v := range a {
       fmt.Printf("%d\n", v)
     }
   < src..

   Por defecto, los elementos de un nuevo arreglo de variables estan
   configurados inicialmente a el valor cero para el tipo de elemento, que es 0
   para los numeros. Podemos utilizar un @e(arreglo literal) para inicializar un
   arreglo con una lista de valores:

   ..src > go
     var q [3]int = [3]int{1, 2, 3}
     var r [3]int = [3]int{1, 2}
     fmt.Println(r[2]) // "0"
   < src..

   En un arreglo literal, si aparece una elipsis @c("...") aparece en lugar de
   la longitud, la longitud del arreglo se determina por el numero de
   inicializadores. La definicion de @c(q) se puede simplificar como

   ..src > go
     q := [...]int{1, 2, 3}
     fmt.Printf("%T\n", q) // "[3]int"
   < src..

   El tamaño de un arreglo es parte de su tipo, por lo que @c([3]int) y
   @c([4]int) son tipos diferentes. El tamaño debe ser una expresion constante,
   es decir, una expresion cuyo valor se puede calcular a medida que se esta
   compilando el programa.

   ..src > go
     q := [3]int{1, 2, 3}
     q = [4]int{1, 2, 3, 4} // error de compilacion: no puede asignar [4]int a [3]int
   < src..

   Como veremos, la sintaxis literal es similar para arreglos, slices, mapas y
   estructuras. El formato especifico anterior es una lista de valores en
   orden, pero tambien es posible especificar una lista de pares de indice y
   valor, como aqui:

   ..src > go
     type Currency int

     const (
       USD Currency = iota
       EUR
       GBP
       RMB
     )
     symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RMB: "¥"}

     fmt.Println(RMB, symbol[RMB]) // "3 ¥"
   < src..

   En esta forma, los indices pueden aparecer en cualquier orden y algunos
   pueden ser omitidos; Como antes, los valores no especificados toman el valor
   cero para el tipo de elemento. Por ejemplo,

   ..src > go
     r := [...]int{99: -1}
   < src..

   define un arreglo @c(r) con 100 elementos, todos en cero excepto para el
   ultimo, que tiene un valor -1.

   Si el tipo de los elementos de un arreglo es @e(comparable) entonces, el tipo
   del arreglo tambien es comparable, asi que podemos comparar directamente dos
   arreglos de ese tipo usando el operador @c(==), que informa de si todos los
   elementos correspondientes son iguales. El operador @c(!=) es su negacion.

   ..src > go
     a := [2]int{1, 2}
     b := [...]int{1, 2}
     c := [2]int{1, 3}
     fmt.Println(a == b, a == c, b == c) // "true false false"
     d := [3]int{1, 2}
     fmt.Println(a == d) // error de compilacion: no puede comparar [2]int == [3]int
   < src..

   Como un ejemplo mas plausible, la funcion @c(Sum256) en el paquete
   @c(crypto/sha256) produce el @e(digest) o hash criptografico SHA256 o DIGEST
   de un mensaje almacenado en un slice arbitrario de bytes. El hash tiene 256
   bits, por lo que su tipo es @c([32]byte) . Si dos hash son los mismos, es muy
   probable que los dos mensajes sean iguales; Si los hash difieren, los dos
   mensajes son diferentes. Este programa imprime y compara los hash SHA256 de
   @c("x") y @c("X"):

   ..figure > @l(gopl.io/ch4/sha256/main.go<>gopl.io/ch4/sha256)

     ..src > go
       import "crypto/sha256"

       func main() {
         c1 := sha256.Sum256([]byte("x"))
         c2 := sha256.Sum256([]byte("X"))
         fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
         // Output:
         // 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
         // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
         // false
         // [32]uint8
       }
     < src..


   Las dos entradas difieren por un solo bit, pero aproximadamente la mitad de
   los bits son diferentes en los hash. Note las verbos @c(Printf): @c(%x) para
   imprimir todos los elementos de un arreglo o una slice de bytes en
   hexadecimal, @c(%t) para mostrar un valor booleano, y @c(%T) para mostrar el
   tipo de un valor.

   Cuando se llama a una funcion, se asigna una copia de cada valor de argumento
   a la variable de parametro correspondiente, por lo que la funcion recibe una
   copia, no el original. Pasar grandes arreglos de esta manera puede ser
   ineficiente, y cualquier cambio que la funcion hace a elementos de arreglo
   afectan solo a la copia, no al original. En este sentido, Go trata a los
   arreglos como a cualquier otro tipo, pero este comportamiento es diferente de
   otros lenguajes que implicitamente pasan arreglos por referencia.

   Por supuesto, podemos pasar explicitamente un puntero a un arreglo para que
   cualquier modificacion que la funcion hace a los elementos del arreglo sean
   visibles para quien llama a la funcion. Esta funcion pone a cero el contenido
   de un arreglo @c([32]byte):

   ..src > go
     func zero(ptr *[32]byte) {
       for i := range ptr {
         ptr[i] = 0
       }
     }
   < src..

   El arreglo literal @c([32]byte{}) produce una serie de 32 bytes. Cada
   elemento del arreglo tiene el valor cero para @c(byte), que es cero. Podemos
   utilizar este hecho para escribir una version diferente de zero:

   ..src > go
     func zero(ptr *[32]byte) {
       *ptr = [32]byte{}
     }
   < src..

   El uso de un puntero a un arreglo es eficiente y permite que la funcion
   llamada mute la variable de quien la llama, pero los arreglos son
   intrinsecamente inflexibles debido a su tamaño fijo. La funcion @c(zero) no
   aceptara un puntero a una variable @c([16]byte), por ejemplo, ni hay ninguna
   manera de añadir o eliminar elementos del arreglo. Por estas razones, aparte
   de casos especiales como el hash SHA256 de tamaño fijo, rara vez se usan
   arreglos como parametros de funcion; En su lugar, utilizamos slices.

   @b(Ejercicio 4.1): Escribir una funcion que cuente el numero de bits que son
   diferentes en dos hash SHA256. (Ver @c(PopCount) en la @l(#Seccion 2.6.2).)

   @b(Ejercicio 4.2): Escribir un programa que imprima el hash SHA256 de su
   entrada estandar por defecto, pero que accepte una bandera de linea de
   comando para imprimir tambien los hash SHA384 o SHA512.

** Seccion 4.2 <> Slices

   Los slices representan secuencias de longitud variable cuyos elementos tienen
   todos el mismo tipo. Un tipo slice se escribe @c([]T), donde los elementos
   tienen el tipo @c(T); es como un tipo arreglo pero sin un tamaño.

   Arreglos y slices estan intimamente conectados. Un slice es una estructura de
   datos ligera que da acceso a una subsecuencia de (o tal vez todos) los
   elementos de un arreglo, que se conoce como @e(arreglo subyacente) del
   slice. Una slice tiene tres componentes: un puntero, una longitud y una
   capacidad. El puntero apunta al primer elemento del arreglo que se puede
   acceder a traves del slice, que no es necesariamente el primer elemento del
   arreglo. La longitud es el numero de elementos del slice; No puede exceder la
   capacidad, que suele ser el numero de elementos entre el inicio de la
   division y el final del arreglo subyacente. Las funciones nativas @c(len) y
   @c(cap) regresan esos valores.

   Multiples slices pueden compartir el mismo arreglo subyacente y pueden
   referirse a partes superpuestas de ese arreglo. La Figura 4.1 muestra un
   arreglo de cadenas para los meses del año, y dos slices superpuestos del
   mismo. El arreglo se declara como

   ..src > go
     meses := [...]string{1: "Enero", /* ... */, 12: "Diciembre"}
   < src..

   asi Enero es @c(meses[1]) y Diciembre es @c(meses[12]). Normalmente, el
   elemento de arreglo en el indice 0 contendria el primer valor, pero como los
   meses siempre estan numerados apartir de 1, podemos dejarlo fuera de la
   declaracion y se inicializara en una cadena vacia.

   ..figure > Figura 4.1. Dos slices superpuestos de un arreglo de meses.

     ..img > img/Figure-4.1.jpg


   El @e(operador de slice) @c(s[i:j]), donde @c(0) ≤ @c(i) ≤ @c(j) ≤
   @c[cap(s)], crea un nuevo segmento que se refiere a los elementos de @c(i) a
   @c(j-1) de la secuencia @c(s), que puede ser una variable del arreglo, un
   puntero a un arreglo u otra porcion. El slice resultante tiene @c(j-i)
   elementos. Si @c(i) se omite, es 0, y si @c(j) se omite, es @c[len(s)]. Asi,
   el slice @c(meses[1:13]) se refiere a toda la gama de meses validos, como lo
   hace el slice @c(meses[1:]); el slice @c(meses[:]) se refiere a todo el
   arreglo. Vamos a definir slices superpuestos para el segundo trimestre y el
   verano boreal:

   ..src > go
     Q2 := meses[4:7]
     verano := meses[6:9]
     fmt.Println(Q2)     // ["Abril" "Mayo" "Junio"]
     fmt.Println(verano) // ["Junio" "Julio" "Augosto"]
   < src..

   Junio ​​se incluye en ambos y es la unica salida de esta (ineficiente) prueba
   para elementos comunes:

   ..src > go
     for _, s := range verano {
       for _, q := range Q2 {
         if s == q {
           fmt.Printf("%s aparece en ambos\n", s)
         }
       }
     }
   < src..

   Seccionar mas alla de @c[cap(s)] causa un panico, pero seccionar mas alla
   @c[len(s)] extiende el slice, por lo que el resultado puede ser mas largo que
   el original:

   ..src > go
     fmt.Println(verano[:20])    // panico: fuera de rango

     veranoSinFin := verano[:5] // ampliar slice (dentro de la capacidad)
     fmt.Println(veranoSinFin)  // "[Junio Julio Augosto Septiembre Octubre]"
   < src..

   Como anotacion, tenga en cuenta la similitud de la operacion de subcadena en
   cadenas con el operador slice en slices de @c([]byte). Ambos se escriben
   @c(x[m:n]), y ambos vuelven una subsecuencia de los bytes originales,
   compartiendo la representacion subyacente de modo que ambas operaciones toman
   tiempo constante. La expresion @c(x[m:n]) produce una cadena si @c(x) es una
   cadena, o un @c([]byte) si @c(x) es un @c([]byte).

   Dado que un slice contiene un puntero a un elemento de un arreglo, el paso de
   un slice a una funcion permite a la funcion modificar los elementos del
   arreglo subyacente. En otras palabras, la copia de una slice crea un alias
   (@l(#Seccion 2.3.2<>§2.3.2)) para el arreglo subyacente. La funcion
   @c(reverse) invierte los elementos de un slice @c([]int) en su lugar, y se
   puede aplicar a slices de cualquier longitud.

   ..figure > @l(gopl.io/ch4/rev/main.go<>gopl.io/ch4/rev)

     ..src > go
       // reverse invierte un slice de enteros en su posicion.
       func reverse(s []int) {
         for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
           s[i], s[j] = s[j], s[i]
         }
       }
     < src..


   Aqui invertimos todo el conjunto:

   ..src > go
     a := [...]int{0, 1, 2, 3, 4, 5}
     reverse(a[:])
     fmt.Println(a) // "[5 4 3 2 1 0]"
   < src..

   Una forma sencilla de @e(rotar) un slice a la izquierda @m(n) elementos es
   aplicar la funcion @c(reverse) tres veces, primero a los @m(n) elementos
   iniciales, luego a los elementos restantes, y finalmente a todo el slice.
   (Para rotar a la derecha, primero haga la tercer llamada.)

   ..src > go
     s := []int{0, 1, 2, 3, 4, 5}
     // rotar s a la izquierda dos posiciones.
     reverse(s[:2])
     reverse(s[2:])
     reverse(s)
     fmt.Println(s) // "[2 3 4 5 0 1]"
   < src..

   Observe como la expresion que inicializa el slice @c(s) difiere de la del
   arreglo de @c(a). Una @e(slice literal) se ve similar a un arreglo literal,
   una secuencia de valores separados por comas y rodeada por llaves, pero el
   tamaño no se proporciona. Esto crea implicitamente una variable de arreglo
   del tamaño correcto y produce una division que apunta a el. Al igual que con
   los arreglos literales, los slices literales pueden especificar los valores
   en orden, o dar sus indices explicitamente, o usar una mezcla de los dos
   estilos.

   A diferencia de los arreglos, los slices no son comparables, por lo que no
   pueden usar @c(==) para probar si dos slices contienen los mismos elementos.
   La libreria estandar proporciona la funcion @c(bytes.Equal) altamente
   optimizada para comparar dos slices de bytes (@c([]byte)), pero para otros
   tipos de slice, tenemos que hacer la comparacion nosotros mismos:

   ..src > go
     func equal(x, y []string) bool {
       if len(x) != len(y) {
         return false
       }
       for i := range x {
         if x[i] != y[i] {
           return false
         }
       }
       return true
     }
   < src..

   En vista de lo natural, que es esta prueba de igualdad de la @"(profundidad),
   y que no es mas costosa en tiempo de ejecucion que el operador @c(==) para
   arreglos de cadenas, puede ser desconcertante que la comparacion de slice no
   funcionen tambien de esta manera. Hay dos razones por las cuales la
   equivalencia de profunda es problematica. En primer lugar, a diferencia de
   los elementos del arreglo, los elementos de un slice son indirectos, lo que
   hace posible que una slice se contenga a si mismo. Aunque hay maneras de
   tratar con tales casos, ninguno es simple, eficiente, y lo mas importante,
   obvio.

   En segundo lugar, debido a que los elementos del slice son indirectos, un
   valor fijo del slice puede contener diferentes elementos en momentos
   diferentes a medida que se modifican los contenidos del arreglo
   subyacente. Dado que una tabla hash como el tipo de mapa de Go solo hace
   copias poco profundas de sus claves, requiere que la igualdad para cada clave
   permanezca igual durante toda la vida de la tabla hash. La equivalencia
   profunda haria asi que los slices no fueran adecuados para ser utilizados
   como mapas de claves. Para los tipos de referencia como punteros y canales,
   el operador @c(==) prueba la @e(identidad de la referencia), es decir, si las
   dos entidades se refieren a la misma cosa. Una prueba de igualdad
   @"(superficial) similar para slices podria ser util, y resolveria el problema
   con los mapas, pero el tratamiento inconsistente de slices y arreglos por el
   operador @c(==) seria confuso. La opcion mas segura es no permitir
   comparaciones de slices por completo.

   La unica comparacion legal en slices es contra @c(nil), como en

   ..src > go
     if summer == nil { /* ... */ }
   < src..

   El valor cero de un tipo slice es @c(nil). Un slice nil no tiene arreglo
   subyacente. El slice nil tiene longitud y capacidad cero, pero tambien hay
   slices no nulos de longitud y capacidad cero, como @c([]int{}) o
   @c{make([]int, 3)[3:]}. Como con cualquier tipo que puede tener valores
   nulos, el valor nulo de un tipo de segmento particular puede ser escrito
   utilizando una expresion de conversion como @c{[]int(nil)}.

   ..src > go
     var s []int    // len(s) == 0, s == nil
     s = nil        // len(s) == 0, s == nil
     s = []int(nil) // len(s) == 0, s == nil
     s = []int{}    // len(s) == 0, s != nil
   < src..

   Por lo tanto, si usted necesita probar si una slice esta vacio, utilice
   @c[len(s) == 0], no @c(s == nil). Ademas de comparar la igualdad con @c(nil),
   una slice nil se comporta como cualquier otro slice de longitud cero; por
   ejemplo, @c[reverse(nil)] es perfectamente seguro. A menos que se demuestre
   claramente lo contrario, las funciones de Go deben tratar todos los slices de
   longitud cero de la misma manera, sea o no nulo.

   La funcion nativa @c(make) crea un slice de un tipo de elemento, con longitud
   y capacidad especifico. Se puede omitir el argumento capacidad, en cuyo caso
   la capacidad es igual a la longitud.

   ..src > go
     make([]T, len)
     make([]T, len, cap) // igual que make([]T, cap)[:len]
   < src..

   Bajo el capo, @c(make) crea una variable de arreglo sin nombre y devuelve un
   slice de este; El arreglo es accesible solo a traves del slice devuelto. En
   la primera forma, el slice es una vista de todo el arreglo. En el segundo, el
   slice es una vista de solo los primeros @c(len) elementos, pero su capacidad
   incluye toda el arreglo arreglo. Los elementos adicionales se reservan para
   el futuro crecimiento.

*** Seccion 4.2.1 <> La Funcion @c(append)

    La funcion nativa @c(append) agrega elementos a slices:

    ..src > go
      var runes []rune
      for _, r := range "Hello, 世界" {
        runes = append(runes, r)
      }
      fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' 'B' 'F']"
    < src..

    El bucle utiliza @c(append) para construir el slice codificado de nueve
    runas literales, aunque este problema especifico se resuelve mas
    convenientemente mediante el uso de la conversion nativa @c{[]rune("Hello,
    世界")}.

    La funcion @c(append) es crucial para la comprension de como trabajan los
    slices, asi que vamos a echar un vistazo a lo que esta pasando. Aqui hay una
    version llamada @c(appendInt) que se especializa en slices @c([]int):

    ..figure > @l(gopl.io/ch4/append/main.go<>gopl.io/ch4/append)

      ..src > go
        func appendInt(x []int, y int) []int {
          var z []int
          zlen := len(x) + 1
          if zlen <= cap(x) {
            // Hay espacio para crecer. Extiende el slice
            z = x[:zlen]
          } else {
            // No hay suficiente espacio.  Asigna un nuevo arreglo.
            // Crecer al doble, para compenzar la complejidad lineal.
            zcap := zlen
            if zcap < 2*len(x) {
              zcap = 2 * len(x)
            }
            z = make([]int, zlen, zcap)
            copy(z, x) // a built-in function; see text
          }
          z[len(x)] = y
          return z
        }
      < src..


    Cada llamada a @c(appendInt) debe comprobar si el slice tiene capacidad
    suficiente para contener los nuevos elementos en el arreglo existente. Si es
    asi, se extiende el slice mediante la definicion de una slice mas grande
    (todavia dentro de la arreglo original), copia el elemento @c(y) en el nuevo
    espacio, y devuelve el slice. La entrada @c(x) y el resultado @c(z)
    comparten el misma arreglo subyacente.

    Si no hay suficiente espacio para el crecimiento, @c(appendInt) debe asignar
    un nueva arreglo lo suficientemente grande para contener el resultado,
    copiar los valores de @c(x) en el y, a continuacion, añadir el nuevo
    elemento @c(y). Ahora el resultado @c(z) hace referencia a un arreglo
    subyacente diferente al que referia el arreglo @c(x).

    Seria facil copiar los elementos con bucles explicitas, pero es mas facil
    utilizar la funcion nativa @c(copy), que copia los elementos de un slice a
    otro del mismo tipo. Su primer argumento es el destino y el segundo es la
    fuente, parecido al orden de los operandos de una asignacion como @c(dst =
    src). Los slices pueden referirse al mismo arreglo subyacente; Incluso
    pueden superponerse. Aunque no lo usamos aqui, @c(copy) devuelve el numero
    de elementos copiados realmente, que es la longitud del menor de los slices,
    por lo que no hay peligro de se acabe o sobreescriba algo fuera del rango.

    Por eficiencia, el nueva arreglo es generalmente algo mayor que el minimo
    necesario para almacenar @c(x) y @c(y). La expandir el arreglo duplicando su
    tamaño en cada expansion evita un numero excesivo de asignaciones y asegura
    que anexar un solo elemento tome un tiempo constante en promedio. Este
    programa demuestra el efecto:

    ..src > go
      func main() {
        var x, y []int
        for i := 0; i < 10; i++ {
          y = appendInt(x, i)
          fmt.Printf("%d cap=%d\t%v\n", i, cap(y), y)
          x = y
        }
      }
    < src..

    Cada cambio de capacidad indica una asignacion y una copia:

    ..pre >
      0  cap=1     [0]
      1  cap=2     [0 1]
      2  cap=4     [0 1 2]
      3  cap=4     [0 1 2 3]
      4  cap=8     [0 1 2 3 4]
      5  cap=8     [0 1 2 3 4 5]
      6  cap=8     [0 1 2 3 4 5 6]
      7  cap=8     [0 1 2 3 4 5 6 7]
      8  cap=16    [0 1 2 3 4 5 6 7 8]
      9  cap=16    [0 1 2 3 4 5 6 7 8 9]
    < pre..


    Echemos un vistazo mas cercano a la iteracion @c(i=3). El slice @c(x)
    contiene tres elementos @c([0 1 2]), pero tiene la capacidad de 4, por lo
    que hay un solo elemento de holgura en el extremo, y agrerar el elemento 3
    procede sin reasignacion en @c(appendInt). El slice @c(y) resultante tiene
    longitud y capacidad 4, y tiene el mismo arreglo subyacente que el slice
    @c(x) original, como lo muestra la Figura 4.2.

    ..figure > Figura 4.2. Adicion con espacio para crecer.

      ..img > img/Figure-4.2.jpg


    En la siguiente iteracion, @c(i=4), no hay holgura en absoluto, por lo que
    @c(appendInt) asigna un nueva arreglo de tamaño 8, copia los cuatro
    elementos de @c(x) (@c([0 1 2 3])), y agrega 4, el valor de @c(i). El slice
    resultante @c(y) tiene una longitud de 5, pero una capacidad de 8; La
    holgura de 3 guardara las siguientes tres iteraciones. Las slices @c(y) y
    @c(x) son vistas de diferentes arreglos. Esta operacion se muestra en la
    Figura 4.3.

    ..figure > Figura 4.3. Adicion sin crear espacio.

      ..img > img/Figure-4.3.jpg


    La funcion nativa @c(append) puede utilizar una estrategia de crecimiento
    mas sofisticado que la simplista @c(appendInt). Por lo general, no sabemos
    si una llamada a @c(append) provocara una reasignacion, asi que no podemos
    asumir que el slice original se refiere al mismo arreglo que el slice
    resultante, ni que este se refiere a uno diferente. Del mismo modo, no
    debemos suponer que las operaciones sobre los elementos del antiguo slice se
    reflejaran (o no) en la nuevo slice. Como resultado de ello, es habitual
    asignar el resultado de una llamada a @c(append) al mismo slice cuyo valor
    pasamos a @c(append):

    ..src > go
      runes = append(runes, r)
    < src..

    La actualizacion de la variable slice se requiere no solo al llamar a
    @c(append), sino tambien a cualquier funcion que pueda cambiar la longitud o
    la capacidad de una slice o hacer que se refiere a un arreglo subyacente
    diferente. Para usar los slices correctamente, es importante tener en cuenta
    que aunque los elementos del arreglo subyacente son indirectos, el puntero,
    la longitud y la capacidad de la slice no lo son. Para actualizarlos se
    requiere una asignacion como la anterior. En este sentido, los slices no son
    los tipos de referencia @"(puros), sino que se asemejan a un tipo de
    agregado como esta estructura:

    ..src > go
      type IntSlice struct {
        ptr      *int
        len, cap int
      }
    < src..

    Nuestra funcion @c(appendInt) añade un elemento a un slice, pero el
    @c(append) nativo nos permite añadir mas de un elemento nuevo, o incluso
    todo un slice de ellos.

    ..src > go
      var x []int
      x = append(x, 1)
      x = append(x, 2, 3)
      x = append(x, 4, 5, 6)
      x = append(x, x...) // añade el slice x
      fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
    < src..

    Con la pequeña modificacion se muestra a continuacion, podemos hacer
    coincidir el comportamiento con el @c(append) nativo. Los puntos suspensivos
    (@c("...")) en la declaracion de @c(appendInt) crean una funcion
    @e(variadic): acepta cualquier numero de argumentos finales. Los puntos
    suspensivos en la llamada @c(append) anterior muestran como suministrar una
    lista de argumentos apartir de un slice. Vamos a explicar este mecanismo en
    detalle en la @l(#Seccion 5.7).

    ..src > go
      func appendInt(x []int, y ...int) []int {
        var z []int
        zlen := len(x) + len(y)
        // ...expand z to at least zlen...
        copy(z[len(x):], y)
        return z
      }
    < src..

    La logica para expandir el arreglo @c(z) subyacente, se mantiene sin
    cambios y no se muestra.

*** Seccion 4.2.2 <> Tecnicas de Slices In Situ

    Veamos mas ejemplos de funciones que, como @c(rotate) y @c(reverse), modifican
    los elementos de un slice en su lugar. Dada una lista de cadenas, la
    funcion @c(nonempty) devuelve las que no estan vacias:

    ..figure > @l(gopl.io/ch4/nonempty/main.go<>gopl.io/ch4/nonempty)

      ..src > go
        // Nonempty es un ejemplo de algoritmo in situ.
        package main

        import "fmt"

        // nonempty regresa un slice que contiene solo las cadenas no vacias.
        // El arreglo subyacente se modifica durante la llamada.
        func nonempty(strings []string) []string {
          i := 0
          for _, s := range strings {
            if s != "" {
              strings[i] = s
              i++
            }
          }
          return strings[:i]
        }
      < src..


    La parte sutil es que la porcion de entrada y la porcion de salida comparten
    el mismo arreglo subyacente. Esto evita la necesidad de asignar otro
    arreglo, aunque por supuesto los contenidos de datos se sobrescriben en
    parte, como se evidencia por la segunda instruccion de impresion:

    ..src > go
      data := []string{"uno", "", "tres"}
      fmt.Printf("%q\n", nonempty(data)) // `["uno" "tres"]`
      fmt.Printf("%q\n", data)           // `["uno" "tres" "tres"]`
    < src..

    Por lo tanto normalmente escribe: @c[data = nonempty(data)].

    La funcion @c(nonempty) tambien se puede escribir utilizando @c(append):

    ..src > go
      func nonempty2(strings []string) []string {
        out := strings[:0] // slice del original con longitud cero
        for _, s := range strings {
          if s != "" {
            out = append(out, s)
          }
        }
        return out
      }
    < src..

    Cualquiera que sea la variante que utilicemos, la reutilizacion de un
    arreglo de este modo requiere que se produzca como maximo un valor de salida
    para cada valor de entrada, lo que es cierto para muchos algoritmos que
    filtran elementos de una secuencia o combinan elementos adyacentes. Este uso
    intrincado de un slice es la excepcion, no la regla, pero puede ser clara,
    eficiente y util en ocasiones.

    Se puede usar un slice para implementar una pila. Dada que tenemos un slice
    vacio @c(stack), podemos empujar un nuevo valor en el extremo del slice con
    @c(append):

    ..src > go
      stack = append(stack, v) // push v
    < src..

    La parte superior del stack es el ultimo elemento:

    ..src > go
      top := stack[len(stack)-1] // parte superior del stack
    < src..

    y para  sacar el elemento del stack es

    ..src > go
      stack = stack[:len(stack)-1] // sacar
    < src..

    Para eliminar un elemento a la mitad de una slice, preservando el orden de
    los elementos restantes, utilice @c(copy) para deslizar los elementos de
    numeros mas altos hacia abajo por uno, para llenar el hueco:

    ..src > go
      func remove(slice []int, i int) []int {
        copy(slice[i:], slice[i+1:])
        return slice[:len(slice)-1]
      }
      func main() {
        s := []int{5, 6, 7, 8, 9}
        fmt.Println(remove(s, 2)) // "[5 6 8 9]"
      }
    < src..

    Y si no necesitamos preservar el orden, podemos solo mover el ultimo
    elemento al hueco:

    ..src > go
      func remove(slice []int, i int) []int {
        slice[i] = slice[len(slice)-1]
        return slice[:len(slice)-1]
      }
      func main() {
        s := []int{5, 6, 7, 8, 9}
        fmt.Println(remove(s, 2)) // "[5 6 9 8]
      }
    < src..

   @b(Ejercicio 4.3): Reescribir @c(reverse) para utilizar un puntero a
   un arreglo en lugar de un slice.

   @b(Ejercicio 4.4): Escribir una version de @c(rotate) que opere en una sola
   pasada.

   @b(Ejercicio 4.5): Escribir una funcion in situ para eliminar duplicados
   adyacentes en una slice @c([]string).

   @b(Ejercicio 4.6): Escribir una funcion in situ que aplaste cada sequencia
   Unicode de espacios adyacentes (ver @c(unicode.IsSpace)) en un slice
   @c([]byte) codificado en UTF-8 en solo espacio ASCII.

   @b(Ejercicio 4.7): Modificar @c(reverse) para invertir in situ los caracteres
   de una slice @c([]byte) que represente una cadena codificado en
   UTF-8. ¿Puedes hacerlo sin asignar nueva memoria?

** Seccion 4.3 <> Mapas

   La tabla hash es una de las mas ingeniosas y versatiles de todas las
   estructuras de datos. Es una coleccion desordenada de pares clave/valor en la
   que todas las claves son distintas, y el valor asociado con una clave dada
   puede ser recuperado, actualizado o eliminado, usando un numero constante de
   comparaciones clave en promedio, no importa cuan grande sea el tamaño de la
   tabla hash.

   En Go, un @e(mapa) es una referencia a una tabla hash, y un tipo de mapa se
   escribe como @c(map[K]V), en donde @c(K) y @c(V) son los tipos de sus claves
   y valores. Todas las claves en un mapa son del mismo tipo, y todos los
   valores son del mismo tipo, pero las claves no necesitan ser del mismo tipo
   que los valores. El tipo de clave @c(K) debe ser comparable usando @c(==), de
   modo que el mapa puede probar si una clave dada es igual a una que ya esta
   dentro de ell. Aunque los numeros de punto flotante son comparables, es una
   mala idea comparar floats por igualdad y, como mencionamos en el @l(#Capitulo
   3), es especialmente malo si NaN es un valor posible. No hay restricciones
   sobre el tipo de valor @c(V).

   Se puede utilizar la funcion nativa @c(make) para crear un mapa:

   ..src > go
     edades := make(map[string]int) // mapeo de cadenas a ints
   < src..

   Tambien podemos usar un @e(mapa literal) para crear un nuevo mapa poblada con
   algunos pares iniciales clave/valor:

   ..src > go
     edades := map[string]int{
       "alice":   31,
       "charlie": 34,
     }
   < src..

   Esto es equivalente a

   ..src > go
     edades := make(map[string]int)
     edades["alice"] = 31
     edades["charlie"] = 34
   < src..

   por lo que una expresion alternativa para un nuevo mapa vacio es
   @c(map[string]int{}).

   Los elementos del mapa se acceden a traves de la notacion de subindice usual:

   ..src > go
     edades["alice"] = 32
     fmt.Println(edades["alice"]) // "32"
   < src..

   y se remueve con la funcion nativa @c(delete):

   ..src > go
     delete(edades, "alice") // remover elemento ages["alice"]
   < src..

   Todas estas operaciones son seguras incluso si el elemento no esta en el
   mapa; una busqueda en el mapa utulizando una clave que no esta presente
   devuelve el valor cero para su tipo, por ejemplo, lo siguiente funciona
   incluso cuando @c("bob") aun no es una clave en el mapa, por lo que el valor
   de @c(edades["bob"]) sera 0.

   ..src > go
     edades["bob"] = edades["bob"] + 1 // feliz cumpleaños!
   < src..

   Las formas de asignacion abreviada @c(x += y) y @c(x++) tambien funcionan
   para elementos del mapa, asi que podemos rescribir la sentencia anterior como

   ..src > go
     edades["bob"] += 1
   < src..

   O incluso mas conciso como

   ..src > go
     edades["bob"]++
   < src..

   Pero un elemento del mapa no es una variable, y no podemos tomar su
   direccion:

   ..src > go
     _ = &ages["bob"] // error de compilacion: no puede tomar la direccion del elemento mapa
   < src..

   Una de las razones por las que no podemos tomar la direccion de un elemento
   de un mapa es que el crecimiento de un mapa podria provocar la reorganizacion
   de elementos existentes en nuevas ubicaciones de almacenamiento, lo que
   podria invalidar la direccion.

   Para enumerar todos los pares clave/valor en el mapa, se utiliza un bucle
   @c(for) basado en @c(range) similar al que vimos para los slices. Las
   iteraciones sucesivas del bucle hacen que las variables @c(name) y @c(age) se
   establecen en el siguiente par clave/valor:

   ..src > go
     for nombre, edad := range edades {
       fmt.Printf("%s\t%d\n", nombre, edad)
     }
   < src..

   El orden de iteracion del mapa no se especifica, y las diferentes
   implementaciones pueden utilizar una funcion de hash diferente, lo que
   conduce a un orden diferente. En la practica, el orden es aleatorio, variando
   de una ejecucion a la siguiente. Esto es intencional; Haciendo que la
   secuencia varie ayuda a obligar a los programas a ser robustos en todas las
   implementaciones. Para enumerar los pares clave/valor en orden, hay que
   ordenar las claves de forma explicita, por ejemplo, mediante la funcion
   @c(Strings) del paquete @c(sort) si las claves son cadenas. Este es un patron
   comun:

   ..src > go
     import "sort"

     var nombres []string
     for nombre := range edades {
       nombres = append(nombres, nombre)
     }

     sort.Strings(nombres)
     for _, nombre := range nombres {
       fmt.Printf("%s\t%d\n", nombre, edades[nombre])
     }
   < src..

   Dado que sabemos el tamaño final de nombres desde el principio, es mas
   eficiente asignar un arreglo del tamaño requerido por adelantado. La
   siguiente declaracion crea un slice que esta inicialmente vacio, pero tiene
   la capacidad suficiente para contener todas las llaves del mapa @e(edades):

   ..src > go
     nombres := make([]string, 0, len(edades))
   < src..

   En el primer @c(range) del bucle anterior, solo necesitamos las llaves claves
   del mapa @c(edades), por lo que se omite la segunda variable de bucle. En el
   segundo bucle, se requieren solo los elementos del slice @c(nombres), por lo
   que se utiliza el identificador en blanco @c(_) para ignorar la primer
   variable, el indice.

   El valor cero para el tipo de un mapa es @c(nil), es decir, una referencia a
   ninguna tabla hash en absoluto.

   ..src > go
     var edades map[string]int
     fmt.Println(edades == nil)    // "true"
     fmt.Println(len(edades) == 0) // "true"
   < src..

   La mayoria de las operaciones en los mapas, incluyendo las operaciones de
   busqueda, @c(delete), @c(len) y bucles @c(range), son seguros para llevar a
   cabo en un mapa de referencia a @c(nil), ya que se comporta como un mapa
   vacio. Pero almacenar en un mapa nil provoca un panico:

   ..src > go
     ages["carol"] = 21 // panic: assignment to entry in nil map
   < src..

   Debe asignar el mapa antes de poder almacenarlo.

   El acceso a un elemento de un mapa mediante subindice siempre produce un
   valor. Si la clave esta presente en el mapa, se obtiene el valor
   correspondiente; si no, se obtiene el valor cero para el tipo de elemento,
   como hemos visto con @c(edades["bob"]). Para muchos propositos eso esta bien,
   pero a veces necesitas saber si el elemento estaba realmente ahi o no. Por
   ejemplo, si el tipo de elemento es numerico, es posible que tenga que
   distinguir entre un elemento inexistente y un elemento que tiene el valor
   cero, mediante una prueba como esta:

   ..src > go
     edad, ok := edades["bob"]
     if !ok { /* "bob" no es una clave en este mapa; edad == 0. */ }
   < src..

   A menudo vera estas dos afirmaciones combinadas, como aqui:

   ..src > go
     if age, ok := ages["bob"]; !ok { /* ... */ }
   < src..

   El subindice de un mapa en este contexto produce dos valores; El segundo es
   un booleano que informa si el elemento estaba presente. La variable booleana
   a menudo se denomina @c(ok), especialmente si se utiliza inmediatamente en
   una condicion @c(if).

   Como con los slices, los mapas no pueden ser compararse uno con otro; la
   unica comparacion legal es con @c(nil). Para probar si dos mapas contienen
   las mismas claves y los mismos valores asociados, debemos escribir un bucle:

   ..src > go
     func equal(x, y map[string]int) bool {
       if len(x) != len(y) {
         return false
       }
       for k, xv := range x {
         if yv, ok := y[k]; !ok || yv != xv {
           return false
         }
       }
       return true
     }
   < src..

   Observe como se utiliza @c(!ok) para distinguir los casos @"(que faltan) y
   los @"(presentes, pero en cero). Si hubieramos escrito ingenuamente @c(xv !=
   y[k]), la llamada de abajo reportaria incorrectamente sus argumentos como
   iguales:

   ..src > go
     // Verdadero si equal esta escrito incorrectamente.
     equal(map[string]int{"A": 0}, map[string]int{"B": 42})
   < src..

   Go no proporciona un tipo @c(set), pero ya que las claves de un mapa son
   distintas, un mapa puede servir a este proposito. Para ilustrarlo, el
   programa @$(dedup) lee una secuencia de lineas e imprime solo la primera
   ocurrencia de cada linea distinta. (Es una variante del programa @$(dup) que
   mostramos en la @l(#Seccion 1.3)). El programa @$(dedup) utiliza un mapa
   cuyas claves representan el conjunto de lineas que ya han aparecido para
   asegurar que las ocurrencias posteriores no se impriman.

   ..figure > @l(gopl.io/ch4/dedup/main.go<>gopl.io/ch4/dedup)

     ..src > go
       func main() {
         consulta := make(map[string]bool) // un conjunto de cadenas
         entrada  := bufio.NewScanner(os.Stdin)
         for entrada.Scan() {
           linea := input.Text()
           if !consulta[linea] {
             consulta[linea] = true
             fmt.Println(linea)
           }
         }

         if err := entrada.Err(); err != nil {
           fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
           os.Exit(1)
         }
       }
     < src..


   Los programadores de Go a menudo describen un mapa de esta manera
   utilizandolo como un @"(conjunto de cadenas) sin mas preambulos, pero
   cuidado, no todo los valores @c(map[string]bool) son conjuntos simples;
   algunos pueden contener valores tanto @c(true) y @c(false).

   A veces necesitamos un mapa o conjunto cuyas claves sean slices, pero ya que
   las claves de un mapa deben ser comparables, esto se no puede expresar
   directamente. Sin embargo, se puede hacer en dos pasos. Primero definimos una
   funcion auxiliar @c(k) que mapea cada clave en una cadena, con la
   caracteristica que @c[k(x) == k(y)] si y solo si consideramos @c(x) e @c(y)
   equivalentes. Luego creamos un mapa cuyas claves son cadenas, aplicando la
   funcion auxiliar a cada clave antes de acceder al mapa.

   El siguiente ejemplo utiliza un mapa para registrar el numero de veces que se
   ha llamado a @c(Add) con una lista dada de cadenas. Utiliza @c(fmt.Sprintf)
   para convertir un slice de cadenas en una sola cadena que es una clave de
   mapa adecuada, citando cada elemento del slice con @c(%q) para registrar los
   limites de las cadena fielmente:

   ..src > go
     var m = make(map[string]int)

     func k(list []string) string  { return fmt.Sprintf("%q", list) }

     func Add(list []string)       { m[k(list)]++ }
     func Count(list []string) int { return m[k(list)] }
   < src..

   El mismo enfoque se puede utilizar para cualquier tipo de clave no
   comparable, no solo para slices. Incluso es util para este tipo de claves
   comparables cuando se desea una definicion de igualdad distinta de @c(==),
   como comparaciones entre mayusculas y minusculas para cadenas. Y el tipo de
   @c[k(x)] no necesita ser una cadena; Cualquier tipo comparable con la
   propiedad de equivalencia deseada lo hara, como enteros, arreglos o
   estructuras.

   Aqui hay otro ejemplo de mapas en accion, un programa que cuenta las
   apariciones de cada punto de codigo Unicode distinto en su entrada. Puesto
   que hay un gran numero de caracteres posibles, solo una pequeña fraccion de
   ellos aparecera en cualquier documento en particular, un mapa es una manera
   natural de hacer un seguimiento de solo los que se han visto y su conteo
   correspondiente.

   ..figure > @l(gopl.io/ch4/charcount/main.go<>gopl.io/ch4/charcount)

     ..src > go
       // Charcount calcula la cuenta de caracteres Unicode.
       package main

       import (
         "bufio"
         "fmt"
         "io"
         "os"
         "unicode"
         "unicode/utf8"
       )

       func main() {
         counts := make(map[rune]int)    // cuenta de caracteres Unicode
         var utflen [utf8.UTFMax + 1]int // cuenta de longitudes de codificaciones UTF-8
         invalid := 0                    // cuenta de caracteres UTF-8 invalidos

         in := bufio.NewReader(os.Stdin)
         for {
           r, n, err := in.ReadRune()    // regresa runa, nbytes, error
           if err == io.EOF {
             break
           }
           if err != nil {
             fmt.Fprintf(os.Stderr, "charcount: %v\n", err)
             os.Exit(1)
           }
           if r == unicode.ReplacementChar && n == 1 {
             invalid++
             continue
           }
           counts[r]++
           utflen[n]++
         }
         fmt.Printf("rune\tcount\n")
         for c, n := range counts {
           fmt.Printf("%q\t%d\n", c, n)
         }
         fmt.Print("\nlen\tcount\n")
         for i, n := range utflen {
           if i > 0 {
             fmt.Printf("%d\t%d\n", i, n)
           }
         }
         if invalid > 0 {
           fmt.Printf("\n%d invalid UTF-8 characters\n", invalid)
         }
       }
     < src..


   El metodo @c(ReadRune) realiza la decodificacion UTF-8 y devuelve tres
   valores: la runa decodificada, la longitud en bytes de su codificacion UTF-8,
   y un valor de error. El unico error que esperamos es el fin de archivo. Si la
   entrada no era la codificacion UTF-8 legal de una runa, la runa devuelta es
   @c(unicode.ReplacementChar) y la su longitud es 1.

   El programa @$(charcount) tambien imprime un recuento de las longitudes de
   las codificaciones UTF-8 de las runas que aparecieron en la entrada. Un mapa
   no es la mejor estructura de datos para eso; ya que las longitudes de
   codificacion varian solo de 1 a utf8.UTFMax (que tiene el valor 4), un
   arreglo es mas compacto.

   Como un experimento, en un momento ejecutamos @$(charcount). Aunque
   (originalmente) esta principalmente en Ingles, por supuesto, tiene un buen
   numero de caracteres no ASCII. Aqui estan los diez primeros:

   ..pre >
     ° 27 世 15 界 14 é 13 ˣ 10 ≤ 5 × 5 𢉩 4 � 4 □ 3

   Y aqui esta la distribucion de las longitudes de todas las codificaciones
   UTF-8:

   ..pre >
     len  count
     1    765391
     2    60
     3    70
     4    0
   < pre..

   El tipo de valor de un mapa puede ser un tipo compuesto, como un mapa o un
   slice. En el siguiente codigo, el tipo de la clave de @c(graph) es @c(string)
   y el tipo de valor es @c(map[string]bool), lo que representa un conjunto de
   cadenas. Conceptualmente, @c(graph) asigna una cadena a un conjunto de cadenas
   relacionadas, sus sucesores en un grafo dirigido.

   ..figure > @l(gopl.io/ch4/graph/main.go<>gopl.io/ch4/graph)

     ..src > go
       var graph = make(map[string]map[string]bool)

       func addEdge(from, to string) {
         edges := graph[from]
         if edges == nil {
           edges = make(map[string]bool)
           graph[from] = edges
         }
         edges[to] = true
       }

       func hasEdge(from, to string) bool {
         return graph[from][to]
       }
     < src..


   La funcion @c(addEdge) muestra la forma idiomatica para poblar un mapa
   perezosamente, es decir, para inicializar cada valor como su clave cuando
   aparece por primera vez. La funcion @c(hasEdge) muestra como el valor cero de
   una entrada del mapa que falta se pone a trabajar: incluso si no estan
   precentes ni @c(from) ni @c(to), @c(graph[from][to]) siempre dara un
   resultado significativo.

   @b(Ejercicio 4.8): Modificar @$(charcount) para contar letras, digitos, y
   demas en sus categorias Unicode, utilizando funciones como
   @c(unicode.IsLetter).

   @b(Ejercicio 4.9): Escribir un programa @$(wordfreq) para reportar la
   frecuencia de cada palabra en un archivo de texto de entrada. Llamar a
   @c[input.Split(bufio.ScanWords)] antes de la primer llamada a @c(Scan) para
   romper la entrada en palabras en lugar de lineas.

** Seccion 4.4 <> Estructuras

   Una @e(estructura) es un tipo de datos agregada que agrupa de cero a mas
   valores con nombre de tipos arbitrarios como una entidad unica. Cada valor se
   denomina @e(campo). El ejemplo clasico de una estructura de procesamiento de
   datos es el registro de un empleado, cuyos campos son un identificador unico,
   el nombre del empleado, direccion, fecha de nacimiento, posicion, salario,
   gerente y similares. Todos estos campos se recopilan en una sola entidad que
   puede ser copiada como una unidad, pasada a funciones y devuelta por ellas,
   almacenada en arreglos, y demas.

   Estas dos declaraciones declaran un tipo de estructura llamada @c(Empleado) y una
   variable llamada @c(dilbert) que es una instancia de un @c(Empleado):

   ..src > go
     type Empleado struct {
       ID        int
       Nombre    string
       Direccion string
       DoB       time.Time
       Posicion  string
       Salario   int
       GerenteID int
     }

     var dilbert Empleado
   < src..

   Los campos individuales de @c(dilbert) se accede usando la notacion de punto
   como @c(dilbert.Nombre) y @c(dilbert.DoB). Puesto que @c(dilbert) es una
   variable, sus campos son variables tambien, por lo que podemos establecer un
   campo:

   ..src > go
     dilbert.Salario -= 5000 // Rebajado, por escribir muy pocas lineas de codigo
   < src..

   O tomar su direccion y acceder a ella a traves de un puntero:

   ..src > go
     posicion := &dilbert.Posicion
     *posicion = "Senior " + *posicion // promovido, para subcontrata a Elbonia
   < src..

   La notacion de punto tambien funciona con un puntero a una estructura:

   ..src > go
     var empleadoDelMes *Empleado = &dilbert
     empleadoDelMes.Posicion += " (proactive team player)"
   < src..

   La ultima sentencia es equivalente a

   ..src > go
     (*empleadoDelMes).Posicion += " (proactive team player)"
   < src..

   Ya que un empleado tiene un ID unico, la funcion @c(EmpleadoPorID) devuelve
   un puntero a una estructura @c(Empleado). Podemos usar la notacion de punto
   para acceder a sus campos:

   ..src > go
     func EmpleadoPorID(id int) *Empleado { /* ... */ }

     fmt.Println(EmpleadoPorID(dilbert.GerenteID).Posicion) // "Jefe de pelo puntiagudo"

     id := dilbert.ID
     EmpleadoPorID(id).Salario = 0 // despedido por... ninguna razon real
   < src..

   La ultima instruccion actualiza la estructura @c(Empleado) a la que apunta el
   resultado de la llamada a @c(EmpleadoPorID). Si el tipo de resultado de
   @c(EmpleadoPorID) se cambiara a @c(Empleado) en lugar de @c(*Empleado), la
   instruccion de asignacion no compilara ya que su lado izquierdo no
   identificaria a una variable.

   Generalmente, se escribe un campo por linea, con el nombre del campo que
   precede a su tipo, pero pueden combinarse los campos consecutivos del mismo
   tipo, como con @c(Nombre) y @c(Direccion):

   ..src > go
     type Empleado struct {
       ID                int
       Nombre, Direccion string
       DoB               time.Time
       Posicion          string
       Salario           int
       GerenteID         int
     }
   < src..

   El orden del campo es significativo para identificar el tipo. Si hubieramos
   combinado tambien la declaracion del campo @c(Posicion) (tambien una cadena),
   o intercambiado @c(Nombre) y @c(Direccion), estariamos definiendo un tipo de
   estructura diferente. Normalmente solo combinamos la declaracion de campos
   relacionados.

   El nombre de un campo en la estructura se exporta si comienza con una letra
   mayuscula; este es el mecanismo principal de control de acceso en Go. Una
   estructura puede contener una mezcla de campos exportados y no exportados.

   Los tipos estructura tienden a ser detallados porque a menudo implican una
   linea para cada campo. Aunque podriamos escribir todo el tipo cada vez que
   sea necesario, la repeticion cansaria. En cambio, los tipos estructura suelen
   aparecer dentro de la declaracion de un tipo con nombre como @c(Empleado).

   Un llamado tipo de estructura @c(S) no puede declarar un campo del mismo tipo
   @c(S): un valor agregado no puede contenerse a si mismo. (Una restriccion
   analoga se aplica a los arreglos.) Pero @c(S) puede declarar un campo del
   tipo puntero @c(*S), lo que nos permite crear estructuras de datos recursivas
   como listas enlazadas y arboles. Esto se ilustra en el siguiente codigo, que
   utiliza un arbol binario para implementar un tipo de insercion:

   ..figure > @l(gopl.io/ch4/treesort/sort.go<>gopl.io/ch4/treesort)

     ..src > go
       type tree struct {
         value       int
         left, right *tree
       }

       // Sort ordena los valores en su lugar.
       func Sort(values []int) {
         var root *tree
         for _, v := range values {
           root = add(root, v)
         }
         appendValues(values[:0], root)
       }

       // appendValues agrega los alementos de t a los valores en orden
       // y devuelve el slice resultante.
       func appendValues(values []int, t *tree) []int {
         if t != nil {
           values = appendValues(values, t.left)
           values = append(values, t.value)
           values = appendValues(values, t.right)
         }
         return values
       }

       func add(t *tree, value int) *tree {
         if t == nil {
           // Equivalente a regresar &tree{value: value}.
           t = new(tree)
           t.value = value
           return t
         }
         if value < t.value {
           t.left = add(t.left, value)
         } else {
           t.right = add(t.right, value)
         }
         return t
       }
     < src..


   El valor cero de una estructura se compone de los valores cero de cada uno de
   sus campos. Por lo general, es deseable que el valor cero sea un defecto
   natural o razonable. Por ejemplo, en @c(bytes.Buffer), el valor inicial de la
   estructura es un buffer vacio listo para su uso, y el valor cero de
   @c(sync.Mutex), que veremos en el @l(#Capitulo 9), es un mutex desbloqueado
   listo para usas. A veces este comportamiento inicial razonable ocurre de
   forma gratuita, pero a veces el diseñador de tipo tiene que trabajar en ello.

   El tipo de una estructura sin campos se denomina @e(estructura vacia), se
   escribe @c(struct{}). Tiene un tamaño cero y no lleva ninguna informacion,
   sin embargo puede ser util. Algunos programadores lo utilizan en lugar de
   @c(bool) como el tipo de valor de un mapa que representa un conjunto, hacer
   hincapie en que solo las claves son significativas, pero el ahorro de espacio
   es marginal y la sintaxis es mas engorrosa, por lo que generalmente lo
   evitamos.

   ..src > go
     seen := make(map[string]struct{}) // conjunto de strings
     // ...
     if _, ok := seen[s]; !ok {
       seen[s] = struct{}{}
       // ...primera ves viendo s...
     }
   < src..

*** Seccion 4.4.1 <> Estructuras Literales

    Un valor de un tipo de estructura se puede escribir usando una estructura
    literal que especifique los valores de sus campos.

    ..src > go
      type Point struct{ X, Y int }

      p := Point{1, 2}
    < src..

    Hay dos formas de struct literal. La primer forma, mostrada arriba, requiere
    que se especifique un valor de @e(cada) campo, en el orden correcto. Se
    carga al escritor (y al lector) el recordar exactamente cuales son los
    campos, y hace que el codigo sea fragil si el conjunto de campos crece mas
    tarde o se reordena. En consequencia, esta forma tiende a ser utilizado solo
    dentro del paquete que define el tipo de estructura o con tipos de
    estructuras mas pequeños para los cuales existe una convencion de ordenacion
    de campos obvia, como @c(image.Point{x, y}) o @c(color.RGBA{red, green,
    blue, alpha}).

    Mas a menudo, se utiliza la segunda forma, en la que una estructura se
    inicia haciendo una lista de todos o algunos de los nombres de los campos y
    sus valores correspondientes, como en esta declaracion del programa
    Lissajous de la @l(#Seccion 1.4):

    ..src > go
      anim := gif.GIF{LoopCount: nframes}
    < src..

    Si se omite un campo en este tipo de literal, se establece en el valor cero
    para su tipo. Ya que los nombres se proporcionan, el orden de los campos no
    importa.

    Las dos formas no se pueden mezclar en el mismo literal. Tampoco se puede
    usar la primer forma de literal (basada en ordenes) para colarse alrededor
    de la regla de que los identificadores no exportados no pueden ser referidos
    desde otro paquete.


    ..src > go
      package p
      type T struct{ a, b int } // no se exportan a y b
    < src..

    ..src > go
      package q
      import "p"
      var _ = p.T{a: 1, b: 2} // error de compilacion: no se puede referenciar a, b
      var _ = p.T{1, 2}       // error de compilacion: no se puede referenciar a, b
    < src..

    Aunque la ultima linea no menciona los identificadores de campo no
    exportados, realmente los esta usando implicitamente, por lo que no es
    permitido.

    Los valores de una estructura se pueden pasar como argumentos a funciones y
    ser devueltos. Por ejemplo, esta funcion escala un @c(Point) por un factor
    especifico:

    ..src > go
      func Scale(p Point, factor int) Point {
        return Point{p.X * factor, p.Y * factor}
      }

      fmt.Println(Scale(Point{1, 2}, 5)) // "{5 10}"
    < src..

    Por eficiencia, las estructuras mas grandes normalmente se pasan a las
    funciones o se devuelven indirectamente mediante un puntero,

    ..src > go
      func Bonus(e *Employee, percent int) int {
        return e.Salary * percent / 100
      }
    < src..

    Y esto es necesario si la funcion debe modificar su argumento, ya que en un
    lenguaje de llamada por valor como Go, la funcion llamada recibe solo una
    copia, no una referencia al argumento original.

    ..src > go
      func AwardAnnualRaise(e *Employee) {
        e.Salary = e.Salary * 105 / 100
      }
    < src..

    Debido a que las estructuras se manejan tan comunmente mediante punteros, es
    posible utilizar esta notacion conpacta para crear e inicializar una
    estructura y obtener su direccion:

    ..src > go
      pp := &Point{1, 2}
    < src..

    Es exactamente equivalente a

    ..src > go
      pp := new(Point)
      *pp = Point{1, 2}
    < src..

    pero @c(&Point{1, 2}) se puede utilizar directamente dentro de una
    expresion, como una llamada de funcion.

*** Seccion 4.4.2 <> Comparacion de estructuras

    Si todos los campos de una estructura son comparables, la estructura en si
    es comparable, por lo que se puede comparar dos expresiones de ese tipo
    usando @c(==) o @c(!=). La operacion @c(==) compara los campos
    correspondientes de las dos estructuras en orden, por lo que las dos
    expresiones a continuacion son equivalentes:

    ..src > go
      type Point struct{ X, Y int }

      p := Point{1, 2}
      q := Point{2, 1}
      fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
      fmt.Println(p == q)                   // "false"
    < src..

    Las estructuras de tipos comparables, al igual que otros tipos comparables,
    se pueden utilizar como la clave de un mapa.

    ..src > go
      type address struct {
        hostname string
        port     int
      }

      hits := make(map[address]int)
      hits[address{"golang.org", 443}]++
    < src..

*** Seccion 4.4.3 <> Estructura Enbebida y Campos Anonimos

    En esta seccion, veremos como utilizar el inusual mecanismo de @e(estructura
    enbebida) de Go que nos permite usar una estructura como un @e(campo
    anonimo) de otra estructura, proporcionando un acceso directo,
    sintacticamente conveniente para que una simple expresion de punto como
    @c(x.f) puede representar una cadena de campos como @c(x.d.e.f).

    Considere un programa de dibujo 2-D que proporciona una libreria de formas,
    como rectangulos, elipses, estrellas y ruedas. Aqui hay dos de los tipos que
    podria definir:

    ..src > go
      type Circulo struct {
        X, Y, Radio int
      }
      type Rueda struct {
        X, Y, Radio, Rayos int
      }
    < src..

    Un @c(Circulo) tiene campos para las coordenadas de su centro @c(X) y @c(Y),
    y un @c(Radio). Una @c(Rueda) tiene todas las caracteristicas de un
    @c(Circulo), ademas de @c(Rayos), el numero de radios radiales
    inscritos. Vamos a crear una rueda:

    ..src > go
      var w Rueda
      w.X = 8
      w.Y = 8
      w.Radio = 5
      w.Rayos = 20
    < src..

    A medida que el conjunto de formas crece, estamos obligados a notar
    semejanzas y repeticiones entre ellos, por lo que puede ser conveniente
    factorizar sus partes comunes:

    ..src > go
      type Punto struct {
        X, Y int
      }

      type Circulo struct {
        Centro Punto
        Radio  int
      }

      type Rueda struct {
        Circulo Circulo
        Rayos   int
      }
    < src..

    La aplicacion puede ser mas clara para ello, pero este cambio hace que el
    acceso a los campos de una Rueda sea mas detallado:

    ..src > go
      var w Rueda
      w.Circulo.Centro.X = 8
      w.Circulo.Centro.Y = 8
      w.Circulo.Radio = 5
      w.Rayos = 20
    < src..

    Go nos permite declarar un campo con un tipo pero sin nombre; estos campos
    se denominan campos anonimos. El tipo del campo debe ser un tipo con nombre
    o un puntero a un tipo con nombre. Debajo, @c(Circulo) y @c(Rueda) tienen un
    campo anonimo cada uno. Se dice que un @c(Punto) esta enbebido dentro del
    @c(Circulo), y un @c(Circulo) esta enbebido dentro de la @c(Rueda).

    ..src > go
      type Circulo struct {
        Punto
        Radio int
      }

      type Rueda struct {
        Circulo
        Rayos   int
      }
    < src..

    Gracias al embebido, podemos referirnos a los nombres en las hojas
    del arbol implicitamento sin dar los nombres participantes:

    ..src > go
      var w Rueda
      w.X = 8        // equivalente a w.Circulo.Punto.X = 8
      w.Y = 8        // equivalente a w.Circulo.Punto.Y = 8
      w.Radio = 5    // equivalente a w.Circulo.Radio = 5
      w.Rayos = 20
    < src..

    Las formas explicitas que se muestran en los comentarios anteriores siguen
    siendo validas, sin embargo, demuestra que @"(campo anonimo) es un termino
    inapropiado. Los campos @c(Circulo) y @c(Punto) tienen nombres–del tipo
    nombrado–pero esos nombres son opcionales en las expresiones de punto.
    Podemos omitir cualquiera o todos los campos anonimos al seleccionar sus
    subcampos.

    Desafortunadamente, no hay una sintaxis compacta correspondiente para una
    estructura literal, por lo que ninguna de ellas compilara:

    ..src > go
      w = Wheel{8, 8, 5, 20}                       // error de compilacion: campos desconocidos
      w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // error de compilacion: campos desconocidos
    < src..

    La estructura literal debe seguir el formato de la declaracion del tipo, por
    lo que debemos utilizar una de las siguientes dos formas, que son
    equivalentes entre si:

    ..figure > @l(gopl.io/ch4/embed/main.go<>gopl.io/ch4/embed)

      ..src > go
          w = Rueda{Circulo{Punto{8, 8}, 5}, 20}

          w = Rueda{
            Circulo: Circulo{
              Punto:  Punto{X: 8, Y: 8},
              Radio: 5,
            },
            Rayos: 20, // NOTA: comma necesaria aqui (y en el Radio)
          }

          fmt.Printf("%#v\n", w)
          // Salida:
          // Rueda{Circulo:Circulo{Punto:Punto{X:8, Y:8}, Radio:5}, Rayos:20}

          w.X = 42

          fmt.Printf("%#v\n", w)
          // Salida:
          // Rueda{Circulo:Circulo{Punto:Punto{X:42, Y:8}, Radio:5}, Rayos:20}
      < src..


    Observe como el adverbio @c(#) hace que el verbo @c(%v) de @c(Printf)
    muestre los valores en una forma similar a la sintaxis Go. Para los valores
    de estructura, este formato incluye el nombre de cada campo.

    Dado que los campos @"(anonimos) tienen nombres implicitos, no se puede
    tener dos campos anonimos del mismo tipo, ya que sus nombres entran en
    conflicto. Y debido a que el nombre del campo esta implicitamente
    determinado por su tipo, tambien lo es la visibilidad del campo. En los
    ejemplos anteriores, se exportan campos anonimos @c(Punto) y
    @c(Circulo). Si no hubieran sido exportados (@c(punto) y @c(circulo)),
    podriamos utilizar la forma compacta

    ..src > go
      w.X = 8 // equivalente a w.circulo.punto.X = 8
    < src..

    pero el fomato explicito que se muestra en el comentario estaria prohibido
    fuera del paquete porque @c(circulo) y @c(punto) serian inaccesibles.

    Lo que hemos visto hasta ahora sobre estructuras enbebidas es solo una pisca
    de azucar sintactico en la notacion de punto utilizada para seleccionar los
    campos de la estructura. Mas adelante, veremos que los campos anonimos no
    necesitan ser de tipo estructura; puede ser cualquier tipo con nombre o
    puntero a un tipo con nombre. Pero, ¿para que querrias incorporar un tipo
    que no tiene subcampos?

    La respuesta tiene que ver con los metodos. La notacion compacta utilizada
    para seleccionar los campos de un tipo enbebido funciona para seleccionar
    tambien sus metodos. En efecto, el tipo de estructura externa gana no solo
    los campos del tipo enbebido sino tambien sus metodos. Este mecanismo es la
    forma principal en que los comportamientos de objetos complejos se componen
    de los mas simples. La composicion es fundamental para la programacion
    orientada a objetos en Go, y la exploraremos mas adelante en la @l(#Seccion
    6.3).

** Seccion 4.5 <> JSON

   JavaScript Object Notation (JSON) es una notacion estandar para enviar y
   recibir informacion estructurada. JSON no es la unica notacion. XML
   (@l(#Seccion 7.14<>§7.14)), ASN.1, y Google’s Protocol Buffers sirven a
   propositos similares y cada uno tiene su nicho, pero debido a su simplicidad,
   facilidad de lectura, y un apoyo universal, JSON es el mas utilizado.

   Go tiene un excelente soporte para la codificacion y decodificacion de estos
   formatos, proporcionado por los paquetes de las librerias estandar
   @c(encoding/json) , @c(encoding/xml), @c(encoding/asn1), y demas, y todos
   estos paquetes tienen APIs similares. En esta seccion se presenta una breve
   descripcion de las partes mas importantes del paquete @c(encoding/json).

   JSON es una codificacion de valores JavaScript–cadenas, numeros, booleanos,
   arreglos y objetos–como texto Unicode. Es una representacion eficiente pero
   legible para los tipos de datos basicos del @l(#Capitulo 3) y los tipos
   compuestos de este capitulo–arreglos, slices, estructuras, y mapas.

   Los tipos JSON basicos son numeros (en notacion decimal o cientifica),
   booleanos (@c(true) o @c(false)), y cadenas, que son secuencias de puntos de
   codigo Unicode entre comillas dobles, con escapes mediante la barra invertida
   utilizando una notacion similar a Go, aunque los escapes JSON @c(\U)@e(hhhh)
   denotan codigos UTF-16, no runas.

   Estos tipos basicos se pueden combinar recursivamente utilizando arreglos
   JSON y objetos. Un arreglo JSON es una secuencia ordenada de valores, escrita
   como una lista separada por comas entre corchetes; los arreglos JSON se
   utilizan para codificar arreglos Go y slices. Un objeto JSON es un mapeo de
   cadenas a valores, escrito como una secuencia de pares @c(nombre:valor)
   separados por comas y rodeados por llaves; Los objetos JSON se usan para
   codificar mapas Go (con claves de tipo cadena) y estructuras. Por ejemplo:

   | @c(booleano) | @c(true)                                 |
   |--------------|------------------------------------------|
   | @c(numero)   | @c(-273.15)                              |
   |--------------|------------------------------------------|
   | @c(cadena)   | @c("She said \"Hello,  世界\"")            |
   |--------------|------------------------------------------|
   | @c(arreglo)  | @c(["gold", "silver", "bronze"])         |
   |--------------|------------------------------------------|
   | @c(objeto)   | @c({"year": 1980,                        |
   |              | "event": "archery",                      |
   |              | "medals": ["gold", "silver", "bronze"]}) |


   Considere una aplicacion que reune reseñas de peliculas y ofrece
   recomendaciones. A continuacion se declara un tipo de datos @c(Movie) y luego
   una lista de estos valores. (Los literales de cadena despues de las
   declaraciones @c(Year) y @c(Color) son etiquetas de campo; las explicaremos
   en un momento.)

   ..figure > @l(gopl.io/ch4/movie/main.go<>gopl.io/ch4/movie)

     ..src > go
       type Movie struct {
         Title  string
         Year   int  `json:"released"`
         Color  bool `json:"color,omitempty"`
         Actors []string
       }

       var movies = []Movie{
         {Title: "Casablanca", Year: 1942, Color: false,
           Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
         {Title: "Cool Hand Luke", Year: 1967, Color: true,
           Actors: []string{"Paul Newman"}},
         {Title: "Bullitt", Year: 1968, Color: true,
           Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
         // ...
       }
     < src..


   Las estructuras de datos como esta son un excelente ajuste para JSON, y es
   facil de convertir en ambas direcciones. Convertir una estructura de datos Go
   como @c(movies) a JSON se denomina @e(marshaling). La ordenacion se se
   realiza con @c(json.Marshal):

   ..src > go
     data, err := json.Marshal(movies)
     if err != nil {
       log.Fatalf("JSON marshaling failed: %s", err)
     }
     fmt.Printf("%s\n", data)
   < src..

   @c(Marshal) produce una slice de bytes que contiene una cadena muy grande sin
   ningun espacio en blanco:

   ..src > go
     [{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingrid Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Actors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]}]
   < src..

   Esta representacion compacta contiene toda la informacion, pero es dificil de
   leer. Para el consumo humano, una variante llamada @c(json.MarshalIndent)
   produce una salida perfectamente indentada. Dos argumentos adicionales
   definen un prefijo para cada linea de salida y una cadena para cada nivel de
   sangria:

   ..src > go
     data, err := json.MarshalIndent(movies, "", "    ")
     if err != nil {
       log.Fatalf("JSON marshaling failed: %s", err)
     }
     fmt.Printf("%s\n", data)
   < src..

   El codigo anterior

   ..src > go
     [
         {
             "Title": "Casablanca",
             "released": 1942,
             "Actors": [
                 "Humphrey Bogart",
                 "Ingrid Bergman"
             ]
         },
         {
             "Title": "Cool Hand Luke",
             "released": 1967,
             "color": true,
             "Actors": [
                 "Paul Newman"
             ]
         },
         {
             "Title": "Bullitt",
             "released": 1968,
             "color": true,
             "Actors": [
                 "Steve McQueen",
                 "Jacqueline Bisset"
             ]
         }
     ]
   < src..

   Marshaling utiliza los nombres de los campos en la estructura Go como los
   nombres de campo de los objetos JSON (mediante @e(reflexion), como veremos en
   la @l(#Seccion 12.6)). Solo se exportan los campos exportables, por lo que
   elegimos nombres en mayusculas para todos los nombres de campo.

   Habra notado que el nombre del campo @c(Year) cambia a @c(released) en la
   salida, y @c(Color) cambia a @c(color) . Eso es debido a las etiquetas de los
   campos. Una etiqueta de campo es una cadena de metadatos asociados en tiempo
   de compilacion con el campo de una estructura:

   ..src > go
     Year  int  `json:"released"`
     Color bool `json:"color,omitempty"`
   < src..

   Una etiqueta de campo puede ser cualquier cadena literal, pero se interpreta
   convencionalmente como una lista separada por espacios de pares
   @c(clave:"valor"); Ya que contiene comillas dobles, las etiquetas de campo
   normalmente se escriben con literales de cadena sin formato. La clave
   @c(json) controla el comportamiento del paquete @c(encoding/json), y otros
   paquetes @c(encoding/...) siguen esta convencion. La primera parte de la
   etiqueta de campo @c(json) especifica un nombre JSON alternativo para el
   campo Go. Las etiquetas de los campos a menudo se utilizan para especificar
   un nombre JSON idiomatico como @c(total_count) para un campo Go llamado
   @c(TotalCount). La etiqueta @c(Color) tiene una opcion adicional,
   @c(omitempty), lo que indica que no se debe producir ninguna salida JSON si
   el campo tiene el valor cero para su tipo (@c(false), aqui) o esta
   vacia. Efectivamente, la salida JSON para Casablanca, una pelicula en blanco
   y negro, no tiene el campo @c(color).

   La operacion inversa para marshaling, la decodificacion de JSON y rellenar
   una estructura de datos Go, se denomina @e(unmarshaling), y se realiza por
   @c(json.Unmarshal). El codigo de abajo descoloca los datos de la pelicula
   JSON en un slice de estructuras cuyo unico campo es Title . De esta manera,
   al definir estructuras de datos Go adecuadas, podemos seleccionar que partes
   de la entrada JSON se deben descifrar y cuales descartar. Cuando
   @c(Unmarshal) regresa, se ha llenado el slice con la informacion de
   @c(Title); Otros nombres en el JSON se ignoran.

   ..src > go
     var titles []struct{ Title string }
     if err := json.Unmarshal(data, &titles); err != nil {
       log.Fatalf("JSON unmarshaling failed: %s", err)
     }
     fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
   < src..

   Muchos servicios web proporcionan una interfaz JSON–se hace una solicitud con
   HTTP y devuelve la informacion deseada en formato JSON. Para ilustrarlo,
   vamos a consultar el seguimiento de problemas en GitHub con su interfaz de
   servicio web. Primero definiremos los tipos y constantes necesarios:

   ..figure > @l(gopl.io/ch4/github/github.go<>gopl.io/ch4/github)

     ..src > go
       // El paquete github proporciana una API en Go para el seguimiento de problemas.
       // Ver https://developer.github.com/v3/search/#search-issues.
       package github

       import "time"

       const IssuesURL = "https://api.github.com/search/issues"

       type IssuesSearchResult struct {
         TotalCount int `json:"total_count"`
         Items      []*Issue
       }

       type Issue struct {
         Number    int
         HTMLURL   string `json:"html_url"`
         Title     string
         State     string
         User      *User
         CreatedAt time.Time `json:"created_at"`
         Body      string    // En formato Markdown
       }

       type User struct {
         Login   string
         HTMLURL string `json:"html_url"`
       }
     < src..


   Como antes, los nombres de todos los campos de estructura deben estar en
   mayuscula incluso si sus nombres JSON no. Sin embargo, el proceso de
   coincidencia que asocia los nombres de JSON con los nombres de una estructura
   de Go durante el unmarshaling no distingue entre mayusculas y minusculas, por
   lo que solo es necesario utilizar una etiqueta de campo cuando hay un
   subrayado en el nombre JSON pero no en el nombre Go. Una vez mas, estamos
   siendo selectivos acerca de que campos decodificar; La respuesta de busqueda
   de GitHub contiene considerablemente mas informacion de la que mostramos
   aqui.

   La funcion @c(SearchIssues) realiza una peticion HTTP y decodifica el
   resultado como JSON. Puesto que los terminos de consulta presentados por un
   usuario pueden contener caracteres como @c(?) y @c(&) que tienen un
   significado especial en una URL, usamos @c(url.QueryEscape) para asegurar de
   que se tomen literalmente.

   ..figure > @l(gopl.io/ch4/github/search.go<>gopl.io/ch4/github)

     ..src > go
       package github

       import (
         "encoding/json"
         "fmt"
         "net/http"
         "net/url"
         "strings"
       )

       // SearchIssues consulta el seguimiento de problemas de GitHub.
       func SearchIssues(terms []string) (*IssuesSearchResult, error) {
         q := url.QueryEscape(strings.Join(terms, " "))
         resp, err := http.Get(IssuesURL + "?q=" + q)
         if err != nil {
           return nil, err
         }

         // Debemos cerrar resp.Body en todas las rutas de ejecucion.
         // (El Capitulo 5 presenta 'defer', lo que simplifica esto.)
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("search query failed: %s", resp.Status)
         }

         var result IssuesSearchResult
         if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
           resp.Body.Close()
           return nil, err
         }
         resp.Body.Close()
         return &result, nil
       }
     < src..


   Los ejemplos anteriores utilizaron @c(json.Unmarshal) para decodificar todo
   el contenido de una slice de bytes como una sola entidad JSON. Para variar,
   este ejemplo utiliza el decodificador de @e(flujo), @c(json.Decoder) , que
   permite que varias entidades JSON sean decodificados en secuencia desde el
   mismo flujo, aunque aqui no necesitamos esa caracteristica. Como era de
   esperar, hay un codificador de flujo correspondiente llamado @c(json.Encoder).

   La llamada a @c(Decode) rellena la variable @c(result). Hay varias maneras en
   que podemos dar un formato agradable a su valor. A continuacion mostramos el
   mas simple, con el commando @c(issues), es como una tabla de texto con
   columnas de ancho fijo, pero en la siguiente seccion vamos a ver un enfoque
   mas sofisticado basado en plantillas.

   ..figure > @l(gopl.io/ch4/issues/main.go<>gopl.io/ch4/issues)

     ..src > go
       // Issues imprime una tabla de coincidencia de problemas que coinciden
       // con los terminos de busqueda
       package main

       import (
         "fmt"
         "log"
         "os"

         "gopl.io/ch4/github"
       )

       func main() {
         result, err := github.SearchIssues(os.Args[1:])
         if err != nil {
           log.Fatal(err)
         }
         fmt.Printf("%d issues:\n", result.TotalCount)
         for _, item := range result.Items {
           fmt.Printf("#%-5d %9.9s %.55s\n",
             item.Number, item.User.Login, item.Title)
         }
       }
     < src..


   Los argumentos de linea de comandos especifican los terminos de busqueda. El
   comando siguiente consulta el rastreador de problemas del proyecto Go para la
   lista de errores abiertos relacionados con la descodificacion JSON:

   ..src > sh
     $ go build gopl.io/ch4/issues
     $ ./issues repo:golang/go is:open json decoder
     13 issues:
     #5680    eaigner encoding/json: set key converter on en/decoder
     #6050  gopherbot encoding/json: provide tokenizer
     #8658  gopherbot encoding/json: use bufio
     #8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal
     #5901        rsc encoding/json: allow override type marshaling
     #9812  klauspost encoding/json: string tag not symmetric
     #7872  extempora encoding/json: Encoder internally buffers full output
     #9650    cespare encoding/json: Decoding gives errPhase when unmarshalin
     #6716  gopherbot encoding/json: include field name in unmarshal error me
     #6901  lukescott encoding/json, encoding/xml: option to treat unknown fi
     #6384    joeshaw encoding/json: encode precise floating point integers u
     #6647    btracey x/tools/cmd/godoc: display type kind of each named type
     #4237  gjemiller encoding/base64: URLEncoding padding is optional
   < src..

   La interfaz de servicio web en GitHub @l(https://developer.github.com/v3/)
   tiene muchas mas funciones delas que tenemos espacio para mostrar aqui.

   @b(Ejercicio 4.10): Modificar @c(issues) para reportar los resultados en
   categorias de edad, es decir menos de un mes de edad, menos de un año de
   edad, y mas de un año de edad.

   @b(Ejercicio 4.11): Construir una herramienta que permite a los usuarios
   crear, leer, actualizar y eliminar los problemas de GitHub desde la linea de
   comandos, invocando su editor de texto preferido cuando se requiera la
   introduccion de texto sustancial.

   @b(Ejercicio 4.12): El popular comic web @e(xkcd) tiene una interfaz
   JSON. Por ejemplo, una solicitud a @l(https://xkcd.com/571/info.0.json)
   produce una descripcion detallada del comic 571, uno de mis muchos
   favoritos. Descargue cada URL (una vez) y construya un indice sin
   conexion. Escriba una herramienta @$(xkcd) que, utilizando este indice,
   imprima la URL y transcripcion de cada comic que coincida con un termino de
   busqueda proporcionado en la linea de comandos.

   @b(Ejercicio 4.13): El servicio web basado en JSON de Open Movie Database le
   permite buscar en @l(https://omdbapi.com/) una pelicula por su nombre y
   descargar la su imagen del poster. Escriba una herramienta @$(poster) que
   descargue la imagen del poster de la pelicula que se nombre en la linea de
   comandos.

** Seccion 4.6 <> Plantillas de Texto y HTML

   El ejemplo anterior muestra como hacer el formato lo mas simple posible, para
   lo cual @c(Printf) es completamente adecuado. Pero a veces el formato debe
   ser mas elaborado, y es deseable separar el formato del codigo completamente.
   Esto se puede hacer con los paquetes @c(text/template) y @c(html/template),
   que proporcionan un mecanismo para la sustitucion de los valores de las
   variables en una plantilla de texto o HTML.

   Una plantilla es una cadena o un archivo que contiene una o mas partes
   encerradas entre llaves dobles, @c({{...}}), llamadas @e(acciones). La mayor
   parte de la cadena se imprime literalmente, pero las acciones desencadenan
   otros comportamientos. Cada accion contiene una expresion en el lenguaje de
   la plantilla, una notacion sencilla pero poderosa para imprimir valores,
   seleccionar de campos de la estructura, llamar a la funciones y metodos,
   expresar el flujo de control, como sentencias @c(if)-@c(else) y bucles
   @c(range), y crear instancias de otras plantillas. A continuacion se muestra
   una cadena de plantilla simple:

   ..figure > @l(gopl.io/ch4/issuesreport/main.go<>gopl.io/ch4/issuesreport)

     ..src > go
       const templ = `{{.TotalCount}} issues:
       {{range .Items}}----------------------------------------
       Number: {{.Number}}
       User:   {{.User.Login}}
       Title:  {{.Title | printf "%.64s"}}
       Age:    {{.CreatedAt | daysAgo}} days
       {{end}}`
     < src..


   Esta plantilla primero imprime el numero de problemas encontrados, luego
   imprime el numero, usuario, titulo y edad en dias de cada uno. Dentro de una
   accion, hay una nocion del valor actual, denominado como @"(punto) y escrita
   como @"(.), un punto. El punto se refiere inicialmente al parametro de la
   plantilla, que sera en este ejemplo @c(github.IssuesSearchResult). La accion
   @c({{.TotalCount}}) expande al valor del campo @c(TotalCount), que se imprime
   en la forma habitual. Las acciones @c({{range .Items}}) y @c({{end}}) crean
   un bucle, por lo que el texto entre ellos se expande varias veces, con el
   punto ligado a elementos sucesivos de @c(Items).

   Dentro de una accion, la notacion @c(|) hace que el resultado de una
   operacion sea el argumento de otra, analoga a una tuberia del shell de
   Unix. En el caso de @c(Title), la segunda operacion es la funcion @c(printf),
   que es un sinonimo nativo para @c(fmt.Sprintf) en todas las plantillas. Para
   @c(Age), la segunda operacion es la funcion, @c(daysAgo), que convierte el
   campo @c(CreatedAt) en el tiempo transcurrido, usando @c(time.Since):

   ..src > go
     func daysAgo(t time.Time) int {
       return int(time.Since(t).Hours() / 24)
     }
   < src..

   Observe que el tipo de @c(CreatedAt) es @c(time.Time), no @c(string). Del
   mismo modo que un tipo puede controlar su formato de cadena (@l(#Seccion
   2.5<>§2.5)) mediante la definicion de ciertos metodos, un tipo puede definir
   tambien metodos para controlar su comportamiento para el marshaling y
   unmarshaling JSON. El valor marshaling JSON de un @c(time.Time) es una cadena
   en un formato estandar.

   Producir la salida con una plantilla es un proceso de dos pasos. Primero
   debemos analizar la plantilla en una representacion interna adecuada, y luego
   ejecutarla en entradas especificas. El analisis se debe hacer solo una
   vez. El siguiente codigo crea y analiza la plantilla templ definida
   anteriormente. Observe el encadenamiento de llamadas a metodos:
   @c(template.New) crea y devuelve una plantilla; @c(Funcs) añade @c(daysAgo)
   al conjunto de funciones accesibles dentro de esta plantilla, luego, devuelve
   esa plantilla; Por ultimo, se llama a @c(Parse) en el resultado.

   ..src > go
     report, err := template.New("report").
       Funcs(template.FuncMap{"daysAgo": daysAgo}).
       Parse(templ)
     if err != nil {
       log.Fatal(err)
     }
   < src..

   Dado que las plantillas suelen fijarse en tiempo de compilacion, la falta de
   analisis de una plantilla indica un error fatal en el programa. La funcion
   auxiliar @c(template.Must) hace que el manejo de errores sea mas conveniente:
   acepta una plantilla y un error, comprueba que el error es nil (y panicos de
   lo contrario) y, luego devuelve la plantilla. Volveremos a esta idea en la
   @l(#Seccion 5.9).

   Una vez la plantilla ha sido creada, aumentada con @c(daysAgo), analizada y
   comprobada, podemos ejecutarla utilizando como fuente de datos
   @c(github.IssuesSearchResult) y @c(os.Stdout) como el destino:

   ..src > go
     var report = template.Must(template.New("issuelist").
       Funcs(template.FuncMap{"daysAgo": daysAgo}).
       Parse(templ))

     func main() {
       result, err := github.SearchIssues(os.Args[1:])
       if err != nil {
         log.Fatal(err)
       }
       if err := report.Execute(os.Stdout, result); err != nil {
         log.Fatal(err)
       }
     }
   < src..

   El programa imprime un informe en texto plano como este:

   ..src > sh
     $ go build gopl.io/ch4/issuesreport
     $ ./issuesreport repo:golang/go is:open json decoder
     13 issues:
     ---------------------------------------
     Number: 5680
     User:   eaigner
     Title:  encoding/json: set key converter on en/decoder
     Age:    750 days
     ---------------------------------------
     Number: 6050
     User:   gopherbot
     Title:  encoding/json: provide tokenizer
     Age:    695 days
     ---------------------------------------
     ...
   < src..

   Ahora pasemos al paquete @c(html/template). Utiliza el mismo API y el mismo
   lenguaje de expresion que @c(text/template) pero añade caracteristicas para
   el escape automatico y apropiado de cadanes que aparecen dentro de HTML,
   JavaScript, CSS o URLs. Estas caracteristicas pueden ayudar a evitar un
   problema de seguridad perenne de la generacion de HTML, un @e(ataque de
   inyeccion), en el que un adversario crea un valor de cadena como el titulo de
   un tema, para incluir codigo malicioso, que cuando se escapa indebidamente
   por una plantilla, les da control sobre la pagina.

   La plantilla siguiente muestra la lista de temas como una tabla HTML.
   Observe la diferente importacion:

   ..figure > @l(gopl.io/ch4/issueshtml/main.go<>gopl.io/ch4/issueshtml)

     ..src > go
       import "html/template"

       var issueList = template.Must(template.New("issuelist").Parse(`
       <h1>{{.TotalCount}} issues</h1>
       <table>
       <tr style='text-align: left'>
         <th>#</th>
         <th>State</th>
         <th>User</th>
         <th>Title</th>
       </tr>
       {{range .Items}}
       <tr>
         <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>
         <td>{{.State}}</td>
         <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>
         <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>
       </tr>
       {{end}}
       </table>
       `))
     < src..


   El siguiente comando ejecuta la nueva plantilla en los resultados de una
   consulta ligeramente diferente:

   ..src > sh
     $ go build gopl.io/ch4/issueshtml
     $ ./issueshtml repo:golang/go commenter:gopherbot json encoder >issues.html
   < src..

   La figura 4.4 muestra la apariencia de la tabla en un navegador web. Los
   enlaces se conectan a las paginas web apropiadas en GitHub.

   ..figure > Figura 4.4. Una tabla HTML de los temas del proyecto Go
     relacionados con la codificacion JSON.

     ..img > img/Figure-4.4.jpg


   Ninguno de los temas en la Figura 4.4 representan un desafio para HTML, pero
   podemos ver el efecto mas claramente con temas cuyos titulos contienen
   metacaracteres HTML como @c(&) y @c(<). Hemos seleccionado dos problemas para
   este ejemplo:

   ..src > sh
     $ ./issueshtml repo:golang/go 3133 10535 >issues2.html
   < src..

   La Figura 4.5 muestra el resultado de esta consulta. Observe que el paquete
   @c(html/template) de forma automatica escapa los titulos HTML de modo que
   aparezcan literalmente. Si por error hubieramos usado el paquete
   @c(text/template), la cadena de cuatro caracteres "&lt;" se habria convertido
   en el caracter @c('<') y la cadena @c("<link>") se habria convertido en un
   elemento @c(link), cambiando la estructura del documento HTML y tal vez
   comprometiendo su seguridad.

   Podemos suprimir este comportamiento de auto-escape para los campos que
   contienen datos HTML confiables mediante el uso de un  tipo de cadena
   denominada @c(template.HTML) en lugar de @c(string) . Existen tipos con nombres
   similares para JavaScript, CSS y URL de confianza. El siguiente programa
   demuestra el principio usando  campos con el mismo valor, pero
   con diferentes tipos: c(A) es un @c(string) y @c(B) es un @c(template.HTML).

   ..figure > Figura 4.5. Los metacaracteres HTML del titulos de temas se
     muestran correctamente.

     ..img > img/Figure-4.5.jpg

   ..figure > @l(gopl.io/ch4/autoescape/main.go<>gopl.io/ch4/autoescape)

     ..src > go
       func main() {
         const templ = `<p>A: {{.A}}</p><p>B: {{.B}}</p>`
         t := template.Must(template.New("escape").Parse(templ))
         var data struct {
           A string        // texto sin fiavilidad
           B template.HTML // HTML confiable
         }
         data.A = "<b>Hello!</b>"
         data.B = "<b>Hello!</b>"
         if err := t.Execute(os.Stdout, data); err != nil {
           log.Fatal(err)
         }
       }
     < src..


   La Figura 4.6 muestra la salida de la plantilla tal como aparece en un
   navegador. Podemos ver que @c(A) esta sujeto a escapar, pero @c(B) no.

   ..figure > Figura 4.6. Los valores de cadena tinen escapado HTML escapado,
     pero los valores @c(template.HTML) no.

     ..img > img/Figure-4.6.jpg


   Tenemos espacio aqui para mostrar solo las caracteristicas mas basicas del
   sistema de plantillas. Como siempre, para obtener mas informacion, consulte
   la documentacion del paquete:

   ..src > sh
     $ go doc text/template
     $ go doc html/template
   < src..

   @b(Ejercicio 4.14): Crear un servidor web que consulta GitHub una vez y luego
   permita la navegacion de la lista de informe de errores, hitos y usuarios.

* Capitulo 5 <> Funciones

  Una funcion nos permite envolver una secuencia de sentencias como una unidad
  que se puede llamar desde cualquier lugar de un programa, tal vez varias
  veces. Las funciones hacen posible romper un gran trabajo en pedazos mas
  pequeños que bien podrian ser escritos por diferentes personas separadas por
  el tiempo y el espacio. Una funcion oculta sus detalles de implementacion a
  sus usuarios. Por todas estas razones, las funciones son una parte critica de
  cualquier lenguaje de programacion.

  Ya hemos visto muchas funciones. Ahora tomaremos un tiempo para una discusion
  mas exhaustiva. El ejemplo de ejecucion de este capitulo es un rastreador web,
  es decir, el componente de un motor de busqueda web responsable de buscar
  paginas web, descubrir los vinculos dentro de ellas, buscar las paginas
  identificadas por dichos vinculos, etc. Un rastreador web nos da una amplia
  oportunidad para explorar la recursividad, funciones anonimas, manejo de
  errores y aspectos de funciones que son unicos de Go.

** Seccion 5.1 <> Declaracion de Funciones

   Una declaracion de funcion tiene un nombre, una lista de parametros, una
   lista opcional de resultados y un cuerpo:

   ..src > go
     func rombre(lista-de-parametros) (lista-de-resultados) {
       cuerpo
     }
   < src..

   La lista de parametros especifica el nombres y tipos de los @e(parametros) de
   la funcion, que son las variables locales cuyos valores o argumentos son
   suministrados por quien hace la llamada. La lista de resultados especifica
   los tipos de los valores que devuelve la funcion. Si la funcion devuelve un
   resultado sin nombre o ningun resultado, los parentesis son opcionales y
   normalmente se omiten. Dejar fuera la lista de resultados declara
   completamente que una funcion que no devuelve ningun valor y se llama solo
   por sus efectos. En la funcion @c(hypot),

   ..src > go
     func hypot(x, y float64) float64 {
       return math.Sqrt(x*x + y*y)
     }

     fmt.Println(hypot(3, 4)) // "5"
   < src..

   @c(x) y @c(y) son parametros en la declaracion, @c(3) y @c(4) son argumentos
   de la llamada, y la funcion devuelve un valor @c(float64).

   Al igual que los parametros, los resultados pueden tener nombre. En ese caso,
   cada nombre declara una variable local inicializada al valor cero para su
   tipo.

   Una funcion que tiene una lista de resultados debe terminar con una
   declaracion @c(return), a menos que la ejecucion claramente no pueda llegar
   al final de la funcion, tal vez porque la funcion termina con una llamada a
   @c(panic) o un bucle @c(for) infinito sin @c(break).

   Como hemos visto con @c(hypot), una secuencia de parametros o resultados del
   mismo tipo puede ser un factor para que el propio tipo se escriba una sola
   vez. Estas dos declaraciones son equivalentes:

   ..src > go
     func f(i, j, k int, s, t string)                { /* ... */ }
     func f(i int, j int, k int, s string, t string) { /* ... */ }
   < src..

   Aqui hay cuatro formas de declarar una funcion con dos parametros y un
   resultado, todos de tipo @c(int). El identificador en blanco puede usarse
   para enfatizar que un parametro no se utiliza.

   ..src > go
     func add(x int, y int) int   { return x + y }
     func sub(x, y int) (z int)   { z = x - y; return }
     func first(x int, _ int) int { return x }
     func zero(int, int) int      { return 0 }

     fmt.Printf("%T\n", add)   // "func(int, int) int"
     fmt.Printf("%T\n", sub)   // "func(int, int) int"
     fmt.Printf("%T\n", first) // "func(int, int) int"
     fmt.Printf("%T\n", zero)  // "func(int, int) int"
   < src..

   El tipo de una funcion a veces se denomina su @e(firma). Dos funciones tienen
   el mismo tipo o firma si tienen la misma secuencia de tipos de parametros y
   la misma secuencia de tipos de resultados. Los nombres de los parametros y
   resultados no afectan al tipo, ni tampoco si se declararon utilizando el
   formto factorizado.

   Cada llamada de funcion debe proporcionar un argumento para cada parametro,
   en el orden en que se declararon los parametros. Go no tiene concepto de
   valores de parametro predeterminados, ni ninguna forma de especificar
   argumentos por nombre, por lo que los nombres de parametros y resultados no
   importan al llamador, excepto como documentacion.

   Los parametros son variables locales dentro del cuerpo de la funcion, con sus
   valores iniciales establecidos a los argumentos proporcionados por quien
   realiza la llamada. Los parametros de funcion y los resultados con nombre son
   variables en el mismo bloque lexico que las variables locales mas externas de
   la funcion.

   Los argumentos se pasan por valor, por lo que la funcion recibe una copia de
   cada argumento; Las modificaciones a la copia no afectan a la persona que
   llama. Sin embargo, si el argumento contiene algun tipo de referencia, como
   un puntero, slice, mapa, funcion o canal, entonces la persona que llama puede
   verse afectada por las modificaciones que hace la funcion de las variables
   que referencian @e(indirectamente) por el argumento.

   De vez en cuando puede encontrar una declaracion de funcion sin un cuerpo, lo
   que indica que la funcion se implementa en un idioma que no es Go. Dicha
   declaracion define la firma de la funcion.

   ..src > go
     package math

     func Sin(x float64) float64 // implementado en lenguaje ensamblador
   < src..

** Seccion 5.2 <> Recursividad

   Las funciones pueden ser @e(recursivas), es decir, que pueden llamarse a si
   mismas, ya sea directa o indirectamente. La recursion es una tecnica poderosa
   para muchos problemas, y por supuesto es esencial para procesar estructuras
   de datos recursivas. En la @l(#Seccion 4.4), se utilizo la recursividad sobre
   un arbol para implementar un mecanismo de insercion sencillo. En esta
   seccion, volveremos a usarlo para procesar documentos HTML.

   El siguiente programa de ejemplo utiliza un paquete no estandar,
   @c(golang.org/x/net/html), que proporciona un analizador de HTML. Los
   repositorios @c(golang.org/x/...) tienen paquetes diseñados y mantenidos por
   el equipo de Go para aplicaciones tales como redes, procesamiento de texto
   internacionalizado, plataformas moviles, manipulacion de imagenes,
   criptografia, y herramientas de desarrollo. Estos paquetes no estan en la
   libreria estandar porque todavia estan en desarrollo o porque son raramente
   necesarios por la mayoria de los programadores de Go.

   Las partes de  la API @c(golang.org/x/net/html) que tendremos que se muestran a
   continuacion. La funcion @c(html.Parse) lee una secuencia de bytes, los analiza,
   y devuelve la raiz del arbol del documento HTML, que es un @c(html.Node). HTML
   tiene varios tipos de nodos–texto, comentarios, etc.–pero aqui solo nos
   interesan con nodos de elemento de la forma @c(<nombre clave='valor'>).

   ..figure > @c(golang.org/x/net/html)

     ..src > go
       package html
       type Node struct {
         Type                    NodeType
         Data                    string
         Attr                    []Attribute
         FirstChild, NextSibling *Node
       }

       type NodeType int32

       const (
         ErrorNode NodeType = iota
         TextNode
         DocumentNode
         ElementNode
         CommentNode
         DoctypeNode
       )

       type Attribute struct {
         Key, Val string
       }

       func Parse(r io.Reader) (*Node, error)
     < src..


   La funcion @c(main) analiza la entrada estandar como HTML, extrae los enlaces
   usando un cuncion recursiva @c(visit), e imprime cada enlace descubierto:

   ..figure > @l(gopl.io/ch5/findlinks1/main.go<>gopl.io/ch5/findlinks1)

     ..src > go
       // Findlinks1 imprime los enlaces en un documento HTML leido en la entrada estandar
       package main

       import (
         "fmt"
         "os"

         "golang.org/x/net/html"
       )

       func main() {
         doc, err := html.Parse(os.Stdin)
         if err != nil {
           fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
           os.Exit(1)
         }
         for _, link := range visit(nil, doc) {
           fmt.Println(link)
         }
       }
     < src..


   La funcion @c(visit) atraviesa un arbol de nodos HTML, extrae el enlace desde
   el atributo @c(href) de cada elemento de @e(anclaje) @c(<a href='...'>),
   añade los enlaces a un slice de strings, y devuelve el slice resultante:

   ..src > go
     // visit agrega los enlaces de cada enlace encontrado en n y devuelve el resultado
     func visit(links []string, n *html.Node) []string {
       if n.Type == html.ElementNode && n.Data == "a" {
         for _, a := range n.Attr {
           if a.Key == "href" {
             links = append(links, a.Val)
           }
         }
       }
       for c := n.FirstChild; c != nil; c = c.NextSibling {
         links = visit(links, c)
       }
       return links
     }
   < src..

   Para descender por el arbol a un nodo @c(n), @c(visit) se llama a si misma
   recursivamente para cada uno de los hijos de @c(n), que se mantienen en el
   lista enlazada @c(FirstChild).

   Vamos a ejecutar @$(findlinks) en la pagina principal de Go, canalizando el
   resultado de @$(fetch) (@l(#Seccion 1.5<>§1.5)) a la entrada de
   @$(findlinks). Hemos modificado la salida ligeramente por brevedad.

   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ go build gopl.io/ch5/findlinks1
     $ ./fetch https://golang.org | ./findlinks1
     #
     /doc/
     /pkg/
     /help/
     /blog/
     http://play.golang.org/
     //tour.golang.org/
     https://golang.org/dl/
     //blog.golang.org/
     /LICENSE
     /doc/tos.html
     http://www.google.com/intl/en/policies/privacy/
   < src..

   Observe la variedad de formas de enlaces que aparecen en la pagina. Mas
   adelante veremos como resolverlos con relacion al URL base,
   @c(https://golang.org), para crear URL absolutas.

   El siguiente programa utiliza la recursion sobre el arbol de nodos HTML para
   imprimir la estructura del arbol en esquema. Cuando encuentra cada elemento,
   empuja la etiqueta del elemento sobre una pila, luego imprime la pila.

   ..figure > @l(gopl.io/ch5/outline/main.go<>gopl.io/ch5/outline)

     ..src > go
       func main() {
         doc, err := html.Parse(os.Stdin)
         if err != nil {
           fmt.Fprintf(os.Stderr, "outline: %v\n", err)
           os.Exit(1)
         }
         outline(nil, doc)
       }

       func outline(stack []string, n *html.Node) {
         if n.Type == html.ElementNode {
           stack = append(stack, n.Data) // push tag
           fmt.Println(stack)
         }
         for c := n.FirstChild; c != nil; c = c.NextSibling {
           outline(stack, c)
         }
       }
     < src..


   Considere una sutileza: aunque @c(outline) @"(empuja) un elemento en el
   @c(stack), no hay ninguna extraccion correspondiente. Cuando @c(outline) se
   llama a si misma de forma recursiva, el receptor recibe una copia del
   @c(stack). Aunque el destinatario de la llamada puede añadir elementos a este
   slice, modificando de su arreglo subyacente e incluso asignando un nuevo
   arreglo, no modifica los elementos iniciales que son visibles para quien
   realiza la llamada, asi que cuando la funcion regresa, el @c(stack) del
   llamantede es tal cual antes de la llamada.

   Aqui esta el esquema de @c(https://golang.org), editado nuevamente por
   razones de brevedad:

   ..src > sh
     $ go build gopl.io/ch5/outline
     $ ./fetch https://golang.org | ./outline
     [html]
     [html head]
     [html head meta]
     [html head title]
     [html head link]
     [html body]
     [html body div]
     [html body div]
     [html body div div]
     [html body div div form]
     [html body div div form div]
     [html body div div form div a]
   < src..

   Como puede ver mediante la experimentacion con @c(outline), la mayoria de los
   documentos HTML pueden ser procesados con solo unos pocos niveles de
   recursividad, pero no es dificil de construir paginas web patologicas que
   requieren una recursion extremadamente profunda.

   Muchas implementaciones de lenguaje de programacion utilizan una funcion
   stack de tamaño fijo; Tamaños de 64KB a 2MB son tipicos. Pilas de tamaño fijo
   imponen un limite en la profundidad de la recursividad, por lo que hay que
   tener cuidado para evitar un desbordamiento de pila cuando se atraviesa
   grandes estructuras de datos de forma recursiva; Las pilas de tamaño fijo
   pueden incluso suponer un riesgo para la seguridad. En contraste, las
   implementaciones tipicas de Go usan pilas de tamaño variable que comienzan
   pequeñas y crecen segun sea necesario hasta un limite del orden de un
   gigabyte. Esto nos permite usar la recursion de forma segura y sin
   preocuparnos por el desbordamiento.

   @b(Ejercicio 5.1): Cambiar el programa @$(findlinks) para atravesar la lista
   enlazada @c(n.FirstChild) mediante llamadas recursivas a @c(visit) en lugar
   de un bucle.

   @b(Ejercicio 5.2): Escribir una funcion para rellenar un mapeo con los
   nombres de los elementos–@c(p), @c(div), @c(span), y asi sucesivamente-al
   numero de elementos con ese nombre en un arbol de documentos HTML.

   @b(Ejercicio 5.3): Escribir una funcion para imprimir el contenido de todos
   los nodos de texto en un arbol de documentos HTML. No descender dentro de
   elementos @c(<script>) o @c(<style>), ya que sus contenidos no son visibles
   en un navegador web.

   @b(Ejercicio 5.4): Extender la funcion @c(visit) para que los extractos otros
   tipos de enlaces desde el documento, como imagenes, scripts y hojas de
   estilo.

** Seccion 5.3 <> Multiples Valores de Retorno

   Una funcion puede devolver mas de un resultado. Hemos visto muchos ejemplos
   de funciones de paquetes estandar que devuelven dos valores, el resultado
   computacional deseado y un valor de error o booleano que indica si el calculo
   funciono. El siguiente ejemplo muestra como escribir una nosotros mismos.

   El programa siguiente es una variacion de @$(findlinks) que hace la peticion
   HTTP por si mismo, asi que ya no necesitamos para ejecutar @$(fetch). Ya que
   las operaciones de analisis y HTTP pueden fallar, @$(findLinks) declara dos
   resultados: la lista de enlaces descubiertos y un error. Por cierto, el
   analizador de HTML por lo general puede recuperarse de una entrada incorrecta
   y construir un documento que contiene nodos de error, por lo @c(Parse)
   raramente falla; Cuando lo hace, normalmente se debe a errores de E/S
   subyacentes.

   ..figure > @l(gopl.io/ch5/findlinks2/main.go<>gopl.io/ch5/findlinks2)

     ..src > go
       func main() {
         for _, url := range os.Args[1:] {
           links, err := findLinks(url)
           if err != nil {
             fmt.Fprintf(os.Stderr, "findlinks2: %v\n", err)
             continue
           }
           for _, link := range links {
             fmt.Println(link)
           }
         }
       }

       // findLinks realiza una peticion HTTP GET por la url, analiza la
       // respuesta como HTML, y extrae y regresa los enlaces.
       func findLinks(url string) ([]string, error) {
         resp, err := http.Get(url)
         if err != nil {
           return nil, err
         }
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
         }
         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
         }
         return visit(nil, doc), nil
       }
     < src..


   Hay cuatro sentencias @c(return) en @c(findLinks), cada uno de las cuales
   devuelve un par de valores. Los tres primeros @c(return) hacen la funcion
   pase los errores subyacentes de los paquetes @c(http) y @c(html) al
   llamador. En el primer caso, el error se devuelve sin cambios; en el segundo
   y tercero, que expande con informacion de contexto adicional con
   @c(fmt.Errorf) (@l(#Seccion 7.8<>§7.8)). Si @c(findLinks) tiene exito, la
   ultima sentencia @c(return) devuelve el slice de enlaces, sin error.

   Debemos asegurarnos de cerrar @c(resp.Body) para que los recursos de red se
   liberen adecuadamente, incluso en caso de error. El recolector de basura de
   Go recicla la memoria no utilizada, pero no asume que liberara recursos del
   sistema operativo no utilizados como archivos abiertos y conexiones de
   red. Deberan cerrarse explicitamente.

   El resultado de llamar a una funcion multi-valor es una tupla de valores. El
   llamador de tal funcion debe asignar explicitamente los valores a las
   variables si se desea utilizar alguna de ellas:

   ..src > go
     links, err := findLinks(url)
   < src..

   Para ignorar uno de los valores, asintelo al identificador en blanco:

   ..src > go
     links, _ := findLinks(url) // errors ignored
   < src..

   El resultado de una llamada multi-valor en si puede ser devuelto desde una
   llamada funcion (multi-valor), como en esta funcion que se comporta como
   @c(findLinks) pero registra su argumento:

   ..src > go
     func findLinksLog(url string) ([]string, error) {
       log.Printf("findLinks %s", url)
       return findLinks(url)
     }
   < src..

   Una llamada multi-valor puede aparecer como el unico argumento cuando se
   llama a una funcion de multiples parametros. Aunque rara vez se utiliza en
   codigo de produccion, esta caracteristica es a veces conveniente durante la
   depuracion, ya que nos permite imprimir todos los resultados de una llamada
   utilizando una sola sentencia. Las dos instrucciones de impresion siguientes
   tienen el mismo efecto.

   ..src > go
     log.Println(findLinks(url))

     links, err := findLinks(url)
     log.Println(links, err)
   < src..

   Los nombres bien elegidos pueden documentar la importancia de los resultados
   de una funcion. Los nombres son particularmente valiosos cuando una funcion
   devuelve multiples resultados del mismo tipo, como

   ..src > go
     func Size(rect image.Rectangle) (width, height int)
     func Split(path string) (dir, file string)
     func HourMinSec(t time.Time) (hour, minute, second int)
   < src..

   Pero no siempre es necesario nombrar multiples resultados unicamente para la
   documentacion. Por ejemplo, la convencion dicta que un resultado final
   @c(bool) indica el exito; un resultado erroneo a menudo no necesita
   explicacion.

   En una funcion con resultados nombrados, se pueden omitir los operandos de
   una sentencia de devolucion. Esto se llama un @c(retorno desnudo).

   ..src > go
     // CountWordsAndImages realiza una peticion HTTP GET para la URL del
     // documento HTML y regresa el numero de palabras e imagenes que contiene.
     func CountWordsAndImages(url string) (words, images int, err error) {
       resp, err := http.Get(url)
       if err != nil {
         return
       }

       doc, err := html.Parse(resp.Body)
       resp.Body.Close()
       if err != nil {
         err = fmt.Errorf("parsing HTML: %s", err)
         return
       }
       words, images = countWordsAndImages(doc)
       return
     }

     func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ }
   < src..

   Un retorno desnudo es una forma abreviada de devolver cada una de las
   variables de resultado nombradas en orden, por lo que en la funcion anterior,
   cada sentencia @c(return) es equivalente a

   ..src > go
     return words, images, err
   < src..

   En funciones como esta, con muchas declaraciones de retorno y varios
   resultados, los resultados desnudos pueden reducir la duplicacion de codigo,
   pero rara vez hacen que el codigo sea mas facil de entender. Por ejemplo, no
   es obvio a primera vista que los dos primeros resultados son equivalentes a
   @c(return 0, 0, err) (porque las variables de resultado @c(words) e
   @c(images) se inicializan con sus valores cero) y que el ultimo @c(return) es
   equivalente a @c(return words, images, nil). Por esta razon, es mejor
   utilizar los resultados desnudos con moderacion.

   @b(Ejercicio 5.5): Implementar @c(countWordsAndImages). (Ver el ejercicio 4.9
   para la division de palabras.)

   @b(Ejercicio 5.6): Modificar la funcion @c(corner) en @c(gopl.io/ch3/surface)
   (@l(#Seccion 3.2<>§3.2)) para utilizar resultados con nombre y una
   declaracion de retorno desnudo.

** Seccion 5.4 <> Errores

   Algunas funciones siempre tienen exito en su tarea. Por ejemplo,
   @c(strings.Contains) y @c(strconv.FormatBool) tienen bien definidos todos los
   posibles valores de los argumentos y no pueden fallar–salvo escenarios
   catastroficos e impredecibles como quedarse sin memoria, donde el sintoma
   esta lejos de la causa y de la cual hay poca esperanza de recuperacion.

   Otras funciones siempre tienen exito siempre y cuando se cumplan sus
   condiciones previas. Por ejemplo, la funcion @c(time.Date) siempre construye
   un @c(time.Time) a partir de sus componentes–año, mes, y asi sucesivamente–a
   menos que el ultimo argumento (la zona horaria) sea @c(nil), en cuyo caso se
   entra en panico. Este panico es un signo seguro de un error en el codigo de
   llamada y nunca debe suceder en un programa bien escrito.

   Para muchas otras funciones, incluso en un programa bien escrito, el exito no
   esta asegurado porque depende de factores ajenos al control del
   programador. Cualquier funcion que haga E/S, por ejemplo, debe enfrentarse a
   la posibilidad de error, y solo un programador ingenuo cree que una simple
   lectura o escritura no puede fallar. De hecho, es cuando las operaciones mas
   confiables fallan inesperadamente que necesitamos saber por que.

   Los errores son, por lo tanto, una parte importante de la API de un paquete o
   de la interfaz de usuario de una aplicacion, y el error es solo uno de varios
   comportamientos esperados. Este es el enfoque que Go toma respecto al manejo
   de errores.

   Una funcion cuyo fallo es un comportamiento esperado devuelve un resultado
   adicional, convencionalmente el ultimo. Si el fallo tiene solo una causa
   posible, el resultado es un valor booleano, generalmente llamado @c(ok), como
   en este ejemplo de una busqueda en la cache que siempre tiene exito a menos
   que no hubiera ninguna entrada para esa clave:

   ..src > go
     value, ok := cache.Lookup(key)
     if !ok {
       // ...cache[key] does not exist...
     }
   < src..

   Mas a menudo, y especialmente para E/S, el fallo puede tener una variedad
   de causas para las cuales el llamador necesitara una explicacion. En tales
   casos, el tipo del resultado adicional es @c(error).

   El tipo nativo @c(error) es un tipo de interfaz. Veremos mas de lo que esto
   significa y sus implicaciones para el manejo de errores en el @l(#Capitulo
   7). Por ahora es suficiente saber que un error puede ser o no @c(nil), que
   nil implica el exito y no-nil implica el fracaso, y que un error no-nil tiene
   una cadena del mensaje de error que se puede obtener llamando a su metodo
   @c(Error) o imprimir mediante @c[fmt.Println(err)] o @c[fmt.Printf("%v",
   err)].

   Normalmente cuando una funcion devuelve un error no-nil, sus otros resultados
   son indefinidos y se deben ignorar. Sin embargo, algunas funciones pueden
   devolver resultados parciales en casos de error. Por ejemplo, si se produce
   un error durante la lectura de un archivo, una llamada a @c(Read) devuelve el
   numero de bytes que fue capaz de leer @e(y) un valor @c(error) que describe
   el problema. Para el comportamiento correcto, algunos llamadores pueden
   necesitar procesar los datos incompletos antes de manejar el error, por lo
   que es importante que estas funciones documente claramente sus resultados.

   El enfoque de Go lo diferencia de muchos otros lenguajes en los que se
   reportan fallos utilizando @e(excepciones), no valores normales. Aunque Go
   tiene un mecanismo de excepcion, como veremos en la @l(#Seccion 5.9), se
   utiliza solo para informar de los errores realmente inesperadas que indican
   un error, no los errores de rutina que un programa robusto deberia esperar.

   La razon de este diseño es que las excepciones tienden a enredar la
   descripcion de un error con el flujo de control requerido para manejarlo,
   conduciendo a menudo a un resultado indeseable: los errores de rutina se
   informan al usuario final en forma de un rastro de pila incomprensible, lleno
   de informacion sobre la estructura del programa pero carece de un contexto
   inteligible sobre lo que salio mal.

   Por el contrario, los programas Go utilizan mecanismos de control de flujo
   normales como @c(if) y @c(return) para responder a los errores. Este estilo
   indudablemente exige que se preste mas atencion a la logica de manejo de
   errores, pero ese es precisamente el punto.

*** Seccion 5.4.1 <> Estrategias de Manejo de Errores

    Cuando una llamada de funcion devuelve un error, es responsabilidad del
    llamador comprobarlo y tomar la accion apropiada. Dependiendo de la
    situacion, puede haber una serie de posibilidades. Echemos un vistazo a
    cinco de ellas.

    La primera y mas comun, es @e(propagar) el error, por lo que un fallo en una
    subrutina se convierte en un fracaso de la rutina de llamada. Vimos ejemplos
    de esto en la funcion @c(findLinks) de la @l(#Seccion 5.3). Si la llamada a
    @c(http.Get) falla, @c(findLinks) devuelve el error HTTP a la persona al
    llamador sin mas preambulos:

    ..src > go
      resp, err := http.Get(url)
      if err != nil {
        return nil, err
      }
    < src..

    Por el contrario, si la llamada a @c(html.Parse) falla, @c(findLinks) no
    devuelve el error del analizador de HTML directamente, porque carece de dos
    piezas cruciales de informacion: que se produjo el error en el analizador, y
    la direccion URL del documento que se esta analizando. En este caso,
    @c(findLinks) construye un nuevo mensaje de error que incluye las dos piezas
    de informacion, asi como un analisis del error subyacente:

    ..src > go
      doc, err := html.Parse(resp.Body)
      resp.Body.Close()
      if err != nil {
        return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
      }
    < src..

    La funcion @c(fmt.Errorf) da formato a un mensaje de error utilizando
    @c(fmt.Sprintf) y devuelve un nuevo valor @c(error). Lo utilizamos para
    generar errores descriptivos mediante el prefijo sucesivo de informacion de
    contexto adicional al mensaje de error original. Cuando el error es en
    ultima instancia, manejado por la funcion @c(main) del programa, se debe
    proporcionar una cadena causal clara a partir de la raiz del problema de la
    falta en su conjunto, que recuerda a una investigacion de accidentes de la
    NASA:

    ..pre >
      genesis: crashed: no parachute: G-switch failed: bad relay orientation

    Debido a que los mensajes de error con frecuencia se encadenan juntos, las
    cadenas de mensajes no deben ser mayusculas y las lineas nuevas deben
    evitarse. Los errores resultantes pueden ser largos, pero seran
    autocontenidos cuando sean encuontrados por herramientas como grep.

    Cuando diseñe mensajes de error, sea deliberado, de modo que cada uno sea
    una descripcion significativa del problema con detalles suficientes y
    relevantes, y sea consistente, de modo que los errores devueltos por la
    misma funcion o por un grupo de funciones en el mismo paquete sean similares
    en forma y se puedan tratar de la misma manera.

    Por ejemplo, el paquete @c(os) garantiza que cada error devuelto por una
    operacion de archivo, como @c(os.Open) o los metodos @c(Read), @c(Write), o
    @c(Close) de un archivo abierto, no describen solo la naturaleza de la falla
    (permiso denegado, directorio erroneo, etc), sino tambien el nombre del
    archivo, por lo el que llamador no necesita incluir esta informacion en el
    mensaje de error.

    En general, la llamada @c[f(x)] es responsable de informar el intento de
    operacion @c(f) y el valor del argumento @c(x) en su relacion con el
    contexto del error. El llamador es responsable de añadir mas informacion que
    tiene, pero la llamada @c[f(x)] no, tal como la URL en la llamada a
    @c(html.Parse) anterior.

    Pasemos a la segunda estrategia para manejar errores. Para errores que
    representan problemas transitorios o impredecibles, puede tener sentido
    volver a intentar la operacion fallida, posiblemente con un retardo entre
    intentos, y tal vez con un limite en el numero de intentos o el tiempo
    dedicado a tratar antes de renunciar por completo.

    ..figure > @l(gopl.io/ch5/wait/wait.go<>gopl.io/ch5/wait)

      ..src > go
        // WaitForServer intenta ponerse en contacto con el servidor de una URL
        // Se intenta durante un minuto usando retroceso exponencial.
        // Informa un error si todos los intentos fallan.
        func WaitForServer(url string) error {
          const timeout = 1 * time.Minute
          deadline := time.Now().Add(timeout)
          for tries := 0; time.Now().Before(deadline); tries++ {
            _, err := http.Head(url)
            if err == nil {
              return nil // exito
            }
            log.Printf("server not responding (%s); retrying...", err)
            time.Sleep(time.Second << uint(tries)) // retroceso exponencial
          }
          return fmt.Errorf("server %s failed to respond after %s", url, timeout)
        }
      < src..


    En tercer lugar, si el progreso es imposible, el llamante puede imprimir el
    error y detener el programa con gracia, pero este curso de accion
    generalmente debe reservarse para el paquete principal de un programa. Las
    funciones de la libreria normalmente deben propagar errores al llamante, a
    menos que el error sea un signo de una inconsistencia interna, es decir, un
    error.

    ..src > go
      // (Dentro de la funcion main.)
      if err := WaitForServer(url); err != nil {
        fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
        os.Exit(1)
      }
    < src..

    Una forma mas conveniente para lograr el mismo efecto es llamar a
    @c(log.Fatalf). Al igual que con todas las funciones @c(log), por defecto se
    prefija la hora y la fecha para el mensaje de error.

    ..src > go
      if err := WaitForServer(url); err != nil {
        log.Fatalf("Site is down: %v\n", err)
      }
    < src..

    El formato predeterminado es util en un servidor de larga ejecucion, pero
    menos para una herramienta interactiva:

    ..pre >
      2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io

    Para una salida mas atractiva, podemos establecer el prefijo utilizado por
    el paquete @c(log) en el nombre del comando, y suprimir la visualizacion de la
    fecha y hora:

    ..src > go
      log.SetPrefix("wait: ")
      log.SetFlags(0)
    < src..

    En cuarto lugar, en algunos casos, basta con registrar el error y luego
    continuar, tal vez con funcionalidad reducida. Una vez mas hay una eleccion
    entre utilizar el paquete @c(log), que añade el prefijo habitual:

    ..src > go
      if err := Ping(); err != nil {
        log.Printf("ping failed: %v; networking disabled", err)
      }
    < src..

    e imprimir directamente a flujo de error estardar:

    ..src > go
      if err := Ping(); err != nil {
        fmt.Fprintf(os.Stderr, "ping failed: %v; networking disabled\n", err)
      }
    < src..

    (Todas las funciones log añaden un salto de linea si no hay uno presente).

    Y quinto y ultimo, en casos raros podemos ignorar un error completamente:

    ..src > go
      dir, err := ioutil.TempDir("", "scratch")
      if err != nil {
        return fmt.Errorf("failed to create temp dir: %v", err)
      }

      // ...use temp dir...

      os.RemoveAll(dir) // ignorar errores; $TMPDIR se limpia periodicamente
    < src..

    La llamada a os.RemoveAll puede fallar, pero el programa lo ignora porque el
    sistema operativo periodicamente limpia el directorio temporal. En este
    caso, descartar el error fue intencional, pero la logica del programa seria
    la misma si hubieramos olvidado tratar con el. Adquiera el habito de
    considerar errores despues de cada llamada de funcion, y cuando
    deliberadamente ignora uno, documente claramente su intencion.

    El manejo de errores en Go tiene un ritmo particular. Despues de comprobar
    un error, el fracaso suele tratarse antes del exito. Si el fallo hace que la
    funcion regrese, la logica para el exito no se sangra dentro de un bloque
    @c(else), pero continua en el nivel externo. Las funciones tienden a exhibir
    una estructura comun, con una serie de comprobaciones iniciales para
    rechazar errores, seguidas por la esencia de la funcion al final,
    minimamente indentada.

*** Seccion 5.4.2 <> Fin de Archivo (EOF)

    Normalmente, la variedad de errores que una funcion puede devolver es
    interesante para el usuario final, pero no para la logica del programa
    intermedio. En ocasiones, sin embargo, un programa debe tomar diferentes
    acciones dependiendo del tipo de error que se ha producido. Considere un
    intento de leer @m(n) bytes de datos de un archivo. Si se elige @m(n) para
    ser la longitud del archivo, cualquier error representa un fracaso. Por otro
    lado, si el llamador trata repetidamente de leer fragmentos de tamaño fijo
    hasta que el archivo se agote, el llamador debe responder de manera
    diferente a una condicion de fin de archivo que a todos los demas
    errores. Por esta razon, el paquete @c(io) garantiza que cualquier daño
    causado por una condicion de fin de archivo siempre informa de un error
    distinguida, @c(io.EOF), que se define de la siguiente manera:

    ..src > go
      package io

      import "errors"

      // EOF es el error devuelto por Read cuando no hay mas entrada disponible.
      var EOF = errors.New("EOF")
    < src..

    El llamador puede detectar esta condicion usando una comparacion simple,
    como en el bucle siguiente, que lee runas de la entrada estandar. (El
    programa @$(charcount) en la @l(#Seccion 4.3) ofrece un ejemplo mas
    completo.)

    ..src > go
      in := bufio.NewReader(os.Stdin)
      for {
        r, _, err := in.ReadRune()
        if err == io.EOF {
          break // lectura terminada
        }
        if err != nil {
          return fmt.Errorf("read failed: %v", err)
        }
        // ...usar r...
      }
    < src..

    Puesto que en una condicion de fin de archivo no existe informacion que
    informar ademas del hecho de que, @c(io.EOF) tiene un mensaje de error fijo,
    @c("EOF"). Para otros errores, es posible que tengamos que informar tanto la
    calidad como la cantidad del error, por asi decirlo, por lo que un valor de
    error fijo no lo hara. En la @l(#Seccion 7.11), vamos a presentar de manera
    mas sistematica a distinguir ciertos valores de error de los demas.

** Seccion 5.5 <> Valores de la Funcion

   En Go las funciones son valores de primera clase: al igual que otros valores,
   los valores de funcion tienen tipos, y pueden ser asignados a variables o
   pasarse a o regresarlas de funciones. Un valor de funcion puede ser llamado
   como cualquier otra funcion. Por ejemplo:

   ..src > go
     func square(n int) int     { return n * n }
     func negative(n int) int   { return -n }
     func product(m, n int) int { return m * n }

     f := square
     fmt.Println(f(3))     // "9"

     f = negative
     fmt.Println(f(3))     // "-3"
     fmt.Printf("%T\n", f) // "func(int) int"

     f = product // error de compilacion: no se puede asignar f(int, int) int a f(int) int
   < src..

   El valor cero para el tipo funcion es @c(nil). Llamar a un valor de funcion
   nulo produce un panico:

   ..src > go
     var f func(int) int
     f(3) // panico: llamar a funcion nil
   < src..

   Los valores de funcion pueden compararse con @c(nil):

   ..src > go
     var f func(int) int
     if f != nil {
       f(3)
     }
   < src..

   Pero no son comparables, por lo que no pueden comparse entre si o utilizarse
   como claves en un mapa.

   Los valores de las funciones nos permiten parametrizar nuestras funciones no
   solo sobre los datos sino tambien sobre el comportamiento. Las librerias
   estandar contienen muchos ejemplos. Por ejemplo, @c(strings.Map) aplica una
   funcion a cada caracter de una cadena, uniendo los resultados para formar
   otra cadena.

   ..src > go
     func add1(r rune) rune { return r + 1 }

     fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
     fmt.Println(strings.Map(add1, "VMS"))      // "WNT"

     fmt.Println(strings.Map(add1, "Admix"))    // "Benjy"
   < src..

   La funcion @c(findLinks) de la @l(#Seccion 5.2) utiliza una funcion auxiliar,
   @c(visit), para visitar todos los nodos en un documento HTML y aplicar una
   accion a cada uno. Usando el valor de una funcion, podemos separar la logica
   del recorrido del arbol de la logica para la accion a aplicar a cada nodo,
   permitiendonos reutilizar el recorrido con diferentes acciones.

   ..figure > @l(gopl.io/ch5/outline2/outline.go<>gopl.io/ch5/outline2)

     ..src > go
       // forEachNode llama a las funciones pre(x) y post(x) para cada nodo
       // x en el arbol originado en n. Ambas funciones son opcionales.
       // pre se llama antes de que los hijos sean visitados (preorden) y
       // post se llama despues (postorden).
       func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
         if pre != nil {
           pre(n)
         }

         for c := n.FirstChild; c != nil; c = c.NextSibling {
           forEachNode(c, pre, post)
         }

         if post != nil {
           post(n)
         }
       }
     < src..


   La funcion @c(forEachNode) acepta dos argumentos de funcion, una para llamar
   antes de que se visiten los hijos de un nodo y otra para llamar despues. Esta
   disposicion da a al lamador una gran flexibilidad. Por ejemplo, las funciones
   @c(startElement) y @c(endElement) imprimen las etiquetas de inicio y fin de
   un elemento HTML, como @c(<b>...</b>):

   ..src > go
     var depth int

     func startElement(n *html.Node) {
       if n.Type == html.ElementNode {
         fmt.Printf("%*s<%s>\n", depth*2, "", n.Data)
         depth++
       }
     }

     func endElement(n *html.Node) {
       if n.Type == html.ElementNode {
         depth--
         fmt.Printf("%*s</%s>\n", depth*2, "", n.Data)
       }
     }
   < src..

   Las funciones tambien indentan la salida usando otro truco de
   @c(fmt.Printf). El adverbio @c(*) en @c(%*s) imprime una cadena rellena con
   un numero variable de espacios. La anchura y la cadena se proporcionan por
   los argumentos @c(depth*2) y @c("").

   Si llamamos a @c(forEachNode) en un documento HTML, de esta forma:

   ..src > go
     forEachNode(doc, startElement, endElement)
   < src..

   obtenemos una variacion mas elaborada en la salida de nuestra programa
   @$(outline) anterior:

   ..src > sh
     $ go build gopl.io/ch5/outline2
     $ ./outline2 http://gopl.io
     <html>
       <head>
         <meta>
         </meta>
         <title>
         </title>
         <style>
         </style>
       </head>
     <body>
       <table>
         <tbody>
           <tr>
             <td>
               <a>
                 <img>
                 </img>
     ...
   < src..

   @b(Ejercicio 5.7): Desarrolla @c(startElement) y @c(endElement) en una
   agradable impresora HTML general. Imprime los nodos de comentarios, nodos de
   texto y los atributos de cada elemento (@c(<a href='...'>)). Utilizar formas
   cortas como @c(<img/>) en lugar de @c(<img></img>) cuando un elemento no
   tiene hijos. Escribir una prueba para asegurarse de que la salida se puede
   analizar con exito. (Vease el @l(#Capitulo 11)).

   @b(Ejercicio 5.8): Modificar @c(forEachNode) para que las funciones @c(pre) y
   @c(post) devuelvan un resultado booleano que señale si se debe continuar el
   recorrido. Utilicelo para escribir una funcion @c(ElementByID) con la
   siguiente firma que se encuentra el primer elemento HTML con el atributo id
   especificado. La funcion debe detener el recorrido tan pronto como se
   encuentre una coincidencia.

   ..src > go
     func ElementByID(doc *html.Node, id string) *html.Node
   < src..

   @b(Ejercicio 5.9): Escribir una funcion @c[expand(s string, f func(string)
   string) string] que reemplaze cada subcadena @c("$foo") dentro de @c(s) con
   el texto devuelto por @c[f("foo")].

** Seccion 5.6 <> Funciones Anonimas

   Funciones con nombre se pueden declarar solo a nivel de paquete, pero podemos
   utilizar un @e(literal de funcion) para denotar un valor de funcion dentro de
   cualquier expresion. Un literal funcion se escribe como una declaracion de la
   funcion, pero sin un nombre despues de la palabra clave @c(func). Es una
   expresion, y su valor se denomina @e(funcion anonima).

   Los literales de la funcion definen una funcion en su punto de uso. A modo de
   ejemplo, la llamada anterior a @c(strings.Map) se puede reescribir como

   ..src > go
     strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
   < src..

   Mas importante aun, las funciones definidas de esta manera tienen acceso a
   todo el entorno lexico, por lo que la funcion interna puede referirse a
   variables de la funcion de inclusion, como muestra este ejemplo:

   ..figure > @l(gopl.io/ch5/squares/main.go<>gopl.io/ch5/squares)

     ..src > go
       // squares regresa una funcion que devuelve el siguiente
       // cuadrado del numero cada ves que se llama.
       func squares() func() int {
         var x int
         return func() int {
           x++
           return x * x
         }
       }

       func main() {
         f := squares()
         fmt.Println(f()) // "1"
         fmt.Println(f()) // "4"
         fmt.Println(f()) // "9"
         fmt.Println(f()) // "16"
       }
     < src..


   La funcion @c(squares) devuelve otra funcion, de tipo @c[func() int]. Una
   llamada a @c(squares) crea una variable local @c(x) y devuelve una funcion
   anonima que, cada vez que se llama, incrementa @c(x) y devuelve su
   cuadrado. Una segunda llamada a @c(squares) crearia una segunda variable
   @c(x) y devolvera una nueva funcion anonima que incremente esa variable.

   El ejemplo @c(squares) demuestra que los valores de funcion no son solo
   codigo, sino que pueden tener estado. La funcion anonima interna puede
   acceder y actualizar las variables locales dentro de la funcion @c(squares).
   Estas referencias de variables ocultas son el por que clasificamos a las
   funciones como tipos de referencia y motivo de que los valores de las
   funciones no sean comparables. Los valores de funcion como estos se
   implementan utilizando una tecnica llamada @e(closures), y los programadores
   Go a menudo utilizan este termino para los valores de la funcion.

   Aqui de nuevo vemos un ejemplo donde el tiempo de vida de una variable no
   esta determinada por su ambito de aplicacion: la variable @c(x) existe
   despues del retorno de @c(squares) dentro de @c(main), aunque @c(x) este
   oculta dentro de @c(f).

   Como un ejemplo un tanto academico de funciones anonimas, considere el
   problema de calcular una secuencia de los cursos de ciencias de la
   computacion que satisfagan los requisitos previos de cada uno. Los
   prerequisitos se dan en la tabla @c(prereqs) de abajo, que es un mapeo de
   cada curso a la lista de cursos que se deben completar antes de ella.

   ..figure > @l(gopl.io/ch5/toposort/main.go<>gopl.io/ch5/toposort)

     ..src > go
       // prereqs asigna cursos de ciencia de la computacion a sus prerequisitos.
       var prereqs = map[string][]string{
         "algoritmos": {"estructura de datos"},
         "calculo":   {"algebra lineal"},

         "compiladores": {
           "estructura de datos",
           "lenguajes formales",
           "organizacion de computadoras",
         },

         "estructura de datos":       {"matematicas discretas"},
         "bases de datos":            {"estructura de datos"},
         "matematicas discretas":     {"introduccion a la programacion"},
         "lenguajes formales":        {"matematicas discretas"},
         "redes":                     {"sitemas operativos"},
         "sistemas operativos":       {"estructura de datos", "organizacion de computadoras"},
         "lenguajes de programacion": {"estructura de datos", "organizacion de computadoras"},
       }
     < src..


   Este tipo de problema se conoce como clasificacion topologica.
   Conceptualmente, la informacion de los requisitos previos forma un grafico
   dirigido con un nodo para cada curso y los bordes de cada curso a los cursos
   de los que depende. El grafico es aciclico: no hay camino de un curso que
   vuelva a si mismo. Podemos calcular una secuencia valida usando la busqueda
   de profundidad en el grafico con el siguiente codigo:

   ..src > go
     func main() {
       for i, course := range topoSort(prereqs) {
         fmt.Printf("%d:\t%s\n", i+1, course)
       }
     }

     func topoSort(m map[string][]string) []string {
       var order []string
       seen := make(map[string]bool)
       var visitAll func(items []string)

       visitAll = func(items []string) {
         for _, item := range items {
           if !seen[item] {
             seen[item] = true
             visitAll(m[item])
             order = append(order, item)
           }
         }
       }

       var keys []string
       for key := range m {
         keys = append(keys, key)
       }

       sort.Strings(keys)
       visitAll(keys)
       return order
     }
   < src..


   Cuando una funcion anonima requiere recursion, como en este ejemplo, primero
   debemos declarar una variable, y luego asignar la funcion anonima a esa
   variable. Si estos dos pasos estuvieran combinados en la declaracion, la
   funcion literal no estaria dentro del alcance de la variable @c(visitAll) por
   lo que no tendria ninguna manera de llamarse a si misma de forma recursiva:

   ..src > go
     visitAll := func(items []string) {
       // ...
       visitAll(m[item]) // compile error: undefined: visitAll
       // ...
     }
   < src..

   La salida del programa @$(toposort) se muestra a continuacion. Es
   determinista, una propiedad a menudo deseable que no siempre viene de forma
   gratuita. En este caso, los valores del mapa @c(prereqs) son slices, no mas
   mapas, por lo que su orden de iteracion es determinista, y ordenamos las
   llaves de @c(prereqs) antes de hacer las llamadas iniciales a @c(visitAll) .

   ..pre >
     1:      introduccion a la programacion
     2:      matematicas discretas
     3:      estructura de datos
     4:      algoritmos
     5:      algebra lineal
     6:      calculo
     7:      lenguajes formales
     8:      organizacion de computadoras
     9:      compiladores
     10:     bases de datos
     11:     sistemas operativos
     12:     redes
     13:     Lenguajes de programacion
   < pre..

   Volvamos a nuestro ejemplo @c(findLinks). Hemos movido la funcion de
   extraccion de enlaces @c(links.Extract) a su propio paquete, ya que la
   usaremos de nuevo en el @l(#Capitulo 8). Hemos sustituido la funcion
   @c(visit) con una funcion anonima que agrega directamente los @c(links) al
   slice, y utilizamos @c(forEachNode) para manejar el recorrido. Ya que
   @c(Extract) solo necesita la funcion @c(pre), se pasa @c(nil) para el
   argumento @c(post).

   ..figure > @l(gopl.io/ch5/links/links.go<>gopl.io/ch5/links)

     ..src > go
       // El paquete links proporciona una funcion de extraccion de links.
       package links

       import (
         "fmt"
         "net/http"

         "golang.org/x/net/html"
       )

       // Extract hace una peticion HTTP GET a la URL especificada, analiza
       // la respuesta como HTML, y regresa el enlace en el documento HTML.
       func Extract(url string) ([]string, error) {
         resp, err := http.Get(url)
         if err != nil {
           return nil, err
         }
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
         }

         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         var links []string
         visitNode := func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "a" {
             for _, a := range n.Attr {
               if a.Key != "href" {
                 continue
               }
               link, err := resp.Request.URL.Parse(a.Val)
               if err != nil {
                 continue // ignora URLs incorrectas
               }
               links = append(links, link.String())
             }
           }
         }
         forEachNode(doc, visitNode, nil)
         return links, nil
       }
     < src..


   En lugar de añadir el atributo @c(href) en bruto al slice @c(links), esta
   version lo analiza como una direccion URL relativa a la URL base del
   documento, @c(resp.Request.URL). El enlace resultante esta en formato
   absoluta, adecuado para su uso en una llamada a @c(http.Get).

   El rastreador web es, en su corazon, un problema de grafico transversal. El
   ejemplo @c(topoSort) mostra un recorrido en profundidad; Para nuestro
   rastreador web, vamos a utilizar la anchura de primera transversal, al menos
   inicialmente. En el @l(#Capitulo 8), vamos a explorar el recorrido
   concurrente.

   La siguiente funcion encapsula la esencia de un recorrido de
   primer-anchura. El llamador proporciona una lista inicial @c(worklist) de
   elementos a visitar y un valor de la funcion @c(f) a llamar para cada
   elemento. Cada elemento se identifica mediante una cadena. La funcion @c(f)
   devuelve una lista de elementos nuevos a añadir a la lista de trabajo. La
   funcion @c(breadthFirst) regresa cuando todos los elementos han sido
   visitados. Mantiene un conjunto de cadenas para garantizar que ningun
   elemento se visita dos veces.

   ..figure > @l(gopl.io/ch5/findlinks3/findlinks.go<>gopl.io/ch5/findlinks3)

     ..src > go
       // breadthFirst llama a f para cada elemento en worklist.
       // Todos los elementos devueltos por f se agregan a worklist.
       // f se llama como maximo una vez para cada elemento.
       func breadthFirst(f func(item string) []string, worklist []string) {
         seen := make(map[string]bool)
         for len(worklist) > 0 {
           items := worklist
           worklist = nil
           for _, item := range items {
             if !seen[item] {
               seen[item] = true
               worklist = append(worklist, f(item)...)
             }
           }
         }
       }
     < src..


   Como explicamos al pasar por el @l(#Capitulo 3), el argumento de
   @"{@c[f(item)...]}  hace que todos los elementos de la lista devuelta por f
   que se añadan a la lista de trabajo.

   En nuestro rastreador, los elementos son URL. La funcion @c(crawl) que
   suministramos a @c(breadthFirst) imprime la URL, extrae sus enlaces, y los
   devuelve para que tambien se visiten..

   ..src > go
     func crawl(url string) []string {
       fmt.Println(url)
       list, err := links.Extract(url)
       if err != nil {
         log.Print(err)
       }
       return list
     }
   < src..

   Para iniciar el rastreador, utilizaremos los argumentos de la linea de
   comandos como las URL iniciales.

   ..src > go
     func main() {
       // Rastrear la web la primer-anchura,
       // partiendo de los argumentos de la linea de comandos.
       breadthFirst(crawl, os.Args[1:])
     }
   < src..

   Vamos a rastrear la web desde @c(https://golang.org). Estos son algunos de
   los enlaces resultantes:

   ..src > sh
     $ go build gopl.io/ch5/findlinks3
     $ ./findlinks3 https://golang.org
     https://golang.org/
     https://golang.org/doc/
     https://golang.org/pkg/
     https://golang.org/project/
     https://code.google.com/p/go-tour/
     https://golang.org/doc/code.html
     https://www.youtube.com/watch?v=XCsL89YtqCs
     http://research.swtch.com/gotour
     https://vimeo.com/53221560
   < src..

   El proceso finaliza cuando todas las paginas web alcanzables se han rastreado
   o se ha agotado la memoria del equipo.

   @b(Ejercicio 5.10): Vuelve a escribir @c(topoSort) para utilizar mapas en
   lugar de slices y eliminar la clasificacion inicial. Verifique que los
   resultados, aunque no deterministicos, sean ordenamientos topologicos
   validos.

   @b(Ejercicio 5.11): El instructor del curso de algebra lineal decide que
   ahora es un requisito previo. Extender la funcion @c(topoSort) para reportar
   ciclos.

   @b(Ejercicio 5.12): Las funciones @c(startElement) y @c(endElement) en
   @c(gopl.io/ch5/outline2) (@l(#Seccion 5.5<>§5.5)) comparten una variable
   global, @c(depth). Conviertalas en funciones anonimas que compartan una
   variable local de la funcion @c(outline).

   @b(Ejercicio 5.13): Modificar @c(crawl) para hacer copias locales de las
   paginas que encuentre, la creando directorios segun sea necesario. No haga
   copias de paginas que provengan de un dominio diferente. Por ejemplo, si la
   pagina original proviene de @l(https://golang.org<>golang.org), guarda todos
   los archivos de alli, pero excluyen los de @l(https://vimeo.com<>vimeo.com).

   @b(Ejercicio 5.14): Usar la funcion @c(breadthFirst) para explorar una
   estructura diferente. Por ejemplo, podria utilizar las dependencias de cursos
   del ejemplo @c(topoSort) (un grafo dirigido), la jerarquia del sistema de
   archivos en el ordenador (un arbol), o una lista de rutas de autobus o de
   metro descargados desde el sitio web de su gobierno de la ciudad (un grafo no
   dirigido).

*** Seccion 5.6.1 <> Advertencia: Captura de Variables de Iteracion

    En esta seccion, veremos una trampa de las reglas de alcance lexico de Go
    que pueden causar resultados sorprendentes. Le recomendamos que comprenda el
    problema antes de proceder, porque la trampa puede atrapar incluso a
    programadores experimentados.

    Considere un programa que debe crear un conjunto de directorios y luego
    eliminarlos. Podemos usar una porcion de valores de funcion para mantener
    las operaciones de limpieza. (Para mayor brevedad, hemos omitido todo el
    manejo de errores en este ejemplo.)

    ..src > go
      var rmdirs []func()
      for _, d := range tempDirs() {
        dir := d               // NOTA: necesario!
        os.MkdirAll(dir, 0755) // tambien crea los directorios padre
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dir)
        })
      }

      // ...algo de trabajo...

      for _, rmdir := range rmdirs {
        rmdir() // clean up
      }
    < src..

    Es posible que se pregunte por que asignamos la variable de bucle @c(d) a
    una nueva variable local @c(dir) dentro del cuerpo del bucle, en lugar de
    simplemente nombrar a la variable de bucle @c(dir) que en esta variante
    sutil incorrectos:

    ..src > go
      var rmdirs []func()
      for _, dir := range tempDirs() {
        os.MkdirAll(dir, 0755)
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dir) // NOTA: incorrecto!
        })
      }
    < src..

    La razon es una consecuencia de las reglas de alcance para variables de
    bucle. En el programa inmediatamente anterior, el bucle @c(for) introduce un
    nuevo bloque lexico en el que se declara la variable @c(dir). Todos los
    valores de la funcion creados por esta bucle @"(capturan) y comparten la
    misma variable–Un lugar de almacenamiento direccionable, no su valor en ese
    momento en particular. El valor de @c(dir) se actualiza en iteraciones
    sucesivas, de manera que cuando las funciones de limpieza son llamados, la
    variable @c(dir) ha sido actualizado varias veces por el ahora completado
    bucle @c(for). Por lo tanto @c(dir) mantiene el valor de la iteracion final,
    y por lo tanto todas las llamadas a @c(os.RemoveAll) intentaran eliminar el
    mismo directorio.

    Con frecuencia, la variable interna introducido para evitar este
    problema–@c(dir) en nuestro ejemplo–se le da exactamente el mismo nombre que
    la variable externa de la que es una copia, lo que lleva a las declaraciones
    de variables de aspecto extraño pero cruciales como este:

    ..src > go
      for _, dir := range tempDirs() {
        dir := dir // declara dir interno, inicializado a dir externo
        // ...
      }
    < src..

    El riesgo no es unica para bucles @c(for) basados en @c(range). El bucle en
    el siguiente ejemplo adolece del mismo problema debido a la captura no
    intencionada de la variable de indice @c(i).

    ..src > go
      var rmdirs []func()
      dirs := tempDirs()
      for i := 0; i < len(dirs); i++ {
        os.MkdirAll(dirs[i], 0755) // OK
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dirs[i]) // NOTA: incorrecto!
        })
      }
    < src..

    El problema de la iteracion de captura variable se encuentran mas a menudo
    cuando se utiliza la sentencia @c(go) (@l(#Capitulo 8)) o con @c(defer) (que
    veremos en un momento), ya que ambos pueden retrasar la ejecucion de un
    valor de funcion hasta despues de que el bucle ha finalizado. Pero el
    problema no es inherente a @c(go) o @c(defer).

** Seccion 5.7 <> Funciones Variadic

   Una @e(funcion variadic) es uno que se puede llamar con un numero de
   argumentos variable. Los ejemplos mas conocidos son @c(fmt.Printf) y sus
   variantes. @c(Printf) requiere un argumento fijo al principio, luego acepta
   cualquier numero de argumentos posteriores.

   Para declarar una funcion variadic, el tipo del parametro final va precedida
   por una elipsis, @"(@c(...)), que indica que la funcion puede ser llamada con
   cualquier numero de argumentos de este tipo.

   ..figure > @l(gopl.io/ch5/sum/main.go<>gopl.io/ch5/sum)

     ..src > go
       func sum(vals ...int) int {
         total := 0
         for _, val := range vals {
           total += val
         }
         return total
       }
     < src..


   La funcion @c(sum) anterior devuelve la suma de cero o mas argumentos
   @c(int). Dentro del cuerpo de la funcion, el tipo de @c(vals) es un slice
   @c([]int). Cuando llame a @c(sum), cualquier numero de valores puede ser
   proporcionado pora su parametro @c(vals).

   ..src > go
     fmt.Println(sum())           // "0"
     fmt.Println(sum(3))          // "3"
     fmt.Println(sum(1, 2, 3, 4)) // "10"
   < src..

   Implicitamente, el llamador asigna un arreglo, copia los argumentos en ell y
   pasa un slice de toda la arreglo a la funcion. La llamada anterior se
   comporta de la misma manera que la llamada que se muestra a continuacion, que
   muestra como invocar una funcion variadica cuando los argumentos ya estan en
   un slice: coloca una elipsis despues del argumento final.

   ..src > go
     values := []int{1, 2, 3, 4}
     fmt.Println(sum(values...)) // "10"
   < src..

   Aunque el parametro @c(...int) se comporta como una slice dentro del cuerpo
   de la funcion, el tipo de una funcion variadic es distinto del tipo de una
   funcion con un parametro slice ordinario.

   ..src > go
     func f(...int) {}
     func g([]int)  {}

     fmt.Printf("%T\n", f) // "func(...int)"
     fmt.Printf("%T\n", g) // "func([]int)"
   < src..

   Las funciones variadic se utilizan a menudo para el formato de la
   secuencia. La funcion @c(errorf) a continuacion construye un mensaje de error
   con formato con un numero de linea en el principio. El sufijo @c(f) es una
   convencion de nomenclatura ampliamente seguido para funciones variadic que
   aceptan una cadena de formato de estilo @c(Printf).

   ..src > go
     func errorf(linenum int, format string, args ...interface{}) {
       fmt.Fprintf(os.Stderr, "Line %d: ", linenum)
       fmt.Fprintf(os.Stderr, format, args...)
       fmt.Fprintln(os.Stderr)
     }

     linenum, name := 12, "count"
     errorf(linenum, "undefined: %s", name) // "Linea 12: sin definir: count"
   < src..

   El tipo @c(interface{}) significa que esta funcion puede aceptar cualquier
   valor en absoluto para sus argumentos finales, como explicaremos en el
   @l(#Capitulo 7).

   @b(Ejercicio 5.15): Escribir funciones variadic @c(max) y @c(min), analoga a
   @c(sum). ¿Que deben hacer estas funciones cuando se llaman sin argumentos?
   Escribir variantes que requieren al menos un argumento.

   @b(Ejercicio 5.16): Escribir una version variadic @c(de strings.Join) .

   @b(Ejercicio 5.17): Escribir una funcion variadic @c(ElementsByTagName) que, dado
   un arbol de nodos HTML y cero o mas nombres, devuelve todos los elementos que
   coinciden con uno de esos nombres. Aqui hay dos ejemplos de llamadas:

   ..src > go
     func ElementsByTagName(doc *html.Node, name ...string) []*html.Node

     images := ElementsByTagName(doc, "img")
     headings := ElementsByTagName(doc, "h1", "h2", "h3", "h4")
   < src..

** Seccion 5.8 <> Llamadas de Funcion Diferida

   Nuestros ejemplos @c(findLinks) utilizan la salida de @c(http.Get) como la
   entrada de @c(html.Parse). Esto funciona bien si el contenido de la URL
   solicitada es de hecho HTML, pero muchas paginas contienen imagenes, texto
   sin formato y otros formatos de archivo. La alimentacion de estos archivos en
   un analizador HTML podria tener efectos no deseados.

   El siguiente programa recupera un documento HTML e imprime su titulo. La
   funcion @c(title) inspecciona la cabecera @c(Content-Type) de la respuesta
   del servidor y devuelve un error si el documento no es HTML.

   ..figure > @l(gopl.io/ch5/title1/title.go<>gopl.io/ch5/title1)

     ..src > go
       func title(url string) error {
         resp, err := http.Get(url)
         if err != nil {
           return err
         }

         // Comprueba que Content-Type sea HTML (e.g., "text/html; charset=utf-8").
         ct := resp.Header.Get("Content-Type")
         if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
           resp.Body.Close()
           return fmt.Errorf("%s has type %s, not text/html", url, ct)
         }

         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         visitNode := func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "title" &&
             n.FirstChild != nil {
             fmt.Println(n.FirstChild.Data)
           }
         }
         forEachNode(doc, visitNode, nil)
         return nil
       }
     < src..


   Aqui esta una sesion tipica, ligeramente editada para encajar:

   ..src > sh
     $ go build gopl.io/ch5/title1
     $ ./title1 http://gopl.io
     The Go Programming Language
     $ ./title1 https://golang.org/doc/effective_go.html
     Effective Go - The Go Programming Language
     $ ./title1 https://golang.org/doc/gopher/frontpage.png
     title: https://golang.org/doc/gopher/frontpage.png
         has type image/png, not text/html
   < src..

   Observe la llamada duplicada @c[resp.Body.Close()], que asegura que @c(title)
   se cierre la conexion de red en todas las rutas de ejecucion, incluyendo las
   fallas. A medida que las funciones se vuelven mas complejas y tienen que
   manejar mas errores, tal duplicacion de la logica de limpieza puede
   convertirse en un problema de mantenimiento. Veamos como el nuevo mecanismo
   @c(defer) de Go hace las cosas mas sencillas.

   Sintacticamente, una sentencia @c(defer) es una funcion ordinaria o una
   llamada a un metodo con la palabra clave @c(defer) como prefijo. Las
   expresiones de funcion y los argumentos se evaluan cuando se ejecuta la
   instruccion, pero la llamada real se aplaza hasta que la funcion que contiene
   la declaracion @c(defer) ha terminado, ya sea ejecutando una instruccion de
   retorno o llegando al final, o anormalmente, por un panico. Cualquier numero
   de llamadas puede ser diferido; se ejecutan en el orden inverso en que fueron
   aplazadas.

   Una sentencia @c(defer) se utiliza a menudo con operaciones pareadas como
   abrir y cerrar, conectar y desconectar o bloquear y desbloquear para
   garantizar que los recursos se liberan en todos los casos, independientemente
   de la complejidad del flujo de control. El lugar adecuado para una sentencia
   @c(defer) que libera un recurso es inmediatamente despues de que el recurso
   se ha adquirido con exito. En la funcion @c(title) a continuacion, una sola
   llamada diferida sustituye a las dos llamadas anteriores de
   @c[resp.Body.Close()]:

   ..figure > @l(gopl.io/ch5/title2/title.go<>gopl.io/ch5/title2)

     ..src > go
       func title(url string) error {
         resp, err := http.Get(url)
         if err != nil {
           return err
         }
         defer resp.Body.Close()

         ct := resp.Header.Get("Content-Type")
         if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
           return fmt.Errorf("%s has type %s, not text/html", url, ct)
         }

         doc, err := html.Parse(resp.Body)
         if err != nil {
           return fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         // ...imprimir los elementos title del documento...

         return nil
       }
     < src..

   El mismo patron se puede utilizar para otros recursos ademas de las
   conexiones de red, por ejemplo para cerrar un archivo abierto:

   ..figure > @c(io/ioutil)

     ..src > go
       package ioutil

       func ReadFile(filename string) ([]byte, error) {
         f, err := os.Open(filename)
         if err != nil {
           return nil, err
         }
         defer f.Close()
         return ReadAll(f)
       }
     < src..


   o para desbloquear un mutex (@l(#Seccion 9.2<>§9.2)):

   ..src > go
     var mu sync.Mutex
     var m = make(map[string]int)

     func lookup(key string) int {
       mu.Lock()
       defer mu.Unlock()
       return m[key]
     }
   < src..

   La sentencia @c(defer) tambien se puede utilizar para emparejar acciones de
   @"(entrada) y @"(salida) al depurar una funcion compleja. A continuacion la
   funcion @c(bigSlowOperation) llama inmediatamente a @c(trace), lo que la hace
   una accion de @"(entrada) que devuelve un valor de funcion que, cuando se le
   llama, hace la accion de @"(salida).  Al diferir una llamada a la funcion
   devuelta de esta manera, podemos instrumentar el punto de entrada y todos los
   puntos de salida de una funcion en una sola declaracion, e incluso pasar
   valores, como el tiempo de inicion @c(start), entre las dos acciones. Pero no
   se olvide de los parentesis finales en el sentencia @c(defer), o la accion de
   @"(entrada) ocurrira en la salida y la accion en la salida no ocurrira en
   absoluto!

   ..figure > @l(gopl.io/ch5/trace/main.go<>gopl.io/ch5/trace)

     ..src > go
       func bigSlowOperation() {
         defer trace("bigSlowOperation")() // no olvide los parentesis adicionales
         // ...mucho trabajo...
         time.Sleep(10 * time.Second)      // simula el funcionamiento lento durmiendo
       }

       func trace(msg string) func() {
         start := time.Now()
         log.Printf("enter %s", msg)
         return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
       }
     < src..


   Cada vez @c(bigSlowOperation) se llama, registra su entrada y salida y el
   tiempo transcurrido entre ellos. (Utilizamos @c(time.Sleep) para simular una
   operacion lenta.)

   ..src > sh
     $ go build gopl.io/ch5/trace
     $ ./trace
     2015/11/18 09:53:26 enter bigSlowOperation
     2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s)
   < src..

   Las funciones diferidas se ejecutan despues de las declaraciones de retorno
   han actualizado las variables de resultado de la funcion. Debido a que una
   funcion anonima puede acceder a las variables de su funcion de inclusion,
   incluidos los resultados con nombra, una funcion anonima diferida puede
   observar los resultados de la funcion.

   Considere la funcion @c(doble):

   ..src > go
     func doble(x int) int {
       return x + x
     }
   < src..

   Al nombrar a su variable de resultado y agregar una sentecia @c(defer),
   podemos hacer que la funcion imprimir sus argumentos y resultados cada vez
   que se llame.

   ..src > go
     func doble(x int) (resultado int) {
       defer func() { fmt.Printf("doble(%d) = %d\n", x, resultado) }()
       return x + x
     }

     _ = double(4)
     // Salida:
     // "doble(4) = 8"
   < src..

   Este truco es exesivo para una funcion tan simple como @c(doble), pero puede
   ser util en funciones con muchas declaraciones de retorno.

   Una funcion anonima diferida puede incluso cambiar los valores que la funcion
   devuelve a su interlocutor:

   ..src > go
     func triple(x int) (result int) {
       defer func() { result += x }()
       return doble(x)
     }

     fmt.Println(triple(4)) // "12"
   < src..

   Dado que las funciones diferidos no se ejecutan hasta el final de la
   ejecucion de una funcion, una declaracion @c(defer) en un bucle merece un
   escrutinio adicional. El codigo siguiente podria quedar sin los descriptores
   de archivo ya que ningun archivo se cerrara hasta que todos los archivos se
   hayan procesado:

   ..src > go
     for _, filename := range filenames {
       f, err := os.Open(filename)
       if err != nil {
         return err
       }
       defer f.Close() // NOTA: arriesgado; podria quedarse sin los descriptores de archivo
       // ...procesando f...
     }
   < src..

   Una solucion es mover el cuerpo del bucle, incluyendo la declaracion
   @c(defer), a otra funcion que se llame en cada iteracion.

   ..src > go
     for _, filename := range filenames {
       if err := doFile(filename); err != nil {
         return err
       }
     }

     func doFile(filename string) error {
       f, err := os.Open(filename)
       if err != nil {
         return err
       }
       defer f.Close()
       // ...procesando f...
     }
   < src..

   El siguiente ejemplo es una mejora del programa @$(fetch) (@l(#Seccion
   1.5<>§1.5)) que escribe la respuesta HTTP a un archivo local en lugar de a la
   salida estandar. Deriva el nombre del archivo del el ultimo componente de la
   ruta URL, que obtiene utilizando la funcion @c(path.Base).

   ..figure > @l(gopl.io/ch5/fetch/main.go<>gopl.io/ch5/fetch)

     ..src > go
       // Fetch descarga la URL y regresa el rombre
       // y la longitud del archivo local.
       func fetch(url string) (filename string, n int64, err error) {
         resp, err := http.Get(url)
         if err != nil {
           return "", 0, err
         }
         defer resp.Body.Close()

         local := path.Base(resp.Request.URL.Path)
         if local == "/" {
           local = "index.html"
         }
         f, err := os.Create(local)
         if err != nil {
           return "", 0, err
         }
         n, err = io.Copy(f, resp.Body)
         // Close file, but prefer error from Copy, if any.
         if closeErr := f.Close(); err == nil {
           err = closeErr
         }
         return local, n, err
       }
     < src..


   La llamada diferida a @c(resp.Body.Close) deberia resultar familiar por
   ahora. Es tentador utilizar una segunda llamada diferida, a @c(f.Close), para
   cerrar el archivo local, pero esto seria sutilmente incorrecto porque
   @c(os.Create) abre un archivo para escribir, crear, segun sea necesario. En
   muchos sistemas de archivos, notablemente NFS, los errores de escritura no se
   informan inmediatamente pero se pueden posponer hasta que se cierre el
   archivo. Si no se comprueba el resultado de la operacion de cierre, la
   perdida de datos graves podria pasar desapercibida. Sin embargo, si ambos
   @c(io.Copy) y @c(f.Close) fallan, debemos preferir reportar el error de
   @c(io.Copy) desde que ocurre por primera vez y es mas probable que nos diga
   la causa raiz.

   @b(Ejercicio 5.18): Sin cambiar su comportamiento, reescriba la funcion
   @c(fetch) utilizando @c(defer) para cerrar el archivo de escritura.

** Seccion 5.9 <> Panico

   El sistema de tipado de Go captura muchos errores en tiempo de compilacion,
   pero otros, como un acceso a un arreglo fuera de limites o una desreferencia
   de puntero nulo, requieren comprobaciones en tiempo de ejecucion. Cuando go
   detecta errores en tiempo de ejecucion, entra en @e(panico).

   Durante un panico tipico, la ejecucion normal se detiene, todas las llamadas
   de funcion diferida en esa gorutina se ejecutan, y el programa se bloquea con
   un mensaje de registro. Este mensaje de registro incluye el @e(valor de
   panico), que suele ser un mensaje de error de algun tipo, y, para cada
   goroutine, un @e(seguimiento de pila) que muestra la pila de llamadas a
   funciones que estaban activas en el momento del panico. Este mensaje de
   registro a menudo tiene suficiente informacion para diagnosticar la causa
   raiz del problema sin ejecutar el programa de nuevo, por lo que siempre debe
   incluirse en un informe de error acerca de un programa de panico.

   No todos los panicos provienen del tiempo de ejecucion. La funcion nativa
   @c(panic) se puede llamar directamente; acepta cualquier valor como
   argumento. Un panico es a menudo lo mejor que puede hacer cuando ocurre
   alguna situacion @"(imposible), por ejemplo, la ejecucion llega a un caso que
   logicamente, no puede suceder:

   ..src > go
     switch s := suit(drawCard()); s {
     case "Spades":   // ...
     case "Hearts":   // ...
     case "Diamonds": // ...
     case "Clubs":    // ...
     default:
       panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
     }
   < src..

   Es una buena practica afirmar que las precondiciones de una funcion se
   mantienen, pero esto puede hacerse facilmente en exceso. A menos que pueda
   proporcionar un mensaje de error mas informativo o detectar un error antes,
   no tiene sentido afirmar una condicion que el tiempo de ejecucion comprobara
   por usted.

   ..src > go
     func Reset(x *Buffer) {
       if x == nil {
         panic("x is nil") // innecesario!
       }
       x.elements = nil
     }
   < src..

   Aunque el mecanismo de panico de Go se parece a las excepciones de otros
   lenguajes, las situaciones en las que se utiliza el panico son muy
   diferentes. Puesto que un panico hace que el programa se bloquee,
   generalmente se usa para errores graves, como una inconsistencia logica en el
   programa; Los programadores diligentes consideran cualquier accidente como
   prueba de un error en su codigo. En un programa robusto, los errores
   @"(esperados), el tipo que surgen de una entrada incorrecta, mala
   configuracion, o un defecto de E/S, deben manejarse con gracia; se tratan
   mejor con el uso de valores de @c(error).

   Considere la funcion @c(regexp.Compile), que compila una expresion regular en
   una forma eficiente para la coincidencia. Se devuelve un @c(error) si se
   llama con un patron mal formado, pero la comprobacion de este error es
   innecesaria y onerosa si la persona que llama sabe que una llamada en
   particular no puede fallar. En tales casos, es razonable que el llamador
   maneje un error con un panico, ya que se cree que es imposible.

   Como la mayoria de las expresiones regulares son literales en el codigo
   fuente del programa, la paquete @c(regexp) proporciona una funcion de
   envoltura @c(regexp.MustCompile) que hace esta comprobacion:

   ..src > go
     package regexp

     func Compile(expr string) (*Regexp, error) { /* ... */ }

     func MustCompile(expr string) *Regexp {
       re, err := Compile(expr)
       if err != nil {
         panic(err)
       }
       return re
     }
   < src..

   La funcion de envoltura hace que sea conveniente para los clientes
   inicializar una variable de nivel de paquete con una expresion regular
   compilada, como esta:

   ..src > go
     var httpSchemeRE = regexp.MustCompile(`^https?:`) // "http:" or "https:"
   < src..

   Por supuesto, @c(MustCompile) no debe ser llamada con valores de entrada no
   confiables. El prefijo @c(Must) es una convencion de nomenclatura comun para
   este tipo de funciones, como @c(template.Must) en la @l(#Seccion 4.6).

   Cuando se produce una situacion de panico, todas las funciones diferidas se
   ejecutan en orden inverso, comenzando con las funciones en lo mas alto de la
   pila y procediendo hasta @c(main), como muestra el siguiente programa:

   ..figure > @l(gopl.io/ch5/defer1/defer.go<>gopl.io/ch5/defer1)

     ..src > go
       func main() {
         f(3)
       }

       func f(x int) {
         fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
         defer fmt.Printf("defer %d\n", x)
         f(x - 1)
       }
     < src..

   Cuando se ejecuta, el programa imprime lo siguiente en la salida estandar:

   ..pre >
     f(3)
     f(2)
     f(1)
     defer 1
     defer 2
     defer 3

   Un panico se produce durante la llamada a @c[f(0)], provocando que se
   ejecuten las tres llamadas diferidas a @c(fmt.Printf). A continuacion, el
   tiempo de ejecucion finaliza el programa, imprimiendo el mensaje de panico y
   un volcado de pila en el flujo de error estandar (simplificado para mayor
   claridad):

   ..pre >
      panic: runtime error: integer divide by zero
      main.f(0)
              src/gopl.io/ch5/defer1/defer.go:14
      main.f(1)
              src/gopl.io/ch5/defer1/defer.go:16
      main.f(2)
              src/gopl.io/ch5/defer1/defer.go:16

      main.f(3)
              src/gopl.io/ch5/defer1/defer.go:16
      main.main()
              src/gopl.io/ch5/defer1/defer.go:10
   < pre..

   Como veremos mas adelante, es posible que una funcion se recupere de un
   panico para que no termine el programa.

   Por propositod de diagnostico, el paquete @c(runtime) permite al programador
   volcar la pila utilizando la misma maquinaria. Al diferir una llamada a
   @c(printStack) en @c(main),

   ..figure > @l(gopl.io/ch5/defer2/defer.go<>gopl.io/ch5/defer2)

     ..src > go
       func main() {
         defer printStack()
         f(3)
       }

       func printStack() {
         var buf [4096]byte
         n := runtime.Stack(buf[:], false)
         os.Stdout.Write(buf[:n])
       }
     < src..


   El siguiente texto adicional (simplificado de nuevo para mayor claridad) se
   imprime a la salida estandar:

   ..pre >
      goroutine 1 [running]:
      main.printStack()
        src/gopl.io/ch5/defer2/defer.go:20
      main.f(0)
        src/gopl.io/ch5/defer2/defer.go:27
      main.f(1)
        src/gopl.io/ch5/defer2/defer.go:29
      main.f(2)
        src/gopl.io/ch5/defer2/defer.go:29
      main.f(3)
        src/gopl.io/ch5/defer2/defer.go:29
      main.main()
        src/gopl.io/ch5/defer2/defer.go:15
   < pre..


   Los lectores familiarizados con excepciones en otros lenguajes pueden
   sorprenderse de que @c(runtime.Stack) pueda imprimir informacion sobre
   funciones que parecen haber sido @"(desenrolladas). El Mecanismo de panico de
   Go ejecuta las funciones diferidos antes de desenrollar la pila.

** Seccion 5.10 <> Recover

   Desistir es generalmente la respuesta correcta a un panico, pero no
   siempre. Podria ser posible recuperarse de alguna manera, o al menos limpiar
   el lio antes de marcharse. Por ejemplo, un servidor web que encuentra un
   problema inesperado podria cerrar la conexion en lugar de dejar al cliente
   colgado y, durante el desarrollo, podria informar el error al cliente
   tambien.

   Si la funcion nativa @c(recover) se llama dentro de una funcion diferida y la
   funcion que contiene la sentencia @c(defer) es presa del panico, @c(recover)
   termina el actual estado de panico y devuelve el valor de panico. La funcion
   que estaba en panico no continua donde lo dejo pero devuelve normalmente. Si
   @c(recover) se llama en cualquier otro momento, no tiene ningun efecto y
   devuelve @c(nil).

   Para ilustrar, considere el desarrollo de un analizador para un
   lenguaje. Incluso cuando parece estar funcionando bien, dada la complejidad
   de su trabajo, los bichos todavia pueden acechar en esquinas
   oscuras. Podriamos preferir que, en lugar de fallar, el analizador convierta
   estos panicos en errores comunes de analisis, quizas con un mensaje extra
   exhortando al usuario a presentar un informe de error.

   ..src > go
     func Parse(input string) (s *Syntax, err error) {
       defer func() {
         if p := recover(); p != nil {
           err = fmt.Errorf("internal error: %v", p)
         }
       }()
       // ...analizador...
     }
   < src..

   La funcion diferida en @c(Parse) se recupera de una situacion de panico,
   utilizando el valor de panico para construir un mensaje de error; una version
   mas elegante podria incluir toda la pila de llamadas usando @c(runtime.Stack).
   Luego la funcion diferida, asigna @c(err) al resultado, que se devuelve al
   llamador.

   La recuperacion indiscriminada de los panicos es una practica dudosa porque
   el estado de las variables de un paquete despues de un panico raramente esta
   bien definido o documentado. Quizas una actualizacion critica de una
   estructura de datos estaba incompleta, se abrio una conexion de archivo o de
   red pero no se cerro o se obtuvo un bloqueo pero no se libero. Ademas, al
   reemplazar un bloqueo con, por ejemplo, una linea en un archivo de registro,
   la recuperacion indiscriminada puede hacer que los errores pasen
   desapercibidos.

   La recuperacion de un panico dentro del mismo paquete puede ayudar a
   simplificar el manejo de errores complejos o inesperados, pero como regla
   general, no debe intentar recuperarse del panico de otro paquete. Las APIs
   publicas deben informar de fallos como @c(errores). Del mismo modo, no debe
   recuperarse de un panico que puede pasar a traves de una funcion que no
   mantiene, como una llamador de devolucion de lllamada, ya que no puede
   razonar sobre su seguridad.

   Por ejemplo, el paquete @c(net/http) proporciona un servidor web que envia
   las solicitudes entrantes a funciones de controlador proporcionados por el
   usuario. En lugar de permitir que un panico en uno de estos controladores
   elimine el proceso, el servidor llama a @c(recover), imprime un seguimiento
   de la pila, y sigue atendiendo. Esto es conveniente en la practica, pero se
   corre el riesgo de perder recursos o dejar al manejador fallido en un estado
   no especificado que podria conducir a otros problemas.

   Por todas las razones anteriores, es mas seguro recuperarse selectivamente si
   es necesario. En otras palabras, recuperar solo de los panicos que estaban
   destinados a ser recuperados, lo que deberia ser raro. Esta intencion puede
   ser codificado mediante el uso de un tipo distinto, sin exportar para el
   valor de panico y probar si el valor devuelto por @c(recover) tiene ese
   tipo. (Veremos una manera de hacer esto en el siguiente ejemplo.) Si es asi,
   el informamos el panico como un error ordinario; si no, que llamamos a
   @c(panic) con el mismo valor para reanudar el estado de panico.

   El ejemplo siguiente es una variacion sobre el programa @$(title) que informa
   de un error si el documento HTML contiene multiples elementos @c(<title>). Si
   es asi, se aborta la recursividad llamando a @c(panic) con un valor del tipo
   especial @c(bailout).

   ..figure > @l(gopl.io/ch5/title3/title.go<>gopl.io/ch5/title3)

     ..src > go
       // soleTitle regresa el siguiente texto del primer elemento title no vacio
       // en doc, y un error si no existiera exactamente uno.
       func soleTitle(doc *html.Node) (title string, err error) {
         type bailout struct{}

         defer func() {
           switch p := recover(); p {
           case nil:
             // sin panico
           case bailout{}:
             // panico "esperado"
             err = fmt.Errorf("multiple title elements")
           default:
             panic(p) // panico inersperado; continuar el panico
           }
         }()

         // Bail out de recursion si encontramos mas de un titulo no vacio.
         forEachNode(doc, func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "title" &&
             n.FirstChild != nil {
             if title != "" {
               panic(bailout{}) // multiples elementos titulo
             }
             title = n.FirstChild.Data
           }
         }, nil)
         if title == "" {
           return "", fmt.Errorf("no title element")
         }
         return title, nil
       }
     < src..


   La funcion diferida que llama a @c(recover), comprueba el valor de panico, e
   informa de un error ordinario si el valor era @c(bailout{}). Todos los demas
   valores no nulos indican un panico inesperados, en cuyo caso el controlador
   llama a @c(panic) con ese valor, deshace el efecto de @c(recover) y reanuda
   el estado original de panico. (Este ejemplo viola algo nuestro consejo acerca
   de no usar panicos para errores @"(esperados), pero proporciona una
   ilustracion compacta de la mecanica).

   De algunas condiciones no hay recuperacion. La falta de memoria, por ejemplo,
   provoca en tiempo de ejecucion que el programa termine con un error grave.

   @b(Ejercicio 5.19): Utilice @c(panic) y @c(recover) para escribir una funcion
   que no contenga ninguna sentencia @c(return) y devuelva un valor distinto de
   cero.

* Capitulo 6 <> Metodos

  Desde principios de los noventa, la programacion orientada a objetos (OOP) ha
  sido el paradigma de programacion dominante en la industria y la educacion, y
  casi todos las lenguajes ampliamente utilizadas desarrolladas desde entonces
  han incluido el soporte para ello. Go no es una excepcion.

  Aunque no existe una definicion universalmente aceptada de la programacion
  orientada a objetos, para nuestros propositos, un @e(objeto) es simplemente un
  valor o variable que tiene metodos, y un metodo es una funcion asociada a un
  tipo particular. Un programa orientado a objetos es aquel que utiliza metodos
  para expresar las propiedades y operaciones de cada estructura de datos de
  modo que los clientes no necesitan acceder directamente a la representacion
  del objeto.

  En los capitulos anteriores, hemos hecho uso regular de metodos de la libreria
  estandar, como el metodo @c(Seconds) del tipo @c(time.Duration):

  ..src > go
    const day = 24 * time.Hour
    fmt.Println(day.Seconds()) // "86400"
  < src..

  y definimos un metodo de propia en la @l(#Seccion 2.5), una metodo @c(String)
  para el Tipo @c(Celsius):

  ..src > go
    func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
  < src..

  En este capitulo, el primero de dos en la programacion orientada a objetos,
  mostraremos como definir y utilizar metodos de manera eficaz. Tambien vamos a
  cubrir dos principios fundamentales de la programacion orientada a objetos,
  encapsulacion y composicion.

** Seccion 6.1 <> Declaracion de Metodos

   Se declara un metodo con una variante de la declaracion de funcion ordinaria
   en la que aparece un parametro extra antes del nombre de la funcion. El
   parametro asigna la funcion al tipo de ese parametro.

   Vamos a escribir nuestro primer metodo en un simple paquete de geometria
   plana:

   ..figure > @l(gopl.io/ch6/geometry/geometry.go<>gopl.io/ch6/geometry)

     ..src > go
       package geometria

       import "math"

       type Punto struct{ X, Y float64 }

       // funcion tradicional
       func Distancia(p, q Punto) float64 {
         return math.Hypot(q.X-p.X, q.Y-p.Y)
       }

       // lo mismo, pero como un metodo del tipo Punto
       func (p Punto) Distancia(q Punto) float64 {
         return math.Hypot(q.X-p.X, q.Y-p.Y)
       }
     < src..

   El parametro extra @c(p) se denomina el @e(receptor) del metodo, un legado de
   los primeros lenguajes orientados a objetos que describen la llamada a un
   metodo como @"(el envio de un mensaje a un objeto).

   En Go, no utilizamos un nombre especial como @c(this) o @c(self) para el
   receptor; Elegimos los nombres de los receptores tal como lo hariamos para
   cualquier otro parametro. Pusto que el nombre del receptor se utilizara con
   frecuencia, es una buena idea elegir algo corto y ser coherente entre los
   metodos. Una opcion comun es la primer letra del nombre del tipo, como @c(p)
   por @c(Point).

   En una llamada al metodo, el argumento del receptor aparece antes del nombre
   del metodo. Esto es paralelo a la declaracion, en la que el parametro del
   receptor aparece antes del nombre del metodo.

   ..src > go
     p := Punto{1, 2}
     q := Punto{4, 6}
     fmt.Println(Distancia(p, q)) // "5", llamada a funcion
     fmt.Println(p.Distancia(q))  // "5", llamada a metodo
   < src..

   No hay conflicto entre las dos declaraciones de funcion llamadas @c(Distancia)
   anteriores. La primera declara una funcion de nivel paquete llamada
   @c(geometria.Distancia). La segunda declara un procedimiento del tipo @c(Punto), por
   lo que su nombre es @c(Punto.Distancia).

   La expresion @c(p.Distancia) se denomina un @e(selector), porque selecciona
   el metodo apropiado @c(Distancia) para el receptor @c(p) de tipo @c(Punto).
   Los selectores tambien se utilizan para seleccionar los campos de un tipo
   estructura, como en @c(p.X). Dado que los metodos y campos habitan el mismo
   espacio de nombres, si declara un metodo @c(X) para el tipo de estructura
   @c(Punto) seria ambiguo y el compilador lo rechazara.

   Debido a que cada tipo tiene su propio espacio de nombres para los metodos,
   podemos usar el nombre @c(Distancia) para otros metodos, siempre y cuando
   pertenecen a diferentes tipos. Vamos a definir un tipo @c(Ruta) que
   representa una secuencia de segmentos de linea y a darle un metodo
   @c(Distancia) tambien.

   ..src > go
     // Una Ruta es un caminoA que conecta los puntos con lineas reactas.
     type Ruta []Punto

     // Distancia devuelve la distancia recorrida a lo largo de la Ruta.
     func (ruta Ruta) Distancia() float64 {
       sum := 0.0
       for i := range ruta {
         if i > 0 {
           sum += ruta[i-1].Distancia(ruta[i])
         }
       }
       return sum
     }
   < src..

   @c(Ruta) es un tipo de slice con nombre, no un tipo de estructura como
   @c(Punto), sin embargo, podemos definir metodos para el. Al permitir que los
   metodos se asocien con cualquier tipo, Go es diferente de muchos otros
   lenguajes orientados a objetos. A menudo es conveniente definir
   comportamientos adicionales para tipos simples como numeros, cadenas, slices,
   mapas, y a veces, incluso funciones. Los metodos pueden ser declarados en
   cualquier tipo con nombre definido en el mismo paquete, siempre y cuando su
   tipo subyacente no sea un puntero ni una interfaz.

   Las dos metodos @c(Distancia) tienen diferentes tipos. No estan relacionados
   entre si en absoluto, aunque @c(Ruta.Distancia) utiliza a @c(Punto.Distancia)
   internamente para calcular la longitud de cada segmento que une los puntos
   adyacentes.

   Vamos a llamar al nuevo metodo para calcular el perimetro de un triangulo
   rectangulo:

   ..cols >

     ..src > go
       perim := Ruta{
         {1, 1},
         {5, 1},
         {5, 4},
         {1, 1},
       }
       fmt.Println(perim.Distancia()) // "12"
     < src..

     ::

     ..img > img/perim.Distance.jpg


   En las dos llamadas anterior a metodos con nombre @c(Distancia), el
   compilador determina que funcion debe llamar basandose tanto en el nombre del
   metodo y el tipo de receptor. En el primero, @c(ruta[i-1]) tiene tipo
   @c(Punto), asi que se llama a @c(Punto.Distancia); en el segundo, @c(perim)
   tiene el tipo Ruta, por lo que se llama a @c(Ruta.Distancia).

   Todos los metodos de un tipo dado deben tener nombres unicos, pero diferentes
   tipos pueden utilizar el mismo nombre para un metodo, al igual que los
   metodos @c(Distancia) para @c(Punto) y @c(Ruta); no hay necesidad de
   calificar los nombres de funcion (por ejemplo, @c(RutaDistancia)) para
   eliminar la ambigüedad. Aqui vemos el primer beneficio al usar metodos sobre
   funciones ordinarias: los nombres de metodos pueden ser mas cortos. El
   beneficio se magnifica para las llamadas que se originan fuera del paquete,
   ya que pueden utilizar el nombre mas corto y omitir el nombre del paquete:

   ..src > go
     import "gopl.io/ch6/geometry"

     perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}}
     fmt.Println(geometry.PathDistance(perim)) // "12", funcion independiente
     fmt.Println(perim.Distance())             // "12", metodo de geometry.Path
   < src..

** Seccion 6.2 <> Metodos con un Receptor de Puntero

   Ya que llamar a una funcion crea una copia de cada valor de argumento, si una
   funcion necesita actualizar una variable, o si un argumento es tan grande que
   queremos evitar copiarlo, debemos pasar la direccion de la variable usando un
   puntero. Lo mismo ocurre con los metodos que necesitan actualizar la variable
   del receptor: los adjudicamos al tipo como puntero, como @c(*Point).

   ..src > go
     func (p *Point) ScaleBy(factor float64) {
       p.X *= factor
       p.Y *= factor
     }
   < src..

   El nombre de este metodo es @c[(*Point).ScaleBy]. Los parentesis son necesarios;
   sin ellos, la expresion se analiza como @c[*(Point.ScaleBy)].

   En un programa realista, la convencion dicta que si cualquier metodo de
   @c(Point) tiene un receptor puntero, entonces todos los metodos de @c(Point)
   deben tener un receptor puntero, incluso los que no lo necesitan
   estrictamente. Hemos roto esta regla para @c(Point) de modo que podamos
   mostrar ambos tipos de metodo.

   Tipos con nombre (@c(Point)) y punteros a ellos @c[(*Point)] son los unicos
   tipos que pueden aparecer en una declaracion receptor. Ademas, para evitar
   ambigüedades, las declaraciones de metodos no estan permitidas en tipos con
   nombre que son ellos mismos tipos de puntero:

   ..src > go
     type P *int
     func (P) f() { /* ... */ } // error de compilacion: tipo de receptor invalido
   < src..

   El metodo @c[(*Point).ScaleBy] se puede llamar al proporcionar un receptor
   @c(*Point), asi:

   ..src > go
     r := &Point{1, 2}
     r.ScaleBy(2)
     fmt.Println(*r) // "{2, 4}"
   < src..

   o asi:

   ..src > go
     p := Point{1, 2}
     pptr := &p
     pptr.ScaleBy(2)
     fmt.Println(p) // "{2, 4}"
   < src..

   o asi:

   ..src > go
     p := Point{1, 2}
     (&p).ScaleBy(2)
     fmt.Println(p) // "{2, 4}"
   < src..

   Pero los dos ultimos casos son desagradables. Afortunadamente, el lenguaje
   nos ayuda aqui. Si el receptor @c(p) es una variable de tipo @c(Point), pero
   el metodo requiere un receptor @c(*Point), podemos emplear esta abreviatura:

   ..src > go
     p.ScaleBy(2)
   < src..

   y el compilador realizara un @c(&p) implicito sobre la variable. Esto solo
   funciona para las variables, incluyendo los campos de la estructura como
   @c(p.X) y elementos de la arreglo o slice como @c(perim[0]). No podemos
   llamar a un metodo @c(*Point) en un receptor @c(Point) no direccionable,
   porque no hay manera de obtener la direccion de un valor temporal.

   ..src > go
     Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
   < src..

   Sin embargo, podemos llamar a un metodo @c(Point) como @c(Point.Distance) con
   un receptor @c(*Point), porque hay una manera de obtener el valor de la
   direccion: solo tiene que cargar el valor apuntado por el receptor. El
   compilador inserta una operacion @c(*) implicita por nosotros. Estas dos
   llamadas de funcion son equivalentes:

   ..src > go
     pptr.Distance(q)
     (*pptr).Distance(q)
   < src..

   Vamos a resumir estos tres casos de nuevo, ya que son un punto frecuente de
   confusion. En cada expresion de llamada de metodo valida, exactamente una de
   estas tres sentencias es verdadera.

   O bien el argumento receptor tiene el mismo tipo que el parametro del
   receptor, por ejemplo ambos tienen tipo @c(T) o ambos tienen tipo @c(*T):

   ..src > go
     Point{1, 2}.Distance(q) //  Point
     pptr.ScaleBy(2)         // *Point
   < src..

   O el argumento de receptor es una variable de tipo @c(T) y el parametro receptor
   tiene tipo @c(*T). El compilador toma implicitamente la direccion de la
   variable:

   ..src > go
     p.ScaleBy(2) // implicit (&p)
   < src..

   O el argumento receptor tiene tipo @c(*T) y el parametro receptor tiene tipo
   @c(T). El compilador dereferencia implicitamente al receptor, en otras
   palabras, carga el valor:

   ..src > go
     pptr.Distance(q) // implicit (*pptr)
   < src..

   Si todos los metodos de un tipo con nombre @c(T) tienen un tipo de receptor
   @c(T) en si (no @c(*T)), es seguro copiar las instancias de ese tipo; Llamar
   a cualquiera de sus metodos necesariamente hace una copia. Por ejemplo, los
   valores @c(time.Duration) se copian liberalmente, incluyendo como argumentos
   a las funciones. Pero si cualquier metodo tiene un receptor de puntero, se
   debe evitar copiar instancas de @c(T), ya que hacerlo puede violar
   invariantes internos. Por ejemplo, copiar una instancia de @c(bytes.Buffer)
   haria que el original y la copia como alias (@l(#Seccion 2.3.2<>§2.3.2))
   tubieran el mismo arreglo subyacente de bytes. Las llamadas de metodo
   subsiguientes tendrian efectos impredecibles.

*** Seccion 6.2.1 <> Nil es un Valor de Receptor Valido

    Al igual que algunas funciones permiten punteros nulos como argumentos,
    tambien lo hacen algunos metodos para su receptor, especialmente si @c(nil)
    es un valor cero significativo del tipo, al igual que con los mapas y los
    slices. En esta sencilla lista enlazada de numeros enteros, @c(nil)
    representa la lista vacia:

    ..src > go
      // Un IntList es una lista enlazada de enteros.
      // Un nil *IntList representa la lista vacia.
      type IntList struct {
        Value int
        Tail *IntList
      }

      // Sum regresa la suma de la lista de elementos.
      func (list *IntList) Sum() int {
        if list == nil {
          return 0
        }
        return list.Value + list.Tail.Sum()
      }
    < src..

    Cuando se define un tipo cuyos metodos permiten @c(nil) como valor receptor,
    vale la pena señalar esto explicitamente en su comentario de documentacion,
    como lo hicimos arriba.

    Aqui esta parte de la definicion del tipo @c(Values) del paquete @c(net/url):

    ..figure > @c(net/url)

      ..src > go
        package url

        // Values map asigna clave de cadena a una lista de valores.
        type Values map[string][]string

        // Get devuelve el primer valor asociado con la clave dada,
        // o "" si no hay nada.
        func (v Values) Get(key string) string {
          if vs := v[key]; len(vs) > 0 {
            return vs[0]
          }
          return ""
        }

        // Add agrega el valor a la clave.
        // Se añade a cualquier valor existente asociado con la clave.
        func (v Values) Add(key, value string) {
          v[key] = append(v[key], value)
        }
      < src..


    Expone su representacion como un mapa, pero tambien proporciona metodos para
    simplificar el acceso al mapa, cuyos valores son slices de cadenas–es un
    @e(mapa multiple). Sus clientes pueden utilizar sus operadores intrinsecos
    (@c(make), slice literales, @c(m[key]), etc.), o sus metodos, o ambos, como
    prefiera:

    ..figure > @l(gopl.io/ch6/urlvalues/main.go<>gopl.io/ch6/urlvalues)

      ..src > go
        m := url.Values{"lang": {"en"}} // construccion directa
        m.Add("item", "1")
        m.Add("item", "2")

        fmt.Println(m.Get("lang")) // "en"
        fmt.Println(m.Get("q"))    // ""
        fmt.Println(m.Get("item")) // "1"      (primer valor)
        fmt.Println(m["item"])     // "[1 2]"  (acceso directo al mapa)

        m = nil
        fmt.Println(m.Get("item")) // ""
        m.Add("item", "3")         // panico: asignacion a ingresar en un mapa nil
      < src..


    En la llamada final a @c(Get), el receptor @c(nil) se comporta como un mapa
    vacio. Podriamos haberlo escrito como @c[Values(nil).Get("item")], pero
    @c[nil.Get("item")] no se compilara porque el tipo @c(nil) no se ha
    determinado. Por el contrario, la llamada final a @c(Add) proboca un panico,
    ya que trata de actualizar un mapa nil.

    Debido a que @c(url.Values) es un tipo de mapa y un mapa se refiere a sus
    pares clave/valor indirectamente, las actualizaciones y supresiones que
    @c(url.Values.Add) hace a los elementos del mapa son visibles para el
    llamador. Sin embargo, al igual que con las funciones ordinarias, los
    cambios que un metodo hace a la propia referencia, como establecerlo en
    @c(nil) o hacer que se refiera a una estructura de mapa de datos diferente,
    no se reflejaran en el llamador.

** Seccion 6.3 <> Composicion de Tipos por Estructuras Enbebidas

   Considere el tipo @c(ColoredPoint):

   ..figure > @l(gopl.io/ch6/coloredpoint/main.go<>gopl.io/ch6/coloredpoint)

     ..src > go
       import "image/color"

       type Point struct{ X, Y float64 }

       type ColoredPoint struct {
         Point
         Color color.RGBA
       }
     < src..


   Podriamos haber definido @c(ColoredPoint) como una estructura de tres campos,
   pero en su lugar, @e(enbebimos) un @c(Point) para proporcionar los campos
   @c(X) e @c(Y). Como vimos en la @l(#Seccion 4.4.3), la incrustacion nos
   permite tomar un atajo sintactico para definir un tipo @c(ColoredPoint) que
   contiene todos los campos de @c(Point), ademas de un poco mas. Si queremos,
   podemos seleccionar los campos de @c(ColoredPoint) que fueron aportados por
   el @c(Point) embebido sin mencionar a @c(Point):

   ..src > go
     var cp ColoredPoint
     cp.X = 1
     fmt.Println(cp.Point.X) // "1"
     cp.Point.Y = 2
     fmt.Println(cp.Y)       // "2"
   < src..

   Un mecanismo similar se aplica a los @e(metodos) de @c(Point). Podemos llamar
   a los metodos del enbebido @c(Point) utilizando un receptor de tipo
   @c(ColoredPoint), a pesar de que @c(ColoredPoint) no tiene metodos
   declarados:

   ..src > go
     red := color.RGBA{255, 0, 0, 255}
     blue := color.RGBA{0, 0, 255, 255}
     var p = ColoredPoint{Point{1, 1}, red}
     var q = ColoredPoint{Point{5, 4}, blue}
     fmt.Println(p.Distance(q.Point)) // "5"
     p.ScaleBy(2)
     q.ScaleBy(2)
     fmt.Println(p.Distance(q.Point)) // "10"
   < src..

   Los metodos de @c(Point) han sido @e(promovidos) a @c(ColoredPoint). De esta
   manera, la incrustacion permite tipos complejos con muchos metodos que se
   construiran por la composicion de varios campos, cada uno proporcionando unos
   pocos metodos.

   Los lectores familiarizados con lenguajes orientados a objetos basados en
   clases pueden ser tentados a ver @c(Point) como una clase base y
   @c(ColoredPoint) como una subclase o clase derivada, o a interpretar la
   relacion entre estos tipos como si @c(ColoredPoint) @"(es un) @c(Point). Pero
   eso seria un error. Observe las llamadas a @c(Distance) arriba. @c(Distance)
   tiene un parametro de tipo @c(Point), ya que @c(q) no es un @c(Point), asi
   que aunque @c(q) tiene un campo enbebido de ese tipo, debemos seleccionarlo
   explicitamente. Si intenta pasar @c(q) seria un error:

   ..src > go
     p.Distance(q) // error de compilacion: no se puede utilizar q (ColoredPoint) como Point
   < src..

   Un @c(ColoredPoint) no es un @c(Point), pero @"(tiene un) @c(Point), y tiene
   dos metodos adicionales @c(Distance) y @c(ScaleBy) promocionados desde
   @c(Point). Si prefiere pensar en terminos de implementacion, el campo
   enbebido instruye al compilador a generar metodos de envoltura adicionales
   que delegan en los metodos declarados, equivalentes a los siguientes:

   ..src > go
     func (p ColoredPoint) Distance(q Point) float64 {
       return p.Point.Distance(q)
     }

     func (p *ColoredPoint) ScaleBy(factor float64) {
       p.Point.ScaleBy(factor)
     }
   < src..

   Cuando @c(Point.Distance) es llamado por el primero de estos metodos de
   envoltura, su valor receptor es @c(p.Point), no @c(p), y no hay manera de que
   el metodo accededa a @c(ColoredPoint) en el que @c(Point) esta enbebido.

   El tipo de un campo anonimo puede ser un @e(puntero) a un tipo con nombre, en
   cuyo caso los campos y metodos se promueven indirectamente del puntero al
   objeto. Agregar otro nivel de indireccion nos permite compartir estructuras
   comunes y variar las relaciones entre los objetos dinamicamente. La
   declaracion de @c(ColoredPoint) a continuacion incorpora un @c(*Point):

   ..src > go
     type ColoredPoint struct {
       *Point
       Color color.RGBA
     }

     p := ColoredPoint{&Point{1, 1}, red}
     q := ColoredPoint{&Point{5, 4}, blue}
     fmt.Println(p.Distance(*q.Point)) // "5"
     q.Point = p.Point                 // ahora p y q comparten el mismo Point
     p.ScaleBy(2)
     fmt.Println(*p.Point, *q.Point)   // "{2 2} {2 2}"
   < src..

   Un tipo de estructura puede tener mas de un campo anonimo. Si hubieramos
   declarado @c(ColoredPoint) como

   ..src > go
     type ColoredPoint struct {
       Point
       color.RGBA
     }
   < src..

   entonces un valor de este tipo tendria todos los metodos de @c(Point), todos
   los metodos de @c(RGBA), y cualesquiera otros metodos declarados en
   @c(ColoredPoint) directamente. Cuando el compilador resuelve un selector como
   @c(p.ScaleBy) a un metodo, primero se busca un metodo llamado directamente
   declarada @c(ScaleBy), luego, para los metodos promovidos de campos
   incrustados en @c(ColoredPoint), luego, para los metodos promovidos dos veces
   de campos incrustados dentro @c(Point) y @c(RGBA), y asi sucesivamente. El
   compilador informa de un error si el selector es ambiguo porque se
   promocionaron dos metodos desde el mismo rango.

   Los metodos pueden ser declaradas solo en tipos con nombre (como @c(Point)) y
   punteros a ellos (@c(*Point)), pero gracias al embedido, es posible y, a
   veces util que los tipos de estructura @e(sin nombre) tambien tengan metodos.

   Aqui hay un buen truco para ilustrarlo. Este ejemplo muestra parte de una
   cache simple implementada usando dos variables a nivel de paquete, un mutex
   (@l(#Seccion 9.2<>§9.2)) y el mapa que lo protege:

   ..src > go
     var (
       mu sync.Mutex // protege a mapping
       mapping = make(map[string]string)
     )

     func Lookup(key string) string {
       mu.Lock()
       v := mapping[key]
       mu.Unlock()
       return v
     }
   < src..

   La version de abajo es funcionalmente equivalente pero agrupa a las dos
   variables relacionadas en una unica variable de nivel de paquete, @c(cache):

   ..src > go
     var cache = struct {
       sync.Mutex
       mapping map[string]string
     } {
       mapping: make(map[string]string),
     }

     func Lookup(key string) string {
       cache.Lock()
       v := cache.mapping[key]
       cache.Unlock()
       return v
     }
   < src..

   La nueva variable da nombres mas expresivos a las variables relacionadas con
   la @c(cache), y debido a que el campo @c(sync.Mutex) esta enbebido dentro de
   ella, su metodos @c(Lock) y @c(Unlock) se promueven al tipo de estructura sin
   nombre, lo que nos permite bloquear la @c(cache) con una sintaxis auto
   explicativa.

** Seccion 6.4 <> Valores y Expresiones de los Metodos

   Normalmente seleccionamos y llamamos a un metodo en la misma expresion, como
   en @c[p.Distance()], pero es posible separar estas dos operaciones. El
   selector @c(p.Distance) produce un @e(valor de metodo), una funcion une un
   metodo (@c[Point.Distance]) a un valor de receptor especifico @c(p). Esta
   funcion puede entonces ser invocada sin un valor de receptor; Solo necesita
   los argumentos del no receptor.

   ..src > go
     p := Point{1, 2}
     q := Point{4, 6}

     distanceFromP := p.Distance        // volor del metodo
     fmt.Println(distanceFromP(q))      // "5"
     var origin Point                   // {0, 0}
     fmt.Println(distanceFromP(origin)) // "2.23606797749979", √5

     scaleP := p.ScaleBy // valor del metodo
     scaleP(2)           // p se vuelve (2, 4)
     scaleP(3)           //       luego (6, 12)
     scaleP(10)          //       luego (60, 120)
   < src..

   Los valores de metodo son utiles cuando la API de un paquete solicita un
   valor de funcion y el comportamiento deseado del cliente para esa funcion es
   llamar a un metodo en un receptor especifico. Por ejemplo, la funcion
   @c(time.AfterFunc) llama a un valor de funcion despues de un retardo
   especificado. Este programa lo utiliza para lanzar el cohete @c(r) despues de
   10 segundos:

   ..src > go
     type Rocket struct { /* ... */ }
     func (r *Rocket) Launch() { /* ... */ }

     r := new(Rocket)
     time.AfterFunc(10 * time.Second, func() { r.Launch() })
   < src..

   La sintaxis del valor del metodo es mas corta:

   ..src > go
     time.AfterFunc(10 * time.Second, r.Launch)
   < src..

   En relacion con el valor del metodo es la @e(expresion del metodo). Al llamar
   a un metodo, a diferencia de una funcion ordinaria, debemos suministrar al
   receptor de una manera especial usando la sintaxis del selector. Una
   expresion de metodo, escrita @c(T.f) o @c[(*T).f] donde @c(T) es un tipo,
   produce un valor de funcion con un primer parametro tomando el lugar del
   receptor, por lo que puede ser llamado de la manera habitual.

   ..src > go
     p := Point{1, 2}
     q := Point{4, 6}

     distance := Point.Distance   // expresion del metodo
     fmt.Println(distance(p, q))  // "5"
     fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

     scale := (*Point).ScaleBy
     scale(&p, 2)
     fmt.Println(p)            // "{2 4}"
     fmt.Printf("%T\n", scale) // "func(*Point, float64)"
   < src..

   Las expresiones de metodo pueden ser utiles cuando se necesita un valor para
   representar una eleccion entre varios metodos pertenecientes al mismo tipo
   para que pueda llamar al metodo elegido con muchos receptores diferentes. En
   el siguiente ejemplo, la variable @c(op) representa el metodo de suma o resta
   del tipo @c(Point), y @c(Path.TranslateBy) lo llama para cada punto en
   @c(Path):

   ..src > go
     type Point struct{ X, Y float64 }

     func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
     func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

     type Path []Point

     func (path Path) TranslateBy(offset Point, add bool) {
       var op func(p, q Point) Point
       if add {
         op = Point.Add
       } else {
         op = Point.Sub
       }
       for i := range path {
         // llama en cada path[i].Add(offset) o path[i].Sub(offset).
         path[i] = op(path[i], offset)
       }
     }
   < src..

** Seccion 6.5 <> Ejemplo: Tipo de Vector de Bits

   Los conjuntos en Go se implementan generalmente como un @c(map[T]bool), donde
   @c(T) es el tipo del elemento. Un conjunto representado por un mapa es muy
   flexible pero, para ciertos problemas, una representacion especializada puede
   superarla. Por ejemplo, en dominios tales como el analisis de flujo de datos
   donde los elementos del conjunto son pequeños numeros enteros no negativos,
   los conjuntos tienen muchos elementos, y las operaciones de conjunto como
   union e interseccion son comunes, un vector de bits es ideal.

   Un vector de bits utiliza una slice de valores o @"(palabras) de enteros sin
   signo, cada bit de los cuales representa un posible elemento del conjunto. El
   conjunto contiene @c(i) si se establece el enesimo bit. El siguiente programa
   muestra un tipo de vector de bits simple con tres metodos:

   ..figure > @l(gopl.io/ch6/intset/intset.go<>gopl.io/ch6/intset)

     ..src > go
       // un IntSet es us conjunto pequeño de enteros no negativos.
       // El valor cero representa un conjunto vacio.
       type IntSet struct {
         words []uint64
       }

       // Has Informa cuando el conjunto contiene valores x no negativos.
       func (s *IntSet) Has(x int) bool {
         word, bit := x/64, uint(x%64)
         return word < len(s.words) && s.words[word]&(1<<bit) != 0
       }

       // Add agrega el valor x no negativo al conjunto.
       func (s *IntSet) Add(x int) {
         word, bit := x/64, uint(x%64)
         for word >= len(s.words) {
           s.words = append(s.words, 0)
         }
         s.words[word] |= 1 << bit
       }

       // UnionWith establece s a la union de s y t.
       func (s *IntSet) UnionWith(t *IntSet) {
         for i, tword := range t.words {
           if i < len(s.words) {
             s.words[i] |= tword
           } else {
             s.words = append(s.words, tword)
           }
         }
       }
     < src..


   Ya que cada palabra tiene 64 bits, para localizar el bit para @c(x), se
   utiliza el cociente @c(x/64) como el indice de la palabra y el resto @c(x%64)
   como el indice de bit dentro de esa palabra. La operacion @c(UnionWith)
   utiliza el operador binario OR @c(|) Para calcular la union de 64 elementos a
   la vez. (Vamos a revisar la eleccion de palabras de 64 bits en el Ejercicio
   6.5.)

   Esta aplicacion carece de muchas caracteristicas deseables, algunas de las
   cuales se plantean como ejercicios, pero es dificil vivir sin : una forma de
   imprimir un @c(IntSet) como una cadena. Vamos a darle una String metodo como
   lo hicimos con @c(Celsius) en la @l(#Seccion 2.5):

   ..src > go
     // String regresa el conjunto como una cadena de la forma "{1 2 3}".
     func (s *IntSet) String() string {
       var buf bytes.Buffer
       buf.WriteByte('{')
       for i, word := range s.words {
         if word == 0 {
           continue
         }
         for j := 0; j < 64; j++ {
           if word&(1<<uint(j)) != 0 {
             if buf.Len() > len("{") {
               buf.WriteByte(' ')
             }
             fmt.Fprintf(&buf, "%d", 64*i+j)
           }
         }
       }
       buf.WriteByte('}')
       return buf.String()
     }
   < src..

   Note la similitud del metodo anterior @c(String) con @c(intsToString) en la
   @l(#Seccion 3.5.4); @c(bytes.Buffer) se utiliza a menudo de esta manera en
   metodos @c(String). El paquete @c(fmt) maneja tipos con un metodo @c(String)
   especialmente para que los valores de los tipos complicados se puedan mostrar
   de una manera amigable para el usuario. En lugar de imprimir la
   representacion del valor en bruto (una estructura en este caso), @c(fmt)
   llama al metodo @c(String). El mecanismo se basa en interfaces y tipo de
   afirmaciones, que vamos a explicar en el @l(#Capitulo 7).

   Ahora podemos demostrar @c(IntSet) en accion:

   ..src > go
     var x, y IntSet
     x.Add(1)
     x.Add(144)
     x.Add(9)
     fmt.Println(x.String()) // "{1 9 144}"

     y.Add(9)
     y.Add(42)
     fmt.Println(y.String()) // "{9 42}"

     x.UnionWith(&y)
     fmt.Println(x.String()) // "{1 9 42 144}"

     fmt.Println(x.Has(9), x.Has(123)) // "true false"
   < src..

   Una palabra de precaucion: declaramos @c(String) y @c(Has) como metodos del
   tipo de puntero @c(*IntSet) no por necesidad, sino por coherencia con los
   otros dos metodos, los cuales necesitan un receptor puntero porque asignan a
   @c(s.words). En consecuencia, un valor @c(IntSet) no tiene una metodo
   @c(String), en ocasiones, conduce a sorpresas como esta:

   ..src > go
     fmt.Println(&x)         // "{1 9 42 144}"
     fmt.Println(x.String()) // "{1 9 42 144}"
     fmt.Println(x)          // "{[4398046511618 0 65536]}"
   < src..

   En el primer caso, Imprimimos un puntero @c(*IntSet), que tiene un metodo
   @c(String). En el segundo caso, que llamamos a @c[String()] en una variable
   @c(IntSet); el compilador inserta la operacion @c(&) implicita, que nos da un
   puntero, que tiene el metodo @c(String). Sin embargo, en el tercer caso,
   debido a que el valor @c(IntSet) no tiene un metodo @c(String), fmt.Println
   imprime la representacion de la estructura en su lugar. Es importante no
   olvidar el operador @c(&). Hacer @c(String) un metodo de @c(IntSet), no
   @c(*IntSet), podria ser una buena idea, pero esto es un juicio caso por caso.

   @b(Ejercicio 6.1): Implementar estos metodos adicionales:

   ..src > go
     func (*IntSet) Len() int      // regresa el numero de elementos
     func (*IntSet) Remove(x int)  // elimina x del conjunto
     func (*IntSet) Clear()        // elimina todos los elementos del conjunto
     func (*IntSet) Copy() *IntSet // regresa una copia del conjunto
   < src..

   @b(Ejercicio 6.2): Definir una metodo variadic @c[(*IntSet).AddAll(...int)]
   que permita añadir una lista de valores, como @c[s.AddAll(1, 2, 3)].

   @b(Ejercicio 6.3): @c[(*IntSet).UnionWith] calcula la union de dos conjuntos
   utilizando @c(|), el operador OR binario. Implementar metodos para
   @c(IntersectWith), @c(DifferenceWith), y @c(SymmetricDifference) para las
   operaciones de conjuntos correspondientes. (La diferencia simetrica de dos
   conjuntos contiene los elementos presentes en un conjunto o el otro, pero no
   ambos.)

   @b(Ejercicio 6.4): añadir un metodo @c(Elems) que devuelve una slice que
   contiene los elementos del conjunto, apto para iterar sobre el con una bucle
   @c(range).

   @b(Ejercicio 6.5): El tipo de cada palabra usada por @c(IntSet) es
   @c(uint64), pero la aritmetica de 64 bits puede ser ineficiente en una
   plataforma de 32 bits. Modificar el programa para usar el tipo @c(uint), que
   es el tipo entero sin signo mas eficiente para la plataforma. En lugar de
   dividir por 64, definir una constante que almacene el tamaño efectivo de
   @c(uint) en bits, 32 o 64. Se puede utilizar la expresion tal vez demasiado
   inteligente @c[32 << (^uint(0) >> 63)] para este proposito.

** Seccion 6.6 <> Encapsulacion

   Se dice que una variable o metodo de un objeto esta encapsulado si es
   inaccesible para los clientes del objeto. La encapsulacion, a veces llamado
   ocultacion de la informacion, es un aspecto clave de la programacion
   orientada a objetos.

   Go solo tiene un mecanismo para controlar la visibilidad de los nombres: los
   identificadores en mayusculas se exportan desde el paquete en el que estan
   definidos y los nombres no capitalizados no. El mismo mecanismo que limita el
   acceso a los miembros de un paquete tambien limita el acceso a los campos de
   una estructura o los metodos de un tipo. Como consecuencia, para encapsular
   un objeto, debemos hacer que sea una estructura.

   Esa es la razon por la que el tipo @c(IntSet) de la seccion anterior fue
   declarado como un tipo de estructura a pesar de que solo tiene un unico
   campo:

   ..src > go
     type IntSet struct {
       words []uint64
     }
   < src..

   En cambio podriamos definir @c(IntSet) como un tipo de slice de la siguiente
   manera, aunque por supuesto tendriamos que sustituir cada ocurrencia de
   @c(s.words) por @c(*s) en sus metodos:

   ..src > go
     type IntSet []uint64
   < src..

   Aunque esta version de @c(IntSet) esencialmente seria equivalente, permitiria
   a clientes de otros paquetes leer y modificar el slice directamente. Dicho de
   otra manera, mientras que la expresion @c(*s) se podrian utilizar en
   cualquier paquete, @c(s.words) solo puede aparecer en el paquete que define
   @c(IntSet).

   Otra consecuencia de este mecanismo basado en el nombre es que la unidad de
   encapsulacion es el paquete, no el tipo como en muchos otros lenguajes. Los
   campos de un tipo de estructura son visibles para todo el codigo dentro del
   mismo paquete. Si el codigo aparece en una funcion o un metodo no hace
   ninguna diferencia.

   La encapsulacion proporciona tres beneficios. En primer lugar, debido a que
   los clientes no pueden modificar directamente las variables del objeto, es
   necesario inspeccionar menos enunciados para comprender los valores posibles
   de esas variables.

   En segundo lugar, ocultar los detalles de la implementacion impide que los
   clientes dependan de las cosas que podrian cambiar, lo que le da al diseñador
   mayor libertad para evolucionar la implementacion sin romper la
   compatibilidad de la API.

   Como ejemplo, considere el tipo @c(bytes.Buffer) tipo. Se utiliza con
   frecuencia para acumular cadenas muy cortas, por lo que es una optimizacion
   rentable para reservar un poco mas de espacio en el objeto para evitar la
   asignacion de memoria en este caso comun. Ya que @c(Buffer) es un tipo
   @c(struct), este espacio tiene la forma de un campo adicional de tipo
   @c([64]byte) con un nombre en minusculas. Cuando se añadio este campo, ya que
   no se exporto, los clientes de @c(Buffer) fuera del paquete @c(bytes) no eran
   conscientes de ningun cambio, excepto un rendimiento mejorado. @c(Buffer) y
   su metodo @c(Grow) se muestran a continuacion, simplificado para mayor
   claridad:

   ..src > go
     type Buffer struct {
       buf     []byte
       initial [64]byte
       /* ... */
     }

     // Grow apmlia la capacidad del buffer, si es necesario,
     // para garantizar espacio por otron n bytes. [...]
     func (b *Buffer) Grow(n int) {
       if b.buf == nil {
         b.buf = b.initial[:0] // use preallocated space initially
       }
       if len(b.buf)+n > cap(b.buf) {
         buf := make([]byte, b.Len(), 2*cap(b.buf) + n)
         copy(buf, b.buf)
         b.buf = buf
       }
     }
   < src..

   El tercer beneficio de la encapsulacion, y en muchos casos el mas importante,
   es que impide que los clientes establezcan arbitrariamente las variables de
   un objeto. Debido a que las variables del objeto solo pueden ser definidas
   por funciones en el mismo paquete, el autor de ese paquete puede garantizar
   que todas esas funciones mantengan las invariantes internas del objeto. Por
   ejemplo, el tipo @c(Counter) continuacion permite a los clientes incrementar
   el contador o reestablecerlo a cero, pero no ponerlo en un valor arbitrario:

   ..src > go
     type Counter struct { n int }

     func (c *Counter) N() int     { return c.n }
     func (c *Counter) Increment() { c.n++ }
     func (c *Counter) Reset()     { c.n = 0 }
   < src..

   Las Funciones que simplemente acceso o modifican los valores internos de un
   tipo, como los metodos del tipo @c(Logger) del paquete @c(log), a
   continuacion, se denominan @e(getters) (optenedores) y @e(setters)
   (definidores). Sin embargo, al nombrar a un metodo getter, por lo general
   omitimos el prefijo @c(Get). Esta preferencia por razones de brevedad se
   extiende a todos los metodos, no solo a los accesores de campo, y para otros
   prefijos redundantes, asi como @c(Fetch), @c(Find), y @c(Lookup).

   ..src > go
     package log

     type Logger struct {
       flags  int
       prefix string
       // ...
     }

     func (l *Logger) Flags() int
     func (l *Logger) SetFlags(flag int)
     func (l *Logger) Prefix() string
     func (l *Logger) SetPrefix(prefix string)
   < src..

   El stilo de Go no prohibe exportar los campos. Por supuesto, una vez
   exportado, un campo no puede ser exportado sin un cambio incompatible a la
   API, por lo que la eleccion inicial debe ser deliberada y debe considerar la
   complejidad de los invariantes que deben mantenerse, la probabilidad de
   cambios futuros y la cantidad del codigo cliente que se veria afectado por un
   cambio.

   La encapsulacion no siempre es deseable. Al revelar su representacion como un
   numero @c(int64) de nanosegundos, @c(time.Duration) nos permite usar todas
   las operaciones aritmeticas y de comparacion con duraciones habituales, e
   incluso para definir constantes de este tipo:

   ..src > go
     const day = 24 * time.Hour
     fmt.Println(day.Seconds()) // "86400"
   < src..

   Como otro ejemplo, contraste @c(IntSet) con el tipo @c(geometry.Path) al
   principio de este capitulo. @c(Path) se definio como un tipo de slice,
   permitiendo a sus clientes construir instancias utilizando la sintaxis
   literal de slice, para iterar sobre sus puntos usando un bucle de rango, y
   asi sucesivamente, mientras que estas operaciones se le niegan a los clientes
   de @c(IntSet).

   Esta es la diferencia fundamental: @c(geometry.Path) es intrinsecamente una
   secuencia de puntos, ni mas ni menos, y no prevemos la adicion de nuevos
   campos a la misma, asi que tiene sentido para el paquete @c(geometry) revelar
   que @c(Path) es un slice. En contraste, un @c(IntSet) simplemente pasa a ser
   representado como un slice @c([]uint64). Podria haber sido representado
   mediante @c([]uint), o algo completamente diferente para los conjuntos que
   son escasos o muy pequeños, y que tal vez podrian beneficiarse de
   caracteristicas adicionales como un campo adicional para registrar el numero
   de elementos en el conjunto. Por estas razones, tiene sentido que @c(IntSet)
   sea opaco.

   En este capitulo, aprendimos como asociar metodos con tipos con nombre y como
   llamar a esos metodos. Aunque los metodos son cruciales para la programacion
   orientada a objetos, son solo la mitad de la imagen. Para completarla,
   necesitamos @e(interfaces), el tema del proximo capitulo.

* Capitulo 7 <> Interfaces
