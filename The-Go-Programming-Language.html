<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" />
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" >
<head>
  <title>The Go Programming Language</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="author" content="Alan A. A. Donovan" />
  <meta name="author" content="Brian W. Kernighan" />
  <meta name="id" content="isbn-10 0-13-419044-0" />
  <meta name="date" content="29/09/2015" />
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
</head>

<body>
<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <ul>
  <li><a class="h2" href="#preface" >Preface</a></li>
    <ul>
    <li><a class="h3" href="#the-origins-of-go" >The Origins of Go</a></li>
    <li><a class="h3" href="#the-go-project" >The Go Project</a></li>
    <li><a class="h3" href="#organization-of-the-book" >Organization of the Book</a></li>
    <li><a class="h3" href="#where-to-find-more-information" >Where to Find More Information</a></li>
    <li><a class="h3" href="#acknowledgments" >Acknowledgments</a></li>
    </ul>
  <li><a class="h2" href="#chapter-1" >Tutorial</a></li>
    <ul>
    <li><a class="h3" href="#section-1.1" >Hello, World</a></li>
    <li><a class="h3" href="#section-1.2" >Command-Line Arguments</a></li>
    <li><a class="h3" href="#section-1.3" >Finding Duplicate Lines</a></li>
    <li><a class="h3" href="#section-1.4" >Animated GIFs</a></li>
    <li><a class="h3" href="#section-1.5" >Fetching a URL</a></li>
    <li><a class="h3" href="#section-1.6" >Fetching URLs Concurrently</a></li>
    <li><a class="h3" href="#section-1.7" >A Web Server</a></li>
    <li><a class="h3" href="#section-1.8" >Loose Ends</a></li>
    </ul>
  <li><a class="h2" href="#chapter-2" >Program Structure</a></li>
    <ul>
    <li><a class="h3" href="#section-2.1" >Names</a></li>
    <li><a class="h3" href="#section-2.2" >Declarations</a></li>
    <li><a class="h3" href="#section-2.3" >Variables</a></li>
      <ul>
      <li><a class="h4" href="#section-2.3.1" >Short Variable Declarations</a></li>
      <li><a class="h4" href="#section-2.3.2" >Pointers</a></li>
      <li><a class="h4" href="#section-2.3.3" >The <code>new</code> Function</a></li>
      <li><a class="h4" href="#section-2.3.4" >Lifetime of Variables</a></li>
      </ul>
    <li><a class="h3" href="#section-2.4" >Assignments</a></li>
      <ul>
      <li><a class="h4" href="#section-2.4.1" >Tuple assignment</a></li>
      <li><a class="h4" href="#section-2.4.2" >Assignability</a></li>
      </ul>
    <li><a class="h3" href="#section-2.5" >Type Declarations</a></li>
    <li><a class="h3" href="#section-2.6" >Packages and Files</a></li>
      <ul>
      <li><a class="h4" href="#section-2.6.1" >Imports</a></li>
      <li><a class="h4" href="#section-2.6.2" >Package Initialization</a></li>
      </ul>
    <li><a class="h3" href="#section-2.7" >Scope</a></li>
    </ul>
  <li><a class="h2" href="#chapter-3" >Basic Data Types</a></li>
    <ul>
    <li><a class="h3" href="#section-3.1" >Integers</a></li>
    <li><a class="h3" href="#section-3.2" >Floating-Point Numbers</a></li>
    <li><a class="h3" href="#section-3.3" >Complex Numbers</a></li>
    <li><a class="h3" href="#section-3.4" >Booleans</a></li>
    <li><a class="h3" href="#section-3.5" >Strings</a></li>
      <ul>
      <li><a class="h4" href="#section-3.5.1" >String Literals</a></li>
      <li><a class="h4" href="#section-3.5.2" >Unicode</a></li>
      <li><a class="h4" href="#section-3.5.3" >UTF-8</a></li>
      <li><a class="h4" href="#section-3.5.4" >Strings and Byte Slices</a></li>
      <li><a class="h4" href="#section-3.5.5" >Conversions between Strings and Numbers</a></li>
      </ul>
    <li><a class="h3" href="#section-3.6" >Constants</a></li>
      <ul>
      <li><a class="h4" href="#section-3.6.1" >The Constant Generator <code>iota</code></a></li>
      <li><a class="h4" href="#section-3.6.2" >Untyped Constants</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#chapter-4" >Composite Types</a></li>
    <ul>
    <li><a class="h3" href="#section-4.1" >Arrays</a></li>
    <li><a class="h3" href="#section-4.2" >Slices</a></li>
      <ul>
      <li><a class="h4" href="#section-4.2.1" >The <code>append</code> Function</a></li>
      <li><a class="h4" href="#section-4.2.2" >In-Place Slice Techniques</a></li>
      </ul>
    <li><a class="h3" href="#section-4.3" >Maps</a></li>
    <li><a class="h3" href="#section-4.4" >Structs</a></li>
      <ul>
      <li><a class="h4" href="#section-4.4.1" >Struct Literals</a></li>
      <li><a class="h4" href="#section-4.4.2" >Comparing Structs</a></li>
      <li><a class="h4" href="#section-4.4.3" >Struct Embedding and Anonymous Fields</a></li>
      </ul>
    <li><a class="h3" href="#section-4.5" >JSON</a></li>
    <li><a class="h3" href="#section-4.6" >Text and HTML Templates</a></li>
    </ul>
  <li><a class="h2" href="#chapter-5" >Functions</a></li>
    <ul>
    <li><a class="h3" href="#section-5.1" >Function Declarations</a></li>
    <li><a class="h3" href="#section-5.2" >Recursion</a></li>
    <li><a class="h3" href="#section-5.3" >Multiple Return Values</a></li>
    <li><a class="h3" href="#section-5.4" >Errors</a></li>
      <ul>
      <li><a class="h4" href="#section-5.4.1" >Error-Handling Strategies</a></li>
      <li><a class="h4" href="#section-5.4.2" >End of File (EOF)</a></li>
      </ul>
    <li><a class="h3" href="#section-5.5" >Function Values</a></li>
    <li><a class="h3" href="#section-5.6" >Anonymous Functions</a></li>
      <ul>
      <li><a class="h4" href="#section-5.6.1" >Caveat: Capturing Iteration Variables</a></li>
      </ul>
    <li><a class="h3" href="#section-5.7" >Variadic Functions</a></li>
    <li><a class="h3" href="#section-5.8" >Deferred Function Calls</a></li>
    <li><a class="h3" href="#section-5.9" >Panic</a></li>
    <li><a class="h3" href="#section-5.10" >Recover</a></li>
    </ul>
  <li><a class="h2" href="#chapter-6" >Methods</a></li>
    <ul>
    <li><a class="h3" href="#section-6.1" >Method Declarations</a></li>
    <li><a class="h3" href="#section-6.2" >Methods with a Pointer Receiver</a></li>
      <ul>
      <li><a class="h4" href="#section-6.2.1" >Nil Is a Valid Receiver Value</a></li>
      </ul>
    <li><a class="h3" href="#section-6.3" >Composing Types by Struct Embedding</a></li>
    <li><a class="h3" href="#section-6.4" >Method Values and Expressions</a></li>
    <li><a class="h3" href="#section-6.5" >Example: Bit Vector Type</a></li>
    <li><a class="h3" href="#section-6.6" >Encapsulation</a></li>
    </ul>
  <li><a class="h2" href="#chapter-7" >Interfaces</a></li>
    <ul>
    <li><a class="h3" href="#section-7.1" >Interfaces as Contracts</a></li>
    <li><a class="h3" href="#section-7.2" >Interface Types</a></li>
    <li><a class="h3" href="#section-7.3" >Interface Satisfaction</a></li>
    <li><a class="h3" href="#section-7.4" >Parsing Flags with <code>flag.Value</code></a></li>
    <li><a class="h3" href="#section-7.5" >Interface Values</a></li>
      <ul>
      <li><a class="h4" href="#section-7.5.1" >Caveat: An Interface Containing a Nil Pointer Is Non-Nil</a></li>
      </ul>
    <li><a class="h3" href="#section-7.6" >Sorting with <code>sort.Interface</code></a></li>
    <li><a class="h3" href="#section-7.7" >The <code>http.Handler</code> Interface</a></li>
    <li><a class="h3" href="#section-7.8" >The <code>error</code> Interface</a></li>
    <li><a class="h3" href="#section-7.9" >Example: Expression Evaluator</a></li>
    <li><a class="h3" href="#section-7.10" >Type Assertions</a></li>
    <li><a class="h3" href="#section-7.11" >Discriminating Errors with Type Assertions</a></li>
    <li><a class="h3" href="#section-7.12" >Querying Behaviors with Interface Type Assertions</a></li>
    <li><a class="h3" href="#section-7.13" >Type Switches</a></li>
    <li><a class="h3" href="#section-7.14" >Example: Token-Based XML Decoding</a></li>
    <li><a class="h3" href="#section-7.15" >A Few Words of Advice</a></li>
    </ul>
  <li><a class="h2" href="#chapter-8" >Goroutines and Channels</a></li>
    <ul>
    <li><a class="h3" href="#section-8.1" >Goroutines</a></li>
    <li><a class="h3" href="#section-8.2" >Example: Concurrent Clock Server</a></li>
    <li><a class="h3" href="#section-8.3" >Example: Concurrent Echo Server</a></li>
    <li><a class="h3" href="#section-8.4" >Channels</a></li>
      <ul>
      <li><a class="h4" href="#section-8.4.1" >Unbuffered Channels</a></li>
      <li><a class="h4" href="#section-8.4.2" >Pipelines</a></li>
      <li><a class="h4" href="#section-8.4.3" >Unidirectional Channel Types</a></li>
      <li><a class="h4" href="#section-8.4.4" >Buffered Channels</a></li>
      </ul>
    <li><a class="h3" href="#section-8.5" >Looping in Parallel</a></li>
    <li><a class="h3" href="#section-8.6" >Example: Concurrent Web Crawler</a></li>
    <li><a class="h3" href="#section-8.7" >Multiplexing with <code>select</code></a></li>
    <li><a class="h3" href="#section-8.8" >Example: Concurrent Directory Traversal</a></li>
    <li><a class="h3" href="#section-8.9" >Cancellation</a></li>
    <li><a class="h3" href="#section-8.10" >Example: Chat Server</a></li>
    </ul>
  <li><a class="h2" href="#chapter-9" >Concurrency with Shared Variables</a></li>
    <ul>
    <li><a class="h3" href="#section-9.1" >Race Conditions</a></li>
    <li><a class="h3" href="#section-9.2" >Mutual Exclusion: <code>sync.Mutex</code></a></li>
    <li><a class="h3" href="#section-9.3" >Read/Write Mutexes: <code>sync.RWMutex</code></a></li>
    <li><a class="h3" href="#section-9.4" >Memory Synchronization</a></li>
    <li><a class="h3" href="#section-9.5" >Lazy Initialization: <code>sync.Once</code></a></li>
    <li><a class="h3" href="#section-9.6" >The Race Detector</a></li>
    <li><a class="h3" href="#section-9.7" >Example: Concurrent Non-Blocking Cache</a></li>
    <li><a class="h3" href="#section-9.8" >Goroutines and Threads</a></li>
      <ul>
      <li><a class="h4" href="#section-9.8.1" >Growable Stacks</a></li>
      <li><a class="h4" href="#section-9.8.2" >Goroutine Scheduling</a></li>
      <li><a class="h4" href="#section-9.8.3" ><code>GOMAXPROCS</code></a></li>
      <li><a class="h4" href="#section-9.8.4" >Goroutines Have No Identity</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#chapter-10" >Packages and the Go Tool</a></li>
    <ul>
    <li><a class="h3" href="#section-10.1" >Introduction</a></li>
    <li><a class="h3" href="#section-10.2" >Import Paths</a></li>
    <li><a class="h3" href="#section-10.3" >The Package Declaration</a></li>
    <li><a class="h3" href="#section-10.4" >Import Declarations</a></li>
    <li><a class="h3" href="#section-10.5" >Blank Imports</a></li>
    <li><a class="h3" href="#section-10.6" >Packages and Naming</a></li>
    <li><a class="h3" href="#section-10.7" >The Go Tool</a></li>
      <ul>
      <li><a class="h4" href="#section-10.7.1" >Workspace Organization</a></li>
      <li><a class="h4" href="#section-10.7.2" >Downloading Packages</a></li>
      <li><a class="h4" href="#section-10.7.3" >Building Packages</a></li>
      <li><a class="h4" href="#section-10.7.4" >Documenting Packages</a></li>
      <li><a class="h4" href="#section-10.7.5" >Internal Packages</a></li>
      <li><a class="h4" href="#section-10.7.6" >Querying Packages</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#chapter-11" >Testing</a></li>
    <ul>
    <li><a class="h3" href="#section-11.1" >The <code class="command" >go test</code> Tool</a></li>
    <li><a class="h3" href="#section-11.2" ><code>Test</code> Functions</a></li>
      <ul>
      <li><a class="h4" href="#section-11.2.1" >Randomized Testing</a></li>
      <li><a class="h4" href="#section-11.2.2" >Testing a Command</a></li>
      <li><a class="h4" href="#section-11.2.3" >White-Box Testing</a></li>
      <li><a class="h4" href="#section-11.2.4" >External Test Packages</a></li>
      <li><a class="h4" href="#section-11.2.5" >Writing Effective Tests</a></li>
      <li><a class="h4" href="#section-11.2.6" >Avoiding Brittle Tests</a></li>
      </ul>
    <li><a class="h3" href="#section-11.3" >Coverage</a></li>
    <li><a class="h3" href="#section-11.4" ><code>Benchmark</code> Functions</a></li>
    <li><a class="h3" href="#section-11.5" >Profiling</a></li>
    <li><a class="h3" href="#section-11.6" ><code>Example</code> Functions</a></li>
    </ul>
  <li><a class="h2" href="#chapter-12" >Reflection</a></li>
    <ul>
    <li><a class="h3" href="#section-12.1" >Why Reflection?</a></li>
    <li><a class="h3" href="#section-12.2" ><code>reflect.Type</code> and <code>reflect.Value</code></a></li>
    <li><a class="h3" href="#section-12.3" ><code>Display</code>, a Recursive Value Printer</a></li>
    <li><a class="h3" href="#section-12.4" >Example: Encoding S-Expressions</a></li>
    <li><a class="h3" href="#section-12.5" >Setting Variables with <code>reflect.Value</code></a></li>
    <li><a class="h3" href="#section-12.6" >Example: Decoding S-Expressions</a></li>
    <li><a class="h3" href="#section-12.7" >Accessing Struct Field Tags</a></li>
    <li><a class="h3" href="#section-12.8" >Displaying the Methods of a Type</a></li>
    <li><a class="h3" href="#section-12.9" >A Word of Caution</a></li>
    </ul>
  <li><a class="h2" href="#chapter-13" >Low-Level Programming</a></li>
    <ul>
    <li><a class="h3" href="#section-13.1" ><code>unsafe.Sizeof</code>, <code>Alignof</code>, and <code>Offsetof</code></a></li>
    <li><a class="h3" href="#section-13.2" ><code>unsafe.Pointer</code></a></li>
    <li><a class="h3" href="#section-13.3" >Example: Deep Equivalence</a></li>
    <li><a class="h3" href="#section-13.4" >Calling C Code with <code class="command" >cgo</code></a></li>
    <li><a class="h3" href="#section-13.5" >Another Word of Caution</a></li>
    </ul>
  </ul>
  </div>
</div>

<h1>The Go Programming Language</h1>
<div class="hBody-1" >
<div class="center" >
<p>For Leila and Meg</p>
</div>
</div>
<h2 id="preface" >Preface</h2>
<div class="hBody-2" >
<blockquote>
<p><q>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</q></p>
<div class="quote-author" >
<p>(From the Go web site at <a href="https://golang.org/" >golang.org</a>)</p>
</div>
</blockquote>
<p>Go was conceived in September 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, all at Google, and was announced in November 2009. The goals of the language and its accompanying tools were to be expressive, efficient in both compilation and execution, and effective in writing reliable and robust programs.</p>
<p>Go bears a surface similarity to C and, like C, is a tool for professional programmers, achieving maximum effect with minimum means. But it is much more than an updated version of C. It borrows and adapts good ideas from many other languages, while avoiding features that have led to complexity and unreliable code. Its facilities for concurrency are new and efficient, and its approach to data abstraction and object-oriented programming is unusually flexible. It has automatic memory management or <em>garbage collection</em>.</p>
<p>Go is especially well suited for building infrastructure like networked servers, and tools and systems for programmers, but it is truly a general-purpose language and finds use in domains as diverse as graphics, mobile applications, and machine learning. It has become popular as a replacement for untyped scripting languages because it balances expressiveness with safety: Go programs typically run faster than programs written in dynamic languages and suffer far fewer crashes due to unexpected type errors.</p>
<p>Go is an open-source project, so source code for its compiler, libraries, and tools is freely available to anyone. Contributions to the project come from an active worldwide community. Go runs on Unix-like systems—GNU/Linux, FreeBSD, OpenBSD, Mac OS X—and on Plan 9 and Microsoft Windows. Programs written in one of these environments generally work without modification on the others.</p>
<p>This book is meant to help you start using Go effectively right away and to use it well, taking full advantage of Go’s language features and standard libraries to write clear, idiomatic, and efficient programs.</p>
</div>
<h3 id="the-origins-of-go" >The Origins of Go</h3>
<div class="hBody-3" >
<p>Like biological species, successful languages beget offspring that incorporate the advantages of their ancestors; interbreeding sometimes leads to surprising strengths; and, very occasionally, a radical new feature arises without precedent. We can learn a lot about why a language is the way it is and what environment it has been adapted for by looking at these influences.</p>
<p>The figure below shows the most important influences of earlier programming languages on the design of Go.</p>
<figure>
<img src="img/go-influences.jpg" />
</figure>
<p>Go is sometimes described as a <q>C-like language,</q> or as <q>C for the 21st century.</q> From C, Go inherited its expression syntax, control-flow statements, basic data types, call-by-value parameter passing, pointers, and above all, C’s emphasis on programs that compile to efficient machine code and cooperate naturally with the abstractions of current operating systems.</p>
<p>But there are other ancestors in Go’s family tree. One major stream of influence comes from languages by Niklaus Wirth, beginning with Pascal. Modula-2 inspired the package concept.  Oberon eliminated the distinction between module interface files and module implementation files. Oberon-2 influenced the syntax for packages, imports, and declarations, and provided the syntax for method declarations.</p>
<p>Another lineage among Go’s ancestors, and one that makes Go distinctive among recent programming languages, is a sequence of little-known research languages developed at Bell Labs, all inspired by the concept of <em>communicating sequential processes</em> (CSP) from Tony Hoare’s seminal 1978 paper on the foundations of concurrency. In CSP, a program is a parallel composition of processes that have no shared state; the processes communicate and synchronize using channels. But Hoare’s CSP was a formal language for describing the fundamental concepts of concurrency, not a programming language for writing executable programs.</p>
<p>Rob Pike and others began to experiment with CSP implementations as actual languages. The first was called Squeak (<q>A language for communicating with mice</q>), which provided a language for handling mouse and keyboard events, with statically created channels. This was followed by Newsqueak, which offered C-like statement and expression syntax and Pascal-like type notation. It was a purely functional language with garbage collection, again aimed at managing keyboard, mouse, and window events. Channels became first-class values, dynamically created and storable in variables.</p>
<p>The Plan 9 operating system carried these ideas forward in a language called Alef. Alef tried to make Newsqueak a viable system programming language, but its omission of garbage collection made concurrency too painful.</p>
<p>Other constructions in Go show the influence of non-ancestral genes here and there; for example <code>iota</code> is loosely from APL, and lexical scope with nested functions is from Scheme (and most languages since). Here too we find novel mutations. Go’s innovative slices provide dynamic arrays with efficient random access but also permit sophisticated sharing arrangements reminiscent of linked lists. And the <code>defer</code> statement is new with Go.</p>
</div>
<h3 id="the-go-project" >The Go Project</h3>
<div class="hBody-3" >
<p>All programming languages reflect the programming philosophy of their creators, which often includes a significant component of reaction to the perceived shortcomings of earlier languages. The Go project was borne of frustration with several software systems at Google that were suffering from an explosion of complexity. (This problem is by no means unique to Google.)</p>
<p>As Rob Pike put it, <q>complexity is multiplicative</q>: fixing a problem by making one part of the system more complex slowly but surely adds complexity to other parts. With constant pressure to add features and options and configurations, and to ship code quickly, it’s easy to neglect simplicity, even though in the long run simplicity is the key to good software.</p>
<p>Simplicity requires more work at the beginning of a project to reduce an idea to its essence and more discipline over the lifetime of a project to distinguish good changes from bad or pernicious ones. With sufficient effort, a good change can be accommodated without compromising what Fred Brooks called the <q>conceptual integrity</q> of the design but a bad change cannot, and a pernicious change trades simplicity for its shallow cousin, convenience. Only through simplicity of design can a system remain stable, secure, and coherent as it grows.</p>
<p>The Go project includes the language itself, its tools and standard libraries, and last but not least, a cultural agenda of radical simplicity. As a recent high-level language, Go has the benefit of hindsight, and the basics are done well: it has garbage collection, a package system, firstclass functions, lexical scope, a system call interface, and immutable strings in which text is generally encoded in UTF-8. But it has comparatively few features and is unlikely to add more. For instance, it has no implicit numeric conversions, no constructors or destructors, no operator overloading, no default parameter values, no inheritance, no generics, no exceptions, no macros, no function annotations, and no thread-local storage. The language is mature and stable, and guarantees backwards compatibility: older Go programs can be compiled and run with newer versions of compilers and standard libraries.</p>
<p>Go has enough of a type system to avoid most of the careless mistakes that plague programmers in dynamic languages, but it has a simpler type system than comparable typed languages.  This approach can sometimes lead to isolated pockets of <q>untyped</q> programming within a broader framework of types, and Go programmers do not go to the lengths that C++ or Haskell programmers do to express safety properties as type-based proofs. But in practice Go gives programmers much of the safety and run-time performance benefits of a relatively strong type system without the burden of a complex one.</p>
<p>Go encourages an awareness of contemporary computer system design, particularly the importance of locality. Its built-in data types and most library data structures are crafted to work naturally without explicit initialization or implicit constructors, so relatively few memory allocations and memory writes are hidden in the code. Go’s aggregate types (structs and arrays) hold their elements directly, requiring less storage and fewer allocations and pointer indirections than languages that use indirect fields. And since the modern computer is a parallel machine, Go has concurrency features based on CSP, as mentioned earlier. The variablesize stacks of Go’s lightweight threads or <em>goroutines</em> are initially small enough that creating one goroutine is cheap and creating a million is practical.</p>
<p>Go’s standard library, often described as coming with <q>batteries included,</q> provides clean building blocks and APIs for I/O, text processing, graphics, cryptography, networking, and distributed applications, with support for many standard file formats and protocols. The libraries and tools make extensive use of convention to reduce the need for configuration and explanation, thus simplifying program logic and making diverse Go programs more similar to each other and thus easier to learn. Projects built using the <code class="command" >go</code> tool use only file and identifier names and an occasional special comment to determine all the libraries, executables, tests, benchmarks, examples, platform-specific variants, and documentation for a project; the Go source itself contains the build specification.</p>
</div>
<h3 id="organization-of-the-book" >Organization of the Book</h3>
<div class="hBody-3" >
<p>We assume that you have programmed in one or more other languages, whether compiled like C, C++, and Java, or interpreted like Python, Ruby, and JavaScript, so we won’t spell out everything as if for a total beginner. Surface syntax will be familiar, as will variables and constants, expressions, control flow, and functions.</p>
<p>Chapter 1 is a tutorial on the basic constructs of Go, introduced through a dozen programs for everyday tasks like reading and writing files, formatting text, creating images, and communicating with Internet clients and servers.</p>
<p>Chapter 2 describes the structural elements of a Go program—declarations, variables, new types, packages and files, and scope. Chapter 3 discusses numbers, booleans, strings, and constants, and explains how to process Unicode. Chapter 4 describes composite types, that is, types built up from simpler ones using arrays, maps, structs, and slices, Go’s approach to dynamic lists. Chapter 5 covers functions and discusses error handling, <code>panic</code> and <code>recover</code>, and the <code>defer</code> statement.</p>
<p>Chapters 1 through 5 are thus the basics, things that are part of any mainstream imperative language. Go’s syntax and style sometimes differ from other languages, but most programmers will pick them up quickly. The remaining chapters focus on topics where Go’s approach is less conventional: methods, interfaces, concurrency, packages, testing, and reflection.</p>
<p>Go has an unusual approach to object-oriented programming. There are no class hierarchies, or indeed any classes; complex object behaviors are created from simpler ones by composition, not inheritance. Methods may be associated with any user-defined type, not just structures, and the relationship between concrete types and abstract types (<em>interfaces</em>) is implicit, so a concrete type may satisfy an interface that the type’s designer was unaware of. Methods are covered in Chapter 6 and interfaces in Chapter 7.</p>
<p>Chapter 8 presents Go’s approach to concurrency, which is based on the idea of communicating sequential processes (CSP), embodied by goroutines and channels. Chapter 9 explains the more traditional aspects of concurrency based on shared variables.</p>
<p>Chapter 10 describes packages, the mechanism for organizing libraries. This chapter also shows how to make effective use of the <code class="command" >go</code> tool, which provides for compilation, testing, benchmarking, program formatting, documentation, and many other tasks, all within a single command.</p>
<p>Chapter 11 deals with testing, where Go takes a notably lightweight approach, avoiding abstraction-laden frameworks in favor of simple libraries and tools. The testing libraries provide a foundation atop which more complex abstractions can be built if necessary.</p>
<p>Chapter 12 discusses reflection, the ability of a program to examine its own representation during execution. Reflection is a powerful tool, though one to be used carefully; this chapter explains finding the right balance by showing how it is used to implement some important Go libraries. Chapter 13 explains the gory details of low-level programming that uses the <code>unsafe</code> package to step around Go’s type system, and when that is appropriate.</p>
<p>Each chapter has a number of exercises that you can use to test your understanding of Go, and to explore extensions and alternatives to the examples from the book.</p>
<p>All but the most trivial code examples in the book are available for download from the public Git repository at <a href="http://www.gopl.io/" >gopl.io</a>. Each example is identified by its package import path and may be conveniently fetched, built, and installed using the <code class="command" >go get</code> command. You’ll need to choose a directory to be your Go workspace and set the <code>GOPATH</code> environment variable to point to it.  The <code class="command" >go</code> tool will create the directory if necessary. For example:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span><span class="nv">$HOME</span>/gobook        <span class="c1"># choose workspace directory
</span><span class="c1"></span></span><span class="in" ><span class="prompt" >&gt; </span>go get gopl.io/ch1/helloworld     <span class="c1"># fetch, build, install
</span><span class="c1"></span></span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">$GOPATH</span>/bin/helloworld            <span class="c1"># run
</span><span class="c1"></span></span><span class="out" >Hello, 世界
</span></code></pre>
<p>To run the examples, you will need at least version 1.5 of Go.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go version
</span><span class="out" >go version go1.5 linux/amd64
</span></code></pre>
<p>Follow the instructions at <a href="https://golang.org/doc/install" >https://golang.org/doc/install</a> if the <code class="command" >go</code> tool on your computer is older or missing.</p>
</div>
<h3 id="where-to-find-more-information" >Where to Find More Information</h3>
<div class="hBody-3" >
<p>The best source for more information about Go is the official web site, <a href="https://golang.org" >https://golang.org</a>, which provides access to the documentation, including the <em>Go Programming Language Specification</em>, standard packages, and the like. There are also tutorials on how to write Go and how to write it well, and a wide variety of online text and video resources that will be valuable complements to this book. The Go Blog at <a href="https://blog.golang.org" >blog.golang.org</a> publishes some of the best writing on Go, with articles on the state of the language, plans for the future, reports on conferences, and in-depth explanations of a wide variety of Go-related topics.</p>
<p>One of the most useful aspects of online access to Go (and a regrettable limitation of a paper book) is the ability to run Go programs from the web pages that describe them. This functionality is provided by the Go Playground at <a href="https://play.golang.org" >play.golang.org</a>, and may be embedded within other pages, such as the home page at <a href="https://golang.org" >golang.org</a> or the documentation pages served by the <code class="command" >godoc</code> tool.</p>
<p>The Playground makes it convenient to perform simple experiments to check one’s understanding of syntax, semantics, or library packages with short programs, and in many ways takes the place of a <em>read-eval-print loop</em> (REPL) in other languages. Its persistent URLs are great for sharing snippets of Go code with others, for reporting bugs or making suggestions.</p>
<p>Built atop the Playground, the Go Tour at <a href="https://tour.golang.org" >tour.golang.org</a> is a sequence of short interactive lessons on the basic ideas and constructions of Go, an orderly walk through the language.</p>
<p>The primary shortcoming of the Playground and the Tour is that they allow only standard libraries to be imported, and many library features—networking, for example—are restricted for practical or security reasons. They also require access to the Internet to compile and run each program. So for more elaborate experiments, you will have to run Go programs on your own computer. Fortunately the download process is straightforward, so it should not take more than a few minutes to fetch the Go distribution from <a href="https://golang.org" >golang.org</a> and start writing and running Go programs of your own.</p>
<p>Since Go is an open-source project, you can read the code for any type or function in the standard library online at <a href="https://golang.org/pkg" >https://golang.org/pkg</a>; the same code is part of the downloaded distribution. Use this to figure out how something works, or to answer questions about details, or merely to see how experts write really good Go.</p>
</div>
<h3 id="acknowledgments" >Acknowledgments</h3>
<div class="hBody-3" >
<p>Rob Pike and Russ Cox, core members of the Go team, read the manuscript several times with great care; their comments on everything from word choice to overall structure and organization have been invaluable. While preparing the Japanese translation, Yoshiki Shibata went far beyond the call of duty; his meticulous eye spotted numerous inconsistencies in the English text and errors in the code. We greatly appreciate thorough reviews and critical comments on the entire manuscript from Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, and Peter Weinberger.</p>
<p>We are indebted to Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue, Jonathan Feinberg, Andrew Gerrand, Robert Griesemer, John Linderman, Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao, and Howard Trickey for many helpful suggestions. We also thank David Brailsford and Raph Levien for typesetting advice.</p>
<p>Our editor Greg Doench at Addison-Wesley got the ball rolling originally and has been continuously helpful ever since. The AW production team—John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith, and Barbara Wood—has been outstanding; authors could not hope for better support.</p>
<p>Alan Donovan wishes to thank: Sameer Ajmani, Chris Demetriou, Walt Drummond, and Reid Tatge at Google for allowing him time to write; Stephen Donovan, for his advice and timely encouragement; and above all, his wife Leila Kazemi, for her unhesitating enthusiasm and unwavering support for this project, despite the long hours of distraction and absenteeism from family life that it entailed.</p>
<p>Brian Kernighan is deeply grateful to friends and colleagues for their patience and forbearance as he moved slowly along the path to understanding, and especially to his wife Meg, who has been unfailingly supportive of book-writing and so much else.</p>
<blockquote>
<div class="quote-author" >
<p>New York</p>
</div>
<div class="quote-author" >
<p>October 2015</p>
</div>
</blockquote>
</div>
<h2 id="chapter-1" >Tutorial</h2>
<div class="hBody-2" >
<p>This chapter is a tour of the basic components of Go. We hope to provide enough information and examples to get you off the ground and doing useful things as quickly as possible. The examples here, and indeed in the whole book, are aimed at tasks that you might have to do in the real world. In this chapter we’ll try to give you a taste of the diversity of programs that one might write in Go, ranging from simple file processing and a bit of graphics to concurrent Internet clients and servers. We certainly won’t explain everything in the first chapter, but studying such programs in a new language can be an effective way to get started.</p>
<p>When you’re learning a new language, there’s a natural tendency to write code as you would have written it in a language you already know. Be aware of this bias as you learn Go and try to avoid it. We’ve tried to illustrate and explain how to write good Go, so use the code here as a guide when you’re writing your own.</p>
</div>
<h3 id="section-1.1" >Hello, World</h3>
<div class="hBody-3" >
<p>We’ll start with the now-traditional <q>hello, world</q> example, which appears at the beginning of <em>The C Programming Language</em>, published in 1978. C is one of the most direct influences on Go, and <q>hello, world</q> illustrates a number of central ideas.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/helloworld/main.go" >gopl.io/ch1/helloworld</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Hello, 世界&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Go is a compiled language. The Go toolchain converts a source program and the things it depends on into instructions in the native machine language of a computer. These tools are accessed through a single command called <code class="command" >go</code> that has a number of subcommands. The simplest of these subcommands is <code class="command" >run</code>, which compiles the source code from one or more source files whose names end in <span class="file" >.go</span>, links it with libraries, then runs the resulting executable file.  (We will use <code class="command" >$</code> as the command prompt throughout the book.)</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run helloworld.go
</span></code></pre>
<p>Not surprisingly, this prints</p>
<pre class="srci" ><code class="sh" ><span class="out" >Hello, 世界
</span></code></pre>
<p>Go natively handles Unicode, so it can process text in all the world’s languages.</p>
<p>If the program is more than a one-shot experiment, it’s likely that you would want to compile it once and save the compiled result for later use. That is done with <code class="command" >go build</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build helloworld.go
</span></code></pre>
<p>This creates an executable binary file called <code class="command" >helloworld</code> that can be run any time without further processing:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./helloworld
</span><span class="out" >Hello, 世界
</span></code></pre>
<p>We have labeled each significant example as a reminder that you can obtain the code from the book’s source code repository at <a href="http://www.gopl.io/" >gopl.io</a>: <a href="http://www.gopl.io/ch1/helloworld" >gopl.io/ch1/helloworld</a></p>
<p>If you run <code class="command" >go get gopl.io/ch1/helloworld</code>, it will fetch the source code and place it in the corresponding directory. There’s more about this topic in <a href="#section-2.6" >Section 2.6</a> and <a href="#section-10.7" >Section 10.7</a>.</p>
<p>Let’s now talk about the program itself. Go code is organized into packages, which are similar to libraries or modules in other languages. A package consists of one or more <span class="file" >.go</span> source files in a single directory that define what the package does. Each source file begins with a package declaration, here <code>package main</code>, that states which package the file belongs to, followed by a list of other packages that it imports, and then the declarations of the program that are stored in that file.</p>
<p>The Go standard library has over 100 packages for common tasks like input and output, sorting, and text manipulation. For instance, the <code>fmt</code> package contains functions for printing formatted output and scanning input. <code>Println</code> is one of the basic output functions in <code>fmt</code>; it prints one or more values, separated by spaces, with a newline character at the end so that the values appear as a single line of output.</p>
<p>Package <code>main</code> is special. It defines a standalone executable program, not a library. Within package <code>main</code> the <em>function</em> <code>main</code> is also special—it’s where execution of the program begins.  Whatever <code>main</code> does is what the program does. Of course, <code>main</code> will normally call upon functions in other packages to do much of the work, such as the function <code>fmt.Println</code>.</p>
<p>We must tell the compiler what packages are needed by this source file; that’s the role of the <code>import</code> declaration that follows the <code>package</code> declaration. The <q>hello, world</q> program uses only one function from one other package, but most programs will import more packages.</p>
<p>You must import exactly the packages you need. A program will not compile if there are missing imports or if there are unnecessary ones. This strict requirement prevents references to unused packages from accumulating as programs evolve.</p>
<p>The <code>import</code> declarations must follow the <code>package</code> declaration. After that, a program consists of the declarations of functions, variables, constants, and types (introduced by the keywords <code>func</code>, <code>var</code>, <code>const</code>, and <code>type</code>); for the most part, the order of declarations does not matter. This program is about as short as possible since it declares only one function, which in turn calls only one other function. To save space, we will sometimes not show the <code>package</code> and <code>import</code> declarations when presenting examples, but they are in the source file and must be there to compile the code.</p>
<p>A function declaration consists of the keyword <code>func</code>, the name of the function, a parameter list (empty for <code>main</code>), a result list (also empty here), and the body of the function—the statements that define what it does—enclosed in braces. We’ll take a closer look at functions in <a href="#chapter-5" >Chapter 5</a>.</p>
<p>Go does not require semicolons at the ends of statements or declarations, except where two or more appear on the same line. In effect, newlines following certain tokens are converted into semicolons, so where newlines are placed matters to proper parsing of Go code. For instance, the opening brace <code>{</code> of the function must be on the same line as the end of the <code>func</code> declaration, not on a line by itself, and in the expression <code>x + y</code>, a newline is permitted after but not before the <code>+</code> operator.</p>
<p>Go takes a strong stance on code formatting. The <code class="command" >gofmt</code> tool rewrites code into the standard format, and the <code class="command" >go</code> tool’s <code class="command" >fmt</code> subcommand applies <code class="command" >gofmt</code> to all the files in the specified package, or the ones in the current directory by default. All Go source files in the book have been run through <code class="command" >gofmt</code>, and you should get into the habit of doing the same for your own code. Declaring a standard format by fiat eliminates a lot of pointless debate about trivia and, more importantly, enables a variety of automated source code transformations that would be infeasible if arbitrary formatting were allowed.</p>
<p>Many text editors can be configured to run <code class="command" >gofmt</code> each time you save a file, so that your source code is always properly formatted. A related tool, <code class="command" >goimports</code>, additionally manages the insertion and removal of import declarations as needed. It is not part of the standard distribution but you can obtain it with this command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go get golang.org/x/tools/cmd/goimports
</span></code></pre>
<p>For most users, the usual way to download and build packages, run their tests, show their documentation, and so on, is with the <code class="command" >go</code> tool, which we’ll look at in <a href="#section-10.7" >Section 10.7</a>.</p>
</div>
<h3 id="section-1.2" >Command-Line Arguments</h3>
<div class="hBody-3" >
<p>Most programs process some input to produce some output; that’s pretty much the definition of computing. But how does a program get input data on which to operate? Some programs generate their own data, but more often, input comes from an external source: a file, a network connection, the output of another program, a user at a keyboard, command-line arguments, or the like. The next few examples will discuss some of these alternatives, starting with command-line arguments.</p>
<p>The <code>os</code> package provides functions and other values for dealing with the operating system in a platform-independent fashion. Command-line arguments are available to a program in a variable named <code>Args</code> that is part of the <code>os</code> package; thus its name anywhere outside the <code>os</code> package is <code>os.Args</code>.</p>
<p>The variable <code>os.Args</code> is a <em>slice</em> of strings. Slices are a fundamental notion in Go, and we’ll talk a lot more about them soon. For now, think of a slice as a dynamically sized sequence <code>s</code> of array elements where individual elements can be accessed as <code>s[i]</code> and a contiguous subsequence as <code>s[m:n]</code>. The number of elements is given by <code>len(s)</code>. As in most other programming languages, all indexing in Go uses <em>half-open</em> intervals that include the first index but exclude the last, because it simplifies logic. For example, the slice <code>s[m:n]</code>, where <code>0 ≤ m ≤ n ≤ len(s)</code>, contains <code>n-m</code> elements.</p>
<p>The first element of <code>os.Args</code>, <code>os.Args[0]</code>, is the name of the command itself; the other elements are the arguments that were presented to the program when it started execution. A slice expression of the form <code>s[m:n]</code> yields a slice that refers to elements <code>m</code> through <code>n-1</code>, so the elements we need for our next example are those in the slice <code>os.Args[1:len(os.Args)]</code>. If <code>m</code> or <code>n</code> is omitted, it defaults to 0 or <code>len(s)</code> respectively, so we can abbreviate the desired slice as <code>os.Args[1:]</code>.</p>
<p>Here’s an implementation of the Unix <code class="command" >echo</code> command, which prints its command-line arguments on a single line. It imports two packages, which are given as a parenthesized list rather than as individual import declarations. Either form is legal, but conventionally the list form is used. The order of imports doesn’t matter; the <code class="command" >gofmt</code> tool sorts the package names into alphabetical order. (When there are several versions of an example, we will often number them so you can be sure of which one we’re talking about.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/echo1/main.go" >gopl.io/ch1/echo1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Echo1 prints its command-line arguments.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">sep</span> <span class="p">=</span> <span class="s">&#34; &#34;</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Comments begin with <code>//</code>. All text from a <code>//</code> to the end of the line is commentary for programmers and is ignored by the compiler. By convention, we describe each package in a comment immediately preceding its package declaration; for a <code>main</code> package, this comment is one or more complete sentences that describe the program as a whole.</p>
<p>The <code>var</code> declaration declares two variables <code>s</code> and <code>sep</code>, of type <code>string</code>. A variable can be initialized as part of its declaration. If it is not explicitly initialized, it is implicitly initialized to the <em>zero value</em> for its type, which is <code>0</code> for numeric types and the empty string <code>&#34;&#34;</code> for strings.  Thus in this example, the declaration implicitly initializes <code>s</code> and <code>sep</code> to empty strings. We’ll have more to say about variables and declarations in <a href="#chapter-2" >Chapter 2</a>.</p>
<p>For numbers, Go provides the usual arithmetic and logical operators. When applied to strings, however, the <code>+</code> operator <em>concatenates</em> the values, so the expression</p>
<pre class="code" ><code class="chroma" ><span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</code></pre>
<p>represents the concatenation of the strings <code>sep</code> and <code>os.Args[i]</code>. The statement we used in the program,</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</code></pre>
<p>is an <em>assignment statement</em> that concatenates the old value of <code>s</code> with <code>sep</code> and <code>os.Args[i]</code> and assigns it back to <code>s</code>; it is equivalent to</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span> <span class="o">+</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</code></pre>
<p>The operator <code>+=</code> is an <em>assignment operator</em>. Each arithmetic and logical operator like <code>+</code> or <code>*</code> has a corresponding assignment operator.</p>
<p>The <code class="command" >echo</code> program could have printed its output in a loop one piece at a time, but this version instead builds up a string by repeatedly appending new text to the end. The string <code>s</code> starts life empty, that is, with value <code>&#34;&#34;</code>, and each trip through the loop adds some text to it; after the first iteration, a space is also inserted so that when the loop is finished, there is one space between each argument. This is a quadratic process that could be costly if the number of arguments is large, but for <code class="command" >echo</code>, that’s unlikely. We’ll show a number of improved versions of <code class="command" >echo</code> in this chapter and the next that will deal with any real inefficiency.</p>
<p>The loop index variable <code>i</code> is declared in the first part of the <code>for</code> loop. The <code>:=</code> symbol is part of a <em>short variable declaration</em>, a statement that declares one or more variables and gives them appropriate types based on the initializer values; there’s more about this in the next chapter.</p>
<p>The increment statement <code>i++</code> adds 1 to <code>i</code>; it’s equivalent to <code>i += 1</code> which is in turn equivalent to <code>i = i + 1</code>. There’s a corresponding decrement statement <code>i--</code> that subtracts 1. These are statements, not expressions as they are in most languages in the C family, so <code>j = i++</code> is illegal, and they are postfix only, so <code>--i</code> is not legal either.</p>
<p>The <code>for</code> loop is the only loop statement in Go. It has a number of forms, one of which is illustrated here:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">initialization</span><span class="p">;</span> <span class="nx">condition</span><span class="p">;</span> <span class="nx">post</span> <span class="p">{</span>
    <span class="c1">// zero or more statements
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Parentheses are never used around the three components of a <code>for</code> loop. The braces are mandatory, however, and the opening brace must be on the same line as the <code>post</code> statement.</p>
<p>The optional <code>initialization</code> statement is executed before the loop starts. If it is present, it must be a <em>simple statement</em>, that is, a short variable declaration, an increment or assignment statement, or a function call. The <code>condition</code> is a boolean expression that is evaluated at the beginning of each iteration of the loop; if it evaluates to <code>true</code>, the statements controlled by the loop are executed. The <code>post</code> statement is executed after the body of the loop, then the <code>condition</code> is evaluated again. The loop ends when the condition becomes false.</p>
<p>Any of these parts may be omitted. If there is no <code>initialization</code> and no <code>post</code>, the semicolons may also be omitted:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// a traditional &#34;while&#34; loop
</span><span class="c1"></span><span class="k">for</span> <span class="nx">condition</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>If the condition is omitted entirely in any of these forms, for example in</p>
<pre class="code" ><code class="chroma" ><span class="c1">// a traditional infinite loop
</span><span class="c1"></span><span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>the loop is infinite, though loops of this form may be terminated in some other way, like a <code>break</code> or <code>return</code> statement.</p>
<p>Another form of the <code>for</code> loop iterates over a <em>range</em> of values from a data type like a string or a slice. To illustrate, here’s a second version of <code class="command" >echo</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/echo2/main.go" >gopl.io/ch1/echo2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Echo2 prints its command-line arguments.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">arg</span>
    <span class="nx">sep</span> <span class="p">=</span> <span class="s">&#34; &#34;</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In each iteration of the loop, <code>range</code> produces a pair of values: the index and the value of the element at that index. In this example, we don’t need the index, but the syntax of a <code>range</code> loop requires that if we deal with the element, we must deal with the index too. One idea would be to assign the index to an obviously temporary variable like <code>temp</code> and ignore its value, but Go does not permit unused local variables, so this would result in a compilation error.</p>
<p>The solution is to use the <em>blank identifier</em>, whose name is <code>_</code> (that is, an underscore). The blank identifier may be used whenever syntax requires a variable name but program logic does not, for instance to discard an unwanted loop index when we require only the element value. Most Go programmers would likely use <code>range</code> and <code>_</code> to write the <code class="command" >echo</code> program as above, since the indexing over <code>os.Args</code> is implicit, not explicit, and thus easier to get right.</p>
<p>This version of the program uses a short variable declaration to declare and initialize <code>s</code> and <code>sep</code>, but we could equally well have declared the variables separately. There are several ways to declare a string variable; these are all equivalent:</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
</code></pre>
<p>Why should you prefer one form to another? The first form, a short variable declaration, is the most compact, but it may be used only within a function, not for package-level variables.  The second form relies on default initialization to the zero value for strings, which is <code>&#34;&#34;</code>. The third form is rarely used except when declaring multiple variables. The fourth form is explicit about the variable’s type, which is redundant when it is the same as that of the initial value but necessary in other cases where they are not of the same type. In practice, you should generally use one of the first two forms, with explicit initialization to say that the initial value is important and implicit initialization to say that the initial value doesn’t matter.</p>
<p>As noted above, each time around the loop, the string <code>s</code> gets completely new contents. The <code>+=</code> statement makes a new string by concatenating the old string, a space character, and the next argument, then assigns the new string to <code>s</code>. The old contents of <code>s</code> are no longer in use, so they will be garbage-collected in due course.</p>
<p>If the amount of data involved is large, this could be costly. A simpler and more efficient solution would be to use the <code>Join</code> function from the <code>strings</code> package:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/echo3/main.go" >gopl.io/ch1/echo3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s">&#34; &#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Finally, if we don’t care about format but just want to see the values, perhaps for debugging, we can let <code>Println</code> format the results for us:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre>
<p>The output of this statement is like what we would get from <code>strings.Join</code>, but with surrounding brackets. Any slice may be printed this way.</p>
<p><b>Exercise 1.1</b>: Modify the <code class="command" >echo</code> program to also print <code>os.Args[0]</code>, the name of the command that invoked it.</p>
<p><b>Exercise 1.2</b>: Modify the <code class="command" >echo</code> program to print the index and value of each of its arguments, one per line.</p>
<p><b>Exercise 1.3</b>: Experiment to measure the difference in running time between our potentially inefficient versions and the one that uses <code>strings.Join</code>. (<a href="#section-1.6" >Section 1.6</a> illustrates part of the <code>time</code> package, and <a href="#section-11.4" >Section 11.4</a> shows how to write benchmark tests for systematic performance evaluation.)</p>
</div>
<h3 id="section-1.3" >Finding Duplicate Lines</h3>
<div class="hBody-3" >
<p>Programs for file copying, printing, searching, sorting, counting, and the like all have a similar structure: a loop over the input, some computation on each element, and generation of output on the fly or at the end. We’ll show three variants of a program called <code class="command" >dup</code>; it is partly inspired by the Unix <code class="command" >uniq</code> command, which looks for adjacent duplicate lines. The structures and packages used are models that can be easily adapted.</p>
<p>The first version of <code class="command" >dup</code> prints each line that appears more than once in the standard input, preceded by its count. This program introduces the <code>if</code> statement, the <code>map</code> data type, and the <code>bufio</code> package.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/dup1/main.go" >gopl.io/ch1/dup1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Dup1 prints the text of each line that appears more than
</span><span class="c1">// once in the standard input, preceded by its count.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;bufio&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>As with <code>for</code>, parentheses are never used around the condition in an <code>if</code> statement, but braces are required for the body. There can be an optional <code>else</code> part that is executed if the condition is false.</p>
<p>A <em>map</em> holds a set of key/value pairs and provides constant-time operations to store, retrieve, or test for an item in the set. The key may be of any type whose values can be compared with <code>==</code>, strings being the most common example; the value may be of any type at all. In this example, the keys are <code>string</code>s and the values are <code>int</code>s. The built-in function <code>make</code> creates a new empty map; it has other uses too. Maps are discussed at length in <a href="#section-4.3" >Section 4.3</a>.</p>
<p>Each time <code class="command" >dup</code> reads a line of input, the line is used as a key into the map and the corresponding value is incremented. The statement <code>counts[input.Text()]++</code> is equivalent to these two statements:</p>
<pre class="code" ><code class="chroma" ><span class="nx">line</span> <span class="o">:=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
<span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="p">=</span> <span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre>
<p>It’s not a problem if the map doesn’t yet contain that key. The first time a new line is seen, the expression <code>counts[line]</code> on the right-hand side evaluates to the zero value for its type, which is 0 for <code>int</code>.</p>
<p>To print the results, we use another <code>range</code>-based <code>for</code> loop, this time over the <code>counts</code> map. As before, each iteration produces two results, a key and the value of the map element for that key. The order of map iteration is not specified, but in practice it is random, varying from one run to another. This design is intentional, since it prevents programs from relying on any particular ordering where none is guaranteed.</p>
<p>Onward to the <code>bufio</code> package, which helps make input and output efficient and convenient.  One of its most useful features is a type called <code>Scanner</code> that reads input and breaks it into lines or words; it’s often the easiest way to process input that comes naturally in lines.</p>
<p>The program uses a short variable declaration to create a new variable input that refers to a <code>bufio.Scanner</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
</code></pre>
<p>The scanner reads from the program’s standard input. Each call to <code>input.Scan()</code> reads the next line and removes the newline character from the end; the result can be retrieved by calling <code>input.Text()</code>. The <code>Scan</code> function returns <code>true</code> if there is a line and <code>false</code> when there is no more input.</p>
<p>The function <code>fmt.Printf</code>, like <code>printf</code> in C and other languages, produces formatted output from a list of expressions. Its first argument is a format string that specifies how subsequent arguments should be formatted. The format of each argument is determined by a conversion character, a letter following a percent sign. For example, <code>%d</code> formats an integer operand using decimal notation, and <code>%s</code> expands to the value of a string operand.</p>
<p><code>Printf</code> has over a dozen such conversions, which Go programmers call <em>verbs</em>. This table is far from a complete specification but illustrates many of the features that are available:</p>
<table border="1">
<tbody>
<tr><td><p><code>%d</code></p>
</td><td><p>decimal integer</p>
</td></tr>
<tr><td><p><code>%x</code>, <code>%o</code>, <code>%b</code></p>
</td><td><p>integer in hexadecimal, octal, binary</p>
</td></tr>
<tr><td><p><code>%f</code>, <code>%g</code>, <code>%e</code></p>
</td><td><p>floating-point number: 3.141593 3.141592653589793 3.141593e+00</p>
</td></tr>
<tr><td><p><code>%t</code></p>
</td><td><p>boolean: <code>true</code> or <code>false</code></p>
</td></tr>
<tr><td><p><code>%c</code></p>
</td><td><p>rune (Unicode code point)</p>
</td></tr>
<tr><td><p><code>%s</code></p>
</td><td><p>string</p>
</td></tr>
<tr><td><p><code>%q</code></p>
</td><td><p>quoted string <code>&#34;abc&#34;</code> or rune <code>&#39;c&#39;</code></p>
</td></tr>
<tr><td><p><code>%v</code></p>
</td><td><p>any value in a natural format</p>
</td></tr>
<tr><td><p><code>%T</code></p>
</td><td><p>type of any value</p>
</td></tr>
<tr><td><p><code>%%</code></p>
</td><td><p>literal percent sign (no operand)</p>
</td></tr>
</tbody>
</table>
<p>The format string in <code>dup1</code> also contains a tab <code>\t</code> and a newline <code>\n</code>. String literals may contain such <em>escape sequences</em> for representing otherwise invisible characters. <code>Printf</code> does not write a newline by default. By convention, formatting functions whose names end in <code>f</code>, such as <code>log.Printf</code> and <code>fmt.Errorf</code>, use the formatting rules of <code>fmt.Printf</code>, whereas those whose names end in <code>ln</code> follow <code>Println</code>, formatting their arguments as if by <code>%v</code>, followed by a newline.</p>
<p>Many programs read either from their standard input, as above, or from a sequence of named files. The next version of <code>dup</code> can read from the standard input or handle a list of file names, using <code>os.Open</code> to open each one:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/dup2/main.go" >gopl.io/ch1/dup2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Dup2 prints the count and text of lines that appear more than once
</span><span class="c1">// in the input.  It reads from stdin or from a list of named files.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;bufio&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="nx">files</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">countLines</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="nx">counts</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
      <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;dup2: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="nx">countLines</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">counts</span><span class="p">)</span>
      <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">countLines</span><span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">counts</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>The function <code>os.Open</code> returns two values. The first is an open file (<code>*os.File</code>) that is used in subsequent reads by the <code>Scanner</code>.</p>
<p>The second result of <code>os.Open</code> is a value of the built-in <code>error</code> type. If <code>err</code> equals the special built-in value <code>nil</code>, the file was opened successfully. The file is read, and when the end of the input is reached, <code>Close</code> closes the file and releases any resources. On the other hand, if <code>err</code> is not <code>nil</code>, something went wrong. In that case, the error value describes the problem. Our simple-minded error handling prints a message on the standard error stream using <code>Fprintf</code> and the verb <code>%v</code>, which displays a value of any type in a default format, and <code class="command" >dup</code> then carries on with the next file; the <code>continue</code> statement goes to the next iteration of the enclosing <code>for</code> loop.</p>
<p>In the interests of keeping code samples to a reasonable size, our early examples are intentionally somewhat cavalier about error handling. Clearly we must check for an error from <code>os.Open</code>; however, we are ignoring the less likely possibility that an error could occur while reading the file with <code>input.Scan</code>. We will note places where we’ve skipped error checking, and we will go into the details of error handling in <a href="#section-5.4" >Section 5.4</a>.</p>
<p>Notice that the call to <code>countLines</code> precedes its declaration. Functions and other package-level entities may be declared in any order.</p>
<p>A map is a <em>reference</em> to the data structure created by <code>make</code>. When a map is passed to a function, the function receives a copy of the reference, so any changes the called function makes to the underlying data structure will be visible through the caller’s map reference too. In our example, the values inserted into the <code>counts</code> map by <code>countLines</code> are seen by <code>main</code>.</p>
<p>The versions of <code class="command" >dup</code> above operate in a <q>streaming</q> mode in which input is read and broken into lines as needed, so in principle these programs can handle an arbitrary amount of input. An alternative approach is to read the entire input into memory in one big gulp, split it into lines all at once, then process the lines. The following version, <code class="command" >dup3</code>, operates in that fashion. It introduces the function <code>ReadFile</code> (from the <code>io/ioutil</code> package), which reads the entire contents of a named file, and <code>strings.Split</code>, which splits a string into a slice of substrings. (<code>Split</code> is the opposite of <code>strings.Join</code>, which we saw earlier.)</p>
<p>We’ve simplified <code class="command" >dup3</code> somewhat. First, it only reads named files, not the standard input, since <code>ReadFile</code> requires a file name argument. Second, we moved the counting of the lines back into <code>main</code>, since it is now needed in only one place.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/dup3/main.go" >gopl.io/ch1/dup3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io/ioutil&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;dup3: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">line</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%s\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p><code>ReadFile</code> returns a byte slice that must be converted into a <code>string</code> so it can be split by <code>strings.Split</code>. We will discuss strings and byte slices at length in <a href="#section-3.5.4" >Section 3.5.4</a>.</p>
<p>Under the covers, <code>bufio.Scanner</code>, <code>ioutil.ReadFile</code>, and <code>ioutil.WriteFile</code> use the <code>Read</code> and <code>Write</code> methods of <code>*os.File</code>, but it’s rare that most programmers need to access those lower-level routines directly. The higher-level functions like those from <code>bufio</code> and <code>io/ioutil</code> are easier to use.</p>
<p><b>Exercise 1.4</b>: Modify <code class="command" >dup2</code> to print the names of all files in which each duplicated line occurs.</p>
</div>
<h3 id="section-1.4" >Animated GIFs</h3>
<div class="hBody-3" >
<p>The next program demonstrates basic usage of Go’s standard image packages, which we’ll use to create a sequence of bit-mapped images and then encode the sequence as a GIF animation. The images, called <em>Lissajous figures</em>, were a staple visual effect in sci-fi films of the 1960s. They are the parametric curves produced by harmonic oscillation in two dimensions, such as two sine waves fed into the <span class="math" >x</span> and <span class="math" >y</span> inputs of an oscilloscope. Figure 1.1 shows some examples.</p>
<div class="figure" >
<h1 class="figure">Figure 1.1. Four Lissajous figures.</h1>
<figure>
<img src="img/Figure-1.1.jpg" />
</figure>
</div>
<p>There are several new constructs in this code, including <code>const</code> declarations, struct types, and composite literals. Unlike most of our examples, this one also involves floating-point computations. We’ll discuss these topics only briefly here, pushing most details off to later chapters, since the primary goal right now is to give you an idea of what Go looks like and the kinds of things that can be done easily with the language and its libraries.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/lissajous/main.go" >gopl.io/ch1/lissajous</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Lissajous generates GIF animations of random Lissajous figures.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;image&#34;</span>
  <span class="s">&#34;image/color&#34;</span>
  <span class="s">&#34;image/gif&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;math&#34;</span>
  <span class="s">&#34;math/rand&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">palette</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">color</span><span class="p">.</span><span class="nx">Color</span><span class="p">{</span><span class="nx">color</span><span class="p">.</span><span class="nx">White</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Black</span><span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">whiteIndex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// first color in palette
</span><span class="c1"></span>  <span class="nx">blackIndex</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// next color in palette
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// The sequence of images is deterministic unless we seed
</span><span class="c1"></span>  <span class="c1">// the pseudo-random number generator using the current time.
</span><span class="c1"></span>  <span class="nx">rand</span><span class="p">.</span><span class="nx">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">UTC</span><span class="p">().</span><span class="nx">UnixNano</span><span class="p">())</span>

  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">lissajous</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">cycles</span>  <span class="p">=</span> <span class="mi">5</span>     <span class="c1">// number of complete x oscillator revolutions
</span><span class="c1"></span>    <span class="nx">res</span>     <span class="p">=</span> <span class="mf">0.001</span> <span class="c1">// angular resolution
</span><span class="c1"></span>    <span class="nx">size</span>    <span class="p">=</span> <span class="mi">100</span>   <span class="c1">// image canvas covers [-size..+size]
</span><span class="c1"></span>    <span class="nx">nframes</span> <span class="p">=</span> <span class="mi">64</span>    <span class="c1">// number of animation frames
</span><span class="c1"></span>    <span class="nx">delay</span>   <span class="p">=</span> <span class="mi">8</span>     <span class="c1">// delay between frames in 10ms units
</span><span class="c1"></span>  <span class="p">)</span>
  <span class="nx">freq</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Float64</span><span class="p">()</span> <span class="o">*</span> <span class="mf">3.0</span> <span class="c1">// relative frequency of y oscillator
</span><span class="c1"></span>  <span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
  <span class="nx">phase</span> <span class="o">:=</span> <span class="mf">0.0</span> <span class="c1">// phase difference
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nframes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">rect</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">img</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewPaletted</span><span class="p">(</span><span class="nx">rect</span><span class="p">,</span> <span class="nx">palette</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
      <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
      <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="nx">blackIndex</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">phase</span> <span class="o">+=</span> <span class="mf">0.1</span>
    <span class="nx">anim</span><span class="p">.</span><span class="nx">Delay</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">anim</span><span class="p">.</span><span class="nx">Delay</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span>
    <span class="nx">anim</span><span class="p">.</span><span class="nx">Image</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">anim</span><span class="p">.</span><span class="nx">Image</span><span class="p">,</span> <span class="nx">img</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">gif</span><span class="p">.</span><span class="nx">EncodeAll</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">anim</span><span class="p">)</span> <span class="c1">// NOTE: ignoring encoding errors
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>After importing a package whose path has multiple components, like <code>image/color</code>, we refer to the package with a name that comes from the last component. Thus the variable <code>color.White</code> belongs to the <code>image/color</code> package and <code>gif.GIF</code> belongs to <code>image/gif</code>.</p>
<p>A <code>const</code> declaration (<a href="#section-3.6" >§3.6</a>) gives names to constants, that is, values that are fixed at compile time, such as the numerical parameters for cycles, frames, and delay. Like <code>var</code> declarations, <code>const</code> declarations may appear at package level (so the names are visible throughout the package) or within a function (so the names are visible only within that function). The value of a constant must be a number, string, or boolean.</p>
<p>The expressions <code>[]color.Color{...}</code> and <code>gif.GIF{...}</code> are <em>composite literals</em> (<a href="#section-4.2" >§4.2</a>, <a href="#section-4.4.1" >§4.4.1</a>), a compact notation for instantiating any of Go’s composite types from a sequence of element values. Here, the first one is a slice and the second one is a <em>struct</em>.</p>
<p>The type <code>gif.GIF</code> is a struct type (<a href="#section-4.4" >§4.4</a>). A struct is a group of values called <em>fields</em>, often of different types, that are collected together in a single object that can be treated as a unit. The variable <code>anim</code> is a struct of type <code>gif.GIF</code>. The struct literal creates a struct value whose <code>LoopCount</code> field is set to <code>nframes</code>; all other fields have the zero value for their type. The individual fields of a struct can be accessed using dot notation, as in the final two assignments which explicitly update the <code>Delay</code> and <code>Image</code> fields of <code>anim</code>.</p>
<p>The <code>lissajous</code> function has two nested loops. The outer loop runs for 64 iterations, each producing a single frame of the animation. It creates a new 201x201 image with a palette of two colors, white and black. All pixels are initially set to the palette’s zero value (the zeroth color in the palette), which we set to white. Each pass through the outer loop generates a new image by setting some pixels to black. The result is appended, using the built-in <code>append</code> function (<a href="#section-4.2.1" >§4.2.1</a>), to a list of frames in <code>anim</code>, along with a specified delay of 80ms. Finally the sequence of frames and delays is encoded into GIF format and written to the output stream <code>out</code>. The type of <code>out</code> is <code>io.Writer</code>, which lets us write to a wide range of possible destinations, as we’ll show soon.</p>
<p>The inner loop runs the two oscillators. The <code>x</code> oscillator is just the sine function. The <code>y</code> oscillator is also a sinusoid, but its frequency relative to the <code>x</code> oscillator is a random number between 0 and 3, and its phase relative to the <code>x</code> oscillator is initially zero but increases with each frame of the animation. The loop runs until the <code>x</code> oscillator has completed five full cycles. At each step, it calls <code>SetColorIndex</code> to color the pixel corresponding to (<code>x</code>, <code>y</code>) black, which is at position 1 in the palette.</p>
<p>The <code>main</code> function calls the <code>lissajous</code> function, directing it to write to the standard output, so this command produces an animated GIF with frames like those in Figure 1.1:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/lissajous
</span><span class="in" ><span class="prompt" >&gt; </span>./lissajous &gt;out.gif
</span></code></pre>
<p><b>Exercise 1.5</b>: Change the Lissajous program’s color palette to green on black, for added authenticity. To create the web color <code>#RRGGBB</code>, use <code>color.RGBA{0xRR, 0xGG, 0xBB, 0xff}</code>, where each pair of hexadecimal digits represents the intensity of the red, green, or blue component of the pixel.</p>
<p><b>Exercise 1.6</b>: Modify the Lissajous program to produce images in multiple colors by adding more values to palette and then displaying them by changing the third argument of <code>SetColorIndex</code> in some interesting way.</p>
</div>
<h3 id="section-1.5" >Fetching a URL</h3>
<div class="hBody-3" >
<p>For many applications, access to information from the Internet is as important as access to the local file system. Go provides a collection of packages, grouped under <code>net</code>, that make it easy to send and receive information through the Internet, make low-level network connections, and set up servers, for which Go’s concurrency features (introduced in <a href="#chapter-8" >Chapter 8</a>) are particularly useful.</p>
<p>To illustrate the minimum necessary to retrieve information over HTTP, here’s a simple program called <code class="command" >fetch</code> that fetches the content of each specified URL and prints it as uninterpreted text; it’s inspired by the invaluable utility <code class="command" >curl</code>. Obviously one would usually do more with such data, but this shows the basic idea. We will use this program frequently in the book.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/fetch/main.go" >gopl.io/ch1/fetch</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Fetch prints the content found at each specified URL.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io/ioutil&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;fetch: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;fetch: reading %s: %v\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This program introduces functions from two packages, <code>net/http</code> and <code>io/ioutil</code>. The <code>http.Get</code> function makes an HTTP request and, if there is no error, returns the result in the response struct <code>resp</code>. The <code>Body</code> field of <code>resp</code> contains the server response as a readable stream. Next, <code>ioutil.ReadAll</code> reads the entire response; the result is stored in <code>b</code>. The <code>Body</code> stream is closed to avoid leaking resources, and <code>Printf</code> writes the response to the standard output.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://gopl.io
</span><span class="out" >&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Go Programming Language&lt;/title&gt;
...
</span></code></pre>
<p>If the HTTP request fails, <code class="command" >fetch</code> reports the failure instead:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./fetch http://bad.gopl.io
</span><span class="out" >fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
</span></code></pre>
<p>In either error case, <code>os.Exit(1)</code> causes the process to exit with a status code of 1.</p>
<p><b>Exercise 1.7</b>: The function call <code>io.Copy(dst, src)</code> reads from <code>src</code> and writes to <code>dst</code>. Use it instead of <code>ioutil.ReadAll</code> to copy the response body to <code>os.Stdout</code> without requiring a buffer large enough to hold the entire stream. Be sure to check the error result of <code>io.Copy</code>.</p>
<p><b>Exercise 1.8</b>: Modify <code class="command" >fetch</code> to add the prefix <code>http://</code> to each argument URL if it is missing. You might want to use <code>strings.HasPrefix</code>.</p>
<p><b>Exercise 1.9</b>: Modify <code class="command" >fetch</code> to also print the HTTP status code, found in <code>resp.Status</code>.</p>
</div>
<h3 id="section-1.6" >Fetching URLs Concurrently</h3>
<div class="hBody-3" >
<p>One of the most interesting and novel aspects of Go is its support for concurrent programming. This is a large topic, to which <a href="#chapter-8" >Chapter 8</a> and Chapter 9 are devoted, so for now we’ll give you just a taste of Go’s main concurrency mechanisms, goroutines and channels.</p>
<p>The next program, <code class="command" >fetchall</code>, does the same fetch of a URL’s contents as the previous example, but it fetches many URLs, all concurrently, so that the process will take no longer than the longest fetch rather than the sum of all the fetch times. This version of <code class="command" >fetchall</code> discards the responses but reports the size and elapsed time for each one:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/fetchall/main.go" >gopl.io/ch1/fetchall</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Fetchall fetches URLs in parallel and reports their times and sizes.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;io/ioutil&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span> <span class="c1">// start a goroutine
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">for</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// receive from channel ch
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%.2fs elapsed\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nx">Seconds</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// send to channel ch
</span><span class="c1"></span>    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// don&#39;t leak resources
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;while reading %s: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">secs</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nx">Seconds</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%.2fs  %7d  %s&#34;</span><span class="p">,</span> <span class="nx">secs</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Here’s an example:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetchall
</span><span class="in" ><span class="prompt" >&gt; </span>./fetchall https://golang.org http://gopl.io https://godoc.org
</span><span class="out" >0.14s     6852 https://godoc.org
0.16s     7261 https://golang.org
0.48s     2475 http://gopl.io
0.48s elapsed
</span></code></pre>
<p>A <em>goroutine</em> is a concurrent function execution. A <em>channel</em> is a communication mechanism that allows one goroutine to pass values of a specified type to another goroutine. The function <code>main</code> runs in a goroutine and the <code>go</code> statement creates additional goroutines.</p>
<p>The <code>main</code> function creates a channel of strings using <code>make</code>. For each command-line argument, the <code>go</code> statement in the first range loop starts a new goroutine that calls <code>fetch</code> asynchronously to fetch the URL using <code>http.Get</code>. The <code>io.Copy</code> function reads the body of the response and discards it by writing to the <code>ioutil.Discard</code> output stream. <code>Copy</code> returns the byte count, along with any error that occurred. As each result arrives, <code>fetch</code> sends a summary line on the channel <code>ch</code>. The second range loop in <code>main</code> receives and prints those lines.</p>
<p>When one goroutine attempts a send or receive on a channel, it blocks until another goroutine attempts the corresponding receive or send operation, at which point the value is transferred and both goroutines proceed. In this example, each <code>fetch</code> sends a value (<code>ch &lt;-</code> <em>expression</em>) on the channel <code>ch</code>, and <code>main</code> receives all of them (<code>&lt;-ch</code>). Having <code>main</code> do all the printing ensures that output from each goroutine is processed as a unit, with no danger of interleaving if two goroutines finish at the same time.</p>
<p><b>Exercise 1.10</b>: Find a web site that produces a large amount of data. Investigate caching by running <code>fetchall</code> twice in succession to see whether the reported time changes much. Do you get the same content each time? Modify <code>fetchall</code> to print its output to a file so it can be examined.</p>
<p><b>Exercise 1.11</b>: Try <code>fetchall</code> with longer argument lists, such as samples from the top million web sites available at <a href="http://www.alexa.com/" >alexa.com</a>. How does the program behave if a web site just doesn’t respond? (<a href="#section-8.9" >Section 8.9</a> describes mechanisms for coping in such cases.)</p>
</div>
<h3 id="section-1.7" >A Web Server</h3>
<div class="hBody-3" >
<p>Go’s library makes it easy to write a web server that responds to client requests like those made by <code class="command" >fetch</code>. In this section, we’ll show a minimal server that returns the path component of the URL used to access the server. That is, if the request is for <code>http://localhost:8000/hello</code>, the response will be <code>URL.Path = &#34;/hello&#34;</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/server1/main.go" >gopl.io/ch1/server1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Server1 is a minimal &#34;echo&#34; server.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="c1">// each request calls handler
</span><span class="c1"></span>  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8000&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// handler echoes the Path component of the requested URL.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;URL.Path = %q\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The program is only a handful of lines long because library functions do most of the work. The <code>main</code> function connects a handler function to incoming URLs that begin with <code>/</code>, which is all URLs, and starts a server listening for incoming requests on port 8000. A request is represented as a struct of type <code>http.Request</code>, which contains a number of related fields, one of which is the URL of the incoming request. When a request arrives, it is given to the handler function, which extracts the path component (<code>/hello</code>) from the request URL and sends it back as the response, using <code>fmt.Fprintf</code>. Web servers will be explained in detail in <a href="#section-7.7" >Section 7.7</a>.</p>
<p>Let’s start the server in the background. On Mac OS X or Linux, add an ampersand (<code>&amp;</code>) to the command; on Microsoft Windows, you will need to run the command without the ampersand in a separate command window.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run src/gopl.io/ch1/server1/main.go <span class="p">&amp;</span>
</span></code></pre>
<p>We can then make client requests from the command line:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000
</span><span class="out" >URL.Path = &#34;/&#34;
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/help
</span><span class="out" >URL.Path = &#34;/help&#34;
</span></code></pre>
<p>Alternatively, we can access the server from a web browser, as shown in Figure 1.2.</p>
<div class="figure" >
<h1 class="figure">Figure 1.2. A response from the echo server.</h1>
<figure>
<img src="img/Figure-1.2.jpg" />
</figure>
</div>
<p>It’s easy to add features to the server. One useful addition is a specific URL that returns a status of some sort. For example, this version does the same echo but also counts the number of requests; a request to the URL <code>/count</code> returns the count so far, excluding <code>/count</code> requests themselves:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/server2/main.go" >gopl.io/ch1/server2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Server2 is a minimal &#34;echo&#34; and counter server.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
  <span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/count&#34;</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8000&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// handler echoes the Path component of the requested URL.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">count</span><span class="o">++</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;URL.Path = %q\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// counter echoes the number of calls so far.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Count %d\n&#34;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The server has two handlers, and the request URL determines which one is called: a request for <code>/count</code> invokes <code>counter</code> and all others invoke <code>handler</code>. A handler pattern that ends with a slash matches any URL that has the pattern as a prefix. Behind the scenes, the server runs the handler for each incoming request in a separate goroutine so that it can serve multiple requests simultaneously. However, if two concurrent requests try to update <code>count</code> at the same time, it might not be incremented consistently; the program would have a serious bug called a <em>race condition</em> (<a href="#section-9.1" >§9.1</a>). To avoid this problem, we must ensure that at most one goroutine accesses the variable at a time, which is the purpose of the <code>mu.Lock()</code> and <code>mu.Unlock()</code> calls that bracket each access of <code>count</code>. We’ll look more closely at concurrency with shared variables in <a href="#chapter-9" >Chapter 9</a>.</p>
<p>As a richer example, the handler function can report on the headers and form data that it receives, making the server useful for inspecting and debugging requests:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch1/server3/main.go" >gopl.io/ch1/server3</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// handler echoes the HTTP request.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s %s %s\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Proto</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Header[%q] = %q\n&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Host = %q\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;RemoteAddr = %q\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Form[%q] = %q\n&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This uses the fields of the <code>http.Request</code> struct to produce output like this:</p>
<div class="pre-block" >
<pre class="pre" >GET /?q=query HTTP/1.1
Header[&#34;Accept-Encoding&#34;] = [&#34;gzip, deflate, sdch&#34;]
Header[&#34;Accept-Language&#34;] = [&#34;en-US,en;q=0.8&#34;]
Header[&#34;Connection&#34;] = [&#34;keep-alive&#34;]
Header[&#34;Accept&#34;] = [&#34;text/html,application/xhtml+xml,application/xml;...&#34;]
Header[&#34;User-Agent&#34;] = [&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)...&#34;]
Host = &#34;localhost:8000&#34;
RemoteAddr = &#34;127.0.0.1:59911&#34;
Form[&#34;q&#34;] = [&#34;query&#34;]
</pre>
</div>
<p>Notice how the call to <code>ParseForm</code> is nested within an <code>if</code> statement. Go allows a simple statement such as a local variable declaration to precede the <code>if</code> condition, which is particularly useful for error handling as in this example. We could have written it as</p>
<pre class="code" ><code class="chroma" ><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>but combining the statements is shorter and reduces the scope of the variable <code>err</code>, which is good practice. We’ll define scope in <a href="#section-2.7" >Section 2.7</a>.</p>
<p>In these programs, we’ve seen three very different types used as output streams. The <code class="command" >fetch</code> program copied HTTP response data to <code>os.Stdout</code>, a file, as did the <code class="command" >lissajous</code> program. The <code class="command" >fetchall</code> program threw the response away (while counting its length) by copying it to the trivial sink <code>ioutil.Discard</code>. And the web server above used <code>fmt.Fprintf</code> to write to an <code>http.ResponseWriter</code> representing the web browser.</p>
<p>Although these three types differ in the details of what they do, they all satisfy a common <em>interface</em>, allowing any of them to be used wherever an output stream is needed. That interface, called <code>io.Writer</code>, is discussed in <a href="#section-7.1" >Section 7.1</a>.</p>
<p>Go’s interface mechanism is the topic of <a href="#chapter-7" >Chapter 7</a>, but to give an idea of what it’s capable of, let’s see how easy it is to combine the web server with the <code>lissajous</code> function so that animated GIFs are written not to the standard output, but to the HTTP client. Just add these lines to the web server:</p>
<pre class="code" ><code class="chroma" ><span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</code></pre>
<p>or equivalently:</p>
<pre class="code" ><code class="chroma" ><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>
<p>The second argument to the <code>HandleFunc</code> function call immediately above is a <em>function literal</em>, that is, an anonymous function defined at its point of use. We will explain it further in <a href="#section-5.6" >Section 5.6</a>.</p>
<p>Once you’ve made this change, visit <a href="http://localhost:8000" >http://localhost:8000</a> in your browser. Each time you load the page, you’ll see a new animation like the one in Figure 1.3.</p>
<p><b>Exercise 1.12</b>: Modify the Lissajous server to read parameter values from the URL. For example, you might arrange it so that a URL like <code>http://localhost:8000/?cycles=20</code> sets the number of cycles to 20 instead of the default 5. Use the <code>strconv.Atoi</code> function to convert the string parameter into an integer. You can see its documentation with <code class="command" >go doc strconv.Atoi</code>.</p>
<div class="figure" >
<h1 class="figure">Figure 1.3. Animated Lissajous figures in a browser.</h1>
<figure>
<img src="img/Figure-1.3.jpg" />
</figure>
</div>
</div>
<h3 id="section-1.8" >Loose Ends</h3>
<div class="hBody-3" >
<p>There is a lot more to Go than we’ve covered in this quick introduction. Here are some topics we’ve barely touched upon or omitted entirely, with just enough discussion that they will be familiar when they make brief appearances before the full treatment.</p>
<dl>
<dt>Control flow</dt>
<dd>
<p>We covered the two fundamental control-flow statements, <code>if</code> and <code>for</code>, but not the <code>switch</code> statement, which is a multi-way branch. Here’s a small example:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="nx">coinflip</span><span class="p">()</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;heads&#34;</span><span class="p">:</span>
  <span class="nx">heads</span><span class="o">++</span>
<span class="k">case</span> <span class="s">&#34;tails&#34;</span><span class="p">:</span>
  <span class="nx">tails</span><span class="o">++</span>
<span class="k">default</span><span class="p">:</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;landed on edge!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The result of calling <code>coinflip</code> is compared to the value of each case. Cases are evaluated from top to bottom, so the first matching one is executed. The optional default case matches if none of the other cases does; it may be placed anywhere. Cases do not fall through from one to the next as in C-like languages (though there is a rarely used <code>fallthrough</code> statement that overrides this behavior).</p>
<p>A <code>switch</code> does not need an operand; it can just list the cases, each of which is a boolean expression:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Signum</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">+</span><span class="mi">1</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This form is called a <em>tagless switch</em>; it’s equivalent to <code>switch true</code>.</p>
<p>Like the <code>for</code> and <code>if</code> statements, a <code>switch</code> may include an optional simple statement—a short variable declaration, an increment or assignment statement, or a function call—that can be used to set a value before it is tested.</p>
<p>The <code>break</code> and <code>continue</code> statements modify the flow of control. A <code>break</code> causes control to resume at the next statement after the innermost <code>for</code>, <code>switch</code>, or <code>select</code> statement (which we’ll see later), and as we saw in <a href="#section-1.3" >Section 1.3</a>, a <code>continue</code> causes the innermost <code>for</code> loop to start its next iteration. Statements may be labeled so that <code>break</code> and <code>continue</code> can refer to them, for instance to break out of several nested loops at once or to start the next iteration of the outermost loop. There is even a <code>goto</code> statement, though it’s intended for machine-generated code, not regular use by programmers.</p>
</dd>
<dt>Named types</dt>
<dd>
<p>A <code>type</code> declaration makes it possible to give a name to an existing type. Since struct types are often long, they are nearly always named. A familiar example is the definition of a <code>Point</code> type for a 2-D graphics system:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</code></pre>
<p>Type declarations and named types are covered in <a href="#chapter-2" >Chapter 2</a>.</p>
</dd>
<dt>Pointers</dt>
<dd>
<p>Go provides pointers, that is, values that contain the address of a variable. In some languages, notably C, pointers are relatively unconstrained. In other languages, pointers are disguised as <q>references,</q> and there’s not much that can be done with them except pass them around. Go takes a position somewhere in the middle. Pointers are explicitly visible. The <code>&amp;</code> operator yields the address of a variable, and the <code>*</code> operator retrieves the variable that the pointer refers to, but there is no pointer arithmetic. We’ll explain pointers in <a href="#section-2.3.2" >Section 2.3.2</a>.</p>
</dd>
<dt>Methods and interfaces</dt>
<dd>
<p>A method is a function associated with a named type; Go is unusual in that methods may be attached to almost any named type. Methods are covered in <a href="#chapter-6" >Chapter 6</a>. Interfaces are abstract types that let us treat different concrete types in the same way based on what methods they have, not how they are represented or implemented. Interfaces are the subject of <a href="#chapter-7" >Chapter 7</a>.</p>
</dd>
<dt>Packages</dt>
<dd>
<p>Go comes with an extensive standard library of useful packages, and the Go community has created and shared many more. Programming is often more about using existing packages than about writing original code of one’s own. Throughout the book, we will point out a couple of dozen of the most important standard packages, but there are many more we don’t have space to mention, and we cannot provide anything remotely like a complete reference for any package.</p>
<p>Before you embark on any new program, it’s a good idea to see if packages already exist that might help you get your job done more easily. You can find an index of the standard library packages at <a href="https://golang.org/pkg" >https://golang.org/pkg</a> and the packages contributed by the community at <a href="https://godoc.org" >https://godoc.org</a>. The <code class="command" >go doc</code> tool makes these documents easily accessible from the command line:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc http.ListenAndServe
</span><span class="out" >package http // import &#34;net/http&#34;

func ListenAndServe(addr string, handler Handler) error
    ListenAndServe listens on the TCP network address addr and then
    calls Serve with handler to handle requests on incoming connections.
...
</span></code></pre>
</dd>
<dt>Comments</dt>
<dd>
<p>We have already mentioned documentation comments at the beginning of a program or package. It’s also good style to write a comment before the declaration of each function to specify its behavior. These conventions are important, because they are used by tools like <code class="command" >go doc</code> and <code class="command" >godoc</code> to locate and display documentation (<a href="#section-10.7.4" >§10.7.4</a>).</p>
<p>For comments that span multiple lines or appear within an expression or statement, there is also the <code>/* ... */</code> notation familiar from other languages. Such comments are sometimes used at the beginning of a file for a large block of explanatory text to avoid a <code>//</code> on every line. Within a comment, <code>//</code> and <code>/*</code> have no special meaning, so comments do not nest.</p>
</dd>
</dl>
</div>
<h2 id="chapter-2" >Program Structure</h2>
<div class="hBody-2" >
<p>In Go, as in any other programming language, one builds large programs from a small set of basic constructs. Variables store values. Simple expressions are combined into larger ones with operations like addition and subtraction. Basic types are collected into aggregates like arrays and structs. Expressions are used in statements whose execution order is determined by control-flow statements like <code>if</code> and <code>for</code>. Statements are grouped into functions for isolation and reuse. Functions are gathered into source files and packages.</p>
<p>We saw examples of most of these in the previous chapter. In this chapter, we’ll go into more detail about the basic structural elements of a Go program. The example programs are intentionally simple, so we can focus on the language without getting sidetracked by complicated algorithms or data structures.</p>
</div>
<h3 id="section-2.1" >Names</h3>
<div class="hBody-3" >
<p>The names of Go functions, variables, constants, types, statement labels, and packages follow a simple rule: a name begins with a letter (that is, anything that Unicode deems a letter) or an underscore and may have any number of additional letters, digits, and underscores. Case matters: <code>heapSort</code> and <code>Heapsort</code> are different names.</p>
<p>Go has 25 <em>keywords</em> like <code>if</code> and <code>switch</code> that may be used only where the syntax permits; they can’t be used as names.</p>
<div class="pre-block" >
<pre class="pre" >break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
</pre>
</div>
<p>In addition, there are about three dozen <em>predeclared</em> names like <code>int</code> and <code>true</code> for built-in constants, types, and functions:</p>
<dl>
<dt>Constants</dt>
<dd>
<div class="pre-block" >
<pre class="pre" >true false iota nil
</pre>
</div>
</dd>
<dt>Types</dt>
<dd>
<div class="pre-block" >
<pre class="pre" >int         int8       int16      int32    int64
uint       uint8      uint16     uint32   uint64   uintptr
float32  float64  complex128  complex64
bool        byte        rune     string    error
</pre>
</div>
</dd>
<dt>Functions</dt>
<dd>
<div class="pre-block" >
<pre class="pre" >make       len   cap   new   append   copy   close   delete
complex   real  imag
panic  recover
</pre>
</div>
</dd>
</dl>
<p>These names are not reserved, so you may use them in declarations. We’ll see a handful of places where redeclaring one of them makes sense, but beware of the potential for confusion.</p>
<p>If an entity is declared within a function, it is <em>local</em> to that function. If declared outside of a function, however, it is visible in all files of the package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an upper-case letter, it is <em>exported</em>, which means that it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with <code>Printf</code> in the <code>fmt</code> package. Package names themselves are always in lower case.</p>
<p>There is no limit on name length, but convention and style in Go programs lean toward short names, especially for local variables with small scopes; you are much more likely to see variables named <code>i</code> than <code>theLoopIndex</code>. Generally, the larger the scope of a name, the longer and more meaningful it should be.</p>
<p>Stylistically, Go programmers use <q>camel case</q> when forming names by combining words; that is, interior capital letters are preferred over interior underscores. Thus the standard libraries have functions with names like <code>QuoteRuneToASCII</code> and <code>parseRequestLine</code> but never <code>quote_rune_to_ASCII</code> or <code>parse_request_line</code>. The letters of acronyms and initialisms like <span class="acronym" >ASCII</span> and <span class="acronym" >HTML</span> are always rendered in the same case, so a function might be called <code>htmlEscape</code>, <code>HTMLEscape</code>, or <code>escapeHTML</code>, but not <code>escapeHtml</code>.</p>
</div>
<h3 id="section-2.2" >Declarations</h3>
<div class="hBody-3" >
<p>A <em>declaration</em> names a program entity and specifies some or all of its properties. There are four major kinds of declarations: <code>var</code>, <code>const</code>, <code>type</code>, and <code>func</code>. We’ll talk about variables and types in this chapter, constants in <a href="#chapter-3" >Chapter 3</a>, and functions in <a href="#chapter-5" >Chapter 5</a>.</p>
<p>A Go program is stored in one or more files whose names end in <span class="file" >.go</span>. Each file begins with a <code>package</code> declaration that says what package the file is part of. The <code>package</code> declaration is followed by any <code>import</code> declarations, and then a sequence of <em>package-level</em> declarations of types, variables, constants, and functions, in any order. For example, this program declares a constant, a function, and a couple of variables:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/boiling/main.go" >gopl.io/ch2/boiling</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Boiling prints the boiling point of water.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">const</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">212.0</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">boilingF</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;boiling point = %g°F or %g°C\n&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="c1">// Output:
</span><span class="c1"></span>  <span class="c1">// boiling point = 212°F or 100°C
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>The constant <code>boilingF</code> is a package-level declaration (as is <code>main</code>), whereas the variables <code>f</code> and <code>c</code> are local to the function <code>main</code>. The name of each package-level entity is visible not only throughout the source file that contains its declaration, but throughout all the files of the package. By contrast, local declarations are visible only within the function in which they are declared and perhaps only within a small part of it.</p>
<p>A function declaration has a name, a list of parameters (the variables whose values are provided by the function’s callers), an optional list of results, and the function body, which contains the statements that define what the function does. The result list is omitted if the function does not return anything. Execution of the function begins with the first statement and continues until it encounters a return statement or reaches the end of a function that has no results. Control and any results are then returned to the caller.</p>
<p>We’ve seen a fair number of functions already and there are lots more to come, including an extensive discussion in <a href="#chapter-5" >Chapter 5</a>, so this is only a sketch. The function <code>fToC</code> below encapsulates the temperature conversion logic so that it is defined only once but may be used from multiple places. Here <code>main</code> calls it twice, using the values of two different local constants:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/ftoc/main.go" >gopl.io/ch2/ftoc</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Ftoc prints two Fahrenheit-to-Celsius conversions.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">freezingF</span><span class="p">,</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">32.0</span><span class="p">,</span> <span class="mf">212.0</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g°F = %g°C\n&#34;</span><span class="p">,</span> <span class="nx">freezingF</span><span class="p">,</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">freezingF</span><span class="p">))</span> <span class="c1">// &#34;32°F = 0°C&#34;
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g°F = %g°C\n&#34;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="p">,</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">boilingF</span><span class="p">))</span>   <span class="c1">// &#34;212°F = 100°C&#34;
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
<span class="p">}</span>
</code></pre>
</div>
</div>
<h3 id="section-2.3" >Variables</h3>
<div class="hBody-3" >
<p>A <code>var</code> declaration creates a variable of a particular type, attaches a name to it, and sets its initial value. Each declaration has the general form</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">name</span> <span class="kd">type</span> <span class="p">=</span> <span class="nx">expression</span>
</code></pre>
<p>Either the type or the <code>= expression</code> part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the expression is omitted, the initial value is the <em>zero value</em> for the type, which is <code>0</code> for numbers, <code>false</code> for booleans, <code>&#34;&#34;</code> for strings, and <code>nil</code> for interfaces and reference types (slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of its elements or fields.</p>
<p>The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there is no such thing as an uninitialized variable. This simplifies code and often ensures sensible behavior of boundary conditions without extra work. For example,</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &#34;&#34;
</span><span class="c1"></span></code></pre>
<p>prints an empty string, rather than causing some kind of error or unpredictable behavior. Go programmers often go to some effort to make the zero value of a more complicated type meaningful, so that variables begin life in a useful state.</p>
<p>It is possible to declare and optionally initialize a set of variables in a single declaration, with a matching list of expressions. Omitting the type allows declaration of multiple variables of different types:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span>                 <span class="c1">// int, int, int
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&#34;four&#34;</span> <span class="c1">// bool, float64, string
</span><span class="c1"></span></code></pre>
<p>Initializers may be literal values or arbitrary expressions. Package-level variables are initialized before <code>main</code> begins (<a href="#section-2.6.2" >§2.6.2</a>), and local variables are initialized as their declarations are encountered during function execution.</p>
<p>A set of variables can also be initialized by calling a function that returns multiple values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// os.Open returns a file and an error
</span><span class="c1"></span></code></pre>
</div>
<h4 id="section-2.3.1" >Short Variable Declarations</h4>
<div class="hBody-4" >
<p>Within a function, an alternate form called a <em>short variable declaration</em> may be used to declare and initialize local variables. It takes the form <code>name := expression</code>, and the type of <code>name</code> is determined by the type of <code>expression</code>. Here are three of the many short variable declarations in the <code>lissajous</code> function (<a href="#section-1.4" >§1.4</a>):</p>
<pre class="code" ><code class="chroma" ><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
<span class="nx">freq</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Float64</span><span class="p">()</span> <span class="o">*</span> <span class="mf">3.0</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span>
</code></pre>
<p>Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A <code>var</code> declaration tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be assigned a value later and its initial value is unimportant.</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span> <span class="o">:=</span> <span class="mi">100</span>                  <span class="c1">// an int
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">boiling</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// a float64
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</code></pre>
<p>As with <code>var</code> declarations, multiple variables may be declared and initialized in the same short variable declaration,</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</code></pre>
<p>but declarations with multiple initializer expressions should be used only when they help readability, such as for short and natural groupings like the initialization part of a <code>for</code> loop.</p>
<p>Keep in mind that <code>:=</code> is a declaration, whereas <code>=</code> is an assignment. A multi-variable declaration should not be confused with a <em>tuple assignment</em> (<a href="#section-2.4.1" >§2.4.1</a>), in which each variable on the left-hand side is assigned the corresponding value from the right-hand side:</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">i</span> <span class="c1">// swap values of i and j
</span><span class="c1"></span></code></pre>
<p>Like ordinary <code>var</code> declarations, short variable declarations may be used for calls to functions like <code>os.Open</code> that return two or more values:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// ...use f...
</span><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</code></pre>
<p>One subtle but important point: a short variable declaration does not necessarily <em>declare</em> all the variables on its left-hand side. If some of them were already declared in the <em>same</em> lexical block (<a href="#section-2.7" >§2.7</a>), then, for those variables, the short variable declaration acts like an <em>assignment</em> to those variables.</p>
<p>In the code below, the first statement declares both <code>in</code> and <code>err</code>. The second declares <code>out</code> but only assigns a value to the existing <code>err</code> variable.</p>
<pre class="code" ><code class="chroma" ><span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span>
</code></pre>
<p>A short variable declaration must declare at least one new variable, however, so this code will not compile:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span> <span class="c1">// compile error: no new variables
</span><span class="c1"></span></code></pre>
<p>The fix is to use an ordinary assignment for the second statement.</p>
<p>A short variable declaration acts like an assignment only to variables that were already declared in the same lexical block; declarations in an outer block are ignored. We’ll see examples of this at the end of the chapter.</p>
</div>
<h4 id="section-2.3.2" >Pointers</h4>
<div class="hBody-4" >
<p>A <em>variable</em> is a piece of storage containing a value. Variables created by declarations are identified by a name, such as <code>x</code>, but many variables are identified only by expressions like <code>x[i]</code> or <code>x.f</code>. All these expressions read the value of a variable, except when they appear on the lefthand side of an assignment, in which case a new value is assigned to the variable.</p>
<p>A <em>pointer</em> value is the <em>address</em> of a variable. A pointer is thus the location at which a value is stored. Not every value has an address, but every variable does. With a pointer, we can read or update the value of a variable <em>indirectly</em>, without using or even knowing the name of the variable, if indeed it has a name.</p>
<p>If a variable is declared <code>var x int</code>, the expression <code>&amp;x</code> (<q>address of <code>x</code></q>) yields a pointer to an integer variable, that is, a value of type <code>*int</code>, which is pronounced <q>pointer to int.</q> If this value is called <code>p</code>, we say <q><code>p</code> points to <code>x</code>,</q> or equivalently <q><code>p</code> contains the address of <code>x</code>.</q> The variable to which <code>p</code> points is written <code>*p</code>. The expression <code>*p</code> yields the value of that variable, an <code>int</code>, but since <code>*p</code> denotes a variable, it may also appear on the left-hand side of an assignment, in which case the assignment updates the variable.</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">x</span>         <span class="c1">// p, of type *int, points to x
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span><span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>          <span class="c1">// equivalent to x = 2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>  <span class="c1">// &#34;2&#34;
</span><span class="c1"></span></code></pre>
<p>Each component of a variable of aggregate type—a field of a struct or an element of an array— is also a variable and thus has an address too.</p>
<p>Variables are sometimes described as <em>addressable</em> values. Expressions that denote variables are the only expressions to which the <em>address-of</em> operator <code>&amp;</code> may be applied.</p>
<p>The zero value for a pointer of any type is <code>nil</code>. The test <code>p != nil</code> is true if <code>p</code> points to a variable. Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are nil.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// &#34;true false false&#34;
</span><span class="c1"></span></code></pre>
<p>It is perfectly safe for a function to return the address of a local variable. For instance, in the code below, the local variable <code>v</code> created by this particular call to <code>f</code> will remain in existence even after the call has returned, and the pointer <code>p</code> will still refer to it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>Each call of <code>f</code> returns a distinct value:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">()</span> <span class="o">==</span> <span class="nx">f</span><span class="p">())</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>Because a pointer contains the address of a variable, passing a pointer argument to a function makes it possible for the function to update the variable that was indirectly passed. For example, this function increments the variable that its argument points to and returns the new value of the variable so it may be used in an expression:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">incr</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">p</span><span class="o">++</span> <span class="c1">// increments what p points to; does not change p
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">*</span><span class="nx">p</span>
<span class="p">}</span>

<span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>              <span class="c1">// side effect: v is now 2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &#34;3&#34; (and v is 3)
</span><span class="c1"></span></code></pre>
<p>Each time we take the address of a variable or copy a pointer, we create new <em>aliases</em> or ways to identify the same variable. For example, <code>*p</code> is an alias for <code>v</code>. Pointer aliasing is useful because it allows us to access a variable without using its name, but this is a double-edged sword: to find all the statements that access a variable, we have to know all its aliases. It’s not just pointers that create aliases; aliasing also occurs when we copy values of other reference types like slices, maps, and channels, and even structs, arrays, and interfaces that contain these types.</p>
<p>Pointers are key to the <code>flag</code> package, which uses a program’s command-line arguments to set the values of certain variables distributed throughout the program. To illustrate, this variation on the earlier <code class="command" >echo</code> command takes two optional flags: <code>-n</code> causes <code class="command" >echo</code> to omit the trailing newline that would normally be printed, and <code>-s sep</code> causes it to separate the output arguments by the contents of the string <code>sep</code> instead of the default single space. Since this is our fourth version, the package is called <span class="file" >gopl.io/ch2/echo4</span>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/echo4/main.go" >gopl.io/ch2/echo4</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Echo4 prints its command-line arguments.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;flag&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&#34;n&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;omit trailing newline&#34;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">sep</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&#34;s&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;separator&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">(),</span> <span class="o">*</span><span class="nx">sep</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">!</span><span class="o">*</span><span class="nx">n</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The function <code>flag.Bool</code> creates a new flag variable of type <code>bool</code>. It takes three arguments: the name of the flag (<code>&#34;n&#34;</code>), the variable’s default value (<code>false</code>), and a message that will be printed if the user provides an invalid argument, an invalid flag, or <code>-h</code> or <code>-help</code>. Similarly, <code>flag.String</code> takes a name, a default value, and a message, and creates a <code>string</code> variable. The variables <code>sep</code> and <code>n</code> are pointers to the flag variables, which must be accessed indirectly as <code>*sep</code> and <code>*n</code>.</p>
<p>When the program is run, it must call <code>flag.Parse</code> before the flags are used, to update the flag variables from their default values. The non-flag arguments are available from <code>flag.Args()</code> as a slice of strings. If <code>flag.Parse</code> encounters an error, it prints a usage message and calls <code>os.Exit(2)</code> to terminate the program.</p>
<p>Let’s run some test cases on <code class="command" >echo</code>:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch2/echo4
</span><span class="in" ><span class="prompt" >&gt; </span>./echo4 a bc def
</span><span class="out" >a bc def
</span><span class="in" ><span class="prompt" >&gt; </span>./echo4 -s / a bc def
</span><span class="out" >a/bc/def
</span><span class="in" ><span class="prompt" >&gt; </span>./echo4 -n a bc def
</span><span class="out" >a bc def$
</span><span class="in" ><span class="prompt" >&gt; </span>./echo4 -help
</span><span class="out" >Usage of ./echo4:
  -n    omit trailing newline
  -s string
        separator (default &#34; &#34;)
</span></code></pre>
</div>
<h4 id="section-2.3.3" >The <code>new</code> Function</h4>
<div class="hBody-4" >
<p>Another way to create a variable is to use the built-in function <code>new</code>. The expression <code>new(T)</code> creates an <em>unnamed variable</em> of type <code>T</code>, initializes it to the zero value of <code>T</code>, and returns its address, which is a value of type <code>*T</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>   <span class="c1">//  p, of type *int, points to an unnamed int variable
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//  &#34;0&#34;
</span><span class="c1"></span><span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>          <span class="c1">//  sets the unnamed int to 2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//  &#34;2&#34;
</span><span class="c1"></span></code></pre>
<p>A variable created with <code>new</code> is no different from an ordinary local variable whose address is taken, except that there’s no need to invent (and declare) a dummy name, and we can use <code>new(T)</code> in an expression. Thus <code>new</code> is only a syntactic convenience, not a fundamental notion:</p>
<p>the two <code>newInt</code> functions below have identical behaviors.</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">int</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">dummy</span>
<span class="p">}</span>
</code></pre>
</div>
</div>
<p>Each call to <code>new</code> returns a distinct variable with a unique address:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>There is one exception to this rule: two variables whose type carries no information and is therefore of size zero, such as <code>struct{}</code> or <code>[0]int</code>, may, depending on the implementation, have the same address.</p>
<p>The <code>new</code> function is relatively rarely used because the most common unnamed variables are of struct types, for which the struct literal syntax (<a href="#section-4.4.1" >§4.4.1</a>) is more flexible.</p>
<p>Since <code>new</code> is a predeclared function, not a keyword, it’s possible to redefine the name for something else within a function, for example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">delta</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">new</span> <span class="o">-</span> <span class="nx">old</span> <span class="p">}</span>
</code></pre>
<p>Of course, within <code>delta</code>, the built-in <code>new</code> function is unavailable.</p>
</div>
<h4 id="section-2.3.4" >Lifetime of Variables</h4>
<div class="hBody-4" >
<p>The <em>lifetime</em> of a variable is the interval of time during which it exists as the program executes.  The lifetime of a package-level variable is the entire execution of the program. By contrast, local variables have dynamic lifetimes: a new instance is created each time the declaration statement is executed, and the variable lives on until it becomes <em>unreachable</em>, at which point its storage may be recycled. Function parameters and results are local variables too; they are created each time their enclosing function is called.</p>
<p>For example, in this excerpt from the Lissajous program of <a href="#section-1.4" >Section 1.4</a>,</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
  <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="nx">blackIndex</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>the variable <code>t</code> is created each time the <code>for</code> loop begins, and new variables <code>x</code> and <code>y</code> are created on each iteration of the loop.</p>
<p>How does the garbage collector know that a variable’s storage can be reclaimed? The full story is much more detailed than we need here, but the basic idea is that every package-level variable, and every local variable of each currently active function, can potentially be the start or root of a path to the variable in question, following pointers and other kinds of references that ultimately lead to the variable. If no such path exists, the variable has become unreachable, so it can no longer affect the rest of the computation.</p>
<p>Because the lifetime of a variable is determined only by whether or not it is reachable, a local variable may outlive a single iteration of the enclosing loop. It may continue to exist even after its enclosing function has returned.</p>
<p>A compiler may choose to allocate local variables on the heap or on the stack but, perhaps surprisingly, this choice is not determined by whether <code>var</code> or <code>new</code> was used to declare the variable.</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">global</span> <span class="o">*</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">global</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span>
<span class="p">}</span>
</code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
  <span class="o">*</span><span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre>
</div>
</div>
<p>Here, <code>x</code> must be heap-allocated because it is still reachable from the variable <code>global</code> after <code>f</code> has returned, despite being declared as a local variable; we say <code>x</code> <em>escapes from</em> <code>f</code>. Conversely, when <code>g</code> returns, the variable <code>*y</code> becomes unreachable and can be recycled. Since <code>*y</code> does not escape from <code>g</code>, it’s safe for the compiler to allocate <code>*y</code> on the stack, even though it was allocated with <code>new</code>. In any case, the notion of escaping is not something that you need to worry about in order to write correct code, though it’s good to keep in mind during performance optimization, since each variable that escapes requires an extra memory allocation.</p>
<p>Garbage collection is a tremendous help in writing correct programs, but it does not relieve you of the burden of thinking about memory. You don’t need to explicitly allocate and free memory, but to write efficient programs you still need to be aware of the lifetime of variables. For example, keeping unnecessary pointers to short-lived objects within long-lived objects, especially global variables, will prevent the garbage collector from reclaiming the short-lived objects.</p>
</div>
<h3 id="section-2.4" >Assignments</h3>
<div class="hBody-3" >
<p>The value held by a variable is updated by an assignment statement, which in its simplest form has a variable on the left of the <code>=</code> sign and an expression on the right.</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>                       <span class="c1">// named variable
</span><span class="c1"></span><span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="kc">true</span>                   <span class="c1">// indirect variable
</span><span class="c1"></span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;bob&#34;</span>         <span class="c1">// struct field
</span><span class="c1"></span><span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">*</span> <span class="nx">scale</span> <span class="c1">// array or slice or map element
</span><span class="c1"></span></code></pre>
<p>Each of the arithmetic and bitwise binary operators has a corresponding <em>assignment operator</em> allowing, for example, the last statement to be rewritten as</p>
<pre class="code" ><code class="chroma" ><span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">*=</span> <span class="nx">scale</span>
</code></pre>
<p>which saves us from having to repeat (and re-evaluate) the expression for the variable.</p>
<p>Numeric variables can also be incremented and decremented by <code>++</code> and <code>--</code> statements:</p>
<pre class="code" ><code class="chroma" ><span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">v</span><span class="o">++</span>    <span class="c1">// same as v = v + 1; v becomes 2
</span><span class="c1"></span><span class="nx">v</span><span class="o">--</span>    <span class="c1">// same as v = v - 1; v becomes 1 again
</span><span class="c1"></span></code></pre>
</div>
<h4 id="section-2.4.1" >Tuple assignment</h4>
<div class="hBody-4" >
<p>Another form of assignment, known as <em>tuple assignment</em>, allows several variables to be assigned at once. All of the right-hand side expressions are evaluated before any of the variables are updated, making this form most useful when some of the variables appear on both sides of the assignment, as happens, for example, when swapping the values of two variables:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</code></pre>
<p>or when computing the greatest common divisor (GCD) of two integers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">%</span><span class="nx">y</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre>
<p>or when computing the n-th Fibonacci number iteratively:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre>
<p>Tuple assignment can also make a sequence of trivial assignments more compact,</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span>
</code></pre>
<p>though as a matter of style, avoid the tuple form if the expressions are complex; a sequence of separate statements is easier to read.</p>
<p>Certain expressions, such as a call to a function with multiple results, produce several values. When such a call is used in an assignment statement, the left-hand side must have as many variables as the function has results.</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;foo.txt&#34;</span><span class="p">)</span> <span class="c1">// function call returns two values
</span><span class="c1"></span></code></pre>
<p>Often, functions use these additional results to indicate some kind of error, either by returning an <code>error</code> as in the call to <code>os.Open</code>, or a <code>bool</code>, usually called <code>ok</code>. As we’ll see in later chapters, there are three operators that sometimes behave this way too. If a map lookup (<a href="#section-4.3" >§4.3</a>), type assertion (<a href="#section-7.10" >§7.10</a>), or channel receive (<a href="#section-8.4.2" >§8.4.2</a>) appears in an assignment in which two results are expected, each produces an additional boolean result:</p>
<pre class="code" ><code class="chroma" ><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>         <span class="c1">// map lookup
</span><span class="c1"></span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>          <span class="c1">// type assertion
</span><span class="c1"></span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>           <span class="c1">// channel receive
</span><span class="c1"></span></code></pre>
<p>As with variable declarations, we can assign unwanted values to the blank identifier:</p>
<pre class="code" ><code class="chroma" ><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="c1">// discard byte count
</span><span class="c1"></span><span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>              <span class="c1">// check type but discard result
</span><span class="c1"></span></code></pre>
</div>
<h4 id="section-2.4.2" >Assignability</h4>
<div class="hBody-4" >
<p>Assignment statements are an explicit form of assignment, but there are many places in a program where an assignment occurs <em>implicitly</em>: a function call implicitly assigns the argument values to the corresponding parameter variables; a <code>return</code> statement implicitly assigns the <code>return</code> operands to the corresponding result variables; and a literal expression for a composite type (<a href="#section-4.2" >§4.2</a>) such as this slice:</p>
<pre class="code" ><code class="chroma" ><span class="nx">medals</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;gold&#34;</span><span class="p">,</span> <span class="s">&#34;silver&#34;</span><span class="p">,</span> <span class="s">&#34;bronze&#34;</span><span class="p">}</span>
</code></pre>
<p>implicitly assigns each element, as if it had been written like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">medals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;gold&#34;</span>
<span class="nx">medals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;silver&#34;</span>
<span class="nx">medals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;bronze&#34;</span>
</code></pre>
<p>The elements of maps and channels, though not ordinary variables, are also subject to similar implicit assignments.</p>
<p>An assignment, explicit or implicit, is always legal if the left-hand side (the variable) and the right-hand side (the value) have the same type. More generally, the assignment is legal only if the value is <em>assignable</em> to the type of the variable.</p>
<p>The rule for <em>assignability</em> has cases for various types, so we’ll explain the relevant case as we introduce each new type. For the types we’ve discussed so far, the rules are simple: the types must exactly match, and <code>nil</code> may be assigned to any variable of interface or reference type. Constants (<a href="#section-3.6" >§3.6</a>) have more flexible rules for assignability that avoid the need for most explicit conversions.</p>
<p>Whether two values may be compared with <code>==</code> and <code>!=</code> is related to assignability: in any comparison, the first operand must be assignable to the type of the second operand, or vice versa.  As with assignability, we’ll explain the relevant cases for <em>comparability</em> when we present each new type.</p>
</div>
<h3 id="section-2.5" >Type Declarations</h3>
<div class="hBody-3" >
<p>The type of a variable or expression defines the characteristics of the values it may take on, such as their size (number of bits or number of elements, perhaps), how they are represented internally, the intrinsic operations that can be performed on them, and the methods associated with them.</p>
<p>In any program there are variables that share the same representation but signify very different concepts. For instance, an <code>int</code> could be used to represent a loop index, a timestamp, a file descriptor, or a month; a <code>float64</code> could represent a velocity in meters per second or a temperature in one of several scales; and a <code>string</code> could represent a password or the name of a color.</p>
<p>A <code>type</code> declaration defines a new <em>named type</em> that has the same <em>underlying type</em> as an existing type. The named type provides a way to separate different and perhaps incompatible uses of the underlying type so that they can’t be mixed unintentionally.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">name</span> <span class="nx">underlying</span><span class="o">-</span><span class="kd">type</span>
</code></pre>
<p>Type declarations most often appear at package level, where the named type is visible throughout the package, and if the name is exported (it starts with an upper-case letter), it’s accessible from other packages as well.</p>
<p>To illustrate type declarations, let’s turn the different temperature scales into different types:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/tempconv0/celsius.go" >gopl.io/ch2/tempconv0</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package tempconv performs Celsius and Fahrenheit temperature computations.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
  <span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>
<p>This package defines two types, <code>Celsius</code> and <code>Fahrenheit</code>, for the two units of temperature. Even though both have the same underlying type, <code>float64</code>, they are not the same type, so they cannot be compared or combined in arithmetic expressions. Distinguishing the types makes it possible to avoid errors like inadvertently combining temperatures in the two different scales; an explicit type <em>conversion</em> like <code>Celsius(t)</code> or <code>Fahrenheit(t)</code> is required to convert from a <code>float64</code>. <code>Celsius(t)</code> and <code>Fahrenheit(t)</code> are conversions, not function calls. They don’t change the value or representation in any way, but they make the change of meaning explicit.  On the other hand, the functions <code>CToF</code> and <code>FToC</code> convert between the two scales; they do return different values.</p>
<p>For every type <code>T</code>, there is a corresponding conversion operation <code>T(x)</code> that converts the value <code>x</code> to type <code>T</code>. A conversion from one type to another is allowed if both have the same underlying type, or if both are unnamed pointer types that point to variables of the same underlying type; these conversions change the type but not the representation of the value. If <code>x</code> is assignable to <code>T</code>, a conversion is permitted but is usually redundant.</p>
<p>Conversions are also allowed between numeric types, and between string and some slice types, as we will see in the next chapter. These conversions may change the representation of the value. For instance, converting a floating-point number to an integer discards any fractional part, and converting a string to a <code>[]byte</code> slice allocates a copy of the string data. In any case, a conversion never fails at run time.</p>
<p>The underlying type of a named type determines its structure and representation, and also the set of intrinsic operations it supports, which are the same as if the underlying type had been used directly. That means that arithmetic operators work the same for <code>Celsius</code> and <code>Fahrenheit</code> as they do for <code>float64</code>, as you might expect.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g\n&#34;</span><span class="p">,</span> <span class="nx">BoilingC</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span>       <span class="c1">// &#34;100&#34; °C
</span><span class="c1"></span><span class="nx">boilingF</span> <span class="o">:=</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">BoilingC</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g\n&#34;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">FreezingC</span><span class="p">))</span> <span class="c1">// &#34;180&#34; °F
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g\n&#34;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span>       <span class="c1">// compile error: type mismatch
</span><span class="c1"></span></code></pre>
<p>Comparison operators like <code>==</code> and <code>&lt;</code> can also be used to compare a value of a named type to another of the same type, or to a value of an unnamed type with the same underlying type. But two values of different named types cannot be compared directly :</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">c</span> <span class="nx">Celsius</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="nx">Fahrenheit</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">f</span><span class="p">)</span>          <span class="c1">// compile error: type mismatch
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// &#34;true&#34;!
</span><span class="c1"></span></code></pre>
<p>Note the last case carefully. In spite of its name, the type conversion <code>Celsius(f)</code> does not change the value of its argument, just its type. The test is true because <code>c</code> and <code>f</code> are both zero.</p>
<p>A named type may provide notational convenience if it helps avoid writing out complex types over and over again. The advantage is small when the underlying type is simple like <code>float64</code>, but big for complicated types, as we will see when we discuss structs.</p>
<p>Named types also make it possible to define new behaviors for values of the type. These behaviors are expressed as a set of functions associated with the type, called the type’s <em>methods</em>.  We’ll look at methods in detail in <a href="#chapter-6" >Chapter 6</a> but will give a taste of the mechanism here.</p>
<p>The declaration below, in which the <code>Celsius</code> parameter <code>c</code> appears before the function name, associates with the <code>Celsius</code> type a method named <code>String</code> that returns <code>c</code>’s numeric value followed by <code>°C</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%g°C&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
<p>Many types declare a <code>String</code> method of this form because it controls how values of the type appear when printed as a string by the <code>fmt</code> package, as we will see in <a href="#section-7.1" >Section 7.1</a>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">c</span> <span class="o">:=</span> <span class="nx">FToC</span><span class="p">(</span><span class="mf">212.0</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;100°C&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &#34;100°C&#34;; no need to call String explicitly
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &#34;100°C&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>          <span class="c1">// &#34;100°C&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%g\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &#34;100&#34;; does not call String
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// &#34;100&#34;; does not call String
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-2.6" >Packages and Files</h3>
<div class="hBody-3" >
<p>Packages in Go serve the same purposes as libraries or modules in other languages, supporting modularity, encapsulation, separate compilation, and reuse. The source code for a package resides in one or more <span class="file" >.go</span> files, usually in a directory whose name ends with the import path; for instance, the files of the <code>gopl.io/ch1/helloworld</code> package are stored in directory <code>$GOPATH/src/gopl.io/ch1/helloworld</code>.</p>
<p>Each package serves as a separate <em>name space</em> for its declarations. Within the <em>image</em> package, for example, the identifier <code>Decode</code> refers to a different function than does the same identifier in the <code>unicode/utf16</code> package. To refer to a function from outside its package, we must <em>qualify</em> the identifier to make explicit whether we mean <code>image.Decode</code> or <code>utf16.Decode</code>.</p>
<p>Packages also let us hide information by controlling which names are visible outside the package, or <em>exported</em>. In Go, a simple rule governs which identifiers are exported and which are not: exported identifiers start with an upper-case letter.</p>
<p>To illustrate the basics, suppose that our temperature conversion software has become popular and we want to make it available to the Go community as a new package. How do we do that?</p>
<p>Let’s create a package called <code>gopl.io/ch2/tempconv</code>, a variation on the previous example.  (Here we’ve made an exception to our usual rule of numbering examples in sequence, so that the package path can be more realistic.) The package itself is stored in two files to show how declarations in separate files of a package are accessed; in real life, a tiny package like this would need only one file.</p>
<p>We have put the declarations of the types, their constants, and their methods in <span class="file" >tempconv.go</span>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/tempconv/tempconv.go" >gopl.io/ch2/tempconv</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package tempconv performs Celsius and Fahrenheit conversions.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
	<span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>    <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%g°C&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%g°F&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>
<p>and the conversion functions in <span class="file" >conv.go</span>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">tempconv</span>

<span class="c1">// CToF converts a Celsius temperature to Fahrenheit.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// FToC converts a Fahrenheit temperature to Celsius.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
<p>Each file starts with a <code>package</code> declaration that defines the package name. When the package is imported, its members are referred to as <code>tempconv.CToF</code> and so on. Package-level names like the types and constants declared in one file of a package are visible to all the other files of the package, as if the source code were all in a single file. Note that <span class="file" >tempconv.go</span> imports <code>fmt</code>, but <span class="file" >conv.go</span> does not, because it does not use anything from <code>fmt</code>.</p>
<p>Because the package-level <code>const</code> names begin with upper-case letters, they too are accessible with qualified names like <code>tempconv.AbsoluteZeroC</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Brrrr! %v\n&#34;</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">AbsoluteZeroC</span><span class="p">)</span> <span class="c1">// &#34;Brrrr! -273.15°C&#34;
</span><span class="c1"></span></code></pre>
<p>To convert a Celsius temperature to Fahrenheit in a package that imports <code>gopl.io/ch2/tempconv</code>, we can write the following code:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">BoilingC</span><span class="p">))</span> <span class="c1">// &#34;212°F&#34;
</span><span class="c1"></span></code></pre>
<p>The <em>doc comment</em> (<a href="#section-10.7.4" >§10.7.4</a>) immediately preceding the package declaration documents the package as a whole. Conventionally, it should start with a summary sentence in the style illustrated. Only one file in each package should have a package doc comment. Extensive doc comments are often placed in a file of their own, conventionally called <span class="file" >doc.go</span>.</p>
<p><b>Exercise 2.1</b>: Add types, constants, and functions to <code>tempconv</code> for processing temperatures in the Kelvin scale, where zero Kelvin is -273.15°C and a difference of 1K has the same magnitude as 1°C.</p>
</div>
<h4 id="section-2.6.1" >Imports</h4>
<div class="hBody-4" >
<p>Within a Go program, every package is identified by a unique string called its <em>import path</em>. These are the strings that appear in an <code>import</code> declaration like <code>&#34;gopl.io/ch2/tempconv&#34;</code>. The language specification doesn’t define where these strings come from or what they mean; it’s up to the tools to interpret them. When using the <code class="command" >go</code> tool (<a href="#chapter-10" >Chapter 10</a>), an import path denotes a directory containing one or more Go source files that together make up the package.</p>
<p>In addition to its import path, each package has a <em>package name</em>, which is the short (and not necessarily unique) name that appears in its <code>package</code> declaration. By convention, a package’s name matches the last segment of its import path, making it easy to predict that the package name of <code>gopl.io/ch2/tempconv</code> is <code>tempconv</code>.</p>
<p>To use <code>gopl.io/ch2/tempconv</code>, we must import it:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/cf/main.go" >gopl.io/ch2/cf</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Cf converts its numeric argument to Celsius and Fahrenheit.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strconv&#34;</span>

  <span class="s">&#34;gopl.io/ch2/tempconv&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseFloat</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;cf: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Celsius</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s = %s, %s = %s\n&#34;</span><span class="p">,</span>
      <span class="nx">f</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The import declaration binds a short name to the imported package that may be used to refer to its contents throughout the file. The <code>import</code> above lets us refer to names within <code>gopl.io/ch2/tempconv</code> by using a <em>qualified identifier</em> like <code>tempconv.CToF</code>. By default, the short name is the package name—<code>tempconv</code> in this case—but an import declaration may specify an alternative name to avoid a conflict (<a href="#section-10.4" >§10.4</a>).</p>
<p>The <code class="command" >cf</code> program converts a single numeric command-line argument to its value in both Celsius and Fahrenheit:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch2/cf
</span><span class="in" ><span class="prompt" >&gt; </span>./cf <span class="m">32</span>
</span><span class="out" >32°F = 0°C, 32°C = 89.6°F
</span><span class="in" ><span class="prompt" >&gt; </span>./cf <span class="m">212</span>
</span><span class="out" >212°F = 100°C, 212°C = 413.6°F
</span><span class="in" ><span class="prompt" >&gt; </span>./cf -40
</span><span class="out" >-40°F = -40°C, -40°C = -40°F
</span></code></pre>
<p>It is an error to import a package and then not refer to it. This check helps eliminate dependencies that become unnecessary as the code evolves, although it can be a nuisance during debugging, since commenting out a line of code like <code>log.Print(&#34;got here!&#34;)</code> may remove the sole reference to the package name <code>log</code>, causing the compiler to emit an error. In this situation, you need to comment out or delete the unnecessary <code>import</code>.</p>
<p>Better still, use the <code>golang.org/x/tools/cmd/goimports</code> tool, which automatically inserts and removes packages from the import declaration as necessary ; most editors can be configured to run <code class="command" >goimports</code> each time you save a file. Like the <code class="command" >gofmt</code> tool, it also pretty-prints Go source files in the canonical format.</p>
<p><b>Exercise 2.2</b>: Write a general-purpose unit-conversion program analogous to <code>cf</code> that reads numbers from its command-line arguments or from the standard input if there are no arguments, and converts each number into units like temperature in Celsius and Fahrenheit, length in feet and meters, weight in pounds and kilograms, and the like.</p>
</div>
<h4 id="section-2.6.2" >Package Initialization</h4>
<div class="hBody-4" >
<p>Package initialization begins by initializing package-level variables in the order in which they are declared, except that dependencies are resolved first:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>      <span class="c1">// a initialized third, to 3
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>        <span class="c1">// b initialized second, to 2, by calling f
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">1</span>          <span class="c1">// c initialized first, to 1
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre>
<p>If the package has multiple <span class="file" >.go</span> files, they are initialized in the order in which the files are given to the compiler; the <code class="command" >go</code> tool sorts <span class="file" >.go</span> files by name before invoking the compiler.</p>
<p>Each variable declared at package level starts life with the value of its initializer expression, if any, but for some variables, like tables of data, an initializer expression may not be the simplest way to set its initial value. In that case, the <code>init</code> function mechanism may be simpler. Any file may contain any number of functions whose declaration is just</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>Such <code>init</code> functions can’t be called or referenced, but otherwise they are normal functions.  Within each file, <code>init</code> functions are automatically executed when the program starts, in the order in which they are declared.</p>
<p>One package is initialized at a time, in the order of imports in the program, dependencies first, so a package <code>p</code> importing <code>q</code> can be sure that <code>q</code> is fully initialized before <code>p</code>’s initialization begins. Initialization proceeds from the bottom up; the <code>main</code> package is the last to be initialized. In this manner, all packages are fully initialized before the application’s <code>main</code> function begins.</p>
<p>The package below defines a function <code>PopCount</code> that returns the number of set bits, that is, bits whose value is 1, in a <code>uint64</code> value, which is called its <em>population count</em>. It uses an <code>init</code> function to precompute a table of results, <code>pc</code>, for each possible 8-bit value so that the <code>PopCount</code> function needn’t take 64 steps but can just return the sum of eight table lookups. (This is definitely <em>not</em> the fastest algorithm for counting bits, but it’s convenient for illustrating <code>init</code> functions, and for showing how to precompute a table of values, which is often a useful programming technique.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch2/popcount/main.go" >gopl.io/ch2/popcount</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">popcount</span>

<span class="c1">// pc[i] is the population count of i.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">pc</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// PopCount returns the population count (number of set bits) of x.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">PopCount</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">))])</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Note that the range loop in <code>init</code> uses only the index; the value is unnecessary and thus need not be included. The loop could also have been written as for</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
</code></pre>
<p>We’ll see other uses of <code>init</code> functions in the next section and in <a href="#section-10.5" >Section 10.5</a>.</p>
<p><b>Exercise 2.3</b>: Rewrite <code>PopCount</code> to use a loop instead of a single expression. Compare the performance of the two versions. (<a href="#section-11.4" >Section 11.4</a> shows how to compare the performance of different implementations systematically.)</p>
<p><b>Exercise 2.4</b>: Write a version of <code>PopCount</code> that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the tablelookup version.</p>
<p><b>Exercise 2.5</b>: The expression <code>x&amp;(x-1)</code> clears the rightmost non-zero bit of <code>x</code>. Write a version of PopCount that counts bits by using this fact, and assess its performance.</p>
</div>
<h3 id="section-2.7" >Scope</h3>
<div class="hBody-3" >
<p>A declaration associates a name with a program entity, such as a function or a variable. The <em>scope</em> of a declaration is the part of the source code where a use of the declared name refers to that declaration.</p>
<p>Don’t confuse scope with lifetime. The scope of a declaration is a region of the program text; it is a compile-time property. The lifetime of a variable is the range of time during execution when the variable can be referred to by other parts of the program; it is a run-time property.</p>
<p>A syntactic <em>block</em> is a sequence of statements enclosed in braces like those that surround the body of a function or loop. A name declared inside a syntactic block is not visible outside that block. The block encloses its declarations and determines their scope. We can generalize this notion of blocks to include other groupings of declarations that are not explicitly surrounded by braces in the source code; we’ll call them all <em>lexical blocks</em>. There is a lexical block for the entire source code, called the <em>universe block</em>; for each package; for each file; for each <code>for</code>, <code>if</code>, and <code>switch</code> statement; for each case in a <code>switch</code> or <code>select</code> statement; and, of course, for each explicit syntactic block.</p>
<p>A declaration’s lexical block determines its scope, which may be large or small. The declarations of built-in types, functions, and constants like <code>int</code>, <code>len</code>, and <code>true</code> are in the universe block and can be referred to throughout the entire program. Declarations outside any function, that is, at <em>package level</em>, can be referred to from any file in the same package. Imported packages, such as <code>fmt</code> in the <code>tempconv</code> example, are declared at the <em>file level</em>, so they can be referred to from the same file, but not from another file in the same package without another <code>import</code>. Many declarations, like that of the variable <code>c</code> in the <code>tempconv.CToF</code> function, are <em>local</em>, so they can be referred to only from within the same function or perhaps just a part of it.</p>
<p>The scope of a control-flow label, as used by <code>break</code>, <code>continue</code>, and <code>goto</code> statements, is the entire enclosing function.</p>
<p>A program may contain multiple declarations of the same name so long as each declaration is in a different lexical block. For example, you can declare a local variable with the same name as a package-level variable. Or, as shown in <a href="#section-2.3.3" >Section 2.3.3</a>, you can declare a function parameter called <code>new</code>, even though a function of this name is predeclared in the universe block. Don’t overdo it, though; the larger the scope of the redeclaration, the more likely you are to surprise the reader.</p>
<p>When the compiler encounters a reference to a name, it looks for a declaration, starting with the innermost enclosing lexical block and working up to the universe block. If the compiler finds no declaration, it reports an <q>undeclared name</q> error. If a name is declared in both an outer block and an inner block, the inner declaration will be found first. In that case, the inner declaration is said to <em>shadow</em> or <em>hide</em> the outer one, making it inaccessible:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;g&#34;</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="s">&#34;f&#34;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// &#34;f&#34;; local var f shadows package-level func f
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="c1">// &#34;g&#34;; package-level var
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="c1">// compile error: undefined: h
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Within a function, lexical blocks may be nested to arbitrary depth, so one local declaration can shadow another. Most blocks are created by control-flow constructs like <code>if</code> statements and <code>for</code> loops. The program below has three different variables called <code>x</code> because each declaration appears in a different lexical block. (This example illustrates scope rules, not good style!)</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="s">&#34;hello!&#34;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="sc">&#39;!&#39;</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;HELLO&#34; (one letter per iteration)
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The expressions <code>x[i]</code> and <code>x + &#39;A&#39; - &#39;a&#39;</code> each refer to a declaration of <code>x</code> from an outer block; we’ll explain that in a moment. (Note that the latter expression is <em>not</em> equivalent to <code>unicode.ToUpper</code>.)</p>
<p>As mentioned above, not all lexical blocks correspond to explicit brace-delimited sequences of statements; some are merely implied. The <code>for</code> loop above creates two lexical blocks: the explicit block for the loop body, and an implicit block that additionally encloses the variables declared by the initialization clause, such as <code>i</code>. The scope of a variable declared in the implicit block is the condition, post-statement (<code>i++</code>), and body of the <code>for</code> statement.</p>
<p>The example below also has three variables named <code>x</code>, each declared in a different block—one in the function body, one in the <code>for</code> statement’s block, and one in the loop body—but only two of the blocks are explicit:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="s">&#34;hello&#34;</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;HELLO&#34; (one letter per iteration)
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Like <code>for</code> loops, <code>if</code> statements and <code>switch</code> statements also create implicit blocks in addition to their body blocks. The code in the following <code>if</code>-<code>else</code> chain shows the scope of <code>x</code> and <code>y</code>:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">();</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">y</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// compile error: x and y are not visible here
</span><span class="c1"></span></code></pre>
<p>The second <code>if</code> statement is nested within the first, so variables declared within the first statement’s initializer are visible within the second. Similar rules apply to each case of a switch statement: there is a block for the condition and a block for each case body.</p>
<p>At the package level, the order in which declarations appear has no effect on their scope, so a declaration may refer to itself or to another that follows it, letting us declare recursive or mutually recursive types and functions. The compiler will report an error if a constant or variable declaration refers to itself, however.</p>
<p>In this program:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// compile error: unused: f
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span> <span class="c1">// compile error: undefined f
</span><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>    <span class="c1">// compile error: undefined f
</span><span class="c1"></span></code></pre>
<p>the scope of <code>f</code> is just the <code>if</code> statement, so <code>f</code> is not accessible to the statements that follow, resulting in compiler errors. Depending on the compiler, you may get an additional error reporting that the local variable <code>f</code> was never used.</p>
<p>Thus it is often necessary to declare <code>f</code> before the condition so that it is accessible after:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</code></pre>
<p>You may be tempted to avoid declaring <code>f</code> and <code>err</code> in the outer block by moving the calls to <code>ReadByte</code> and <code>Close</code> inside an <code>else</code> block:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// f and err are visible here too
</span><span class="c1"></span>  <span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>but normal practice in Go is to deal with the error in the <code>if</code> block and then return, so that the successful execution path is not indented.</p>
<p>Short variable declarations demand an awareness of scope. Consider the program below, which starts by obtaining its current working directory and saving it in a package-level variable. This could be done by calling <code>os.Getwd</code> in function <code>main</code>, but it might be better to separate this concern from the primary logic, especially if failing to get the directory is a fatal error. The function <code>log.Fatalf</code> prints a message and calls <code>os.Exit(1)</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// compile error: unused: cwd
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;os.Getwd failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Since neither <code>cwd</code> nor <code>err</code> is already declared in the init function’s block, the <code>:=</code> statement declares both of them as local variables. The inner declaration of <code>cwd</code> makes the outer one inaccessible, so the statement does not update the package-level <code>cwd</code> variable as intended.</p>
<p>Current Go compilers detect that the local <code>cwd</code> variable is never used and report this as an error, but they are not strictly required to perform this check. Furthermore, a minor change, such as the addition of a logging statement that refers to the local <code>cwd</code> would defeat the check.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// NOTE: wrong!
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;os.Getwd failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Working directory = %s&#34;</span><span class="p">,</span> <span class="nx">cwd</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The global <code>cwd</code> variable remains uninitialized, and the apparently normal log output obfuscates the bug.</p>
<p>There are a number of ways to deal with this potential problem. The most direct is to avoid <code>:=</code> by declaring <code>err</code> in a separate <code>var</code> declaration:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;os.Getwd failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We’ve now seen how packages, files, declarations, and statements express the structure of programs. In the next two chapters, we’ll look at the structure of data.</p>
</div>
<h2 id="chapter-3" >Basic Data Types</h2>
<div class="hBody-2" >
<p>It’s all bits at the bottom, of course, but computers operate fundamentally on fixed-size numbers called <em>words</em>, which are interpreted as integers, floating-point numbers, bit sets, or memory addresses, then combined into larger aggregates that represent packets, pixels, portfolios, poetry, and everything else. Go offers a variety of ways to organize data, with a spectrum of data types that at one end match the features of the hardware and at the other end provide what programmers need to conveniently represent complicated data structures.</p>
<p>Go’s types fall into four categories: <em>basic types</em>, <em>aggregate types</em>, <em>reference types</em>, and <em>interface types</em>. Basic types, the topic of this chapter, include numbers, strings, and booleans. Aggregate types—arrays (<a href="#section-4.1" >§4.1</a>) and structs (<a href="#section-4.4" >§4.4</a>)—form more complicated data types by combining values of several simpler ones. Reference types are a diverse group that includes pointers (<a href="#section-2.3.2" >§2.3.2</a>), slices (<a href="#section-4.2" >§4.2</a>), maps (<a href="#section-4.3" >§4.3</a>), functions (<a href="#chapter-5" >Chapter 5</a>), and channels (<a href="#chapter-8" >Chapter 8</a>), but what they have in common is that they all refer to program variables or state <em>indirectly</em>, so that the effect of an operation applied to one reference is observed by all copies of that reference. Finally, we’ll talk about interface types in <a href="#chapter-7" >Chapter 7</a>.</p>
</div>
<h3 id="section-3.1" >Integers</h3>
<div class="hBody-3" >
<p>Go’s numeric data types include several sizes of integers, floating-point numbers, and complex numbers. Each numeric type determines the size and signedness of its values. Let’s begin with integers.</p>
<p>Go provides both signed and unsigned integer arithmetic. There are four distinct sizes of signed integers—8, 16, 32, and 64 bits—represented by the types <code>int8</code>, <code>int16</code>, <code>int32</code>, and <code>int64</code>, and corresponding unsigned versions <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, and <code>uint64</code>.</p>
<p>There are also two types called just <code>int</code> and <code>uint</code> that are the natural or most efficient size for signed and unsigned integers on a particular platform; <code>int</code> is by far the most widely used numeric type. Both these types have the same size, either 32 or 64 bits, but one must not make assumptions about which; different compilers may make different choices even on identical hardware.</p>
<p>The type <code>rune</code> is a synonym for <code>int32</code> and conventionally indicates that a value is a Unicode code point. The two names may be used interchangeably. Similarly, the type <code>byte</code> is a synonym for <code>uint8</code>, and emphasizes that the value is a piece of raw data rather than a small numeric quantity.</p>
<p>Finally, there is an unsigned integer type <code>uintptr</code>, whose width is not specified but is sufficient to hold all the bits of a pointer value. The <code>uintptr</code> type is used only for low-level programming, such as at the boundary of a Go program with a C library or an operating system. We’ll see examples of this when we deal with the <code>unsafe</code> package in <a href="#chapter-13" >Chapter 13</a>.</p>
<p>Regardless of their size, <code>int</code>, <code>uint</code>, and <code>uintptr</code> are different types from their explicitly sized siblings. Thus <code>int</code> is not the same type as <code>int32</code>, even if the natural size of integers is 32 bits, and an explicit conversion is required to use an <code>int</code> value where an <code>int32</code> is needed, and vice versa.</p>
<p>Signed numbers are represented in 2’s-complement form, in which the high-order bit is reserved for the sign of the number and the range of values of an <span class="math" >n</span>-bit number is from -2ⁿ⁻¹ to 2ⁿ⁻¹-1. Unsigned integers use the full range of bits for non-negative values and thus have the range 0 to 2ⁿ-1. For instance, the range of <code>int8</code> is -128 to 127, whereas the range of <code>uint8</code> is 0 to 255.</p>
<p>Go’s binary operators for arithmetic, logic, and comparison are listed here in order of decreasing precedence:</p>
<div class="pre-block" >
<pre class="pre" >*   /   %  &lt;&lt;  &gt;&gt;  &amp;   &amp;^
+   -   |  ^
==  !=  &lt;  &lt;=  &gt;   &gt;=
&amp;&amp;
||
</pre>
</div>
<p>There are only five levels of precedence for binary operators. Operators at the same level associate to the left, so parentheses may be required for clarity, or to make the operators evaluate in the intended order in an expression like <code>mask &amp; (1 &lt;&lt; 28)</code>.</p>
<p>Each operator in the first two lines of the table above, for instance <code>+</code>, has a corresponding <code>assignment operator</code> like <code>+=</code> that may be used to abbreviate an assignment statement.</p>
<p>The arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> may be applied to integer, floating-point, and complex numbers, but the remainder operator <code>%</code> applies only to integers. The behavior of <code>%</code> for negative numbers varies across programming languages. In Go, the sign of the remainder is always the same as the sign of the dividend, so <code>-5%3</code> and <code>-5%-3</code> are both <code>-2</code>. The behavior of <code>/</code> depends on whether its operands are integers, so <code>5.0/4.0</code> is <code>1.25</code>, but <code>5/4</code> is <code>1</code> because integer division truncates the result toward zero.</p>
<p>If the result of an arithmetic operation, whether signed or unsigned, has more bits than can be represented in the result type, it is said to <em>overflow</em>. The high-order bits that do not fit are silently discarded. If the original number is a signed type, the result could be negative if the leftmost bit is a 1, as in the <code>int8</code> example here:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">u</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">255</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">u</span><span class="o">*</span><span class="nx">u</span><span class="p">)</span> <span class="c1">// &#34;255 0 1&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int8</span> <span class="p">=</span> <span class="mi">127</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// &#34;127 -128 1&#34;
</span><span class="c1"></span></code></pre>
<p>Two integers of the same type may be compared using the binary comparison operators below; the type of a comparison expression is a boolean.</p>
<table border="1">
<tbody>
<tr><td><p><code>==</code></p>
</td><td><p>equal to</p>
</td></tr>
<tr><td><p><code>!=</code></p>
</td><td><p>not equal to</p>
</td></tr>
<tr><td><p><code>&lt;</code></p>
</td><td><p>less than</p>
</td></tr>
<tr><td><p><code>&lt;=</code></p>
</td><td><p>less than or equal to</p>
</td></tr>
<tr><td><p><code>&gt;</code></p>
</td><td><p>greater than</p>
</td></tr>
<tr><td><p><code>&gt;=</code></p>
</td><td><p>greater than or equal to</p>
</td></tr>
</tbody>
</table>
<p>In fact, all values of basic type—booleans, numbers, and strings—are <em>comparable</em>, meaning that two values of the same type may be compared using the <code>==</code> and <code>!=</code> operators. Furthermore, integers, floating-point numbers, and strings are <em>ordered</em> by the comparison operators. The values of many other types are not comparable, and no other types are ordered. As we encounter each type, we’ll present the rules governing the <em>comparability</em> of its values.</p>
<p>There are also unary addition and subtraction operators:</p>
<table border="1">
<tbody>
<tr><td><p><code>+</code></p>
</td><td><p>unary positive (no effect)</p>
</td></tr>
<tr><td><p><code>-</code></p>
</td><td><p>unary negation</p>
</td></tr>
</tbody>
</table>
<p>For integers, <code>+x</code> is a shorthand for <code>0+x</code> and <code>-x</code> is a shorthand for <code>0-x</code>; for floating-point and complex numbers, <code>+x</code> is just <code>x</code> and <code>-x</code> is the negation of <code>x</code>.</p>
<p>Go also provides the following bitwise binary operators, the first four of which treat their operands as bit patterns with no concept of arithmetic carry or sign:</p>
<table border="1">
<tbody>
<tr><td><p><code>&amp;</code></p>
</td><td><p>bitwise AND</p>
</td></tr>
<tr><td><p><code>|</code></p>
</td><td><p>bitwise OR</p>
</td></tr>
<tr><td><p><code>^</code></p>
</td><td><p>bitwise XOR</p>
</td></tr>
<tr><td><p><code>&amp;^</code></p>
</td><td><p>bit clear (AND NOT)</p>
</td></tr>
<tr><td><p><code>&lt;&lt;</code></p>
</td><td><p>left shift</p>
</td></tr>
<tr><td><p><code>&gt;&gt;</code></p>
</td><td><p>right shift</p>
</td></tr>
</tbody>
</table>
<p>The operator <code>^</code> is bitwise exclusive OR (XOR) when used as a binary operator, but when used as a unary prefix operator it is bitwise negation or complement; that is, it returns a value with each bit in its operand inverted. The <code>&amp;^</code> operator is bit clear (AND NOT): in the expression <code>z = x &amp;^ y</code>, each bit of <code>z</code> is 0 if the corresponding bit of <code>y</code> is 1; other wise it equals the corresponding bit of <code>x</code>.</p>
<p>The code below shows how bitwise operations can be used to interpret a <code>uint8</code> value as a compact and efficient set of 8 independent bits. It uses <code>Printf</code>’s <code>%b</code> verb to print a number’s binary digits; <code>08</code> modifies <code>%b</code> (an adverb!) to pad the result with zeros to exactly 8 digits.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>    <span class="c1">// &#34;00100010&#34;, the set {1, 5}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>    <span class="c1">// &#34;00000110&#34;, the set {1, 2}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &#34;00000010&#34;, the intersection {1}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">|</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &#34;00100110&#34;, the union {1, 2, 5}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">^</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &#34;00100100&#34;, the symmetric difference {2, 5}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&amp;^</span><span class="nx">y</span><span class="p">)</span> <span class="c1">// &#34;00100000&#34;, the difference {5}
</span><span class="c1"></span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// membership test
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>   <span class="c1">// &#34;1&#34;, &#34;5&#34;
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &#34;01000100&#34;, the set {2, 6}
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%08b\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &#34;00010001&#34;, the set {0, 4}
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>(<a href="#section-6.5" >Section 6.5</a> shows an implementation of integer sets that can be much bigger than a byte.)</p>
<p>In the shift operations <code>x&lt;&lt;n</code> and <code>x&gt;&gt;n</code>, the <code>n</code> operand determines the number of bit positions to shift and must be unsigned; the <code>x</code> operand may be unsigned or signed. Arithmetically, a left shift <code>x&lt;&lt;n</code> is equivalent to multiplication by 2ⁿ and a right shift <code>x&gt;&gt;n</code> is equivalent to the floor of division by 2ⁿ.</p>
<p>Left shifts fill the vacated bits with zeros, as do right shifts of unsigned numbers, but right shifts of signed numbers fill the vacated bits with copies of the sign bit. For this reason, it is important to use unsigned arithmetic when you’re treating an integer as a bit pattern.</p>
<p>Although Go provides unsigned numbers and arithmetic, we tend to use the signed <code>int</code> form even for quantities that can’t be negative, such as the length of an array, though <code>uint</code> might seem a more obvious choice. Indeed, the built-in <code>len</code> function returns a signed <code>int</code>, as in this loop which announces prize medals in reverse order:</p>
<pre class="code" ><code class="chroma" ><span class="nx">medals</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;gold&#34;</span><span class="p">,</span> <span class="s">&#34;silver&#34;</span><span class="p">,</span> <span class="s">&#34;bronze&#34;</span><span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">medals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">medals</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// &#34;bronze&#34;, &#34;silver&#34;, &#34;gold&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The alternative would be calamitous. If <code>len</code> returned an unsigned number, then <code>i</code> too would be a <code>uint</code>, and the condition <code>i &gt;= 0</code> would always be true by definition. After the third iteration, in which <code>i == 0</code>, the <code>i--</code> statement would cause <code>i</code> to become not -1, but the maximum <code>uint</code> value (for example, 2⁶⁴-1), and the evaluation of <code>medals[i]</code> would fail at run time, or <em>panic</em> (<a href="#section-5.9" >§5.9</a>), by attempting to access an element outside the bounds of the slice.</p>
<p>For this reason, unsigned numbers tend to be used only when their bitwise operators or peculiar arithmetic operators are required, as when implementing bit sets, parsing binary file formats, or for hashing and cryptography. They are typically not used for merely non-negative quantities.</p>
<p>In general, an explicit conversion is required to convert a value from one type to another, and binary operators for arithmetic and logic (except shifts) must have operands of the same type. Although this occasionally results in longer expressions, it also eliminates a whole class of problems and makes programs easier to understand.</p>
<p>As an example familiar from other contexts, consider this sequence:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">apples</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">oranges</span> <span class="kt">int16</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">var</span> <span class="nx">compote</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">apples</span> <span class="o">+</span> <span class="nx">oranges</span> <span class="c1">// compile error
</span><span class="c1"></span></code></pre>
<p>Attempting to compile these three declarations produces an error message:</p>
<div class="pre-block" >
<pre class="pre" >invalid operation: apples + oranges (mismatched types int32 and int16)
</pre>
</div>
<p>This type mismatch can be fixed in several ways, most directly by converting everything to a common type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">compote</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">apples</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">oranges</span><span class="p">)</span>
</code></pre>
<p>As described in <a href="#section-2.5" >Section 2.5</a>, for every type <code>T</code>, the conversion operation <code>T(x)</code> converts the value <code>x</code> to type <code>T</code> if the conversion is allowed. Many integer-to-integer conversions do not entail any change in value; they just tell the compiler how to interpret a value. But a conversion that narrows a big integer into a smaller one, or a conversion from integer to floating-point or vice versa, may change the value or lose precision:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span> <span class="o">:=</span> <span class="mf">3.141</span>          <span class="c1">// a float64
</span><span class="c1"></span><span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>   <span class="c1">// &#34;3.141 3&#34;
</span><span class="c1"></span><span class="nx">f</span> <span class="p">=</span> <span class="mf">1.99</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span></code></pre>
<p>Float to integer conversion discards any fractional part, truncating toward zero. You should avoid conversions in which the operand is out of range for the target type, because the behavior depends on the implementation:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span> <span class="o">:=</span> <span class="mf">1e100</span>  <span class="c1">// a float64
</span><span class="c1"></span><span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// result is implementation-dependent
</span><span class="c1"></span></code></pre>
<p>Integer literals of any size and type can be written as ordinary decimal numbers, or as octal numbers if they begin with <code>0</code>, as in <code>0666</code>, or as hexadecimal if they begin with <code>0x</code> or <code>0X</code>, as in <code>0xdeadbeef</code>. Hex digits may be upper or lower case. Nowadays octal numbers seem to be used for exactly one purpose—file permissions on POSIX systems—but hexadecimal numbers are widely used to emphasize the bit pattern of a number over its numeric value.</p>
<p>When printing numbers using the <code>fmt</code> package, we can control the radix and format with the <code>%d</code>, <code>%o</code>, and <code>%x</code> verbs, as shown in this example:</p>
<pre class="code" ><code class="chroma" ><span class="nx">o</span> <span class="o">:=</span> <span class="mo">0666</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %[1]o %#[1]o\n&#34;</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span> <span class="c1">// &#34;438 666 0666&#34;
</span><span class="c1"></span><span class="nx">x</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %[1]x %#[1]x %#[1]X\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
</span><span class="c1"></span></code></pre>
<p>Note the use of two <code>fmt</code> tricks. Usually a <code>Printf</code> format string containing multiple <code>%</code> verbs would require the same number of extra operands, but the <code>[1]</code> <q>adverbs</q> after <code>%</code> tell <code>Printf</code> to use the first operand over and over again. Second, the <code>#</code> adverb for <code>%o</code> or <code>%x</code> or <code>%X</code> tells <code>Printf</code> to emit a <code>0</code> or <code>0x</code> or <code>0X</code> prefix respectively.</p>
<p>Rune literals are written as a character within single quotes. The simplest example is an ASCII character like <code>&#39;a&#39;</code>, but it’s possible to write any Unicode code point either directly or with numeric escapes, as we will see shortly.</p>
<p>Runes are printed with <code>%c</code>, or with <code>%q</code> if quoting is desired:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ascii</span> <span class="o">:=</span> <span class="sc">&#39;a&#39;</span>
<span class="nx">unicode</span> <span class="o">:=</span> <span class="sc">&#39;𢉩&#39;</span>
<span class="nx">newline</span> <span class="o">:=</span> <span class="sc">&#39;\n&#39;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %[1]c %[1]q\n&#34;</span><span class="p">,</span> <span class="nx">ascii</span><span class="p">)</span>   <span class="c1">// &#34;97 a &#39;a&#39;&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %[1]c %[1]q\n&#34;</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">)</span> <span class="c1">// &#34;22269 𢉩 &#39;𢉩&#39;&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %[1]q\n&#34;</span><span class="p">,</span> <span class="nx">newline</span><span class="p">)</span>       <span class="c1">// &#34;10 &#39;\n&#39;&#34;
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-3.2" >Floating-Point Numbers</h3>
<div class="hBody-3" >
<p>Go provides two sizes of floating-point numbers, <code>float32</code> and <code>float64</code>. Their arithmetic properties are governed by the IEEE 754 standard implemented by all modern CPUs.</p>
<p>Values of these numeric types range from tiny to huge. The limits of floating-point values can be found in the <code>math</code> package. The constant <code>math.MaxFloat32</code>, the largest <code>float32</code>, is about <code>3.4e38</code>, and <code>math.MaxFloat64</code> is about <code>1.8e308</code>. The smallest positive values are near <code>1.4e-45</code> and <code>4.9e-324</code>, respectively.</p>
<p>A <code>float32</code> provides approximately six decimal digits of precision, whereas a <code>float64</code> provides about 15 digits; <code>float64</code> should be preferred for most purposes because <code>float32</code> computations accumulate error rapidly unless one is quite careful, and the smallest positive integer that cannot be exactly represented as a <code>float32</code> is not large:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">16777216</span> <span class="c1">// 1 &lt;&lt; 24
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span> <span class="o">==</span> <span class="nx">f</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1">// &#34;true&#34;!
</span><span class="c1"></span></code></pre>
<p>Floating-point numbers can be written literally using decimals, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">e</span> <span class="p">=</span> <span class="mf">2.71828</span> <span class="c1">// (approximately)
</span><span class="c1"></span></code></pre>
<p>Digits may be omitted before the decimal point (<code>.707</code>) or after it (<code>1.</code>). Very small or very large numbers are better written in scientific notation, with the letter <code>e</code> or <code>E</code> preceding the decimal exponent:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">Avogadro</span> <span class="p">=</span> <span class="mf">6.02214129e23</span>
<span class="kd">const</span> <span class="nx">Planck</span>   <span class="p">=</span> <span class="mf">6.62606957e-34</span>
</code></pre>
<p>Floating-point values are conveniently printed with <code>Printf</code>’s <code>%g</code> verb, which chooses the most compact representation that has adequate precision, but for tables of data, the <code>%e</code> (exponent) or <code>%f</code> (no exponent) forms may be more appropriate. All three verbs allow field width and numeric precision to be controlled.</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;x = %d eˣ = %8.3f\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre>
<p>The code above prints the powers of <em>e</em> with three decimal digits of precision, aligned in an eight-character field:</p>
<div class="pre-block" >
<pre class="pre" >x = 0 eˣ =    1.000
x = 1 eˣ =    2.718
x = 2 eˣ =    7.389
x = 3 eˣ =   20.086
x = 4 eˣ =   54.598
x = 5 eˣ =  148.413
x = 6 eˣ =  403.429
x = 7 eˣ = 1096.633
</pre>
</div>
<p>In addition to a large collection of the usual mathematical functions, the <code>math</code> package has functions for creating and detecting the special values defined by IEEE 754: the positive and negative infinities, which represent numbers of excessive magnitude and the result of division by zero; and NaN (<q>not a number</q>), the result of such mathematically dubious operations as <code>0/0</code> or <code>Sqrt(-1)</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">z</span> <span class="kt">float64</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="nx">z</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="nx">z</span><span class="p">,</span> <span class="nx">z</span><span class="o">/</span><span class="nx">z</span><span class="p">)</span> <span class="c1">// &#34;0 -0 +Inf -Inf NaN&#34;
</span><span class="c1"></span></code></pre>
<p>The function <code>math.IsNaN</code> tests whether its argument is a not-a-number value, and <code>math.NaN</code> returns such a value. It’s tempting to use NaN as a sentinel value in a numeric computation, but testing whether a specific computational result is equal to NaN is fraught with peril because any comparison with NaN <em>always</em> yields <code>false</code> (except <code>!=</code>, which is always the negation of <code>==</code>):</p>
<pre class="code" ><code class="chroma" ><span class="nx">nan</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">NaN</span><span class="p">()</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">nan</span> <span class="o">==</span> <span class="nx">nan</span><span class="p">,</span> <span class="nx">nan</span> <span class="p">&lt;</span> <span class="nx">nan</span><span class="p">,</span> <span class="nx">nan</span> <span class="p">&gt;</span> <span class="nx">nan</span><span class="p">)</span> <span class="c1">// &#34;false false false&#34;
</span><span class="c1"></span></code></pre>
<p>If a function that returns a floating-point result might fail, it’s better to report the failure separately, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">compute</span><span class="p">()</span> <span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">failed</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>The next program illustrates floating-point graphics computation. It plots a function of two variables <code>z = f(x, y)</code> as a wire mesh 3-D surface, using Scalable Vector Graphics (<span class="acronym" >SVG</span>), a standard <span class="acronym" >XML</span> notation for line drawings. Figure 3.1 shows an example of its output for the function <code>sin(r)/r</code>, where <code>r</code> is <code>sqrt(x*x+y*y)</code>.</p>
<div class="figure" >
<h1 class="figure">Figure 3.1. A surface plot of the function <code>sin(r)/r</code>.</h1>
<figure>
<img src="img/Figure-3.1.jpg" />
</figure>
</div>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/surface/main.go" >gopl.io/ch3/surface</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Surface computes an SVG rendering of a 3-D surface function.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="p">=</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">320</span>            <span class="c1">// canvas size in pixels
</span><span class="c1"></span>  <span class="nx">cells</span>         <span class="p">=</span> <span class="mi">100</span>                 <span class="c1">// number of grid cells
</span><span class="c1"></span>  <span class="nx">xyrange</span>       <span class="p">=</span> <span class="mf">30.0</span>                <span class="c1">// axis ranges (-xyrange..+xyrange)
</span><span class="c1"></span>  <span class="nx">xyscale</span>       <span class="p">=</span> <span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="nx">xyrange</span> <span class="c1">// pixels per x or y unit
</span><span class="c1"></span>  <span class="nx">zscale</span>        <span class="p">=</span> <span class="nx">height</span> <span class="o">*</span> <span class="mf">0.4</span>        <span class="c1">// pixels per z unit
</span><span class="c1"></span>  <span class="nx">angle</span>         <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span> <span class="o">/</span> <span class="mi">6</span>         <span class="c1">// angle of x, y axes (=30°)
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">sin30</span><span class="p">,</span> <span class="nx">cos30</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">),</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">)</span> <span class="c1">// sin(30°), cos(30°)
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &#34;</span><span class="o">+</span>
    <span class="s">&#34;style=&#39;stroke: grey; fill: white; stroke-width: 0.7&#39; &#34;</span><span class="o">+</span>
    <span class="s">&#34;width=&#39;%d&#39; height=&#39;%d&#39;&gt;&#34;</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">cells</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">cells</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">ax</span><span class="p">,</span> <span class="nx">ay</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">bx</span><span class="p">,</span> <span class="nx">by</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;&lt;polygon points=&#39;%g,%g %g,%g %g,%g %g,%g&#39;/&gt;\n&#34;</span><span class="p">,</span>
        <span class="nx">ax</span><span class="p">,</span> <span class="nx">ay</span><span class="p">,</span> <span class="nx">bx</span><span class="p">,</span> <span class="nx">by</span><span class="p">,</span> <span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;&lt;/svg&gt;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Find point (x,y) at corner of cell (i,j).
</span><span class="c1"></span>  <span class="nx">x</span> <span class="o">:=</span> <span class="nx">xyrange</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">/</span><span class="nx">cells</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nx">xyrange</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span><span class="o">/</span><span class="nx">cells</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

  <span class="c1">// Compute surface height z.
</span><span class="c1"></span>  <span class="nx">z</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>

  <span class="c1">// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).
</span><span class="c1"></span>  <span class="nx">sx</span> <span class="o">:=</span> <span class="nx">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="nx">y</span><span class="p">)</span><span class="o">*</span><span class="nx">cos30</span><span class="o">*</span><span class="nx">xyscale</span>
  <span class="nx">sy</span> <span class="o">:=</span> <span class="nx">height</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span><span class="o">*</span><span class="nx">sin30</span><span class="o">*</span><span class="nx">xyscale</span> <span class="o">-</span> <span class="nx">z</span><span class="o">*</span><span class="nx">zscale</span>
  <span class="k">return</span> <span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// distance from (0,0)
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Notice that the function <code>corner</code> returns two values, the coordinates of the corner of the cell.</p>
<p>The explanation of how the program works requires only basic geometry, but it’s fine to skip over it, since the point is to illustrate floating-point computation. The essence of the program is mapping between three different coordinate systems, shown in Figure 3.2. The first is a 2-D grid of 100&amp;100 cells identified by integer coordinates <span class="math" >(i, j)</span>, starting at <span class="math" >(0, 0)</span> in the far back corner. We plot from the back to the front so that background polygons may be obscured by foreground ones.</p>
<p>The second coordinate system is a mesh of 3-D floating-point coordinates <span class="math" >(x, y, z)</span>, where <span class="math" >x</span> and <span class="math" >y</span> are linear functions of <span class="math" >i</span> and <span class="math" >j</span>, translated so that the origin is in the center, and scaled by the constant <code>xyrange</code>. The height <span class="math" >z</span> is the value of the surface function <span class="math" >ƒ(x, y)</span>.</p>
<p>The third coordinate system is the 2-D image canvas, with <span class="math" >(0, 0)</span> in the top left corner. Points in this plane are denoted <span class="math" >(sx, sy)</span>. We use an isometric projection to map each 3-D point</p>
<div class="figure" >
<h1 class="figure">Figure 3.2. Three different coordinate systems.</h1>
<figure>
<img src="img/Figure-3.2.jpg" />
</figure>
</div>
<p><span class="math" >(x, y, z)</span> onto the 2-D canvas. A point appears farther to the right on the canvas the greater its <span class="math" >x</span> value or the <em>smaller</em> its <span class="math" >y</span> value. And a point appears farther down the canvas the greater its <span class="math" >x</span> value or <span class="math" >y</span> value, and the smaller its <span class="math" >z</span> value. The vertical and horizontal scale factors for <span class="math" >x</span> and <span class="math" >y</span> are derived from the sine and cosine of a 30° angle. The scale factor for <span class="math" >z</span>, 0.4, is an arbitrary parameter.</p>
<p>For each cell in the 2-D grid, the main function computes the coordinates on the image canvas of the four corners of the polygon ABCD, where B corresponds to <span class="math" >(i, j)</span> and A, C, and D are its neighbors, then prints an SVG instruction to draw it.</p>
<p><b>Exercise 3.1</b>: If the function <code>f</code> returns a non-finite <code>float64</code> value, the SVG file will contain invalid <code>&lt;polygon&gt;</code> elements (although many SVG renderers handle this gracefully). Modify the program to skip invalid polygons.</p>
<p><b>Exercise 3.2</b>: Experiment with visualizations of other functions from the <code>math</code> package. Can you produce an egg box, moguls, or a saddle?</p>
<p><b>Exercise 3.3</b>: Color each polygon based on its height, so that the peaks are colored red (<code>#ff0000</code>) and the valleys blue (<code>#0000ff</code>).</p>
<p><b>Exercise 3.4</b>: Following the approach of the Lissajous example in <a href="#section-1.7" >Section 1.7</a>, construct a web server that computes surfaces and writes SVG data to the client. The server must set the <code>Content-Type</code> header like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span><span class="p">.</span><span class="nx">Header</span><span class="p">().</span><span class="nx">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;image/svg+xml&#34;</span><span class="p">)</span>
</code></pre>
<p>(This step was not required in the Lissajous example because the server uses standard heuristics to recognize common formats like PNG from the first 512 bytes of the response and generates the proper header.) Allow the client to specify values like height, width, and color as HTTP request parameters.</p>
</div>
<h3 id="section-3.3" >Complex Numbers</h3>
<div class="hBody-3" >
<p>Go provides two sizes of complex numbers, <code>complex64</code> and <code>complex128</code>, whose components are <code>float32</code> and <code>float64</code> respectively. The built-in function <code>complex</code> creates a complex number from its real and imaginary components, and the built-in <code>real</code> and <code>imag</code> functions extract those components:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 1+2i
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">y</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// 3+4i
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>                 <span class="c1">// &#34;(-5+10i)&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">))</span>           <span class="c1">// &#34;-5&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">imag</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">))</span>           <span class="c1">// &#34;10&#34;
</span><span class="c1"></span></code></pre>
<p>If a floating-point literal or decimal integer literal is immediately followed by <code>i</code>, such as <code>3.141592i</code> or <code>2i</code>, it becomes an <em>imaginary literal</em>, denoting a complex number with a zero real component:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="m">1i</span> <span class="o">*</span> <span class="m">1i</span><span class="p">)</span> <span class="c1">// &#34;(-1+0i)&#34;, i² = -1
</span><span class="c1"></span></code></pre>
<p>Under the rules for constant arithmetic, complex constants can be added to other constants (integer or floating point, real or imaginary), allowing us to write complex numbers naturally, like <code>1+2i</code>, or equivalently, <code>2i+1</code>. The declarations of <code>x</code> and <code>y</code> above can be simplified:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">+</span> <span class="m">2i</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="mi">3</span> <span class="o">+</span> <span class="m">4i</span>
</code></pre>
<p>Complex numbers may be compared for equality with <code>==</code> and <code>!=</code>. Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</p>
<p>The <code>math/cmplx</code> package provides library functions for working with complex numbers, such as the complex square root and exponentiation functions.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cmplx</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// &#34;(0+1i)&#34;
</span><span class="c1"></span></code></pre>
<p>The following program uses <code>complex128</code> arithmetic to generate a Mandelbrot set.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/mandelbrot/main.go" >gopl.io/ch3/mandelbrot</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Mandelbrot emits a PNG image of the Mandelbrot fractal.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;image&#34;</span>
  <span class="s">&#34;image/color&#34;</span>
  <span class="s">&#34;image/png&#34;</span>
  <span class="s">&#34;math/cmplx&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">xmin</span><span class="p">,</span> <span class="nx">ymin</span><span class="p">,</span> <span class="nx">xmax</span><span class="p">,</span> <span class="nx">ymax</span> <span class="p">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span>
    <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span>          <span class="p">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span>
  <span class="p">)</span>

  <span class="nx">img</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewRGBA</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">py</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">py</span> <span class="p">&lt;</span> <span class="nx">height</span><span class="p">;</span> <span class="nx">py</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">py</span><span class="p">)</span><span class="o">/</span><span class="nx">height</span><span class="o">*</span><span class="p">(</span><span class="nx">ymax</span><span class="o">-</span><span class="nx">ymin</span><span class="p">)</span> <span class="o">+</span> <span class="nx">ymin</span>
    <span class="k">for</span> <span class="nx">px</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">px</span> <span class="p">&lt;</span> <span class="nx">width</span><span class="p">;</span> <span class="nx">px</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">px</span><span class="p">)</span><span class="o">/</span><span class="nx">width</span><span class="o">*</span><span class="p">(</span><span class="nx">xmax</span><span class="o">-</span><span class="nx">xmin</span><span class="p">)</span> <span class="o">+</span> <span class="nx">xmin</span>
      <span class="nx">z</span> <span class="o">:=</span> <span class="nb">complex</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
      <span class="c1">// Image point (px, py) represents complex value z.
</span><span class="c1"></span>      <span class="nx">img</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">px</span><span class="p">,</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">mandelbrot</span><span class="p">(</span><span class="nx">z</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">png</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">img</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">mandelbrot</span><span class="p">(</span><span class="nx">z</span> <span class="kt">complex128</span><span class="p">)</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Color</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">iterations</span> <span class="p">=</span> <span class="mi">200</span>
  <span class="kd">const</span> <span class="nx">contrast</span> <span class="p">=</span> <span class="mi">15</span>

  <span class="kd">var</span> <span class="nx">v</span> <span class="kt">complex128</span>
  <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">iterations</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="o">*</span><span class="nx">v</span> <span class="o">+</span> <span class="nx">z</span>
    <span class="k">if</span> <span class="nx">cmplx</span><span class="p">.</span><span class="nx">Abs</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Gray</span><span class="p">{</span><span class="mi">255</span> <span class="o">-</span> <span class="nx">contrast</span><span class="o">*</span><span class="nx">n</span><span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Black</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The two nested loops iterate over each point in a 1024x1024 grayscale raster image representing the -2 to +2 portion of the complex plane. The program tests whether repeatedly squaring and adding the number that point represents eventually <q>escapes</q> the circle of radius 2. If so, the point is shaded by the number of iterations it took to escape. If not, the value belongs to the Mandelbrot set, and the point remains black. Finally, the program writes to its standard output the PNG-encoded image of the iconic fractal, shown in Figure 3.3.</p>
<div class="figure" >
<h1 class="figure">Figure 3.3. The Mandelbrot set.</h1>
<figure>
<img src="img/Figure-3.3.jpg" />
</figure>
</div>
<p><b>Exercise 3.5</b>: Implement a full-color Mandelbrot set using the function <code>image.NewRGBA</code> and the type <code>color.RGBA</code> or <code>color.YCbCr</code>.</p>
<p><b>Exercise 3.6</b>: Supersampling is a technique to reduce the effect of pixelation by computing the color value at several points within each pixel and taking the average. The simplest method is to divide each pixel into four <q>subpixels.</q> Implement it.</p>
<p><b>Exercise 3.7</b>: Another simple fractal uses Newton’s method to find complex solutions to a function such as <span class="math" >z⁴-1 = 0</span>. Shade each starting point by the number of iterations required to get close to one of the four roots. Color each point by the root it approaches.</p>
<p><b>Exercise 3.8</b>: Rendering fractals at high zoom levels demands great arithmetic precision. Implement the same fractal using four different representations of numbers: <code>complex64</code>, <code>complex128</code>, <code>big.Float</code>, and <code>big.Rat</code>. (The latter two types are found in the <code>math/big</code> package. <code>Float</code> uses arbitrary but bounded-precision floating-point; <code>Rat</code> uses unbounded-precision rational numbers.) How do they compare in performance and memory usage? At what zoom levels do rendering artifacts become visible?</p>
<p><b>Exercise 3.9</b>: Write a web server that renders fractals and writes the image data to the client.  Allow the client to specify the <span class="math" >x</span>, <span class="math" >y</span>, and zoom values as parameters to the HTTP request.</p>
</div>
<h3 id="section-3.4" >Booleans</h3>
<div class="hBody-3" >
<p>A value of type <code>bool</code>, or <em>boolean</em>, has only two possible values, <code>true</code> and <code>false</code>. The conditions in <code>if</code> and <code>for</code> statements are booleans, and comparison operators like <code>==</code> and <code>&lt;</code> produce a boolean result. The unary operator <code>!</code> is logical negation, so <code>!true</code> is <code>false</code>, or, one might say, <code>(!true==false)==true</code>, although as a matter of style, we always simplify redundant boolean expressions like <code>x==true</code> to <code>x</code>.</p>
<p>Boolean values can be combined with the <code>&amp;&amp;</code> (AND) and <code>||</code> (OR) operators, which have <em>shortcircuit</em> behavior: if the answer is already determined by the value of the left operand, the right operand is not evaluated, making it safe to write expressions like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span>
</code></pre>
<p>where <code>s[0]</code> would panic if applied to an empty string.</p>
<p>Since <code>&amp;&amp;</code> has higher precedence than <code>||</code> (mnemonic: <code>&amp;&amp;</code> is boolean multiplication, <code>||</code> is boolean addition), no parentheses are required for conditions of this form:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="o">||</span>
  <span class="sc">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span> <span class="o">||</span>
  <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
  <span class="c1">// ...ASCII letter or digit...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>There is no implicit conversion from a boolean value to a numeric value like 0 or 1, or vice versa. It’s necessary to use an explicit <code>if</code>, as in</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">i</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre>
<p>It might be worth writing a conversion function if this operation were needed often:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// btoi returns 1 if b is true and 0 if false.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">btoi</span><span class="p">(</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
<p>The inverse operation is so simple that it doesn’t warrant a function, but for symmetry here it is:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// itob reports whether i is non-zero.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">itob</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre>
</div>
<h3 id="section-3.5" >Strings</h3>
<div class="hBody-3" >
<p>A string is an immutable sequence of bytes. Strings may contain arbitrary data, including bytes with value 0, but usually they contain human-readable text. Text strings are conventionally interpreted as UTF-8-encoded sequences of Unicode code points (runes), which we’ll explore in detail very soon.</p>
<p>The built-in <code>len</code> function returns the number of bytes (not runes) in a string, and the <em>index</em> operation <code>s[i]</code> retrieves the <span class="math" >i</span>-th byte of string <code>s</code>, where <code>0</code> ≤ <code>i</code> &lt; <code>len(s)</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;hello, world&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>     <span class="c1">// &#34;12&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="c1">// &#34;104 119&#34;  (&#39;h&#39; and &#39;w&#39;)
</span><span class="c1"></span></code></pre>
<p>Attempting to access a byte outside this range results in a panic:</p>
<pre class="code" ><code class="chroma" ><span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span> <span class="c1">// panic: index out of range
</span><span class="c1"></span></code></pre>
<p>The <span class="math" >i</span>-th byte of a string is not necessarily the <span class="math" >i</span>-th <em>character</em> of a string, because the UTF-8 encoding of a non-ASCII code point requires two or more bytes. Working with characters is discussed shortly.</p>
<p>The <em>substring</em> operation <code>s[i:j]</code> yields a new string consisting of the bytes of the original string starting at index <code>i</code> and continuing up to, but not including, the byte at index <code>j</code>. The result contains <code>j-i</code> bytes.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// &#34;hello&#34;
</span><span class="c1"></span></code></pre>
<p>Again, a panic results if either index is out of bounds or if <code>j</code> is less than <code>i</code>.</p>
<p>Either or both of the <code>i</code> and <code>j</code> operands may be omitted, in which case the default values of 0 (the start of the string) and <code>len(s)</code> (its end) are assumed, respectively.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// &#34;hello&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">7</span><span class="p">:])</span> <span class="c1">// &#34;world&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span>  <span class="c1">// &#34;hello, world&#34;
</span><span class="c1"></span></code></pre>
<p>The <code>+</code> operator makes a new string by concatenating two strings:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;goodbye&#34;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span> <span class="c1">// &#34;goodbye, world&#34;
</span><span class="c1"></span></code></pre>
<p>Strings may be compared with comparison operators like <code>==</code> and <code>&lt;</code>; the comparison is done byte by byte, so the result is the natural lexicographic ordering.</p>
<p>String values are immutable: the byte sequence contained in a string value can never be changed, though of course we can assign a new value to a string <em>variable</em>. To append one string to another, for instance, we can write</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;left foot&#34;</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="nx">s</span>
<span class="nx">s</span> <span class="o">+=</span> <span class="s">&#34;, right foot&#34;</span>
</code></pre>
<p>This does not modify the string that <code>s</code> originally held but causes <code>s</code> to hold the new string formed by the <code>+=</code> statement; meanwhile, <code>t</code> still contains the old string.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &#34;left foot, right foot&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// &#34;left foot&#34;
</span><span class="c1"></span></code></pre>
<p>Since strings are immutable, constructions that try to modify a string’s data in place are not allowed:</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;L&#39;</span> <span class="c1">// compile error: cannot assign to s[0]
</span><span class="c1"></span></code></pre>
<p>Immutability means that it is safe for two copies of a string to share the same underlying memory, making it cheap to copy strings of any length. Similarly, a string <code>s</code> and a substring like <code>s[7:]</code> may safely share the same data, so the substring operation is also cheap. No new memory is allocated in either case. Figure 3.4 illustrates the arrangement of a string and two of its substrings sharing the same underlying byte array.</p>
<div class="figure" >
<h1 class="figure">Figure 3.4. The string <code>&#34;hello, world&#34;</code> and two substrings.</h1>
<figure>
<img src="img/Figure-3.4.jpg" />
</figure>
</div>
</div>
<h4 id="section-3.5.1" >String Literals</h4>
<div class="hBody-4" >
<p>A string value can be written as a <em>string literal</em>, a sequence of bytes enclosed in double quotes:</p>
<pre class="code" ><code class="chroma" ><span class="s">&#34;Hello, 世界&#34;</span>
</code></pre>
<p>Because Go source files are always encoded in UTF-8 and Go text strings are conventionally interpreted as UTF-8, we can include Unicode code points in string literals.</p>
<p>Within a double-quoted string literal, <em>escape sequences</em> that begin with a backslash <code>\</code> can be used to insert arbitrary byte values into the string. One set of escapes handles ASCII control codes like newline, carriage return, and tab:</p>
<table border="1">
<tbody>
<tr><td><p><code>\a</code></p>
</td><td><p><q>alert</q> or bell</p>
</td></tr>
<tr><td><p><code>\b</code></p>
</td><td><p>backspace</p>
</td></tr>
<tr><td><p><code>\f</code></p>
</td><td><p>form feed</p>
</td></tr>
<tr><td><p><code>\n</code></p>
</td><td><p>newline</p>
</td></tr>
<tr><td><p><code>\r</code></p>
</td><td><p>carriage return</p>
</td></tr>
<tr><td><p><code>\t</code></p>
</td><td><p>tab</p>
</td></tr>
<tr><td><p><code>\v</code></p>
</td><td><p>vertical tab</p>
</td></tr>
<tr><td><p><code>\&#39;</code></p>
</td><td><p>single quote (only in the rune literal &#39;\&#39;&#39;)</p>
</td></tr>
<tr><td><p><code>\&#34;</code></p>
</td><td><p>double quote (only within &#34;...&#34; literals)</p>
</td></tr>
<tr><td><p><code>\\</code></p>
</td><td><p>backslash</p>
</td></tr>
</tbody>
</table>
<p>Arbitrary bytes can also be included in literal strings using hexadecimal or octal escapes. A <em>hexadecimal</em> escape is written <code>\x</code><em>hh</em>, with exactly two hexadecimal digits <em>h</em> (in upper or lower case). An octal escape is written <em>\ooo</em> with exactly three octal digits <em>o</em> (0 through 7) not exceeding <code>\377</code>. Both denote a single byte with the specified value. Later, we’ll see how to encode Unicode code points numerically in string literals.</p>
<p>A <em>raw string literal</em> is written <code>`...`</code>, using backquotes instead of double quotes. Within a raw string literal, no escape sequences are processed; the contents are taken literally, including backslashes and newlines, so a raw string literal may spread over several lines in the program source. The only processing is that carriage returns are deleted so that the value of the string is the same on all platforms, including those that conventionally put carriage returns in text files.</p>
<p>Raw string literals are a convenient way to write regular expressions, which tend to have lots of backslashes. They are also useful for HTML templates, JSON literals, command usage messages, and the like, which often extend over multiple lines.</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">GoUsage</span> <span class="p">=</span> <span class="s">`Go is a tool for managing Go source code.
</span><span class="s">
</span><span class="s">Usage:
</span><span class="s">    go command [arguments]
</span><span class="s">...`</span>
</code></pre>
</div>
<h4 id="section-3.5.2" >Unicode</h4>
<div class="hBody-4" >
<p>Long ago, life was simple and there was, at least in a parochial view, only one character set to deal with: ASCII, the American Standard Code for Information Interchange. ASCII, or more precisely US-ASCII, uses 7 bits to represent 128 <q>characters</q>: the upper- and lower-case letters of English, digits, and a variety of punctuation and device-control characters. For much of the early days of computing, this was adequate, but it left a very large fraction of the world’s population unable to use their own writing systems in computers. With the growth of the Internet, data in myriad languages has become much more common. How can this rich variety be dealt with at all and, if possible, efficiently?</p>
<p>The answer is Unicode (<a href="http://unicode.org/" >unicode.org</a>), which collects all of the characters in all of the world’s writing systems, plus accents and other diacritical marks, control codes like tab and carriage return, and plenty of esoterica, and assigns each one a standard number called a <em>Unicode code point</em> or, in Go terminology, a <code>rune</code>.</p>
<p>Unicode version 8 defines code points for over 120,000 characters in well over 100 languages and scripts. How are these represented in computer programs and data? The natural data type to hold a single rune is <code>int32</code>, and that’s what Go uses; it has the synonym <code>rune</code> for precisely this purpose.</p>
<p>We could represent a sequence of runes as a sequence of <code>int32</code> values. In this representation, which is called UTF-32 or UCS-4, the encoding of each Unicode code point has the same size, 32 bits. This is simple and uniform, but it uses much more space than necessary since most computer-readable text is in ASCII, which requires only 8 bits or 1 byte per character. All the characters in widespread use still number fewer than 65,536, which would fit in 16 bits. Can we do better?</p>
</div>
<h4 id="section-3.5.3" >UTF-8</h4>
<div class="hBody-4" >
<p>UTF-8 is a variable-length encoding of Unicode code points as bytes. UTF-8 was invented by Ken Thompson and Rob Pike, two of the creators of Go, and is now a Unicode standard. It uses between 1 and 4 bytes to represent each rune, but only 1 byte for ASCII characters, and only 2 or 3 bytes for most runes in common use. The high-order bits of the first byte of the encoding for a rune indicate how many bytes follow. A high-order <code>0</code> indicates 7-bit ASCII, where each rune takes only 1 byte, so it is identical to conventional ASCII. A high-order <code>110</code> indicates that the rune takes 2 bytes; the second byte begins with <code>10</code>. Larger runes have analogous encodings.</p>
<table border="1">
<tbody>
<tr><td><p><code>0xxxxxx</code></p>
</td><td><p>runes 0−127</p>
</td><td><p>(ASCII)</p>
</td></tr>
<tr><td><p><code>110xxxx 10xxxxxx</code></p>
</td><td><p>128−2047</p>
</td><td><p>(values &lt;128 unused)</p>
</td></tr>
<tr><td><p><code>1110xxx 10xxxxxx 10xxxxxx</code></p>
</td><td><p>2048−65535</p>
</td><td><p>(values &lt;2048 unused)</p>
</td></tr>
<tr><td><p><code>11110xx 10xxxxxx 10xxxxxx 10xxxxxx</code></p>
</td><td><p>65536−0x10ffff</p>
</td><td><p>(other values unused)</p>
</td></tr>
</tbody>
</table>
<p>A variable-length encoding precludes direct indexing to access the <span class="math" >n</span>-th character of a string, but UTF-8 has many desirable properties to compensate. The encoding is compact, compatible with ASCII, and self-synchronizing: it’s possible to find the beginning of a character by backing up no more than three bytes. It’s also a prefix code, so it can be decoded from left to right without any ambiguity or lookahead. No rune’s encoding is a substring of any other, or even of a sequence of others, so you can search for a rune by just searching for its bytes, without worrying about the preceding context. The lexicographic byte order equals the Unicode code point order, so sorting UTF-8 works naturally. There are no embedded NUL (zero) bytes, which is convenient for programming languages that use NUL to terminate strings.</p>
<p>Go source files are always encoded in UTF-8, and UTF-8 is the preferred encoding for text strings manipulated by Go programs. The <code>unicode</code> package provides functions for working with individual runes (such as distinguishing letters from numbers, or converting an uppercase letter to a lower-case one), and the <code>unicode/utf8</code> package provides functions for encoding and decoding runes as bytes using UTF-8.</p>
<p>Many Unicode characters are hard to type on a keyboard or to distinguish visually from similar-looking ones; some are even invisible. Unicode escapes in Go string literals allow us to specify them by their numeric code point value. There are two forms, <code>\u</code><em>hhhh</em> for a 16-bit value and <code>\U</code><em>hhhhhhhh</em> for a 32-bit value, where each <em>h</em> is a hexadecimal digit; the need for the 32-bit form arises very infrequently. Each denotes the UTF-8 encoding of the specified code point. Thus, for example, the following string literals all represent the same six-byte string:</p>
<pre class="code" ><code class="chroma" ><span class="s">&#34;世界&#34;</span>
<span class="s">&#34;\xe4\xb8\x96\xe7\x95\x8c&#34;</span>
<span class="s">&#34;\u4e16\u754c&#34;</span>
<span class="s">&#34;\U00004e16\U0000754c&#34;</span>
</code></pre>
<p>The three escape sequences above provide alternative notations for the first string, but the values they denote are identical.  Unicode escapes may also be used in rune literals. These three literals are equivalent:</p>
<div class="pre-block" >
<pre class="pre" >&#39;世&#39; &#39;\u4e16&#39; &#39;\U00004e16&#39;
</pre>
</div>
<p>A rune whose value is less than 256 may be written with a single hexadecimal escape, such as <code>&#39;\x41&#39;</code> for <code>&#39;A&#39;</code>, but for higher values, a <code>\u</code> or <code>\U</code> escape must be used. Consequently, <code>&#39;\xe4\xb8\x96&#39;</code> is not a legal rune literal, even though those three bytes are a valid UTF-8 encoding of a single code point.</p>
<p>Thanks to the nice properties of UTF-8, many string operations don’t require decoding. We can test whether one string contains another as a prefix:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)]</span> <span class="o">==</span> <span class="nx">prefix</span>
<span class="p">}</span>
</code></pre>
<p>or as a suffix:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">HasSuffix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">suffix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">suffix</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">suffix</span><span class="p">):]</span> <span class="o">==</span> <span class="nx">suffix</span>
<span class="p">}</span>
</code></pre>
<p>or as a substring:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">substr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">substr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<p>using the same logic for UTF-8-encoded text as for raw bytes. This is not true for other encodings. (The functions above are drawn from the <code>strings</code> package, though its implementation of <code>Contains</code> uses a hashing technique to search more efficiently.)</p>
<p>On the other hand, if we really care about the individual Unicode characters, we have to use other mechanisms. Consider the string from our very first example, which includes two East Asian characters. Figure 3.5 illustrates its representation in memory. The string contains 13 bytes, but interpreted as UTF-8, it encodes only nine code points or runes:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;unicode/utf8&#34;</span>

<span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;Hello, 世界&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>                    <span class="c1">// &#34;13&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneCountInString</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// &#34;9&#34;
</span><span class="c1"></span></code></pre>
<p>To process those characters, we need a UTF-8 decoder. The <code>unicode/utf8</code> package provides one that we can use like this:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">DecodeRuneInString</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%c\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
  <span class="nx">i</span> <span class="o">+=</span> <span class="nx">size</span>
<span class="p">}</span>
</code></pre>
<p>Each call to <code>DecodeRuneInString</code> returns <code>r</code>, the rune itself, and <code>size</code>, the number of bytes occupied by the UTF-8 encoding of <code>r</code>. The size is used to update the byte index <code>i</code> of the next rune in the string. But this is clumsy, and we need loops of this kind all the time. Fortunately, Go’s <code>range</code> loop, when applied to a string, performs UTF-8 decoding implicitly. The output of the loop below is also shown in Figure 3.5; notice how the index jumps by more than 1 for each non-ASCII rune.</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&#34;Hello, 世界&#34;</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%q\t%d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<div class="figure" >
<h1 class="figure">Figure 3.5. A <code>range</code> loop decodes a UTF-8-encoded string.</h1>
<figure>
<img src="img/Figure-3.5.jpg" />
</figure>
</div>
<p>We could use a simple <code>range</code> loop to count the number of runes in a string, like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="nx">n</span><span class="o">++</span>
<span class="p">}</span>
</code></pre>
<p>As with the other forms of <code>range</code> loop, we can omit the variables we don’t need:</p>
<pre class="code" ><code class="chroma" ><span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="nx">n</span><span class="o">++</span>
<span class="p">}</span>
</code></pre>
<p>Or we can just call <code>utf8.RuneCountInString(s)</code>.</p>
<p>We mentioned earlier that it is mostly a matter of convention in Go that text strings are interpreted as UTF-8-encoded sequences of Unicode code points, but for correct use of <code>range</code> loops on strings, it’s more than a convention, it’s a necessity. What happens if we range over a string containing arbitrary binary data or, for that matter, UTF-8 data containing errors?</p>
<p>Each time a UTF-8 decoder, whether explicit in a call to <code>utf8.DecodeRuneInString</code> or implicit in a <code>range</code> loop, consumes an unexpected input byte, it generates a special Unicode <em>replacement character</em>, <code>&#39;\uFFFD&#39;</code>, which is usually printed as a white question mark inside a black hexagonal or diamond-like shape �. When a program encounters this rune value, it’s often a sign that some upstream part of the system that generated the string data has been careless in its treatment of text encodings.</p>
<p>UTF-8 is exceptionally convenient as an interchange format but within a program runes may be more convenient because they are of uniform size and are thus easily indexed in arrays and slices.</p>
<p>A <code>[]rune</code> conversion applied to a UTF-8-encoded string returns the sequence of Unicode code points that the string encodes:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// &#34;program&#34; in Japanese katakana
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;プログラム&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;% x\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// &#34;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&#34;
</span><span class="c1"></span><span class="nx">r</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%x\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>  <span class="c1">// &#34;[30d7 30ed 30b0 30e9 30e0]&#34;
</span><span class="c1"></span></code></pre>
<p>(The verb <code>% x</code> in the first <code>Printf</code> inserts a space between each pair of hex digits.)</p>
<p>If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span> <span class="c1">// &#34;プログラム&#34;
</span><span class="c1"></span></code></pre>
<p>Converting an integer value to a string interprets the integer as a rune value, and yields the UTF-8 representation of that rune:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mi">65</span><span class="p">))</span>     <span class="c1">// &#34;A&#34;, not &#34;65&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mh">0x4eac</span><span class="p">))</span> <span class="c1">// &#34;京&#34;
</span><span class="c1"></span></code></pre>
<p>If the rune is invalid, the replacement character is substituted:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mi">1234567</span><span class="p">))</span> <span class="c1">// &#34;�&#34;
</span><span class="c1"></span></code></pre>
</div>
<h4 id="section-3.5.4" >Strings and Byte Slices</h4>
<div class="hBody-4" >
<p>Four standard packages are particularly important for manipulating strings: <code>bytes</code>, <code>strings</code>, <code>strconv</code>, and <code>unicode</code>. The <code>strings</code> package provides many functions for searching, replacing, comparing, trimming, splitting, and joining strings.</p>
<p>The <code>bytes</code> package has similar functions for manipulating slices of bytes, of type <code>[]byte</code>, which share some properties with strings. Because strings are immutable, building up strings incrementally can involve a lot of allocation and copying. In such cases, it’s more efficient to use the <code>bytes.Buffer</code> type, which we’ll show in a moment.</p>
<p>The <code>strconv</code> package provides functions for converting boolean, integer, and floating-point values to and from their string representations, and functions for quoting and unquoting strings.</p>
<p>The <code>unicode</code> package provides functions like <code>IsDigit</code>, <code>IsLetter</code>, <code>IsUpper</code>, and <code>IsLower</code> for classifying runes. Each function takes a single rune argument and returns a boolean. Conversion functions like <code>ToUpper</code> and <code>ToLower</code> convert a rune into the given case if it is a letter. All these functions use the Unicode standard categories for letters, digits, and so on. The <code>strings</code> package has similar functions, also called <code>ToUpper</code> and <code>ToLower</code>, that return a new string with the specified transformation applied to each character of the original string.</p>
<p>The <code>basename</code> function below was inspired by the Unix shell utility of the same name. In our version, <code>basename</code>(s) removes any prefix of s that looks like a file system path with components separated by slashes, and it removes any suffix that looks like a file type:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&#34;a/b/c.go&#34;</span><span class="p">))</span> <span class="c1">// &#34;c&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&#34;c.d.go&#34;</span><span class="p">))</span>   <span class="c1">// &#34;c.d&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">))</span>      <span class="c1">// &#34;abc&#34;
</span><span class="c1"></span></code></pre>
<p>The first version of <code>basename</code> does all the work without the help of libraries:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/basename1/main.go" >gopl.io/ch3/basename1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// basename removes directory components and a .suffix.
</span><span class="c1">// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.c
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">basename</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="c1">// Discard last &#39;/&#39; and everything before.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
      <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Preserve everything before last &#39;.&#39;.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="p">{</span>
      <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre>
</div>
<p>A simpler version uses the <code>strings.LastIndex</code> library function:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/basename2/main.go" >gopl.io/ch3/basename2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">basename</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">slash</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">LastIndex</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span> <span class="c1">// -1 if &#34;/&#34; not found
</span><span class="c1"></span>  <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">slash</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="nx">dot</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">LastIndex</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">);</span> <span class="nx">dot</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">dot</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>path</code> and <code>path/filepath</code> packages provide a more general set of functions for manipulating hierarchical names. The <code>path</code> package works with slash-delimited paths on any platform. It shouldn’t be used for file names, but it is appropriate for other domains, like the path component of a URL. By contrast, <code>path/filepath</code> manipulates file names using the rules for the host platform, such as <code>/foo/bar</code> for POSIX or <code>c:\foo\bar</code> on Microsoft Windows.</p>
<p>Let’s continue with another substring example. The task is to take a string representation of an integer, such as <code>&#34;12345&#34;</code>, and insert commas every three places, as in <code>&#34;12,345&#34;</code>. This version only works for integers; handling floating-point numbers is left as an exercise.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/comma/main.go" >gopl.io/ch3/comma</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// comma inserts commas in a non-negative decimal integer string.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">comma</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">comma</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The argument to <code>comma</code> is a string. If its length is less than or equal to 3, no comma is necessary. Otherwise, <code>comma</code> calls itself recursively with a substring consisting of all but the last three characters, and appends a comma and the last three characters to the result of the recursive call.</p>
<p>A string contains an array of bytes that, once created, is immutable. By contrast, the elements of a byte slice can be freely modified.</p>
<p>Strings can be converted to byte slices and back again:</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;abc&#34;</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</code></pre>
<p>Conceptually, the <code>[]byte(s)</code> conversion allocates a new byte array holding a copy of the bytes of <code>s</code>, and yields a slice that references the entirety of that array. An optimizing compiler may be able to avoid the allocation and copying in some cases, but in general copying is required to ensure that the bytes of <code>s</code> remain unchanged even if those of <code>b</code> are subsequently modified. The conversion from byte slice back to string with <code>string(b)</code> also makes a copy, to ensure immutability of the resulting string <code>s2</code>.</p>
<p>To avoid conversions and unnecessary memory allocation, many of the utility functions in the <code>bytes</code> package directly parallel their counterparts in the <code>strings</code> package. For example, here are half a dozen functions from <code>strings</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">substr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Fields</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</code></pre>
<p>and the corresponding ones from <code>bytes</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">subslice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Fields</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span>
<span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="nx">s</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</code></pre>
<p>The only difference is that strings have been replaced by byte slices.</p>
<p>The <code>bytes</code> package provides the <code>Buffer</code> type for efficient manipulation of byte slices. A <code>Buffer</code> starts out empty but grows as data of types like <code>string</code>, <code>byte</code>, and <code>[]byte</code> are written to it. As the example below shows, a <code>bytes.Buffer</code> variable requires no initialization because its zero value is usable:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/printints/main.go" >gopl.io/ch3/printints</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// intsToString is like fmt.Sprint(values) but adds commas.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">intsToString</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&#34;, &#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">intsToString</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}))</span> <span class="c1">// &#34;[1, 2, 3]&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>When appending the UTF-8 encoding of an arbitrary rune to a <code>bytes.Buffer</code>, it’s best to use <code>bytes.Buffer</code>’s <code>WriteRune</code> method, but <code>WriteByte</code> is fine for ASCII characters such as <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>.</p>
<p>The <code>bytes.Buffer</code> type is extremely versatile, and when we discuss interfaces in <a href="#chapter-7" >Chapter 7</a>, we’ll see how it may be used as a replacement for a file whenever an I/O function requires a sink for bytes (<code>io.Writer</code>) as <code>Fprintf</code> does above, or a source of bytes (<code>io.Reader</code>).</p>
<p><b>Exercise 3.10</b>: Write a non-recursive version of <code>comma</code>, using <code>bytes.Buffer</code> instead of string concatenation.</p>
<p><b>Exercise 3.11</b>: Enhance <code>comma</code> so that it deals correctly with floating-point numbers and an optional sign.</p>
<p><b>Exercise 3.12</b>: Write a function that reports whether two strings are anagrams of each other, that is, they contain the same letters in a different order.</p>
</div>
<h4 id="section-3.5.5" >Conversions between Strings and Numbers</h4>
<div class="hBody-4" >
<p>In addition to conversions between strings, runes, and bytes, it’s often necessary to convert between numeric values and their string representations. This is done with functions from the <code>strconv</code> package.</p>
<p>To convert an integer to a string, one option is to use <code>fmt.Sprintf</code>; another is to use the function <code>strconv.Itoa</code> (<q>integer to ASCII</q>):</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">123</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// &#34;123 123&#34;
</span><span class="c1"></span></code></pre>
<p><code>FormatInt</code> and <code>FormatUint</code> can be used to format numbers in a different base:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &#34;1111011&#34;
</span><span class="c1"></span></code></pre>
<p>The <code>fmt.Printf</code> verbs <code>%b</code>, <code>%d</code>, <code>%o</code>, and <code>%x</code> are often more convenient than <code>Format</code> functions, especially if we want to include additional information besides the number:</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;x=%b&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;x=1111011&#34;
</span><span class="c1"></span></code></pre>
<p>To parse a string representing an integer, use the <code>strconv</code> functions <code>Atoi</code> or <code>ParseInt</code>, or ParseUint for unsigned integers:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">)</span>             <span class="c1">// x is an int
</span><span class="c1"></span><span class="nx">y</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="c1">// base 10, up to 64 bits
</span><span class="c1"></span></code></pre>
<p>The third argument of <code>ParseInt</code> gives the size of the integer type that the result must fit into; for example, 16 implies <code>int16</code>, and the special value of 0 implies <code>int</code>. In any case, the type of the result y is always <code>int64</code>, which you can then convert to a smaller type.</p>
<p>Sometimes <code>fmt.Scanf</code> is useful for parsing input that consists of orderly mixtures of strings and numbers all on a single line, but it can be inflexible, especially when handling incomplete or irregular input.</p>
</div>
<h3 id="section-3.6" >Constants</h3>
<div class="hBody-3" >
<p>Constants are expressions whose value is known to the compiler and whose evaluation is guaranteed to occur at compile time, not at run time. The underlying type of every constant is a basic type: boolean, string, or number.</p>
<p>A <code>const</code> declaration defines named values that look syntactically like variables but whose value is constant, which prevents accidental (or nefarious) changes during program execution.  For instance, a constant is more appropriate than a variable for a mathematical constant like <code>pi</code>, since its value won’t change:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.14159</span> <span class="c1">// approximately; math.Pi is a better approximation
</span><span class="c1"></span></code></pre>
<p>As with variables, a sequence of constants can appear in one declaration; this would be appropriate for a group of related values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">e</span>  <span class="p">=</span> <span class="mf">2.71828182845904523536028747135266249775724709369995957496696763</span>
  <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.14159265358979323846264338327950288419716939937510582097494459</span>
<span class="p">)</span>
</code></pre>
<p>Many computations on constants can be completely evaluated at compile time, reducing the work necessary at run time and enabling other compiler optimizations. Errors ordinarily detected at run time can be reported at compile time when their operands are constants, such as integer division by zero, string indexing out of bounds, and any floating-point operation that would result in a non-finite value.</p>
<p>The results of all arithmetic, logical, and comparison operations applied to constant operands are themselves constants, as are the results of conversions and calls to certain built-in functions such as <code>len</code>, <code>cap</code>, <code>real</code>, <code>imag</code>, <code>complex</code>, and <code>unsafe.Sizeof</code> (<a href="#section-13.1" >§13.1</a>).</p>
<p>Since their values are known to the compiler, constant expressions may appear in types, specifically as the length of an array type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">IPv4Len</span> <span class="p">=</span> <span class="mi">4</span>

<span class="c1">// parseIPv4 parses an IPv4 address (d.d.d.d).
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">parseIPv4</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">IP</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="p">[</span><span class="nx">IPv4Len</span><span class="p">]</span><span class="kt">byte</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>A constant declaration may specify a type as well as a value, but in the absence of an explicit type, the type is inferred from the expression on the right-hand side. In the following, <code>time.Duration</code> is a named type whose underlying type is <code>int64</code>, and <code>time.Minute</code> is a constant of that type. Both of the constants declared below thus have the type <code>time.Duration</code> as well, as revealed by <code>%T</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">noDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">const</span> <span class="nx">timeout</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T %[1]v\n&#34;</span><span class="p">,</span> <span class="nx">noDelay</span><span class="p">)</span>     <span class="c1">// &#34;time.Duration 0&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T %[1]v\n&#34;</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>     <span class="c1">// &#34;time.Duration 5m0s&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T %[1]v\n&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span> <span class="c1">// &#34;time.Duration 1m0s&#34;
</span><span class="c1"></span></code></pre>
<p>When a sequence of constants is declared as a group, the right-hand side expression may be omitted for all but the first of the group, implying that the previous expression and its type should be used again. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span>
  <span class="nx">c</span> <span class="p">=</span> <span class="mi">2</span>
  <span class="nx">d</span>
<span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">// &#34;1 1 2 2&#34;
</span><span class="c1"></span></code></pre>
<p>This is not very useful if the implicitly copied right-hand side expression always evaluates to the same thing. But what if it could vary? This brings us to <code>iota</code>.</p>
</div>
<h4 id="section-3.6.1" >The Constant Generator <code>iota</code></h4>
<div class="hBody-4" >
<p>A <code>const</code> declaration may use the <em>constant generator</em> <code>iota</code>, which is used to create a sequence of related values without spelling out each one explicitly. In a <code>const</code> declaration, the value of <code>iota</code> begins at zero and increments by one for each item in the sequence.</p>
<p>Here’s an example from the <code>time</code> package, which defines named constants of type <code>Weekday</code> for the days of the week, starting with zero for <code>Sunday</code>. Types of this kind are often called <em>enumerations</em>, or <em>enums</em> for short.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Weekday</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Sunday</span> <span class="nx">Weekday</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Monday</span>
  <span class="nx">Tuesday</span>
  <span class="nx">Wednesday</span>
  <span class="nx">Thursday</span>
  <span class="nx">Friday</span>
  <span class="nx">Saturday</span>
<span class="p">)</span>
</code></pre>
<p>This declares <code>Sunday</code> to be 0, <code>Monday</code> to be 1, and so on.</p>
<p>We can use <code>iota</code> in more complex expressions too, as in this example from the <code>net</code> package where each of the lowest 5 bits of an unsigned integer is given a distinct name and boolean interpretation:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Flags</span> <span class="kt">uint</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">FlagUp</span> <span class="nx">Flags</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// is up
</span><span class="c1"></span>  <span class="nx">FlagBroadcast</span>            <span class="c1">// supports broadcast access capability
</span><span class="c1"></span>  <span class="nx">FlagLoopback</span>             <span class="c1">// is a loopback interface
</span><span class="c1"></span>  <span class="nx">FlagPointToPoint</span>         <span class="c1">// belongs to a point-to-point link
</span><span class="c1"></span>  <span class="nx">FlagMulticast</span>            <span class="c1">// supports multicast access capability
</span><span class="c1"></span><span class="p">)</span>
</code></pre>
<p>As <code>iota</code> increments, each constant is assigned the value of <code>1 &lt;&lt; iota</code>, which evaluates to successive powers of two, each corresponding to a single bit. We can use these constants within functions that test, set, or clear one or more of these bits:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch3/netflag/netflag.go" >gopl.io/ch3/netflag</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Flags</span><span class="p">)</span> <span class="kt">bool</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">v</span><span class="o">&amp;</span><span class="nx">FlagUp</span> <span class="o">==</span> <span class="nx">FlagUp</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TurnDown</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Flags</span><span class="p">)</span>     <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="o">&amp;^=</span> <span class="nx">FlagUp</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">SetBroadcast</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Flags</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="o">|=</span> <span class="nx">FlagBroadcast</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">IsCast</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Flags</span><span class="p">)</span> <span class="kt">bool</span>   <span class="p">{</span> <span class="k">return</span> <span class="nx">v</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">FlagBroadcast</span><span class="p">|</span><span class="nx">FlagMulticast</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="nx">Flags</span> <span class="p">=</span> <span class="nx">FlagMulticast</span> <span class="p">|</span> <span class="nx">FlagUp</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%b %t\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &#34;10001 true&#34;
</span><span class="c1"></span>  <span class="nx">TurnDown</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%b %t\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &#34;10000 false&#34;
</span><span class="c1"></span>  <span class="nx">SetBroadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%b %t\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &#34;10010 false&#34;
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%b %t\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsCast</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &#34;10010 true&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>As a more complex example of <code>iota</code>, this declaration names the powers of 1024:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">_</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
  <span class="nx">KiB</span> <span class="c1">// 1024
</span><span class="c1"></span>  <span class="nx">MiB</span> <span class="c1">// 1048576
</span><span class="c1"></span>  <span class="nx">GiB</span> <span class="c1">// 1073741824
</span><span class="c1"></span>  <span class="nx">TiB</span> <span class="c1">// 1099511627776              (exceeds 1 &lt;&lt; 32)
</span><span class="c1"></span>  <span class="nx">PiB</span> <span class="c1">// 1125899906842624
</span><span class="c1"></span>  <span class="nx">EiB</span> <span class="c1">// 1152921504606846976
</span><span class="c1"></span>  <span class="nx">ZiB</span> <span class="c1">// 1180591620717411303424     (exceeds 1 &lt;&lt; 64)
</span><span class="c1"></span>  <span class="nx">YiB</span> <span class="c1">// 1208925819614629174706176
</span><span class="c1"></span><span class="p">)</span>
</code></pre>
<p>The <code>iota</code> mechanism has its limits. For example, it’s not possible to generate the more familiar powers of 1000 (KB, MB, and so on) because there is no exponentiation operator.</p>
<p><b>Exercise 3.13</b>: Write <code>const</code> declarations for KB, MB, up through YB as compactly as you can.</p>
</div>
<h4 id="section-3.6.2" >Untyped Constants</h4>
<div class="hBody-4" >
<p>Constants in Go are a bit unusual. Although a constant can have any of the basic data types like <code>int</code> or <code>float64</code>, including named basic types like <code>time.Duration</code>, many constants are not committed to a particular type. The compiler represents these uncommitted constants with much greater numeric precision than values of basic types, and arithmetic on them is more precise than machine arithmetic; you may assume at least 256 bits of precision. There are six flavors of these uncommitted constants, called <em>untyped</em> boolean, untyped integer, untyped rune, untyped floating-point, untyped complex, and untyped string.</p>
<p>By deferring this commitment, untyped constants not only retain their higher precision until later, but they can participate in many more expressions than committed constants without requiring conversions. For example, the values <code>ZiB</code> and <code>YiB</code> in the example above are too big to store in any integer variable, but they are legitimate constants that may be used in expressions like this one:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">YiB</span><span class="o">/</span><span class="nx">ZiB</span><span class="p">)</span> <span class="c1">// &#34;1024&#34;
</span><span class="c1"></span></code></pre>
<p>As another example, the floating-point constant <code>math.Pi</code> may be used wherever any floatingpoint or complex value is needed:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
</code></pre>
<p>If <code>math.Pi</code> had been committed to a specific type such as <code>float64</code>, the result would not be as precise, and type conversions would be required to use it when a <code>float32</code> or <code>complex128</code> value is wanted:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">Pi64</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">Pi64</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex128</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
</code></pre>
<p>For literals, syntax determines flavor. The literals <code>0</code>, <code>0.0</code>, <code>0i</code>, and <code>&#39;\u0000&#39;</code> all denote constants of the same value but different flavors: untyped integer, untyped floating-point, untyped complex, and untyped rune, respectively. Similarly, <code>true</code> and <code>false</code> are untyped booleans and string literals are untyped strings.</p>
<p>Recall that <code>/</code> may represent integer or floating-point division depending on its operands.  Consequently, the choice of literal may affect the result of a constant division expression:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">212</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span>     <span class="c1">// &#34;100&#34;; (f - 32) * 5 is a float64
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span> <span class="o">*</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">))</span>     <span class="c1">// &#34;0&#34;;   5/9 is an untyped integer, 0
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">9.0</span> <span class="o">*</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">))</span> <span class="c1">// &#34;100&#34;; 5.0/9.0 is an untyped float
</span><span class="c1"></span></code></pre>
<p>Only constants can be untyped. When an untyped constant is assigned to a variable, as in the first statement below, or appears on the right-hand side of a variable declaration with an explicit type, as in the other three statements, the constant is implicitly converted to the type of that variable if possible.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="m">0i</span> <span class="c1">// untyped complex -&gt; float64
</span><span class="c1"></span><span class="nx">f</span> <span class="p">=</span> <span class="mi">2</span>                  <span class="c1">// untyped integer -&gt; float64
</span><span class="c1"></span><span class="nx">f</span> <span class="p">=</span> <span class="mf">1e123</span>              <span class="c1">// untyped floating-point -&gt; float64
</span><span class="c1"></span><span class="nx">f</span> <span class="p">=</span> <span class="sc">&#39;a&#39;</span>                <span class="c1">// untyped rune -&gt; float64
</span><span class="c1"></span></code></pre>
<p>The statements above are thus equivalent to these:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="m">0i</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mf">1e123</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
</code></pre>
<p>Whether implicit or explicit, converting a constant from one type to another requires that the target type can represent the original value. Rounding is allowed for real and complex floating-point numbers:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">deadbeef</span> <span class="p">=</span> <span class="mh">0xdeadbeef</span> <span class="c1">// untyped int with value 3735928559
</span><span class="c1"></span>  <span class="nx">a</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span>  <span class="c1">// uint32 with value 3735928559
</span><span class="c1"></span>  <span class="nx">b</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span> <span class="c1">// float32 with value 3735928576 (rounded up)
</span><span class="c1"></span>  <span class="nx">c</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span> <span class="c1">// float64 with value 3735928559 (exact)
</span><span class="c1"></span>  <span class="nx">d</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span>   <span class="c1">// compile error: constant overflows int32
</span><span class="c1"></span>  <span class="nx">e</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mf">1e309</span><span class="p">)</span>    <span class="c1">// compile error: constant overflows float64
</span><span class="c1"></span>  <span class="nx">f</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>          <span class="c1">// compile error: constant underflows uint
</span><span class="c1"></span><span class="p">)</span>
</code></pre>
<p>In a variable declaration without an explicit type (including short variable declarations), the flavor of the untyped constant implicitly determines the default type of the variable, as in these examples:</p>
<pre class="code" ><code class="chroma" ><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>      <span class="c1">// untyped integer;        implicit int(0)
</span><span class="c1"></span><span class="nx">r</span> <span class="o">:=</span> <span class="sc">&#39;\000&#39;</span> <span class="c1">// untyped rune;           implicit rune(&#39;\000&#39;)
</span><span class="c1"></span><span class="nx">f</span> <span class="o">:=</span> <span class="mf">0.0</span>    <span class="c1">// untyped floating-point; implicit float64(0.0)
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="m">0i</span>     <span class="c1">// untyped complex;        implicit complex128(0i)
</span><span class="c1"></span></code></pre>
<p>Note the asymmetry: untyped integers are converted to <code>int</code>, whose size is not guaranteed, but untyped floating-point and complex numbers are converted to the explicitly sized types <code>float64</code> and <code>complex128</code>. The language has no unsized <code>float</code> and <code>complex</code> types analogous to unsized <code>int</code>, because it is very difficult to write correct numerical algorithms without knowing the size of one’s floating-point data types.</p>
<p>To give the variable a different type, we must explicitly convert the untyped constant to the desired type or state the desired type in the variable declaration, as in these examples:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="nb">int8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int8</span> <span class="p">=</span> <span class="mi">0</span>
</code></pre>
<p>These defaults are particularly important when converting an untyped constant to an interface value (see <a href="#chapter-7" >Chapter 7</a>) since they determine its dynamic type.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">// &#34;int&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>    <span class="c1">// &#34;float64&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="m">0i</span><span class="p">)</span>     <span class="c1">// &#34;complex128&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="sc">&#39;\000&#39;</span><span class="p">)</span> <span class="c1">// &#34;int32&#34; (rune)
</span><span class="c1"></span></code></pre>
<p>We’ve now covered the basic data types of Go. The next step is to show how they can be combined into larger groupings like arrays and structs, and then into data structures for solving real programming problems; that is the topic of <a href="#chapter-4" >Chapter 4</a>.</p>
</div>
<h2 id="chapter-4" >Composite Types</h2>
<div class="hBody-2" >
<p>In <a href="#chapter-3" >Chapter 3</a> we discussed the basic types that serve as building blocks for data structures in a Go program; they are the atoms of our universe. In this chapter, we’ll take a look at <em>composite</em> types, the molecules created by combining the basic types in various ways. We’ll talk about four such types—arrays, slices, maps, and structs—and at the end of the chapter, we’ll show how structured data using these types can be encoded as and parsed from JSON data and used to generate HTML from templates.</p>
<p>Arrays and structs are <em>aggregate</em> types; their values are concatenations of other values in memory. Arrays are homogeneous—their elements all have the same type—whereas structs are heterogeneous. Both arrays and structs are fixed size. In contrast, slices and maps are dynamic data structures that grow as values are added.</p>
</div>
<h3 id="section-4.1" >Arrays</h3>
<div class="hBody-3" >
<p>An array is a fixed-length sequence of zero or more elements of a particular type. Because of their fixed length, arrays are rarely used directly in Go. Slices, which can grow and shrink, are much more versatile, but to understand slices we must understand arrays first.</p>
<p>Individual array elements are accessed with the conventional subscript notation, where subscripts run from zero to one less than the array length. The built-in function <code>len</code> returns the number of elements in the array.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>             <span class="c1">// array of 3 integers
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        <span class="c1">// print the first element
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// print the last element, a[2]
</span><span class="c1"></span>
<span class="c1">// Print the indices and elements.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Print the elements only.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>By default, the elements of a new array variable are initially set to the zero value for the element type, which is 0 for numbers. We can use an <em>array literal</em> to initialize an array with a list of values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">q</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// &#34;0&#34;
</span><span class="c1"></span></code></pre>
<p>In an array literal, if an ellipsis <q><code>...</code></q> appears in place of the length, the array length is determined by the number of initializers. The definition of <code>q</code> can be simplified to</p>
<pre class="code" ><code class="chroma" ><span class="nx">q</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &#34;[3]int&#34;
</span><span class="c1"></span></code></pre>
<p>The size of an array is part of its type, so <code>[3]int</code> and <code>[4]int</code> are different types. The size must be a constant expression, that is, an expression whose value can be computed as the program is being compiled.</p>
<pre class="code" ><code class="chroma" ><span class="nx">q</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">q</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// compile error: cannot assign [4]int to [3]int
</span><span class="c1"></span></code></pre>
<p>As we’ll see, the literal syntax is similar for arrays, slices, maps, and structs. The specific form above is a list of values in order, but it is also possible to specify a list of index and value pairs, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Currency</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">USD</span> <span class="nx">Currency</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">EUR</span>
  <span class="nx">GBP</span>
  <span class="nx">RMB</span>
<span class="p">)</span>
<span class="nx">symbol</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="nx">USD</span><span class="p">:</span> <span class="s">&#34;$&#34;</span><span class="p">,</span> <span class="nx">EUR</span><span class="p">:</span> <span class="s">&#34;€&#34;</span><span class="p">,</span> <span class="nx">GBP</span><span class="p">:</span> <span class="s">&#34;£&#34;</span><span class="p">,</span> <span class="nx">RMB</span><span class="p">:</span> <span class="s">&#34;¥&#34;</span><span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">RMB</span><span class="p">,</span> <span class="nx">symbol</span><span class="p">[</span><span class="nx">RMB</span><span class="p">])</span> <span class="c1">// &#34;3 ¥&#34;
</span><span class="c1"></span></code></pre>
<p>In this form, indices can appear in any order and some may be omitted; as before, unspecified values take on the zero value for the element type. For instance,</p>
<pre class="code" ><code class="chroma" ><span class="nx">r</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">99</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
</code></pre>
<p>defines an array <code>r</code> with 100 elements, all zero except for the last, which has value -1.</p>
<p>If an array’s element type is <em>comparable</em> then the array type is comparable too, so we may directly compare two arrays of that type using the <code>==</code> operator, which reports whether all corresponding elements are equal. The <code>!=</code> operator is its negation.</p>
<pre class="code" ><code class="chroma" ><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// &#34;true false false&#34;
</span><span class="c1"></span><span class="nx">d</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">// compile error: cannot compare [2]int == [3]int
</span><span class="c1"></span></code></pre>
<p>As a more plausible example, the function <code>Sum256</code> in the <code>crypto/sha256</code> package produces the SHA256 cryptographic hash or <em>digest</em> of a message stored in an arbitrary byte slice. The digest has 256 bits, so its type is <code>[32]byte</code>. If two digests are the same, it is extremely likely that the two messages are the same; if the digests differ, the two messages are different. This program prints and compares the SHA256 digests of <code>&#34;x&#34;</code> and <code>&#34;X&#34;</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/sha256/main.go" >gopl.io/ch4/sha256</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;crypto/sha256&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">c1</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nx">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">))</span>
  <span class="nx">c2</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nx">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;X&#34;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%x\n%x\n%t\n%T\n&#34;</span><span class="p">,</span> <span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">c1</span> <span class="o">==</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">c1</span><span class="p">)</span>
  <span class="c1">// Output:
</span><span class="c1"></span>  <span class="c1">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
</span><span class="c1"></span>  <span class="c1">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
</span><span class="c1"></span>  <span class="c1">// false
</span><span class="c1"></span>  <span class="c1">// [32]uint8
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>The two inputs differ by only a single bit, but approximately half the bits are different in the digests. Notice the <code>Printf</code> verbs: <code>%x</code> to print all the elements of an array or slice of bytes in hexadecimal, <code>%t</code> to show a boolean, and <code>%T</code> to display the type of a value.</p>
<p>When a function is called, a copy of each argument value is assigned to the corresponding parameter variable, so the function receives a copy, not the original. Passing large arrays in this way can be inefficient, and any changes that the function makes to array elements affect only the copy, not the original. In this regard, Go treats arrays like any other type, but this behavior is different from languages that implicitly pass arrays <em>by reference</em>.</p>
<p>Of course, we can explicitly pass a pointer to an array so that any modifications the function makes to array elements will be visible to the caller. This function zeroes the contents of a <code>[32]byte</code> array:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ptr</span> <span class="p">{</span>
    <span class="nx">ptr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The array literal <code>[32]byte{}</code> yields an array of 32 bytes. Each element of the array has the zero value for <code>byte</code>, which is zero. We can use that fact to write a different version of <code>zero</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">ptr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>Using a pointer to an array is efficient and allows the called function to mutate the caller’s variable, but arrays are still inherently inflexible because of their fixed size. The <code>zero</code> function will not accept a pointer to a <code>[16]byte</code> variable, for example, nor is there any way to add or remove array elements. For these reasons, other than special cases like SHA256’s fixed-size hash, arrays are seldom used as function parameters or results; instead, we use slices.</p>
<p><b>Exercise 4.1</b>: Write a function that counts the number of bits that are different in two SHA256 hashes. (See <code>PopCount</code> from <a href="#section-2.6.2" >Section 2.6.2</a>.)</p>
<p><b>Exercise 4.2</b>: Write a program that prints the SHA256 hash of its standard input by default but supports a command-line flag to print the SHA384 or SHA512 hash instead.</p>
</div>
<h3 id="section-4.2" >Slices</h3>
<div class="hBody-3" >
<p>Slices represent variable-length sequences whose elements all have the same type. A slice type is written <code>[]T</code>, where the elements have type <code>T</code>; it looks like an array type without a size.</p>
<p>Arrays and slices are intimately connected. A slice is a lightweight data structure that gives access to a subsequence (or perhaps all) of the elements of an array, which is known as the slice’s <em>underlying array</em>. A slice has three components: a pointer, a length, and a capacity. The pointer points to the first element of the array that is reachable through the slice, which is not necessarily the array’s first element. The length is the number of slice elements; it can’t exceed the capacity, which is usually the number of elements between the start of the slice and the end of the underlying array. The built-in functions <code>len</code> and <code>cap</code> return those values.</p>
<p>Multiple slices can share the same underlying array and may refer to overlapping parts of that array. Figure 4.1 shows an array of strings for the months of the year, and two overlapping slices of it. The array is declared as</p>
<pre class="code" ><code class="chroma" ><span class="nx">months</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#34;January&#34;</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="s">&#34;December&#34;</span><span class="p">}</span>
</code></pre>
<p>so January is <code>months[1]</code> and December is <code>months[12]</code>. Ordinarily, the array element at index 0 would contain the first value, but because months are always numbered from 1, we can leave it out of the declaration and it will be initialized to an empty string.</p>
<div class="figure" >
<h1 class="figure">Figure 4.1. Two overlapping slices of an array of months.</h1>
<figure>
<img src="img/Figure-4.1.jpg" />
</figure>
</div>
<p>The <em>slice operator</em> <code>s[i:j]</code>, where <code>0</code> ≤ <code>i</code> ≤ <code>j</code> ≤ <code>cap(s)</code>, creates a new slice that refers to elements <code>i</code> through <code>j-1</code> of the sequence <code>s</code>, which may be an array variable, a pointer to an array, or another slice. The resulting slice has <code>j-i</code> elements. If <code>i</code> is omitted, it’s 0, and if <code>j</code> is omitted, it’s <code>len(s)</code>. Thus the slice <code>months[1:13]</code> refers to the whole range of valid months, as does the slice <code>months[1:]</code>; the slice <code>months[:]</code> refers to the whole array. Let’s define overlapping slices for the second quarter and the northern summer:</p>
<pre class="code" ><code class="chroma" ><span class="nx">Q2</span> <span class="o">:=</span> <span class="nx">months</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nx">summer</span> <span class="o">:=</span> <span class="nx">months</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Q2</span><span class="p">)</span>     <span class="c1">// [&#34;April&#34; &#34;May&#34; &#34;June&#34;]
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">summer</span><span class="p">)</span> <span class="c1">// [&#34;June&#34; &#34;July&#34; &#34;August&#34;]
</span><span class="c1"></span></code></pre>
<p>June is included in each and is the sole output of this (inefficient) test for common elements:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">summer</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">q</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">Q2</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">q</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s appears in both\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Slicing beyond <code>cap(s)</code> causes a panic, but slicing beyond <code>len(s)</code> extends the slice, so the result may be longer than the original:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">summer</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>    <span class="c1">// panic: out of range
</span><span class="c1"></span>
<span class="nx">endlessSummer</span> <span class="o">:=</span> <span class="nx">summer</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">// extend a slice (within capacity)
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">endlessSummer</span><span class="p">)</span>  <span class="c1">// &#34;[June July August September October]&#34;
</span><span class="c1"></span></code></pre>
<p>As an aside, note the similarity of the substring operation on strings to the slice operator on <code>[]byte</code> slices. Both are written <code>x[m:n]</code>, and both return a subsequence of the original bytes, sharing the underlying representation so that both operations take constant time. The expression <code>x[m:n]</code> yields a string if <code>x</code> is a string, or a <code>[]byte</code> if <code>x</code> is a <code>[]byte</code>.</p>
<p>Since a slice contains a pointer to an element of an array, passing a slice to a function permits the function to modify the underlying array elements. In other words, copying a slice creates an <em>alias</em> (<a href="#section-2.3.2" >§2.3.2</a>) for the underlying array. The function <code>reverse</code> reverses the elements of an <code>[]int</code> slice in place, and it may be applied to slices of any length.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/rev/main.go" >gopl.io/ch4/rev</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// reverse reverses a slice of ints in place.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Here we reverse the whole array a:</p>
<pre class="code" ><code class="chroma" ><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">a</span><span class="p">[:])</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// &#34;[5 4 3 2 1 0]&#34;
</span><span class="c1"></span></code></pre>
<p>A simple way to <em>rotate</em> a slice left by <span class="math" >n</span> elements is to apply the <code>reverse</code> function three times, first to the leading <span class="math" >n</span> elements, then to the remaining elements, and finally to the whole slice. (To rotate to the right, make the third call first.)</p>
<pre class="code" ><code class="chroma" ><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="c1">// Rotate s left by two positions.
</span><span class="c1"></span><span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &#34;[2 3 4 5 0 1]&#34;
</span><span class="c1"></span></code></pre>
<p>Notice how the expression that initializes the slice <code>s</code> differs from that for the array <code>a</code>. A <em>slice literal</em> looks like an array literal, a sequence of values separated by commas and surrounded by braces, but the size is not given. This implicitly creates an array variable of the right size and yields a slice that points to it. As with array literals, slice literals may specify the values in order, or give their indices explicitly, or use a mix of the two styles.</p>
<p>Unlike arrays, slices are not comparable, so we cannot use <code>==</code> to test whether two slices contain the same elements. The standard library provides the highly optimized <code>bytes.Equal</code> function for comparing two slices of bytes (<code>[]byte</code>), but for other types of slice, we must do the comparison ourselves:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>Given how natural this <q>deep</q> equality test is, and that it is no more costly at run time than the <code>==</code> operator for arrays of strings, it may be puzzling that slice comparisons do not also work this way. There are two reasons why deep equivalence is problematic. First, unlike array elements, the elements of a slice are indirect, making it possible for a slice to contain itself.  Although there are ways to deal with such cases, none is simple, efficient, and most importantly, obvious.</p>
<p>Second, because slice elements are indirect, a fixed slice value may contain different elements at different times as the contents of the underlying array are modified. Because a hash table such as Go’s map type makes only shallow copies of its keys, it requires that equality for each key remain the same throughout the lifetime of the hash table. Deep equivalence would thus make slices unsuitable for use as map keys. For reference types like pointers and channels, the <code>==</code> operator tests <em>reference identity</em>, that is, whether the two entities refer to the same thing. An analogous <q>shallow</q> equality test for slices could be useful, and it would solve the problem with maps, but the inconsistent treatment of slices and arrays by the <code>==</code> operator would be confusing. The safest choice is to disallow slice comparisons altogether.</p>
<p>The only legal slice comparison is against <code>nil</code>, as in</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">summer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>The zero value of a slice type is <code>nil</code>. A nil slice has no underlying array. The nil slice has length and capacity zero, but there are also non-nil slices of length and capacity zero, such as <code>[]int{}</code> or <code>make([]int, 3)[3:]</code>. As with any type that can have nil values, the nil value of a particular slice type can be written using a conversion expression such as <code>[]int(nil)</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>    <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="kc">nil</span>        <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// len(s) == 0, s == nil
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>    <span class="c1">// len(s) == 0, s != nil
</span><span class="c1"></span></code></pre>
<p>So, if you need to test whether a slice is empty, use <code>len(s) == 0</code>, not <code>s == nil</code>. Other than comparing equal to <code>nil</code>, a nil slice behaves like any other zero-length slice; <code>reverse(nil)</code> is perfectly safe, for example. Unless clearly documented to the contrary, Go functions should treat all zero-length slices the same way, whether nil or non-nil.</p>
<p>The built-in function <code>make</code> creates a slice of a specified element type, length, and capacity. The capacity argument may be omitted, in which case the capacity equals the length.</p>
<pre class="code" ><code class="chroma" ><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
<span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span> <span class="c1">// same as make([]T, cap)[:len]
</span><span class="c1"></span></code></pre>
<p>Under the hood, <code>make</code> creates an unnamed array variable and returns a slice of it; the array is accessible only through the returned slice. In the first form, the slice is a view of the entire array. In the second, the slice is a view of only the array’s first <code>len</code> elements, but its capacity includes the entire array. The additional elements are set aside for future growth.</p>
</div>
<h4 id="section-4.2.1" >The <code>append</code> Function</h4>
<div class="hBody-4" >
<p>The built-in <code>append</code> function appends items to slices:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">runes</span> <span class="p">[]</span><span class="kt">rune</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&#34;Hello, 世界&#34;</span> <span class="p">{</span>
  <span class="nx">runes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">runes</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">runes</span><span class="p">)</span> <span class="c1">// &#34;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; &#39; &#39; &#39;B&#39; &#39;F&#39;]&#34;
</span><span class="c1"></span></code></pre>
<p>The loop uses <code>append</code> to build the slice of nine runes encoded by the string literal, although this specific problem is more conveniently solved by using the built-in conversion <code>[]rune(&#34;Hello, 世界&#34;)</code>.</p>
<p>The <code>append</code> function is crucial to understanding how slices work, so let’s take a look at what is going on. Here’s a version called <code>appendInt</code> that is specialized for <code>[]int</code> slices:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/append/main.go" >gopl.io/ch4/append</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="nx">zlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="nx">zlen</span> <span class="o">&lt;=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// There is room to grow.  Extend the slice.
</span><span class="c1"></span>    <span class="nx">z</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[:</span><span class="nx">zlen</span><span class="p">]</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// There is insufficient space.  Allocate a new array.
</span><span class="c1"></span>    <span class="c1">// Grow by doubling, for amortized linear complexity.
</span><span class="c1"></span>    <span class="nx">zcap</span> <span class="o">:=</span> <span class="nx">zlen</span>
    <span class="k">if</span> <span class="nx">zcap</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zcap</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">z</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">zlen</span><span class="p">,</span> <span class="nx">zcap</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// a built-in function; see text
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">y</span>
  <span class="k">return</span> <span class="nx">z</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Each call to <code>appendInt</code> must check whether the slice has sufficient capacity to hold the new elements in the existing array. If so, it extends the slice by defining a larger slice (still within the original array), copies the element <code>y</code> into the new space, and returns the slice. The input <code>x</code> and the result <code>z</code> share the same underlying array.</p>
<p>If there is insufficient space for growth, <code>appendInt</code> must allocate a new array big enough to hold the result, copy the values from <code>x</code> into it, then append the new element <code>y</code>. The result <code>z</code> now refers to a different underlying array than the array that <code>x</code> refers to.</p>
<p>It would be straightforward to copy the elements with explicit loops, but it’s easier to use the built-in function <code>copy</code>, which copies elements from one slice to another of the same type. Its first argument is the destination and its second is the source, resembling the order of operands in an assignment like <code>dst = src</code>. The slices may refer to the same underlying array ; they may even overlap. Although we don’t use it here, <code>copy</code> returns the number of elements actually copied, which is the smaller of the two slice lengths, so there is no danger of running off the end or overwriting something out of range.</p>
<p>For efficiency, the new array is usually somewhat larger than the minimum needed to hold <code>x</code> and <code>y</code>. Expanding the array by doubling its size at each expansion avoids an excessive number of allocations and ensures that appending a single element takes constant time on average.  This program demonstrates the effect:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="p">=</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d cap=%d\t%v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">y</span><span class="p">),</span> <span class="nx">y</span><span class="p">)</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">y</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Each change in capacity indicates an allocation and a copy:</p>
<div class="pre-block" >
<pre class="pre" >0  cap=1     [0]
1  cap=2     [0 1]
2  cap=4     [0 1 2]
3  cap=4     [0 1 2 3]
4  cap=8     [0 1 2 3 4]
5  cap=8     [0 1 2 3 4 5]
6  cap=8     [0 1 2 3 4 5 6]
7  cap=8     [0 1 2 3 4 5 6 7]
8  cap=16    [0 1 2 3 4 5 6 7 8]
9  cap=16    [0 1 2 3 4 5 6 7 8 9]
</pre>
</div>
<p>Let’s take a closer look at the <code>i=3</code> iteration. The slice <code>x</code> contains the three elements <code>[0 1 2]</code> but has capacity 4, so there is a single element of slack at the end, and <code>appendInt</code> of the element 3 may proceed without reallocating. The resulting slice <code>y</code> has length and capacity 4, and has the same underlying array as the original slice <code>x</code>, as Figure 4.2 shows.</p>
<div class="figure" >
<h1 class="figure">Figure 4.2. Appending with room to grow.</h1>
<figure>
<img src="img/Figure-4.2.jpg" />
</figure>
</div>
<p>On the next iteration, <code>i=4</code>, there is no slack at all, so <code>appendInt</code> allocates a new array of size 8, copies the four elements <code>[0 1 2 3]</code> of <code>x</code>, and appends 4, the value of <code>i</code>. The resulting slice <code>y</code> has a length of 5 but a capacity of 8; the slack of 3 will save the next three iterations from the need to reallocate. The slices <code>y</code> and <code>x</code> are views of different arrays. This operation is depicted in Figure 4.3.</p>
<div class="figure" >
<h1 class="figure">Figure 4.3. Appending without room to grow.</h1>
<figure>
<img src="img/Figure-4.3.jpg" />
</figure>
</div>
<p>The built-in <code>append</code> function may use a more sophisticated growth strategy than <code>appendInt</code>’s simplistic one. Usually we don’t know whether a given call to <code>append</code> will cause a reallocation, so we can’t assume that the original slice refers to the same array as the resulting slice, nor that it refers to a different one. Similarly, we must not assume that operations on elements of the old slice will (or will not) be reflected in the new slice. As a result, it’s usual to assign the result of a call to <code>append</code> to the same slice variable whose value we passed to <code>append</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">runes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">runes</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</code></pre>
<p>Updating the slice variable is required not just when calling <code>append</code>, but for any function that may change the length or capacity of a slice or make it refer to a different underlying array. To use slices correctly, it’s important to bear in mind that although the elements of the underlying array are indirect, the slice’s pointer, length, and capacity are not. To update them requires an assignment like the one above. In this respect, slices are not <q>pure</q> reference types but resemble an aggregate type such as this struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">IntSlice</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ptr</span>      <span class="o">*</span><span class="kt">int</span>
  <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>Our <code>appendInt</code> function adds a single element to a slice, but the built-in <code>append</code> lets us add more than one new element, or even a whole slice of them.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="o">...</span><span class="p">)</span> <span class="c1">// append the slice x
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>      <span class="c1">// &#34;[1 2 3 4 5 6 1 2 3 4 5 6]&#34;
</span><span class="c1"></span></code></pre>
<p>With the small modification shown below, we can match the behavior of the built-in <code>append</code>.  The ellipsis <q><code>...</code></q> in the declaration of <code>appendInt</code> makes the function <em>variadic</em>: it accepts any number of final arguments. The corresponding ellipsis in the call above to <code>append</code> shows how to supply a list of arguments from a slice. We’ll explain this mechanism in detail in <a href="#section-5.7" >Section 5.7</a>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="nx">zlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
  <span class="c1">// ...expand z to at least zlen...
</span><span class="c1"></span>  <span class="nb">copy</span><span class="p">(</span><span class="nx">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">):],</span> <span class="nx">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">z</span>
<span class="p">}</span>
</code></pre>
<p>The logic to expand <code>z</code>’s underlying array remains unchanged and is not shown.</p>
</div>
<h4 id="section-4.2.2" >In-Place Slice Techniques</h4>
<div class="hBody-4" >
<p>Let’s see more examples of functions that, like <code>rotate</code> and <code>reverse</code>, modify the elements of a slice in place. Given a list of strings, the <code>nonempty</code> function returns the non-empty ones:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/nonempty/main.go" >gopl.io/ch4/nonempty</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Nonempty is an example of an in-place slice algorithm.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">// nonempty returns a slice holding only the non-empty strings.
</span><span class="c1">// The underlying array is modified during the call.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">nonempty</span><span class="p">(</span><span class="nx">strings</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="nx">strings</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
      <span class="nx">i</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">strings</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The subtle part is that the input slice and the output slice share the same underlying array.  This avoids the need to allocate another array, though of course the contents of <code>data</code> are partly overwritten, as evidenced by the second print statement:</p>
<pre class="code" ><code class="chroma" ><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;one&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;three&#34;</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">nonempty</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="c1">// `[&#34;one&#34; &#34;three&#34;]`
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>           <span class="c1">// `[&#34;one&#34; &#34;three&#34; &#34;three&#34;]`
</span><span class="c1"></span></code></pre>
<p>Thus we would usually write: <code>data = nonempty(data)</code>.</p>
<p>The <code>nonempty</code> function can also be written using <code>append</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">nonempty2</span><span class="p">(</span><span class="nx">strings</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// zero-length slice of original
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="nx">out</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</code></pre>
<p>Whichever variant we use, reusing an array in this way requires that at most one output value is produced for each input value, which is true of many algorithms that filter out elements of a sequence or combine adjacent ones. Such intricate slice usage is the exception, not the rule, but it can be clear, efficient, and useful on occasion.</p>
<p>A slice can be used to implement a stack. Given an initially empty slice <code>stack</code>, we can push a new value onto the end of the slice with <code>append</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// push v
</span><span class="c1"></span></code></pre>
<p>The top of the stack is the last element:</p>
<pre class="code" ><code class="chroma" ><span class="nx">top</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// top of stack
</span><span class="c1"></span></code></pre>
<p>and shrinking the stack by popping that element is</p>
<pre class="code" ><code class="chroma" ><span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// pop
</span><span class="c1"></span></code></pre>
<p>To remove an element from the middle of a slice, preserving the order of the remaining elements, use <code>copy</code> to slide the higher-numbered elements down by one to fill the gap:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">return</span> <span class="nx">slice</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &#34;[5 6 8 9]&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>And if we don’t need to preserve the order, we can just move the last element into the gap:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="nx">slice</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &#34;[5 6 9 8]
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p><b>Exercise 4.3</b>: Rewrite <code>reverse</code> to use an array pointer instead of a slice.</p>
<p><b>Exercise 4.4</b>: Write a version of <code>rotate</code> that operates in a single pass.</p>
<p><b>Exercise 4.5</b>: Write an in-place function to eliminate adjacent duplicates in a <code>[]string</code> slice.</p>
<p><b>Exercise 4.6</b>: Write an in-place function that squashes each run of adjacent Unicode spaces (see <code>unicode.IsSpace</code>) in a UTF-8-encoded <code>[]byte</code> slice into a single ASCII space.</p>
<p><b>Exercise 4.7</b>: Modify <code>reverse</code> to reverse the characters of a <code>[]byte</code> slice that represents a UTF-8-encoded string, in place. Can you do it without allocating new memory?</p>
</div>
<h3 id="section-4.3" >Maps</h3>
<div class="hBody-3" >
<p>The hash table is one of the most ingenious and versatile of all data structures. It is an unordered collection of key/value pairs in which all the keys are distinct, and the value associated with a given key can be retrieved, updated, or removed using a constant number of key comparisons on the average, no matter how large the hash table.</p>
<p>In Go, a <em>map</em> is a reference to a hash table, and a map type is written <code>map[K]V</code>, where <code>K</code> and <code>V</code> are the types of its keys and values. All of the keys in a given map are of the same type, and all of the values are of the same type, but the keys need not be of the same type as the values. The key type <code>K</code> must be comparable using <code>==</code>, so that the map can test whether a given key is equal to one already within it. Though floating-point numbers are comparable, it’s a bad idea to compare floats for equality and, as we mentioned in <a href="#chapter-3" >Chapter 3</a>, especially bad if NaN is a possible value. There are no restrictions on the value type <code>V</code>.</p>
<p>The built-in function <code>make</code> can be used to create a map:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// mapping from strings to ints
</span><span class="c1"></span></code></pre>
<p>We can also use a <em>map literal</em> to create a new map populated with some initial key/value pairs:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
  <span class="s">&#34;alice&#34;</span><span class="p">:</span>   <span class="mi">31</span><span class="p">,</span>
  <span class="s">&#34;charlie&#34;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
<p>This is equivalent to</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">31</span>
<span class="nx">ages</span><span class="p">[</span><span class="s">&#34;charlie&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">34</span>
</code></pre>
<p>so an alternative expression for a new empty map is <code>map[string]int{}</code>.</p>
<p>Map elements are accessed through the usual subscript notation:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">32</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;alice&#34;</span><span class="p">])</span> <span class="c1">// &#34;32&#34;
</span><span class="c1"></span></code></pre>
<p>and removed with the built-in function <code>delete</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nb">delete</span><span class="p">(</span><span class="nx">ages</span><span class="p">,</span> <span class="s">&#34;alice&#34;</span><span class="p">)</span> <span class="c1">// remove element ages[&#34;alice&#34;]
</span><span class="c1"></span></code></pre>
<p>All of these operations are safe even if the element isn’t in the map; a map lookup using a key that isn’t present returns the zero value for its type, so, for instance, the following works even when <code>&#34;bob&#34;</code> is not yet a key in the map because the value of <code>ages[&#34;bob&#34;]</code> will be <code>0</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// happy birthday!
</span><span class="c1"></span></code></pre>
<p>The shorthand assignment forms <code>x += y</code> and <code>x++</code> also work for map elements, so we can rewrite the statement above as</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre>
<p>or even more concisely as</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span><span class="o">++</span>
</code></pre>
<p>But a map element is not a variable, and we cannot take its address:</p>
<pre class="code" ><code class="chroma" ><span class="nx">_</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span> <span class="c1">// compile error: cannot take address of map element
</span><span class="c1"></span></code></pre>
<p>One reason that we can’t take the address of a map element is that growing a map might cause rehashing of existing elements into new storage locations, thus potentially invalidating the address.</p>
<p>To enumerate all the key/value pairs in the map, we use a <code>range</code>-based <code>for</code> loop similar to those we saw for slices. Successive iterations of the loop cause the <code>name</code> and <code>age</code> variables to be set to the next key/value pair:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ages</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\t%d\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The order of map iteration is unspecified, and different implementations might use a different hash function, leading to a different ordering. In practice, the order is random, varying from one execution to the next. This is intentional; making the sequence vary helps force programs to be robust across implementations. To enumerate the key/value pairs in order, we must sort the keys explicitly, for instance, using the <code>Strings</code> function from the <code>sort</code> package if the keys are strings. This is a common pattern:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;sort&#34;</span>

<span class="kd">var</span> <span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span>
<span class="k">for</span> <span class="nx">name</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ages</span> <span class="p">{</span>
  <span class="nx">names</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">names</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">names</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">names</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\t%d\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">ages</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
<p>Since we know the final size of <code>names</code> from the outset, it is more efficient to allocate an array of the required size up front. The statement below creates a slice that is initially empty but has sufficient capacity to hold all the keys of the <code>ages</code> map:</p>
<pre class="code" ><code class="chroma" ><span class="nx">names</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ages</span><span class="p">))</span>
</code></pre>
<p>In the first <code>range</code> loop above, we require only the keys of the <code>ages</code> map, so we omit the second loop variable. In the second loop, we require only the elements of the <code>names</code> slice, so we use the blank identifier <code>_</code> to ignore the first variable, the index.</p>
<p>The zero value for a map type is <code>nil</code>, that is, a reference to no hash table at all.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">ages</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">ages</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>    <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span></code></pre>
<p>Most operations on maps, including lookup, <code>delete</code>, <code>len</code>, and <code>range</code> loops, are safe to perform on a nil map reference, since it behaves like an empty map. But storing to a nil map causes a panic:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ages</span><span class="p">[</span><span class="s">&#34;carol&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">21</span> <span class="c1">// panic: assignment to entry in nil map
</span><span class="c1"></span></code></pre>
<p>You must allocate the map before you can store into it.</p>
<p>Accessing a map element by subscripting always yields a value. If the key is present in the map, you get the corresponding value; if not, you get the zero value for the element type, as we saw with <code>ages[&#34;bob&#34;]</code>. For many purposes that’s fine, but sometimes you need to know whether the element was really there or not. For example, if the element type is numeric, you might have to distinguish between a nonexistent element and an element that happens to have the value zero, using a test like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">age</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">]</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="cm">/* &#34;bob&#34; is not a key in this map; age == 0. */</span> <span class="p">}</span>
</code></pre>
<p>You’ll often see these two statements combined, like this:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&#34;bob&#34;</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>Subscripting a map in this context yields two values; the second is a boolean that reports whether the element was present. The boolean variable is often called <code>ok</code>, especially if it is immediately used in an <code>if</code> condition.</p>
<p>As with slices, maps cannot be compared to each other; the only legal comparison is with <code>nil</code>. To test whether two maps contain the same keys and the same associated values, we must write a loop:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">xv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">yv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">y</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">yv</span> <span class="o">!=</span> <span class="nx">xv</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>Observe how we use <code>!ok</code> to distinguish the <q>missing</q> and <q>present but zero</q> cases. Had we naïvely written <code>xv != y[k]</code>, the call below would incorrectly report its arguments as equal:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// True if equal is written incorrectly.
</span><span class="c1"></span><span class="nx">equal</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;B&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">})</span>
</code></pre>
<p>Go does not provide a <code>set</code> type, but since the keys of a map are distinct, a map can serve this purpose. To illustrate, the program <code class="command" >dedup</code> reads a sequence of lines and prints only the first occurrence of each distinct line. (It’s a variant of the <code class="command" >dup</code> program that we showed in <a href="#section-1.3" >Section 1.3</a>.)  The <code class="command" >dedup</code> program uses a map whose keys represent the set of lines that have already appeared to ensure that subsequent occurrences are not printed.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/dedup/main.go" >gopl.io/ch4/dedup</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// a set of strings
</span><span class="c1"></span>  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">line</span> <span class="o">:=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="p">{</span>
      <span class="nx">seen</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;dedup: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Go programmers often describe a map used in this fashion as a <q>set of strings</q> without further ado, but beware, not all <code>map[string]bool</code> values are simple sets; some may contain both <code>true</code> and <code>false</code> values.</p>
<p>Sometimes we need a map or set whose keys are slices, but because a map’s keys must be comparable, this cannot be expressed directly. However, it can be done in two steps. First we define a helper function <code>k</code> that maps each key to a string, with the property that <code>k(x) == k(y)</code> if and only if we consider <code>x</code> and <code>y</code> equivalent. Then we create a map whose keys are strings, applying the helper function to each key before we access the map.</p>
<p>The example below uses a map to record the number of times <code>Add</code> has been called with a given list of strings. It uses <code>fmt.Sprintf</code> to convert a slice of strings into a single string that is a suitable map key, quoting each slice element with <code>%q</code> to record string boundaries faithfully:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">k</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>  <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%q&#34;</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>       <span class="p">{</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">(</span><span class="nx">list</span><span class="p">)]</span><span class="o">++</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">(</span><span class="nx">list</span><span class="p">)]</span> <span class="p">}</span>
</code></pre>
<p>The same approach can be used for any non-comparable key type, not just slices. It’s even useful for comparable key types when you want a definition of equality other than <code>==</code>, such as case-insensitive comparisons for strings. And the type of <code>k(x)</code> needn’t be a string; any comparable type with the desired equivalence property will do, such as integers, arrays, or structs.</p>
<p>Here’s another example of maps in action, a program that counts the occurrences of each distinct Unicode code point in its input. Since there are a large number of possible characters, only a small fraction of which would appear in any particular document, a map is a natural way to keep track of just the ones that have been seen and their corresponding counts.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/charcount/main.go" >gopl.io/ch4/charcount</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Charcount computes counts of Unicode characters.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;bufio&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;unicode&#34;</span>
  <span class="s">&#34;unicode/utf8&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>    <span class="c1">// counts of Unicode characters
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">utflen</span> <span class="p">[</span><span class="nx">utf8</span><span class="p">.</span><span class="nx">UTFMax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">int</span> <span class="c1">// count of lengths of UTF-8 encodings
</span><span class="c1"></span>  <span class="nx">invalid</span> <span class="o">:=</span> <span class="mi">0</span>                    <span class="c1">// count of invalid UTF-8 characters
</span><span class="c1"></span>
  <span class="nx">in</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">.</span><span class="nx">ReadRune</span><span class="p">()</span>    <span class="c1">// returns rune, nbytes, error
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;charcount: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ReplacementChar</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">invalid</span><span class="o">++</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span><span class="o">++</span>
    <span class="nx">utflen</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;rune\tcount\n&#34;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%q\t%d\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&#34;\nlen\tcount\n&#34;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">utflen</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\t%d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">invalid</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\n%d invalid UTF-8 characters\n&#34;</span><span class="p">,</span> <span class="nx">invalid</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>ReadRune</code> method performs UTF-8 decoding and returns three values: the decoded rune, the length in bytes of its UTF-8 encoding, and an error value. The only error we expect is end-of-file. If the input was not a legal UTF-8 encoding of a rune, the returned rune is <code>unicode.ReplacementChar</code> and the length is 1.</p>
<p>The <code class="command" >charcount</code> program also prints a count of the lengths of the UTF-8 encodings of the runes that appeared in the input. A map is not the best data structure for that; since encoding lengths range only from 1 to <code>utf8.UTFMax</code> (which has the value 4), an array is more compact.</p>
<p>As an experiment, we ran <code class="command" >charcount</code> on this book itself at one point. Although it’s mostly in English, of course, it does have a fair number of non-ASCII characters. Here are the top ten:</p>
<div class="pre-block" >
<pre class="pre" >° 27 世 15 界 14 é 13 ˣ 10 ≤ 5 × 5 𢉩 4 � 4 □ 3
</pre>
</div>
<p>and here is the distribution of the lengths of all the UTF-8 encodings:</p>
<div class="pre-block" >
<pre class="pre" >len  count
1    765391
2    60
3    70
4    0
</pre>
</div>
<p>The value type of a map can itself be a composite type, such as a map or slice. In the following code, the key type of <code>graph</code> is <code>string</code> and the value type is <code>map[string]bool</code>, representing a set of strings. Conceptually, <code>graph</code> maps a string to a set of related strings, its successors in a directed graph.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/graph/main.go" >gopl.io/ch4/graph</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">graph</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">addEdge</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">edges</span> <span class="o">:=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">]</span>
  <span class="k">if</span> <span class="nx">edges</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">edges</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">]</span> <span class="p">=</span> <span class="nx">edges</span>
  <span class="p">}</span>
  <span class="nx">edges</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">hasEdge</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">][</span><span class="nx">to</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>addEdge</code> function shows the idiomatic way to populate a map lazily, that is, to initialize each value as its key appears for the first time. The <code>hasEdge</code> function shows how the zero value of a missing map entry is often put to work: even if neither <code>from</code> nor <code>to</code> is present, <code>graph[from][to]</code> will always give a meaningful result.</p>
<p><b>Exercise 4.8</b>: Modify <code class="command" >charcount</code> to count letters, digits, and so on in their Unicode categories, using functions like <code>unicode.IsLetter</code>.</p>
<p><b>Exercise 4.9</b>: Write a program <code class="command" >wordfreq</code> to report the frequency of each word in an input text file. Call <code>input.Split(bufio.ScanWords)</code> before the first call to <code>Scan</code> to break the input into words instead of lines.</p>
</div>
<h3 id="section-4.4" >Structs</h3>
<div class="hBody-3" >
<p>A <em>struct</em> is an aggregate data type that groups together zero or more named values of arbitrary types as a single entity. Each value is called a <em>field</em>. The classic example of a struct from data processing is the employee record, whose fields are a unique ID, the employee’s name, address, date of birth, position, salary, manager, and the like. All of these fields are collected into a single entity that can be copied as a unit, passed to functions and returned by them, stored in arrays, and so on.</p>
<p>These two statements declare a struct type called <code>Employee</code> and a variable called <code>dilbert</code> that is an instance of an <code>Employee</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>        <span class="kt">int</span>
  <span class="nx">Name</span>      <span class="kt">string</span>
  <span class="nx">Address</span>   <span class="kt">string</span>
  <span class="nx">DoB</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">Position</span>  <span class="kt">string</span>
  <span class="nx">Salary</span>    <span class="kt">int</span>
  <span class="nx">ManagerID</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dilbert</span> <span class="nx">Employee</span>
</code></pre>
<p>The individual fields of <code>dilbert</code> are accessed using dot notation like <code>dilbert.Name</code> and <code>dilbert.DoB</code>. Because dilbert is a variable, its fields are variables too, so we may assign to a field:</p>
<pre class="code" ><code class="chroma" ><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">-=</span> <span class="mi">5000</span> <span class="c1">// demoted, for writing too few lines of code
</span><span class="c1"></span></code></pre>
<p>or take its address and access it through a pointer:</p>
<pre class="code" ><code class="chroma" ><span class="nx">position</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Position</span>
<span class="o">*</span><span class="nx">position</span> <span class="p">=</span> <span class="s">&#34;Senior &#34;</span> <span class="o">+</span> <span class="o">*</span><span class="nx">position</span> <span class="c1">// promoted, for outsourcing to Elbonia
</span><span class="c1"></span></code></pre>
<p>The dot notation also works with a pointer to a struct:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">employeeOfTheMonth</span> <span class="o">*</span><span class="nx">Employee</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">dilbert</span>
<span class="nx">employeeOfTheMonth</span><span class="p">.</span><span class="nx">Position</span> <span class="o">+=</span> <span class="s">&#34; (proactive team player)&#34;</span>
</code></pre>
<p>The last statement is equivalent to</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="o">*</span><span class="nx">employeeOfTheMonth</span><span class="p">).</span><span class="nx">Position</span> <span class="o">+=</span> <span class="s">&#34; (proactive team player)&#34;</span>
</code></pre>
<p>Given an employee’s unique ID, the function <code>EmployeeByID</code> returns a pointer to an <code>Employee</code> struct. We can use the dot notation to access its fields:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">EmployeeByID</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Employee</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">EmployeeByID</span><span class="p">(</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">ManagerID</span><span class="p">).</span><span class="nx">Position</span><span class="p">)</span> <span class="c1">// &#34;Pointy-haired boss&#34;
</span><span class="c1"></span>
<span class="nx">id</span> <span class="o">:=</span> <span class="nx">dilbert</span><span class="p">.</span><span class="nx">ID</span>
<span class="nx">EmployeeByID</span><span class="p">(</span><span class="nx">id</span><span class="p">).</span><span class="nx">Salary</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// fired for... no real reason
</span><span class="c1"></span></code></pre>
<p>The last statement updates the <code>Employee</code> struct that is pointed to by the result of the call to <code>EmployeeByID</code>. If the result type of <code>EmployeeByID</code> were changed to <code>Employee</code> instead of <code>*Employee</code>, the assignment statement would not compile since its left-hand side would not identify a variable.</p>
<p>Fields are usually written one per line, with the field’s name preceding its type, but consecutive fields of the same type may be combined, as with <code>Name</code> and <code>Address</code> here:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>            <span class="kt">int</span>
  <span class="nx">Name</span><span class="p">,</span> <span class="nx">Address</span> <span class="kt">string</span>
  <span class="nx">DoB</span>           <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">Position</span>      <span class="kt">string</span>
  <span class="nx">Salary</span>        <span class="kt">int</span>
  <span class="nx">ManagerID</span>     <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>Field order is significant to type identity. Had we also combined the declaration of the <code>Position</code> field (also a string), or interchanged <code>Name</code> and <code>Address</code>, we would be defining a different struct type. Typically we only combine the declarations of related fields.</p>
<p>The name of a struct field is exported if it begins with a capital letter; this is Go’s main access control mechanism. A struct type may contain a mixture of exported and unexported fields.</p>
<p>Struct types tend to be verbose because they often involve a line for each field. Although we could write out the whole type each time it is needed, the repetition would get tiresome. Instead, struct types usually appear within the declaration of a named type like <code>Employee</code>.</p>
<p>A named struct type <code>S</code> can’t declare a field of the same type <code>S</code>: an aggregate value cannot contain itself. (An analogous restriction applies to arrays.) But <code>S</code> may declare a field of the pointer type <code>*S</code>, which lets us create recursive data structures like linked lists and trees. This is illustrated in the code below, which uses a binary tree to implement an insertion sort:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/treesort/sort.go" >gopl.io/ch4/treesort</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">tree</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span>       <span class="kt">int</span>
  <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">tree</span>
<span class="p">}</span>

<span class="c1">// Sort sorts values in place.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Sort</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">root</span> <span class="o">*</span><span class="nx">tree</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
    <span class="nx">root</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// appendValues appends the elements of t to values in order
</span><span class="c1">// and returns the resulting slice.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">tree</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">values</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">tree</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Equivalent to return &amp;tree{value: value}.
</span><span class="c1"></span>    <span class="nx">t</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span>
    <span class="k">return</span> <span class="nx">t</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">value</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">value</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">left</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">right</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The zero value for a struct is composed of the zero values of each of its fields. It is usually desirable that the zero value be a natural or sensible default. For example, in <code>bytes.Buffer</code>, the initial value of the struct is a ready-to-use empty buffer, and the zero value of <code>sync.Mutex</code>, which we’ll see in <a href="#chapter-9" >Chapter 9</a>, is a ready-to-use unlocked mutex. Sometimes this sensible initial behavior happens for free, but sometimes the type designer has to work at it.</p>
<p>The struct type with no fields is called the <em>empty struct</em>, written <code>struct{}</code>. It has size zero and carries no information but may be useful nonetheless. Some Go programmers use it instead of <code>bool</code> as the value type of a map that represents a set, to emphasize that only the keys are significant, but the space saving is marginal and the syntax more cumbersome, so we generally avoid it.</p>
<pre class="code" ><code class="chroma" ><span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span> <span class="c1">// set of strings
</span><span class="c1">// ...
</span><span class="c1"></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">seen</span><span class="p">[</span><span class="nx">s</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">seen</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
  <span class="c1">// ...first time seeing s...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<h4 id="section-4.4.1" >Struct Literals</h4>
<div class="hBody-4" >
<p>A value of a struct type can be written using a <em>struct literal</em> that specifies values for its fields.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</code></pre>
<p>There are two forms of struct literal. The first form, shown above, requires that a value be specified for <em>every</em> field, in the right order. It burdens the writer (and reader) with remembering exactly what the fields are, and it makes the code fragile should the set of fields later grow or be reordered. Accordingly, this form tends to be used only within the package that defines the struct type, or with smaller struct types for which there is an obvious field ordering convention, like <code>image.Point{x, y}</code> or <code>color.RGBA{red, green, blue, alpha}</code>.</p>
<p>More often, the second form is used, in which a struct value is initialized by listing some or all of the field names and their corresponding values, as in this statement from the Lissajous program of <a href="#section-1.4" >Section 1.4</a>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
</code></pre>
<p>If a field is omitted in this kind of literal, it is set to the zero value for its type. Because names are provided, the order of fields doesn’t matter.</p>
<p>The two forms cannot be mixed in the same literal. Nor can you use the (order-based) first form of literal to sneak around the rule that unexported identifiers may not be referred to from another package.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">p</span>
<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span> <span class="p">}</span> <span class="c1">// a and b are not exported
</span><span class="c1"></span></code></pre>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">q</span>
<span class="kn">import</span> <span class="s">&#34;p&#34;</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// compile error: can&#39;t reference a, b
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>       <span class="c1">// compile error: can&#39;t reference a, b
</span><span class="c1"></span></code></pre>
<p>Although the last line above doesn’t mention the unexported field identifiers, it’s really using them implicitly, so it’s not allowed.</p>
<p>Struct values can be passed as arguments to functions and returned from them. For instance, this function scales a <code>Point</code> by a specified factor:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Scale</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">factor</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">factor</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">factor</span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Scale</span><span class="p">(</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">// &#34;{5 10}&#34;
</span><span class="c1"></span></code></pre>
<p>For efficiency, larger struct types are usually passed to or returned from functions indirectly using a pointer,</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Bonus</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Employee</span><span class="p">,</span> <span class="nx">percent</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">*</span> <span class="nx">percent</span> <span class="o">/</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre>
<p>and this is required if the function must modify its argument, since in a call-by-value language like Go, the called function receives only a copy of an argument, not a reference to the original argument.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">AwardAnnualRaise</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Employee</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">*</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre>
<p>Because structs are so commonly dealt with through pointers, it’s possible to use this shorthand notation to create and initialize a struct variable and obtain its address:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</code></pre>
<p>It is exactly equivalent to</p>
<pre class="code" ><code class="chroma" ><span class="nx">pp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Point</span><span class="p">)</span>
<span class="o">*</span><span class="nx">pp</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</code></pre>
<p>but <code>&amp;Point{1, 2}</code> can be used directly within an expression, such as a function call.</p>
</div>
<h4 id="section-4.4.2" >Comparing Structs</h4>
<div class="hBody-4" >
<p>If all the fields of a struct are comparable, the struct itself is comparable, so two expressions of that type may be compared using <code>==</code> or <code>!=</code>. The <code>==</code> operation compares the corresponding fields of the two structs in order, so the two printed expressions below are equivalent:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span>                   <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>Comparable struct types, like other comparable types, may be used as the key type of a map.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">address</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">hostname</span> <span class="kt">string</span>
  <span class="nx">port</span>     <span class="kt">int</span>
<span class="p">}</span>

<span class="nx">hits</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">address</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">hits</span><span class="p">[</span><span class="nx">address</span><span class="p">{</span><span class="s">&#34;golang.org&#34;</span><span class="p">,</span> <span class="mi">443</span><span class="p">}]</span><span class="o">++</span>
</code></pre>
</div>
<h4 id="section-4.4.3" >Struct Embedding and Anonymous Fields</h4>
<div class="hBody-4" >
<p>In this section, we’ll see how Go’s unusual <em>struct embedding</em> mechanism lets us use one named struct type as an <em>anonymous field</em> of another struct type, providing a convenient syntactic shortcut so that a simple dot expression like <code>x.f</code> can stand for a chain of fields like <code>x.d.e.f</code>.</p>
<p>Consider a 2-D drawing program that provides a library of shapes, such as rectangles, ellipses, stars, and wheels. Here are two of the types it might define:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Circle</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">,</span> <span class="nx">Radius</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Wheel</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">,</span> <span class="nx">Radius</span><span class="p">,</span> <span class="nx">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>A <code>Circle</code> has fields for the <code>X</code> and <code>Y</code> coordinates of its center, and a <code>Radius</code>. A <code>Wheel</code> has all the features of a <code>Circle</code>, plus <code>Spokes</code>, the number of inscribed radial spokes. Let’s create a wheel:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Wheel</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Radius</span> <span class="p">=</span> <span class="mi">5</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Spokes</span> <span class="p">=</span> <span class="mi">20</span>
</code></pre>
<p>As the set of shapes grows, we’re bound to notice similarities and repetition among them, so it may be convenient to factor out their common parts:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Circle</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Center</span> <span class="nx">Point</span>
  <span class="nx">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Wheel</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Circle</span> <span class="nx">Circle</span>
  <span class="nx">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>The application may be clearer for it, but this change makes accessing the fields of a <code>Wheel</code> more verbose:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Wheel</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circle</span><span class="p">.</span><span class="nx">Center</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circle</span><span class="p">.</span><span class="nx">Center</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circle</span><span class="p">.</span><span class="nx">Radius</span> <span class="p">=</span> <span class="mi">5</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Spokes</span> <span class="p">=</span> <span class="mi">20</span>
</code></pre>
<p>Go lets us declare a field with a type but no name; such fields are called <em>anonymous fields</em>. The type of the field must be a named type or a pointer to a named type. Below, <code>Circle</code> and <code>Wheel</code> have one anonymous field each. We say that a <code>Point</code> is <em>embedded</em> within <code>Circle</code>, and a <code>Circle</code> is embedded within <code>Wheel</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Circle</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Point</span>
  <span class="nx">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Wheel</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Circle</span>
  <span class="nx">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<p>Thanks to embedding, we can refer to the names at the leaves of the implicit tree without giving the intervening names:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Wheel</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>        <span class="c1">// equivalent to w.Circle.Point.X = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>        <span class="c1">// equivalent to w.Circle.Point.Y = 8
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Radius</span> <span class="p">=</span> <span class="mi">5</span>   <span class="c1">// equivalent to w.Circle.Radius = 5
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Spokes</span> <span class="p">=</span> <span class="mi">20</span>
</code></pre>
<p>The explicit forms shown in the comments above are still valid, however, showing that <q>anonymous field</q> is something of a misnomer. The fields <code>Circle</code> and <code>Point</code> do have names—that of the named type—but those names are optional in dot expressions. We may omit any or all of the anonymous fields when selecting their subfields.</p>
<p>Unfortunately, there’s no corresponding shorthand for the struct literal syntax, so neither of these will compile:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">}</span>                       <span class="c1">// compile error: unknown fields
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// compile error: unknown fields
</span><span class="c1"></span></code></pre>
<p>The struct literal must follow the shape of the type declaration, so we must use one of the two forms below, which are equivalent to each other:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/embed/main.go" >gopl.io/ch4/embed</a></h1>
<pre class="code" ><code class="chroma" >  <span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="nx">Circle</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span> <span class="mi">5</span><span class="p">},</span> <span class="mi">20</span><span class="p">}</span>

  <span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span>
    <span class="nx">Circle</span><span class="p">:</span> <span class="nx">Circle</span><span class="p">{</span>
      <span class="nx">Point</span><span class="p">:</span>  <span class="nx">Point</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
      <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="c1">// NOTE: trailing comma necessary here (and at Radius)
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
  <span class="c1">// Output:
</span><span class="c1"></span>  <span class="c1">// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}
</span><span class="c1"></span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">42</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
  <span class="c1">// Output:
</span><span class="c1"></span>  <span class="c1">// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}
</span><span class="c1"></span></code></pre>
</div>
<p>Notice how the <code>#</code> adverb causes <code>Printf</code>’s <code>%v</code> verb to display values in a form similar to Go syntax. For struct values, this form includes the name of each field.</p>
<p>Because <q>anonymous</q> fields do have implicit names, you can’t have two anonymous fields of the same type since their names would conflict. And because the name of the field is implicitly determined by its type, so too is the visibility of the field. In the examples above, the <code>Point</code> and <code>Circle</code> anonymous fields are exported. Had they been unexported (<code>point</code> and <code>circle</code>), we could still use the shorthand form</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// equivalent to w.circle.point.X = 8
</span><span class="c1"></span></code></pre>
<p>but the explicit long form shown in the comment would be forbidden outside the declaring package because <code>circle</code> and <code>point</code> would be inaccessible.</p>
<p>What we’ve seen so far of struct embedding is just a sprinkling of syntactic sugar on the dot notation used to select struct fields. Later, we’ll see that anonymous fields need not be struct types; any named type or pointer to a named type will do. But why would you want to embed a type that has no subfields?</p>
<p>The answer has to do with methods. The shorthand notation used for selecting the fields of an embedded type works for selecting its methods as well. In effect, the outer struct type gains not just the fields of the embedded type but its methods too. This mechanism is the main way that complex object behaviors are composed from simpler ones. <em>Composition</em> is central to object-oriented programming in Go, and we’ll explore it further in <a href="#section-6.3" >Section 6.3</a>.</p>
</div>
<h3 id="section-4.5" >JSON</h3>
<div class="hBody-3" >
<p>JavaScript Object Notation (JSON) is a standard notation for sending and receiving structured information. JSON is not the only such notation. XML (<a href="#section-7.14" >§7.14</a>), ASN.1, and Google’s Protocol Buffers serve similar purposes and each has its niche, but because of its simplicity, readability, and universal support, JSON is the most widely used.</p>
<p>Go has excellent support for encoding and decoding these formats, provided by the standard library packages <code>encoding/json</code>, <code>encoding/xml</code>, <code>encoding/asn1</code>, and so on, and these packages all have similar APIs. This section gives a brief overview of the most important parts of the <code>encoding/json</code> package.</p>
<p>JSON is an encoding of JavaScript values—strings, numbers, booleans, arrays, and objects—as Unicode text. It’s an efficient yet readable representation for the basic data types of <a href="#chapter-3" >Chapter 3</a> and the composite types of this chapter—arrays, slices, structs, and maps.</p>
<p>The basic JSON types are numbers (in decimal or scientific notation), booleans (<code>true</code> or <code>false</code>), and strings, which are sequences of Unicode code points enclosed in double quotes, with backslash escapes using a similar notation to Go, though JSON’s <code>\u</code><em>hhhh</em> numeric escapes denote UTF-16 codes, not runes.</p>
<p>These basic types may be combined recursively using JSON arrays and objects. A JSON array is an ordered sequence of values, written as a comma-separated list enclosed in square brackets; JSON arrays are used to encode Go arrays and slices. A JSON object is a mapping from strings to values, written as a sequence of <code>name:value</code> pairs separated by commas and surrounded by braces; JSON objects are used to encode Go maps (with string keys) and structs.  For example:</p>
<table border="1">
<tbody>
<tr><td><p><code>boolean</code></p>
</td><td><p><code>true</code></p>
</td></tr>
<tr><td><p><code>number</code></p>
</td><td><p><code>-273.15</code></p>
</td></tr>
<tr><td><p><code>string</code></p>
</td><td><p><code>&#34;She said \&#34;Hello,  世界\&#34;&#34;</code></p>
</td></tr>
<tr><td><p><code>array</code></p>
</td><td><p><code>[&#34;gold&#34;, &#34;silver&#34;, &#34;bronze&#34;]</code></p>
</td></tr>
<tr><td><p><code>object</code></p>
</td><td><p><code>{&#34;year&#34;: 1980, &#34;event&#34;: &#34;archery&#34;, &#34;medals&#34;: [&#34;gold&#34;, &#34;silver&#34;, &#34;bronze&#34;]}</code></p>
</td></tr>
</tbody>
</table>
<p>Consider an application that gathers movie reviews and offers recommendations. Its <code>Movie</code> data type and a typical list of values are declared below. (The string literals after the <code>Year</code> and <code>Color</code> field declarations are <em>field tags</em>; we’ll explain them in a moment.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/movie/main.go" >gopl.io/ch4/movie</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Movie</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span>  <span class="kt">string</span>
  <span class="nx">Year</span>   <span class="kt">int</span>  <span class="s">`json:&#34;released&#34;`</span>
  <span class="nx">Color</span>  <span class="kt">bool</span> <span class="s">`json:&#34;color,omitempty&#34;`</span>
  <span class="nx">Actors</span> <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">movies</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">Movie</span><span class="p">{</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;Casablanca&#34;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1942</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;Humphrey Bogart&#34;</span><span class="p">,</span> <span class="s">&#34;Ingrid Bergman&#34;</span><span class="p">}},</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;Cool Hand Luke&#34;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1967</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;Paul Newman&#34;</span><span class="p">}},</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;Bullitt&#34;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1968</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;Steve McQueen&#34;</span><span class="p">,</span> <span class="s">&#34;Jacqueline Bisset&#34;</span><span class="p">}},</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>Data structures like this are an excellent fit for JSON, and it’s easy to convert in both directions. Converting a Go data structure like <code>movies</code> to JSON is called <em>marshaling</em>. Marshaling is done by <code>json.Marshal</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">movies</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;JSON marshaling failed: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</code></pre>
<p><code>Marshal</code> produces a byte slice containing a very long string with no extraneous white space; we’ve folded the lines so it fits:</p>
<pre class="code" ><code class="chroma" ><span class="p">[{</span><span class="s">&#34;Title&#34;</span><span class="p">:</span><span class="s">&#34;Casablanca&#34;</span><span class="p">,</span><span class="s">&#34;released&#34;</span><span class="p">:</span><span class="mi">1942</span><span class="p">,</span><span class="s">&#34;Actors&#34;</span><span class="p">:[</span><span class="s">&#34;Humphrey Bogart&#34;</span><span class="p">,</span><span class="s">&#34;Ingrid Bergman&#34;</span><span class="p">]},{</span><span class="s">&#34;Title&#34;</span><span class="p">:</span><span class="s">&#34;Cool Hand Luke&#34;</span><span class="p">,</span><span class="s">&#34;released&#34;</span><span class="p">:</span><span class="mi">1967</span><span class="p">,</span><span class="s">&#34;color&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="s">&#34;Actors&#34;</span><span class="p">:[</span><span class="s">&#34;Paul Newman&#34;</span><span class="p">]},{</span><span class="s">&#34;Title&#34;</span><span class="p">:</span><span class="s">&#34;Bullitt&#34;</span><span class="p">,</span><span class="s">&#34;released&#34;</span><span class="p">:</span><span class="mi">1968</span><span class="p">,</span><span class="s">&#34;color&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="s">&#34;Actors&#34;</span><span class="p">:[</span><span class="s">&#34;Steve McQueen&#34;</span><span class="p">,</span><span class="s">&#34;Jacqueline Bisset&#34;</span><span class="p">]}]</span>
</code></pre>
<p>This compact representation contains all the information but it’s hard to read. For human consumption, a variant called <code>json.MarshalIndent</code> produces neatly indented output. Two additional arguments define a prefix for each line of output and a string for each level of indentation:</p>
<pre class="code" ><code class="chroma" ><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">movies</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;    &#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;JSON marshaling failed: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</code></pre>
<p>The code above prints</p>
<pre class="code" ><code class="chroma" ><span class="p">[</span>
    <span class="p">{</span>
        <span class="s">&#34;Title&#34;</span><span class="p">:</span> <span class="s">&#34;Casablanca&#34;</span><span class="p">,</span>
        <span class="s">&#34;released&#34;</span><span class="p">:</span> <span class="mi">1942</span><span class="p">,</span>
        <span class="s">&#34;Actors&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&#34;Humphrey Bogart&#34;</span><span class="p">,</span>
            <span class="s">&#34;Ingrid Bergman&#34;</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#34;Title&#34;</span><span class="p">:</span> <span class="s">&#34;Cool Hand Luke&#34;</span><span class="p">,</span>
        <span class="s">&#34;released&#34;</span><span class="p">:</span> <span class="mi">1967</span><span class="p">,</span>
        <span class="s">&#34;color&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="s">&#34;Actors&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&#34;Paul Newman&#34;</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#34;Title&#34;</span><span class="p">:</span> <span class="s">&#34;Bullitt&#34;</span><span class="p">,</span>
        <span class="s">&#34;released&#34;</span><span class="p">:</span> <span class="mi">1968</span><span class="p">,</span>
        <span class="s">&#34;color&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="s">&#34;Actors&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&#34;Steve McQueen&#34;</span><span class="p">,</span>
            <span class="s">&#34;Jacqueline Bisset&#34;</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre>
<p>Marshaling uses the Go struct field names as the field names for the JSON objects (through <em>reflection</em>, as we’ll see in <a href="#section-12.6" >Section 12.6</a>). Only exported fields are marshaled, which is why we chose capitalized names for all the Go field names.</p>
<p>You may have noticed that the name of the <code>Year</code> field changed to <code>released</code> in the output, and <code>Color</code> changed to <code>color</code>. That’s because of the <em>field tags</em>. A field tag is a string of metadata associated at compile time with the field of a struct:</p>
<pre class="code" ><code class="chroma" ><span class="nx">Year</span>  <span class="kt">int</span>  <span class="s">`json:&#34;released&#34;`</span>
<span class="nx">Color</span> <span class="kt">bool</span> <span class="s">`json:&#34;color,omitempty&#34;`</span>
</code></pre>
<p>A field tag may be any literal string, but it is conventionally interpreted as a space-separated list of <code>key:&#34;value&#34;</code> pairs; since they contain double quotation marks, field tags are usually written with raw string literals. The <code>json</code> key controls the behavior of the <code>encoding/json</code> package, and other <code>encoding/...</code> packages follow this convention. The first part of the <code>json</code> field tag specifies an alternative JSON name for the Go field. Field tags are often used to specify an idiomatic JSON name like <code>total_count</code> for a Go field named <code>TotalCount</code>. The tag for <code>Color</code> has an additional option, <code>omitempty</code>, which indicates that no JSON output should be produced if the field has the zero value for its type (<code>false</code>, here) or is otherwise empty.  Sure enough, the JSON output for <em>Casablanca</em>, a black-and-white movie, has no <code>color</code> field.</p>
<p>The inverse operation to marshaling, decoding JSON and populating a Go data structure, is called <em>unmarshaling</em>, and it is done by <code>json.Unmarshal</code>. The code below unmarshals the JSON movie data into a slice of structs whose only field is <code>Title</code>. By defining suitable Go data structures in this way, we can select which parts of the JSON input to decode and which to discard. When <code>Unmarshal</code> returns, it has filled in the slice with the <code>Title</code> information; other names in the JSON are ignored.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">titles</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span> <span class="nx">Title</span> <span class="kt">string</span> <span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">titles</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;JSON unmarshaling failed: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">titles</span><span class="p">)</span> <span class="c1">// &#34;[{Casablanca} {Cool Hand Luke} {Bullitt}]&#34;
</span><span class="c1"></span></code></pre>
<p>Many web services provide a JSON interface—make a request with HTTP and back comes the desired information in JSON format. To illustrate, let’s query the GitHub issue tracker using its web-service interface. First we’ll define the necessary types and constants:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/github/github.go" >gopl.io/ch4/github</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package github provides a Go API for the GitHub issue tracker.
</span><span class="c1">// See https://developer.github.com/v3/search/#search-issues.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">github</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="kd">const</span> <span class="nx">IssuesURL</span> <span class="p">=</span> <span class="s">&#34;https://api.github.com/search/issues&#34;</span>

<span class="kd">type</span> <span class="nx">IssuesSearchResult</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">TotalCount</span> <span class="kt">int</span> <span class="s">`json:&#34;total_count&#34;`</span>
  <span class="nx">Items</span>      <span class="p">[]</span><span class="o">*</span><span class="nx">Issue</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Issue</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span>    <span class="kt">int</span>
  <span class="nx">HTMLURL</span>   <span class="kt">string</span> <span class="s">`json:&#34;html_url&#34;`</span>
  <span class="nx">Title</span>     <span class="kt">string</span>
  <span class="nx">State</span>     <span class="kt">string</span>
  <span class="nx">User</span>      <span class="o">*</span><span class="nx">User</span>
  <span class="nx">CreatedAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&#34;created_at&#34;`</span>
  <span class="nx">Body</span>      <span class="kt">string</span>    <span class="c1">// in Markdown format
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Login</span>   <span class="kt">string</span>
  <span class="nx">HTMLURL</span> <span class="kt">string</span> <span class="s">`json:&#34;html_url&#34;`</span>
<span class="p">}</span>
</code></pre>
</div>
<p>As before, the names of all the struct fields must be capitalized even if their JSON names are not. However, the matching process that associates JSON names with Go struct names during unmarshaling is case-insensitive, so it’s only necessary to use a field tag when there’s an underscore in the JSON name but not in the Go name. Again, we are being selective about which fields to decode; the GitHub search response contains considerably more information than we show here.</p>
<p>The <code>SearchIssues</code> function makes an HTTP request and decodes the result as JSON. Since the query terms presented by a user could contain characters like <code>?</code> and <code>&amp;</code> that have special meaning in a URL, we use <code>url.QueryEscape</code> to ensure that they are taken literally.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/github/search.go" >gopl.io/ch4/github</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">github</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;encoding/json&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
  <span class="s">&#34;net/url&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="c1">// SearchIssues queries the GitHub issue tracker.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">terms</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">IssuesSearchResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">q</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">QueryEscape</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">terms</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">))</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">IssuesURL</span> <span class="o">+</span> <span class="s">&#34;?q=&#34;</span> <span class="o">+</span> <span class="nx">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// We must close resp.Body on all execution paths.
</span><span class="c1"></span>  <span class="c1">// (Chapter 5 presents &#39;defer&#39;, which makes this simpler.)
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;search query failed: %s&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">result</span> <span class="nx">IssuesSearchResult</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The earlier examples used <code>json.Unmarshal</code> to decode the entire contents of a byte slice as a single JSON entity. For variety, this example uses the <em>streaming</em> decoder, <code>json.Decoder</code>, which allows several JSON entities to be decoded in sequence from the same stream, although we don’t need that feature here. As you might expect, there is a corresponding streaming encoder called <code>json.Encoder</code>.</p>
<p>The call to <code>Decode</code> populates the variable <code>result</code>. There are various ways we can format its value nicely. The simplest, demonstrated by the <code>issues</code> command below, is as a text table with fixed-width columns, but in the next section we’ll see a more sophisticated approach based on templates.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/issues/main.go" >gopl.io/ch4/issues</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Issues prints a table of GitHub issues matching the search terms.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;gopl.io/ch4/github&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">github</span><span class="p">.</span><span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d issues:\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">TotalCount</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;#%-5d %9.9s %.55s\n&#34;</span><span class="p">,</span>
      <span class="nx">item</span><span class="p">.</span><span class="nx">Number</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">User</span><span class="p">.</span><span class="nx">Login</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Title</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The command-line arguments specify the search terms. The command below queries the Go project’s issue tracker for the list of open bugs related to JSON decoding:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch4/issues
</span><span class="in" ><span class="prompt" >&gt; </span>./issues repo:golang/go is:open json decoder
</span><span class="out" >13 issues:
#5680    eaigner encoding/json: set key converter on en/decoder
#6050  gopherbot encoding/json: provide tokenizer
#8658  gopherbot encoding/json: use bufio
#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal
#5901        rsc encoding/json: allow override type marshaling
#9812  klauspost encoding/json: string tag not symmetric
#7872  extempora encoding/json: Encoder internally buffers full output
#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin
#6716  gopherbot encoding/json: include field name in unmarshal error me
#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi
#6384    joeshaw encoding/json: encode precise floating point integers u
#6647    btracey x/tools/cmd/godoc: display type kind of each named type
#4237  gjemiller encoding/base64: URLEncoding padding is optional
</span></code></pre>
<p>The GitHub web-service interface at <a href="https://developer.github.com/v3/" >https://developer.github.com/v3/</a> has many more features than we have space for here.</p>
<p><b>Exercise 4.10</b>: Modify <code>issues</code> to report the results in age categories, say less than a month old, less than a year old, and more than a year old.</p>
<p><b>Exercise 4.11</b>: Build a tool that lets users create, read, update, and delete GitHub issues from the command line, invoking their preferred text editor when substantial text input is required.</p>
<p><b>Exercise 4.12</b>: The popular web comic <em>xkcd</em> has a JSON interface. For example, a request to <a href="https://xkcd.com/571/info.0.json" >https://xkcd.com/571/info.0.json</a> produces a detailed description of comic 571, one of many favorites. Download each URL (once!)  and build an offline index. Write a tool <code class="command" >xkcd</code> that, using this index, prints the URL and transcript of each comic that matches a search term provided on the command line.</p>
<p><b>Exercise 4.13</b>: The JSON-based web service of the Open Movie Database lets you search <a href="https://omdbapi.com/" >https://omdbapi.com/</a> for a movie by name and download its poster image. Write a tool <code class="command" >poster</code> that downloads the poster image for the movie named on the command line.</p>
</div>
<h3 id="section-4.6" >Text and HTML Templates</h3>
<div class="hBody-3" >
<p>The previous example does only the simplest possible formatting, for which <code>Printf</code> is entirely adequate. But sometimes formatting must be more elaborate, and it’s desirable to separate the format from the code more completely. This can be done with the <code>text/template</code> and <code>html/template</code> packages, which provide a mechanism for substituting the values of variables into a text or HTML template.</p>
<p>A template is a string or file containing one or more portions enclosed in double braces, <code>{{...}}</code>, called <em>actions</em>. Most of the string is printed literally, but the actions trigger other behaviors. Each action contains an expression in the template language, a simple but powerful notation for printing values, selecting struct fields, calling functions and methods, expressing control flow such as <code>if</code>-<code>else</code> statements and <code>range</code> loops, and instantiating other templates. A simple template string is shown below:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/issuesreport/main.go" >gopl.io/ch4/issuesreport</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">templ</span> <span class="p">=</span> <span class="s">`{{.TotalCount}} issues:
</span><span class="s">{{range .Items}}----------------------------------------
</span><span class="s">Number: {{.Number}}
</span><span class="s">User:   {{.User.Login}}
</span><span class="s">Title:  {{.Title | printf &#34;%.64s&#34;}}
</span><span class="s">Age:    {{.CreatedAt | daysAgo}} days
</span><span class="s">{{end}}`</span>
</code></pre>
</div>
<p>This template first prints the number of matching issues, then prints the number, user, title, and age in days of each one. Within an action, there is a notion of the current value, referred to as <q>dot</q> and written as <q>.</q>, a period. The dot initially refers to the template’s parameter, which will be a <code>github.IssuesSearchResult</code> in this example. The <code>{{.TotalCount}}</code> action expands to the value of the <code>TotalCount</code> field, printed in the usual way. The <code>{{range .Items}}</code> and <code>{{end}}</code> actions create a loop, so the text between them is expanded multiple times, with dot bound to successive elements of <code>Items</code>.</p>
<p>Within an action, the <code>|</code> notation makes the result of one operation the argument of another, analogous to a Unix shell pipeline. In the case of <code>Title</code>, the second operation is the <code>printf</code> function, which is a built-in synonym for <code>fmt.Sprintf</code> in all templates. For <code>Age</code>, the second operation is the following function, <code>daysAgo</code>, which converts the <code>CreatedAt</code> field into an elapsed time, using <code>time.Since</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">daysAgo</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nx">Hours</span><span class="p">()</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Notice that the type of <code>CreatedAt</code> is <code>time.Time</code>, not <code>string</code>. In the same way that a type may control its string formatting (<a href="#section-2.5" >§2.5</a>) by defining certain methods, a type may also define methods to control its JSON marshaling and unmarshaling behavior. The JSON-marshaled value of a <code>time.Time</code> is a string in a standard format.</p>
<p>Producing output with a template is a two-step process. First we must parse the template into a suitable internal representation, and then execute it on specific inputs. Parsing need be done only once. The code below creates and parses the template <code>templ</code> defined above. Note the chaining of method calls: <code>template.New</code> creates and returns a template; <code>Funcs</code> adds <code>daysAgo</code> to the set of functions accessible within this template, then returns that template; finally, <code>Parse</code> is called on the result.</p>
<pre class="code" ><code class="chroma" ><span class="nx">report</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;report&#34;</span><span class="p">).</span>
  <span class="nx">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span><span class="s">&#34;daysAgo&#34;</span><span class="p">:</span> <span class="nx">daysAgo</span><span class="p">}).</span>
  <span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Because templates are usually fixed at compile time, failure to parse a template indicates a fatal bug in the program. The <code>template.Must</code> helper function makes error handling more convenient: it accepts a template and an error, checks that the error is nil (and panics otherwise), and then returns the template. We’ll come back to this idea in <a href="#section-5.9" >Section 5.9</a>.</p>
<p>Once the template has been created, augmented with <code>daysAgo</code>, parsed, and checked, we can execute it using a <code>github.IssuesSearchResult</code> as the data source and <code>os.Stdout</code> as the destination:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">report</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;issuelist&#34;</span><span class="p">).</span>
  <span class="nx">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span><span class="s">&#34;daysAgo&#34;</span><span class="p">:</span> <span class="nx">daysAgo</span><span class="p">}).</span>
  <span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">))</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">github</span><span class="p">.</span><span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">report</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The program prints a plain text report like this:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch4/issuesreport
</span><span class="in" ><span class="prompt" >&gt; </span>./issuesreport repo:golang/go is:open json decoder
</span><span class="out" >13 issues:
---------------------------------------
Number: 5680
User:   eaigner
Title:  encoding/json: set key converter on en/decoder
Age:    750 days
---------------------------------------
Number: 6050
User:   gopherbot
Title:  encoding/json: provide tokenizer
Age:    695 days
---------------------------------------
...
</span></code></pre>
<p>Now let’s turn to the <code>html/template</code> package. It uses the same API and expression language as <code>text/template</code> but adds features for automatic and context-appropriate escaping of strings appearing within HTML, JavaScript, CSS, or URLs. These features can help avoid a perennial security problem of HTML generation, an <em>injection attack</em>, in which an adversary crafts a string value like the title of an issue to include malicious code that, when improperly escaped by a template, gives them control over the page.</p>
<p>The template below prints the list of issues as an HTML table. Note the different import:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/issueshtml/main.go" >gopl.io/ch4/issueshtml</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;html/template&#34;</span>

<span class="kd">var</span> <span class="nx">issueList</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;issuelist&#34;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="s">`
</span><span class="s">&lt;h1&gt;{{.TotalCount}} issues&lt;/h1&gt;
</span><span class="s">&lt;table&gt;
</span><span class="s">&lt;tr style=&#39;text-align: left&#39;&gt;
</span><span class="s">  &lt;th&gt;#&lt;/th&gt;
</span><span class="s">  &lt;th&gt;State&lt;/th&gt;
</span><span class="s">  &lt;th&gt;User&lt;/th&gt;
</span><span class="s">  &lt;th&gt;Title&lt;/th&gt;
</span><span class="s">&lt;/tr&gt;
</span><span class="s">{{range .Items}}
</span><span class="s">&lt;tr&gt;
</span><span class="s">  &lt;td&gt;&lt;a href=&#39;{{.HTMLURL}}&#39;&gt;{{.Number}}&lt;/a&gt;&lt;/td&gt;
</span><span class="s">  &lt;td&gt;{{.State}}&lt;/td&gt;
</span><span class="s">  &lt;td&gt;&lt;a href=&#39;{{.User.HTMLURL}}&#39;&gt;{{.User.Login}}&lt;/a&gt;&lt;/td&gt;
</span><span class="s">  &lt;td&gt;&lt;a href=&#39;{{.HTMLURL}}&#39;&gt;{{.Title}}&lt;/a&gt;&lt;/td&gt;
</span><span class="s">&lt;/tr&gt;
</span><span class="s">{{end}}
</span><span class="s">&lt;/table&gt;
</span><span class="s">`</span><span class="p">))</span>
</code></pre>
</div>
<p>The command below executes the new template on the results of a slightly different query:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch4/issueshtml
</span><span class="in" ><span class="prompt" >&gt; </span>./issueshtml repo:golang/go commenter:gopherbot json encoder &gt;issues.html
</span></code></pre>
<p>Figure 4.4 shows the appearance of the table in a web browser. The links connect to the appropriate web pages at GitHub.</p>
<div class="figure" >
<h1 class="figure">Figure 4.4. An HTML table of Go project issues relating to JSON encoding.</h1>
<figure>
<img src="img/Figure-4.4.jpg" />
</figure>
</div>
<p>None of the issues in Figure 4.4 pose a challenge for HTML, but we can see the effect more clearly with issues whose titles contain HTML metacharacters like <code>&amp;</code> and <code>&lt;</code>. We’ve selected two such issues for this example:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./issueshtml repo:golang/go <span class="m">3133</span> <span class="m">10535</span> &gt;issues2.html
</span></code></pre>
<p>Figure 4.5 shows the result of this query. Notice that the <code>html/template</code> package automatically HTML-escaped the titles so that they appear literally. Had we used the <code>text/template</code> package by mistake, the four-character string <code>&#34;&amp;lt;&#34;</code> would have been rendered as a less-than character <code>&#39;&lt;&#39;</code>, and the string <code>&#34;&lt;link&gt;&#34;</code> would have become a <code>link</code> element, changing the structure of the HTML document and perhaps compromising its security.</p>
<p>We can suppress this auto-escaping behavior for fields that contain trusted HTML data by using the named string type <code>template.HTML</code> instead of <code>string</code>. Similar named types exist for trusted JavaScript, CSS, and URLs. The program below demonstrates the principle by using two fields with the same value but different types: <code>A</code> is a string and <code>B</code> is a <code>template.HTML</code>.</p>
<div class="figure" >
<h1 class="figure">Figure 4.5. HTML metacharacters in issue titles are correctly displayed.</h1>
<figure>
<img src="img/Figure-4.5.jpg" />
</figure>
</div>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch4/autoescape/main.go" >gopl.io/ch4/autoescape</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">templ</span> <span class="p">=</span> <span class="s">`&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`</span>
  <span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;escape&#34;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">))</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">A</span> <span class="kt">string</span>        <span class="c1">// untrusted plain text
</span><span class="c1"></span>    <span class="nx">B</span> <span class="nx">template</span><span class="p">.</span><span class="nx">HTML</span> <span class="c1">// trusted HTML
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">A</span> <span class="p">=</span> <span class="s">&#34;&lt;b&gt;Hello!&lt;/b&gt;&#34;</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="s">&#34;&lt;b&gt;Hello!&lt;/b&gt;&#34;</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Figure 4.6 shows the template’s output as it appears in a browser. We can see that <code>A</code> was subject to escaping but <code>B</code> was not.</p>
<div class="figure" >
<h1 class="figure">Figure 4.6. String values are HTML-escaped but <code>template.HTML</code> values are not.</h1>
<figure>
<img src="img/Figure-4.6.jpg" />
</figure>
</div>
<p>We have space here to show only the most basic features of the template system. As always, for more information, consult the package documentation:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc text/template
</span><span class="in" ><span class="prompt" >&gt; </span>go doc html/template
</span></code></pre>
<p><b>Exercise 4.14</b>: Create a web server that queries GitHub once and then allows navigation of the list of bug reports, milestones, and users.</p>
</div>
<h2 id="chapter-5" >Functions</h2>
<div class="hBody-2" >
<p>A function lets us wrap up a sequence of statements as a unit that can be called from elsewhere in a program, perhaps multiple times. Functions make it possible to break a big job into smaller pieces that might well be written by different people separated by both time and space.  A function hides its implementation details from its users. For all of these reasons, functions are a critical part of any programming language.</p>
<p>We’ve seen many functions already. Now let’s take time for a more thorough discussion. The running example of this chapter is a web crawler, that is, the component of a web search engine responsible for fetching web pages, discovering the links within them, fetching the pages identified by those links, and so on. A web crawler gives us ample opportunity to explore recursion, anonymous functions, error handling, and aspects of functions that are unique to Go.</p>
</div>
<h3 id="section-5.1" >Function Declarations</h3>
<div class="hBody-3" >
<p>A function declaration has a name, a list of parameters, an optional list of results, and a body:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">name</span><span class="p">(</span><span class="nx">parameter</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span><span class="o">-</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">body</span>
<span class="p">}</span>
</code></pre>
<p>The parameter list specifies the names and types of the function’s <em>parameters</em>, which are the local variables whose values or <em>arguments</em> are supplied by the caller. The result list specifies the types of the values that the function returns. If the function returns one unnamed result or no results at all, parentheses are optional and usually omitted. Leaving off the result list entirely declares a function that does not return any value and is called only for its effects. In the <code>hypot</code> function,</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &#34;5&#34;
</span><span class="c1"></span></code></pre>
<p><code>x</code> and <code>y</code> are parameters in the declaration, <code>3</code> and <code>4</code> are arguments of the call, and the function returns a <code>float64</code> value.</p>
<p>Like parameters, results may be named. In that case, each name declares a local variable initialized to the zero value for its type.</p>
<p>A function that has a result list must end with a <code>return</code> statement unless execution clearly cannot reach the end of the function, perhaps because the function ends with a call to <code>panic</code> or an infinite <code>for</code> loop with no <code>break</code>.</p>
<p>As we saw with <code>hypot</code>, a sequence of parameters or results of the same type can be factored so that the type itself is written only once. These two declarations are equivalent:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span>                <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>Here are four ways to declare a function with two parameters and one result, all of type <code>int</code>.  The blank identifier can be used to emphasize that a parameter is unused.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>   <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">z</span> <span class="kt">int</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">z</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">first</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>      <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">add</span><span class="p">)</span>   <span class="c1">// &#34;func(int, int) int&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">sub</span><span class="p">)</span>   <span class="c1">// &#34;func(int, int) int&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">first</span><span class="p">)</span> <span class="c1">// &#34;func(int, int) int&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">zero</span><span class="p">)</span>  <span class="c1">// &#34;func(int, int) int&#34;
</span><span class="c1"></span></code></pre>
<p>The type of a function is sometimes called its <em>signature</em>. Two functions have the same type or signature if they have the same sequence of parameter types and the same sequence of result types. The names of parameters and results don’t affect the type, nor does whether or not they were declared using the factored form.</p>
<p>Every function call must provide an argument for each parameter, in the order in which the parameters were declared. Go has no concept of default parameter values, nor any way to specify arguments by name, so the names of parameters and results don’t matter to the caller except as documentation.</p>
<p>Parameters are local variables within the body of the function, with their initial values set to the arguments supplied by the caller. Function parameters and named results are variables in the same lexical block as the function’s outermost local variables.</p>
<p>Arguments are passed <em>by value</em>, so the function receives a copy of each argument; modifications to the copy do not affect the caller. However, if the argument contains some kind of reference, like a pointer, slice, map, function, or channel, then the caller may be affected by any modifications the function makes to variables <em>indirectly</em> referred to by the argument.</p>
<p>You may occasionally encounter a function declaration without a body, indicating that the function is implemented in a language other than Go. Such a declaration defines the function signature.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">math</span>

<span class="kd">func</span> <span class="nx">Sin</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="c1">// implemented in assembly language
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-5.2" >Recursion</h3>
<div class="hBody-3" >
<p>Functions may be <em>recursive</em>, that is, they may call themselves, either directly or indirectly.  Recursion is a powerful technique for many problems, and of course it’s essential for processing recursive data structures. In <a href="#section-4.4" >Section 4.4</a>, we used recursion over a tree to implement a simple insertion sort. In this section, we’ll use it again for processing HTML documents.</p>
<p>The example program below uses a non-standard package, <code>golang.org/x/net/html</code>, which provides an HTML parser. The <code>golang.org/x/...</code> repositories hold packages designed and maintained by the Go team for applications such as networking, internationalized text processing, mobile platforms, image manipulation, cryptography, and developer tools. These packages are not in the standard library because they’re still under development or because they’re rarely needed by the majority of Go programmers.</p>
<p>The parts of the <code>golang.org/x/net/html</code> API that we’ll need are shown below. The function <code>html.Parse</code> reads a sequence of bytes, parses them, and returns the root of the HTML document tree, which is an <code>html.Node</code>. HTML has several kinds of nodes—text, comments, and so on—but here we are concerned only with element nodes of the form <code>&lt;name key=&#39;value&#39;&gt;</code>.</p>
<div class="figure" >
<h1 class="figure"><code>golang.org/x/net/html</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">html</span>
<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Type</span>                    <span class="nx">NodeType</span>
  <span class="nx">Data</span>                    <span class="kt">string</span>
  <span class="nx">Attr</span>                    <span class="p">[]</span><span class="nx">Attribute</span>
  <span class="nx">FirstChild</span><span class="p">,</span> <span class="nx">NextSibling</span> <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NodeType</span> <span class="kt">int32</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">ErrorNode</span> <span class="nx">NodeType</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">TextNode</span>
  <span class="nx">DocumentNode</span>
  <span class="nx">ElementNode</span>
  <span class="nx">CommentNode</span>
  <span class="nx">DoctypeNode</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Attribute</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Key</span><span class="p">,</span> <span class="nx">Val</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre>
</div>
<p>The <code>main</code> function parses the standard input as HTML, extracts the links using a recursive <code>visit</code> function, and prints each discovered link:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/findlinks1/main.go" >gopl.io/ch5/findlinks1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Findlinks1 prints the links in an HTML document read from standard input.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;golang.org/x/net/html&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;findlinks1: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>visit</code> function traverses an HTML node tree, extracts the link from the <code>href</code> attribute of each <em>anchor</em> element <code>&lt;a href=&#39;...&#39;&gt;</code>, appends the links to a slice of strings, and returns the resulting slice:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// visit appends to links each link found in n and returns the result.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&#34;a&#34;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="s">&#34;href&#34;</span> <span class="p">{</span>
        <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">links</span> <span class="p">=</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">links</span>
<span class="p">}</span>
</code></pre>
<p>To descend the tree for a node <code>n</code>, <code>visit</code> recursively calls itself for each of <code>n</code>’s children, which are held in the <code>FirstChild</code> linked list.</p>
<p>Let’s run <code class="command" >findlinks</code> on the Go home page, piping the output of <code class="command" >fetch</code> (<a href="#section-1.5" >§1.5</a>) to the input of <code class="command" >findlinks</code>. We’ve edited the output slightly for brevity.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/findlinks1
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch https://golang.org <span class="p">|</span> ./findlinks1
</span><span class="out" >#
/doc/
/pkg/
/help/
/blog/
http://play.golang.org/
//tour.golang.org/
https://golang.org/dl/
//blog.golang.org/
/LICENSE
/doc/tos.html
http://www.google.com/intl/en/policies/privacy/
</span></code></pre>
<p>Notice the variety of forms of links that appear in the page. Later we’ll see how to resolve them relative to the base URL, <code>https://golang.org</code>, to make absolute URLs.</p>
<p>The next program uses recursion over the HTML node tree to print the structure of the tree in outline. As it encounters each element, it pushes the element’s tag onto a stack, then prints the stack.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/outline/main.go" >gopl.io/ch5/outline</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;outline: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">outline</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span> <span class="c1">// push tag
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Note one subtlety: although <code>outline</code> <q>pushes</q> an element on <code>stack</code>, there is no corresponding pop. When <code>outline</code> calls itself recursively, the callee receives a copy of <code>stack</code>. Although the callee may append elements to this slice, modifying its underlying array and perhaps even allocating a new array, it doesn’t modify the initial elements that are visible to the caller, so when the function returns, the caller’s <code>stack</code> is as it was before the call.</p>
<p>Here’s the outline of <code>https://golang.org</code>, again edited for brevity:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/outline
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch https://golang.org <span class="p">|</span> ./outline
</span><span class="out" >[html]
[html head]
[html head meta]
[html head title]
[html head link]
[html body]
[html body div]
[html body div]
[html body div div]
[html body div div form]
[html body div div form div]
[html body div div form div a]
</span></code></pre>
<p>As you can see by experimenting with <code>outline</code>, most HTML documents can be processed with only a few levels of recursion, but it’s not hard to construct pathological web pages that require extremely deep recursion.</p>
<p>Many programming language implementations use a fixed-size function call stack; sizes from 64KB to 2MB are typical. Fixed-size stacks impose a limit on the depth of recursion, so one must be careful to avoid a <em>stack overflow</em> when traversing large data structures recursively; fixed-size stacks may even pose a security risk. In contrast, typical Go implementations use variable-size stacks that start small and grow as needed up to a limit on the order of a gigabyte.  This lets us use recursion safely and without worrying about overflow.</p>
<p><b>Exercise 5.1</b>: Change the <code class="command" >findlinks</code> program to traverse the <code>n.FirstChild</code> linked list using recursive calls to <code>visit</code> instead of a loop.</p>
<p><b>Exercise 5.2</b>: Write a function to populate a mapping from element names—<code>p</code>, <code>div</code>, <code>span</code>, and so on—to the number of elements with that name in an HTML document tree.</p>
<p><b>Exercise 5.3</b>: Write a function to print the contents of all text nodes in an HTML document tree. Do not descend into <code>&lt;script&gt;</code> or <code>&lt;style&gt;</code> elements, since their contents are not visible in a web browser.</p>
<p><b>Exercise 5.4</b>: Extend the <code>visit</code> function so that it extracts other kinds of links from the document, such as images, scripts, and style sheets.</p>
</div>
<h3 id="section-5.3" >Multiple Return Values</h3>
<div class="hBody-3" >
<p>A function can return more than one result. We’ve seen many examples of functions from standard packages that return two values, the desired computational result and an error value or boolean that indicates whether the computation worked. The next example shows how to write one of our own.</p>
<p>The program below is a variation of <code class="command" >findlinks</code> that makes the HTTP request itself so that we no longer need to run <code class="command" >fetch</code>. Because the HTTP and parsing operations can fail, <code class="command" >findLinks</code> declares two results: the list of discovered links and an error. Incidentally, the HTML parser can usually recover from bad input and construct a document containing error nodes, so <code>Parse</code> rarely fails; when it does, it’s typically due to underlying I/O errors.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/findlinks2/main.go" >gopl.io/ch5/findlinks2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;findlinks2: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">links</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// findLinks performs an HTTP GET request for url, parses the
</span><span class="c1">// response as HTML, and extracts and returns the links.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;getting %s: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing %s as HTML: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>There are four return statements in <code>findLinks</code>, each of which returns a pair of values. The first three <code>return</code>s cause the function to pass the underlying errors from the <code>http</code> and <code>html</code> packages on to the caller. In the first case, the error is returned unchanged; in the second and third, it is augmented with additional context information by <code>fmt.Errorf</code> (<a href="#section-7.8" >§7.8</a>). If <code>findLinks</code> is successful, the final return statement returns the slice of links, with no error.</p>
<p>We must ensure that <code>resp.Body</code> is closed so that network resources are properly released even in case of error. Go’s garbage collector recycles unused memory, but do not assume it will release unused operating system resources like open files and network connections. They should be closed explicitly.</p>
<p>The result of calling a multi-valued function is a tuple of values. The caller of such a function must explicitly assign the values to variables if any of them are to be used:</p>
<pre class="code" ><code class="chroma" ><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</code></pre>
<p>To ignore one of the values, assign it to the blank identifier:</p>
<pre class="code" ><code class="chroma" ><span class="nx">links</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="c1">// errors ignored
</span><span class="c1"></span></code></pre>
<p>The result of a multi-valued call may itself be returned from a (multi-valued) calling function, as in this function that behaves like <code>findLinks</code> but logs its argument:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">findLinksLog</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;findLinks %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>A multi-valued call may appear as the sole argument when calling a function of multiple parameters. Although rarely used in production code, this feature is sometimes convenient during debugging since it lets us print all the results of a call using a single statement. The two print statements below have the same effect.</p>
<pre class="code" ><code class="chroma" ><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">))</span>

<span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</code></pre>
<p>Well-chosen names can document the significance of a function’s results. Names are particularly valuable when a function returns multiple results of the same type, like</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Size</span><span class="p">(</span><span class="nx">rect</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">)</span> <span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">file</span> <span class="kt">string</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">HourMinSec</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">hour</span><span class="p">,</span> <span class="nx">minute</span><span class="p">,</span> <span class="nx">second</span> <span class="kt">int</span><span class="p">)</span>
</code></pre>
<p>but it’s not always necessary to name multiple results solely for documentation. For instance, convention dictates that a final <code>bool</code> result indicates success; an <code>error</code> result often needs no explanation.</p>
<p>In a function with named results, the operands of a return statement may be omitted. This is called a <em>bare return</em>.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// CountWordsAndImages does an HTTP GET request for the HTML
</span><span class="c1">// document url and returns the number of words and images in it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">CountWordsAndImages</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing HTML: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="p">=</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>A bare return is a shorthand way to return each of the named result variables in order, so in the function above, each return statement is equivalent to</p>
<pre class="code" ><code class="chroma" ><span class="k">return</span> <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span><span class="p">,</span> <span class="nx">err</span>
</code></pre>
<p>In functions like this one, with many return statements and several results, bare returns can reduce code duplication, but they rarely make code easier to understand. For instance, it’s not obvious at first glance that the two early returns are equivalent to <code>return 0, 0, err</code> (because the result variables <code>words</code> and <code>images</code> are initialized to their zero values) and that the final <code>return</code> is equivalent to <code>return words, images, nil</code>. For this reason, bare returns are best used sparingly.</p>
<p><b>Exercise 5.5</b>: Implement <code>countWordsAndImages</code>. (See Exercise 4.9 for word-splitting.)</p>
<p><b>Exercise 5.6</b>: Modify the <code>corner</code> function in <code>gopl.io/ch3/surface</code> (<a href="#section-3.2" >§3.2</a>) to use named results and a bare return statement.</p>
</div>
<h3 id="section-5.4" >Errors</h3>
<div class="hBody-3" >
<p>Some functions always succeed at their task. For example, <code>strings.Contains</code> and <code>strconv.FormatBool</code> have well-defined results for all possible argument values and cannot fail—barring catastrophic and unpredictable scenarios like running out of memory, where the symptom is far from the cause and from which there’s little hope of recovery.</p>
<p>Other functions always succeed so long as their preconditions are met. For example, the <code>time.Date</code> function always constructs a <code>time.Time</code> from its components—year, month, and so on—unless the last argument (the time zone) is <code>nil</code>, in which case it panics. This panic is a sure sign of a bug in the calling code and should never happen in a well-written program.</p>
<p>For many other functions, even in a well-written program, success is not assured because it depends on factors beyond the programmer’s control. Any function that does I/O, for example, must confront the possibility of error, and only a naïve programmer believes a simple read or write cannot fail. Indeed, it’s when the most reliable operations fail unexpectedly that we most need to know why.</p>
<p>Errors are thus an important part of a package’s API or an application’s user interface, and failure is just one of several expected behaviors. This is the approach Go takes to error handling.</p>
<p>A function for which failure is an expected behavior returns an additional result, conventionally the last one. If the failure has only one possible cause, the result is a boolean, usually called <code>ok</code>, as in this example of a cache lookup that always succeeds unless there was no entry for that key:</p>
<pre class="code" ><code class="chroma" ><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...cache[key] does not exist...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>More often, and especially for I/O, the failure may have a variety of causes for which the caller will need an explanation. In such cases, the type of the additional result is <code>error</code>.</p>
<p>The built-in type <code>error</code> is an interface type. We’ll see more of what this means and its implications for error handling in <a href="#chapter-7" >Chapter 7</a>. For now it’s enough to know that an error may be nil or non-nil, that nil implies success and non-nil implies failure, and that a non-nil <code>error</code> has an error message string which we can obtain by calling its <code>Error</code> method or print by calling <code>fmt.Println(err)</code> or <code>fmt.Printf(&#34;%v&#34;, err)</code>.</p>
<p>Usually when a function returns a non-nil error, its other results are undefined and should be ignored. However, a few functions may return partial results in error cases. For example, if an error occurs while reading from a file, a call to <code>Read</code> returns the number of bytes it was able to read <em>and</em> an <code>error</code> value describing the problem. For correct behavior, some callers may need to process the incomplete data before handling the error, so it is important that such functions clearly document their results.</p>
<p>Go’s approach sets it apart from many other languages in which failures are reported using <em>exceptions</em>, not ordinary values. Although Go does have an exception mechanism of sorts, as we will see in <a href="#section-5.9" >Section 5.9</a>, it is used only for reporting truly unexpected errors that indicate a bug, not the routine errors that a robust program should be built to expect.</p>
<p>The reason for this design is that exceptions tend to entangle the description of an error with the control flow required to handle it, often leading to an undesirable outcome: routine errors are reported to the end user in the form of an incomprehensible stack trace, full of information about the structure of the program but lacking intelligible context about what went wrong.</p>
<p>By contrast, Go programs use ordinary control-flow mechanisms like <code>if</code> and <code>return</code> to respond to errors. This style undeniably demands that more attention be paid to error-handling logic, but that is precisely the point.</p>
</div>
<h4 id="section-5.4.1" >Error-Handling Strategies</h4>
<div class="hBody-4" >
<p>When a function call returns an error, it’s the caller’s responsibility to check it and take appropriate action. Depending on the situation, there may be a number of possibilities. Let’s take a look at five of them.</p>
<p>First, and most common, is to <em>propagate</em> the error, so that a failure in a subroutine becomes a failure of the calling routine. We saw examples of this in the <code>findLinks</code> function of <a href="#section-5.3" >Section 5.3</a>. If the call to <code>http.Get</code> fails, <code>findLinks</code> returns the HTTP error to the caller without further ado:</p>
<pre class="code" ><code class="chroma" ><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre>
<p>In contrast, if the call to <code>html.Parse</code> fails, <code>findLinks</code> does not return the HTML parser’s error directly because it lacks two crucial pieces of information: that the error occurred in the parser, and the URL of the document that was being parsed. In this case, <code>findLinks</code> constructs a new error message that includes both pieces of information as well as the underlying parse error:</p>
<pre class="code" ><code class="chroma" ><span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing %s as HTML: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>fmt.Errorf</code> function formats an error message using <code>fmt.Sprintf</code> and returns a new <code>error</code> value. We use it to build descriptive errors by successively prefixing additional context information to the original error message. When the error is ultimately handled by the program’s <code>main</code> function, it should provide a clear causal chain from the root problem to the overall failure, reminiscent of a NASA accident investigation:</p>
<div class="pre-block" >
<pre class="pre" >genesis: crashed: no parachute: G-switch failed: bad relay orientation
</pre>
</div>
<p>Because error messages are frequently chained together, message strings should not be capitalized and newlines should be avoided. The resulting errors may be long, but they will be selfcontained when found by tools like <code class="command" >grep</code>.</p>
<p>When designing error messages, be deliberate, so that each one is a meaningful description of the problem with sufficient and relevant detail, and be consistent, so that errors returned by the same function or by a group of functions in the same package are similar in form and can be dealt with in the same way.</p>
<p>For example, the <code>os</code> package guarantees that every error returned by a file operation, such as <code>os.Open</code> or the <code>Read</code>, <code>Write</code>, or <code>Close</code> methods of an open file, describes not just the nature of the failure (permission denied, no such directory, and so on) but also the name of the file, so the caller needn’t include this information in the error message it constructs.</p>
<p>In general, the call <code>f(x)</code> is responsible for reporting the attempted operation <code>f</code> and the argument value <code>x</code> as they relate to the context of the error. The caller is responsible for adding further information that it has but the call <code>f(x)</code> does not, such as the URL in the call to <code>html.Parse</code> above.</p>
<p>Let’s move on to the second strategy for handling errors. For errors that represent transient or unpredictable problems, it may make sense to <em>retry</em> the failed operation, possibly with a delay between tries, and perhaps with a limit on the number of attempts or the time spent trying before giving up entirely.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/wait/wait.go" >gopl.io/ch5/wait</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// WaitForServer attempts to contact the server of a URL.
</span><span class="c1">// It tries for one minute using exponential back-off.
</span><span class="c1">// It reports an error if all attempts fail.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">timeout</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
  <span class="nx">deadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">tries</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Before</span><span class="p">(</span><span class="nx">deadline</span><span class="p">);</span> <span class="nx">tries</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Head</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// success
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;server not responding (%s); retrying...&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">&lt;&lt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">tries</span><span class="p">))</span> <span class="c1">// exponential back-off
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;server %s failed to respond after %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Third, if progress is impossible, the caller can print the error and stop the program gracefully, but this course of action should generally be reserved for the main package of a program.  Library functions should usually propagate errors to the caller, unless the error is a sign of an internal inconsistency—that is, a bug.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// (In function main.)
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;Site is down: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>A more convenient way to achieve the same effect is to call <code>log.Fatalf</code>. As with all the <code>log</code> functions, by default it prefixes the time and date to the error message.</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;Site is down: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The default format is helpful in a long-running server, but less so for an interactive tool:</p>
<div class="pre-block" >
<pre class="pre" >2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io
</pre>
</div>
<p>For a more attractive output, we can set the prefix used by the <code>log</code> package to the name of the command, and suppress the display of the date and time:</p>
<pre class="code" ><code class="chroma" ><span class="nx">log</span><span class="p">.</span><span class="nx">SetPrefix</span><span class="p">(</span><span class="s">&#34;wait: &#34;</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">SetFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre>
<p>Fourth, in some cases, it’s sufficient just to log the error and then continue, perhaps with reduced functionality. Again there’s a choice between using the <code>log</code> package, which adds the usual prefix:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;ping failed: %v; networking disabled&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>and printing directly to the standard error stream:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;ping failed: %v; networking disabled\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>(All <code>log</code> functions append a newline if one is not already present.)</p>
<p>And fifth and finally, in rare cases we can safely ignore an error entirely:</p>
<pre class="code" ><code class="chroma" ><span class="nx">dir</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">TempDir</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;scratch&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;failed to create temp dir: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...use temp dir...
</span><span class="c1"></span>
<span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// ignore errors; $TMPDIR is cleaned periodically
</span><span class="c1"></span></code></pre>
<p>The call to <code>os.RemoveAll</code> may fail, but the program ignores it because the operating system periodically cleans out the temporary directory. In this case, discarding the error was intentional, but the program logic would be the same had we forgotten to deal with it. Get into the habit of considering errors after every function call, and when you deliberately ignore one, document your intention clearly.</p>
<p>Error handling in Go has a particular rhythm. After checking an error, failure is usually dealt with before success. If failure causes the function to return, the logic for success is not indented within an <code>else</code> block but follows at the outer level. Functions tend to exhibit a common structure, with a series of initial checks to reject errors, followed by the substance of the function at the end, minimally indented.</p>
</div>
<h4 id="section-5.4.2" >End of File (EOF)</h4>
<div class="hBody-4" >
<p>Usually, the variety of errors that a function may return is interesting to the end user but not to the intervening program logic. On occasion, however, a program must take different actions depending on the kind of error that has occurred. Consider an attempt to read <span class="math" >n</span> bytes of data from a file. If <span class="math" >n</span> is chosen to be the length of the file, any error represents a failure. On the other hand, if the caller repeatedly tries to read fixed-size chunks until the file is exhausted, the caller must respond differently to an end-of-file condition than it does to all other errors. For this reason, the <code>io</code> package guarantees that any read failure caused by an end-of-file condition is always reported by a distinguished error, <code>io.EOF</code>, which is defined as follows:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">io</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>

<span class="c1">// EOF is the error returned by Read when no more input is available.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">EOF</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">)</span>
</code></pre>
<p>The caller can detect this condition using a simple comparison, as in the loop below, which reads runes from the standard input. (The <code class="command" >charcount</code> program in <a href="#section-4.3" >Section 4.3</a> provides a more complete example.)</p>
<pre class="code" ><code class="chroma" ><span class="nx">in</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">.</span><span class="nx">ReadRune</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
    <span class="k">break</span> <span class="c1">// finished reading
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;read failed: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...use r...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Since in an end-of-file condition there is no information to report besides the fact of it, <code>io.EOF</code> has a fixed error message, <code>&#34;EOF&#34;</code>. For other errors, we may need to report both the quality and quantity of the error, so to speak, so a fixed error value will not do. In <a href="#section-7.11" >Section 7.11</a>, we’ll present a more systematic way to distinguish certain error values from others.</p>
</div>
<h3 id="section-5.5" >Function Values</h3>
<div class="hBody-3" >
<p>Functions are <em>first-class values</em> in Go: like other values, function values have types, and they may be assigned to variables or passed to or returned from functions. A function value may be called like any other function. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">square</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">negative</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>   <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">product</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>

<span class="nx">f</span> <span class="o">:=</span> <span class="nx">square</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>     <span class="c1">// &#34;9&#34;
</span><span class="c1"></span>
<span class="nx">f</span> <span class="p">=</span> <span class="nx">negative</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>     <span class="c1">// &#34;-3&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &#34;func(int) int&#34;
</span><span class="c1"></span>
<span class="nx">f</span> <span class="p">=</span> <span class="nx">product</span> <span class="c1">// compile error: can&#39;t assign func(int, int) int to func(int) int
</span><span class="c1"></span></code></pre>
<p>The zero value of a function type is <code>nil</code>. Calling a nil function value causes a panic:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// panic: call of nil function
</span><span class="c1"></span></code></pre>
<p>Function values may be compared with <code>nil</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="k">if</span> <span class="nx">f</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>but they are not comparable, so they may not be compared against each other or used as keys in a map.</p>
<p>Function values let us parameterize our functions over not just data, but behavior too. The standard libraries contain many examples. For instance, <code>strings.Map</code> applies a function to each character of a string, joining the results to make another string.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">add1</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&#34;HAL-9000&#34;</span><span class="p">))</span> <span class="c1">// &#34;IBM.:111&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&#34;VMS&#34;</span><span class="p">))</span>      <span class="c1">// &#34;WNT&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&#34;Admix&#34;</span><span class="p">))</span>    <span class="c1">// &#34;Benjy&#34;
</span><span class="c1"></span></code></pre>
<p>The <code>findLinks</code> function from <a href="#section-5.2" >Section 5.2</a> uses a helper function, <code>visit</code>, to visit all the nodes in an HTML document and apply an action to each one. Using a function value, we can separate the logic for tree traversal from the logic for the action to be applied to each node, letting us reuse the traversal with different actions.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/outline2/outline.go" >gopl.io/ch5/outline2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// forEachNode calls the functions pre(x) and post(x) for each node
</span><span class="c1">// x in the tree rooted at n. Both functions are optional.
</span><span class="c1">// pre is called before the children are visited (preorder) and
</span><span class="c1">// post is called after (postorder).
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">pre</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">pre</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">post</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">post</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>forEachNode</code> function accepts two function arguments, one to call before a node’s children are visited and one to call after. This arrangement gives the caller a great deal of flexibility. For example, the functions <code>startElement</code> and <code>endElement</code> print the start and end tags of an HTML element like <code>&lt;b&gt;...&lt;/b&gt;</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">depth</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">startElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%*s&lt;%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="nx">depth</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">endElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">depth</span><span class="o">--</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%*s&lt;/%s&gt;\n&#34;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The functions also indent the output using another <code>fmt.Printf</code> trick. The <code>*</code> adverb in <code>%*s</code> prints a string padded with a variable number of spaces. The width and the string are provided by the arguments <code>depth*2</code> and <code>&#34;&#34;</code>.</p>
<p>If we call <code>forEachNode</code> on an HTML document, like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">startElement</span><span class="p">,</span> <span class="nx">endElement</span><span class="p">)</span>
</code></pre>
<p>we get a more elaborate variation on the output of our earlier <code class="command" >outline</code> program:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/outline2
</span><span class="in" ><span class="prompt" >&gt; </span>./outline2 http://gopl.io
</span><span class="out" >&lt;html&gt;
  &lt;head&gt;
    &lt;meta&gt;
    &lt;/meta&gt;
    &lt;title&gt;
    &lt;/title&gt;
    &lt;style&gt;
    &lt;/style&gt;
  &lt;/head&gt;
&lt;body&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;
          &lt;a&gt;
            &lt;img&gt;
            &lt;/img&gt;
...
</span></code></pre>
<p><b>Exercise 5.7</b>: Develop <code>startElement</code> and <code>endElement</code> into a general HTML pretty-printer.  Print comment nodes, text nodes, and the attributes of each element (<code>&lt;a href=&#39;...&#39;&gt;</code>). Use short forms like <code>&lt;img/&gt;</code> instead of <code>&lt;img&gt;&lt;/img&gt;</code> when an element has no children. Write a test to ensure that the output can be parsed successfully. (See <a href="#chapter-11" >Chapter 11</a>.)</p>
<p><b>Exercise 5.8</b>: Modify <code>forEachNode</code> so that the <code>pre</code> and <code>post</code> functions return a boolean result indicating whether to continue the traversal. Use it to write a function <code>ElementByID</code> with the following signature that finds the first HTML element with the specified <code>id</code> attribute. The function should stop the traversal as soon as a match is found.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">ElementByID</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>
</code></pre>
<p><b>Exercise 5.9</b>: Write a function <code>expand(s string, f func(string) string) string</code> that replaces each substring <q><code>$foo</code></q> within <code>s</code> by the text returned by <code>f(&#34;foo&#34;)</code>.</p>
</div>
<h3 id="section-5.6" >Anonymous Functions</h3>
<div class="hBody-3" >
<p>Named functions can be declared only at the package level, but we can use a <em>function literal</em> to denote a function value within any expression. A function literal is written like a function declaration, but without a name following the <code>func</code> keyword. It is an expression, and its value is called an <em>anonymous function</em>.</p>
<p>Function literals let us define a function at its point of use. As an example, the earlier call to <code>strings.Map</code> can be rewritten as</p>
<pre class="code" ><code class="chroma" ><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">},</span> <span class="s">&#34;HAL-9000&#34;</span><span class="p">)</span>
</code></pre>
<p>More importantly, functions defined in this way have access to the entire lexical environment, so the inner function can refer to variables from the enclosing function, as this example shows:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/squares/main.go" >gopl.io/ch5/squares</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// squares returns a function that returns
</span><span class="c1">// the next square number each time it is called.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">squares</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">x</span><span class="o">++</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">squares</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &#34;4&#34;
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &#34;9&#34;
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &#34;16&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>The function <code>squares</code> returns another function, of type <code>func() int</code>. A call to <code>squares</code> creates a local variable <code>x</code> and returns an anonymous function that, each time it is called, increments <code>x</code> and returns its square. A second call to <code>squares</code> would create a second variable <code>x</code> and return a new anonymous function which increments that variable.</p>
<p>The <code>squares</code> example demonstrates that function values are not just code but can have state.  The anonymous inner function can access and update the local variables of the enclosing function <code>squares</code>. These hidden variable references are why we classify functions as reference types and why function values are not comparable. Function values like these are implemented using a technique called <em>closures</em>, and Go programmers often use this term for function values.</p>
<p>Here again we see an example where the lifetime of a variable is not determined by its scope: the variable <code>x</code> exists after <code>squares</code> has returned within <code>main</code>, even though <code>x</code> is hidden inside <code>f</code>.</p>
<p>As a somewhat academic example of anonymous functions, consider the problem of computing a sequence of computer science courses that satisfies the prerequisite requirements of each one. The prerequisites are given in the <code>prereqs</code> table below, which is a mapping from each course to the list of courses that must be completed before it.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/toposort/main.go" >gopl.io/ch5/toposort</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// prereqs maps computer science courses to their prerequisites.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">prereqs</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{</span>
  <span class="s">&#34;algorithms&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;data structures&#34;</span><span class="p">},</span>
  <span class="s">&#34;calculus&#34;</span><span class="p">:</span>   <span class="p">{</span><span class="s">&#34;linear algebra&#34;</span><span class="p">},</span>

  <span class="s">&#34;compilers&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">&#34;data structures&#34;</span><span class="p">,</span>
    <span class="s">&#34;formal languages&#34;</span><span class="p">,</span>
    <span class="s">&#34;computer organization&#34;</span><span class="p">,</span>
  <span class="p">},</span>

  <span class="s">&#34;data structures&#34;</span><span class="p">:</span>       <span class="p">{</span><span class="s">&#34;discrete math&#34;</span><span class="p">},</span>
  <span class="s">&#34;databases&#34;</span><span class="p">:</span>             <span class="p">{</span><span class="s">&#34;data structures&#34;</span><span class="p">},</span>
  <span class="s">&#34;discrete math&#34;</span><span class="p">:</span>         <span class="p">{</span><span class="s">&#34;intro to programming&#34;</span><span class="p">},</span>
  <span class="s">&#34;formal languages&#34;</span><span class="p">:</span>      <span class="p">{</span><span class="s">&#34;discrete math&#34;</span><span class="p">},</span>
  <span class="s">&#34;networks&#34;</span><span class="p">:</span>              <span class="p">{</span><span class="s">&#34;operating systems&#34;</span><span class="p">},</span>
  <span class="s">&#34;operating systems&#34;</span><span class="p">:</span>     <span class="p">{</span><span class="s">&#34;data structures&#34;</span><span class="p">,</span> <span class="s">&#34;computer organization&#34;</span><span class="p">},</span>
  <span class="s">&#34;programming languages&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;data structures&#34;</span><span class="p">,</span> <span class="s">&#34;computer organization&#34;</span><span class="p">},</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This kind of problem is known as topological sorting. Conceptually, the prerequisite information forms a directed graph with a node for each course and edges from each course to the courses that it depends on. The graph is acyclic: there is no path from a course that leads back to itself. We can compute a valid sequence using depth-first search through the graph with the code below :</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">course</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">prereqs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d:\t%s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">course</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">order</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">visitAll</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

  <span class="nx">visitAll</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
        <span class="nx">order</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">order</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">keys</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
  <span class="nx">visitAll</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">order</span>
<span class="p">}</span>
</code></pre>
<p>When an anonymous function requires recursion, as in this example, we must first declare a variable, and then assign the anonymous function to that variable. Had these two steps been combined in the declaration, the function literal would not be within the scope of the variable <code>visitAll</code> so it would have no way to call itself recursively:</p>
<pre class="code" ><code class="chroma" ><span class="nx">visitAll</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span> <span class="c1">// compile error: undefined: visitAll
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The output of the <code class="command" >toposort</code> program is shown below. It is deterministic, an often-desirable property that doesn’t always come for free. Here, the values of the <code>prereqs</code> map are slices, not more maps, so their iteration order is deterministic, and we sorted the keys of <code>prereqs</code> before making the initial calls to <code>visitAll</code>.</p>
<div class="pre-block" >
<pre class="pre" >1:      intro to programming
2:      discrete math
3:      data structures
4:      algorithms
5:      linear algebra
6:      calculus
7:      formal languages
8:      computer organization
9:      compilers
10:     databases
11:     operating systems
12:     networks
13:     programming languages
</pre>
</div>
<p>Let’s return to our <code>findLinks</code> example. We’ve moved the link-extraction function <code>links.Extract</code> to its own package, since we’ll use it again in <a href="#chapter-8" >Chapter 8</a>. We replaced the <code>visit</code> function with an anonymous function that appends to the <code>links</code> slice directly, and used <code>forEachNode</code> to handle the traversal. Since <code>Extract</code> needs only the <code>pre</code> function, it passes <code>nil</code> for the <code>post</code> argument.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/links/links.go" >gopl.io/ch5/links</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package links provides a link-extraction function.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">links</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;net/http&#34;</span>

  <span class="s">&#34;golang.org/x/net/html&#34;</span>
<span class="p">)</span>

<span class="c1">// Extract makes an HTTP GET request to the specified URL, parses
</span><span class="c1">// the response as HTML, and returns the links in the HTML document.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;getting %s: %s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing %s as HTML: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&#34;a&#34;</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">!=</span> <span class="s">&#34;href&#34;</span> <span class="p">{</span>
          <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">link</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">continue</span> <span class="c1">// ignore bad URLs
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">link</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">links</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Instead of appending the raw <code>href</code> attribute value to the <code>links</code> slice, this version parses it as a URL relative to the base URL of the document, <code>resp.Request.URL</code>. The resulting <code>link</code> is in absolute form, suitable for use in a call to <code>http.Get</code>.</p>
<p>Crawling the web is, at its heart, a problem of graph traversal. The <code>topoSort</code> example showed a depth-first traversal; for our web crawler, we’ll use breadth-first traversal, at least initially. In <a href="#chapter-8" >Chapter 8</a>, we’ll explore concurrent traversal.</p>
<p>The function below encapsulates the essence of a breadth-first traversal. The caller provides an initial list <code>worklist</code> of items to visit and a function value <code>f</code> to call for each item. Each item is identified by a string. The function <code>f</code> returns a list of new items to append to the worklist. The <code>breadthFirst</code> function returns when all items have been visited. It maintains a set of strings to ensure that no item is visited twice.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/findlinks3/findlinks.go" >gopl.io/ch5/findlinks3</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// breadthFirst calls f for each item in the worklist.
</span><span class="c1">// Any items returned by f are added to the worklist.
</span><span class="c1">// f is called at most once for each item.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">worklist</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">worklist</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">items</span> <span class="o">:=</span> <span class="nx">worklist</span>
    <span class="nx">worklist</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">worklist</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">worklist</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>As we explained in passing in <a href="#chapter-4" >Chapter 4</a>, the argument <q><code>f(item)...</code></q> causes all the items in the list returned by <code>f</code> to be appended to the worklist.</p>
<p>In our crawler, items are URLs. The <code>crawl</code> function we’ll supply to <code>breadthFirst</code> prints the URL, extracts its links, and returns them so that they too are visited.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</code></pre>
<p>To start the crawler off, we’ll use the command-line arguments as the initial URLs.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Crawl the web breadth-first,
</span><span class="c1"></span>  <span class="c1">// starting from the command-line arguments.
</span><span class="c1"></span>  <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">crawl</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>
</code></pre>
<p>Let’s crawl the web starting from <code>https://golang.org</code>. Here are some of the resulting links:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/findlinks3
</span><span class="in" ><span class="prompt" >&gt; </span>./findlinks3 https://golang.org
</span><span class="out" >https://golang.org/
https://golang.org/doc/
https://golang.org/pkg/
https://golang.org/project/
https://code.google.com/p/go-tour/
https://golang.org/doc/code.html
https://www.youtube.com/watch?v=XCsL89YtqCs
http://research.swtch.com/gotour
https://vimeo.com/53221560
</span></code></pre>
<p>The process ends when all reachable web pages have been crawled or the memory of the computer is exhausted.</p>
<p><b>Exercise 5.10</b>: Rewrite <code>topoSort</code> to use maps instead of slices and eliminate the initial sort.  Verify that the results, though nondeterministic, are valid topological orderings.</p>
<p><b>Exercise 5.11</b>: The instructor of the linear algebra course decides that calculus is now a prerequisite. Extend the <code>topoSort</code> function to report cycles.</p>
<p><b>Exercise 5.12</b>: The <code>startElement</code> and <code>endElement</code> functions in <code>gopl.io/ch5/outline2</code> (<a href="#section-5.5" >§5.5</a>) share a global variable, <code>depth</code>. Turn them into anonymous functions that share a variable local to the <code>outline</code> function.</p>
<p><b>Exercise 5.13</b>: Modify <code>crawl</code> to make local copies of the pages it finds, creating directories as necessary. Don’t make copies of pages that come from a different domain. For example, if the original page comes from <a href="https://golang.org" >golang.org</a>, save all files from there, but exclude ones from <a href="https://vimeo.com" >vimeo.com</a>.</p>
<p><b>Exercise 5.14</b>: Use the <code>breadthFirst</code> function to explore a different structure. For example, you could use the course dependencies from the <code>topoSort</code> example (a directed graph), the file system hierarchy on your computer (a tree), or a list of bus or subway routes downloaded from your city government’s web site (an undirected graph).</p>
</div>
<h4 id="section-5.6.1" >Caveat: Capturing Iteration Variables</h4>
<div class="hBody-4" >
<p>In this section, we’ll look at a pitfall of Go’s lexical scope rules that can cause surprising results.  We urge you to understand the problem before proceeding, because the trap can ensnare even experienced programmers.</p>
<p>Consider a program that must create a set of directories and later remove them. We can use a slice of function values to hold the clean-up operations. (For brevity, we have omitted all error handling in this example.)</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">d</span>               <span class="c1">// NOTE: necessary!
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// creates parent directories too
</span><span class="c1"></span>  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// ...do some work...
</span><span class="c1"></span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rmdir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rmdirs</span> <span class="p">{</span>
  <span class="nx">rmdir</span><span class="p">()</span> <span class="c1">// clean up
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>You may be wondering why we assigned the loop variable <code>d</code> to a new local variable <code>dir</code> within the loop body, instead of just naming the loop variable <code>dir</code> as in this subtly incorrect variant:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// NOTE: incorrect!
</span><span class="c1"></span>  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>The reason is a consequence of the scope rules for loop variables. In the program immediately above, the <code>for</code> loop introduces a new lexical block in which the variable <code>dir</code> is declared. All function values created by this loop <q>capture</q> and share the same variable—an addressable storage location, not its value at that particular moment. The value of <code>dir</code> is updated in successive iterations, so by the time the cleanup functions are called, the <code>dir</code> variable has been updated several times by the now-completed <code>for</code> loop. Thus <code>dir</code> holds the value from the final iteration, and consequently all calls to <code>os.RemoveAll</code> will attempt to remove the same directory.</p>
<p>Frequently, the inner variable introduced to work around this problem—<code>dir</code> in our example—is given the exact same name as the outer variable of which it is a copy, leading to odd-looking but crucial variable declarations like this:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">dir</span> <span class="c1">// declares inner dir, initialized to outer dir
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The risk is not unique to <code>range</code>-based <code>for</code> loops. The loop in the example below suffers from the same problem due to unintended capture of the index variable <code>i</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="nx">dirs</span> <span class="o">:=</span> <span class="nx">tempDirs</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dirs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// OK
</span><span class="c1"></span>  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// NOTE: incorrect!
</span><span class="c1"></span>  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>The problem of iteration variable capture is most often encountered when using the <code>go</code> statement (<a href="#chapter-8" >Chapter 8</a>) or with <code>defer</code> (which we will see in a moment) since both may delay the execution of a function value until after the loop has finished. But the problem is not inherent to <code>go</code> or <code>defer</code>.</p>
</div>
<h3 id="section-5.7" >Variadic Functions</h3>
<div class="hBody-3" >
<p>A <em>variadic function</em> is one that can be called with varying numbers of arguments. The most familiar examples are <code>fmt.Printf</code> and its variants. <code>Printf</code> requires one fixed argument at the beginning, then accepts any number of subsequent arguments.</p>
<p>To declare a variadic function, the type of the final parameter is preceded by an ellipsis, <q><code>...</code></q>, which indicates that the function may be called with any number of arguments of this type.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/sum/main.go" >gopl.io/ch5/sum</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">val</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>sum</code> function above returns the sum of zero or more <code>int</code> arguments. Within the body of the function, the type of <code>vals</code> is an <code>[]int</code> slice. When <code>sum</code> is called, any number of values may be provided for its <code>vals</code> parameter.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">())</span>           <span class="c1">// &#34;0&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>          <span class="c1">// &#34;3&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &#34;10&#34;
</span><span class="c1"></span></code></pre>
<p>Implicitly, the caller allocates an array, copies the arguments into it, and passes a slice of the entire array to the function. The last call above thus behaves the same as the call below, which shows how to invoke a variadic function when the arguments are already in a slice: place an ellipsis after the final argument.</p>
<pre class="code" ><code class="chroma" ><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="o">...</span><span class="p">))</span> <span class="c1">// &#34;10&#34;
</span><span class="c1"></span></code></pre>
<p>Although the <code>...int</code> parameter behaves like a slice within the function body, the type of a variadic function is distinct from the type of a function with an ordinary slice parameter.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">g</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &#34;func(...int)&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="c1">// &#34;func([]int)&#34;
</span><span class="c1"></span></code></pre>
<p>Variadic functions are often used for string formatting. The <code>errorf</code> function below constructs a formatted error message with a line number at the beginning. The suffix <code>f</code> is a widely followed naming convention for variadic functions that accept a <code>Printf</code>-style format string.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;Line %d: &#34;</span><span class="p">,</span> <span class="nx">linenum</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">linenum</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&#34;count&#34;</span>
<span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span><span class="p">,</span> <span class="s">&#34;undefined: %s&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="c1">// &#34;Line 12: undefined: count&#34;
</span><span class="c1"></span></code></pre>
<p>The <code>interface{}</code> type means that this function can accept any values at all for its final arguments, as we’ll explain in <a href="#chapter-7" >Chapter 7</a>.</p>
<p><b>Exercise 5.15</b>: Write variadic functions <code>max</code> and <code>min</code>, analogous to <code>sum</code>. What should these functions do when called with no arguments? Write variants that require at least one argument.</p>
<p><b>Exercise 5.16</b>: Write a variadic version of <code>strings.Join</code>.</p>
<p><b>Exercise 5.17</b>: Write a variadic function <code>ElementsByTagName</code> that, given an HTML node tree and zero or more names, returns all the elements that match one of those names. Here are two example calls:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">name</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>

<span class="nx">images</span> <span class="o">:=</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="s">&#34;img&#34;</span><span class="p">)</span>
<span class="nx">headings</span> <span class="o">:=</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="s">&#34;h1&#34;</span><span class="p">,</span> <span class="s">&#34;h2&#34;</span><span class="p">,</span> <span class="s">&#34;h3&#34;</span><span class="p">,</span> <span class="s">&#34;h4&#34;</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="section-5.8" >Deferred Function Calls</h3>
<div class="hBody-3" >
<p>Our <code>findLinks</code> examples used the output of <code>http.Get</code> as the input to <code>html.Parse</code>. This works well if the content of the requested URL is indeed HTML, but many pages contain images, plain text, and other file formats. Feeding such files into an HTML parser could have undesirable effects.</p>
<p>The program below fetches an HTML document and prints its title. The <code>title</code> function inspects the <code>Content-Type</code> header of the server’s response and returns an error if the document is not HTML.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/title1/title.go" >gopl.io/ch5/title1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// Check Content-Type is HTML (e.g., &#34;text/html; charset=utf-8&#34;).
</span><span class="c1"></span>  <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&#34;text/html&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&#34;text/html;&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s has type %s, not text/html&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing %s as HTML: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&#34;title&#34;</span> <span class="o">&amp;&amp;</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Here’s a typical session, slightly edited to fit:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/title1
</span><span class="in" ><span class="prompt" >&gt; </span>./title1 http://gopl.io
</span><span class="out" >The Go Programming Language
</span><span class="in" ><span class="prompt" >&gt; </span>./title1 https://golang.org/doc/effective_go.html
</span><span class="out" >Effective Go - The Go Programming Language
</span><span class="in" ><span class="prompt" >&gt; </span>./title1 https://golang.org/doc/gopher/frontpage.png
</span><span class="out" >title: https://golang.org/doc/gopher/frontpage.png
    has type image/png, not text/html
</span></code></pre>
<p>Observe the duplicated <code>resp.Body.Close()</code> call, which ensures that <code>title</code> closes the network connection on all execution paths, including failures. As functions grow more complex and have to handle more errors, such duplication of clean-up logic may become a maintenance problem. Let’s see how Go’s novel <code>defer</code> mechanism makes things simpler.</p>
<p>Syntactically, a <code>defer</code> statement is an ordinary function or method call prefixed by the keyword <code>defer</code>. The function and argument expressions are evaluated when the statement is executed, but the actual call is <em>deferred</em> until the function that contains the <code>defer</code> statement has finished, whether normally, by executing a return statement or falling off the end, or abnormally, by panicking. Any number of calls may be deferred; they are executed in the reverse of the order in which they were deferred.</p>
<p>A <code>defer</code> statement is often used with paired operations like open and close, connect and disconnect, or lock and unlock to ensure that resources are released in all cases, no matter how complex the control flow. The right place for a <code>defer</code> statement that releases a resource is immediately after the resource has been successfully acquired. In the <code>title</code> function below, a single deferred call replaces both previous calls to <code>resp.Body.Close()</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/title2/title.go" >gopl.io/ch5/title2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&#34;text/html&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&#34;text/html;&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s has type %s, not text/html&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;parsing %s as HTML: %v&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// ...print doc&#39;s title element...
</span><span class="c1"></span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The same pattern can be used for other resources beside network connections, for instance to close an open file:</p>
<div class="figure" >
<h1 class="figure"><code>io/ioutil</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">ioutil</span>

<span class="kd">func</span> <span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">ReadAll</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>or to unlock a mutex (<a href="#section-9.2" >§9.2</a>):</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>The <code>defer</code> statement can also be used to pair <q>on entry</q> and <q>on exit</q> actions when debugging a complex function. The <code>bigSlowOperation</code> function below calls <code>trace</code> immediately, which does the <q>on entry</q> action then returns a function value that, when called, does the corresponding <q>on exit</q> action. By deferring a call to the returned function in this way, we can instrument the entry point and all exit points of a function in a single statement and even pass values, like the <code>start</code> time, between the two actions. But don’t forget the final parentheses in the <code>defer</code> statement, or the <q>on entry</q> action will happen on exit and the on-exit action won’t happen at all!</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/trace/main.go" >gopl.io/ch5/trace</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">bigSlowOperation</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">trace</span><span class="p">(</span><span class="s">&#34;bigSlowOperation&#34;</span><span class="p">)()</span> <span class="c1">// don&#39;t forget the extra parentheses
</span><span class="c1"></span>  <span class="c1">// ...lots of work...
</span><span class="c1"></span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>      <span class="c1">// simulate slow operation by sleeping
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;enter %s&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;exit %s (%s)&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Each time <code>bigSlowOperation</code> is called, it logs its entry and exit and the elapsed time between them. (We used <code>time.Sleep</code> to simulate a slow operation.)</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch5/trace
</span><span class="in" ><span class="prompt" >&gt; </span>./trace
</span><span class="out" >2015/11/18 09:53:26 enter bigSlowOperation
2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s)
</span></code></pre>
<p>Deferred functions run <em>after</em> return statements have updated the function’s result variables.  Because an anonymous function can access its enclosing function’s variables, including named results, a deferred anonymous function can observe the function’s results.</p>
<p>Consider the function <code>double</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre>
<p>By naming its result variable and adding a <code>defer</code> statement, we can make the function print its arguments and results each time it is called.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;double(%d) = %d\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="nx">_</span> <span class="p">=</span> <span class="nx">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// &#34;double(4) = 8&#34;
</span><span class="c1"></span></code></pre>
<p>This trick is overkill for a function as simple as <code>double</code> but may be useful in functions with many return statements.</p>
<p>A deferred anonymous function can even change the values that the enclosing function returns to its caller:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">triple</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">+=</span> <span class="nx">x</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">double</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">triple</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1">// &#34;12&#34;
</span><span class="c1"></span></code></pre>
<p>Because deferred functions aren’t executed until the very end of a function’s execution, a <code>defer</code> statement in a loop deserves extra scrutiny. The code below could run out of file descriptors since no file will be closed until all files have been processed:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// NOTE: risky; could run out of file descriptors
</span><span class="c1"></span>  <span class="c1">// ...process f...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>One solution is to move the loop body, including the <code>defer</code> statement, into another function that is called on each iteration.</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="c1">// ...process f...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The example below is an improved <code class="command" >fetch</code> program (<a href="#section-1.5" >§1.5</a>) that writes the HTTP response to a local file instead of to the standard output. It derives the file name from the last component of the URL path, which it obtains using the <code>path.Base</code> function.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/fetch/main.go" >gopl.io/ch5/fetch</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Fetch downloads the URL and returns the
</span><span class="c1">// name and length of the local file.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="nx">local</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">Base</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">local</span> <span class="o">==</span> <span class="s">&#34;/&#34;</span> <span class="p">{</span>
    <span class="nx">local</span> <span class="p">=</span> <span class="s">&#34;index.html&#34;</span>
  <span class="p">}</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">local</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="c1">// Close file, but prefer error from Copy, if any.
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">closeErr</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">closeErr</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">local</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The deferred call to <code>resp.Body.Close</code> should be familiar by now. It’s tempting to use a second deferred call, to <code>f.Close</code>, to close the local file, but this would be subtly wrong because <code>os.Create</code> opens a file for writing, creating it as needed. On many file systems, notably NFS, write errors are not reported immediately but may be postponed until the file is closed. Failure to check the result of the close operation could cause serious data loss to go unnoticed.  However, if both <code>io.Copy</code> and <code>f.Close</code> fail, we should prefer to report the error from <code>io.Copy</code> since it occurred first and is more likely to tell us the root cause.</p>
<p><b>Exercise 5.18</b>: Without changing its behavior, rewrite the <code>fetch</code> function to use <code>defer</code> to close the writable file.</p>
</div>
<h3 id="section-5.9" >Panic</h3>
<div class="hBody-3" >
<p>Go’s type system catches many mistakes at compile time, but others, like an out-of-bounds array access or nil pointer dereference, require checks at run time. When the Go runtime detects these mistakes, it <em>panics</em>.</p>
<p>During a typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message. This log message includes the <em>panic value</em>, which is usually an error message of some sort, and, for each goroutine, a <em>stack Trace</em> showing the stack of function calls that were active at the time of the panic. This log message often has enough information to diagnose the root cause of the problem without running the program again, so it should always be included in a bug report about a panicking program.</p>
<p>Not all panics come from the runtime. The built-in <code>panic</code> function may be called directly ; it accepts any value as an argument. A panic is often the best thing to do when some <q>impossible</q> situation happens, for instance, execution reaches a case that logically can’t happen:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">suit</span><span class="p">(</span><span class="nx">drawCard</span><span class="p">());</span> <span class="nx">s</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&#34;Spades&#34;</span><span class="p">:</span>   <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="s">&#34;Hearts&#34;</span><span class="p">:</span>   <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="s">&#34;Diamonds&#34;</span><span class="p">:</span> <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="s">&#34;Clubs&#34;</span><span class="p">:</span>    <span class="c1">// ...
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;invalid suit %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">))</span> <span class="c1">// Joker?
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>It’s good practice to assert that the preconditions of a function hold, but this can easily be done to excess. Unless you can provide a more informative error message or detect an error sooner, there is no point asserting a condition that the runtime will check for you.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Reset</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;x is nil&#34;</span><span class="p">)</span> <span class="c1">// unnecessary!
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">x</span><span class="p">.</span><span class="nx">elements</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Although Go’s panic mechanism resembles exceptions in other languages, the situations in which panic is used are quite different. Since a panic causes the program to crash, it is generally used for grave errors, such as a logical inconsistency in the program; diligent programmers consider any crash to be proof of a bug in their code. In a robust program, <q>expected</q> errors, the kind that arise from incorrect input, misconfiguration, or failing I/O, should be handled gracefully; they are best dealt with using <code>error</code> values.</p>
<p>Consider the function <code>regexp.Compile</code>, which compiles a regular expression into an efficient form for matching. It returns an <code>error</code> if called with an ill-formed pattern, but checking this error is unnecessary and burdensome if the caller knows that a particular call cannot fail. In such cases, it’s reasonable for the caller to handle an error by panicking, since it is believed to be impossible.</p>
<p>Since most regular expressions are literals in the program source code, the <code>regexp</code> package provides a wrapper function <code>regexp.MustCompile</code> that does this check:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">regexp</span>

<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">MustCompile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Regexp</span> <span class="p">{</span>
  <span class="nx">re</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">re</span>
<span class="p">}</span>
</code></pre>
<p>The wrapper function makes it convenient for clients to initialize a package-level variable with a compiled regular expression, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">httpSchemeRE</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="s">`^https?:`</span><span class="p">)</span> <span class="c1">// &#34;http:&#34; or &#34;https:&#34;
</span><span class="c1"></span></code></pre>
<p>Of course, <code>MustCompile</code> should not be called with untrusted input values. The <code>Must</code> prefix is a common naming convention for functions of this kind, like <code>template.Must</code> in <a href="#section-4.6" >Section 4.6</a>.</p>
<p>When a panic occurs, all deferred functions are run in reverse order, starting with those of the topmost function on the stack and proceeding up to <code>main</code>, as the program below demonstrates:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/defer1/defer.go" >gopl.io/ch5/defer1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;f(%d)\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="mi">0</span><span class="o">/</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// panics if x == 0
</span><span class="c1"></span>  <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;defer %d\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>When run, the program prints the following to the standard output:</p>
<div class="pre-block" >
<pre class="pre" >f(3)
f(2)
f(1)
defer 1
defer 2
defer 3
</pre>
</div>
<p>A panic occurs during the call to <code>f(0)</code>, causing the three deferred calls to <code>fmt.Printf</code> to run.  Then the runtime terminates the program, printing the panic message and a stack dump to the standard error stream (simplified for clarity):</p>
<div class="pre-block" >
<pre class="pre" > panic: runtime error: integer divide by zero
 main.f(0)
         src/gopl.io/ch5/defer1/defer.go:14
 main.f(1)
         src/gopl.io/ch5/defer1/defer.go:16
 main.f(2)
         src/gopl.io/ch5/defer1/defer.go:16

 main.f(3)
         src/gopl.io/ch5/defer1/defer.go:16
 main.main()
         src/gopl.io/ch5/defer1/defer.go:10
</pre>
</div>
<p>As we will see soon, it is possible for a function to recover from a panic so that it does not terminate the program.</p>
<p>For diagnostic purposes, the <code>runtime</code> package lets the programmer dump the stack using the same machinery. By deferring a call to <code>printStack</code> in <code>main</code>,</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/defer2/defer.go" >gopl.io/ch5/defer2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">printStack</span><span class="p">()</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printStack</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="kt">byte</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:],</span> <span class="kc">false</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
<span class="p">}</span>
</code></pre>
</div>
<p>the following additional text (again simplified for clarity) is printed to the standard output:</p>
<div class="pre-block" >
<pre class="pre" > goroutine 1 [running]:
 main.printStack()
   src/gopl.io/ch5/defer2/defer.go:20
 main.f(0)
   src/gopl.io/ch5/defer2/defer.go:27
 main.f(1)
   src/gopl.io/ch5/defer2/defer.go:29
 main.f(2)
   src/gopl.io/ch5/defer2/defer.go:29
 main.f(3)
   src/gopl.io/ch5/defer2/defer.go:29
 main.main()
   src/gopl.io/ch5/defer2/defer.go:15
</pre>
</div>
<p>Readers familiar with exceptions in other languages may be surprised that <code>runtime.Stack</code> can print information about functions that seem to have already been <q>unwound.</q> Go’s panic mechanism runs the deferred functions <code>before</code> it unwinds the stack.</p>
</div>
<h3 id="section-5.10" >Recover</h3>
<div class="hBody-3" >
<p>Giving up is usually the right response to a panic, but not always. It might be possible to recover in some way, or at least clean up the mess before quitting. For example, a web server that encounters an unexpected problem could close the connection rather than leave the client hanging, and during development, it might report the error to the client too.</p>
<p>If the built-in <code>recover</code> function is called within a deferred function and the function containing the <code>defer</code> statement is panicking, <code>recover</code> ends the current state of panic and returns the panic value. The function that was panicking does not continue where it left off but returns normally. If <code>recover</code> is called at any other time, it has no effect and returns <code>nil</code>.</p>
<p>To illustrate, consider the development of a parser for a language. Even when it appears to be working well, given the complexity of its job, bugs may still lurk in obscure corner cases. We might prefer that, instead of crashing, the parser turns these panics into ordinary parse errors, perhaps with an extra message exhorting the user to file a bug report.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">input</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Syntax</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;internal error: %v&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c1">// ...parser...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The deferred function in <code>Parse</code> recovers from a panic, using the panic value to construct an error message; a fancier version might include the entire call stack using <code>runtime.Stack</code>. The deferred function then assigns to the <code>err</code> result, which is returned to the caller.</p>
<p>Recovering indiscriminately from panics is a dubious practice because the state of a package’s variables after a panic is rarely well defined or documented. Perhaps a critical update to a data structure was incomplete, a file or network connection was opened but not closed, or a lock was acquired but not released. Furthermore, by replacing a crash with, say, a line in a log file, indiscriminate recovery may cause bugs to go unnoticed.</p>
<p>Recovering from a panic within the same package can help simplify the handling of complex or unexpected errors, but as a general rule, you should not attempt to recover from another package’s panic. Public APIs should report failures as <code>errors</code>. Similarly, you should not recover from a panic that may pass through a function you do not maintain, such as a caller-provided callback, since you cannot reason about its safety.</p>
<p>For example, the <code>net/http</code> package provides a web server that dispatches incoming requests to user-provided handler functions. Rather than let a panic in one of these handlers kill the process, the server calls <code>recover</code>, prints a stack trace, and continues serving. This is convenient in practice, but it does risk leaking resources or leaving the failed handler in an unspecified state that could lead to other problems.</p>
<p>For all the above reasons, it’s safest to recover selectively if at all. In other words, recover only from panics that were intended to be recovered from, which should be rare. This intention can be encoded by using a distinct, unexported type for the panic value and testing whether the value returned by <code>recover</code> has that type. (We’ll see one way to do this in the next example.) If so, we report the panic as an ordinary <code>error</code>; if not, we call <code>panic</code> with the same value to resume the state of panic.</p>
<p>The example below is a variation on the <code class="command" >title</code> program that reports an error if the HTML document contains multiple <code>&lt;title&gt;</code> elements. If so, it aborts the recursion by calling <code>panic</code> with a value of the special type <code>bailout</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch5/title3/title.go" >gopl.io/ch5/title3</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// soleTitle returns the text of the first non-empty title element
</span><span class="c1">// in doc, and an error if there was not exactly one.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">soleTitle</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">title</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">bailout</span> <span class="kd">struct</span><span class="p">{}</span>

  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
      <span class="c1">// no panic
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">bailout</span><span class="p">{}:</span>
      <span class="c1">// &#34;expected&#34; panic
</span><span class="c1"></span>      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;multiple title elements&#34;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="nb">panic</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// unexpected panic; carry on panicking
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Bail out of recursion if we find more than one non-empty title.
</span><span class="c1"></span>  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&#34;title&#34;</span> <span class="o">&amp;&amp;</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">title</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">bailout</span><span class="p">{})</span> <span class="c1">// multiple title elements
</span><span class="c1"></span>      <span class="p">}</span>
      <span class="nx">title</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">title</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;no title element&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">title</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The deferred handler function calls <code>recover</code>, checks the panic value, and reports an ordinary error if the value was <code>bailout{}</code>. All other non-nil values indicate an unexpected panic, in which case the handler calls <code>panic</code> with that value, undoing the effect of <code>recover</code> and resuming the original state of panic. (This example does somewhat violate our advice about not using panics for <q>expected</q> errors, but it provides a compact illustration of the mechanics.)</p>
<p>From some conditions there is no recovery. Running out of memory, for example, causes the Go runtime to terminate the program with a fatal error.</p>
<p><b>Exercise 5.19</b>: Use <code>panic</code> and <code>recover</code> to write a function that contains no <code>return</code> statement yet returns a non-zero value.</p>
</div>
<h2 id="chapter-6" >Methods</h2>
<div class="hBody-2" >
<p>Since the early 1990s, object-oriented programming (OOP) has been the dominant programming paradigm in industry and education, and nearly all widely used languages developed since then have included support for it. Go is no exception.</p>
<p>Although there is no universally accepted definition of object-oriented programming, for our purposes, an <em>object</em> is simply a value or variable that has methods, and a <em>method</em> is a function associated with a particular type. An object-oriented program is one that uses methods to express the properties and operations of each data structure so that clients need not access the object’s representation directly.</p>
<p>In earlier chapters, we have made regular use of methods from the standard library, like the <code>Seconds</code> method of type <code>time.Duration</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">day</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">day</span><span class="p">.</span><span class="nx">Seconds</span><span class="p">())</span> <span class="c1">// &#34;86400&#34;
</span><span class="c1"></span></code></pre>
<p>and we defined a method of our own in <a href="#section-2.5" >Section 2.5</a>, a <code>String</code> method for the <code>Celsius</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%g°C&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
<p>In this chapter, the first of two on object-oriented programming, we’ll show how to define and use methods effectively. We’ll also cover two key principles of object-oriented programming, <em>encapsulation</em> and <em>composition</em>.</p>
</div>
<h3 id="section-6.1" >Method Declarations</h3>
<div class="hBody-3" >
<p>A method is declared with a variant of the ordinary function declaration in which an extra parameter appears before the function name. The parameter attaches the function to the type of that parameter.</p>
<p>Let’s write our first method in a simple package for plane geometry:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch6/geometry/geometry.go" >gopl.io/ch6/geometry</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">geometry</span>

<span class="kn">import</span> <span class="s">&#34;math&#34;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// traditional function
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// same thing, but as a method of the Point type
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The extra parameter <code>p</code> is called the method’s <em>receiver</em>, a legacy from early object-oriented languages that described calling a method as <q>sending a message to an object.</q></p>
<p>In Go, we don’t use a special name like <code>this</code> or <code>self</code> for the receiver; we choose receiver names just as we would for any other parameter. Since the receiver name will be frequently used, it’s a good idea to choose something short and to be consistent across methods. A common choice is the first letter of the type name, like <code>p</code> For <code>Point</code>.</p>
<p>In a method call, the receiver argument appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &#34;5&#34;, function call
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>  <span class="c1">// &#34;5&#34;, method call
</span><span class="c1"></span></code></pre>
<p>There’s no conflict between the two declarations of functions called <code>Distance</code> above. The first declares a package-level function called <code>geometry.Distance</code>. The second declares a method of the type <code>Point</code>, so its name is <code>Point.Distance</code>.</p>
<p>The expression <code>p.Distance</code> is called a <em>selector</em>, because it selects the appropriate <code>Distance</code> method for the receiver <code>p</code> of type <code>Point</code>. Selectors are also used to select fields of struct types, as in <code>p.X</code>. Since methods and fields inhabit the same name space, declaring a method <code>X</code> on the struct type <code>Point</code> would be ambiguous and the compiler will reject it.</p>
<p>Since each type has its own name space for methods, we can use the name <code>Distance</code> for other methods so long as they belong to different types. Let’s define a type <code>Path</code> that represents a sequence of line segments and give it a <code>Distance</code> method too.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// A Path is a journey connecting the points with straight lines.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="c1">// Distance returns the distance traveled along the path.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">:=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</code></pre>
<p><code>Path</code> is a named slice type, not a struct type like <code>Point</code>, yet we can still define methods for it.  In allowing methods to be associated with any type, Go is unlike many other object-oriented languages. It is often convenient to define additional behaviors for simple types such as numbers, strings, slices, maps, and sometimes even functions. Methods may be declared on any named type defined in the same package, so long as its underlying type is neither a pointer nor an interface.</p>
<p>The two <code>Distance</code> methods have different types. They’re not related to each other at all, though <code>Path.Distance</code> uses <code>Point.Distance</code> internally to compute the length of each segment that connects adjacent points.</p>
<p>Let’s call the new method to compute the perimeter of a right triangle:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="code" ><code class="chroma" ><span class="nx">perim</span> <span class="o">:=</span> <span class="nx">Path</span><span class="p">{</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span> <span class="c1">// &#34;12&#34;
</span><span class="c1"></span></code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<figure>
<img src="img/perim.Distance.jpg" />
</figure>
</div>
</div>
<p>In the two calls above to methods named <code>Distance</code>, the compiler determines which function to call based on both the method name and the type of the receiver. In the first, <code>path[i-1]</code> has type <code>Point</code> so <code>Point.Distance</code> is called; in the second, <code>perim</code> has type <code>Path</code>, so <code>Path.Distance</code> is called.</p>
<p>All methods of a given type must have unique names, but different types can use the same name for a method, like the <code>Distance</code> methods for <code>Point</code> and <code>Path</code>; there’s no need to qualify function names (for example, <code>PathDistance</code>) to disambiguate. Here we see the first benefit to using methods over ordinary functions: method names can be shorter. The benefit is magnified for calls originating outside the package, since they can use the shorter name <em>and</em> omit the package name:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;gopl.io/ch6/geometry&#34;</span>

<span class="nx">perim</span> <span class="o">:=</span> <span class="nx">geometry</span><span class="p">.</span><span class="nx">Path</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">PathDistance</span><span class="p">(</span><span class="nx">perim</span><span class="p">))</span> <span class="c1">// &#34;12&#34;, standalone function
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span>             <span class="c1">// &#34;12&#34;, method of geometry.Path
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-6.2" >Methods with a Pointer Receiver</h3>
<div class="hBody-3" >
<p>Because calling a function makes a copy of each argument value, if a function needs to update a variable, or if an argument is so large that we wish to avoid copying it, we must pass the address of the variable using a pointer. The same goes for methods that need to update the receiver variable: we attach them to the pointer type, such as <code>*Point</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</code></pre>
<p>The name of this method is <code>(*Point).ScaleBy</code>. The parentheses are necessary ; without them, the expression would be parsed as <code>*(Point.ScaleBy)</code>.</p>
<p>In a realistic program, convention dictates that if any method of <code>Point</code> has a pointer receiver, then <em>all</em> methods of <code>Point</code> should have a pointer receiver, even ones that don’t strictly need it.  We’ve broken this rule for <code>Point</code> so that we can show both kinds of method.</p>
<p>Named types (<code>Point</code>) and pointers to them <code>(*Point)</code> are the only types that may appear in a receiver declaration. Furthermore, to avoid ambiguities, method declarations are not permitted on named types that are themselves pointer types:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">P</span><span class="p">)</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// compile error: invalid receiver type
</span><span class="c1"></span></code></pre>
<p>The <code>(*Point).ScaleBy</code> method can be called by providing a <code>*Point</code> receiver, like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// &#34;{2, 4}&#34;
</span><span class="c1"></span></code></pre>
<p>or this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">pptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &#34;{2, 4}&#34;
</span><span class="c1"></span></code></pre>
<p>or this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">).</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &#34;{2, 4}&#34;
</span><span class="c1"></span></code></pre>
<p>But the last two cases are ungainly. Fortunately, the language helps us here. If the receiver <code>p</code> is a <em>variable</em> of type <code>Point</code> but the method requires a <code>*Point</code> receiver, we can use this shorthand:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>and the compiler will perform an implicit <code>&amp;p</code> on the variable. This works only for variables, including struct fields like <code>p.X</code> and array or slice elements like <code>perim[0]</code>. We cannot call a <code>*Point</code> method on a non-addressable <code>Point</code> receiver, because there’s no way to obtain the address of a temporary value.</p>
<pre class="code" ><code class="chroma" ><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// compile error: can&#39;t take address of Point literal
</span><span class="c1"></span></code></pre>
<p>But we <em>can</em> call a <code>Point</code> method like <code>Point.Distance</code> with a <code>*Point</code> receiver, because there is a way to obtain the value from the address: just load the value pointed to by the receiver. The compiler inserts an implicit <code>*</code> operation for us. These two function calls are equivalent:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="nx">pptr</span><span class="p">).</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</code></pre>
<p>Let’s summarize these three cases again, since they are a frequent point of confusion. In every valid method call expression, exactly one of these three statements is true.</p>
<p>Either the receiver argument has the same type as the receiver parameter, for example both have type <code>T</code> or both have type <code>*T</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">//  Point
</span><span class="c1"></span><span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">// *Point
</span><span class="c1"></span></code></pre>
<p>Or the receiver argument is a <em>variable</em> of type <code>T</code> and the receiver parameter has type <code>*T</code>. The compiler implicitly takes the address of the variable:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// implicit (&amp;p)
</span><span class="c1"></span></code></pre>
<p>Or the receiver argument has type <code>*T</code> and the receiver parameter has type <code>T</code>. The compiler implicitly dereferences the receiver, in other words, loads the value:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// implicit (*pptr)
</span><span class="c1"></span></code></pre>
<p>If all the methods of a named type <code>T</code> have a receiver type of <code>T</code> itself (not <code>*T</code>), it is safe to copy instances of that type; calling any of its methods necessarily makes a copy. For example, <code>time.Duration</code> values are liberally copied, including as arguments to functions. But if any method has a pointer receiver, you should avoid copying instances of <code>T</code> because doing so may violate internal invariants. For example, copying an instance of <code>bytes.Buffer</code> would cause the original and the copy to alias (<a href="#section-2.3.2" >§2.3.2</a>) the same underlying array of bytes. Subsequent method calls would have unpredictable effects.</p>
</div>
<h4 id="section-6.2.1" >Nil Is a Valid Receiver Value</h4>
<div class="hBody-4" >
<p>Just as some functions allow nil pointers as arguments, so do some methods for their receiver, especially if <code>nil</code> is a meaningful zero value of the type, as with maps and slices. In this simple linked list of integers, <code>nil</code> represents the empty list:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// An IntList is a linked list of integers.
</span><span class="c1">// A nil *IntList represents the empty list.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">IntList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Value</span> <span class="kt">int</span>
  <span class="nx">Tail</span> <span class="o">*</span><span class="nx">IntList</span>
<span class="p">}</span>

<span class="c1">// Sum returns the sum of the list elements.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">list</span> <span class="o">*</span><span class="nx">IntList</span><span class="p">)</span> <span class="nx">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">list</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Sum</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>When you define a type whose methods allow <code>nil</code> as a receiver value, it’s worth pointing this out explicitly in its documentation comment, as we did above.</p>
<p>Here’s part of the definition of the <code>Values</code> type from the <code>net/url</code> package:</p>
<div class="figure" >
<h1 class="figure"><code>net/url</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">url</span>

<span class="c1">// Values maps a string key to a list of values.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>

<span class="c1">// Get returns the first value associated with the given key,
</span><span class="c1">// or &#34;&#34; if there are none.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="c1">// Add adds the value to key.
</span><span class="c1">// It appends to any existing values associated with key.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>It exposes its representation as a map but also provides methods to simplify access to the map, whose values are slices of strings—it’s a <em>multimap</em>. Its clients can use its intrinsic operators (<code>make</code>, slice literals, <code>m[key]</code>, and so on), or its methods, or both, as they prefer:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch6/urlvalues/main.go" >gopl.io/ch6/urlvalues</a></h1>
<pre class="code" ><code class="chroma" ><span class="nx">m</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&#34;lang&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;en&#34;</span><span class="p">}}</span> <span class="c1">// direct construction
</span><span class="c1"></span><span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;lang&#34;</span><span class="p">))</span> <span class="c1">// &#34;en&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;q&#34;</span><span class="p">))</span>    <span class="c1">// &#34;&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">))</span> <span class="c1">// &#34;1&#34;      (first value)
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&#34;item&#34;</span><span class="p">])</span>     <span class="c1">// &#34;[1 2]&#34;  (direct map access)
</span><span class="c1"></span>
<span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">))</span> <span class="c1">// &#34;&#34;
</span><span class="c1"></span><span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">)</span>         <span class="c1">// panic: assignment to entry in nil map
</span><span class="c1"></span></code></pre>
</div>
<p>In the final call to <code>Get</code>, the <code>nil</code> receiver behaves like an empty map. We could equivalently have written it as <code>Values(nil).Get(&#34;item&#34;)</code>, but <code>nil.Get(&#34;item&#34;)</code> will not compile because the type of <code>nil</code> has not been determined. By contrast, the final call to <code>Add</code> panics as it tries to update a nil map.</p>
<p>Because <code>url.Values</code> is a map type and a map refers to its key/value pairs indirectly, any updates and deletions that <code>url.Values.Add</code> makes to the map elements are visible to the caller. However, as with ordinary functions, any changes a method makes to the reference itself, like setting it to <code>nil</code> or making it refer to a different map data structure, will not be reflected in the caller.</p>
</div>
<h3 id="section-6.3" >Composing Types by Struct Embedding</h3>
<div class="hBody-3" >
<p>Consider the type <code>ColoredPoint</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch6/coloredpoint/main.go" >gopl.io/ch6/coloredpoint</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;image/color&#34;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Point</span>
  <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</code></pre>
</div>
<p>We could have defined <code>ColoredPoint</code> as a struct of three fields, but instead we <em>embedded</em> a <code>Point</code> to provide the <code>X</code> and <code>Y</code> fields. As we saw in <a href="#section-4.4.3" >Section 4.4.3</a>, embedding lets us take a syntactic shortcut to defining a <code>ColoredPoint</code> that contains all the fields of <code>Point</code>, plus some more. If we want, we can select the fields of <code>ColoredPoint</code> that were contributed by the embedded <code>Point</code> without mentioning <code>Point</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">cp</span> <span class="nx">ColoredPoint</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span><span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>       <span class="c1">// &#34;2&#34;
</span><span class="c1"></span></code></pre>
<p>A similar mechanism applies to the <em>methods</em> of <code>Point</code>. We can call methods of the embedded <code>Point</code> field using a receiver of type <code>ColoredPoint</code>, even though <code>ColoredPoint</code> has no declared methods:</p>
<pre class="code" ><code class="chroma" ><span class="nx">red</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="nx">blue</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">q</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &#34;5&#34;
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &#34;10&#34;
</span><span class="c1"></span></code></pre>
<p>The methods of <code>Point</code> have been <em>promoted</em> to <code>ColoredPoint</code>. In this way, embedding allows complex types with many methods to be built up by the <em>composition</em> of several fields, each providing a few methods.</p>
<p>Readers familiar with class-based object-oriented languages may be tempted to view <code>Point</code> as a base class and <code>ColoredPoint</code> as a subclass or derived class, or to interpret the relationship between these types as if a <code>ColoredPoint</code> <q>is a</q> <code>Point</code>. But that would be a mistake. Notice the calls to <code>Distance</code> above. <code>Distance</code> has a parameter of type <code>Point</code>, and <code>q</code> is not a <code>Point</code>, so although <code>q</code> does have an embedded field of that type, we must explicitly select it. Attempting to pass <code>q</code> would be an error:</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// compile error: cannot use q (ColoredPoint) as Point
</span><span class="c1"></span></code></pre>
<p>A <code>ColoredPoint</code> is not a <code>Point</code>, but it <q>has a</q> <code>Point</code>, and it has two additional methods <code>Distance</code> and <code>ScaleBy</code> promoted from <code>Point</code>. If you prefer to think in terms of implementation, the embedded field instructs the compiler to generate additional wrapper methods that delegate to the declared methods, equivalent to these:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>When <code>Point.Distance</code> is called by the first of these wrapper methods, its receiver value is <code>p.Point</code>, not <code>p</code>, and there is no way for the method to access the <code>ColoredPoint</code> in which the <code>Point</code> is embedded.</p>
<p>The type of an anonymous field may be a <em>pointer</em> to a named type, in which case fields and methods are promoted indirectly from the pointed-to object. Adding another level of indirection lets us share common structures and vary the relationships between objects dynamically. The declaration of <code>ColoredPoint</code> below embeds a <code>*Point</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">Point</span>
  <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &#34;5&#34;
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span>                 <span class="c1">// p and q now share the same Point
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">,</span> <span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">)</span>   <span class="c1">// &#34;{2 2} {2 2}&#34;
</span><span class="c1"></span></code></pre>
<p>A struct type may have more than one anonymous field. Had we declared <code>ColoredPoint</code> as</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Point</span>
  <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</code></pre>
<p>then a value of this type would have all the methods of <code>Point</code>, all the methods of <code>RGBA</code>, and any additional methods declared on <code>ColoredPoint</code> directly. When the compiler resolves a selector such as <code>p.ScaleBy</code> to a method, it first looks for a directly declared method named <code>ScaleBy</code>, then for methods promoted once from <code>ColoredPoint</code>’s embedded fields, then for methods promoted twice from embedded fields within <code>Point</code> and <code>RGBA</code>, and so on. The compiler reports an error if the selector was ambiguous because two methods were promoted from the same rank.</p>
<p>Methods can be declared only on named types (like <code>Point</code>) and pointers to them (<code>*Point</code>), but thanks to embedding, it’s possible and sometimes useful for <em>unnamed</em> struct types to have methods too.</p>
<p>Here’s a nice trick to illustrate. This example shows part of a simple cache implemented using two package-level variables, a mutex (<a href="#section-9.2" >§9.2</a>) and the map that it guards:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards mapping
</span><span class="c1"></span>  <span class="nx">mapping</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>The version below is functionally equivalent but groups together the two related variables in a single package-level variable, <code>cache</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">cache</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
  <span class="nx">mapping</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span> <span class="p">{</span>
  <span class="nx">mapping</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">cache</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">cache</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</code></pre>
<p>The new variable gives more expressive names to the variables related to the cache, and because the <code>sync.Mutex</code> field is embedded within it, its <code>Lock</code> and <code>Unlock</code> methods are promoted to the unnamed struct type, allowing us to lock the <code>cache</code> with a self-explanatory syntax.</p>
</div>
<h3 id="section-6.4" >Method Values and Expressions</h3>
<div class="hBody-3" >
<p>Usually we select and call a method in the same expression, as in <code>p.Distance()</code>, but it’s possible to separate these two operations. The selector <code>p.Distance</code> yields a <em>method value</em>, a function that binds a method (<code>Point.Distance</code>) to a specific receiver value <code>p</code>. This function can then be invoked without a receiver value; it needs only the non-receiver arguments.</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

<span class="nx">distanceFromP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span>        <span class="c1">// method value
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>      <span class="c1">// &#34;5&#34;
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">origin</span> <span class="nx">Point</span>                   <span class="c1">// {0, 0}
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">origin</span><span class="p">))</span> <span class="c1">// &#34;2.23606797749979&#34;, √5
</span><span class="c1"></span>
<span class="nx">scaleP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span> <span class="c1">// method value
</span><span class="c1"></span><span class="nx">scaleP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>           <span class="c1">// p becomes (2, 4)
</span><span class="c1"></span><span class="nx">scaleP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>           <span class="c1">//      then (6, 12)
</span><span class="c1"></span><span class="nx">scaleP</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>          <span class="c1">//      then (60, 120)
</span><span class="c1"></span></code></pre>
<p>Method values are useful when a package’s API calls for a function value, and the client’s desired behavior for that function is to call a method on a specific receiver. For example, the function <code>time.AfterFunc</code> calls a function value after a specified delay. This program uses it to launch the rocket <code>r</code> after 10 seconds:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Rocket</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Rocket</span><span class="p">)</span> <span class="nx">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Rocket</span><span class="p">)</span>
<span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">()</span> <span class="p">})</span>
</code></pre>
<p>The method value syntax is shorter:</p>
<pre class="code" ><code class="chroma" ><span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">)</span>
</code></pre>
<p>Related to the method value is the <em>method expression</em>. When calling a method, as opposed to an ordinary function, we must supply the receiver in a special way using the selector syntax. A method expression, written <code>T.f</code> or <code>(*T).f</code> where <code>T</code> is a type, yields a function value with a regular first parameter taking the place of the receiver, so it can be called in the usual way.</p>
<pre class="code" ><code class="chroma" ><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

<span class="nx">distance</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span>   <span class="c1">// method expression
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span>  <span class="c1">// &#34;5&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">distance</span><span class="p">)</span> <span class="c1">// &#34;func(Point, Point) float64&#34;
</span><span class="c1"></span>
<span class="nx">scale</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nx">ScaleBy</span>
<span class="nx">scale</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>            <span class="c1">// &#34;{2 4}&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">scale</span><span class="p">)</span> <span class="c1">// &#34;func(*Point, float64)&#34;
</span><span class="c1"></span></code></pre>
<p>Method expressions can be helpful when you need a value to represent a choice among several methods belonging to the same type so that you can call the chosen method with many different receivers. In the following example, the variable <code>op</code> represents either the addition or the subtraction method of type <code>Point</code>, and <code>Path.TranslateBy</code> calls it for each point in the <code>Path</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Sub</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">TranslateBy</span><span class="p">(</span><span class="nx">offset</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">op</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span>
  <span class="k">if</span> <span class="nx">add</span> <span class="p">{</span>
    <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Add</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Sub</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
    <span class="c1">// Call either path[i].Add(offset) or path[i].Sub(offset).
</span><span class="c1"></span>    <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">offset</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<h3 id="section-6.5" >Example: Bit Vector Type</h3>
<div class="hBody-3" >
<p>Sets in Go are usually implemented as a <code>map[T]bool</code>, where <code>T</code> is the element type. A set represented by a map is very flexible but, for certain problems, a specialized representation may outperform it. For example, in domains such as dataflow analysis where set elements are small non-negative integers, sets have many elements, and set operations like union and intersection are common, a <em>bit vector</em> is ideal.</p>
<p>A bit vector uses a slice of unsigned integer values or <q>words,</q> each bit of which represents a possible element of the set. The set contains <span class="math" >i</span> if the <span class="math" >i</span>-th bit is set. The following program demonstrates a simple bit vector type with three methods:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch6/intset/intset.go" >gopl.io/ch6/intset</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// An IntSet is a set of small non-negative integers.
</span><span class="c1">// Its zero value represents the empty set.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">// Has reports whether the set contains the non-negative value x.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Has</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">word</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">bit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Add adds the non-negative value x to the set.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">word</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bit</span>
<span class="p">}</span>

<span class="c1">// UnionWith sets s to the union of s and t.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">UnionWith</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tword</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">tword</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="nx">tword</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Since each word has 64 bits, to locate the bit for <code>x</code>, we use the quotient <code>x/64</code> as the word index and the remainder <code>x%64</code> as the bit index within that word. The <code>UnionWith</code> operation uses the bitwise OR operator <code>|</code> to compute the union 64 elements at a time. (We’ll revisit the choice of 64-bit words in Exercise 6.5.)</p>
<p>This implementation lacks many desirable features, some of which are posed as exercises below, but one is hard to live without: a way to print an <code>IntSet</code> as a string. Let’s give it a <code>String</code> method as we did with <code>Celsius</code> in <a href="#section-2.5" >Section 2.5</a>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// String returns the set as a string of the form &#34;{1 2 3}&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;{&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">word</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">word</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s">&#34;{&#34;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;}&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Notice the similarity of the <code>String</code> method above with <code>intsToString</code> in <a href="#section-3.5.4" >Section 3.5.4</a>; <code>bytes.Buffer</code> is often used this way in <code>String</code> methods. The <code>fmt</code> package treats types with a <code>String</code> method specially so that values of complicated types can display themselves in a userfriendly manner. Instead of printing the raw representation of the value (a struct in this case), <code>fmt</code> calls the <code>String</code> method. The mechanism relies on interfaces and type assertions, which we’ll explain in <a href="#chapter-7" >Chapter 7</a>.</p>
<p>We can now demonstrate <code>IntSet</code> in action:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">IntSet</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">144</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;{1 9 144}&#34;
</span><span class="c1"></span>
<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;{9 42}&#34;
</span><span class="c1"></span>
<span class="nx">x</span><span class="p">.</span><span class="nx">UnionWith</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;{1 9 42 144}&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span> <span class="c1">// &#34;true false&#34;
</span><span class="c1"></span></code></pre>
<p>A word of caution: we declared <code>String</code> and <code>Has</code> as methods of the pointer type <code>*IntSet</code> not out of necessity, but for consistency with the other two methods, which need a pointer receiver because they assign to <code>s.words</code>. Consequently, an <code>IntSet</code> <em>value</em> does not have a <code>String</code> method, occasionally leading to surprises like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>         <span class="c1">// &#34;{1 9 42 144}&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;{1 9 42 144}&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>          <span class="c1">// &#34;{[4398046511618 0 65536]}&#34;
</span><span class="c1"></span></code></pre>
<p>In the first case, we print an <code>*IntSet</code> pointer, which does have a <code>String</code> method. In the second case, we call <code>String()</code> on an <code>IntSet</code> variable; the compiler inserts the implicit <code>&amp;</code> operation, giving us a pointer, which has the <code>String</code> method. But in the third case, because the <code>IntSet</code> value does not have a <code>String</code> method, <code>fmt.Println</code> prints the representation of the struct instead. It’s important not to forget the <code>&amp;</code> operator. Making <code>String</code> a method of <code>IntSet</code>, not <code>*IntSet</code>, might be a good idea, but this is a case-by-case judgment.</p>
<p><b>Exercise 6.1</b>: Implement these additional methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>      <span class="c1">// return the number of elements
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Remove</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">// remove x from the set
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Clear</span><span class="p">()</span>        <span class="c1">// remove all elements from the set
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Copy</span><span class="p">()</span> <span class="o">*</span><span class="nx">IntSet</span> <span class="c1">// return a copy of the set
</span><span class="c1"></span></code></pre>
<p><b>Exercise 6.2</b>: Define a variadic <code>(*IntSet).AddAll(...int)</code> method that allows a list of values to be added, such as <code>s.AddAll(1, 2, 3)</code>.</p>
<p><b>Exercise 6.3</b>: <code>(*IntSet).UnionWith</code> computes the union of two sets using <code>|</code>, the word-parallel bitwise OR operator. Implement methods for <code>IntersectWith</code>, <code>DifferenceWith</code>, and <code>SymmetricDifference</code> for the corresponding set operations. (The symmetric difference of two sets contains the elements present in one set or the other but not both.)</p>
<p><b>Exercise 6.4</b>: Add a method <code>Elems</code> that returns a slice containing the elements of the set, suitable for iterating over with a <code>range</code> loop.</p>
<p><b>Exercise 6.5</b>: The type of each word used by <code>IntSet</code> is <code>uint64</code>, but 64-bit arithmetic may be inefficient on a 32-bit platform. Modify the program to use the <code>uint</code> type, which is the most efficient unsigned integer type for the platform. Instead of dividing by 64, define a constant holding the effective size of <code>uint</code> in bits, 32 or 64. You can use the perhaps too-clever expression <code>32 &lt;&lt; (^uint(0) &gt;&gt; 63)</code> for this purpose.</p>
</div>
<h3 id="section-6.6" >Encapsulation</h3>
<div class="hBody-3" >
<p>A variable or method of an object is said to be <em>encapsulated</em> if it is inaccessible to clients of the object. Encapsulation, sometimes called <em>information hiding</em>, is a key aspect of object-oriented programming.</p>
<p>Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncapitalized names are not. The same mechanism that limits access to members of a package also limits access to the fields of a struct or the methods of a type. As a consequence, to encapsulate an object, we must make it a struct.</p>
<p>That’s the reason the <code>IntSet</code> type from the previous section was declared as a struct type even though it has only a single field:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</code></pre>
<p>We could instead define <code>IntSet</code> as a slice type as follows, though of course we’d have to replace each occurrence of <code>s.words</code> by <code>*s</code> in its methods:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</code></pre>
<p>Although this version of <code>IntSet</code> would be essentially equivalent, it would allow clients from other packages to read and modify the slice directly. Put another way, whereas the expression <code>*s</code> could be used in any package, <code>s.words</code> may appear only in the package that defines <code>IntSet</code>.</p>
<p>Another consequence of this name-based mechanism is that the unit of encapsulation is the package, not the type as in many other languages. The fields of a struct type are visible to all code within the same package. Whether the code appears in a function or a method makes no difference.</p>
<p>Encapsulation provides three benefits. First, because clients cannot directly modify the object’s variables, one need inspect fewer statements to understand the possible values of those variables.</p>
<p>Second, hiding implementation details prevents clients from depending on things that might change, which gives the designer greater freedom to evolve the implementation without breaking API compatibility.</p>
<p>As an example, consider the <code>bytes.Buffer</code> type. It is frequently used to accumulate very short strings, so it is a profitable optimization to reserve a little extra space in the object to avoid memory allocation in this common case. Since <code>Buffer</code> is a struct type, this space takes the form of an extra field of type <code>[64]byte</code> with an uncapitalized name. When this field was added, because it was not exported, clients of <code>Buffer</code> outside the <code>bytes</code> package were unaware of any change except improved performance. <code>Buffer</code> and its <code>Grow</code> method are shown below, simplified for clarity :</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Buffer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">buf</span>     <span class="p">[]</span><span class="kt">byte</span>
  <span class="nx">initial</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
  <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="c1">// Grow expands the buffer&#39;s capacity, if necessary,
</span><span class="c1">// to guarantee space for another n bytes. [...]
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nx">Grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">initial</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// use preallocated space initially
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Len</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The third benefit of encapsulation, and in many cases the most important, is that it prevents clients from setting an object’s variables arbitrarily. Because the object’s variables can be set only by functions in the same package, the author of that package can ensure that all those functions maintain the object’s internal invariants. For example, the <code>Counter</code> type below permits clients to increment the counter or to reset it to zero, but not to set it to some arbitrary value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">n</span> <span class="kt">int</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">N</span><span class="p">()</span> <span class="kt">int</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Increment</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Reset</span><span class="p">()</span>     <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre>
<p>Functions that merely access or modify internal values of a type, such as the methods of the <code>Logger</code> type from <code>log</code> package, below, are called <em>getters</em> and <em>setters</em>. However, when naming a getter method, we usually omit the <code>Get</code> prefix. This preference for brevity extends to all methods, not just field accessors, and to other redundant prefixes as well, such as <code>Fetch</code>, <code>Find</code>, and <code>Lookup</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">log</span>

<span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">flags</span>  <span class="kt">int</span>
  <span class="nx">prefix</span> <span class="kt">string</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetFlags</span><span class="p">(</span><span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span>
</code></pre>
<p>Go style does not forbid exported fields. Of course, once exported, a field cannot be unexported without an incompatible change to the API, so the initial choice should be deliberate and should consider the complexity of the invariants that must be maintained, the likelihood of future changes, and the quantity of client code that would be affected by a change.</p>
<p>Encapsulation is not always desirable. By revealing its representation as an <code>int64</code> number of nanoseconds, <code>time.Duration</code> lets us use all the usual arithmetic and comparison operations with durations, and even to define constants of this type:</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">day</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">day</span><span class="p">.</span><span class="nx">Seconds</span><span class="p">())</span> <span class="c1">// &#34;86400&#34;
</span><span class="c1"></span></code></pre>
<p>As another example, contrast <code>IntSet</code> with the <code>geometry.Path</code> type from the beginning of this chapter. <code>Path</code> was defined as a slice type, allowing its clients to construct instances using the slice literal syntax, to iterate over its points using a range loop, and so on, whereas these operations are denied to clients of <code>IntSet</code>.</p>
<p>Here’s the crucial difference: <code>geometry.Path</code> is intrinsically a sequence of points, no more and no less, and we don’t foresee adding new fields to it, so it makes sense for the <code>geometry</code> package to reveal that <code>Path</code> is a slice. In contrast, an <code>IntSet</code> merely happens to be represented as a <code>[]uint64</code> slice. It could have been represented using <code>[]uint</code>, or something completely different for sets that are sparse or very small, and it might perhaps benefit from additional features like an extra field to record the number of elements in the set. For these reasons, it makes sense for <code>IntSet</code> to be opaque.</p>
<p>In this chapter, we learned how to associate methods with named types, and how to call those methods. Although methods are crucial to object-oriented programming, they’re only half the picture. To complete it, we need <em>interfaces</em>, the subject of the next chapter.</p>
</div>
<h2 id="chapter-7" >Interfaces</h2>
<div class="hBody-2" >
<p>Interface types express generalizations or abstractions about the behaviors of other types. By generalizing, interfaces let us write functions that are more flexible and adaptable because they are not tied to the details of one particular implementation.</p>
<p>Many object-oriented languages have some notion of interfaces, but what makes Go’s interfaces so distinctive is that they are <em>satisfied implicitly</em>. In other words, there’s no need to declare all the interfaces that a given concrete type satisfies; simply possessing the necessary methods is enough. This design lets you create new interfaces that are satisfied by existing concrete types without changing the existing types, which is particularly useful for types defined in packages that you don’t control.</p>
<p>In this chapter, we’ll start by looking at the basic mechanics of interface types and their values.  Along the way, we’ll study several important interfaces from the standard library. Many Go programs make as much use of standard interfaces as they do of their own ones. Finally, we’ll look at <em>type assertions</em> (<a href="#section-7.10" >§7.10</a>) and <em>type switches</em> (<a href="#section-7.13" >§7.13</a>) and see how they enable a different kind of generality.</p>
</div>
<h3 id="section-7.1" >Interfaces as Contracts</h3>
<div class="hBody-3" >
<p>All the types we’ve looked at so far have been <em>concrete types</em>. A concrete type specifies the exact representation of its values and exposes the intrinsic operations of that representation, such as arithmetic for numbers, or indexing, <code>append</code>, and <code>range</code> for slices. A concrete type may also provide additional behaviors through its methods. When you have a value of a concrete type, you know exactly what it <em>is</em> and what you can <em>do</em> with it.</p>
<p>There is another kind of type in Go called an <em>interface type</em>. An interface is an <em>abstract type</em>. It doesn’t expose the representation or internal structure of its values, or the set of basic operations they support; it reveals only some of their methods. When you have a value of an interface type, you know nothing about what it <em>is</em>; you know only what it can <em>do</em>, or more precisely, what behaviors are provided by its methods.</p>
<p>Throughout the book, we’ve been using two similar functions for string formatting: <code>fmt.Printf</code>, which writes the result to the standard output (a file), and <code>fmt.Sprintf</code>, which returns the result as a <code>string</code>. It would be unfortunate if the hard part, formatting the result, had to be duplicated because of these superficial differences in how the result is used. Thanks to interfaces, it does not. Both of these functions are, in effect, wrappers around a third function, <code>fmt.Fprintf</code>, that is agnostic about what happens to the result it computes:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The <code>F</code> prefix of <code>Fprintf</code> stands for <em>file</em> and indicates that the formatted output should be written to the file provided as the first argument. In the <code>Printf</code> case, the argument, <code>os.Stdout</code>, is an <code>*os.File</code>. In the <code>Sprintf</code> case, however, the argument is not a file, though it superficially resembles one: <code>&amp;buf</code> is a pointer to a memory buffer to which bytes can be written.</p>
<p>The first parameter of <code>Fprintf</code> is not a file either. It’s an <code>io.Writer</code>, which is an interface type with the following declaration:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">io</span>

<span class="c1">// Writer is the interface that wraps the basic Write method.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// Write writes len(p) bytes from p to the underlying data stream.
</span><span class="c1"></span>  <span class="c1">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
</span><span class="c1"></span>  <span class="c1">// and any error encountered that caused the write to stop early.
</span><span class="c1"></span>  <span class="c1">// Write must return a non-nil error if it returns n &lt; len(p).
</span><span class="c1"></span>  <span class="c1">// Write must not modify the slice data, even temporarily.
</span><span class="c1"></span>  <span class="c1">//
</span><span class="c1"></span>  <span class="c1">// Implementations must not retain p.
</span><span class="c1"></span>  <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>io.Writer</code> interface defines the contract between <code>Fprintf</code> and its callers. On the one hand, the contract requires that the caller provide a value of a concrete type like <code>*os.File</code> or <code>*bytes.Buffer</code> that has a method called <code>Write</code> with the appropriate signature and behavior.  On the other hand, the contract guarantees that <code>Fprintf</code> will do its job given any value that satisfies the <code>io.Writer</code> interface. <code>Fprintf</code> may not assume that it is writing to a file or to memory, only that it can call <code>Write</code>.</p>
<p>Because <code>fmt.Fprintf</code> assumes nothing about the representation of the value and relies only on the behaviors guaranteed by the <code>io.Writer</code> contract, we can safely pass a value of any concrete type that satisfies <code>io.Writer</code> as the first argument to <code>fmt.Fprintf</code>. This freedom to substitute one type for another that satisfies the same interface is called <em>substitutability</em>, and is a hallmark of object-oriented programming.</p>
<p>Let’s test this out using a new type. The <code>Write</code> method of the <code>*ByteCounter</code> type below merely counts the bytes written to it before discarding them. (The conversion is required to make the types of <code>len(p)</code> and <code>*c</code> match in the <code>+=</code> assignment statement.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/bytecounter/main.go" >gopl.io/ch7/bytecounter</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ByteCounter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ByteCounter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">c</span> <span class="o">+=</span> <span class="nx">ByteCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="c1">// convert int to ByteCounter
</span><span class="c1"></span>  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Since <code>*ByteCounter</code> satisfies the <code>io.Writer</code> contract, we can pass it to <code>Fprintf</code>, which does its string formatting oblivious to this change; the <code>ByteCounter</code> correctly accumulates the length of the result.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">c</span> <span class="nx">ByteCounter</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &#34;5&#34;, = len(&#34;hello&#34;)
</span><span class="c1"></span>
<span class="nx">c</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset the counter
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;Dolly&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;hello, %s&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &#34;12&#34;, = len(&#34;hello, Dolly&#34;)
</span><span class="c1"></span></code></pre>
<p>Besides <code>io.Writer</code>, there is another interface of great importance to the <code>fmt</code> package. <code>Fprintf</code> and <code>Fprintln</code> provide a way for types to control how their values are printed. In <a href="#section-2.5" >Section 2.5</a>, we defined a <code>String</code> method for the <code>Celsius</code> type so that temperatures would print as <code>&#34;100°C&#34;</code>, and in <a href="#section-6.5" >Section 6.5</a> we equipped <code>*IntSet</code> with a <code>String</code> method so that sets would be rendered using traditional set notation like <code>&#34;{1 2 3}&#34;</code>. Declaring a <code>String</code> method makes a type satisfy one of the most widely used interfaces of all, <code>fmt.Stringer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// The String method is used to print values passed
</span><span class="c1">// as an operand to any format that accepts a string
</span><span class="c1">// or to an unformatted printer such as Print.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>We’ll explain how the <code>fmt</code> package discovers which values satisfy this interface in <a href="#section-7.10" >Section 7.10</a>.</p>
<p><b>Exercise 7.1</b>: Using the ideas from <code>ByteCounter</code>, implement counters for words and for lines.  You will find <code>bufio.ScanWords</code> useful.</p>
<p><b>Exercise 7.2</b>: Write a function <code>CountingWriter</code> with the signature below that, given an <code>io.Writer</code>, returns a new <code>Writer</code> that wraps the original, and a pointer to an <code>int64</code> variable that at any moment contains the number of bytes written to the new <code>Writer</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">CountingWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span>
</code></pre>
<p><b>Exercise 7.3</b>: Write a <code>String</code> method for the <code>*tree</code> type in <code>gopl.io/ch4/treesort</code> (<a href="#section-4.4" >§4.4</a>) that reveals the sequence of values in the tree.</p>
</div>
<h3 id="section-7.2" >Interface Types</h3>
<div class="hBody-3" >
<p>An interface type specifies a set of methods that a concrete type must possess to be considered an instance of that interface.</p>
<p>The <code>io.Writer</code> type is one of the most widely used interfaces because it provides an abstraction of all the types to which bytes can be written, which includes files, memory buffers, network connections, HTTP clients, archivers, hashers, and so on. The <code>io</code> package defines many other useful interfaces. A <code>Reader</code> represents any type from which you can read bytes, and a <code>Closer</code> is any value that you can close, such as a file or a network connection. (By now you’ve probably noticed the naming convention for many of Go’s single-method interfaces.)</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">io</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>Looking farther, we find declarations of new interface types as combinations of existing ones.  Here are two examples:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Reader</span>
  <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Reader</span>
  <span class="nx">Writer</span>
  <span class="nx">Closer</span>
<span class="p">}</span>
</code></pre>
<p>The syntax used above, which resembles struct embedding, lets us name another interface as a shorthand for writing out all of its methods. This is called <em>embedding</em> an interface. We could have written <code>io.ReadWriter</code> without embedding, albeit less succinctly, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>or even using a mixture of the two styles:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">Writer</span>
<span class="p">}</span>
</code></pre>
<p>All three declarations have the same effect. The order in which the methods appear is immaterial. All that matters is the set of methods.</p>
<p><b>Exercise 7.4</b>: The <code>strings.NewReader</code> function returns a value that satisfies the <code>io.Reader</code> interface (and others) by reading from its argument, a string. Implement a simple version of <code>NewReader</code> yourself, and use it to make the HTML parser (<a href="#section-5.2" >§5.2</a>) take input from a string.</p>
<p><b>Exercise 7.5</b>: The <code>LimitReader</code> function in the <code>io</code> package accepts an <code>io.Reader</code> <code>r</code> and a number of bytes <code>n</code>, and returns another <code>Reader</code> that reads from <code>r</code> but reports an end-of-file condition after <code>n</code> bytes. Implement it.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">LimitReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
</code></pre>
</div>
<h3 id="section-7.3" >Interface Satisfaction</h3>
<div class="hBody-3" >
<p>A type <em>satisfies</em> an interface if it possesses all the methods the interface requires. For example, an <code>*os.File</code> satisfies <code>io.Reader</code>, <code>Writer</code>, <code>Closer</code>, and <code>ReadWriter</code>. A <code> *bytes.Buffer</code> satisfies <code>Reader</code>, <code>Writer</code>, and <code>ReadWriter</code>, but does not satisfy <code>Closer</code> because it does not have a <code>Close</code> method. As a shorthand, Go programmers often say that a concrete type <q>is a</q> particular interface type, meaning that it satisfies the interface. For example, a <code>*bytes.Buffer</code> is an <code>io.Writer</code>; an <code>*os.File</code> is an <code>io.ReadWriter</code>.</p>
<p>The assignability rule (<a href="#section-2.4.2" >§2.4.2</a>) for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface. So:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>           <span class="c1">// OK: *os.File has Write method
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>   <span class="c1">// OK: *bytes.Buffer has Write method
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>         <span class="c1">// compile error: time.Duration lacks Write method
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">rwc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriteCloser</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>         <span class="c1">// OK: *os.File has Read, Write, Close methods
</span><span class="c1"></span><span class="nx">rwc</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// compile error: *bytes.Buffer lacks Close method
</span><span class="c1"></span></code></pre>
<p>This rule applies even when the right-hand side is itself an interface:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="nx">rwc</span>                 <span class="c1">// OK: io.ReadWriteCloser has Write method
</span><span class="c1"></span><span class="nx">rwc</span> <span class="p">=</span> <span class="nx">w</span>                 <span class="c1">// compile error: io.Writer lacks Close method
</span><span class="c1"></span></code></pre>
<p>Because <code>ReadWriter</code> and <code>ReadWriteCloser</code> include all the methods of <code>Writer</code>, any type that satisfies <code>ReadWriter</code> or <code>ReadWriteCloser</code> necessarily satisfies <code>Writer</code>.</p>
<p>Before we go further, we should explain one subtlety in what it means for a type to have a method. Recall from <a href="#section-6.2" >Section 6.2</a> that for each named concrete type <code>T</code>, some of its methods have a receiver of type <code>T</code> itself whereas others require a <code>*T</code> pointer. Recall also that it is legal to call a <code>*T</code> method on an argument of type <code>T</code> so long as the argument is a <em>variable</em>; the compiler implicitly takes its address. But this is mere syntactic sugar: a value of type <code>T</code> does not possess all the methods that a <code>*T</code> pointer does, and as a result it might satisfy fewer interfaces.</p>
<p>An example will make this clear. The <code>String</code> method of the <code>IntSet</code> type from <a href="#section-6.5" >Section 6.5</a> requires a pointer receiver, so we cannot call that method on a non-addressable <code>IntSet</code> value:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">IntSet</span><span class="p">{}.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// compile error: String requires *IntSet receiver
</span><span class="c1"></span></code></pre>
<p>but we can call it on an <code>IntSet</code> variable:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">s</span> <span class="nx">IntSet</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// OK: s is a variable and &amp;s has a String method
</span><span class="c1"></span></code></pre>
<p>However, since only <code>*IntSet</code> has a <code>String</code> method, only <code>*IntSet</code> satisfies the <code>fmt.Stringer</code> interface:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span> <span class="c1">// OK
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="nx">s</span>  <span class="c1">// compile error: IntSet lacks String method
</span><span class="c1"></span></code></pre>
<p><a href="#section-12.8" >Section 12.8</a> includes a program that prints the methods of an arbitrary value, and the <code class="command" >godoc -analysis=type</code> tool (<a href="#section-10.7.4" >§10.7.4</a>) displays the methods of each type and the relationship between interfaces and concrete types.</p>
<p>Like an envelope that wraps and conceals the letter it holds, an interface wraps and conceals the concrete type and value that it holds. Only the methods revealed by the interface type may be called, even if the concrete type has others:</p>
<pre class="code" ><code class="chroma" ><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// OK: *os.File has Write method
</span><span class="c1"></span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// OK: *os.File has Close method
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// OK: io.Writer has Write method
</span><span class="c1"></span><span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// compile error: io.Writer lacks Close method
</span><span class="c1"></span></code></pre>
<p>An interface with more methods, such as <code>io.ReadWriter</code>, tells us more about the values it contains, and places greater demands on the types that implement it, than does an interface with fewer methods such as <code>io.Reader</code>. So what does the type <code>interface{}</code>, which has no methods at all, tell us about the concrete types that satisfy it?</p>
<p>That’s right: nothing. This may seem useless, but in fact the type <code>interface{}</code>, which is called the <em>empty interface</em> type, is indispensable. Because the empty interface type places no demands on the types that satisfy it, we can assign <em>any</em> value to the empty interface.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">any</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">any</span> <span class="p">=</span> <span class="mf">12.34</span>
<span class="nx">any</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;one&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</code></pre>
<p>Although it wasn’t obvious, we’ve been using the empty interface type since the very first example in this book, because it is what allows functions like <code>fmt.Println</code>, or <code>errorf</code> in <a href="#section-5.7" >Section 5.7</a>, to accept arguments of any type.</p>
<p>Of course, having created an <code>interface{}</code> value containing a boolean, float, string, map, pointer, or any other type, we can do nothing directly to the value it holds since the interface has no methods. We need a way to get the value back out again. We’ll see how to do that using a <em>type assertion</em> in <a href="#section-7.10" >Section 7.10</a>.</p>
<p>Since interface satisfaction depends only on the methods of the two types involved, there is no need to declare the relationship between a concrete type and the interfaces it satisfies. That said, it is occasionally useful to document and assert the relationship when it is intended but not otherwise enforced by the program. The declaration below asserts at compile time that a value of type <code>*bytes.Buffer</code> satisfies <code>io.Writer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// *bytes.Buffer must satisfy io.Writer
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</code></pre>
<p>We needn’t allocate a new variable since any value of type <code>*bytes.Buffer</code> will do, even <code>nil</code>, which we write as <code>(*bytes.Buffer)(nil)</code> using an explicit conversion. And since we never intend to refer to <code>w</code>, we can replace it with the blank identifier. Together, these changes give us this more frugal variant:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// *bytes.Buffer must satisfy io.Writer
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</code></pre>
<p>Non-empty interface types such as <code>io.Writer</code> are most often satisfied by a pointer type, particularly when one or more of the interface methods implies some kind of mutation to the receiver, as the <code>Write</code> method does. A pointer to a struct is an especially common methodbearing type.</p>
<p>But pointer types are by no means the only types that satisfy interfaces, and even interfaces with mutator methods may be satisfied by one of Go’s other reference types. We’ve seen examples of slice types with methods (<code>geometry.Path</code>, <a href="#section-6.1" >§6.1</a>) and map types with methods (<code>url.Values</code>, <a href="#section-6.2.1" >§6.2.1</a>), and later we’ll see a function type with methods (<code>http.HandlerFunc</code>, <a href="#section-7.7" >§7.7</a>). Even basic types may satisfy interfaces; as we well see in <a href="#section-7.4" >Section 7.4</a>, <code>time.Duration</code> satisfies <code>fmt.Stringer</code>.</p>
<p>A concrete type may satisfy many unrelated interfaces. Consider a program that organizes or sells digitized cultural artifacts like music, films, and books. It might define the following set of concrete types:</p>
<div class="pre-block" >
<pre class="pre" >Album
Book
Movie
Magazine
Podcast
TVEpisode
Track
</pre>
</div>
<p>We can express each abstraction of interest as an interface. Some properties are common to all artifacts, such as a title, a creation date, and a list of creators (authors or artists).</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Artifact</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Title</span><span class="p">()</span> <span class="kt">string</span>
  <span class="nx">Creators</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">Created</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre>
<p>Other properties are restricted to certain types of artifacts. Properties of the printed word are relevant only to books and magazines, whereas only movies and TV episodes have a screen resolution.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Text</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Pages</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">Words</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">PageSize</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Audio</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &#34;MP3&#34;, &#34;WAV&#34;
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Video</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &#34;MP4&#34;, &#34;WMV&#34;
</span><span class="c1"></span>  <span class="nx">Resolution</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>These interfaces are but one useful way to group related concrete types together and express the facets they share in common. We may discover other groupings later. For example, if we find we need to handle <code>Audio</code> and <code>Video</code> items in the same way, we can define a <code>Streamer</code> interface to represent their common aspects without changing any existing type declarations.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Streamer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>Each grouping of concrete types based on their shared behaviors can be expressed as an interface type. Unlike class-based languages, in which the set of interfaces satisfied by a class is explicit, in Go we can define new abstractions or groupings of interest when we need them, without modifying the declaration of the concrete type. This is particularly useful when the concrete type comes from a package written by a different author. Of course, there do need to be underlying commonalities in the concrete types.</p>
</div>
<h3 id="section-7.4" >Parsing Flags with <code>flag.Value</code></h3>
<div class="hBody-3" >
<p>In this section, we’ll see how another standard interface, <code>flag.Value</code>, helps us define new notations for command-line flags. Consider the program below, which sleeps for a specified period of time.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/sleep/sleep.go" >gopl.io/ch7/sleep</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">period</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="s">&#34;period&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="s">&#34;sleep period&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Sleeping for %v...&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">period</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="o">*</span><span class="nx">period</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Before it goes to sleep it prints the time period. The <code>fmt</code> package calls the <code>time.Duration</code>’s <code>String</code> method to print the period not as a number of nanoseconds, but in a user-friendly notation:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch7/sleep
</span><span class="in" ><span class="prompt" >&gt; </span>./sleep
</span><span class="out" >Sleeping for 1s...
</span></code></pre>
<p>By default, the sleep period is one second, but it can be controlled through the <code>-period</code> command-line flag. The <code>flag.Duration</code> function creates a flag variable of type <code>time.Duration</code> and allows the user to specify the duration in a variety of user-friendly formats, including the same notation printed by the <code>String</code> method. This symmetry of design leads to a nice user interface.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./sleep -period 50ms
</span><span class="out" >Sleeping for 50ms...
</span><span class="in" ><span class="prompt" >&gt; </span>./sleep -period 2m30s
</span><span class="out" >Sleeping for 2m30s...
</span><span class="in" ><span class="prompt" >&gt; </span>./sleep -period <span class="m">1</span>.5h
</span><span class="out" >Sleeping for 1h30m0s...
</span><span class="in" ><span class="prompt" >&gt; </span>./sleep -period <span class="s2">&#34;1 day&#34;</span>
</span><span class="out" >invalid value &#34;1 day&#34; for flag -period: time: invalid duration 1 day
</span></code></pre>
<p>Because duration-valued flags are so useful, this feature is built into the <code>flag</code> package, but it’s easy to define new flag notations for our own data types. We need only define a type that satisfies the <code>flag.Value</code> interface, whose declaration is below:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">flag</span>

<span class="c1">// Value is the interface to the value stored in a flag.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>The <code>String</code> method formats the flag’s value for use in command-line help messages; thus every <code>flag.Value</code> is also a <code>fmt.Stringer</code>. The <code>Set</code> method parses its string argument and updates the flag value. In effect, the <code>Set</code> method is the inverse of the <code>String</code> method, and it is good practice for them to use the same notation.</p>
<p>Let’s define a <code>celsiusFlag</code> type that allows a temperature to be specified in Celsius, or in Fahrenheit with an appropriate conversion. Notice that <code>celsiusFlag</code> embeds a <code>Celsius</code> (<a href="#section-2.5" >§2.5</a>), thereby getting a <code>String</code> method for free. To satisfy <code>flag.Value</code>, we need only declare the <code>Set</code> method:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/tempconv/tempconv.go" >gopl.io/ch7/tempconv</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// *celsiusFlag satisfies the flag.Value interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">celsiusFlag</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Celsius</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">celsiusFlag</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">unit</span> <span class="kt">string</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="kt">float64</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sscanf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%f%s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">unit</span><span class="p">)</span> <span class="c1">// no error check needed
</span><span class="c1"></span>  <span class="k">switch</span> <span class="nx">unit</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&#34;C&#34;</span><span class="p">,</span> <span class="s">&#34;°C&#34;</span><span class="p">:</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="s">&#34;F&#34;</span><span class="p">,</span> <span class="s">&#34;°F&#34;</span><span class="p">:</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;invalid temperature %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The call to <code>fmt.Sscanf</code> parses a floating-point number (<code>value</code>) and a string (<code>unit</code>) from the input <code>s</code>. Although one must usually check <code>Sscanf</code>’s error result, in this case we don’t need to because if there was a problem, no switch case will match.</p>
<p>The <code>CelsiusFlag</code> function below wraps it all up. To the caller, it returns a pointer to the <code>Celsius</code> field embedded within the <code>celsiusFlag</code> variable <code>f</code>. The <code>Celsius</code> field is the variable that will be updated by the <code>Set</code> method during flags processing. The call to <code>Var</code> adds the flag to the application’s set of command-line flags, the global variable <code>flag.CommandLine</code>.  Programs with unusually complex command-line interfaces may have several variables of this type. The call to <code>Var</code> assigns a <code>*celsiusFlag</code> argument to a <code>flag.Value</code> parameter, causing the compiler to check that <code>*celsiusFlag</code> has the necessary methods.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// CelsiusFlag defines a Celsius flag with the specified name,
</span><span class="c1">// default value, and usage, and returns the address of the flag variable.
</span><span class="c1">// The flag argument must have a quantity and a unit, e.g., &#34;100C&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">CelsiusFlag</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">Celsius</span><span class="p">,</span> <span class="nx">usage</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Celsius</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">celsiusFlag</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">CommandLine</span><span class="p">.</span><span class="nx">Var</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">usage</span><span class="p">)</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span>
<span class="p">}</span>
</code></pre>
<p>Now we can start using the new flag in our programs:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/tempflag/tempflag.go" >gopl.io/ch7/tempflag</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">temp</span> <span class="p">=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">CelsiusFlag</span><span class="p">(</span><span class="s">&#34;temp&#34;</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="s">&#34;the temperature&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">temp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Here’s a typical session:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch7/tempflag
</span><span class="in" ><span class="prompt" >&gt; </span>./tempflag
</span><span class="out" >20°C
</span><span class="in" ><span class="prompt" >&gt; </span>./tempflag -temp -18C
</span><span class="out" >-18°C
</span><span class="in" ><span class="prompt" >&gt; </span>./tempflag -temp <span class="m">212</span>°F
</span><span class="out" >100°C
</span><span class="in" ><span class="prompt" >&gt; </span>./tempflag -temp <span class="m">273</span>.15K
</span><span class="out" >invalid value &#34;273.15K&#34; for flag -temp: invalid temperature &#34;273.15K&#34;
Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
</span><span class="in" ><span class="prompt" >&gt; </span>./tempflag -help
</span><span class="out" >Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
</span></code></pre>
<p><b>Exercise 7.6</b>: Add support for Kelvin temperatures to <code>tempflag</code>.</p>
<p><b>Exercise 7.7</b>: Explain why the help message contains <code>°C</code> when the default value of <code>20.0</code> does not.</p>
</div>
<h3 id="section-7.5" >Interface Values</h3>
<div class="hBody-3" >
<p>Conceptually, a value of an interface type, or <em>interface value</em>, has two components, a concrete type and a value of that type. These are called the interface’s <em>dynamic type</em> and <em>dynamic value</em>.</p>
<p>For a statically typed language like Go, types are a compile-time concept, so a type is not a value. In our conceptual model, a set of values called <em>type descriptors</em> provide information about each type, such as its name and methods. In an interface value, the type component is represented by the appropriate type descriptor.</p>
<p>In the four statements below, the variable <code>w</code> takes on three different values. (The initial and final values are the same.)</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</code></pre>
<p>Let’s take a closer look at the value and dynamic behavior of <code>w</code> after each statement. The first statement declares <code>w</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
</code></pre>
<p>In Go, variables are always initialized to a well-defined value, and interfaces are no exception.  The zero value for an interface has both its type and value components set to <code>nil</code> (Figure 7.1).</p>
<div class="figure" >
<h1 class="figure">Figure 7.1. A nil interface value.</h1>
<div class="art-block" >
<pre class="art" >      w
      ┏━━━━━━━━━━━━┓
 type ┃    nil     ┃
      ┣━━━━━━━━━━━━┫
value ┃    nil     ┃
      ┗━━━━━━━━━━━━┛
</pre>
</div>
</div>
<p>An interface value is described as nil or non-nil based on its dynamic type, so this is a nil interface value. You can test whether an interface value is nil using <code>w == nil</code> or <code>w != nil</code>.  Calling any method of a nil interface value causes a panic:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// panic: nil pointer dereference
</span><span class="c1"></span></code></pre>
<p>The second statement assigns a value of type <code>*os.File</code> to <code>w</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
</code></pre>
<p>This assignment involves an implicit conversion from a concrete type to an interface type, and is equivalent to the explicit conversion <code>io.Writer(os.Stdout)</code>. A conversion of this kind, whether explicit or implicit, captures the type and the value of its operand. The interface value’s dynamic type is set to the type descriptor for the pointer type <code>*os.File</code>, and its dynamic value holds a copy of <code>os.Stdout</code>, which is a pointer to the <code>os.File</code> variable representing the standard output of the process (Figure 7.2).</p>
<div class="figure" >
<h1 class="figure">Figure 7.2. An interface value containing an <code>*os.File</code> pointer.</h1>
<figure>
<img src="img/Figure-7.2.jpg" />
</figure>
</div>
<p>Calling the <code>Write</code> method on an interface value containing an <code>*os.File</code> pointer causes the <code>(*os.File).Write</code> method to be called. The call prints <code>&#34;hello&#34;</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// &#34;hello&#34;
</span><span class="c1"></span></code></pre>
<p>In general, we cannot know at compile time what the dynamic type of an interface value will be, so a call through an interface must use <em>dynamic dispatch</em>. Instead of a direct call, the compiler must generate code to obtain the address of the method named <code>Write</code> from the type descriptor, then make an indirect call to that address. The receiver argument for the call is a copy of the interface’s dynamic value, <code>os.Stdout</code>. The effect is as if we had made this call directly:</p>
<pre class="code" ><code class="chroma" ><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// &#34;hello&#34;
</span><span class="c1"></span></code></pre>
<p>The third statement assigns a value of type <code>*bytes.Buffer</code> to the interface value:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</code></pre>
<p>The dynamic type is now <code>*bytes.Buffer</code> and the dynamic value is a pointer to the newly allocated buffer (Figure 7.3).</p>
<div class="figure" >
<h1 class="figure">Figure 7.3. An interface value containing a <code>*bytes.Buffer</code> pointer.</h1>
<figure>
<img src="img/Figure-7.3.jpg" />
</figure>
</div>
<p>A call to the <code>Write</code> method uses the same mechanism as before:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// writes &#34;hello&#34; to the bytes.Buffer
</span><span class="c1"></span></code></pre>
<p>This time, the type descriptor is <code>*bytes.Buffer</code>, so the <code>(*bytes.Buffer).Write</code> method is called, with the address of the buffer as the value of the receiver parameter. The call appends <code>&#34;hello&#34;</code> to the buffer.</p>
<p>Finally, the fourth statement assigns <code>nil</code> to the interface value:</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</code></pre>
<p>This resets both its components to <code>nil</code>, restoring <code>w</code> to the same state as when it was declared, which was shown in Figure 7.1.</p>
<p>An interface value can hold arbitrarily large dynamic values. For example, the <code>time.Time</code> type, which represents an instant in time, is a struct type with several unexported fields. If we create an interface value from it,</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</code></pre>
<p>the result might look like Figure 7.4. Conceptually, the dynamic value always fits inside the interface value, no matter how large its type. (This is only a conceptual model; a realistic implementation is quite different.)</p>
<div class="figure" >
<h1 class="figure">Figure 7.4. An interface value holding a <code>time.Time</code> struct.</h1>
<figure>
<img src="img/Figure-7.4.jpg" />
</figure>
</div>
<p>Interface values may be compared using <code>==</code> and <code>!=</code>. Two interface values are equal if both are nil, or if their dynamic types are identical and their dynamic values are equal according to the usual behavior of <code>==</code> for that type. Because interface values are comparable, they may be used as the keys of a map or as the operand of a switch statement.</p>
<p>However, if two interface values are compared and have the same dynamic type, but that type is not comparable (a slice, for instance), then the comparison fails with a panic:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// panic: comparing uncomparable type []int
</span><span class="c1"></span></code></pre>
<p>In this respect, interface types are unusual. Other types are either safely comparable (like basic types and pointers) or not comparable at all (like slices, maps, and functions), but when comparing interface values or aggregate types that contain interface values, we must be aware of the potential for a panic. A similar risk exists when using interfaces as map keys or switch operands. Only compare interface values if you are certain that they contain dynamic values of comparable types.</p>
<p>When handling errors, or during debugging, it is often helpful to report the dynamic type of an interface value. For that, we use the <code>fmt</code> package’s <code>%T</code> verb:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &#34;&lt;nil&gt;&#34;
</span><span class="c1"></span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &#34;*os.File&#34;
</span><span class="c1"></span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &#34;*bytes.Buffer&#34;
</span><span class="c1"></span></code></pre>
<p>Internally, <code>fmt</code> uses reflection to obtain the name of the interface’s dynamic type. We’ll look at reflection in <a href="#chapter-12" >Chapter 12</a>.</p>
</div>
<h4 id="section-7.5.1" >Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>
<div class="hBody-4" >
<p>A nil interface value, which contains no value at all, is not the same as an interface value containing a pointer that happens to be nil. This subtle distinction creates a trap into which every Go programmer has stumbled.</p>
<p>Consider the program below. With <code>debug</code> set to <code>true</code>, the main function collects the output of the function <code>f</code> in a <code>bytes.Buffer</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">const</span> <span class="nx">debug</span> <span class="p">=</span> <span class="kc">true</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// enable collection of output
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                    <span class="c1">// NOTE: subtly incorrect!
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
    <span class="c1">// ...use buf...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If out is non-nil, output will be written to it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...do something...
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;done!\n&#34;</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We might expect that changing <code>debug</code> to <code>false</code> would disable the collection of the output, but in fact it causes the program to panic during the <code>out.Write</code> call:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;done!\n&#34;</span><span class="p">))</span> <span class="c1">// panic: nil pointer dereference
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>When <code>main</code> calls <code>f</code>, it assigns a nil pointer of type <code>*bytes.Buffer</code> to the <code>out</code> parameter, so the dynamic value of <code>out</code> is <code>nil</code>. However, its dynamic type is <code>*bytes.Buffer</code>, meaning that <code>out</code> is a non-nil interface containing a nil pointer value (Figure 7.5), so the defensive check <code>out != nil</code> is still true.</p>
<div class="figure" >
<h1 class="figure">Figure 7.5. A non-nil interface containing a nil pointer.</h1>
<div class="art-block" >
<pre class="art" >      w
      ┏━━━━━━━━━━━━━━━━━┓
 type ┃  *bytes.Buffer  ┃
      ┣━━━━━━━━━━━━━━━━━┫
value ┃       nil       ┃
      ┗━━━━━━━━━━━━━━━━━┛
</pre>
</div>
</div>
<p>As before, the dynamic dispatch mechanism determines that <code>(*bytes.Buffer).Write</code> must be called but this time with a receiver value that is nil. For some types, such as <code>*os.File</code>, <code>nil</code> is a valid receiver (<a href="#section-6.2.1" >§6.2.1</a>), but <code>*bytes.Buffer</code> is not among them. The method is called, but it panics as it tries to access the buffer.</p>
<p>The problem is that although a nil <code>*bytes.Buffer</code> pointer has the methods needed to satisfy the interface, it doesn’t satisfy the <em>behavioral</em> requirements of the interface. In particular, the call violates the implicit precondition of <code>(*bytes.Buffer).Write</code> that its receiver is not nil, so assigning the nil pointer to the interface was a mistake. The solution is to change the type of <code>buf</code> in <code>main</code> to <code>io.Writer</code>, thereby avoiding the assignment of the dysfunctional value to the interface in the first place:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
  <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// enable collection of output
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="c1">// OK
</span><span class="c1"></span></code></pre>
<p>Now that we’ve covered the mechanics of interface values, let’s take a look at some more important interfaces from Go’s standard library. In the next three sections, we’ll see how interfaces are used for sorting, web serving, and error handling.</p>
</div>
<h3 id="section-7.6" >Sorting with <code>sort.Interface</code></h3>
<div class="hBody-3" >
<p>Like string formatting, sorting is a frequently used operation in many programs. Although a minimal Quicksort can be written in about 15 lines, a robust implementation is much longer, and it is not the kind of code we should wish to write anew or copy each time we need it.</p>
<p>Fortunately, the <code>sort</code> package provides in-place sorting of any sequence according to any ordering function. Its design is rather unusual. In many languages, the sorting algorithm is associated with the sequence data type, while the ordering function is associated with the type of the elements. By contrast, Go’s <code>sort.Sort</code> function assumes nothing about the representation of either the sequence or its elements. Instead, it uses an interface, <code>sort.Interface</code>, to specify the contract between the generic sort algorithm and each sequence type that may be sorted. An implementation of this interface determines both the concrete representation of the sequence, which is often a slice, and the desired ordering of its elements.</p>
<p>An in-place sort algorithm needs three things—the length of the sequence, a means of comparing two elements, and a way to swap two elements—so they are the three methods of <code>sort.Interface</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">sort</span>

<span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="c1">// i, j are indices of sequence elements
</span><span class="c1"></span>  <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>To sort any sequence, we need to define a type that implements these three methods, then apply <code>sort.Sort</code> to an instance of that type. As perhaps the simplest example, consider sorting a slice of strings. The new type <code>StringSlice</code> and its <code>Len</code>, <code>Less</code>, and <code>Swap</code> methods are shown below.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">StringSlice</span> <span class="p">[]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>Now we can sort a slice of strings, <code>names</code>, by converting the slice to a <code>StringSlice</code> like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">StringSlice</span><span class="p">(</span><span class="nx">names</span><span class="p">))</span>
</code></pre>
<p>The conversion yields a slice value with the same length, capacity, and underlying array as <code>names</code> but with a type that has the three methods required for sorting.</p>
<p>Sorting a slice of strings is so common that the <code>sort</code> package provides the <code>StringSlice</code> type, as well as a function called <code>Strings</code> so that the call above can be simplified to <code>sort.Strings(names)</code>.</p>
<p>The technique here is easily adapted to other sort orders, for instance, to ignore capitalization or special characters. (The Go program that sorts index terms and page numbers for this book does this, with extra logic for Roman numerals.) For more complicated sorting, we use the same idea, but with more complicated data structures or more complicated implementations of the <code>sort.Interface</code> methods.</p>
<p>Our running example for sorting will be a music playlist, displayed as a table. Each track is a single row, and each column is an attribute of that track, like artist, title, and running time.  Imagine that a graphical user interface presents the table, and that clicking the head of a column causes the playlist to be sorted by that attribute; clicking the same column head again reverses the order. Let’s look at what might happen in response to each click.</p>
<p>The variable <code>tracks</code> below contains a playlist. (One of the authors apologizes for the other author’s musical tastes.) Each element is indirect, a pointer to a <code>Track</code>. Although the code below would work if we stored the <code>Tracks</code> directly, the sort function will swap many pairs of elements, so it will run faster if each element is a pointer, which is a single machine word, instead of an entire <code>Track</code>, which might be eight words or more.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/sorting/main.go" >gopl.io/ch7/sorting</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Track</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span>  <span class="kt">string</span>
  <span class="nx">Artist</span> <span class="kt">string</span>
  <span class="nx">Album</span>  <span class="kt">string</span>
  <span class="nx">Year</span>   <span class="kt">int</span>
  <span class="nx">Length</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">tracks</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">{</span>
  <span class="p">{</span><span class="s">&#34;Go&#34;</span><span class="p">,</span> <span class="s">&#34;Delilah&#34;</span><span class="p">,</span> <span class="s">&#34;From the Roots Up&#34;</span><span class="p">,</span> <span class="mi">2012</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&#34;3m38s&#34;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&#34;Go&#34;</span><span class="p">,</span> <span class="s">&#34;Moby&#34;</span><span class="p">,</span> <span class="s">&#34;Moby&#34;</span><span class="p">,</span> <span class="mi">1992</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&#34;3m37s&#34;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&#34;Go Ahead&#34;</span><span class="p">,</span> <span class="s">&#34;Alicia Keys&#34;</span><span class="p">,</span> <span class="s">&#34;As I Am&#34;</span><span class="p">,</span> <span class="mi">2007</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&#34;4m36s&#34;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&#34;Ready 2 Go&#34;</span><span class="p">,</span> <span class="s">&#34;Martin Solveig&#34;</span><span class="p">,</span> <span class="s">&#34;Smash&#34;</span><span class="p">,</span> <span class="mi">2011</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&#34;4m24s&#34;</span><span class="p">)},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">length</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">ParseDuration</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>printTracks</code> function prints the playlist as a table. A graphical display would be nicer, but this little routine uses the <code>text/tabwriter</code> package to produce a table whose columns are neatly aligned and padded as shown below. Observe that <code>*tabwriter.Writer</code> satisfies <code>io.Writer</code>. It collects each piece of data written to it; its <code>Flush</code> method formats the entire table and writes it to <code>os.Stdout</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">printTracks</span><span class="p">(</span><span class="nx">tracks</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">format</span> <span class="p">=</span> <span class="s">&#34;%v\t%v\t%v\t%v\t%v\t\n&#34;</span>
  <span class="nx">tw</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tabwriter</span><span class="p">.</span><span class="nx">Writer</span><span class="p">).</span><span class="nx">Init</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&#34;Title&#34;</span><span class="p">,</span> <span class="s">&#34;Artist&#34;</span><span class="p">,</span> <span class="s">&#34;Album&#34;</span><span class="p">,</span> <span class="s">&#34;Year&#34;</span><span class="p">,</span> <span class="s">&#34;Length&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&#34;-----&#34;</span><span class="p">,</span> <span class="s">&#34;------&#34;</span><span class="p">,</span> <span class="s">&#34;-----&#34;</span><span class="p">,</span> <span class="s">&#34;----&#34;</span><span class="p">,</span> <span class="s">&#34;------&#34;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tracks</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Title</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Artist</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Album</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Year</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">tw</span><span class="p">.</span><span class="nx">Flush</span><span class="p">()</span> <span class="c1">// calculate column widths and print table
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>To sort the playlist by the <code>Artist</code> field, we define a new slice type with the necessary <code>Len</code>, <code>Less</code>, and <code>Swap</code> methods, analogous to what we did for <code>StringSlice</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">byArtist</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>To call the generic sort routine, we must first convert <code>tracks</code> to the new type, <code>byArtist</code>, that defines the order:</p>
<pre class="code" ><code class="chroma" ><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">))</span>
</code></pre>
<p>After sorting the slice by artist, the output from <code>printTracks</code> is</p>
<div class="pre-block" >
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Go          Delilah         From the Roots Up  2012  3m38s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Moby            Moby               1992  3m37s
</pre>
</div>
<p>If the user requests <q>sort by artist</q> a second time, we’ll sort the tracks in reverse. We needn’t define a new type <code>byReverseArtist</code> with an inverted <code>Less</code> method, however, since the <code>sort</code> package provides a <code>Reverse</code> function that transforms any sort order to its inverse.</p>
<pre class="code" ><code class="chroma" ><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">)))</span>
</code></pre>
<p>After reverse-sorting the slice by artist, the output from printTracks is</p>
<div class="pre-block" >
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
</pre>
</div>
<p>The <code>sort.Reverse</code> function deserves a closer look since it uses composition (<a href="#section-6.3" >§6.3</a>), which is an important idea. The <code>sort</code> package defines an unexported type <code>reverse</code>, which is a struct that embeds a <code>sort.Interface</code>. The <code>Less</code> method for <code>reverse</code> calls the <code>Less</code> method of the embedded <code>sort.Interface</code> value, but with the indices flipped, reversing the order of the sort results.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">sort</span>

<span class="kd">type</span> <span class="nx">reverse</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Interface</span> <span class="p">}</span> <span class="c1">// that is, sort.Interface
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">reverse</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nx">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Reverse</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span> <span class="p">}</span>
</code></pre>
<p><code>Len</code> and <code>Swap</code>, the other two methods of <code>reverse</code>, are implicitly provided by the original <code>sort.Interface</code> value because it is an embedded field. The exported function <code>Reverse</code> returns an instance of the <code>reverse</code> type that contains the original <code>sort.Interface</code> value.</p>
<p>To sort by a different column, we must define a new type, such as <code>byYear</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">byYear</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Year</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>After sorting <code>tracks</code> by year using <code>sort.Sort(byYear(tracks))</code>, <code>printTracks</code> shows a chronological listing:</p>
<div class="pre-block" >
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s
</pre>
</div>
<p>For every slice element type and every ordering function we need, we declare a new implementation of <code>sort.Interface</code>. As you can see, the <code>Len</code> and <code>Swap</code> methods have identical definitions for all slice types. In the next example, the concrete type <code>customSort</code> combines a slice with a function, letting us define a new sort order by writing only the comparison function. Incidentally, the concrete types that implement <code>sort.Interface</code> are not always slices; <code>customSort</code> is a struct type.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">customSort</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">t</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>
  <span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">less</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>Let’s define a multi-tier ordering function whose primary sort key is the <code>Title</code>, whose secondary key is the <code>Year</code>, and whose tertiary key is the running time, <code>Length</code>. Here’s the call to <code>Sort</code> using an anonymous ordering function:</p>
<pre class="code" ><code class="chroma" ><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">customSort</span><span class="p">{</span><span class="nx">tracks</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}})</span>
</code></pre>
<p>And here’s the result. Notice that the tie between the two tracks titled <q>Go</q> is broken in favor of the older one.</p>
<div class="pre-block" >
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
</pre>
</div>
<p>Although sorting a sequence of length <span class="math" >n</span> requires <span class="math" >O(n log n)</span> comparison operations, testing whether a sequence is already sorted requires at most <span class="math" >n-1</span> comparisons. The <code>IsSorted</code> function from the <code>sort</code> package checks this for us. Like <code>sort.Sort</code>, it abstracts both the sequence and its ordering function using <code>sort.Interface</code>, but it never calls the <code>Swap</code> method: This code demonstrates the <code>IntsAreSorted</code> and <code>Ints</code> functions and the <code>IntSlice</code> type:</p>
<pre class="code" ><code class="chroma" ><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &#34;[1 1 3 4]&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">values</span><span class="p">)))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &#34;[4 3 1 1]&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>For convenience, the <code>sort</code> package provides versions of its functions and types specialized for <code>[]int</code>, <code>[]string</code>, and <code>[]float64</code> using their natural orderings. For other types, such as <code>[]int64</code> or <code>[]uint</code>, we’re on our own, though the path is short.</p>
<p><b>Exercise 7.8</b>: Many GUIs provide a table widget with a stateful multi-tier sort: the primary sort key is the most recently clicked column head, the secondary sort key is the second-most recently clicked column head, and so on. Define an implementation of <code>sort.Interface</code> for use by such a table. Compare that approach with repeated sorting using <code>sort.Stable</code>.</p>
<p><b>Exercise 7.9</b>: Use the <code>html/template</code> package (<a href="#section-4.6" >§4.6</a>) to replace <code>printTracks</code> with a function that displays the tracks as an HTML table. Use the solution to the previous exercise to arrange that each click on a column head makes an HTTP request to sort the table.</p>
<p><b>Exercise 7.10</b>: The <code>sort.Interface</code> type can be adapted to other uses. Write a function <code>IsPalindrome(s sort.Interface) bool</code> that reports whether the sequence <code>s</code> is a palindrome, in other words, reversing the sequence would not change it. Assume that the elements at indices <code>i</code> and <code>j</code> are equal if <code>!s.Less(i, j) &amp;&amp; !s.Less(j, i)</code>.</p>
</div>
<h3 id="section-7.7" >The <code>http.Handler</code> Interface</h3>
<div class="hBody-3" >
<p>In <a href="#chapter-1" >Chapter 1</a>, we saw a glimpse of how to use the <code>net/http</code> package to implement web clients (<a href="#section-1.5" >§1.5</a>) and servers (<a href="#section-1.7" >§1.7</a>). In this section, we’ll look more closely at the server API, whose foundation is the <code>http.Handler</code> interface:</p>
<div class="figure" >
<h1 class="figure"><code>net/http</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">ListenAndServe</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span>
</code></pre>
</div>
<p>The <code>ListenAndServe</code> function requires a server address, such as <code>&#34;localhost:8000&#34;</code>, and an instance of the <code>Handler</code> interface to which all requests should be dispatched. It runs forever, or until the server fails (or fails to start) with an error, always non-nil, which it returns.</p>
<p>Imagine an e-commerce site with a database mapping the items for sale to their prices in dollars. The program below shows the simplest imaginable implementation. It models the inventory as a map type, <code>database</code>, to which we’ve attached a <code>ServeHTTP</code> method so that it satisfies the <code>http.Handler</code> interface. The handler ranges over the map and prints the items.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/http1/main.go" >gopl.io/ch7/http1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&#34;shoes&#34;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&#34;socks&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8000&#34;</span><span class="p">,</span> <span class="nx">db</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">dollars</span> <span class="kt">float32</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">dollars</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;$%.2f&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s: %s\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>If we start the server,</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch7/http1
</span><span class="in" ><span class="prompt" >&gt; </span>./http1 <span class="p">&amp;</span>
</span></code></pre>
<p>then connect to it with the <code class="command" >fetch</code> program from <a href="#section-1.5" >Section 1.5</a> (or a web browser if you prefer), we get the following output:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000
</span><span class="out" >shoes: $50.00
socks: $5.00
</span></code></pre>
<p>So far, the server can only list its entire inventory and will do this for every request, regardless of URL. A more realistic server defines multiple different URLs, each triggering a different behavior. Let’s call the existing one <code>/list</code> and add another one called <code>/price</code> that reports the price of a single item, specified as a request parameter like <code>/price?item=socks</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/http2/main.go" >gopl.io/ch7/http2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&#34;/list&#34;</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s: %s\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="s">&#34;/price&#34;</span><span class="p">:</span>
    <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">)</span>
    <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;no such item: %q\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span>  <span class="c1">// 404
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;no such page: %s\n&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now the handler decides what logic to execute based on the path component of the URL, <code>req.URL.Path</code>. If the handler doesn’t recognize the path, it reports an HTTP error to the client by calling <code>w.WriteHeader(http.StatusNotFound)</code>; this must be done before writing any text to <code>w</code>. (Incidentally, <code>http.ResponseWriter</code> is another interface. It augments <code>io.Writer</code> with methods for sending HTTP response headers.) Equivalently, we could use the <code>http.Error</code> utility function:</p>
<pre class="code" ><code class="chroma" ><span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;no such page: %s\n&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404
</span><span class="c1"></span></code></pre>
<p>The case for <code>/price</code> calls the URL’s <code>Query</code> method to parse the HTTP request parameters as a map, or more precisely, a multimap of type <code>url.Values</code> (<a href="#section-6.2.1" >§6.2.1</a>) from the <code>net/url</code> package. It then finds the first <code>item</code> parameter and looks up its price. If the item wasn’t found, it reports an error.</p>
<p>Here’s an example session with the new server:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch7/http2
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./http2 <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/list
</span><span class="out" >shoes: $50.00
socks: $5.00
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/price?item<span class="o">=</span>socks
</span><span class="out" >$5.00
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/price?item<span class="o">=</span>shoes
</span><span class="out" >$50.00
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/price?item<span class="o">=</span>hat
</span><span class="out" >no such item: &#34;hat&#34;
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://localhost:8000/help
</span><span class="out" >no such page: /help
</span></code></pre>
<p>Obviously we could keep adding cases to <code>ServeHTTP</code>, but in a realistic application, it’s convenient to define the logic for each case in a separate function or method. Furthermore, related URLs may need similar logic; several image files may have URLs of the form <code>/images/*.png</code>, for instance. For these reasons, <code>net/http</code> provides <code>ServeMux</code>, a <em>request multiplexer</em>, to simplify the association between URLs and handlers. A <code>ServeMux</code> aggregates a collection of <code>http.Handlers</code> into a single <code>http.Handler</code>. Again, we see that different types satisfying the same interface are <em>substitutable</em>: the web server can dispatch requests to any <code>http.Handler</code>, regardless of which concrete type is behind it.</p>
<p>For a more complex application, several <code>ServeMuxes</code> may be composed to handle more intricate dispatching requirements. Go doesn’t have a canonical web framework analogous to Ruby’s Rails or Python’s Django. This is not to say that such frameworks don’t exist, but the building blocks in Go’s standard library are flexible enough that frameworks are often unnecessary. Furthermore, although frameworks are convenient in the early phases of a project, their additional complexity can make longer-term maintenance harder.</p>
<p>In the program below, we create a <code>ServeMux</code> and use it to associate the URLs with the corresponding handlers for the <code>/list</code> and <code>/price</code> operations, which have been split into separate methods. We then use the <code>ServeMux</code> as the main handler in the call to <code>ListenAndServe</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/http3/main.go" >gopl.io/ch7/http3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&#34;shoes&#34;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&#34;socks&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewServeMux</span><span class="p">()</span>
  <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/list&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">))</span>
  <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;/price&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">))</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8000&#34;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">list</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s: %s\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">price</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;item&#34;</span><span class="p">)</span>
  <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;no such item: %q\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Let’s focus on the two calls to <code>mux.Handle</code> that register the handlers. In the first one, <code>db.list</code> is a method value (<a href="#section-6.4" >§6.4</a>), that is, a value of type</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
</code></pre>
<p>that, when called, invokes the <code>database.list</code> method with the receiver value <code>db</code>. So <code>db.list</code> is a function that implements handler-like behavior, but since it has no methods, it doesn’t satisfy the <code>http.Handler</code> interface and can’t be passed directly to <code>mux.Handle</code>.</p>
<p>The expression <code>http.HandlerFunc(db.list)</code> is a conversion, not a function call, since <code>http.HandlerFunc</code> is a type. It has the following definition:</p>
<div class="figure" >
<h1 class="figure"><code>net/http</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p><code>HandlerFunc</code> demonstrates some unusual features of Go’s interface mechanism. It is a function type that has methods and satisfies an interface, <code>http.Handler</code>. The behavior of its <code>ServeHTTP</code> method is to call the underlying function. <code>HandlerFunc</code> is thus an adapter that lets a function value satisfy an interface, where the function and the interface’s sole method have the same signature. In effect, this trick lets a single type such as <code>database</code> satisfy the <code>http.Handler</code> interface several different ways: once through its <code>list</code> method, once through its <code>price</code> method, and so on.</p>
<p>Because registering a handler this way is so common, <code>ServeMux</code> has a convenience method called <code>HandleFunc</code> that does it for us, so we can simplify the handler registration code to this:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/http3a/main.go" >gopl.io/ch7/http3a</a></h1>
<pre class="code" ><code class="chroma" ><span class="nx">mux</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/list&#34;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
<span class="nx">mux</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/price&#34;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">)</span>
</code></pre>
</div>
<p>It’s easy to see from the code above how one would construct a program in which there are two different web servers, listening on different ports, defining different URLs, and dispatching to different handlers. We would just construct another <code>ServeMux</code> and make another call to <code>ListenAndServe</code>, perhaps concurrently. But in most programs, one web server is plenty. Also, it’s typical to define HTTP handlers across many files of an application, and it would be a nuisance if they all had to be explicitly registered with the application’s <code>ServeMux</code> instance.</p>
<p>So, for convenience, <code>net/http</code> provides a global <code>ServeMux</code> instance called <code>DefaultServeMux</code> and package-level functions called <code>http.Handle</code> and <code>http.HandleFunc</code>. To use <code>DefaultServeMux</code> as the server’s main handler, we needn’t pass it to <code>ListenAndServe</code>; <code>nil</code> will do.</p>
<p>The server’s main function can then be simplified to</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/http4/main.go" >gopl.io/ch7/http4</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&#34;shoes&#34;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&#34;socks&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/list&#34;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&#34;/price&#34;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">)</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8000&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Finally, an important reminder: as we mentioned in <a href="#section-1.7" >Section 1.7</a>, the web server invokes each handler in a new goroutine, so handlers must take precautions such as <em>locking</em> when accessing variables that other goroutines, including other requests to the same handler, may be accessing. We’ll talk about concurrency in the next two chapters.</p>
<p><b>Exercise 7.11</b>: Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form <code>/update?item=socks&amp;price=6</code> will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.)</p>
<p><b>Exercise 7.12</b>: Change the handler for <code>/list</code> to print its output as an HTML table, not text.  You may find the <code>html/template</code> package (<a href="#section-4.6" >§4.6</a>) useful.</p>
</div>
<h3 id="section-7.8" >The <code>error</code> Interface</h3>
<div class="hBody-3" >
<p>Since the beginning of this book, we’ve been using and creating values of the mysterious predeclared <code>error</code> type without explaining what it really is. In fact, it’s just an interface type with a single method that returns an error message:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>The simplest way to create an <code>error</code> is by calling <code>errors.New</code>, which returns a new <code>error</code> for a given error message. The entire <code>errors</code> package is only four lines long:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">errors</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">text</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">text</span> <span class="p">}</span>
</code></pre>
<p>The underlying type of <code>errorString</code> is a struct, not a string, to protect its representation from inadvertent (or premeditated) updates. And the reason that the pointer type <code>*errorString</code>, not <code>errorString</code> alone, satisfies the <code>error</code> interface is so that every call to <code>New</code> allocates a distinct <code>error</code> instance that is equal to no other. We would not want a distinguished error such as <code>io.EOF</code> to compare equal to one that merely happened to have the same message.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>Calls to <code>errors.New</code> are relatively infrequent because there’s a convenient wrapper function, <code>fmt.Errorf</code>, that does string formatting too. We used it several times in <a href="#chapter-5" >Chapter 5</a>.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>

<span class="kd">func</span> <span class="nx">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Although <code>*errorString</code> may be the simplest type of <code>error</code>, it is far from the only one. For example, the <code>syscall</code> package provides Go’s low-level system call API. On many platforms, it defines a numeric type <code>Errno</code> that satisfies <code>error</code>, and on Unix platforms, <code>Errno</code>’s <code>Error</code> method does a lookup in a table of strings, as shown below :</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">syscall</span>

<span class="kd">type</span> <span class="nx">Errno</span> <span class="kt">uintptr</span> <span class="c1">// operating system error code
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">errors</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="s">&#34;operation not permitted&#34;</span><span class="p">,</span>   <span class="c1">// EPERM
</span><span class="c1"></span>  <span class="mi">2</span><span class="p">:</span> <span class="s">&#34;no such file or directory&#34;</span><span class="p">,</span> <span class="c1">// ENOENT
</span><span class="c1"></span>  <span class="mi">3</span><span class="p">:</span> <span class="s">&#34;no such process&#34;</span><span class="p">,</span>           <span class="c1">// ESRCH
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Errno</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">[</span><span class="nx">e</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;errno %d&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The following statement creates an interface value holding the <code>Errno</code> value 2, signifying the POSIX <code>ENOENT</code> condition:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Errno</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span> <span class="c1">// &#34;no such file or directory&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// &#34;no such file or directory&#34;
</span><span class="c1"></span></code></pre>
<p>The value of <code>err</code> is shown graphically in Figure 7.6.</p>
<div class="figure" >
<h1 class="figure">Figure 7.6. An interface value holding a <code>syscall.Errno</code> integer.</h1>
<div class="art-block" >
<pre class="art" >      err
      ┏━━━━━━━━━━━━━━━━━┓
 type ┃  syscall.Errno  ┃
      ┣━━━━━━━━━━━━━━━━━┫
value ┃        2        ┃
      ┗━━━━━━━━━━━━━━━━━┛
</pre>
</div>
</div>
<p><code>Errno</code> is an efficient representation of system call errors drawn from a finite set, and it satisfies the standard <code>error</code> interface. We’ll see other types that satisfy this interface in <a href="#section-7.11" >Section 7.11</a>.</p>
</div>
<h3 id="section-7.9" >Example: Expression Evaluator</h3>
<div class="hBody-3" >
<p>In this section, we’ll build an evaluator for simple arithmetic expressions. We’ll use an interface, <code>Expr</code>, to represent any expression in this language. For now, this interface needs no methods, but we’ll add some later.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// An Expr is an arithmetic expression.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span><span class="p">{}</span>
</code></pre>
<p>Our expression language consists of floating-point literals; the binary operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>; the unary operators <code>-x</code> and <code>+x</code>; function calls <code>pow(x,y)</code>, <code>sin(x)</code>, and <code>sqrt(x)</code>; variables such as <code>x</code> and <code>pi</code>; and of course parentheses and standard operator precedence. All values are of type <code>float64</code>. Here are some example expressions:</p>
<pre class="code" ><code class="chroma" ><span class="nx">sqrt</span><span class="p">(</span><span class="nx">A</span> <span class="o">/</span> <span class="nx">pi</span><span class="p">)</span>
<span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nx">F</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
</code></pre>
<p>The five concrete types below represent particular kinds of expression. A <code>Var</code> represents a reference to a variable. (We’ll soon see why it is exported.) A <code>literal</code> represents a floatingpoint constant. The <code>unary</code> and <code>binary</code> types represent operator expressions with one or two operands, which can be any kind of <code>Expr</code>. A <code>call</code> represents a function call; we’ll restrict its <code>fn</code> field to <code>pow</code>, <code>sin</code>, or <code>sqrt</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/eval/ast.go" >gopl.io/ch7/eval</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// A Var identifies a variable, e.g., x.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Var</span> <span class="kt">string</span>

<span class="c1">// A literal is a numeric constant, e.g., 3.141.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">literal</span> <span class="kt">float64</span>

<span class="c1">// A unary represents a unary operator expression, e.g., -x.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">unary</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span> <span class="kt">rune</span> <span class="c1">// one of &#39;+&#39;, &#39;-&#39;
</span><span class="c1"></span>  <span class="nx">x</span>  <span class="nx">Expr</span>
<span class="p">}</span>

<span class="c1">// A binary represents a binary operator expression, e.g., x+y.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">binary</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span>   <span class="kt">rune</span> <span class="c1">// one of &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;
</span><span class="c1"></span>  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">Expr</span>
<span class="p">}</span>

<span class="c1">// A call represents a function call expression, e.g., sin(x).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">fn</span>   <span class="kt">string</span> <span class="c1">// one of &#34;pow&#34;, &#34;sin&#34;, &#34;sqrt&#34;
</span><span class="c1"></span>  <span class="nx">args</span> <span class="p">[]</span><span class="nx">Expr</span>
<span class="p">}</span>
</code></pre>
</div>
<p>To evaluate an expression containing variables, we’ll need an <em>environment</em> that maps variable names to values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Env</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">float64</span>
</code></pre>
<p>We’ll also need each kind of expression to define an <code>Eval</code> method that returns the expression’s value in a given environment. Since every expression must provide this method, we add it to the <code>Expr</code> interface. The package exports only the types <code>Expr</code>, <code>Env</code>, and <code>Var</code>; clients can use the evaluator without access to the other expression types.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// Eval returns the value of this Expr in the environment env.
</span><span class="c1"></span>  <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span>
<span class="p">}</span>
</code></pre>
<p>The concrete <code>Eval</code> methods are shown below. The method for <code>Var</code> performs an environment lookup, which returns zero if the variable is not defined, and the method for <code>literal</code> simply returns the literal value.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Var</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">env</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">literal</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">_</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Eval</code> methods for <code>unary</code> and <code>binary</code> recursively evaluate their operands, then apply the operation <code>op</code> to them. We don’t consider divisions by zero or infinity to be errors, since they produce a result, albeit non-finite. Finally, the method for <code>call</code> evaluates the arguments to the <code>pow</code>, <code>sin</code>, or <code>sqrt</code> function, then calls the corresponding function in the <code>math</code> package.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">unary</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span> <span class="p">{</span>
  <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">+</span><span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unsupported unary operator: %q&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">binary</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span> <span class="p">{</span>
  <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">*</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">/</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unsupported binary operator: %q&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">call</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&#34;pow&#34;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">),</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="k">case</span> <span class="s">&#34;sin&#34;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="k">case</span> <span class="s">&#34;sqrt&#34;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unsupported function call: %s&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
<p>Several of these methods can fail. For example, a <code>call</code> expression could have an unknown function or the wrong number of arguments. It’s also possible to construct a <code>unary</code> or <code>binary</code> expression with an invalid operator such as <code>!</code> or <code>&lt;</code> (although the <code>Parse</code> function mentioned below will never do this). These errors cause <code>Eval</code> to panic. Other errors, like evaluating a <code>Var</code> not present in the environment, merely cause <code>Eval</code> to return the wrong result. All of these errors could be detected by inspecting the <code>Expr</code> before evaluating it. That will be the job of the <code>Check</code> method, which we will show soon, but first let’s test <code>Eval</code>.</p>
<p>The <code>TestEval</code> function below is a test of the evaluator. It uses the <code>testing</code> package, which we’ll explain in <a href="#chapter-11" >Chapter 11</a>, but for now it’s enough to know that calling <code>t.Errorf</code> reports an error. The function loops over a table of inputs that defines three expressions and different environments for each one. The first expression computes the radius of a circle given its area <code>A</code>, the second computes the sum of the cubes of two variables <code>x</code> and <code>y</code>, and the third converts a Fahrenheit temperature <code>F</code> to Celsius.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestEval</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">expr</span> <span class="kt">string</span>
    <span class="nx">env</span>  <span class="nx">Env</span>
    <span class="nx">want</span> <span class="kt">string</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&#34;sqrt(A / pi)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">:</span> <span class="mi">87616</span><span class="p">,</span> <span class="s">&#34;pi&#34;</span><span class="p">:</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">},</span> <span class="s">&#34;167&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;pow(x, 3) + pow(y, 3)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s">&#34;1729&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;pow(x, 3) + pow(y, 3)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="s">&#34;1729&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;5 / 9 * (F - 32)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;F&#34;</span><span class="p">:</span> <span class="o">-</span><span class="mi">40</span><span class="p">},</span> <span class="s">&#34;-40&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;5 / 9 * (F - 32)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;F&#34;</span><span class="p">:</span> <span class="mi">32</span><span class="p">},</span> <span class="s">&#34;0&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;5 / 9 * (F - 32)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;F&#34;</span><span class="p">:</span> <span class="mi">212</span><span class="p">},</span> <span class="s">&#34;100&#34;</span><span class="p">},</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">prevExpr</span> <span class="kt">string</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="c1">// Print expr only when it changes.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span> <span class="o">!=</span> <span class="nx">prevExpr</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\n%s\n&#34;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">)</span>
      <span class="nx">prevExpr</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span>
    <span class="p">}</span>
    <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// parse error
</span><span class="c1"></span>      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%.6g&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\t%v =&gt; %s\n&#34;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s.Eval() in %v = %q, want %q\n&#34;</span><span class="p">,</span>
        <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>For each entry in the table, the test parses the expression, evaluates it in the environment, and prints the result. We don’t have space to show the <code>Parse</code> function here, but you’ll find it if you download the package using <code class="command" >go get</code>.</p>
<p>The <code class="command" >go test</code> command (<a href="#section-11.1" >§11.1</a>) runs a package’s tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v gopl.io/ch7/eval
</span></code></pre>
<p>The <code>-v</code> flag lets us see the printed output of the test, which is normally suppressed for a successful test like this one. Here is the output of the test’s <code>fmt.Printf</code> statements:</p>
<pre class="srci" ><code class="sh" ><span class="out" >sqrt(A / pi)
    map[A:87616 pi:3.141592653589793] =&gt; 167

pow(x, 3) + pow(y, 3)
    map[x:12 y:1] =&gt; 1729
    map[x:9 y:10] =&gt; 1729

5 / 9 * (F - 32)
    map[F:-40] =&gt; -40
    map[F:32] =&gt; 0
    map[F:212] =&gt; 100
</span></code></pre>
<p>Fortunately the inputs so far have all been well formed, but our luck is unlikely to last. Even in interpreted languages, it is common to check the syntax for <em>static</em> errors, that is, mistakes that can be detected without running the program. By separating the static checks from the dynamic ones, we can detect errors sooner and perform many checks only once instead of each time an expression is evaluated.</p>
<p>Let’s add another method to the <code>Expr</code> interface. The <code>Check</code> method checks for static errors in an expression syntax tree. We’ll explain its <code>vars</code> parameter in a moment.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span>
  <span class="c1">// Check reports errors in this Expr and adds its Vars to the set.
</span><span class="c1"></span>  <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre>
<p>The concrete <code>Check</code> methods are shown below. Evaluation of <code>literal</code> and <code>Var</code> cannot fail, so the <code>Check</code> methods for these types return <code>nil</code>. The methods for <code>unary</code> and <code>binary</code> first check that the operator is valid, then recursively check the operands. Similarly, the method for <code>call</code> first checks that the function is known and has the right number of arguments, then recursively checks each argument.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Var</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">vars</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">literal</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">unary</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ContainsRune</span><span class="p">(</span><span class="s">&#34;+-&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected unary op %q&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">binary</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ContainsRune</span><span class="p">(</span><span class="s">&#34;+-*/&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected binary op %q&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">call</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">arity</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">numParams</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unknown function %q&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">arity</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;call to %s has %d args, want %d&#34;</span><span class="p">,</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">),</span> <span class="nx">arity</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">numParams</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&#34;pow&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;sin&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;sqrt&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</code></pre>
<p>We’ve listed a selection of flawed inputs and the errors they elicit, in two groups. The <code>Parse</code> function (not shown) reports syntax errors and the <code>Check</code> function reports semantic errors.</p>
<div class="pre-block" >
<pre class="pre" >x % 2             unexpected &#39;%&#39;
math.Pi           unexpected &#39;.&#39;
!true             unexpected &#39;!&#39;
&#34;hello&#34;           unexpected &#39;&#34;&#39;

log(10)           unknown function &#34;log&#34;
sqrt(1, 2)        call to sqrt has 2 args, want 1
</pre>
</div>
<p><code>Check</code>’s argument, a set of <code>Vars</code>, accumulates the set of variable names found within the expression. Each of these variables must be present in the environment for evaluation to succeed. This set is logically the <em>result</em> of the call to <code>Check</code>, but because the method is recursive, it is more convenient for <code>Check</code> to populate a set passed as a parameter. The client must provide an empty set in the initial call.</p>
<p>In <a href="#section-3.2" >Section 3.2</a>, we plotted a function <code>f(x,y)</code> that was fixed at compile time. Now that we can parse, check, and evaluate expressions in strings, we can build a web application that receives an expression at run time from the client and plots the surface of that function. We can use the <code>vars</code> set to check that the expression is a function of only two variables, <code>x</code> and <code>y</code>—three, actually, since we’ll provide <code>r</code>, the radius, as a convenience. And we’ll use the <code>Check</code> method to reject ill-formed expressions before evaluation begins so that we don’t repeat those checks during the 40,000 evaluations (100×100 cells, each with four corners) of the function that follow.</p>
<p>The <code>parseAndCheck</code> function combines these parsing and checking steps:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/surface/surface.go" >gopl.io/ch7/surface</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;gopl.io/ch7/eval&#34;</span>

<span class="kd">func</span> <span class="nx">parseAndCheck</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Expr</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;empty expression&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">eval</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">vars</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vars</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&#34;x&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&#34;y&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&#34;r&#34;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;undefined variable: %s&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">expr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>To make this a web application, all we need is the <code>plot</code> function below, which has the familiar signature of an <code>http.HandlerFunc</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">plot</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">()</span>
  <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parseAndCheck</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;expr&#34;</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;bad expr: &#34;</span><span class="o">+</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">Header</span><span class="p">().</span><span class="nx">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;image/svg+xml&#34;</span><span class="p">)</span>
  <span class="nx">surface</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// distance from (0,0)
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Env</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">:</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">:</span> <span class="nx">r</span><span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<p>The <code>plot</code> function parses and checks the expression specified in the HTTP request and uses it to create an anonymous function of two variables. The anonymous function has the same signature as the fixed function <code>f</code> from the original surface-plotting program, but it evaluates the user-supplied expression. The environment defines <code>x</code>, <code>y</code>, and the radius <code>r</code>. Finally, <code>plot</code> calls <code>surface</code>, which is just the <code>main</code> function from <code>gopl.io/ch3/surface</code>, modified to take the function to plot and the output <code>io.Writer</code> as parameters, instead of using the fixed function <code>f</code> and <code>os.Stdout</code>. Figure 7.7 shows three surfaces produced by the program.</p>
<div class="figure" >
<h1 class="figure">Figure 7.7. The surfaces of three functions: (a) <code>sin(-x)*pow(1.5,-r)</code>; (b) <code>pow(2,sin(y))*pow(2,sin(x))/12</code>; (c) <code>sin(x*y/10)/10</code>.</h1>
<figure>
<img src="img/Figure-7.7.a.jpg" />
</figure>
<figure>
<img src="img/Figure-7.7.b.jpg" />
</figure>
<figure>
<img src="img/Figure-7.7.c.jpg" />
</figure>
</div>
<p><b>Exercise 7.13</b>: Add a <code>String</code> method to <code>Expr</code> to pretty-print the syntax tree. Check that the results, when parsed again, yield an equivalent tree.</p>
<p><b>Exercise 7.14</b>: Define a new concrete type that satisfies the <code>Expr</code> interface and provides a new operation such as computing the minimum value of its operands. Since the <code>Parse</code> function does not create instances of this new type, to use it you will need to construct a syntax tree directly (or extend the parser).</p>
<p><b>Exercise 7.15</b>: Write a program that reads a single expression from the standard input, prompts the user to provide values for any variables, then evaluates the expression in the resulting environment. Handle all errors gracefully.</p>
<p><b>Exercise 7.16</b>: Write a web-based calculator program.</p>
</div>
<h3 id="section-7.10" >Type Assertions</h3>
<div class="hBody-3" >
<p>A <em>type assertion</em> is an operation applied to an interface value. Syntactically, it looks like <code>x.(T)</code>, where <code>x</code> is an expression of an interface type and <code>T</code> is a type, called the <q>asserted</q> type. A type assertion checks that the dynamic type of its operand matches the asserted type.</p>
<p>There are two possibilities. First, if the asserted type <code>T</code> is a concrete type, then the type assertion checks whether <code>x</code>’s dynamic type is <em>identical to</em> <code>T</code>. If this check succeeds, the result of the type assertion is <code>x</code>’s dynamic value, whose type is of course <code>T</code>. In other words, a type assertion to a concrete type extracts the concrete value from its operand. If the check fails, then the operation panics. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// success: f == os.Stdout
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// panic: interface holds *os.File, not *bytes.Buffer
</span><span class="c1"></span></code></pre>
<p>Second, if instead the asserted type <code>T</code> is an interface type, then the type assertion checks whether <code>x</code>’s dynamic type <em>satisfies</em> <code>T</code>. If this check succeeds, the dynamic value is not extracted; the result is still an interface value with the same type and value components, but the result has the interface type <code>T</code>. In other words, a type assertion to an interface type changes the type of the expression, making a different (and usually larger) set of methods accessible, but it preserves the dynamic type and value components inside the interface value.</p>
<p>After the first type assertion below, both <code>w</code> and <code>rw</code> hold <code>os.Stdout</code> so each has a dynamic type of <code>*os.File</code>, but <code>w</code>, an <code>io.Writer</code>, exposes only the file’s <code>Write</code> method, whereas <code>rw</code> exposes its <code>Read</code> method too.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">rw</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span> <span class="c1">// success: *os.File has both Read and Write
</span><span class="c1"></span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">ByteCounter</span><span class="p">)</span>
<span class="nx">rw</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span>  <span class="c1">// panic: *ByteCounter has no Read method
</span><span class="c1"></span></code></pre>
<p>No matter what type was asserted, if the operand is a nil interface value, the type assertion fails. A type assertion to a less restrictive interface type (one with fewer methods) is rarely needed, as it behaves just like an assignment, except in the nil case.</p>
<pre class="code" ><code class="chroma" ><span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span>             <span class="c1">// io.ReadWriter is assignable to io.Writer
</span><span class="c1"></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="c1">// fails only if rw == nil
</span><span class="c1"></span></code></pre>
<p>Often we’re not sure of the dynamic type of an interface value, and we’d like to test whether it is some particular type. If the type assertion appears in an assignment in which two results are expected, such as the following declarations, the operation does not panic on failure but instead returns an additional second result, a boolean indicating success:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// success: ok, f == os.Stdout
</span><span class="c1"></span><span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// failure: !ok, b == nil
</span><span class="c1"></span></code></pre>
<p>The second result is conventionally assigned to a variable named <code>ok</code>. If the operation failed, <code>ok</code> is false, and the first result is equal to the zero value of the asserted type, which in this example is a nil <code>*bytes.Buffer</code>.</p>
<p>The <code>ok</code> result is often immediately used to decide what to do next. The extended form of the if statement makes this quite compact:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...use f...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>When the operand of a type assertion is a variable, rather than invent another name for the new local variable, you’ll sometimes see the original name reused, shadowing the original, like this:</p>
<pre class="code" ><code class="chroma" ><span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...use w...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<h3 id="section-7.11" >Discriminating Errors with Type Assertions</h3>
<div class="hBody-3" >
<p>Consider the set of errors returned by file operations in the <code>os</code> package. I/O can fail for any number of reasons, but three kinds of failure often must be handled differently: file already exists (for create operations), file not found (for read operations), and permission denied. The <code>os</code> package provides these three helper functions to classify the failure indicated by a given <code>error</code> value:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">os</span>

<span class="kd">func</span> <span class="nx">IsExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsPermission</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre>
<p>A naïve implementation of one of these predicates might check that the error message contains a certain substring,</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="c1">// NOTE: not robust!
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="s">&#34;file does not exist&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>but because the logic for handling I/O errors can vary from one platform to another, this approach is not robust and the same failure may be reported with a variety of different error messages. Checking for substrings of error messages may be useful during testing to ensure that functions fail in the expected manner, but it’s inadequate for production code.</p>
<p>A more reliable approach is to represent structured error values using a dedicated type. The os package defines a type called <code>PathError</code> to describe failures involving an operation on a file path, like <code>Open</code> or <code>Delete</code>, and a variant called <code>LinkError</code> to describe failures of operations involving two file paths, like <code>Symlink</code> and <code>Rename</code>. Here’s <code>os.PathError</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">os</span>

<span class="c1">// PathError records an error and the operation and file path that caused it.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Op</span>   <span class="kt">string</span>
  <span class="nx">Path</span> <span class="kt">string</span>
  <span class="nx">Err</span>  <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">PathError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Op</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Path</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>Most clients are oblivious to <code>PathError</code> and deal with all errors in a uniform way by calling their <code>Error</code> methods. Although <code>PathError</code>’s <code>Error</code> method forms a message by simply concatenating the fields, <code>PathError</code>’s structure preserves the underlying components of the error. Clients that need to distinguish one kind of failure from another can use a type assertion to detect the specific type of the error; the specific type provides more detail than a simple string.</p>
<pre class="code" ><code class="chroma" ><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;/no/such/file&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// &#34;open /no/such/file: No such file or directory&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// &amp;os.PathError{Op:&#34;open&#34;, Path:&#34;/no/such/file&#34;, Err:0x2}
</span><span class="c1"></span></code></pre>
<p>That’s how the three helper functions work. For example, <code>IsNotExist</code>, shown below, reports whether an error is equal to <code>syscall.ENOENT</code> (<a href="#section-7.8" >§7.8</a>) or to the distinguished error <code>os.ErrNotExist</code> (see <code>io.EOF</code> in <a href="#section-5.4.2" >§5.4.2</a>), or is a <code>*PathError</code> whose underlying error is one of those two.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;errors&#34;</span>
  <span class="s">&#34;syscall&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ErrNotExist</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&#34;file does not exist&#34;</span><span class="p">)</span>

<span class="c1">// IsNotExist returns a boolean indicating whether the error is known to
</span><span class="c1">// report that a file or directory does not exist. It is satisfied by
</span><span class="c1">// ErrNotExist as well as some syscall errors.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">pe</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">PathError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">pe</span><span class="p">.</span><span class="nx">Err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ENOENT</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrNotExist</span>
<span class="p">}</span>
</code></pre>
<p>And here it is in action:</p>
<pre class="code" ><code class="chroma" ><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;/no/such/file&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span></code></pre>
<p>Of course, <code>PathError</code>’s structure is lost if the error message is combined into a larger string, for instance by a call to <code>fmt.Errorf</code>. Error discrimination must usually be done immediately after the failing operation, before an error is propagated to the caller.</p>
</div>
<h3 id="section-7.12" >Querying Behaviors with Interface Type Assertions</h3>
<div class="hBody-3" >
<p>The logic below is similar to the part of the <code>net/http</code> web server responsible for writing HTTP header fields such as <code>&#34;Content-type: text/html&#34;</code>. The <code>io.Writer</code> <code>w</code> represents the HTTP response; the bytes written to it are ultimately sent to someone’s web browser.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Content-Type: &#34;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">contentType</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Because the <code>Write</code> method requires a byte slice, and the value we wish to write is a string, a <code>[]byte(...)</code> conversion is required. This conversion allocates memor y and makes a copy, but the copy is thrown away almost immediately after. Let’s pretend that this is a core part of the web server and that our profiling has revealed that this memory allocation is slowing it down. Can we avoid allocating memory here?</p>
<p>The <code>io.Writer</code> interface tells us only one fact about the concrete type that <code>w</code> holds: that bytes may be written to it. If we look behind the curtains of the <code>net/http</code> package, we see that the dynamic type that <code>w</code> holds in this program also has a <code>WriteString</code> method that allows strings to be efficiently written to it, avoiding the need to allocate a temporary copy. (This may seem like a shot in the dark, but a number of important types that satisfy <code>io.Writer</code> also have a <code>WriteString</code> method, including <code>*bytes.Buffer</code>, <code>*os.File</code> and <code>*bufio.Writer</code>.)</p>
<p>We cannot assume that an arbitrary <code>io.Writer</code> <code>w</code> also has the <code>WriteString</code> method. But we can define a new interface that has just this method and use a type assertion to test whether the dynamic type of <code>w</code> satisfies this new interface.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// writeString writes s to w.
</span><span class="c1">// If w has a WriteString method, it is invoked instead of w.Write.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">stringWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">WriteString</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">sw</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">stringWriter</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// avoid a copy
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// allocate temporary copy
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Content-Type: &#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>To avoid repeating ourselves, we’ve moved the check into the utility function <code>writeString</code>, but it is so useful that the standard library provides it as <code>io.WriteString</code>. It is the recommended way to write a string to an <code>io.Writer</code>.</p>
<p>What’s curious in this example is that there is no standard interface that defines the <code>WriteString</code> method and specifies its required behavior. Furthermore, whether or not a concrete type satisfies the <code>stringWriter</code> interface is determined only by its methods, not by any declared relationship between it and the interface type. What this means is that the technique above relies on the assumption that <em>if</em> a type satisfies the interface below, <em>then</em> <code>WriteString(s)</code> must have the same effect as <code>Write([]byte(s))</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
  <span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Although <code>io.WriteString</code> documents its assumption, few functions that call it are likely to document that they too make the same assumption. Defining a method of a particular type is taken as an implicit assent for a certain behavioral contract. Newcomers to Go, especially those from a background in strongly typed languages, may find this lack of explicit intention unsettling, but it is rarely a problem in practice. With the exception of the empty interface <code>interface{}</code>, interface types are seldom satisfied by unintended coincidence.</p>
<p>The <code>writeString</code> function above uses a type assertion to see whether a value of a general interface type also satisfies a more specific interface type, and if so, it uses the behaviors of the specific interface. This technique can be put to good use whether or not the queried interface is standard like <code>io.ReadWriter</code> or user-defined like <code>stringWriter</code>.</p>
<p>It’s also how <code>fmt.Fprintf</code> distinguishes values that satisfy <code>error</code> or <code>fmt.Stringer</code> from all other values. Within <code>fmt.Fprintf</code>, there is a step that converts a single operand to a string, something like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">formatOneValue</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// ...all other types...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>If <code>x</code> satisfies either of the two interfaces, that determines the formatting of the value. If not, the default case handles all other types more or less uniformly using reflection; we’ll find out how in <a href="#chapter-12" >Chapter 12</a>.</p>
<p>Again, this makes the assumption that any type with a <code>String</code> method satisfies the behavioral contract of <code>fmt.Stringer</code>, which is to return a string suitable for printing.</p>
</div>
<h3 id="section-7.13" >Type Switches</h3>
<div class="hBody-3" >
<p>Interfaces are used in two distinct styles. In the first style, exemplified by <code>io.Reader</code>, <code>io.Writer</code>, <code>fmt.Stringer</code>, <code>sort.Interface</code>, <code>http.Handler</code>, and <code>error</code>, an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation details and intrinsic operations of those concrete types. The emphasis is on the methods, not on the concrete types.</p>
<p>The second style exploits the ability of an interface value to hold values of a variety of concrete types and considers the interface to be the <em>union</em> of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently. In this style, the emphasis is on the concrete types that satisfy the interface, not on the interface’s methods (if indeed it has any), and there is no hiding of information. We’ll describe interfaces used this way as <em>discriminated unions</em>.</p>
<p>If you’re familiar with object-oriented programming, you may recognize these two styles as <em>subtype polymorphism</em> and <em>ad hoc polymorphism</em>, but you needn’t remember those terms. For the remainder of this chapter, we’ll present examples of the second style.</p>
<p>Go’s API for querying an SQL database, like those of other languages, lets us cleanly separate the fixed part of a query from the variable parts. An example client might look like this:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;database/sql&#34;</span>

<span class="kd">func</span> <span class="nx">listTracks</span><span class="p">(</span><span class="nx">db</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">artist</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">Exec</span><span class="p">(</span>
    <span class="s">&#34;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&#34;</span><span class="p">,</span>
    <span class="nx">artist</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span><span class="p">)</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The <code>Exec</code> method replaces each <code>&#39;?&#39;</code> in the query string with an SQL literal denoting the corresponding argument value, which may be a boolean, a number, a string, or <code>nil</code>. Constructing queries this way helps avoid SQL injection attacks, in which an adversary takes control of the query by exploiting improper quotation of input data. Within <code>Exec</code>, we might find a function like the one below, which converts each argument value to its literal SQL notation.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;NULL&#34;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">int</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">uint</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">bool</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;TRUE&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;FALSE&#34;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// (not shown)
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unexpected type %T: %v&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <code>switch</code> statement simplifies an <code>if</code>-<code>else</code> chain that performs a series of value equality tests.  An analogous <em>type switch</em> statement simplifies an <code>if</code>-<code>else</code> chain of type assertions.</p>
<p>In its simplest form, a type switch looks like an ordinary switch statement in which the operand is <code>x.(type)</code>—that’s literally the keyword <code>type</code>—and each case has one or more types. A type switch enables a multi-way branch based on the interface value’s dynamic type. The <code>nil</code> case matches if <code>x == nil</code>, and the <code>default</code> case matches if no other case does. A type switch for <code>sqlQuote</code> would have these cases:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>       <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span> <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>      <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="kt">string</span><span class="p">:</span>    <span class="c1">// ...
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>        <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>As with an ordinary switch statement (<a href="#section-1.8" >§1.8</a>), cases are considered in order and, when a match is found, the case’s body is executed. Case order becomes significant when one or more case types are interfaces, since then there is a possibility of two cases matching. The position of the <code>default</code> case relative to the others is immaterial. No <code>fallthrough</code> is allowed.</p>
<p>Notice that in the original function, the logic for the <code>bool</code> and <code>string</code> cases needs access to the value extracted by the type assertion. Since this is typical, the type switch statement has an extended form that binds the extracted value to a new variable within each case:</p>
<pre class="code" ><code class="chroma" ><span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>Here we’ve called the new variables <code>x</code> too; as with type assertions, reuse of variable names is common. Like a <code>switch</code> statement, a type switch implicitly creates a lexical block, so the declaration of the new variable called <code>x</code> does not conflict with a variable <code>x</code> in an outer block. Each <code>case</code> also implicitly creates a separate lexical block.</p>
<p>Rewriting <code>sqlQuote</code> to use the extended form of type switch makes it significantly clearer:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">&#34;NULL&#34;</span>
  <span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// x has type interface{} here.
</span><span class="c1"></span>  <span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;TRUE&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;FALSE&#34;</span>
  <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// (not shown)
</span><span class="c1"></span>  <span class="k">default</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unexpected type %T: %v&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In this version, within the block of each single-type case, the variable <code>x</code> has the same type as the case. For instance, <code>x</code> has type <code>bool</code> within the <code>bool</code> case and <code>string</code> within the <code>string</code> case. In all other cases, <code>x</code> has the (interface) type of the <code>switch</code> operand, which is <code>interface{}</code> in this example. When the same action is required for multiple cases, like <code>int</code> and <code>uint</code>, the type switch makes it easy to combine them.</p>
<p>Although <code>sqlQuote</code> accepts an argument of any type, the function runs to completion only if the argument’s type matches one of the cases in the type switch; otherwise it panics with an <q>unexpected type</q> message. Although the type of <code>x</code> is <code>interface{}</code>, we consider it a <em>discriminated union</em> of <code>int</code>, <code>uint</code>, <code>bool</code>, <code>string</code>, and <code>nil</code>.</p>
</div>
<h3 id="section-7.14" >Example: Token-Based XML Decoding</h3>
<div class="hBody-3" >
<p><a href="#section-4.5" >Section 4.5</a> showed how to decode JSON documents into Go data structures with the <code>Marshal</code> and <code>Unmarshal</code> functions from the <code>encoding/json</code> package. The <code>encoding/xml</code> package provides a similar API. This approach is convenient when we want to construct a representation of the document tree, but that’s unnecessary for many programs. The <code>encoding/xml</code> package also provides a lower-level <em>token-based</em> API for decoding XML. In the token-based style, the parser consumes the input and produces a stream of tokens, primarily of four kinds—<code>StartElement</code>, <code>EndElement</code>, <code>CharData</code>, and <code>Comment</code>—each being a concrete type in the <code>encoding/xml</code> package. Each call to <code>(*xml.Decoder).Token</code> returns a token.</p>
<p>The relevant parts of the API are shown here:</p>
<div class="figure" >
<h1 class="figure"><code>encoding/xml</code></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">xml</span>

<span class="kd">type</span> <span class="nx">Name</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Local</span> <span class="kt">string</span> <span class="c1">// e.g., &#34;Title&#34; or &#34;id&#34;
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Attr</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// e.g., name=&#34;value&#34;
</span><span class="c1"></span>  <span class="nx">Name</span> <span class="nx">Name</span>
  <span class="nx">Value</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// A Token includes StartElement, EndElement, CharData,
</span><span class="c1">// and Comment, plus a few esoteric types (not shown).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Token</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">StartElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// e.g., &lt;name&gt;
</span><span class="c1"></span>  <span class="nx">Name</span> <span class="nx">Name</span>
  <span class="nx">Attr</span> <span class="p">[]</span><span class="nx">Attr</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">EndElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">Name</span> <span class="nx">Name</span> <span class="p">}</span> <span class="c1">// e.g., &lt;/name&gt;
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CharData</span> <span class="p">[]</span><span class="kt">byte</span>                 <span class="c1">// e.g., &lt;p&gt;CharData&lt;/p&gt;
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Comment</span> <span class="p">[]</span><span class="kt">byte</span>                  <span class="c1">// e.g., &lt;!-- Comment --&gt;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Decoder</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Decoder</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Decoder</span><span class="p">)</span> <span class="nx">Token</span><span class="p">()</span> <span class="p">(</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="c1">// returns next Token in sequence
</span><span class="c1"></span></code></pre>
</div>
<p>The <code>Token</code> interface, which has no methods, is also an example of a discriminated union. The purpose of a traditional interface like <code>io.Reader</code> is to hide details of the concrete types that satisfy it so that new implementations can be created; each concrete type is treated uniformly.  By contrast, the set of concrete types that satisfy a discriminated union is fixed by the design and exposed, not hidden. Discriminated union types have few methods; functions that operate on them are expressed as a set of cases using a type switch, with different logic in each case.</p>
<p>The <code class="command" >xmlselect</code> program below extracts and prints the text found beneath certain elements in an XML document tree. Using the API above, it can do its job in a single pass over the input without ever materializing the tree.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/xmlselect/main.go" >gopl.io/ch7/xmlselect</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Xmlselect prints the text of selected elements of an XML document.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;encoding/xml&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dec</span> <span class="o">:=</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// stack of element names
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">tok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">Token</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;xmlselect: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">tok</span> <span class="o">:=</span> <span class="nx">tok</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">StartElement</span><span class="p">:</span>
      <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">Name</span><span class="p">.</span><span class="nx">Local</span><span class="p">)</span> <span class="c1">// push
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">EndElement</span><span class="p">:</span>
      <span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// pop
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">CharData</span><span class="p">:</span>
      <span class="k">if</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s: %s\n&#34;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">),</span> <span class="nx">tok</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// containsAll reports whether x contains the elements of y, in order.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
      <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Each time the loop in <code>main</code> encounters a <code>StartElement</code>, it pushes the element’s name onto a stack, and for each <code>EndElement</code> it pops the name from the stack. The API guarantees that the sequence of <code>StartElement</code> and <code>EndElement</code> tokens will be properly matched, even in illformed documents. <code>Comments</code> are ignored. When <code>xmlselect</code> encounters a <code>CharData</code>, it prints the text only if the stack contains all the elements named by the command-line arguments, in order.</p>
<p>The command below prints the text of any <code>h2</code> elements appearing beneath two levels of <code>div</code> elements. Its input is the XML specification, itself an XML document.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 <span class="p">|</span>
./xmlselect div div h2
</span><span class="out" >html body div div h2: 1 Introduction
html body div div h2: 2 Documents
html body div div h2: 3 Logical Structures
html body div div h2: 4 Physical Structures
html body div div h2: 5 Conformance
html body div div h2: 6 Notation
html body div div h2: A References
html body div div h2: B Definitions for Character Normalization
...
</span></code></pre>
<p><b>Exercise 7.17</b>: Extend <code class="command" >xmlselect</code> so that elements may be selected not just by name, but by their attributes too, in the manner of CSS, so that, for instance, an element like <code>&lt;div id=&#34;page&#34; class=&#34;wide&#34;&gt;</code> could be selected by a matching <code>id</code> or <code>class</code> as well as its name.</p>
<p><b>Exercise 7.18</b>: Using the token-based decoder API, write a program that will read an arbitrary XML document and construct a tree of generic nodes that represents it. Nodes are of two kinds: <code>CharData</code> nodes represent text strings, and <code>Element</code> nodes represent named elements and their attributes. Each element node has a slice of child nodes.</p>
<p>You may find the following declarations helpful.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;encoding/xml&#34;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// CharData or *Element
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">CharData</span> <span class="kt">string</span>

<span class="kd">type</span> <span class="nx">Element</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Type</span>     <span class="nx">xml</span><span class="p">.</span><span class="nx">Name</span>
  <span class="nx">Attr</span>     <span class="p">[]</span><span class="nx">xml</span><span class="p">.</span><span class="nx">Attr</span>
  <span class="nx">Children</span> <span class="p">[]</span><span class="nx">Node</span>
<span class="p">}</span>
</code></pre>
</div>
<h3 id="section-7.15" >A Few Words of Advice</h3>
<div class="hBody-3" >
<p>When designing a new package, novice Go programmers often start by creating a set of interfaces and only later define the concrete types that satisfy them. This approach results in many interfaces, each of which has only a single implementation. Don’t do that. Such interfaces are unnecessary abstractions; they also have a run-time cost. You can restrict which methods of a type or fields of a struct are visible outside a package using the export mechanism (<a href="#section-6.6" >§6.6</a>).  Interfaces are only needed when there are two or more concrete types that must be dealt with in a uniform way.</p>
<p>We make an exception to this rule when an interface is satisfied by a single concrete type but that type cannot live in the same package as the interface because of its dependencies. In that case, an interface is a good way to decouple two packages.</p>
<p>Because interfaces are used in Go only when they are satisfied by two or more types, they necessarily abstract away from the details of any particular implementation. The result is smaller interfaces with fewer, simpler methods, often just one as with <code>io.Writer</code> or <code>fmt.Stringer</code>. Small interfaces are easier to satisfy when new types come along. A good rule of thumb for interface design is <em>ask only for what you need</em>.</p>
<p>This concludes our tour of methods and interfaces. Go has great support for the objectoriented style of programming, but this does not mean you need to use it exclusively. Not everything need be an object; standalone functions have their place, as do unencapsulated data types. Observe that together, the examples in the first five chapters of this book call no more than two dozen methods, like <code>input.Scan</code>, as opposed to ordinary function calls like <code>fmt.Printf</code>.</p>
</div>
<h2 id="chapter-8" >Goroutines and Channels</h2>
<div class="hBody-2" >
<p>Concurrent programming, the expression of a program as a composition of several autonomous activities, has never been more important than it is today. Web servers handle requests for thousands of clients at once. Tablet and phone apps render animations in the user interface while simultaneously performing computation and network requests in the background. Even traditional batch problems—read some data, compute, write some output—use concurrency to hide the latency of I/O operations and to exploit a modern computer’s many processors, which every year grow in number but not in speed.</p>
<p>Go enables two styles of concurrent programming. This chapter presents goroutines and channels, which support <em>communicating sequential processes</em> or <span class="acronym" >CSP</span>, a model of concurrency in which values are passed between independent activities (goroutines) but variables are for the most part confined to a single activity. <a href="#chapter-9" >Chapter 9</a> covers some aspects of the more traditional model of <em>shared memory multithreading</em>, which will be familiar if you’ve used threads in other mainstream languages. <a href="#chapter-9" >Chapter 9</a> also points out some important hazards and pitfalls of concurrent programming that we won’t delve into in this chapter.</p>
<p>Even though Go’s support for concurrency is one of its great strengths, reasoning about concurrent programs is inherently harder than about sequential ones, and intuitions acquired from sequential programming may at times lead us astray. If this is your first encounter with concurrency, we recommend spending a little extra time thinking about the examples in these two chapters.</p>
</div>
<h3 id="section-8.1" >Goroutines</h3>
<div class="hBody-3" >
<p>In Go, each concurrently executing activity is called a <em>goroutine</em>. Consider a program that has two functions, one that does some computation and one that writes some output, and assume that neither function calls the other. A sequential program may call one function and then call the other, but in a <em>concurrent</em> program with two or more goroutines, calls to <em>both</em> functions can be active at the same time. We’ll see such a program in a moment.</p>
<p>If you have used operating system threads or threads in other languages, then you can assume for now that a goroutine is similar to a thread, and you’ll be able to write correct programs. The differences between threads and goroutines are essentially quantitative, not qualitative, and will be described in <a href="#section-9.8" >Section 9.8</a>.</p>
<p>When a program starts, its only goroutine is the one that calls the <code>main</code> function, so we call it the <em>main goroutine</em>. New goroutines are created by the <code>go</code> statement. Syntactically, a <code>go</code> statement is an ordinary function or method call prefixed by the keyword <code>go</code>. A <code>go</code> statement causes the function to be called in a newly created goroutine. The <code>go</code> statement itself completes immediately:</p>
<pre class="code" ><code class="chroma" ><span class="nx">f</span><span class="p">()</span>    <span class="c1">// call f(); wait for it to return
</span><span class="c1"></span><span class="k">go</span> <span class="nx">f</span><span class="p">()</span> <span class="c1">// create a new goroutine that calls f(); don&#39;t wait
</span><span class="c1"></span></code></pre>
<p>In the example below, the main goroutine computes the 45th Fibonacci number. Since it uses the terribly inefficient recursive algorithm, it runs for an appreciable time, during which we’d like to provide the user with a visual indication that the program is still running, by displaying an animated textual <q>spinner.</q></p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/spinner/main.go" >gopl.io/ch8/spinner</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">spinner</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">45</span>
  <span class="nx">fibN</span> <span class="o">:=</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// slow
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\rFibonacci(%d) = %d\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fibN</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">spinner</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">`-\|/`</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;\r%c&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>After several seconds of animation, the <code>fib(45)</code> call returns and the <code>main</code> function prints its result:</p>
<div class="pre-block" >
<pre class="pre" >Fibonacci(45) = 1134903170
</pre>
</div>
<p>The <code>main</code> function then returns. When this happens, all goroutines are abruptly terminated and the program exits. Other than by returning from <code>main</code> or exiting the program, there is no programmatic way for one goroutine to stop another, but as we will see later, there are ways to communicate with a goroutine to request that it stop itself.</p>
<p>Notice how the program is expressed as the composition of two autonomous activities, spinning and Fibonacci computation. Each is written as a separate function but both make progress concurrently.</p>
</div>
<h3 id="section-8.2" >Example: Concurrent Clock Server</h3>
<div class="hBody-3" >
<p>Networking is a natural domain in which to use concurrency since servers typically handle many connections from their clients at once, each client being essentially independent of the others. In this section, we’ll introduce the <code>net</code> package, which provides the components for building networked client and server programs that communicate over TCP, UDP, or Unix domain sockets. The <code>net/http</code> package we’ve been using since <a href="#chapter-1" >Chapter 1</a> is built on top of functions from the <code>net</code> package.</p>
<p>Our first example is a sequential clock server that writes the current time to the client once per second:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/clock1/clock.go" >gopl.io/ch8/clock1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Clock1 is a TCP server that periodically writes the time.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net&#34;</span>
  <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted
</span><span class="c1"></span>      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle one connection at a time
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Format</span><span class="p">(</span><span class="s">&#34;15:04:05\n&#34;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="c1">// e.g., client disconnected
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>Listen</code> function creates a <code>net.Listener</code>, an object that listens for incoming connections on a network port, in this case TCP port <code>localhost:8000</code>. The listener’s <code>Accept</code> method blocks until an incoming connection request is made, then returns a <code>net.Conn</code> object representing the connection.</p>
<p>The <code>handleConn</code> function handles one complete client connection. In a loop, it writes the current time, <code>time.Now()</code>, to the client. Since <code>net.Conn</code> satisfies the <code>io.Writer</code> interface, we can write directly to it. The loop ends when the write fails, most likely because the client has disconnected, at which point <code>handleConn</code> closes its side of the connection using a deferred call to <code>Close</code> and goes back to waiting for another connection request.</p>
<p>The <code>time.Time.Format</code> method provides a way to format date and time information by example. Its argument is a template indicating how to format a reference time, specifically <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>. The reference time has eight components (day of the week, month, day of the month, and so on). Any collection of them can appear in the <code>Format</code> string in any order and in a number of formats; the selected components of the date and time will be displayed in the selected formats. Here we are just using the hour, minute, and second of the time. The <code>time</code> package defines templates for many standard time formats, such as <code>time.RFC1123</code>. The same mechanism is used in reverse when parsing a time using <code>time.Parse</code>.</p>
<p>To connect to the server, we’ll need a client program such as <code class="command" >nc</code> (<q>netcat</q>), a standard utility program for manipulating network connections:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/clock1
</span><span class="in" ><span class="prompt" >&gt; </span>./clock1 <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>nc localhost <span class="m">8000</span>
</span><span class="out" >13:58:54
13:58:55
13:58:56
13:58:57
^C
</span></code></pre>
<p>The client displays the time sent by the server each second until we interrupt the client with Control-C, which on Unix systems is echoed as <code>^C</code> by the shell. If <code class="command" >nc</code> or <code class="command" >netcat</code> is not installed on your system, you can use <code class="command" >telnet</code> or this simple Go version of <code class="command" >netcat</code> that uses <code>net.Dial</code> to connect to a TCP server:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/netcat1/netcat.go" >gopl.io/ch8/netcat1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Netcat1 is a read-only TCP client.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This program reads data from the connection and writes it to the standard output until an end-of-file condition or an error occurs. The <code>mustCopy</code> function is a utility used in several examples in this section. Let’s run two clients at the same time on different terminals, one shown to the left and one to the right:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/netcat1
</span><span class="in" ><span class="prompt" >&gt; </span>./netcat1
</span><span class="out" >13:58:54
13:58:55
13:58:56
^C
</span></code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>killall clock1
</span></code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./netcat1
</span><span class="out" >
13:58:57
13:58:58
13:58:59
^C
</span></code></pre>
</div>
</div>
<p>The <code class="command" >killall</code> command is a Unix utility that kills all processes with the given name.</p>
<p>The second client must wait until the first client is finished because the server is <em>sequential</em>; it deals with only one client at a time. Just one small change is needed to make the server concurrent: adding the <code>go</code> keyword to the call to <code>handleConn</code> causes each call to run in its own goroutine.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/clock2/clock.go" >gopl.io/ch8/clock2</a></h1>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted
</span><span class="c1"></span>    <span class="k">continue</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle connections concurrently
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>Now, multiple clients can receive the time at once:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/clock2
</span><span class="in" ><span class="prompt" >&gt; </span>./clock2 <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/netcat1
</span><span class="in" ><span class="prompt" >&gt; </span>./netcat1
</span><span class="out" >14:02:54
14:02:55
14:02:56
14:02:57
14:02:58
14:02:59
14:03:00
14:03:01
^C
</span></code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>killall clock1
</span></code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./netcat1
</span><span class="out" >14:02:55
14:02:56
^C
</span></code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./netcat1
</span><span class="out" >14:03:00
14:03:01
14:03:02
^C
</span></code></pre>
</div>
</div>
<p><b>Exercise 8.1</b>: Modify <code class="command" >clock2</code> to accept a port number, and write a program, <code class="command" >clockwall</code>, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business offices. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">TZ</span><span class="o">=</span>US/Eastern    ./clock2 -port <span class="m">8010</span> <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">TZ</span><span class="o">=</span>Europe/London ./clock2 -port <span class="m">8020</span> <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">TZ</span><span class="o">=</span>Asia/Tokyo    ./clock2 -port <span class="m">8030</span> <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>clockwall <span class="nv">NewYork</span><span class="o">=</span>localhost:8010 <span class="nv">London</span><span class="o">=</span>localhost:8020 <span class="nv">Tokyo</span><span class="o">=</span>localhost:8030
</span></code></pre>
<p><b>Exercise 8.2</b>: Implement a concurrent File Transfer Protocol (FTP) server. The server should interpret commands from each client such as <code class="command" >cd</code> to change directory, <code class="command" >ls</code> to list a directory, <code class="command" >get</code> to send the contents of a file, and <code>close</code> to close the connection. You can use the standard <code class="command" >ftp</code> command as the client, or write your own.</p>
</div>
<h3 id="section-8.3" >Example: Concurrent Echo Server</h3>
<div class="hBody-3" >
<p>The clock server used one goroutine per connection. In this section, we’ll build an echo server that uses multiple goroutines per connection. Most echo servers merely write whatever they read, which can be done with this trivial version of <code>handleConn</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>A more interesting echo server might simulate the reverberations of a real echo, with the response loud at first (<code>&#34;HELLO!&#34;</code>), then moderate (<code>&#34;Hello!&#34;</code>)  after a delay, then quiet (<code>&#34;hello!&#34;</code>) before fading to nothing, as in this version of <code>handleConn</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/reverb1/reverb.go" >gopl.io/ch8/reverb1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">shout</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">,</span> <span class="nx">shout</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()
</span><span class="c1"></span>  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>We’ll need to upgrade our client program so that it sends terminal input to the server while also copying the server response to the output, which presents another opportunity to use concurrency:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/netcat2/netcat.go" >gopl.io/ch8/netcat2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">go</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>While the main goroutine reads the standard input and sends it to the server, a second goroutine reads and prints the server’s response. When the main goroutine encounters the end of the input, for example, after the user types Control-D (<code>^D</code>) at the terminal (or the equivalent Control-Z on Microsoft Windows), the program stops, even if the other goroutine still has work to do. (We’ll see how to make the program wait for both sides to finish once we’ve introduced channels in <a href="#section-8.4.1" >Section 8.4.1</a>.)</p>
<p>In the session below, the client’s input is left-aligned and the server’s responses are indented.  The client shouts at the echo server three times:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/reverb1
</span><span class="in" ><span class="prompt" >&gt; </span>./reverb1 <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/netcat2
</span><span class="in" ><span class="prompt" >&gt; </span>./netcat2
</span><span class="out" >Hello?
    HELLO?
    Hello?
    hello?
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    is there anybody there?
    YOOO-HOOO!
    Yooo-hooo!
    yooo-hooo!
^D
</span><span class="in" ><span class="prompt" >&gt; </span>killall reverb1
</span></code></pre>
<p>Notice that the third shout from the client is not dealt with until the second shout has petered out, which is not very realistic. A real echo would consist of the <em>composition</em> of the three independent shouts. To simulate it, we’ll need more goroutines. Again, all we need to do is add the <code>go</code> keyword, this time to the call to <code>echo</code></p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/reverb2/reverb.go" >gopl.io/ch8/reverb2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()
</span><span class="c1"></span>  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The arguments to the function started by <code>go</code> are evaluated when the <code>go</code> statement itself is executed; thus <code>input.Text()</code> is evaluated in the main goroutine.  Now the echoes are concurrent and overlap in time:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/reverb2
</span><span class="in" ><span class="prompt" >&gt; </span>./reverb2 <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>./netcat2
</span><span class="out" >Is there anybody there?
    IS THERE ANYBODY THERE?

Yooo-hooo!
    Is there anybody there?
    YOOO-HOOO!
    is there anybody there?
    Yooo-hooo!
    yooo-hooo!
^D
</span><span class="in" ><span class="prompt" >&gt; </span>killall reverb2
</span></code></pre>
<p>All that was required to make the server use concurrency, not just to handle connections from multiple clients but even within a single connection, was the insertion of two <code>go</code> keywords.</p>
<p>However in adding these keywords, we had to consider carefully that it is safe to call methods of <code>net.Conn</code> concurrently, which is not true for most types. We’ll discuss the crucial concept of <em>concurrency safety</em> in the next chapter.</p>
</div>
<h3 id="section-8.4" >Channels</h3>
<div class="hBody-3" >
<p>If goroutines are the activities of a concurrent Go program, <em>channels</em> are the connections between them. A channel is a communication mechanism that lets one goroutine send values to another goroutine. Each channel is a conduit for values of a particular type, called the channel’s <em>element type</em>. The type of a channel whose elements have type <code>int</code> is written <code>chan int</code>.</p>
<p>To create a channel, we use the built-in <code>make</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ch has type &#39;chan int&#39;
</span><span class="c1"></span></code></pre>
<p>As with maps, a channel is a <em>reference</em> to the data structure created by <code>make</code>. When we copy a channel or pass one as an argument to a function, we are copying a reference, so caller and callee refer to the same data structure. As with other reference types, the zero value of a channel is <code>nil</code>.</p>
<p>Two channels of the same type may be compared using <code>==</code>. The comparison is true if both are references to the same channel data structure. A channel may also be compared to <code>nil</code>.</p>
<p>A channel has two principal operations, <em>send</em> and <em>receive</em>, collectively known as <em>communications</em>. A send statement transmits a value from one goroutine, through the channel, to another goroutine executing a corresponding receive expression. Both operations are written using the <code>&lt;-</code> operator. In a send statement, the <code>&lt;-</code> separates the channel and value operands. In a receive expression, <code>&lt;-</code> precedes the channel operand. A receive expression whose result is not used is a valid statement.</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span>  <span class="c1">// a send statement
</span><span class="c1"></span>
<span class="nx">x</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// a receive expression in an assignment statement
</span><span class="c1"></span><span class="o">&lt;-</span><span class="nx">ch</span>     <span class="c1">// a receive statement; result is discarded
</span><span class="c1"></span></code></pre>
<p>Channels support a third operation, <em>close</em>, which sets a flag indicating that no more values will ever be sent on this channel; subsequent attempts to send will panic. Receive operations on a closed channel yield the values that have been sent until no more values are left; any receive operations thereafter complete immediately and yield the zero value of the channel’s element type.</p>
<p>To close a channel, we call the built-in <code>close</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</code></pre>
<p>A channel created with a simple call to <code>make</code> is called an <em>unbuffered</em> channel, but <code>make</code> accepts an optional second argument, an integer called the channel’s <em>capacity</em>. If the capacity is nonzero, <code>make</code> creates a <em>buffered</em> channel.</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// unbuffered channel
</span><span class="c1"></span><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// unbuffered channel
</span><span class="c1"></span><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// buffered channel with capacity 3
</span><span class="c1"></span></code></pre>
<p>We’ll look at unbuffered channels first and buffered channels in <a href="#section-8.4.4" >Section 8.4.4</a>.</p>
</div>
<h4 id="section-8.4.1" >Unbuffered Channels</h4>
<div class="hBody-4" >
<p>A send operation on an unbuffered channel blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue. Conversely, if the receive operation was attempted first, the receiving goroutine is blocked until another goroutine performs a send on the same channel.</p>
<p>Communication over an unbuffered channel causes the sending and receiving goroutines to <em>synchronize</em>. Because of this, unbuffered channels are sometimes called <em>synchronous</em> channels.  When a value is sent on an unbuffered channel, the receipt of the value <em>happens before</em> the reawakening of the sending goroutine.</p>
<p>In discussions of concurrency, when we say <em>x happens before y</em>, we don’t mean merely that <em>x</em> occurs earlier in time than <em>y</em>; we mean that it is guaranteed to do so and that all its prior effects, such as updates to variables, are complete and that you may rely on them.</p>
<p>When <em>x</em> neither happens before <em>y</em> nor after <em>y</em>, we say that <em>x is concurrent with y</em>. This doesn’t mean that <em>x</em> and <em>y</em> are necessarily simultaneous, merely that we cannot assume anything about their ordering. As we’ll see in the next chapter, it’s necessary to order certain events during the program’s execution to avoid the problems that arise when two goroutines access the same variable concurrently.</p>
<p>The client program in <a href="#section-8.3" >Section 8.3</a> copies input to the server in its main goroutine, so the client program terminates as soon as the input stream closes, even if the background goroutine is still working. To make the program wait for the background goroutine to complete before exiting, we use a channel to synchronize the two goroutines:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/netcat3/netcat.go" >gopl.io/ch8/netcat3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// signal the main goroutine
</span><span class="c1"></span>  <span class="p">}()</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="o">&lt;-</span><span class="nx">done</span> <span class="c1">// wait for background goroutine to finish
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>When the user closes the standard input stream, <code>mustCopy</code> returns and the main goroutine calls <code>conn.Close()</code>, closing both halves of the network connection. Closing the write half of the connection causes the server to see an end-of-file condition. Closing the read half causes the background goroutine’s call to <code>io.Copy</code> to return a <q>read from closed connection</q> error, which is why we’ve removed the error logging; Exercise 8.3 suggests a better solution. (Notice that the <code>go</code> statement calls a literal function, a common construction.)</p>
<p>Before it returns, the background goroutine logs a message, then sends a value on the <code>done</code> channel. The main goroutine waits until it has received this value before returning. As a result, the program always logs the <code>&#34;done&#34;</code> message before exiting.</p>
<p>Messages sent over channels have two important aspects. Each message has a value, but sometimes the fact of communication and the moment at which it occurs are just as important. We call messages <em>events</em> when we wish to stress this aspect. When the event carries no additional information, that is, its sole purpose is synchronization, we’ll emphasize this by using a channel whose element type is <code>struct{}</code>, though it’s common to use a channel of <code>bool</code> or <code>int</code> for the same purpose since <code>done &lt;- 1</code> is shorter than <code>done &lt;- struct{}{}</code>.</p>
<p><b>Exercise 8.3</b>: In <code class="command" >netcat3</code>, the interface value <code>conn</code> has the concrete type <code>*net.TCPConn</code>, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its <code>CloseRead</code> and <code>CloseWrite</code> methods. Modify the main goroutine of <code class="command" >netcat3</code> to close only the write half of the connection so that the program will continue to print the final echoes from the <code class="command" >reverb1</code> server even after the standard input has been closed.  (Doing this for the <code class="command" >reverb2</code> server is harder; see Exercise 8.4.)</p>
</div>
<h4 id="section-8.4.2" >Pipelines</h4>
<div class="hBody-4" >
<p>Channels can be used to connect goroutines together so that the output of one is the input to another. This is called a <em>pipeline</em>. The program below consists of three goroutines connected by two channels, as shown schematically in Figure 8.1.</p>
<div class="figure" >
<h1 class="figure">Figure 8.1. A three-stage pipeline.</h1>
<figure>
<img src="img/Figure-8.1.jpg" />
</figure>
</div>
<p>The first goroutine, <em>counter</em>, generates the integers 0, 1, 2, ..., and sends them over a channel to the second goroutine, <em>squarer</em>, which receives each value, squares it, and sends the result over another channel to the third goroutine, <em>printer</em>, which receives the squared values and prints them. For clarity of this example, we have intentionally chosen very simple functions, though of course they are too computationally trivial to warrant their own goroutines in a realistic program.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/pipeline1/main.go" >gopl.io/ch8/pipeline1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="c1">// Counter
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Squarer
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
      <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Printer (in main goroutine)
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">squares</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>As you might expect, the program prints the infinite series of squares 0, 1, 4, 9, and so on.  Pipelines like this may be found in long-running server programs where channels are used for lifelong communication between goroutines containing infinite loops. But what if we want to send only a finite number of values through the pipeline?</p>
<p>If the sender knows that no further values will ever be sent on a channel, it is useful to communicate this fact to the receiver goroutines so that they can stop waiting. This is accomplished by <em>closing</em> the channel using the built-in <code>close</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
</code></pre>
<p>After a channel has been closed, any further send operations on it will panic. After the closed channel has been <em>drained</em>, that is, after the last sent element has been received, all subsequent receive operations will proceed without blocking but will yield a zero value. Closing the <code>naturals</code> channel above would cause the squarer’s loop to spin as it receives a never-ending stream of zero values, and to send these zeros to the printer.</p>
<p>There is no way to test directly whether a channel has been closed, but there is a variant of the receive operation that produces two results: the received channel element, plus a boolean value, conventionally called <code>ok</code>, which is <code>true</code> for a successful receive and <code>false</code> for a receive on a closed and drained channel. Using this feature, we can modify the squarer’s loop to stop when the <code>naturals</code> channel is drained and close the <code>squares</code> channel in turn.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Squarer
</span><span class="c1"></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="k">break</span> <span class="c1">// channel was closed and drained
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}()</span>
</code></pre>
<p>Because the syntax above is clumsy and this pattern is common, the language lets us use a <code>range</code> loop to iterate over channels too. This is a more convenient syntax for receiving all the values sent on a channel and terminating the loop after the last one.</p>
<p>In the pipeline below, when the counter goroutine finishes its loop after 100 elements, it closes the <code>naturals</code> channel, causing the squarer to finish its loop and close the <code>squares</code> channel.  (In a more complex program, it might make sense for the counter and squarer functions to defer the calls to <code>close</code> at the outset.) Finally, the main goroutine finishes its loop and the program exits.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/pipeline2/main.go" >gopl.io/ch8/pipeline2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="c1">// Counter
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Squarer
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">naturals</span> <span class="p">{</span>
      <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Printer (in main goroutine)
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">squares</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>You needn’t close every channel when you’ve finished with it. It’s only necessary to close a channel when it is important to tell the receiving goroutines that all data have been sent. A channel that the garbage collector determines to be unreachable will have its resources reclaimed whether or not it is closed. (Don’t confuse this with the close operation for open files. It <em>is</em> important to call the <code>Close</code> method on every file when you’ve finished with it.)</p>
<p>Attempting to close an already-closed channel causes a panic, as does closing a nil channel.  Closing channels has another use as a broadcast mechanism, which we’ll cover in <a href="#section-8.9" >Section 8.9</a>.</p>
</div>
<h4 id="section-8.4.3" >Unidirectional Channel Types</h4>
<div class="hBody-4" >
<p>As programs grow, it is natural to break up large functions into smaller pieces. Our previous example used three goroutines, communicating over two channels, which were local variables of <code>main</code>. The program naturally divides into three functions:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre>
<p>The <code>squarer</code> function, sitting in the middle of the pipeline, takes two parameters, the input channel and the output channel. Both have the same type, but their intended uses are opposite: <code>in</code> is only to be received from, and <code>out</code> is only to be sent to. The names <code>in</code> and <code>out</code> convey this intention, but still, nothing prevents <code>squarer</code> from sending to <code>in</code> or receiving from <code>out</code>.</p>
<p>This arrangement is typical. When a channel is supplied as a function parameter, it is nearly always with the intent that it be used exclusively for sending or exclusively for receiving.</p>
<p>To document this intent and prevent misuse, the Go type system provides <em>unidirectional</em> channel types that expose only one or the other of the send and receive operations. The type <code>chan&lt;- int</code>, a <em>send-only</em> channel of int, allows sends but not receives. Conversely, the type <code>&lt;-chan int, a <em>receive-only</em> channel of <code>int</code>, allows receives but not sends. (The position of the <code>&lt;-</code> arrow relative to the <code>chan</code> keyword is a mnemonic.</code> Violations of this discipline are detected at compile time.</p>
<p>Since the <code>close</code> operation asserts that no more sends will occur on a channel, only the sending goroutine is in a position to call it, and for this reason it is a compile-time error to attempt to close a receive-only channel.</p>
<p>Here’s the squaring pipeline once more, this time with unidirectional channel types:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/pipeline3/main.go" >gopl.io/ch8/pipeline3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="o">*</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="k">go</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
  <span class="k">go</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">squares</span><span class="p">,</span> <span class="nx">naturals</span><span class="p">)</span>
  <span class="nx">printer</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The call <code>counter(naturals)</code> implicitly converts <code>naturals</code>, a value of type <code>chan int</code>, to the type of the parameter, <code>chan&lt;- int</code>. The <code>printer(squares)</code> call does a similar implicit conversion to <code>&lt;-chan int</code>. Conversions from bidirectional to unidirectional channel types are permitted in any assignment. There is no going back, however: once you have a value of a unidirectional type such as <code>chan&lt;- int</code>, there is no way to obtain from it a value of type <code>chan int</code> that refers to the same channel data structure.</p>
</div>
<h4 id="section-8.4.4" >Buffered Channels</h4>
<div class="hBody-4" >
<p>A buffered channel has a queue of elements. The queue’s maximum size is determined when it is created, by the capacity argument to <code>make</code>. The statement below creates a buffered channel capable of holding three <code>string</code> values. Figure 8.2 is a graphical representation of <code>ch</code> and the channel to which it refers.</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<div class="figure" >
<h1 class="figure">Figure 8.2. An empty buffered channel.</h1>
<figure>
<img src="img/Figure-8.2.jpg" />
</figure>
</div>
<p>A send operation on a buffered channel inserts an element at the back of the queue, and a receive operation removes an element from the front. If the channel is full, the send operation blocks its goroutine until space is made available by another goroutine’s receive. Conversely, if the channel is empty, a receive operation blocks until a value is sent by another goroutine.</p>
<p>We can send up to three values on this channel without the goroutine blocking:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;A&#34;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;B&#34;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;C&#34;</span>
</code></pre>
<p>At this point, the channel is full (Figure 8.3), and a fourth send statement would block.</p>
<div class="figure" >
<h1 class="figure">Figure 8.3. A full buffered channel.</h1>
<figure>
<img src="img/Figure-8.3.jpg" />
</figure>
</div>
<p>If we receive one value,</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &#34;A&#34;
</span><span class="c1"></span></code></pre>
<p>the channel is neither full nor empty (Figure 8.4), so either a send operation or a receive operation could proceed without blocking. In this way, the channel’s buffer decouples the sending and receiving goroutines.</p>
<div class="figure" >
<h1 class="figure">Figure 8.4. A partially full buffered channel.</h1>
<figure>
<img src="img/Figure-8.3.jpg" />
</figure>
</div>
<p>In the unlikely event that a program needs to know the channel’s buffer capacity, it can be obtained by calling the built-in <code>cap</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &#34;3&#34;
</span><span class="c1"></span></code></pre>
<p>When applied to a channel, the built-in <code>len</code> function returns the number of elements currently buffered. Since in a concurrent program this information is likely to be stale as soon as it is retrieved, its value is limited, but it could conceivably be useful during fault diagnosis or performance optimization.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &#34;2&#34;
</span><span class="c1"></span></code></pre>
<p>After two more receive operations the channel is empty again, and a fourth would block:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &#34;B&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &#34;C&#34;
</span><span class="c1"></span></code></pre>
<p>In this example, the send and receive operations were all performed by the same goroutine, but in real programs they are usually executed by different goroutines. Novices are sometimes tempted to use buffered channels within a single goroutine as a queue, lured by their pleasingly simple syntax, but this is a mistake. Channels are deeply connected to goroutine scheduling, and without another goroutine receiving from the channel, a sender—and perhaps the whole program—risks becoming blocked forever. If all you need is a simple queue, make one using a slice.</p>
<p>The example below shows an application of a buffered channel. It makes parallel requests to three <code>mirrors</code>, that is, equivalent but geographically distributed servers. It sends their responses over a buffered channel, then receives and returns only the first response, which is the quickest one to arrive. Thus <code>mirroredQuery</code> returns a result even before the two slower servers have responded. (Incidentally, it’s quite normal for several goroutines to send values to the same channel concurrently, as in this example, or to receive from the same channel.)</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">mirroredQuery</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">responses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&#34;asia.gopl.io&#34;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&#34;europe.gopl.io&#34;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&#34;americas.gopl.io&#34;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">responses</span> <span class="c1">// return the quickest response
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">request</span><span class="p">(</span><span class="nx">hostname</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">response</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>Had we used an unbuffered channel, the two slower goroutines would have gotten stuck trying to send their responses on a channel from which no goroutine will ever receive. This situation, called a <em>goroutine leak</em>, would be a bug. Unlike garbage variables, leaked goroutines are not automatically collected, so it is important to make sure that goroutines terminate themselves when no longer needed.</p>
<p>The choice between unbuffered and buffered channels, and the choice of a buffered channel’s capacity, may both affect the correctness of a program. Unbuffered channels give stronger synchronization guarantees because every send operation is synchronized with its corresponding receive; with buffered channels, these operations are decoupled. Also, when we know an upper bound on the number of values that will be sent on a channel, it’s not unusual to create a buffered channel of that size and perform all the sends before the first value is received. Failure to allocate sufficient buffer capacity would cause the program to deadlock.</p>
<p>Channel buffering may also affect program performance. Imagine three cooks in a cake shop, one baking, one icing, and one inscribing each cake before passing it on to the next cook in the assembly line. In a kitchen with little space, each cook that has finished a cake must wait for the next cook to become ready to accept it; this rendezvous is analogous to communication over an unbuffered channel.</p>
<p>If there is space for one cake between each cook, a cook may place a finished cake there and immediately start work on the next; this is analogous to a buffered channel with capacity 1. So long as the cooks work at about the same rate on average, most of these handovers proceed quickly, smoothing out transient differences in their respective rates. More space between cooks—larger buffers—can smooth out bigger transient variations in their rates without stalling the assembly line, such as happens when one cook takes a short break, then later rushes to catch up.</p>
<p>On the other hand, if an earlier stage of the assembly line is consistently faster than the following stage, the buffer between them will spend most of its time full. Conversely, if the later stage is faster, the buffer will usually be empty. A buffer provides no benefit in this case.</p>
<p>The assembly line metaphor is a useful one for channels and goroutines. For example, if the second stage is more elaborate, a single cook may not be able to keep up with the supply from the first cook or meet the demand from the third. To solve the problem, we could hire another cook to help the second, performing the same task but working independently. This is analogous to creating another goroutine communicating over the same channels.</p>
<p>We don’t have space to show it here, but the <code>gopl.io/ch8/cake</code> package simulates this cake shop, with several parameters you can vary. It includes benchmarks (<a href="#section-11.4" >§11.4</a>) for a few of the scenarios described above.</p>
</div>
<h3 id="section-8.5" >Looping in Parallel</h3>
<div class="hBody-3" >
<p>In this section, we’ll explore some common concurrency patterns for executing all the iterations of a loop in parallel. We’ll consider the problem of producing thumbnail-size images from a set of full-size ones. The <code>gopl.io/ch8/thumbnail</code> package provides an <code>ImageFile</code> function that can scale a single image. We won’t show its implementation but it can be downloaded from <a href="http://www.gopl.io/" >gopl.io</a>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/thumbnail/thumbnail_test.go" >gopl.io/ch8/thumbnail</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// ImageFile reads an image from infile and writes
</span><span class="c1">// a thumbnail-size version of it in the same directory.
</span><span class="c1">// It returns the generated file name, e.g. &#34;foo.thumb.jpeg&#34;.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">ImageFile</span><span class="p">(</span><span class="nx">infile</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre>
</div>
<p>The program below loops over a list of image file names and produces a thumbnail for each one:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/thumbnail/thumbnail_test.go" >gopl.io/ch8/thumbnail</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// makeThumbnails makes thumbnails of the specified files.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Obviously the order in which we process the files doesn’t matter, since each scaling operation is independent of all the others. Problems like this that consist entirely of subproblems that are completely independent of each other are described as <em>embarrassingly parallel</em>. Embarrassingly parallel problems are the easiest kind to implement concurrently and enjoy performance that scales linearly with the amount of parallelism.</p>
<p>Let’s execute all these operations in parallel, thereby hiding the latency of the file I/O and using multiple CPUs for the image-scaling computations. Our first attempt at a concurrent version just adds a <code>go</code> keyword. We’ll ignore errors for now and address them later.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// NOTE: incorrect!
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails2</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This version runs really fast—too fast, in fact, since it takes less time than the original, even when the slice of file names contains only a single element. If there’s no parallelism, how can the concurrent version possibly run faster? The answer is that <code>makeThumbnails</code> returns before it has finished doing what it was supposed to do. It starts all the goroutines, one per file name, but doesn’t wait for them to finish.</p>
<p>There is no direct way to wait until a goroutine has finished, but we can change the inner goroutine to report its completion to the outer goroutine by sending an event on a shared channel. Since we know that there are exactly <code>len(filenames)</code> inner goroutines, the outer goroutine need only count that many events before it returns:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// makeThumbnails3 makes thumbnails of the specified files in parallel.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails3</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>      <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Wait for goroutines to complete.
</span><span class="c1"></span>  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="o">&lt;-</span><span class="nx">ch</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notice that we passed the value of <code>f</code> as an explicit argument to the literal function instead of using the declaration of <code>f</code> from the enclosing <code>for</code> loop:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTE: incorrect!
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}()</span>
<span class="p">}</span>
</code></pre>
<p>Recall the problem of loop variable capture inside an anonymous function, described in <a href="#section-5.6.1" >Section 5.6.1</a>. Above, the single variable <code>f</code> is shared by all the anonymous function values and updated by successive loop iterations. By the time the new goroutines start executing the literal function, the <code>for</code> loop may have updated <code>f</code> and started another iteration or (more likely) finished entirely, so when these goroutines read the value of <code>f</code>, they all observe it to have the value of the final element of the slice. By adding an explicit parameter, we ensure that we use the value of <code>f</code> that is current when the <code>go</code> statement is executed.</p>
<p>What if we want to return values from each worker goroutine to the main one? If the call to <code>thumbnail.ImageFile</code> fails to create a file, it returns an error. The next version of <code>makeThumbnails</code> returns the first error it receives from any of the scaling operations:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// makeThumbnails4 makes thumbnails for the specified files in parallel.
</span><span class="c1">// It returns an error if any step failed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails4</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">errors</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="nx">errors</span> <span class="o">&lt;-</span> <span class="nx">err</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errors</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span> <span class="c1">// NOTE: incorrect: goroutine leak!
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>This function has a subtle bug. When it encounters the first non-nil error, it returns the error to the caller, leaving no goroutine draining the <code>errors</code> channel. Each remaining worker goroutine will block forever when it tries to send a value on that channel, and will never terminate. This situation, a goroutine leak (<a href="#section-8.4.4" >§8.4.4</a>), may cause the whole program to get stuck or to run out of memory.</p>
<p>The simplest solution is to use a buffered channel with sufficient capacity that no worker goroutine will block when it sends a message. (An alternative solution is to create another goroutine to drain the channel while the main goroutine returns the first error without delay.)</p>
<p>The next version of <code>makeThumbnails</code> uses a buffered channel to return the names of the generated image files along with any errors.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// makeThumbnails5 makes thumbnails for the specified files in parallel.
</span><span class="c1">// It returns the generated file names in an arbitrary order,
</span><span class="c1">// or an error if any step failed.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails5</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">thumbfiles</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">thumbfile</span> <span class="kt">string</span>
    <span class="nx">err</span>       <span class="kt">error</span>
  <span class="p">}</span>

  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filenames</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">it</span> <span class="nx">item</span>
      <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">it</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="nx">it</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
    <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">thumbfiles</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">thumbfiles</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">thumbfiles</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Our final version of <code>makeThumbnails</code>, below, returns the total number of bytes occupied by the new files. Unlike the previous versions, however, it receives the file names not as a slice but over a channel of strings, so we cannot predict the number of loop iterations.</p>
<p>To know when the last goroutine has finished (which may not be the last one to start), we need to increment a counter before each goroutine starts and decrement it as each goroutine finishes. This demands a special kind of counter, one that can be safely manipulated from multiple goroutines and that provides a way to wait until it becomes zero. This counter type is known as <code>sync.WaitGroup</code>, and the code below shows how to use it:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// makeThumbnails6 makes thumbnails for each file received from the channel.
</span><span class="c1">// It returns the number of bytes occupied by the files it creates.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">makeThumbnails6</span><span class="p">(</span><span class="nx">filenames</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
  <span class="nx">sizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// number of working goroutines
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">// worker
</span><span class="c1"></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
      <span class="nx">thumb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="nx">info</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">thumb</span><span class="p">)</span> <span class="c1">// OK to ignore error
</span><span class="c1"></span>      <span class="nx">sizes</span> <span class="o">&lt;-</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// closer
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
  <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sizes</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">size</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</code></pre>
<p>Note the asymmetry in the <code>Add</code> and <code>Done</code> methods. <code>Add</code>, which increments the counter, must be called before the worker goroutine starts, not within it; otherwise we would not be sure that the <code>Add</code> <em>happens before</em> the <q>closer</q> goroutine calls <code>Wait</code>. Also, <code>Add</code> takes a parameter, but <code>Done</code> does not; it’s equivalent to <code>Add(-1)</code>. We use <code>defer</code> to ensure that the counter is decremented even in the error case. The structure of the code above is a common and idiomatic pattern for looping in parallel when we don’t know the number of iterations.</p>
<p>The <code>sizes</code> channel carries each file size back to the main goroutine, which receives them using a <code>range</code> loop and computes the sum. Observe how we create a closer goroutine that waits for the workers to finish before closing the <code>sizes</code> channel. These two operations, wait and close, must be concurrent with the loop over <code>sizes</code>. Consider the alternatives: if the wait operation were placed in the main goroutine before the loop, it would never end, and if placed after the loop, it would be unreachable since with nothing closing the channel, the loop would never terminate.</p>
<p>Figure 8.5 illustrates the sequence of events in the <code>makeThumbnails6</code> function. The vertical lines represent goroutines. The thin segments indicate sleep, the thick segments activity. The diagonal arrows indicate events that synchronize one goroutine with another. Time flows down. Notice how the main goroutine spends most of its time in the <code>range</code> loop asleep, waiting for a worker to send a value or the closer to close the channel.</p>
<div class="figure" >
<h1 class="figure">Figure 8.5. The sequence of events in <code>makeThumbnails6</code>.</h1>
<figure>
<img src="img/Figure-8.5.jpg" />
</figure>
</div>
<p><b>Exercise 8.4</b>: Modify the <code class="command" >reverb2</code> server to use a <code>sync.WaitGroup</code> per connection to count the number of active <code>echo</code> goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modified <code class="command" >netcat3</code> client from that exercise waits for the final echoes of multiple concurrent shouts, even after the standard input has been closed.</p>
<p><b>Exercise 8.5</b>: Take an existing CPU-bound sequential program, such as the Mandelbrot program of <a href="#section-3.3" >Section 3.3</a> or the 3-D surface computation of <a href="#section-3.2" >Section 3.2</a>, and execute its main loop in parallel using channels for communication. How much faster does it run on a multiprocessor machine? What is the optimal number of goroutines to use?</p>
</div>
<h3 id="section-8.6" >Example: Concurrent Web Crawler</h3>
<div class="hBody-3" >
<p>In <a href="#section-5.6" >Section 5.6</a>, we made a simple web crawler that explored the link graph of the web in breadth-first order. In this section, we’ll make it concurrent so that independent calls to <code>crawl</code> can exploit the I/O parallelism available in the web. The <code>crawl</code> function remains exactly as it was in <code>gopl.io/ch5/findlinks3</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/crawl1/findlinks.go" >gopl.io/ch8/crawl1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The main function resembles <code>breadthFirst</code> (<a href="#section-5.6" >§5.6</a>). As before, a worklist records the queue of items that need processing, each item being a list of URLs to crawl, but this time, instead of representing the queue using a slice, we use a channel. Each call to <code>crawl</code> occurs in its own goroutine and sends the links it discovers back to the worklist.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

  <span class="c1">// Start with the command-line arguments.
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Crawl the web concurrently.
</span><span class="c1"></span>  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notice that the crawl goroutine takes <code>link</code> as an explicit parameter to avoid the problem of loop variable capture we first saw in <a href="#section-5.6.1" >Section 5.6.1</a>. Also notice that the initial send of the command-line arguments to the worklist must run in its own goroutine to avoid <em>deadlock</em>, a stuck situation in which both the main goroutine and a crawler goroutine attempt to send to each other while neither is receiving. An alternative solution would be to use a buffered channel.</p>
<p>The crawler is now highly concurrent and prints a storm of URLs, but it has two problems.  The first problem manifests itself as error messages in the log after a few seconds of operation:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/crawl1
</span><span class="in" ><span class="prompt" >&gt; </span>./crawl1 http://gopl.io/
</span><span class="out" >http://gopl.io/
https://golang.org/help/

https://golang.org/doc/
https://golang.org/blog/
...
2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files
...
</span></code></pre>
<p>The initial error message is a surprising report of a DNS lookup failure for a reliable domain.  The subsequent error message reveals the cause: the program created so many network connections at once that it exceeded the per-process limit on the number of open files, causing operations such as DNS lookups and calls to <code>net.Dial</code> to start failing.</p>
<p>The program is <em>too</em> parallel. Unbounded parallelism is rarely a good idea since there is always a limiting factor in the system, such as the number of CPU cores for compute-bound workloads, the number of spindles and heads for local disk I/O operations, the bandwidth of the network for streaming downloads, or the serving capacity of a web service. The solution is to limit the number of parallel uses of the resource to match the level of parallelism that is available. A simple way to do that in our example is to ensure that no more than <em>n</em> calls to <code>links.Extract</code> are active at once, where <em>n</em> is comfortably less than the file descriptor limit—20, say. This is analogous to the way a doorman at a crowded nightclub admits a guest only when some other guest leaves.</p>
<p>We can limit parallelism using a buffered channel of capacity <em>n</em> to model a concurrency primitive called a <em>counting semaphore</em>. Conceptually, each of the <em>n</em> vacant slots in the channel buffer represents a token entitling the holder to proceed. Sending a value into the channel acquires a token, and receiving a value from the channel releases a token, creating a new vacant slot. This ensures that at most <em>n</em> sends can occur without an intervening receive.  (Although it might be more intuitive to treat <em>filled</em> slots in the channel buffer as tokens, using vacant slots avoids the need to fill the channel buffer after creating it.) Since the channel element type is not important, we’ll use <em>struct{}</em>, which has size zero.</p>
<p>Let’s rewrite the <code>crawl</code> function so that the call to <em>links.Extract</em> is bracketed by operations to acquire and release a token, thus ensuring that at most 20 calls to it are active at one time.  It’s good practice to keep the semaphore operations as close as possible to the I/O operation they regulate.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/crawl2/findlinks.go" >gopl.io/ch8/crawl2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// tokens is a counting semaphore used to
</span><span class="c1">// enforce a limit of 20 concurrent requests.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">tokens</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">tokens</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire a token
</span><span class="c1"></span>  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="o">&lt;-</span><span class="nx">tokens</span> <span class="c1">// release the token
</span><span class="c1"></span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The second problem is that the program never terminates, even when it has discovered all the links reachable from the initial URLs. (Of course, you’re unlikely to notice this problem unless you choose the initial URLs carefully or implement the depth-limiting feature of Exercise 8.6.)  For the program to terminate, we need to break out of the main loop when the worklist is empty <em>and</em> no crawl goroutines are active.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span> <span class="c1">// number of pending sends to worklist
</span><span class="c1"></span>
  <span class="c1">// Start with the command-line arguments.
</span><span class="c1"></span>  <span class="nx">n</span><span class="o">++</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Crawl the web concurrently.
</span><span class="c1"></span>  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">list</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">worklist</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">n</span><span class="o">++</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In this version, the counter <code>n</code> keeps track of the number of sends to the worklist that are yet to occur. Each time we know that an item needs to be sent to the worklist, we increment <code>n</code>, once before we send the initial command-line arguments, and again each time we start a crawler goroutine. The main loop terminates when <code>n</code> falls to zero, since there is no more work to be done.</p>
<p>Now the concurrent crawler runs about 20 times faster than the breadth-first crawler from <a href="#section-5.6" >Section 5.6</a>, without errors, and terminates correctly if it should complete its task.</p>
<p>The program below shows an alternative solution to the problem of excessive concurrency.  This version uses the original crawl function that has no counting semaphore, but calls it from one of 20 long-lived crawler goroutines, thus ensuring that at most 20 HTTP requests are active concurrently.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/crawl3/findlinks.go" >gopl.io/ch8/crawl3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>  <span class="c1">// lists of URLs, may have duplicates
</span><span class="c1"></span>  <span class="nx">unseenLinks</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// de-duplicated URLs
</span><span class="c1"></span>
  <span class="c1">// Add command-line arguments to worklist.
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Create 20 crawler goroutines to fetch each unseen link.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">unseenLinks</span> <span class="p">{</span>
        <span class="nx">foundLinks</span> <span class="o">:=</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">foundLinks</span> <span class="p">}()</span>
      <span class="p">}</span>
    <span class="p">}()</span>
  <span class="p">}</span>

  <span class="c1">// The main goroutine de-duplicates worklist items
</span><span class="c1"></span>  <span class="c1">// and sends the unseen ones to the crawlers.
</span><span class="c1"></span>  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">unseenLinks</span> <span class="o">&lt;-</span> <span class="nx">link</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The crawler goroutines are all fed by the same channel, <code>unseenLinks</code>. The main goroutine is responsible for de-duplicating items it receives from the worklist, and then sending each unseen one over the <code>unseenLinks</code> channel to a crawler goroutine.</p>
<p>The <code>seen</code> map is <em>confined</em> within the main goroutine; that is, it can be accessed only by that goroutine. Like other forms of information hiding, confinement helps us reason about the correctness of a program. For example, local variables cannot be mentioned by name from outside the function in which they are declared; variables that do not escape (<a href="#section-2.3.4" >§2.3.4</a>) from a function cannot be accessed from outside that function; and encapsulated fields of an object cannot be accessed except by the methods of that object. In all cases, information hiding helps to limit unintended interactions between parts of the program.</p>
<p>Links found by <code>crawl</code> are sent to the worklist from a dedicated goroutine to avoid deadlock.</p>
<p>To save space, we have not addressed the problem of termination in this example.</p>
<p><b>Exercise 8.6</b>: Add depth-limiting to the concurrent crawler. That is, if the user sets <code>-depth=3</code>, then only URLs reachable by at most three links will be fetched.</p>
<p><b>Exercise 8.7</b>: Write a concurrent program that creates a local mirror of a web site, fetching each reachable page and writing it to a directory on the local disk. Only pages within the original domain (for instance, <a href="https://golang.org" >golang.org</a>) should be fetched. URLs within mirrored pages should be altered as needed so that they refer to the mirrored page, not the original.</p>
</div>
<h3 id="section-8.7" >Multiplexing with <code>select</code></h3>
<div class="hBody-3" >
<p>The program below does the countdown for a rocket launch. The <code>time.Tick</code> function returns a channel on which it sends events periodically, acting like a metronome. The value of each event is a timestamp, but it is rarely as interesting as the fact of its delivery.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/countdown1/countdown.go" >gopl.io/ch8/countdown1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Commencing countdown.&#34;</span><span class="p">)</span>
  <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
    <span class="o">&lt;-</span><span class="nx">tick</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now let’s add the ability to abort the launch sequence by pressing the return key during the countdown. First, we start a goroutine that tries to read a single byte from the standard input and, if it succeeds, sends a value on a channel called <code>abort</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/countdown2/countdown.go" >gopl.io/ch8/countdown2</a></h1>
<pre class="code" ><code class="chroma" ><span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte
</span><span class="c1"></span>  <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}()</span>
</code></pre>
</div>
<p>Now each iteration of the countdown loop needs to wait for an event to arrive on one of the two channels: the ticker channel if everything is fine (<q>nominal</q> in NASA jargon) or an abort event if there was an <q>anomaly.</q> We can’t just receive from each channel because whichever operation we try first will block until completion. We need to <code>multiplex</code> these operations, and to do that, we need a <em>select statement</em>.</p>
<pre class="code" ><code class="chroma" ><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
  <span class="c1">// ...use x...
</span><span class="c1"></span><span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">:</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The general form of a select statement is shown above. Like a switch statement, it has a number of cases and an optional <code>default</code>. Each case specifies a <em>communication</em> (a send or receive operation on some channel) and an associated block of statements. A receive expression may appear on its own, as in the first case, or within a short variable declaration, as in the second case; the second form lets you refer to the received value.</p>
<p>A <code>select</code> waits until a communication for some case is ready to proceed. It then performs that communication and executes the case’s associated statements; the other communications do not happen. A <code>select</code> with no cases, <code>select{}</code>, waits forever.</p>
<p>Let’s return to our rocket launch program. The <code>time.After</code> function immediately returns a channel, and starts a new goroutine that sends a single value on that channel after the specified time. The select statement below waits until the first of two events arrives, either an abort event or the event indicating that 10 seconds have elapsed. If 10 seconds go by with no abort, the launch proceeds.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...create abort channel...
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Commencing countdown. Press return to abort.&#34;</span><span class="p">)</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
    <span class="c1">// Do nothing.
</span><span class="c1"></span>  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Launch aborted!&#34;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
<p>The example below is more subtle. The channel <code>ch</code>, whose buffer size is 1, is alternately empty then full, so only one of the cases can proceed, either the send when <code>i</code> is even, or the receive when <code>i</code> is odd. It always prints <code>0 2 4 6 8</code>.</p>
<pre class="code" ><code class="chroma" ><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;0&#34; &#34;2&#34; &#34;4&#34; &#34;6&#34; &#34;8&#34;
</span><span class="c1"></span>  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>If multiple cases are ready, <code>select</code> picks one at random, which ensures that every channel has an equal chance of being selected. Increasing the buffer size of the previous example makes its output nondeterministic, because when the buffer is neither full nor empty, the select statement figuratively tosses a coin.</p>
<p>Let’s make our launch program print the countdown. The select statement below causes each iteration of the loop to wait up to 1 second for an abort, but no longer.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/countdown3/countdown.go" >gopl.io/ch8/countdown3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...create abort channel...
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Commencing countdown.  Press return to abort.&#34;</span><span class="p">)</span>
  <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
      <span class="c1">// Do nothing.
</span><span class="c1"></span>    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Launch aborted!&#34;</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>time.Tick</code> function behaves as if it creates a goroutine that calls <code>time.Sleep</code> in a loop, sending an event each time it wakes up. When the countdown function above returns, it stops receiving events from <code>tick</code>, but the ticker goroutine is still there, trying in vain to send on a channel from which no goroutine is receiving—a <em>goroutine leak</em> (<a href="#section-8.4.4" >§8.4.4</a>).</p>
<p>The <code>Tick</code> function is convenient, but it’s appropriate only when the ticks will be needed throughout the lifetime of the application. Otherwise, we should use this pattern:</p>
<pre class="code" ><code class="chroma" ><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

<span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span>    <span class="c1">// receive from the ticker&#39;s channel
</span><span class="c1"></span>
<span class="nx">ticker</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span> <span class="c1">// cause the ticker&#39;s goroutine to terminate
</span><span class="c1"></span></code></pre>
<p>Sometimes we want to try to send or receive on a channel but avoid blocking if the channel is not ready—a <em>non-blocking</em> communication. A select statement can do that too. A <code>select</code> may have a <em>default</em>, which specifies what to do when none of the other communications can proceed immediately.</p>
<p>The select statement below receives a value from the <code>abort</code> channel if there is one to receive; otherwise it does nothing. This is a non-blocking receive operation; doing it repeatedly is called <em>polling</em> a channel.</p>
<pre class="code" ><code class="chroma" ><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Launch aborted!\n&#34;</span><span class="p">)</span>
  <span class="k">return</span>
<span class="k">default</span><span class="p">:</span>
  <span class="c1">// do nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>The zero value for a channel is <code>nil</code>. Perhaps surprisingly, nil channels are sometimes useful.  Because send and receive operations on a nil channel block forever, a case in a select statement whose channel is nil is never selected. This lets us use <code>nil</code> to enable or disable cases that correspond to features like handling timeouts or cancellation, responding to other input events, or emitting output. We’ll see an example in the next section.</p>
<p><b>Exercise 8.8</b>: Using a select statement, add a timeout to the echo server from <a href="#section-8.3" >Section 8.3</a> so that it disconnects any client that shouts nothing within 10 seconds.</p>
</div>
<h3 id="section-8.8" >Example: Concurrent Directory Traversal</h3>
<div class="hBody-3" >
<p>In this section, we’ll build a program that reports the disk usage of one or more directories specified on the command line, like the Unix <code class="command" >du</code> command. Most of its work is done by the <code>walkDir</code> function below, which enumerates the entries of the directory <code>dir</code> using the <code>dirents</code> helper function.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/du1/main.go" >gopl.io/ch8/du1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// walkDir recursively walks the file tree rooted at dir
</span><span class="c1">// and sends the size of each found file on fileSizes.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
      <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// dirents returns the entries of directory dir.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="nx">entries</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadDir</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;du1: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">entries</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>ioutil.ReadDir</code> function returns a slice of <code>os.FileInfo</code>—the same information that a call to <code>os.Stat</code> returns for a single file. For each subdirectory, <code>walkDir</code> recursively calls itself, and for each file, <code>walkDir</code> sends a message on the <code>fileSizes</code> channel. The message is the size of the file in bytes.</p>
<p>The main function, shown below, uses two goroutines. The background goroutine calls <code>walkDir</code> for each directory  specified on the command line and finally closes the <code>fileSizes</code> channel. The main goroutine computes the sum of the file sizes it receives from the channel and finally prints the total.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// The du1 command computes the disk usage of the files in a directory.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;flag&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io/ioutil&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;path/filepath&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Determine the initial directories.
</span><span class="c1"></span>  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">roots</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">()</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">roots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">roots</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;.&#34;</span><span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Traverse the file tree.
</span><span class="c1"></span>  <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
      <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Print the results.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
  <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
    <span class="nx">nfiles</span><span class="o">++</span>
    <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
  <span class="p">}</span>
  <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d files %.1f GB\n&#34;</span><span class="p">,</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">nbytes</span><span class="p">)</span><span class="o">/</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>This program pauses for a long while before printing its result:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/du1
</span><span class="in" ><span class="prompt" >&gt; </span>./du1 <span class="nv">$HOME</span> /usr /bin /etc
</span><span class="out" >213201 files 62.7 GB
</span></code></pre>
<p>The program would be nicer if it kept us informed of its progress. However, simply moving the <code>printDiskUsage</code> call into the loop would cause it to print thousands of lines of output.</p>
<p>The variant of <code class="command" >du</code> below prints the totals periodically, but only if the <code>-v</code> flag is specified since not all users will want to see progress messages. The background goroutine that loops over <code>roots</code> remains unchanged. The main goroutine now uses a ticker to generate events every 500ms, and a select statement to wait for either a file size message, in which case it updates the totals, or a tick event, in which case it prints the current totals. If the <code>-v</code> flag is not specified, the <code>tick</code> channel remains nil, and its case in the <code>select</code> is effectively disabled.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/du2/main.go" >gopl.io/ch8/du2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">verbose</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&#34;v&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;show verbose progress messages&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...start background goroutine...
</span><span class="c1"></span>
  <span class="c1">// Print the results periodically.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">tick</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="k">if</span> <span class="o">*</span><span class="nx">verbose</span> <span class="p">{</span>
    <span class="nx">tick</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
<span class="nx">loop</span><span class="p">:</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">break</span> <span class="nx">loop</span> <span class="c1">// fileSizes was closed
</span><span class="c1"></span>      <span class="p">}</span>
      <span class="nx">nfiles</span><span class="o">++</span>
      <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
      <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span> <span class="c1">// final totals
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>Since the program no longer uses a <code>range</code> loop, the first <code>select</code> case must explicitly test whether the <code>fileSizes</code> channel has been closed, using the two-result form of receive operation. If the channel has been closed, the program breaks out of the loop. The labeled <code>break</code> statement breaks out of both the <code>select</code> and the <code>for</code> loop; an unlabeled <code>break</code> would break out of only the <code>select</code>, causing the loop to begin the next iteration.</p>
<p>The program now gives us a leisurely stream of updates:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/du2
</span><span class="in" ><span class="prompt" >&gt; </span>./du2 -v <span class="nv">$HOME</span> /usr /bin /etc
</span><span class="out" >28608 files 8.3 GB
54147 files 10.3 GB
93591 files 15.1 GB
127169 files 52.9 GB
175931 files 62.2 GB
213201 files 62.7 GB
</span></code></pre>
<p>However, it still takes too long to finish. There’s no reason why all the calls to <code>walkDir</code> can’t be done concurrently, thereby exploiting parallelism in the disk system. The third version of <code class="command" >du</code>, below, creates a new goroutine for each call to <code>walkDir</code>. It uses a <code>sync.WaitGroup</code> (<a href="#section-8.5" >§8.5</a>) to count the number of calls to <code>walkDir</code> that are still active, and a closer goroutine to close the <code>fileSizes</code> channel when the counter drops to zero.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/du3/main.go" >gopl.io/ch8/du3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...determine roots...
</span><span class="c1"></span>
  <span class="c1">// Traverse each root of the file tree in parallel.
</span><span class="c1"></span>  <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="c1">// ...select loop...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
      <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Since this program creates many thousands of goroutines at its peak, we have to change <code>dirents</code> to use a counting semaphore to prevent it from opening too many files at once, just as we did for the web crawler in <a href="#section-8.6" >Section 8.6</a>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// sema is a counting semaphore for limiting concurrency in dirents.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">sema</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="c1">// dirents returns the entries of directory dir.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>        <span class="c1">// acquire token
</span><span class="c1"></span>  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// release token
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span></code></pre>
<p>This version runs several times faster than the previous one, though there is a lot of variability from system to system.</p>
<p><b>Exercise 8.9</b>: Write a version of <code class="command" >du</code> that computes and periodically displays separate totals for each of the <code>root</code> directories.</p>
</div>
<h3 id="section-8.9" >Cancellation</h3>
<div class="hBody-3" >
<p>Sometimes we need to instruct a goroutine to stop what it is doing, for example, in a web server performing a computation on behalf of a client that has disconnected.</p>
<p>There is no way for one goroutine to terminate another directly, since that would leave all its shared variables in undefined states. In the rocket launch program (<a href="#section-8.7" >§8.7</a>) we sent a single value on a channel named <code>abort</code>, which the countdown goroutine interpreted as a request to stop itself. But what if we need to cancel two goroutines, or an arbitrary number?</p>
<p>One possibility might be to send as many events on the <code>abort</code> channel as there are goroutines to cancel. If some of the goroutines have already terminated themselves, however, our count will be too large, and our sends will get stuck. On the other hand, if those goroutines have spawned other goroutines, our count will be too small, and some goroutines will remain unaware of the cancellation. In general, it’s hard to know how many goroutines are working on our behalf at any given moment. Moreover, when a goroutine receives a value from the <code>abort</code> channel, it consumes that value so that other goroutines won’t see it. For cancellation, what we need is a reliable mechanism to <em>broadcast</em> an event over a channel so that many goroutines can see it <em>as</em> it occurs and can later see that it <em>has</em> occurred.</p>
<p>Recall that after a channel has been closed and drained of all sent values, subsequent receive operations proceed immediately, yielding zero values. We can exploit this to create a broadcast mechanism: don’t send a value on the channel, close it.</p>
<p>We can add cancellation to the <code class="command" >du</code> program from the previous section with a few simple changes. First, we create a cancellation channel on which no values are ever sent, but whose closure indicates that it is time for the program to stop what it is doing. We also define a utility function, <code>cancelled</code>, that checks or <em>polls</em> the cancellation state at the instant it is called.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/du4/main.go" >gopl.io/ch8/du4</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

<span class="kd">func</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Next, we create a goroutine that will read from the standard input, which is typically connected to the terminal. As soon as any input is read (for instance, the user presses the return key), this goroutine broadcasts the cancellation by closing the <code>done</code> channel.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Cancel traversal when input is detected.
</span><span class="c1"></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte
</span><span class="c1"></span>  <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}()</span>
</code></pre>
<p>Now we need to make our goroutines respond to the cancellation. In the main goroutine, we add a third case to the select statement that tries to receive from the <code>done</code> channel. The function returns if this case is ever selected, but before it returns it must first drain the <code>fileSizes</code> channel, discarding all values until the channel is closed. It does this to ensure that any active calls to <code>walkDir</code> can run to completion without getting stuck sending to <code>fileSizes</code>.</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="c1">// Drain fileSizes to allow existing goroutines to finish.
</span><span class="c1"></span>    <span class="k">for</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
      <span class="c1">// Do nothing.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code>walkDir</code> goroutine polls the cancellation status when it begins, and returns without doing anything if the status is set. This turns all goroutines created after cancellation into no-ops:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>It might be profitable to poll the cancellation status again within <code>walkDir</code>’s loop, to avoid creating goroutines after the cancellation event. Cancellation involves a trade-off; a quicker response often requires more intrusive changes to program logic. Ensuring that no expensive operations ever occur after the cancellation event may require updating many places in your code, but often most of the benefit can be obtained by checking for cancellation in a few important places.</p>
<p>A little profiling of this program revealed that the bottleneck was the acquisition of a semaphore token in <code>dirents</code>. The <code>select</code> below makes this operation cancellable and reduces the typical cancellation latency of the program from hundreds of milliseconds to tens:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span> <span class="c1">// acquire token
</span><span class="c1"></span>  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// cancelled
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// release token
</span><span class="c1"></span>
  <span class="c1">// ...read directory...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Now, when cancellation occurs, all the background goroutines quickly stop and the <code>main</code> function returns. Of course, when <code>main</code> returns, a program exits, so it can be hard to tell a main function that cleans up after itself from one that does not. There’s a handy trick we can use during testing: if instead of returning from <code>main</code> in the event of cancellation, we execute a call to <code>panic</code>, then the runtime will dump the stack of every goroutine in the program. If the main goroutine is the only one left, then it has cleaned up after itself. But if other goroutines remain, they may not have been properly cancelled, or perhaps they have been cancelled but the cancellation takes time; a little investigation may be worthwhile. The panic dump often contains sufficient information to distinguish these cases.</p>
<p><b>Exercise 8.10</b>: HTTP requests may be cancelled by closing the optional <code>Cancel</code> channel in the <code>http.Request</code> struct. Modify the web crawler of <a href="#section-8.6" >Section 8.6</a> to support cancellation.</p>
<p>Hint: the <code>http.Get</code> convenience function does not give you an opportunity to customize a <code>Request</code>. Instead, create the request using <code>http.NewRequest</code>, set its <code>Cancel</code> field, then perform the request by calling <code>http.DefaultClient.Do(req)</code>.</p>
<p><b>Exercise 8.11</b>: Following the approach of <code>mirroredQuery</code> in <a href="#section-8.4.4" >Section 8.4.4</a>, implement a variant of <code class="command" >fetch</code> that requests several URLs concurrently. As soon as the first response arrives, cancel the other requests.</p>
</div>
<h3 id="section-8.10" >Example: Chat Server</h3>
<div class="hBody-3" >
<p>We’ll finish this chapter with a chat server that lets several users broadcast textual messages to each other. There are four kinds of goroutine in this program. There is one instance apiece of the <code>main</code> and <code>broadcaster</code> goroutines, and for each client connection there is one <code>handleConn</code> and one <code>clientWriter</code> goroutine. The broadcaster is a good illustration of how <code>select</code> is used, since it has to respond to three different kinds of messages.</p>
<p>The job of the main goroutine, shown below, is to listen for and accept incoming network connections from clients. For each one, it creates a new <code>handleConn</code> goroutine, just as in the concurrent echo server we saw at the start of this chapter.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch8/chat/chat.go" >gopl.io/ch8/chat</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;localhost:8000&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">go</span> <span class="nx">broadcaster</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Next is the broadcaster. Its local variable <code>clients</code> records the current set of connected clients.  The only information recorded about each client is the identity of its outgoing message channel, about which more later.</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">client</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span> <span class="c1">// an outgoing message channel
</span><span class="c1"></span>
<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">entering</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
  <span class="nx">leaving</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
  <span class="nx">messages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// all incoming client messages
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">broadcaster</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">clients</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">client</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// all connected clients
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">messages</span><span class="p">:</span>
      <span class="c1">// Broadcast incoming message to all
</span><span class="c1"></span>      <span class="c1">// clients&#39; outgoing message channels.
</span><span class="c1"></span>      <span class="k">for</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">clients</span> <span class="p">{</span>
        <span class="nx">cli</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
      <span class="p">}</span>
    <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">entering</span><span class="p">:</span>
      <span class="nx">clients</span><span class="p">[</span><span class="nx">cli</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">leaving</span><span class="p">:</span>
      <span class="nb">delete</span><span class="p">(</span><span class="nx">clients</span><span class="p">,</span> <span class="nx">cli</span><span class="p">)</span>
      <span class="nb">close</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The broadcaster listens on the global <code>entering</code> and <code>leaving</code> channels for announcements of arriving and departing <code>clients</code>. When it receives one of these events, it updates the clients set, and if the event was a departure, it closes the client’s outgoing message channel. The broadcaster also listens for events on the global <code>messages</code> channel, to which each client sends all its incoming messages. When the broadcaster receives one of these events, it broadcasts the message to every connected client.</p>
<p>Now let’s look at the per-client goroutines. The <code>handleConn</code> function creates a new outgoing message channel for its client and announces the arrival of this client to the broadcaster over the <code>entering</code> channel. Then it reads every line of text from the client, sending each line to the broadcaster over the global incoming message channel, prefixing each message with the identity of its sender. Once there is nothing more to read from the client, <code>handleConn</code> announces the departure of the client over the <code>leaving</code> channel and closes the connection.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// outgoing client messages
</span><span class="c1"></span>  <span class="k">go</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

  <span class="nx">who</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;You are &#34;</span> <span class="o">+</span> <span class="nx">who</span>
  <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&#34; has arrived&#34;</span>
  <span class="nx">entering</span> <span class="o">&lt;-</span> <span class="nx">ch</span>

  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()
</span><span class="c1"></span>
  <span class="nx">leaving</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
  <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&#34; has left&#34;</span>
  <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="c1">// NOTE: ignoring network errors
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In addition, <code>handleConn</code> creates a <code>clientWriter</code> goroutine for each client that receives messages broadcast to the client’s outgoing message channel and writes them to the client’s network connection. The client writer’s loop terminates when the broadcaster closes the channel after receiving a <code>leaving</code> notification.</p>
<p>The display below shows the server in action with two clients in separate windows on the same computer, using <code>netcat</code> to chat:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/chat
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch8/netcat3
</span></code></pre>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./chat <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>./netcat3
</span><span class="out" >You are 127.0.0.1:64208
127.0.0.1:64211 has arrived
Hi!
127.0.0.1:64208: Hi!

127.0.0.1:64211: Hi yourself.
^C
</span></code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./netcat3
</span><span class="out" >You are 127.0.0.1:64216

127.0.0.1:64211: Welcome.

127.0.0.1:64211 has left
</span></code></pre>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>./netcat3
</span><span class="out" >You are 127.0.0.1:64211
127.0.0.1:64208: Hi!
Hi yourself.
127.0.0.1:64211: Hi yourself.

127.0.0.1:64208 has left

127.0.0.1:64216 has arrived
Welcome.
127.0.0.1:64211: Welcome.
^C
</span></code></pre>
</div>
</div>
<p>While hosting a chat session for <span class="math" >n</span> clients, this program runs <span class="math" >2n+2</span> concurrently communicating goroutines, yet it needs no explicit locking operations (<a href="#section-9.2" >§9.2</a>). The <code>clients</code> map is confined to a single goroutine, the broadcaster, so it cannot be accessed concurrently. The only variables that are shared by multiple goroutines are channels and instances of <code>net.Conn</code>, both of which are <em>concurrency safe</em>. We’ll talk more about confinement, concurrency safety, and the implications of sharing variables across goroutines in the next chapter.</p>
<p><b>Exercise 8.12</b>: Make the broadcaster announce the current set of clients to each new arrival.  This requires that the <code>clients</code> set and the <code>entering</code> and leaving channels record the client name too.</p>
<p><b>Exercise 8.13</b>: Make the chat server disconnect idle clients, such as those that have sent no messages in the last five minutes. Hint: calling <code>conn.Close()</code> in another goroutine unblocks active <code>Read</code> calls such as the one done by <code>input.Scan()</code>.</p>
<p><b>Exercise 8.14</b>: Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when prefixing each message with its sender’s identity.</p>
<p><b>Exercise 8.15</b>: Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.</p>
</div>
<h2 id="chapter-9" >Concurrency with Shared Variables</h2>
<div class="hBody-2" >
<p>In the previous chapter, we presented several programs that use goroutines and channels to express concurrency in a direct and natural way. However, in doing so, we glossed over a number of important and subtle issues that programmers must bear in mind when writing concurrent code.</p>
<p>In this chapter, we’ll take a closer look at the mechanics of concurrency. In particular, we’ll point out some of the problems associated with sharing variables among multiple goroutines, the analytical techniques for recognizing those problems, and the patterns for solving them.  Finally, we’ll explain some of the technical differences between goroutines and operating system threads.</p>
</div>
<h3 id="section-9.1" >Race Conditions</h3>
<div class="hBody-3" >
<p>In a sequential program, that is, a program with only one goroutine, the steps of the program happen in the familiar execution order determined by the program logic. For instance, in a sequence of statements, the first one happens before the second one, and so on. In a program with two or more goroutines, the steps within each goroutine happen in the familiar order, but in general we don’t know whether an event <em>x</em> in one goroutine happens before an event <em>y</em> in another goroutine, or happens after it, or is simultaneous with it. When we cannot confidently say that one event <em>happens before</em> the other, then the events <em>x</em> and <em>y</em> are <em>concurrent</em>.</p>
<p>Consider a function that works correctly in a sequential program. That function is <em>concurrency-safe</em> if it continues to work correctly even when called concurrently, that is, from two or more goroutines with no additional synchronization. We can generalize this notion to a set of collaborating functions, such as the methods and operations of a particular type. A type is concurrency-safe if all its accessible methods and operations are concurrency-safe.</p>
<p>We can make a program concurrency-safe without making every concrete type in that program concurrency-safe. Indeed, concurrency-safe types are the exception rather than the rule, so you should access a variable concurrently only if the documentation for its type says that this is safe. We avoid concurrent access to most variables either by <em>confining</em> them to a single goroutine or by maintaining a higher-level invariant of <em>mutual exclusion</em>. We’ll explain these terms in this chapter.</p>
<p>In contrast, exported package-level functions <em>are</em> generally expected to be concurrency-safe.  Since package-level variables cannot be confined to a single goroutine, functions that modify them must enforce mutual exclusion.</p>
<p>There are many reasons a function might not work when called concurrently, including deadlock, livelock, and resource starvation. We don’t have space to discuss all of them, so we’ll focus on the most important one, the <em>race condition</em>.</p>
<p>A race condition is a situation in which the program does not give the correct result for some interleavings of the operations of multiple goroutines. Race conditions are pernicious because they may remain latent in a program and appear infrequently, perhaps only under heavy load or when using certain compilers, platforms, or architectures. This makes them hard to reproduce and diagnose.</p>
<p>It is traditional to explain the seriousness of race conditions through the metaphor of financial loss, so we’ll consider a simple bank account program.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Package bank implements a bank with only one account.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">bank</span>

<span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">balance</span> <span class="p">}</span>
</code></pre>
<p>(We could have written the body of the <code>Deposit</code> function as <code>balance += amount</code>, which is equivalent, but the longer form will simplify the explanation.)</p>
<p>For a program this trivial, we can see at a glance that any sequence of calls to <code>Deposit</code> and <code>Balance</code> will give the right answer, that is, <code>Balance</code> will report the sum of all amounts previously deposited. However, if we call these functions not in a sequence but concurrently, <code>Balance</code> is no longer guaranteed to give the right answer. Consider the following two goroutines, which represent two transactions on a joint bank account:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Alice:
</span><span class="c1"></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">bank</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>                <span class="c1">// A1
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">bank</span><span class="p">.</span><span class="nx">Balance</span><span class="p">())</span> <span class="c1">// A2
</span><span class="c1"></span><span class="p">}()</span>

<span class="c1">// Bob:
</span><span class="c1"></span><span class="k">go</span> <span class="nx">bank</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>               <span class="c1">// B
</span><span class="c1"></span></code></pre>
<p>Alice deposits $200, then checks her balance, while Bob deposits $100. Since the steps <code>A1</code> and <code>A2</code> occur concurrently with <code>B</code>, we cannot predict the order in which they happen. Intuitively, it might seem that there are only three possible orderings, which we’ll call <q>Alice first,</q> <q>Bob first,</q> and <q>Alice/Bob/Alice.</q> The following table shows the value of the balance variable after each step. The quoted strings represent the printed balance slips.</p>
<div class="pre-block" >
<pre class="pre" >Alice first             Bob first          Alice/Bob/Alice
          0                     0                        0
  A1    200             B     100                A1    200
  A2 &#34;= 200&#34;            A1    300                B     300
  B     300             A2 &#34;= 300&#34;               A2 &#34;= 300&#34;
</pre>
</div>
<p>In all cases the final balance is $300. The only variation is whether Alice’s balance slip includes Bob’s transaction or not, but the customers are satisfied either way.</p>
<p>But this intuition is wrong. There is a fourth possible outcome, in which Bob’s deposit occurs in the middle of Alice’s deposit, after the balance has been read (<code>balance + amount</code>) but before it has been updated (<code>balance = ...</code>), causing Bob’s transaction to disappear. This is because Alice’s deposit operation <code>A1</code> is really a sequence of two operations, a read and a write; call them <code>A1r</code> and <code>A1w</code>. Here’s the problematic interleaving:</p>
<div class="pre-block" >
<pre class="pre" >Data race
         0
A1r      0          ... = balance + amount
B      100
A1w    200          balance = ...
A2  &#34;= 200&#34;
</pre>
</div>
<p>After <code>A1r</code>, the expression <code>balance + amount</code> evaluates to 200, so this is the value written during <code>A1w</code>, despite the intervening deposit. The final balance is only $200. The bank is $100 richer at Bob’s expense.</p>
<p>This program contains a particular kind of race condition called a <code>data race</code>. A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write.</p>
<p>Things get even messier if the data race involves a variable of a type that is larger than a single machine word, such as an interface, a string, or a slice. This code updates <code>x</code> concurrently to two slices of different lengths:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">}()</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">}()</span>
<span class="nx">x</span><span class="p">[</span><span class="mi">999999</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// NOTE: undefined behavior; memory corruption possible!
</span><span class="c1"></span></code></pre>
<p>The value of <code>x</code> in the final statement is not defined; it could be nil, or a slice of length 10, or a slice of length 1,000,000. But recall that there are three parts to a slice: the pointer, the length, and the capacity. If the pointer comes from the first call to make and the length comes from the second, <code>x</code> would be a chimera, a slice whose nominal length is 1,000,000 but whose underlying array has only 10 elements. In this eventuality, storing to element 999,999 would clobber an arbitrary faraway memory location, with consequences that are impossible to predict and hard to debug and localize. This semantic minefield is called <em>undefined behavior</em> and is well known to C programmers; fortunately it is rarely as troublesome in Go as in C.</p>
<p>Even the notion that a concurrent program is an interleaving of several sequential programs is a false intuition. As we’ll see in <a href="#section-9.4" >Section 9.4</a>, data races may have even stranger outcomes.  Many programmers—even some very clever ones—will occasionally offer justifications for known data races in their programs: <q>the cost of mutual exclusion is too high,</q> <q>this logic is only for logging,</q> <q>I don’t mind if I drop some messages,</q> and so on. The absence of problems on a given compiler and platform may give them false confidence. A good rule of thumb is that <em>there is no such thing as a benign data race</em>. So how do we avoid data races in our programs?</p>
<p>We’ll repeat the definition, since it is so important: A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race.</p>
<p>The first way is not to write the variable. Consider the map below, which is lazily populated as each key is requested for the first time. If <code>Icon</code> is called sequentially, the program works fine, but if <code>Icon</code> is called concurrently, there is a data race accessing the map.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">icons</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// NOTE: not concurrency-safe!
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">icon</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">icon</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">icon</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icon</span>
<span class="p">}</span>
</code></pre>
<p>If instead we initialize the map with all necessary entries before creating additional goroutines and never modify it again, then any number of goroutines may safely call <code>Icon</code> concurrently since each only reads the map.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">icons</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">{</span>
  <span class="s">&#34;spades.png&#34;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;spades.png&#34;</span><span class="p">),</span>
  <span class="s">&#34;hearts.png&#34;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;hearts.png&#34;</span><span class="p">),</span>
  <span class="s">&#34;diamonds.png&#34;</span><span class="p">:</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;diamonds.png&#34;</span><span class="p">),</span>
  <span class="s">&#34;clubs.png&#34;</span><span class="p">:</span>    <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;clubs.png&#34;</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1">// Concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>In the example above, the <code>icons</code> variable is assigned during package initialization, which <em>happens before</em> the program’s main function starts running. Once initialized, <code>icons</code> is never modified. Data structures that are never modified or are immutable are inherently concurrency-safe and need no synchronization. But obviously we can’t use this approach if updates are essential, as with a bank account.</p>
<p>The second way to avoid a data race is to avoid accessing the variable from multiple goroutines. This is the approach taken by many of the programs in the previous chapter. For example, the main goroutine in the concurrent web crawler (<a href="#section-8.6" >§8.6</a>) is the sole goroutine that accesses the <code>seen</code> map, and the <code>broadcaster</code> goroutine in the chat server (<a href="#section-8.10" >§8.10</a>) is the only goroutine that accesses the <code>clients</code> map. These variables are <em>confined</em> to a single goroutine.</p>
<p>Since other goroutines cannot access the variable directly, they must use a channel to send the confining goroutine a request to query or update the variable. This is what is meant by the Go mantra <q>Do not communicate by sharing memory; instead, share memory by communicating.</q> A goroutine that brokers access to a confined variable using channel requests is called a <em>monitor goroutine</em> for that variable. For example, the <code>broadcaster</code> goroutine monitors access to the <code>clients</code> map.</p>
<p>Here’s the bank example rewritten with the <code>balance</code> variable confined to a monitor goroutine called <code>teller</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/bank1/bank.go" >gopl.io/ch9/bank1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package bank provides a concurrency-safe bank with one account.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">bank</span>

<span class="kd">var</span> <span class="nx">deposits</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// send amount to deposit
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">balances</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// receive balance
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">deposits</span> <span class="o">&lt;-</span> <span class="nx">amount</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span>       <span class="p">{</span> <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">balances</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">teller</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span> <span class="c1">// balance is confined to teller goroutine
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">amount</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">deposits</span><span class="p">:</span>
      <span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span>
    <span class="k">case</span> <span class="nx">balances</span> <span class="o">&lt;-</span> <span class="nx">balance</span><span class="p">:</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">teller</span><span class="p">()</span> <span class="c1">// start the monitor goroutine
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
</div>
<p>Even when a variable cannot be confined to a single goroutine for its entire lifetime, confinement may still be a solution to the problem of concurrent access. For example, it’s common to share a variable between goroutines in a pipeline by passing its address from one stage to the next over a channel. If each stage of the pipeline refrains from accessing the variable after sending it to the next stage, then all accesses to the variable are sequential. In effect, the variable is confined to one stage of the pipeline, then confined to the next, and so on. This discipline is sometimes called <em>serial confinement</em>.</p>
<p>In the example below, <code>Cakes</code> are serially confined, first to the <code>baker</code> goroutine, then to the <code>icer</code> goroutine:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Cake</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">state</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">baker</span><span class="p">(</span><span class="nx">cooked</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">cake</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Cake</span><span class="p">)</span>
    <span class="nx">cake</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="s">&#34;cooked&#34;</span>
    <span class="nx">cooked</span> <span class="o">&lt;-</span> <span class="nx">cake</span> <span class="c1">// baker never touches this cake again
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">icer</span><span class="p">(</span><span class="nx">iced</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">,</span> <span class="nx">cooked</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">cake</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cooked</span> <span class="p">{</span>
    <span class="nx">cake</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="s">&#34;iced&#34;</span>
    <span class="nx">iced</span> <span class="o">&lt;-</span> <span class="nx">cake</span>   <span class="c1">// icer never touches this cake again
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The third way to avoid a data race is to allow many goroutines to access the variable, but only one at a time. This approach is known as <em>mutual exclusion</em> and is the subject of the next section.</p>
<p><b>Exercise 9.1</b>: Add a function <code>Withdraw(amount int) bool</code> to the <code>gopl.io/ch9/bank1</code> program. The result should indicate whether the transaction succeeded or failed due to insufficient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to <code>Withdraw</code>.</p>
</div>
<h3 id="section-9.2" >Mutual Exclusion: <code>sync.Mutex</code></h3>
<div class="hBody-3" >
<p>In <a href="#section-8.6" >Section 8.6</a>, we used a buffered channel as a <em>counting semaphore</em> to ensure that no more than 20 goroutines made simultaneous HTTP requests. With the same idea, we can use a channel of capacity 1 to ensure that at most one goroutine accesses a shared variable at a time.  A semaphore that counts only to 1 is called a <em>binary semaphore</em>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/bank2/bank.go" >gopl.io/ch9/bank2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">sema</span>    <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// a binary semaphore guarding balance
</span><span class="c1"></span>  <span class="nx">balance</span> <span class="kt">int</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire token
</span><span class="c1"></span>  <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
  <span class="o">&lt;-</span><span class="nx">sema</span> <span class="c1">// release token
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// acquire token
</span><span class="c1"></span>  <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
  <span class="o">&lt;-</span><span class="nx">sema</span> <span class="c1">// release token
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This pattern of <em>mutual exclusion</em> is so useful that it is supported directly by the <em>Mutex</em> type from the <code>sync</code> package. Its <code>Lock</code> method acquires the token (called a <em>lock</em>) and its <code>Unlock</code> method releases it:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/bank3/bank.go" >gopl.io/ch9/bank3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;sync&#34;</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards balance
</span><span class="c1"></span>  <span class="nx">balance</span> <span class="kt">int</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Each time a goroutine accesses the variables of the bank (just <code>balance</code> here), it must call the mutex’s <code>Lock</code> method to acquire an exclusive lock. If some other goroutine has acquired the lock, this operation will block until the other goroutine calls <code>Unlock</code> and the lock becomes available again. The mutex <em>guards</em> the shared variables. By convention, the variables guarded by a mutex are declared immediately after the declaration of the mutex itself. If you deviate from this, be sure to document it.</p>
<p>The region of code between <code>Lock</code> and <code>Unlock</code> in which a goroutine is free to read and modify the shared variables is called a <em>critical section</em>. The lock holder’s call to <code>Unlock</code> <em>happens before</em> any other goroutine can acquire the lock for itself. It is essential that the goroutine release the lock once it is finished, on all paths through the function, including error paths.</p>
<p>The bank program above exemplifies a common concurrency pattern. A set of exported functions encapsulates one or more variables so that the only way to access the variables is through these functions (or methods, for the variables of an object). Each function acquires a mutex lock at the beginning and releases it at the end, thereby ensuring that the shared variables are not accessed concurrently. This arrangement of functions, mutex lock, and variables is called a <em>monitor</em>. (This older use of the word <q>monitor</q> inspired the term <q>monitor goroutine.</q> Both uses share the meaning of a broker that ensures variables are accessed sequentially.)</p>
<p>Since the critical sections in the <code>Deposit</code> and <code>Balance</code> functions are so short—a single line, no branching—calling <code>Unlock</code> at the end is straightforward. In more complex critical sections, especially those in which errors must be dealt with by returning early, it can be hard to tell that calls to <code>Lock</code> and <code>Unlock</code> are strictly paired on all paths. Go’s <code>defer</code> statement comes to the rescue: by deferring a call to <code>Unlock</code>, the critical section implicitly extends to the end of the current function, freeing us from having to remember to insert <code>Unlock</code> calls in one or more places far from the call to <code>Lock</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>
</code></pre>
<p>In the example above, the <code>Unlock</code> executes <em>after</em> the return statement has read the value of <code>balance</code>, so the <code>Balance</code> function is concurrency-safe. As a bonus, we no longer need the local variable <code>b</code>.</p>
<p>Furthermore, a deferred <code>Unlock</code> will run even if the critical section panics, which may be important in programs that make use of <code>recover</code> (<a href="#section-5.10" >§5.10</a>). A <code>defer</code> is marginally more expensive than an explicit call to <code>Unlock</code>, but not enough to justify less clear code. As always with concurrent programs, favor clarity and resist premature optimization. Where possible, use <code>defer</code> and let critical sections extend to the end of a function.</p>
<p>Consider the <code>Withdraw</code> function below. On success, it reduces the balance by the specified amount and returns <code>true</code>. But if the account holds insufficient funds for the transaction, <code>Withdraw</code> restores the balance and returns <code>false</code>.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// NOTE: not atomic!
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">Deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// insufficient funds
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>This function eventually gives the correct result, but it has a nasty side effect. When an excessive withdrawal is attempted, the balance transiently dips below zero. This may cause a concurrent withdrawal for a modest sum to be spuriously rejected. So if Bob tries to buy a sports car, Alice can’t pay for her morning coffee. The problem is that Withdraw is not <em>atomic</em>: it consists of a sequence of three separate operations, each of which acquires and then releases the mutex lock, but nothing locks the whole sequence.</p>
<p>Ideally, <code>Withdraw</code> should acquire the mutex lock once around the whole operation. However, this attempt won’t work:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// NOTE: incorrect!
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">Deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// insufficient funds
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p><code>Deposit</code> tries to acquire the mutex lock a second time by calling <code>mu.Lock()</code>, but because mutex locks are not <em>re-entrant</em>—it’s not possible to lock a mutex that’s already locked—this leads to a deadlock where nothing can proceed, and <code>Withdraw</code> blocks forever.</p>
<p>There is a good reason Go’s mutexes are not re-entrant. The purpose of a mutex is to ensure that certain invariants of the shared variables are maintained at critical points during program execution. One of the invariants is <q>no goroutine is accessing the shared variables,</q> but there may be additional invariants specific to the data structures that the mutex guards. When a goroutine acquires a mutex lock, it may assume that the invariants hold. While it holds the lock, it may update the shared variables so that the invariants are temporarily violated.  However, when it releases the lock, it must guarantee that order has been restored and the invariants hold once again. Although a re-entrant mutex would ensure that no other goroutines are accessing the shared variables, it cannot protect the additional invariants of those variables.</p>
<p>A common solution is to divide a function such as <code>Deposit</code> into two: an unexported function, <code>deposit</code>, that assumes the lock is already held and does the real work, and an exported function <code>Deposit</code> that acquires the lock before calling <code>deposit</code>. We can then express <code>Withdraw</code> in terms of <code>deposit</code> like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">balance</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// insufficient funds
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>

<span class="c1">// This function requires that the lock be held.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span> <span class="p">}</span>
</code></pre>
<p>Of course, the <code>deposit</code> function shown here is so trivial that a realistic <code>Withdraw</code> function wouldn’t bother calling it, but nonetheless it illustrates the principle.</p>
<p>Encapsulation (<a href="#section-6.6" >§6.6</a>), by reducing unexpected interactions in a program, helps us maintain data structure invariants. For the same reason, encapsulation also helps us maintain concurrency invariants. When you use a mutex, make sure that both it and the variables it guards are not exported, whether they are package-level variables or the fields of a struct.</p>
</div>
<h3 id="section-9.3" >Read/Write Mutexes: <code>sync.RWMutex</code></h3>
<div class="hBody-3" >
<p>In a fit of anxiety after seeing his $100 deposit vanish without a trace, Bob writes a program to check his bank balance hundreds of times a second. He runs it at home, at work, and on his phone. The bank notices that the increased traffic is delaying deposits and withdrawals, because all the <code>Balance</code> requests run sequentially, holding the lock exclusively and temporarily preventing other goroutines from running.</p>
<p>Since the <code>Balance</code> function only needs to <em>read</em> the state of the variable, it would in fact be safe for multiple <code>Balance</code> calls to run concurrently, so long as no <code>Deposit</code> or <code>Withdraw</code> call is running. In this scenario we need a special kind of lock that allows read-only operations to proceed in parallel with each other, but write operations to have fully exclusive access. This lock is called a <em>multiple readers, single writer</em> lock, and in Go it’s provided by <code>sync.RWMutex</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span> <span class="c1">// readers lock
</span><span class="c1"></span>  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>
</code></pre>
<p>The <code>Balance</code> function now calls the <code>RLock</code> and <code>RUnlock</code> methods to acquire and release a <em>readers</em> or <em>shared</em> lock. The <code>Deposit</code> function, which is unchanged, calls the <code>mu.Lock</code> and <code>mu.Unlock</code> methods to acquire and release a <em>writer or exclusive</em> lock.</p>
<p>After this change, most of Bob’s <code>Balance</code> requests run in parallel with each other and finish more quickly. The lock is available for more of the time, and <code>Deposit</code> requests can proceed in a timely manner.</p>
<p><code>RLock</code> can be used only if there are no writes to shared variables in the critical section. In general, we should not assume that <em>logically</em> read-only functions or methods don’t also update some variables. For example, a method that appears to be a simple accessor might also increment an internal usage counter, or update a cache so that repeat calls are faster. If in doubt, use an exclusive <code>Lock</code>.</p>
<p>It’s only profitable to use an <code>RWMutex</code> when most of the goroutines that acquire the lock are readers, and the lock is under <em>contention</em>, that is, goroutines routinely have to wait to acquire it. An <code>RWMutex</code> requires more complex internal bookkeeping, making it slower than a regular mutex for uncontended locks.</p>
</div>
<h3 id="section-9.4" >Memory Synchronization</h3>
<div class="hBody-3" >
<p>You may wonder why the <code>Balance</code> method needs mutual exclusion, either channel-based or mutex-based. After all, unlike <code>Deposit</code>, it consists only of a single operation, so there is no danger of another goroutine executing <q>in the middle</q> of it. There are two reasons we need a mutex. The first is that it’s equally important that <code>Balance</code> not execute in the middle of some other operation like <code>Withdraw</code>. The second (and more subtle) reason is that synchronization is about more than just the order of execution of multiple goroutines; synchronization also affects memory.</p>
<p>In a modern computer there may be dozens of processors, each with its own local cache of the main memory. For efficiency, writes to memory are buffered within each processor and flushed out to main memory only when necessary. They may even be committed to main memory in a different order than they were written by the writing goroutine. Synchronization primitives like channel communications and mutex operations cause the processor to flush out and commit all its accumulated writes so that the effects of goroutine execution up to that point are guaranteed to be visible to goroutines running on other processors.</p>
<p>Consider the possible outputs of the following snippet of code:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>                   <span class="c1">// A1
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&#34;y:&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// A2
</span><span class="c1"></span><span class="p">}()</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>                   <span class="c1">// B1
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&#34;x:&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// B2
</span><span class="c1"></span><span class="p">}()</span>
</code></pre>
<p>Since these two goroutines are concurrent and access shared variables without mutual exclusion, there is a data race, so we should not be surprised that the program is not deterministic. We might expect it to print any one of these four results, which correspond to intuitive interleavings of the labeled statements of the program:</p>
<div class="pre-block" >
<pre class="pre" >y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1
</pre>
</div>
<p>The fourth line could be explained by the sequence <code>A1</code>,<code>B1</code>,<code>A2</code>,<code>B2</code> or by <code>B1</code>,<code>A1</code>,<code>A2</code>,<code>B2</code>, for example. However, these two outcomes might come as a surprise:</p>
<div class="pre-block" >
<pre class="pre" >x:0 y:0
y:0 x:0
</pre>
</div>
<p>but depending on the compiler, CPU, and many other factors, they can happen too. What possible interleaving of the four statements could explain them?</p>
<p>Within a single goroutine, the effects of each statement are guaranteed to occur in the order of execution; goroutines are <em>sequentially consistent</em>. But in the absence of explicit synchronization using a channel or mutex, there is no guarantee that events are seen in the same order by all goroutines. Although goroutine <code>A</code> must observe the effect of the write <code>x = 1</code> before it reads the value of <code>y</code>, it does not necessarily observe the write to <code>y</code> done by goroutine <code>B</code>, so <code>A</code> may print a <em>stale</em> value of <code>y</code>.</p>
<p>It is tempting to try to understand concurrency as if it corresponds to <em>some</em> interleaving of the statements of each goroutine, but as the example above shows, this is not how a modern compiler or CPU works. Because the assignment and the <code>Print</code> refer to different variables, a compiler may conclude that the order of the two statements cannot affect the result, and swap them. If the two goroutines execute on different CPUs, each with its own cache, writes by one goroutine are not visible to the other goroutine’s <code>Print</code> until the caches are synchronized with main memory.</p>
<p>All these concurrency problems can be avoided by the consistent use of simple, established patterns. Where possible, confine variables to a single goroutine; for all other variables, use mutual exclusion.</p>
</div>
<h3 id="section-9.5" >Lazy Initialization: <code>sync.Once</code></h3>
<div class="hBody-3" >
<p>It is good practice to defer an expensive initialization step until the moment it is needed. Initializing a variable up front increases the start-up latency of a program and is unnecessary if execution doesn’t always reach the part of the program that uses that variable. Let’s return to the <code>icons</code> variable we saw earlier in the chapter:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>
</code></pre>
<p>This version of <code>Icon</code> uses <em>lazy initialization</em>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">loadIcons</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">icons</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">{</span>
    <span class="s">&#34;spades.png&#34;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;spades.png&#34;</span><span class="p">),</span>
    <span class="s">&#34;hearts.png&#34;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;hearts.png&#34;</span><span class="p">),</span>
    <span class="s">&#34;diamonds.png&#34;</span><span class="p">:</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;diamonds.png&#34;</span><span class="p">),</span>
    <span class="s">&#34;clubs.png&#34;</span><span class="p">:</span>    <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;clubs.png&#34;</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NOTE: not concurrency-safe!
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">loadIcons</span><span class="p">()</span> <span class="c1">// one-time initialization
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>For a variable accessed by only a single goroutine, we can use the pattern above, but this pattern is not safe if <code>Icon</code> is called concurrently. Like the bank’s original <code>Deposit</code> function, <code>Icon</code> consists of multiple steps: it tests whether <code>icons</code> is nil, then it loads the icons, then it updates <code>icons</code> to a non-nil value. Intuition might suggest that the worst possible outcome of the race condition above is that the <code>loadIcons</code> function is called several times. While the first goroutine is busy loading the icons, another goroutine entering <code>Icon</code> would find the variable still equal to <code>nil</code>, and would also call <code>loadIcons</code>.</p>
<p>But this intuition is also wrong. (We hope that by now you are developing a new intuition about concurrency, that intuitions about concurrency are not to be trusted!) Recall the discussion of memory from <a href="#section-9.4" >Section 9.4</a>. In the absence of explicit synchronization, the compiler and CPU are free to reorder accesses to memory in any number of ways, so long as the behavior of each goroutine is sequentially consistent. One possible reordering of the statements of <code>loadIcons</code> is shown below. It stores the empty map in the <code>icons</code> variable before populating it:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">loadIcons</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">icons</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&#34;spades.png&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;spades.png&#34;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&#34;hearts.png&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;hearts.png&#34;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&#34;diamonds.png&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;diamonds.png&#34;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&#34;clubs.png&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&#34;clubs.png&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Consequently, a goroutine finding <code>icons</code> to be non-nil may not assume that the initialization of the variable is complete.</p>
<p>The simplest correct way to ensure that all goroutines observe the effects of <code>loadIcons</code> is to synchronize them using a mutex:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards icons
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// Concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">loadIcons</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>However, the cost of enforcing mutually exclusive access to <code>icons</code> is that two goroutines cannot access the variable concurrently, even once the variable has been safely initialized and will never be modified again. This suggests a multiple-readers lock:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// guards icons
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// Concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">icon</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">icon</span>
  <span class="p">}</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>

  <span class="c1">// acquire an exclusive lock
</span><span class="c1"></span>  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// NOTE: must recheck for nil
</span><span class="c1"></span>    <span class="nx">loadIcons</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">icon</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">icon</span>
<span class="p">}</span>
</code></pre>
<p>There are now two critical sections. The goroutine first acquires a reader lock, consults the map, then releases the lock. If an entry was found (the common case), it is returned. If no entry was found, the goroutine acquires a writer lock. There is no way to upgrade a shared lock to an exclusive one without first releasing the shared lock, so we must recheck the <code>icons</code> variable in case another goroutine already initialized it in the interim.</p>
<p>The pattern above gives us greater concurrency but is complex and thus error-prone.  Fortunately, the <code>sync</code> package provides a specialized solution to the problem of one-time initialization: <code>sync.Once</code>. Conceptually, a <code>Once</code> consists of a mutex and a boolean variable that records whether initialization has taken place; the mutex guards both the boolean and the client’s data structures. The sole method, Do, accepts the initialization function as its argument. Let’s use <code>Once</code> to simplify the <code>Icon</code> function:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">loadIconsOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// Concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">loadIconsOnce</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="nx">loadIcons</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>
<p>Each call to <code>Do(loadIcons)</code> locks the mutex and checks the boolean variable. In the first call, in which the variable is false, Do calls <code>loadIcons</code> and sets the variable to true. Subsequent calls do nothing, but the mutex synchronization ensures that the effects of <code>loadIcons</code> on memory (specifically, <code>icons</code>) become visible to all goroutines. Using <code>sync.Once</code> in this way, we can avoid sharing variables with other goroutines until they have been properly constructed.</p>
<p><b>Exercise 9.2</b>: Rewrite the <code>PopCount</code> example from <a href="#section-2.6.2" >Section 2.6.2</a> so that it initializes the lookup table using <code>sync.Once</code> the first time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like <code>PopCount</code>.)</p>
</div>
<h3 id="section-9.6" >The Race Detector</h3>
<div class="hBody-3" >
<p>Even with the greatest of care, it’s all too easy to make concurrency mistakes. Fortunately, the Go runtime and toolchain are equipped with a sophisticated and easy-to-use dynamic analysis tool, the <em>race detector</em>.</p>
<p>Just add the <code>-race</code> flag to your <code class="command" >go build</code>, <code class="command" >go run</code>, or <code class="command" >go test</code> command. This causes the compiler to build a modified version of your application or test with additional instrumentation that effectively records all accesses to shared variables that occurred during execution, along with the identity of the goroutine that read or wrote the variable. In addition, the modified program records all synchronization events, such as <code>go</code> statements, channel operations, and calls to <code>(*sync.Mutex).Lock</code>, <code>(*sync.WaitGroup).Wait</code>, and so on. (The complete set of synchronization events is specified by the <em>The Go Memory Model</em> document that accompanies the language specification.)</p>
<p>The race detector studies this stream of events, looking for cases in which one goroutine reads or writes a shared variable that was most recently written by a different goroutine without an intervening synchronization operation. This indicates a concurrent access to the shared variable, and thus a data race. The tool prints a report that includes the identity of the variable, and the stacks of active function calls in the reading goroutine and the writing goroutine. This is usually sufficient to pinpoint the problem. <a href="#section-9.7" >Section 9.7</a> contains an example of the race detector in action.</p>
<p>The race detector reports all data races that were actually executed. However, it can only detect race conditions that occur during a run; it cannot prove that none will ever occur. For best results, make sure that your tests exercise your packages using concurrency.</p>
<p>Due to extra bookkeeping, a program built with race detection needs more time and memory to run, but the overhead is tolerable even for many production jobs. For infrequently occurring race conditions, letting the race detector do its job can save hours or days of debugging.</p>
</div>
<h3 id="section-9.7" >Example: Concurrent Non-Blocking Cache</h3>
<div class="hBody-3" >
<p>In this section, we’ll build a <em>concurrent non-blocking cache</em>, an abstraction that solves a problem that arises often in real-world concurrent programs but is not well addressed by existing libraries. This is the problem of <em>memoizing</em> a function, that is, caching the result of a function so that it need be computed only once. Our solution will be concurrency-safe and will avoid the contention associated with designs based on a single lock for the whole cache.</p>
<p>We’ll use the <code>httpGetBody</code> function below as an example of the type of function we might want to memoize. It makes an HTTP GET request and reads the response body. Calls to this function are relatively expensive, so we’d like to avoid repeating them unnecessarily.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">httpGetBody</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The final line hides a minor subtlety. <code>ReadAll</code> returns two results, a <code>[]byte</code> and an <code>error</code>, but since these are assignable to the declared result types of <code>httpGetBody</code>—<code>interface{}</code> and <code>error</code>, respectively—we can return the result of the call without further ado. We chose this return type for <code>httpGetBody</code> so that it conforms to the type of functions that our cache is designed to memoize.</p>
<p>Here’s the first draft of the cache:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/memo1/memo.go" >gopl.io/ch9/memo1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package memo provides a concurrency-unsafe
</span><span class="c1">// memoization of a function of type Func.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">memo</span>

<span class="c1">// A Memo caches the results of calling a Func.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// Func is the type of the function to memoize.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Func</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">result</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">err</span>   <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">cache</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span><span class="p">)}</span>
<span class="p">}</span>

<span class="c1">// NOTE: not concurrency-safe!
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<p>A <code>Memo</code> instance holds the function <code>f</code> to memoize, of type <code>Func</code>, and the cache, which is a mapping from strings to <code>results</code>. Each <code>result</code> is simply the pair of results returned by a call to <code>f</code>—a value and an error. We’ll show several variations of <code>Memo</code> as the design progresses, but all will share these basic aspects.</p>
<p>An example of how to use <code>Memo</code> appears below. For each element in a stream of incoming URLs, we call <code>Get</code>, logging the latency of the call and the amount of data it returns:</p>
<pre class="code" ><code class="chroma" ><span class="nx">m</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">httpGetBody</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">incomingURLs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s, %s, %d bytes\n&#34;</span><span class="p">,</span>
    <span class="nx">url</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">.([]</span><span class="kt">byte</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre>
<p>We can use the <code>testing</code> package (the topic of <a href="#chapter-11" >Chapter 11</a>) to systematically investigate the effect of memoization. From the test output below, we see that the URL stream contains duplicates, and that although the first call to <code>(*Memo).Get</code> for each URL takes hundreds of milliseconds, the second request returns the same amount of data in under a millisecond.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v gopl.io/ch9/memo1
</span><span class="out" >=== RUN   Test
https://golang.org, 175.026418ms, 7537 bytes
https://godoc.org, 172.686825ms, 6878 bytes
https://play.golang.org, 115.762377ms, 5767 bytes
http://gopl.io, 749.887242ms, 2856 bytes
https://golang.org, 721ns, 7537 bytes
https://godoc.org, 152ns, 6878 bytes
https://play.golang.org, 205ns, 5767 bytes
http://gopl.io, 326ns, 2856 bytes
--- PASS: Test (1.21s)
PASS
ok gopl.io/ch9/memo1   1.257s
</span></code></pre>
<p>This test executes all calls to <code>Get</code> sequentially.</p>
<p>Since HTTP requests are a great opportunity for parallelism, let’s change the test so that it makes all requests concurrently. The test uses a <code>sync.WaitGroup</code> to wait until the last request is complete before returning.</p>
<pre class="code" ><code class="chroma" ><span class="nx">m</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">httpGetBody</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="k">for</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">incomingURLs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s, %s, %d bytes\n&#34;</span><span class="p">,</span>
      <span class="nx">url</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">.([]</span><span class="kt">byte</span><span class="p">)))</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">n</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
</code></pre>
<p>The test runs much faster, but unfortunately it is unlikely to work correctly all the time. We may notice unexpected cache misses, or cache hits that return incorrect values, or even crashes.</p>
<p>Worse, it is likely to work correctly <em>some</em> of the time, so we may not even notice that it has a problem. But if we run it with the <code>-race</code> flag, the race detector (<a href="#section-9.6" >§9.6</a>) often prints a report such as this one:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>TestConcurrent -race -v gopl.io/ch9/memo1
</span><span class="out" >=== RUN   TestConcurrent
...
WARNING: DATA RACE
Write by goroutine 36:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  gopl.io/ch9/memo1.(*Memo).Get()
      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
Previous write by goroutine 35:
  runtime.mapassign1()
      ~/go/src/runtime/hashmap.go:411 +0x0
  gopl.io/ch9/memo1.(*Memo).Get()
      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
...
Found 1 data race(s)
FAIL    gopl.io/ch9/memo1   2.393s
</span></code></pre>
<p>The reference to <code>memo.go:32</code> tells us that two goroutines have updated the <code>cache</code> map without any intervening synchronization. <code>Get</code> is not concurrency-safe: it has a data race.</p>
<pre class="code" ><code class="chroma" ><span class="index" class="ln">28  </span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="index" class="ln">29  </span>  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="index" class="ln">30  </span>  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
<span class="index" class="ln">31  </span>    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="index" class="ln">32  </span>    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
<span class="index" class="ln">33  </span>  <span class="p">}</span>
<span class="index" class="ln">34  </span>  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="index" class="ln">35  </span><span class="p">}</span>
<span class="index" class="ln">36  </span></code></pre>
<p>The simplest way to make the cache concurrency-safe is to use monitor-based synchronization. All we need to do is add a mutex to the <code>Memo</code>, acquire the mutex lock at the start of <code>Get</code>, and release it before <code>Get</code> returns, so that the two <code>cache</code> operations occur within the critical section:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/memo2/memo.go" >gopl.io/ch9/memo2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards cache
</span><span class="c1"></span>  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// Get is concurrency-safe.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now the race detector is silent, even when running the tests concurrently. Unfortunately this change to <code>Memo</code> reverses our earlier performance gains. By holding the lock for the duration of each call to <code>f</code>, <code>Get</code> serializes all the I/O operations we intended to parallelize. What we need is a <em>non-blocking</em> cache, one that does not serialize calls to the function it memoizes.</p>
<p>In the next implementation of <code>Get</code>, below, the calling goroutine acquires the lock twice: once for the lookup, and then a second time for the update if the lookup returned nothing. In between, other goroutines are free to use the cache.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/memo3/memo.go" >gopl.io/ch9/memo3</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

    <span class="c1">// Between the two critical sections, several goroutines
</span><span class="c1"></span>    <span class="c1">// may race to compute f(key) and update the map.
</span><span class="c1"></span>    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The performance improves again, but now we notice that some URLs are being fetched twice.  This happens when two or more goroutines call <code>Get</code> for the same URL at about the same time.  Both consult the cache, find no value there, and then call the slow function <code>f</code>. Then both of them update the map with the result they obtained. One of the results is overwritten by the other.</p>
<p>Ideally we’d like to avoid this redundant work. This feature is sometimes called <em>duplicate suppression</em>. In the version of <code>Memo</code> below, each map element is a pointer to an <code>entry</code> struct.  Each <code>entry</code> contains the memoized result of a call to the function <code>f</code>, as before, but it additionally contains a channel called <code>ready</code>. Just after the <code>entry</code>’s <code>result</code> has been set, this channel will be closed, to <em>broadcast</em> (<a href="#section-8.9" >§8.9</a>) to any other goroutines that it is now safe for them to read the result from the <code>entry</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/memo4/memo.go" >gopl.io/ch9/memo4</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">res</span>   <span class="nx">result</span>
  <span class="nx">ready</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// closed when res is ready
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">cache</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span><span class="p">)}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards cache
</span><span class="c1"></span>  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">e</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// This is the first request for this key.
</span><span class="c1"></span>    <span class="c1">// This goroutine becomes responsible for computing
</span><span class="c1"></span>    <span class="c1">// the value and broadcasting the ready condition.
</span><span class="c1"></span>    <span class="nx">e</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entry</span><span class="p">{</span><span class="nx">ready</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})}</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span><span class="p">)</span> <span class="c1">// broadcast ready condition
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// This is a repeat request for this key.
</span><span class="c1"></span>    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="o">&lt;-</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span> <span class="c1">// wait for ready condition
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre>
</div>
<p>A call to <code>Get</code> now involves acquiring the mutex lock that guards the <code>cache</code> map, looking in the map for a pointer to an existing <code>entry</code>, allocating and inserting a new <code>entry</code> if none was found, then releasing the lock. If there was an existing <code>entry</code>, its value is not necessarily ready yet—another goroutine could still be calling the slow function <code>f</code>—so the calling goroutine must wait for the <code>entry</code>’s <q>ready</q> condition before it reads the <code>entry</code>’s <code>result</code>. It does this by reading a value from the <code>ready</code> channel, since this operation blocks until the channel is closed.</p>
<p>If there was no existing <code>entry</code>, then by inserting a new <q>not ready</q> <code>entry</code> into the map, the current goroutine becomes responsible for invoking the slow function, updating the <code>entry</code>, and broadcasting the readiness of the new <code>entry</code> to any other goroutines that might (by then) be waiting for it.</p>
<p>Notice that the variables <code>e.res.value</code> and <code>e.res.err</code> in the <code>entry</code> are shared among multiple goroutines. The goroutine that creates the <code>entry</code> sets their values, and other goroutines read their values once the <q>ready</q> condition has been broadcast. Despite being accessed by multiple goroutines, no mutex lock is necessary. The closing of the <code>ready</code> channel <em>happens before</em> any other goroutine receives the broadcast event, so the write to those variables in the first goroutine <em>happens before</em> they are read by subsequent goroutines. There is no data race.</p>
<p>Our concurrent, duplicate-suppressing, non-blocking cache is complete.</p>
<p>The implementation of <code>Memo</code> above uses a mutex to guard a map variable that is shared by each goroutine that calls <code>Get</code>. It’s interesting to contrast this design with an alternative one in which the map variable is confined to a <em>monitor goroutine</em> to which callers of <code>Get</code> must send a message.</p>
<p>The declarations of <code>Func</code>, <code>result</code>, and <code>entry</code> remain as before:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Func is the type of the function to memoize.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Func</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>

<span class="c1">// A result is the result of calling a Func.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">result</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">err</span>   <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">res</span>   <span class="nx">result</span>
  <span class="nx">ready</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// closed when res is ready
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>However, the <code>Memo</code> type now consists of a channel, <code>requests</code>, through which the caller of <code>Get</code> communicates with the monitor goroutine. The element type of the channel is a <code>request</code>.  Using this structure, the caller of <code>Get</code> sends the monitor goroutine both the key, that is, the argument to the memoized function, and another channel, <code>response</code>, over which the result should be sent back when it becomes available. This channel will carry only a single value.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch9/memo5/memo.go" >gopl.io/ch9/memo5</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// A request is a message requesting that the Func be applied to key.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">request</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">key</span>      <span class="kt">string</span>
  <span class="nx">response</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">result</span> <span class="c1">// the client wants a single result
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">requests</span> <span class="kd">chan</span> <span class="nx">request</span> <span class="p">}</span>

<span class="c1">// New returns a memoization of f.  Clients must subsequently call Close.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="nx">memo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">requests</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">request</span><span class="p">)}</span>
  <span class="k">go</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">server</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">memo</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">response</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">result</span><span class="p">)</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">response</span><span class="p">}</span>
  <span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">response</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>
<p>The <code>Get</code> method, above, creates a response channel, puts it in the request, sends it to the monitor goroutine, then immediately receives from it.</p>
<p>The <code>cache</code> variable is confined to the monitor goroutine <code>(*Memo).server</code>, shown below. The monitor reads requests in a loop until the request channel is closed by the <code>Close</code> method. For each request, it consults the cache, creating and inserting a new <code>entry</code> if none was found.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">server</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">cache</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span> <span class="p">{</span>
    <span class="nx">e</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// This is the first request for this key.
</span><span class="c1"></span>      <span class="nx">e</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entry</span><span class="p">{</span><span class="nx">ready</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})}</span>
      <span class="nx">cache</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
      <span class="k">go</span> <span class="nx">e</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// call f(key)
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">e</span><span class="p">.</span><span class="nx">deliver</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">response</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nx">call</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Evaluate the function.
</span><span class="c1"></span>  <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  <span class="c1">// Broadcast the ready condition.
</span><span class="c1"></span>  <span class="nb">close</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nx">deliver</span><span class="p">(</span><span class="nx">response</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait for the ready condition.
</span><span class="c1"></span>  <span class="o">&lt;-</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span>
  <span class="c1">// Send the result to the client.
</span><span class="c1"></span>  <span class="nx">response</span> <span class="o">&lt;-</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span>
<span class="p">}</span>
</code></pre>
<p>In a similar manner to the mutex-based version, the first request for a given key becomes responsible for calling the function <code>f</code> on that key, storing the result in the <code>entry</code>, and broadcasting the readiness of the <code>entry</code> by closing the <code>ready</code> channel. This is done by <code>(*entry).call</code>.</p>
<p>A subsequent request for the same key finds the existing <code>entry</code> in the map, waits for the result to become ready, and sends the result through the response channel to the client goroutine that called <code>Get</code>. This is done by <code>(*entry).deliver</code>. The <code>call</code> and <code>deliver</code> methods must be called in their own goroutines to ensure that the monitor goroutine does not stop processing new requests.</p>
<p>This example shows that it’s possible to build many concurrent structures using either of the two approaches—shared variables and locks, or communicating sequential processes— without excessive complexity.</p>
<p>It’s not always obvious which approach is preferable in a given situation, but it’s worth knowing how they correspond. Sometimes switching from one approach to the other can make your code simpler.</p>
<p><b>Exercise 9.3</b>: Extend the Func type and the <code>(*Memo).Get</code> method so that callers may provide an optional <code>done</code> channel through which they can cancel the operation (<a href="#section-8.9" >§8.9</a>). The results of a cancelled <code>Func</code> call should not be cached.</p>
</div>
<h3 id="section-9.8" >Goroutines and Threads</h3>
<div class="hBody-3" >
<p>In the previous chapter we said that the difference between goroutines and operating system (OS) threads could be ignored until later. Although the differences between them are essentially quantitative, a big enough quantitative difference becomes a qualitative one, and so it is with goroutines and threads. The time has now come to distinguish them.</p>
</div>
<h4 id="section-9.8.1" >Growable Stacks</h4>
<div class="hBody-4" >
<p>Each OS thread has a fixed-size block of memory (often as large as 2MB) for its <em>stack</em>, the work area where it saves the local variables of function calls that are in progress or temporarily suspended while another function is called. This fixed-size stack is simultaneously too much and too little. A 2MB stack would be a huge waste of memory for a little goroutine, such as one that merely waits for a <code>WaitGroup</code> then closes a channel. It’s not uncommon for a Go program to create hundreds of thousands of goroutines at one time, which would be impossible with stacks this large. Yet despite their size, fixed-size stacks are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both.</p>
<p>In contrast, a goroutine starts life with a small stack, typically 2KB. A goroutine’s stack, like the stack of an OS thread, holds the local variables of active and suspended function calls, but unlike an OS thread, a goroutine’s stack is not fixed; it grows and shrinks as needed. The size limit for a goroutine stack may be as much as 1GB, orders of magnitude larger than a typical fixed-size thread stack, though of course few goroutines use that much.</p>
<p><b>Exercise 9.4</b>: Construct a pipeline that connects an arbitrary number of goroutines with channels. What is the maximum number of pipeline stages you can create without running out of memory? How long does a value take to transit the entire pipeline?</p>
</div>
<h4 id="section-9.8.2" >Goroutine Scheduling</h4>
<div class="hBody-4" >
<p>OS threads are scheduled by the OS kernel. Every few milliseconds, a hardware timer interrupts the processor, which causes a kernel function called the <em>scheduler</em> to be invoked. This function suspends the currently executing thread and saves its registers in memory, looks over the list of threads and decides which one should run next, restores that thread’s registers from memory, then resumes the execution of that thread. Because OS threads are scheduled by the kernel, passing control from one thread to another requires a full <em>context switch</em>, that is, saving the state of one user thread to memory, restoring the state of another, and updating the scheduler’s data structures. This operation is slow, due to its poor locality and the number of memory accesses required, and has historically only gotten worse as the number of CPU cycles required to access memory has increased.</p>
<p>The Go runtime contains its own scheduler that uses a technique known as <em>m:n scheduling</em>, because it multiplexes (or schedules) <em>m</em> goroutines on <em>n</em> OS threads. The job of the Go scheduler is analogous to that of the kernel scheduler, but it is concerned only with the goroutines of a single Go program.</p>
<p>Unlike the operating system’s thread scheduler, the Go scheduler is not invoked periodically by a hardware timer, but implicitly by certain Go language constructs. For example, when a goroutine calls <code>time.Sleep</code> or blocks in a channel or mutex operation, the scheduler puts it to sleep and runs another goroutine until it is time to wake the first one up. Because it doesn’t need a switch to kernel context, rescheduling a goroutine is much cheaper than rescheduling a thread.</p>
<p><b>Exercise 9.5</b>: Write a program with two goroutines that send messages back and forth over two unbuffered channels in ping-pong fashion. How many communications per second can the program sustain?</p>
</div>
<h4 id="section-9.8.3" ><code>GOMAXPROCS</code></h4>
<div class="hBody-4" >
<p>The Go scheduler uses a parameter called <code>GOMAXPROCS</code> to determine how many OS threads may be actively executing Go code simultaneously. Its default value is the number of CPUs on the machine, so on a machine with 8 CPUs, the scheduler will schedule Go code on up to 8 OS threads at once. (<code>GOMAXPROCS</code> is the <span class="math" >n</span> in <span class="math" >m:n</span> scheduling.) Goroutines that are sleeping or blocked in a communication do not need a thread at all. Goroutines that are blocked in I/O or other system calls or are calling non-Go functions, do need an OS thread, but <code>GOMAXPROCS</code> need not account for them.</p>
<p>You can explicitly control this parameter using the <code>GOMAXPROCS</code> environment variable or the <code>runtime.GOMAXPROCS</code> function. We can see the effect of <code>GOMAXPROCS</code> on this little program, which prints an endless stream of zeros and ones:</p>
<pre class="code" ><code class="chroma" ><span class="k">for</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">GOMAXPROCS</span><span class="o">=</span><span class="m">1</span> go run hacker-cliche.go
</span><span class="out" >111111111111111111110000000000000000000011111...
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">GOMAXPROCS</span><span class="o">=</span><span class="m">2</span> go run hacker-cliche.go
</span><span class="out" >010101010101010101011001100101011010010100110...
</span></code></pre>
<p>In the first run, at most one goroutine was executed at a time. Initially, it was the main goroutine, which prints ones. After a period of time, the Go scheduler put it to sleep and woke up the goroutine that prints zeros, giving it a turn to run on the OS thread. In the second run, there were two OS threads available, so both goroutines ran simultaneously, printing digits at about the same rate. We must stress that many factors are involved in goroutine scheduling, and the runtime is constantly evolving, so your results may differ from the ones above.</p>
<p><b>Exercise 9.6</b>: Measure how the performance of a compute-bound parallel program (see Exercise 8.5) varies with <code>GOMAXPROCS</code>. What is the optimal value on your computer? How many CPUs does your computer have?</p>
</div>
<h4 id="section-9.8.4" >Goroutines Have No Identity</h4>
<div class="hBody-4" >
<p>In most operating systems and programming languages that support multithreading, the current thread has a distinct identity that can be easily obtained as an ordinary value, typically an integer or pointer. This makes it easy to build an abstraction called <em>thread-local storage</em>, which is essentially a global map keyed by thread identity, so that each thread can store and retrieve values independent of other threads.</p>
<p>Goroutines have no notion of identity that is accessible to the programmer. This is by design, since thread-local storage tends to be abused. For example, in a web server implemented in a language with thread-local storage, it’s common for many functions to find information about the HTTP request on whose behalf they are currently working by looking in that storage.  However, just as with programs that rely excessively on global variables, this can lead to an unhealthy <q>action at a distance</q> in which the behavior of a function is not determined by its arguments alone, but by the identity of the thread in which it runs. Consequently, if the identity of the thread should change—some worker threads are enlisted to help, say—the function misbehaves mysteriously.</p>
<p>Go encourages a simpler style of programming in which parameters that affect the behavior of a function are explicit. Not only does this make programs easier to read, but it lets us freely assign subtasks of a given function to many different goroutines without worrying about their identity.</p>
<p>You’ve now learned about all the language features you need for writing Go programs. In the next two chapters, we’ll step back to look at some of the practices and tools that support programming in the large: how to structure a project as a set of packages, and how to obtain, build, test, benchmark, profile, document, and share those packages.</p>
</div>
<h2 id="chapter-10" >Packages and the Go Tool</h2>
<div class="hBody-2" >
<p>A modest-size program today might contain 10,000 functions. Yet its author need think about only a few of them and design even fewer, because the vast majority were written by others and made available for reuse through <em>packages</em>.</p>
<p>Go comes with over 100 standard packages that provide the foundations for most applications.  The Go community, a thriving ecosystem of package design, sharing, reuse, and improvement, has published many more, and you can find a searchable index of them at <a href="http://godoc.org" >http://godoc.org</a>.  In this chapter, we’ll show how to use existing packages and create new ones.</p>
<p>Go also comes with the <code class="command" >go</code> tool, a sophisticated but simple-to-use command for managing workspaces of Go packages. Since the beginning of the book, we’ve been showing how to use the <code class="command" >go</code> tool to download, build, and run example programs. In this chapter, we’ll look at the tool’s underlying concepts and tour more of its capabilities, which include printing documentation and querying metadata about the packages in the workspace. In the next chapter we’ll explore its testing features.</p>
</div>
<h3 id="section-10.1" >Introduction</h3>
<div class="hBody-3" >
<p>The purpose of any package system is to make the design and maintenance of large programs practical by grouping related features together into units that can be easily understood and changed, independent of the other packages of the program. This <em>modularity</em> allows packages to be shared and reused by different projects, distributed within an organization, or made available to the wider world.</p>
<p>Each package defines a distinct name space that encloses its identifiers. Each name is associated with a particular package, letting us choose short, clear names for the types, functions, and so on that we use most often, without creating conflicts with other parts of the program.</p>
<p>Packages also provide <em>encapsulation</em> by controlling which names are visible or exported outside the package. Restricting the visibility of package members hides the helper functions and types behind the package’s API, allowing the package maintainer to change the implementation with confidence that no code outside the package will be affected. Restricting visibility also hides variables so that clients can access and update them only through exported functions that preserve internal invariants or enforce mutual exclusion in a concurrent program.</p>
<p>When we change a file, we must recompile the file’s package and potentially all the packages that depend on it. Go compilation is notably faster than most other compiled languages, even when building from scratch. There are three main reasons for the compiler’s speed. First, all imports must be explicitly listed at the beginning of each source file, so the compiler does not have to read and process an entire file to determine its dependencies. Second, the dependencies of a package form a directed acyclic graph, and because there are no cycles, packages can be compiled separately and perhaps in parallel. Finally, the object file for a compiled Go package records export information not just for the package itself, but for its dependencies too.  When compiling a package, the compiler must read one object file for each import but need not look beyond these files.</p>
</div>
<h3 id="section-10.2" >Import Paths</h3>
<div class="hBody-3" >
<p>Each package is identified by a unique string called its <em>import path</em>. Import paths are the strings that appear in <code>import</code> declarations.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;math/rand&#34;</span>
  <span class="s">&#34;encoding/json&#34;</span>

  <span class="s">&#34;golang.org/x/net/html&#34;</span>

  <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>
<span class="p">)</span>
</code></pre>
<p>As we mentioned in <a href="#section-2.6.1" >Section 2.6.1</a>, the Go language specification doesn’t define the meaning of these strings or how to determine a package’s import path, but leaves these issues to the tools. In this chapter, we’ll take a detailed look at how the <code class="command" >go</code> tool interprets them, since that’s what the majority of Go programmers use for building, testing, and so on. Other tools do exist, though. For example, Go programmers using Google’s internal multi-language build system follow different rules for naming and locating packages, specifying tests, and so on, that more closely match the conventions of that system.</p>
<p>For packages you intend to share or publish, import paths should be globally unique. To avoid conflicts, the import paths of all packages other than those from the standard library should start with the Internet domain name of the organization that owns or hosts the package; this also makes it possible to find packages. For example, the declaration above imports an HTML parser maintained by the Go team and a popular third-party MySQL database driver.</p>
</div>
<h3 id="section-10.3" >The Package Declaration</h3>
<div class="hBody-3" >
<p>A <code>package</code> declaration is required at the start of every Go source file. Its main purpose is to determine the default identifier for that package (called the <em>package name</em>) when it is imported by another package.</p>
<p>For example, every file of the <code>math/rand</code> package starts with <code>package rand</code>, so when you import this package, you can access its members as <code>rand.Int</code>, <code>rand.Float64</code>, and so on.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;math/rand&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>
<span class="p">}</span>
</code></pre>
<p>Conventionally, the package name is the last segment of the import path, and as a result, two packages may have the same name even though their import paths necessarily differ. For example, the packages whose import paths are <code>math/rand</code> and <code>crypto/rand</code> both have the name <code>rand</code>. We’ll see how to use both in the same program in a moment.</p>
<p>There are three major exceptions to the <q>last segment</q> convention. The first is that a package defining a command (an executable Go program) always has the name <code>main</code>, regardless of the package’s import path. This is a signal to <code class="command" >go build</code> (<a href="#section-10.7.3" >§10.7.3</a>) that it must invoke the linker to make an executable file.</p>
<p>The second exception is that some files in the directory may have the suffix <code>_test</code> on their package name if the file name ends with <code>_test.go</code>. Such a directory may define <em>two</em> packages: the usual one, plus another one called an <em>external test package</em>. The <code>_test</code> suffix signals to <code class="command" >go test</code> that it must build both packages, and it indicates which files belong to each package.  External test packages are used to avoid cycles in the import graph arising from dependencies of the test; they are covered in more detail in <a href="#section-11.2.4" >Section 11.2.4</a>.</p>
<p>The third exception is that some tools for dependency management append version number suffixes to package import paths, such as <code>&#34;gopkg.in/yaml.v2&#34;</code>. The package name excludes the suffix, so in this case it would be just <code>yaml</code>.</p>
</div>
<h3 id="section-10.4" >Import Declarations</h3>
<div class="hBody-3" >
<p>A Go source file may contain zero or more <code>import</code> declarations immediately after the <code>package</code> declaration and before the first non-import declaration. Each import declaration may specify the import path of a single package, or multiple packages in a parenthesized list. The two forms below are equivalent but the second form is more common.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;os&#34;</span>
</code></pre>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>
</code></pre>
<p>Imported packages may be grouped by introducing blank lines; such groupings usually indicate different domains. The order is not significant, but by convention the lines of each group are sorted alphabetically. (Both <code class="command" >gofmt</code> and <code class="command" >goimports</code> will group and sort for you.)</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;html/template&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;golang.org/x/net/html&#34;</span>
  <span class="s">&#34;golang.org/x/net/ipv4&#34;</span>
<span class="p">)</span>
</code></pre>
<p>If we need to import two packages whose names are the same, like <code>math/rand</code> and <code>crypto/rand</code>, into a third package, the import declaration must specify an alternative name for at least one of them to avoid a conflict. This is called a <em>renaming import</em>.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;crypto/rand&#34;</span>
  <span class="nx">mrand</span> <span class="s">&#34;math/rand&#34;</span> <span class="c1">// alternative name mrand avoids conflict
</span><span class="c1"></span><span class="p">)</span>
</code></pre>
<p>The alternative name affects only the importing file. Other files, even ones in the same package, may import the package using its default name, or a different name.</p>
<p>A renaming import may be useful even when there is no conflict. If the name of the imported package is unwieldy, as is sometimes the case for automatically generated code, an abbreviated name may be more convenient. The same short name should be used consistently to avoid confusion. Choosing an alternative name can help avoid conflicts with common local variable names. For example, in a file with many local variables named <code>path</code>, we might import the standard <code>&#34;path&#34;</code> package as <code>pathpkg</code>.</p>
<p>Each import declaration establishes a dependency from the current package to the imported package. The <code class="command" >go build</code> tool reports an error if these dependencies form a cycle.</p>
</div>
<h3 id="section-10.5" >Blank Imports</h3>
<div class="hBody-3" >
<p>It is an error to import a package into a file but not refer to the name it defines within that file.  However, on occasion we must import a package merely for the side effects of doing so: evaluation of the initializer expressions of its package-level variables and execution of its <code>init</code> functions (<a href="#section-2.6.2" >§2.6.2</a>). To suppress the <q>unused import</q> error we would otherwise encounter, we must use a renaming import in which the alternative name is <code>_</code>, the blank identifier. As usual, the blank identifier can never be referenced.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;image/png&#34;</span> <span class="c1">// register PNG decoder
</span><span class="c1"></span></code></pre>
<p>This is known as a <em>blank import</em>. It is most often used to implement a compile-time mechanism whereby the main program can enable optional features by blank-importing additional packages. First we’ll see how to use it, then we’ll see how it works.</p>
<p>The standard library’s <code>image</code> package exports a <code>Decode</code> function that reads bytes from an <code>io.Reader</code>, figures out which image format was used to encode the data, invokes the appropriate decoder, then returns the resulting <code>image.Image</code>. Using <code>image.Decode</code>, it’s easy to build a simple image converter that reads an image in one format and writes it out in another:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch10/jpeg/main.go" >gopl.io/ch10/jpeg</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// The jpeg command reads a PNG image from the standard input
</span><span class="c1">// and writes it as a JPEG image to the standard output.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;image&#34;</span>
  <span class="s">&#34;image/jpeg&#34;</span>
  <span class="nx">_</span> <span class="s">&#34;image/png&#34;</span> <span class="c1">// register PNG decoder
</span><span class="c1"></span>  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">toJPEG</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;jpeg: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">toJPEG</span><span class="p">(</span><span class="nx">in</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">img</span><span class="p">,</span> <span class="nx">kind</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;Input format =&#34;</span><span class="p">,</span> <span class="nx">kind</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">img</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">jpeg</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span><span class="nx">Quality</span><span class="p">:</span> <span class="mi">95</span><span class="p">})</span>
<span class="p">}</span>
</code></pre>
</div>
<p>If we feed the output of <code>gopl.io/ch3/mandelbrot</code> (<a href="#section-3.3" >§3.3</a>) to the converter program, it detects the PNG input format and writes a JPEG version of Figure 3.3.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch3/mandelbrot
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch10/jpeg
</span><span class="in" ><span class="prompt" >&gt; </span>./mandelbrot <span class="p">|</span> ./jpeg &gt;mandelbrot.jpg
</span><span class="out" >Input format = png
</span></code></pre>
<p>Notice the blank import of <code>image/png</code>. Without that line, the program compiles and links as usual but can no longer recognize or decode input in PNG format:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch10/jpeg
</span><span class="in" ><span class="prompt" >&gt; </span>./mandelbrot <span class="p">|</span> ./jpeg &gt;mandelbrot.jpg
</span><span class="out" >jpeg: image: unknown format
</span></code></pre>
<p>Here’s how it works. The standard library provides decoders for GIF, PNG, and JPEG, and users may provide others, but to keep executables small, decoders are not included in an application unless explicitly requested. The <code>image.Decode</code> function consults a table of supported formats. Each entry in the table specifies four things: the name of the format; a string that is a prefix of all images encoded this way, used to detect the encoding; a function <code>Decode</code> that decodes an encoded image; and another function <code>DecodeConfig</code> that decodes only the image metadata, such as its size and color space. An entry is added to the table by calling <code>image.RegisterFormat</code>, typically from within the package initializer of the supporting package for each format, like this one in <code>image/png</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">png</span> <span class="c1">// image/png
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">Decode</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">DecodeConfig</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Config</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pngHeader</span> <span class="p">=</span> <span class="s">&#34;\x89PNG\r\n\x1a\n&#34;</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">RegisterFormat</span><span class="p">(</span><span class="s">&#34;png&#34;</span><span class="p">,</span> <span class="nx">pngHeader</span><span class="p">,</span> <span class="nx">Decode</span><span class="p">,</span> <span class="nx">DecodeConfig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>The effect is that an application need only blank-import the package for the format it needs to make the <code>image.Decode</code> function able to decode it.</p>
<p>The <code>database/sql</code> package uses a similar mechanism to let users install just the database drivers they need. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;database/sql&#34;</span>
  <span class="nx">_</span> <span class="s">&#34;github.com/lib/pq&#34;</span>                <span class="c1">// enable support for Postgres
</span><span class="c1"></span>  <span class="nx">_</span> <span class="s">&#34;github.com/go-sql-driver/mysql&#34;</span>   <span class="c1">// enable support for MySQL
</span><span class="c1"></span><span class="p">)</span>

<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;postgres&#34;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span> <span class="c1">// OK
</span><span class="c1"></span><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;mysql&#34;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span>    <span class="c1">// OK
</span><span class="c1"></span><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&#34;sqlite3&#34;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span>  <span class="c1">// returns error: unknown driver &#34;sqlite3&#34;
</span><span class="c1"></span></code></pre>
<p><b>Exercise 10.1</b>: Extend the <code class="command" >jpeg</code> program so that it converts any supported input format to any output format, using <code>image.Decode</code> to detect the input format and a flag to select the output format.</p>
<p><b>Exercise 10.2</b>: Define a generic archive file-reading function capable of reading ZIP files (<code>archive/zip</code>) and POSIX tar files (<code>archive/tar</code>). Use a registration mechanism similar to the one described above so that support for each file format can be plugged in using blank imports.</p>
</div>
<h3 id="section-10.6" >Packages and Naming</h3>
<div class="hBody-3" >
<p>In this section, we’ll offer some advice on how to follow Go’s distinctive conventions for naming packages and their members.</p>
<p>When creating a package, keep its name short, but not so short as to be cryptic. The most frequently used packages in the standard library are named <code>bufio</code>, <code>bytes</code>, <code>flag</code>, <code>fmt</code>, <code>http</code>, <code>io</code>, <code>json</code>, <code>os</code>, <code>sort</code>, <code>sync</code>, and <code>time</code>.</p>
<p>Be descriptive and unambiguous where possible. For example, don’t name a utility package <code>util</code> when a name such as <code>imageutil</code> or <code>ioutil</code> is specific yet still concise. Avoid choosing package names that are commonly used for related local variables, or you may compel the package’s clients to use renaming imports, as with the <code>path</code> package.</p>
<p>Package names usually take the singular form. The standard packages <code>bytes</code>, <code>errors</code>, and <code>strings</code> use the plural to avoid hiding the corresponding predeclared types and, in the case of <code>go/types</code>, to avoid conflict with a keyword.</p>
<p>Avoid package names that already have other connotations. For example, we originally used the name <code>temp</code> for the temperature conversion package in <a href="#section-2.5" >Section 2.5</a>, but that didn’t last long. It was a terrible idea because <q>temp</q> is an almost universal synonym for <q>temporary.</q> We went through a brief period with the name <code>temperature</code>, but that was too long and didn’t say what the package did. In the end, it became <code>tempconv</code>, which is shorter and parallel with <code>strconv</code>.</p>
<p>Now let’s turn to the naming of package members. Since each reference to a member of another package uses a qualified identifier such as <code>fmt.Println</code>, the burden of describing the package member is borne equally by the package name and the member name. We need not mention the concept of formatting in <code>Println</code> because the package name <code>fmt</code> does that already. When designing a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples:</p>
<div class="pre-block" >
<pre class="pre" >bytes.Equal     flag.Int     http.Get     json.Marshal
</pre>
</div>
<p>We can identify some common naming patterns. The <code>strings</code> package provides a number of independent functions for manipulating strings:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">strings</span>

<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">needle</span><span class="p">,</span> <span class="nx">haystack</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>

<span class="kd">type</span> <span class="nx">Replacer</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">NewReplacer</span><span class="p">(</span><span class="nx">oldnew</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Replacer</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">NewReader</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reader</span>
</code></pre>
<p>The word <code>string</code> does not appear in any of their names. Clients refer to them as <code>strings.Index</code>, <code>strings.Replacer</code>, and so on.</p>
<p>Other packages that we might describe as <em>single-type packages</em>, such as <code>html/template</code> and <code>math/rand</code>, expose one principal data type plus its methods, and often a New function to create instances.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">rand</span> <span class="c1">// &#34;math/rand&#34;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Rand</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">source</span> <span class="nx">Source</span><span class="p">)</span> <span class="o">*</span><span class="nx">Rand</span>
</code></pre>
<p>This can lead to repetition, as in <code>template.Template</code> or <code>rand.Rand</code>, which is why the names of these kinds of packages are often especially short.</p>
<p>At the other extreme, there are packages like <code>net/http</code> that have a lot of names without a lot of structure, because they perform a complicated task. Despite having over twenty types and many more functions, the package’s most important members have the simplest names: <code>Get</code>, <code>Post</code>, <code>Handle</code>, <code>Error</code>, <code>Client</code>, <code>Server</code>.</p>
</div>
<h3 id="section-10.7" >The Go Tool</h3>
<div class="hBody-3" >
<p>The rest of this chapter concerns the <code class="command" >go</code> tool, which is used for downloading, querying, formatting, building, testing, and installing packages of Go code.</p>
<p>The <code class="command" >go</code> tool combines the features of a diverse set of tools into one command set. It is a package manager (analogous to <code class="command" >apt</code> or <code class="command" >rpm</code>) that answers queries about its inventory of packages, computes their dependencies, and downloads them from remote version-control systems. It is a build system that computes file dependencies and invokes compilers, assemblers, and linkers, although it is intentionally less complete than the standard Unix <code class="command" >make</code>. And it is a test driver, as we will see in <a href="#chapter-11" >Chapter 11</a>.</p>
<p>Its command-line interface uses the <q>Swiss army knife</q> style, with over a dozen subcommands, some of which we have already seen, like <code>get</code>, <code>run</code>, <code>build</code>, and <code>fmt</code>. You can run <code class="command" >go help</code> to see the index of its built-in documentation, but for reference, we’ve listed the most commonly used commands below:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go
</span><span class="out" >...
    build       compile packages and dependencies
    clean       remove object files
    doc         show documentation for package or symbol
    env         print Go environment information
    fix         run go tool fix on packages
    fmt         run gofmt on package sources
    generate    generate Go files by processing source
    get         download and install packages and dependencies
    install     compile and install packages and dependencies
    list        list packages
    run         compile and run Go program
    test        test packages
    tool        run specified go tool
    version     print Go version
    vet         run go tool vet on packages

Use &#34;go help [command]&#34; for more information about a command.
...
</span></code></pre>
<p>To keep the need for configuration to a minimum, the <code class="command" >go</code> tool relies heavily on conventions. For example, given the name of a Go source file, the tool can find its enclosing package, because each directory contains a single package and the import path of a package corresponds to the directory hierarchy in the workspace. Given the import path of a package, the tool can find the corresponding directory in which it stores object files. It can also find the URL of the server that hosts the source code repository.</p>
</div>
<h4 id="section-10.7.1" >Workspace Organization</h4>
<div class="hBody-4" >
<p>The only configuration most users ever need is the <code>GOPATH</code> environment variable, which specifies the root of the workspace. When switching to a different workspace, users update the value of <code>GOPATH</code>. For instance, we set <code>GOPATH</code> to <code>$HOME/gobook</code> while working on this book:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span><span class="nv">$HOME</span>/gobook
</span><span class="in" ><span class="prompt" >&gt; </span>go get gopl.io/...
</span></code></pre>
<p>After you download all the programs for this book using the command above, your workspace will contain a hierarchy like this one:</p>
<div class="pre-block" >
<pre class="pre" >GOPATH/
      src/
          gopl.io/
                  .git/
                  ch1/
                      helloworld/
                                 main.go
                      dup/
                          main.go
                      ...
          golang.org/x/net/
                          .git/
                          html/
                              parse.go
                              node.go
                              ...
      bin/
          helloworld
          dup
      pkg/
          darwin_amd64/
          ...
</pre>
</div>
<p><code>GOPATH</code> has three subdirectories. The <span class="file" >src</span> subdirectory holds source code. Each package resides in a directory whose name relative to <code>$GOPATH/src</code> is the package’s import path, such as <code>gopl.io/ch1/helloworld</code>. Observe that a single <code>GOPATH</code> workspace contains multiple version-control repositories beneath <span class="file" >src</span>, such as <code>gopl.io</code> or <code>golang.org</code>. The <span class="file" >pkg</span> subdirectory is where the build tools store compiled packages, and the <span class="file" >bin</span> subdirectory holds executable programs like <code class="command" >helloworld</code>.</p>
<p>A second environment variable, <code>GOROOT</code>, specifies the root directory of the Go distribution, which provides all the packages of the standard library. The directory structure beneath <code>GOROOT</code> resembles that of <code>GOPATH</code>, so, for example, the source files of the <code>fmt</code> package reside in the <span class="file" >$GOROOT/src/fmt</span> directory. Users never need to set <code>GOROOT</code> since, by default, the <code class="command" >go</code> tool will use the location where it was installed.</p>
<p>The <code class="command" >go env</code> command prints the effective values of the environment variables relevant to the toolchain, including the default values for the missing ones. <code>GOOS</code> specifies the target operating system (for example, <code>android</code>, <code>linux</code>, <code>darwin</code>, or <code>windows</code>) and <code>GOARCH</code> specifies the target processor architecture, such as <code>amd64</code>, <code>386</code>, or <code>arm</code>. Although <code>GOPATH</code> is the only variable you must set, the others occasionally appear in our explanations.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go env
</span><span class="out" >GOPATH=&#34;/home/gopher/gobook&#34;
GOROOT=&#34;/usr/local/go&#34;
GOARCH=&#34;amd64&#34;
GOOS=&#34;darwin&#34;
</span></code></pre>
</div>
<h4 id="section-10.7.2" >Downloading Packages</h4>
<div class="hBody-4" >
<p>When using the <code class="command" >go</code> tool, a package’s import path indicates not only where to find it in the local workspace, but where to find it on the Internet so that <code class="command" >go get</code> can retrieve and update it.</p>
<p>The <code class="command" >go get</code> command can download a single package or an entire subtree or repository using the <code>...</code> notation, as in the previous section. The tool also computes and downloads all the dependencies of the initial packages, which is why the <code>golang.org/x/net/html</code> package appeared in the workspace in the previous example.</p>
<p>Once <code class="command" >go get</code> has downloaded the packages, it builds them and then <em>installs</em> the libraries and commands. We’ll look at the details in the next section, but an example will show how straightforward the process is. The first command below gets the <code class="command" >golint</code> tool, which checks for common style problems in Go source code. The second command runs <code class="command" >golint</code> on <code>gopl.io/ch2/popcount</code> from <a href="#section-2.6.2" >Section 2.6.2</a>. It helpfully reports that we have forgotten to write a doc comment for the package:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go get github.com/golang/lint/golint
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">$GOPATH</span>/bin/golint gopl.io/ch2/popcount
</span><span class="out" >src/gopl.io/ch2/popcount/main.go:1:1:
  package comment should be of the form &#34;Package popcount ...&#34;
</span></code></pre>
<p>The <code class="command" >go get</code> command has support for popular code-hosting sites like GitHub, Bitbucket, and Launchpad and can make the appropriate requests to their version-control systems. For less well-known sites, you may have to indicate which version-control protocol to use in the import path, such as Git or Mercurial. Run <code class="command" >go help importpath</code> for the details.</p>
<p>The directories that <code class="command" >go get</code> creates are true clients of the remote repository, not just copies of the files, so you can use version-control commands to see a diff of local edits you’ve made or to update to a different revision. For example, the <span class="file" >golang.org/x/net</span> directory is a Git client:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/golang.org/x/net
</span><span class="in" ><span class="prompt" >&gt; </span>git remote -v
</span><span class="out" >origin  https://go.googlesource.com/net (fetch)
origin  https://go.googlesource.com/net (push)
</span></code></pre>
<p>Notice that the apparent domain name in the package’s import path, <code>golang.org</code>, differs from the actual domain name of the Git server, <code>go.googlesource.com</code>. This is a feature of the go tool that lets packages use a custom domain name in their import path while being hosted by a generic service such as <a href="https://googlesource.com" >https://googlesource.com</a> or <a href="https://github.com" >https://github.com</a>. HTML pages beneath <a href="https://golang.org/x/net/html" >https://golang.org/x/net/html</a> include the metadata shown below, which redirects the <code class="command" >go</code> tool to the Git repository at the actual hosting site:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/fetch
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch https://golang.org/x/net/html <span class="p">|</span> grep go-import
</span><span class="out" >&lt;meta name=&#34;go-import&#34; content=&#34;golang.org/x/net git https://go.googlesource.com/net&#34;&gt;
</span></code></pre>
<p>If you specify the <code>-u</code> flag, <code class="command" >go get</code> will ensure that all packages it visits, including dependencies, are updated to their latest version before being built and installed. Without that flag, packages that already exist locally will not be updated.</p>
<p>The <code class="command" >go get -u</code> command generally retrieves the latest version of each package, which is convenient when you’re getting started but may be inappropriate for deployed projects, where precise control of dependencies is critical for release hygiene. The usual solution to this problem is to <em>vendor</em> the code, that is, to make a persistent local copy of all the necessary dependencies, and to update this copy carefully and deliberately. Prior to Go 1.5, this required changing those packages’ import paths, so our copy of <code>golang.org/x/net/html</code> would become <code>gopl.io/vendor/golang.org/x/net/html</code>. More recent versions of the go tool support vendoring directly, though we don’t have space to show the details here. See <em>Vendor Directories</em> in the output of the <code class="command" >go help gopath</code> command.</p>
<p><b>Exercise 10.3</b>: Using <code class="command" >fetch http://gopl.io/ch1/helloworld?go-get=1</code>, find out which service hosts the code samples for this book. (HTTP requests from <code class="command" >go get</code> include the <code>go-get</code> parameter so that servers can distinguish them from ordinary browser requests.)</p>
</div>
<h4 id="section-10.7.3" >Building Packages</h4>
<div class="hBody-4" >
<p>The <code class="command" >go build</code> command compiles each argument package. If the package is a library, the result is discarded; this merely checks that the package is free of compile errors. If the package is named <code>main</code>, <code class="command" >go build</code> invokes the linker to create an executable in the current directory; the name of the executable is taken from the last segment of the package’s import path.</p>
<p>Since each directory contains one package, each executable program, or <em>command</em> in Unix terminology, requires its own directory. These directories are sometimes children of a directory named <code>cmd</code>, such as the <code>golang.org/x/tools/cmd/godoc</code> command which serves Go package documentation through a web interface (<a href="#section-10.7.4" >§10.7.4</a>).</p>
<p>Packages may be specified by their import paths, as we saw above, or by a relative directory name, which must start with a <code>.</code> or <code>..</code> segment even if this would not ordinarily be required.  If no argument is provided, the current directory is assumed. Thus the following commands build the same package, though each writes the executable to the directory in which <code class="command" >go build</code> is run:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch1/helloworld
</span><span class="in" ><span class="prompt" >&gt; </span>go build
</span></code></pre>
<p>and:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> anywhere
</span><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch1/helloworld
</span></code></pre>
<p>and:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>
</span><span class="in" ><span class="prompt" >&gt; </span>go build ./src/gopl.io/ch1/helloworld
</span></code></pre>
<p>but not:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>
</span><span class="in" ><span class="prompt" >&gt; </span>go build src/gopl.io/ch1/helloworld
</span><span class="out" >Error: cannot find package &#34;src/gopl.io/ch1/helloworld&#34;.
</span></code></pre>
<p>Packages may also be specified as a list of file names, though this tends to be used only for small programs and one-off experiments. If the package name is <code>main</code>, the executable name comes from the basename of the first <span class="file" >.go</span> file.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>cat quoteargs.go
</span><span class="out" >package main

import (
  &#34;fmt&#34;
  &#34;os&#34;
)

func main() {
  fmt.Printf(&#34;%q\n&#34;, os.Args[1:])
}
</span><span class="in" ><span class="prompt" >&gt; </span>go build quoteargs.go
</span><span class="in" ><span class="prompt" >&gt; </span>./quoteargs one <span class="s2">&#34;two three&#34;</span> four<span class="se">\ </span>five
</span><span class="out" >[&#34;one&#34; &#34;two three&#34; &#34;four five&#34;]
</span></code></pre>
<p>Particularly for throwaway programs like this one, we want to run the executable as soon as we’ve built it. The <code class="command" >go run</code> command combines these two steps:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go run quoteargs.go one <span class="s2">&#34;two three&#34;</span> four<span class="se">\ </span>five
</span><span class="out" >[&#34;one&#34; &#34;two three&#34; &#34;four five&#34;]
</span></code></pre>
<p>The first argument that doesn’t end in <span class="file" >.go</span> is assumed to be the beginning of the list of arguments to the Go executable.</p>
<p>By default, the <code class="command" >go build</code> command builds the requested package and all its dependencies, then throws away all the compiled code except the final executable, if any. Both the dependency analysis and the compilation are surprisingly fast, but as projects grow to dozens of packages and hundreds of thousands of lines of code, the time to recompile dependencies can become noticeable, potentially several seconds, even when those dependencies haven’t changed at all.</p>
<p>The <code class="command" >go install</code> command is very similar to <code class="command" >go build</code>, except that it saves the compiled code for each package and command instead of throwing it away. Compiled packages are saved beneath the <span class="file" >$GOPATH/pkg</span> directory corresponding to the <span class="file" >src</span> directory in which the source resides, and command executables are saved in the <span class="file" >$GOPATH/bin</span> directory. (Many users put <span class="file" >$GOPATH/bin</span> on their executable search path.) Thereafter, <code class="command" >go build</code> and <code class="command" >go install</code> do not run the compiler for those packages and commands if they have not changed, making subsequent builds much faster. For convenience, <code class="command" >go build -i</code> installs the packages that are dependencies of the build target.</p>
<p>Since compiled packages vary by platform and architecture, <code class="command" >go install</code> saves them beneath a subdirectory whose name incorporates the values of the <code>GOOS</code> and <code>GOARCH</code> environment variables. For example, on a Mac the <code>golang.org/x/net/html</code> package is compiled and installed in the file <span class="file" >golang.org/x/net/html.a</span> under <span class="file" >$GOPATH/pkg/darwin_amd64</span>.</p>
<p>It is straightforward to <em>cross-compile</em> a Go program, that is, to build an executable intended for a different operating system or CPU. Just set the <code>GOOS</code> or <code>GOARCH</code> variables during the build.  The <code class="command" >cross</code> program prints the operating system and architecture for which it was built:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch10/cross/main.go" >gopl.io/ch10/cross</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOARCH</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The following commands produce 64-bit and 32-bit executables respectively:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch10/cross
</span><span class="in" ><span class="prompt" >&gt; </span>./cross
</span><span class="out" >darwin amd64
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> go build gopl.io/ch10/cross
</span><span class="in" ><span class="prompt" >&gt; </span>./cross
</span><span class="out" >darwin 386
</span></code></pre>
<p>Some packages may need to compile different versions of the code for certain platforms or processors, to deal with low-level portability issues or to provide optimized versions of important routines, for instance. If a file name includes an operating system or processor architecture name like <span class="file" >net_linux.go</span> or <span class="file" >asm_amd64.s</span>, then the <code class="command" >go</code> tool will compile the file only when building for that target. Special comments called <em>build tags</em> give more fine-grained control. For example, if a file contains this comment:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// +build linux darwin
</span><span class="c1"></span></code></pre>
<p>before the package declaration (and its doc comment), <code class="command" >go build</code> will compile it only when building for Linux or Mac OS X, and this comment says never to compile the file:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// +build ignore
</span><span class="c1"></span></code></pre>
<p>For more details, see the <em>Build Constraints</em> section of the <code>go/build</code> package’s documentation:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc go/build
</span></code></pre>
</div>
<h4 id="section-10.7.4" >Documenting Packages</h4>
<div class="hBody-4" >
<p>Go style strongly encourages good documentation of package APIs. Each declaration of an exported package member and the package declaration itself should be immediately preceded by a comment explaining its purpose and usage.</p>
<p>Go <em>doc comments</em> are always complete sentences, and the first sentence is usually a summary that starts with the name being declared. Function parameters and other identifiers are mentioned without quotation or markup. For example, here’s the doc comment for <code>fmt.Fprintf</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Fprintf formats according to a format specifier and writes to w.
</span><span class="c1">// It returns the number of bytes written and any write error encountered.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre>
<p>The details of <code>Fprintf</code>’s formatting are explained in a doc comment associated with the <code>fmt</code> package itself. A comment immediately preceding a <code>package</code> declaration is considered the doc comment for the package as a whole. There must be only one, though it may appear in any file. Longer package comments may warrant a file of their own; <code>fmt</code>’s is over 300 lines.  This file is usually called <span class="file" >doc.go</span>.</p>
<p>Good documentation need not be extensive, and documentation is no substitute for simplicity.  Indeed, Go’s conventions favor brevity and simplicity in documentation as in all things, since documentation, like code, requires maintenance too. Many declarations can be explained in one well-worded sentence, and if the behavior is truly obvious, no comment is needed. Throughout the book, as space permits, we’ve preceded many declarations by doc comments, but you will find better examples as you browse the standard library. Two tools can help you do that.</p>
<p>The <code class="command" >go doc</code> tool prints the declaration and doc comment of the entity specified on the command line, which may be a package:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc <span class="nb">time</span>
</span><span class="out" >package time // import &#34;time&#34;

Package time provides functionality for measuring and displaying time.

const Nanosecond Duration = 1 ...
func After(d Duration) &lt;-chan Time
func Sleep(d Duration)
func Since(t Time) Duration
func Now() Time
type Duration int64
type Time struct { ... }
...many more...
</span></code></pre>
<p>or a package member:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc time.Since
</span><span class="out" >func Since(t Time) Duration

    Since returns the time elapsed since t.
    It is shorthand for time.Now().Sub(t).
</span></code></pre>
<p>or a method:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc time.Duration.Seconds
</span><span class="out" >func (d Duration) Seconds() float64

    Seconds returns the duration as a floating-point number of seconds.
</span></code></pre>
<p>The tool does not need complete import paths or correct identifier case. This command prints the documentation of <code>(*json.Decoder).Decode</code> from the <code>encoding/json</code> package:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go doc json.decode
</span><span class="out" >func (dec *Decoder) Decode(v interface{}) error

    Decode reads the next JSON-encoded value from its input and stores
    it in the value pointed to by v.
</span></code></pre>
<p>The second tool, confusingly named <code class="command" >godoc</code>, serves cross-linked HTML pages that provide the same information as <code class="command" >go doc</code> and much more. The <code class="command" >godoc</code> server at <a href="https://golang.org/pkg" >https://golang.org/pkg</a> covers the standard library. Figure 10.1 shows the documentation for the <code>time</code> package, and in <a href="#section-11.6" >Section 11.6</a> we’ll see <code class="command" >godoc</code>’s interactive display of example programs. The <code class="command" >godoc</code> server at <a href="https://godoc.org" >https://godoc.org</a> has a searchable index of thousands of open-source packages.</p>
<p>You can also run an instance of <code class="command" >godoc</code> in your workspace if you want to browse your own packages. Visit <a href="http://localhost:8000/pkg" >http://localhost:8000/pkg</a> in your browser while running this command:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>godoc -http<span class="o">=</span>:8000
</span></code></pre>
<p>Its <code>-analysis=type</code> and <code>-analysis=pointer</code> flags augment the documentation and the source code with the results of advanced static analysis.</p>
</div>
<h4 id="section-10.7.5" >Internal Packages</h4>
<div class="hBody-4" >
<p>The package is the most important mechanism for encapsulation in Go programs. Unexported identifiers are visible only within the same package, and exported identifiers are visible to the world.</p>
<p>Sometimes, though, a middle ground would be helpful, a way to define identifiers that are visible to a small set of trusted packages, but not to everyone. For example, when we’re breaking up a large package into more manageable parts, we may not want to reveal the interfaces between those parts to other packages. Or we may want to share utility functions across several packages of a project without exposing them more widely. Or perhaps we just want to experiment with a new package without prematurely committing to its API, by putting it <q>on probation</q> with a limited set of clients.</p>
<div class="figure" >
<h1 class="figure">Figure 10.1. The <code>time</code> package in <code class="command" >godoc</code>.</h1>
<figure>
<img src="img/Figure-10.1.jpg" />
</figure>
</div>
<p>To address these needs, the <code class="command" >go build</code> tool treats a package specially if its import path contains a path segment named <code>internal</code>. Such packages are called <em>internal packages</em>. An internal package may be imported only by another package that is inside the tree rooted at the parent of the <code>internal</code> directory. For example, given the packages below, <code>net/http/internal/chunked</code> can be imported from <code>net/http/httputil</code> or <code>net/http</code>, but not from <code>net/url</code>. However, <code>net/url</code> may import <code>net/http/httputil</code>.</p>
<div class="pre-block" >
<pre class="pre" >net/http
net/http/internal/chunked
net/http/httputil
net/url
</pre>
</div>
</div>
<h4 id="section-10.7.6" >Querying Packages</h4>
<div class="hBody-4" >
<p>The <code class="command" >go list</code> tool reports information about available packages. In its simplest form, <code class="command" >go list</code> tests whether a package is present in the workspace and prints its import path if so:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list github.com/go-sql-driver/mysql
</span><span class="out" >github.com/go-sql-driver/mysql
</span></code></pre>
<p>An argument to <code class="command" >go list</code> may contain the <q><code>...</code></q> wildcard, which matches any substring of a package’s import path. We can use it to enumerate all the packages within a Go workspace:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list ...
</span><span class="out" >archive/tar
archive/zip
bufio
bytes
cmd/addr2line
cmd/api
...many more...
</span></code></pre>
<p>or within a specific subtree:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list gopl.io/ch3/...
</span><span class="out" >gopl.io/ch3/basename1
gopl.io/ch3/basename2
gopl.io/ch3/comma
gopl.io/ch3/mandelbrot
gopl.io/ch3/netflag
gopl.io/ch3/printints
gopl.io/ch3/surface
</span></code></pre>
<p>or related to a particular topic:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list ...xml...
</span><span class="out" >encoding/xml
gopl.io/ch7/xmlselect
</span></code></pre>
<p>The <code class="command" >go list</code> command obtains the complete metadata for each package, not just the import path, and makes this information available to users or other tools in a variety of formats. The <code>-json</code> flag causes <code class="command" >go list</code> to print the entire record of each package in JSON format:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -json <span class="nb">hash</span>
</span><span class="out" >{
    &#34;Dir&#34;: &#34;/home/gopher/go/src/hash&#34;,
    &#34;ImportPath&#34;: &#34;hash&#34;,
    &#34;Name&#34;: &#34;hash&#34;,
    &#34;Doc&#34;: &#34;Package hash provides interfaces for hash functions.&#34;,
    &#34;Target&#34;: &#34;/home/gopher/go/pkg/darwin_amd64/hash.a&#34;,
    &#34;Goroot&#34;: true,
    &#34;Standard&#34;: true,
    &#34;Root&#34;: &#34;/home/gopher/go&#34;,
    &#34;GoFiles&#34;: [
           &#34;hash.go&#34;
    ],
    &#34;Imports&#34;: [
        &#34;io&#34;
    ],
    &#34;Deps&#34;: [
        &#34;errors&#34;,
        &#34;io&#34;,
        &#34;runtime&#34;,
        &#34;sync&#34;,
        &#34;sync/atomic&#34;,
        &#34;unsafe&#34;
    ]
}
</span></code></pre>
<p>The <code>-f</code> flag lets users customize the output format using the template language of package <code>text/template</code> (<a href="#section-4.6" >§4.6</a>). This command prints the transitive dependencies of the <code>strconv</code> package, separated by spaces:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -f <span class="s1">&#39;{{join .Deps &#34; &#34;}}&#39;</span> strconv
</span><span class="out" >errors math runtime unicode/utf8 unsafe
</span></code></pre>
<p>and this command prints the direct imports of each package in the <code>compress</code> subtree of the standard library:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -f <span class="s1">&#39;{{.ImportPath}} -&gt; {{join .Imports &#34; &#34;}}&#39;</span> compress/...
</span><span class="out" >compress/bzip2 -&gt; bufio io sort
compress/flate -&gt; bufio fmt io math sort strconv
compress/gzip -&gt; bufio compress/flate errors fmt hash hash/crc32 io time
compress/lzw -&gt; bufio errors fmt io
compress/zlib -&gt; bufio compress/flate errors fmt hash hash/adler32 io
</span></code></pre>
<p>The <code class="command" >go list</code> command is useful for both one-off interactive queries and for build and test automation scripts. We’ll use it again in <a href="#section-11.2.4" >Section 11.2.4</a>. For more information, including the set of available fields and their meaning, see the output of <code class="command" >go help list</code>.</p>
<p>In this chapter, we’ve explained all the important subcommands of the <code class="command" >go</code> tool—except one. In the next chapter, we’ll see how the <code class="command" >go test</code> command is used for testing Go programs.</p>
<p><b>Exercise 10.4</b>: Construct a tool that reports the set of all packages in the workspace that transitively depend on the packages specified by the arguments. Hint: you will need to run <code class="command" >go list</code> twice, once for the initial packages and once for all packages. You may want to parse its JSON output using the <code class="command" >encoding/json</code> package (<a href="#section-4.5" >§4.5</a>).</p>
</div>
<h2 id="chapter-11" >Testing</h2>
<div class="hBody-2" >
<p>Maurice Wilkes, the developer of EDSAC, the first stored-program computer, had a startling insight while climbing the stairs of his laboratory in 1949. In <em>Memoirs of a Computer Pioneer</em>, he recalled, <q>The realization came over me with full force that a good part of the remainder of my life was going to be spent in finding errors in my own programs.</q> Surely every programmer of a stored-program computer since then can sympathize with Wilkes, though perhaps not without some bemusement at his naïveté about the difficulties of software construction.</p>
<p>Programs today are far larger and more complex than in Wilkes’s time, of course, and a great deal of effort has been spent on techniques to make this complexity manageable. Two techniques in particular stand out for their effectiveness. The first is routine peer review of programs before they are deployed. The second, the subject of this chapter, is testing.</p>
<p>Testing, by which we implicitly mean <em>automated</em> testing, is the practice of writing small programs that check that the code under test (the <em>production</em> code) behaves as expected for certain inputs, which are usually either carefully chosen to exercise certain features or randomized to ensure broad coverage.</p>
<p>The field of software testing is enormous. The task of testing occupies all programmers some of the time and some programmers all of the time. The literature on testing includes thousands of printed books and millions of words of blog posts. In every mainstream programming language, there are dozens of software packages intended for test construction, some with a great deal of theory, and the field seems to attract more than a few prophets with cult-like followings. It is almost enough to convince programmers that to write effective tests they must acquire a whole new set of skills.</p>
<p>Go’s approach to testing can seem rather low-tech in comparison. It relies on one command, <code class="command" >go test</code>, and a set of conventions for writing test functions that <code class="command" >go test</code> can run. The comparatively lightweight mechanism is effective for pure testing, and it extends naturally to benchmarks and systematic examples for documentation.</p>
<p>In practice, writing test code is not much different from writing the original program itself.  We write short functions that focus on one part of the task. We have to be careful of boundary conditions, think about data structures, and reason about what results a computation should produce from suitable inputs. But this is the same process as writing ordinary Go code; it needn’t require new notations, conventions, and tools.</p>
</div>
<h3 id="section-11.1" >The <code class="command" >go test</code> Tool</h3>
<div class="hBody-3" >
<p>The <code class="command" >go test</code> subcommand is a test driver for Go packages that are organized according to certain conventions. In a package directory, files whose names end with <span class="file" >_test.go</span> are not part of the package ordinarily built by <code class="command" >go build</code> but are a part of it when built by <code class="command" >go test</code>.</p>
<p>Within <span class="file" >*_test.go</span> files, three kinds of functions are treated specially : tests, benchmarks, and examples. A <em>test function</em>, which is a function whose name begins with <code>Test</code>, exercises some program logic for correct behavior; <code class="command" >go test</code> calls the test function and reports the result, which is either <code>PASS</code> or <code>FAIL</code>. A <em>benchmark function</em> has a name beginning with <code>Benchmark</code> and measures the performance of some operation; <code class="command" >go test</code> reports the mean execution time of the operation. And an <em>example function</em>, whose name starts with <code>Example</code>, provides machine-checked documentation. We will cover tests in detail in <a href="#section-11.2" >Section 11.2</a>, benchmarks in <a href="#section-11.4" >Section 11.4</a>, and examples in <a href="#section-11.6" >Section 11.6</a>.</p>
<p>The <code class="command" >go test</code> tool scans the <span class="file" >*_test.go</span> files for these special functions, generates a temporary <code>main</code> package that calls them all in the proper way, builds and runs it, reports the results, and then cleans up.</p>
</div>
<h3 id="section-11.2" ><code>Test</code> Functions</h3>
<div class="hBody-3" >
<p>Each test file must import the <code>testing</code> package. Test functions have the following signature:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestName</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Test function names must begin with <code>Test</code>; the optional suffix <em>Name</em> must begin with a capital letter:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestSin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestCos</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestLog</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre>
<p>The <code>t</code> parameter provides methods for reporting test failures and logging additional information. Let’s define an example package <code>gopl.io/ch11/word1</code>, containing a single function <code>IsPalindrome</code> that reports whether a string reads the same forward and backward. (This implementation tests every byte twice if the string is a palindrome; we’ll come back to that shortly.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch11/word1/word.go" >gopl.io/ch11/word1</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package word provides utilities for word games.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">word</span>

<span class="c1">// IsPalindrome reports whether s reads the same forward and backward.
</span><span class="c1">// (Our first attempt.)
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In the same directory, the file <span class="file" >word_test.go</span> contains two test functions named <code>TestPalindrome</code> and <code>TestNonPalindrome</code>. Each checks that <code>IsPalindrome</code> gives the right answer for a single input and reports failures using <code>t.Error</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">word</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nx">TestPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;detartrated&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&#34;detartrated&#34;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;kayak&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&#34;kayak&#34;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestNonPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;palindrome&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&#34;palindrome&#34;) = true`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <code class="command" >go test</code> (or <code class="command" >go build</code>) command with no package arguments operates on the package in the current directory. We can build and run the tests with the following command.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch11/word1
</span><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span>
</span><span class="out" >ok   gopl.io/ch11/word1 0.008s
</span></code></pre>
<p>Satisfied, we ship the program, but no sooner have the launch party guests departed than the bug reports start to arrive. A French user named Noelle Eve Elleon complains that <code>IsPalindrome</code> doesn’t recognize <q>été.</q> Another, from Central America, is disappointed that it rejects <q>A man, a plan, a canal: Panama.</q> These specific and small bug reports naturally lend themselves to new test cases.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestFrenchPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;été&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&#34;été&#34;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestCanalPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="s">&#34;A man, a plan, a canal: Panama&#34;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">`IsPalindrome(%q) = false`</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>To avoid writing the long input string twice, we use <code>Errorf</code>, which provides formatting like <code>Printf</code>.</p>
<p>When the two new tests have been added, the <code class="command" >go test</code> command fails with informative error messages.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span>
</span><span class="out" >--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome(&#34;été&#34;) = false
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome(&#34;A man, a plan, a canal: Panama&#34;) = false
FAIL
FAIL    gopl.io/ch11/word1 0.014s
</span></code></pre>
<p>It’s good practice to write the test first and observe that it triggers the same failure described by the user’s bug report. Only then can we be confident that whatever fix we come up with addresses the right problem.</p>
<p>As a bonus, running <code class="command" >go test</code> is usually quicker than manually going through the steps described in the bug report, allowing us to iterate more rapidly. If the test suite contains many slow tests, we may make even faster progress if we’re selective about which ones we run.</p>
<p>The <code>-v</code> flag prints the name and execution time of each test in the package:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v
</span><span class="out" >=== RUN TestPalindrome
--- PASS: TestPalindrome (0.00s)
=== RUN TestNonPalindrome
--- PASS: TestNonPalindrome (0.00s)
=== RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
word_test.go:28: IsPalindrome(&#34;été&#34;) = false
=== RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
word_test.go:35: IsPalindrome(&#34;A man, a plan, a canal: Panama&#34;) = false
FAIL
exit status 1
FAIL    gopl.io/ch11/word1 0.017s
</span></code></pre>
<p>and the <code>-run</code> flag, whose argument is a regular expression, causes <code class="command" >go test</code> to run only those tests whose function name matches the pattern:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span><span class="s2">&#34;French|Canal&#34;</span>
</span><span class="out" >=== RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
word_test.go:28: IsPalindrome(&#34;été&#34;) = false
=== RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
word_test.go:35: IsPalindrome(&#34;A man, a plan, a canal: Panama&#34;) = false
FAIL
exit status 1
FAIL    gopl.io/ch11/word1 0.014s
</span></code></pre>
<p>Of course, once we’ve gotten the selected tests to pass, we should invoke <code class="command" >go test</code> with no flags to run the entire test suite one last time before we commit the change.</p>
<p>Now our task is to fix the bugs. A quick investigation reveals the cause of the first bug to be <code>IsPalindrome</code>’s use of byte sequences, not rune sequences, so that non-ASCII characters such as the <code>é</code> in <code>&#34;été&#34;</code> confuse it. The second bug arises from not ignoring spaces, punctuation, and letter case.</p>
<p>Chastened, we rewrite the function more carefully:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch11/word2/word.go" >gopl.io/ch11/word2</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Package word provides utilities for word games.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">word</span>

<span class="kn">import</span> <span class="s">&#34;unicode&#34;</span>

<span class="c1">// IsPalindrome reports whether s reads the same forward and backward.
</span><span class="c1">// Letter case is ignored, as are non-letters.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">letters</span> <span class="p">[]</span><span class="kt">rune</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">letters</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">letters</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">letters</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">letters</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">letters</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
</div>
<p>We also write a more comprehensive set of test cases that combines all the previous ones and a number of new ones into a table.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestIsPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="kt">string</span>
    <span class="nx">want</span>  <span class="kt">bool</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;aa&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;ab&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;kayak&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;detartrated&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;A man, a plan, a canal: Panama&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;Evil I did dwell; lewd did I live.&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;Able was I ere I saw Elba&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;été&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;Et se resservir, ivresse reste.&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;palindrome&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span> <span class="c1">// non-palindrome
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;desserts&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span>   <span class="c1">// semi-palindrome
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">:=</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;IsPalindrome(%q) = %v&#34;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">got</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Our new tests pass:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> gopl.io/ch11/word2
</span><span class="out" >ok      gopl.io/ch11/word2        0.015s
</span></code></pre>
<p>This style of <em>table-driven</em> testing is very common in Go. It is straightforward to add new table entries as needed, and since the assertion logic is not duplicated, we can invest more effort in producing a good error message.</p>
<p>The output of a failing test does <em>not</em> include the entire stack trace at the moment of the call to <code>t.Errorf</code>. Nor does <code>t.Errorf</code> cause a panic or stop the execution of the test, unlike assertion failures in many test frameworks for other languages. Tests are independent of each other. If an early entry in the table causes the test to fail, later table entries will still be checked, and thus we may learn about multiple failures during a single run.</p>
<p>When we really must stop a test function, perhaps because some initialization code failed or to prevent a failure already reported from causing a confusing cascade of others, we use <code>t.Fatal</code> or <code>t.Fatalf</code>. These must be called from the same goroutine as the <code>Test</code> function, not from another one created during the test.</p>
<p>Test failure messages are usually of the form <code>&#34;f(x) = y, want z&#34;</code>, where <code>f(x)</code> explains the attempted operation and its input, <code>y</code> is the actual result, and <code>z</code> the expected result. Where convenient, as in our palindrome example, actual Go syntax is used for the <code>f(x)</code> part. Displaying <code>x</code> is particularly important in a table-driven test, since a given assertion is executed many times with different values. Avoid boilerplate and redundant information. When testing a boolean function such as <code>IsPalindrome</code>, omit the want <code>z</code> part since it adds no information. If <code>x</code>, <code>y</code>, or <code>z</code> is lengthy, print a concise summar y of the relevant parts instead. The author of a test should strive to help the programmer who must diagnose a test failure.</p>
<p><b>Exercise 11.1</b>: Write tests for the <code class="command" >charcount</code> program in <a href="#section-4.3" >Section 4.3</a>.</p>
<p><b>Exercise 11.2</b>: Write a set of tests for <code>IntSet</code> (<a href="#section-6.5" >§6.5</a>) that checks that its behavior after each operation is equivalent to a set based on built-in maps. Save your implementation for benchmarking in Exercise 11.7.</p>
</div>
<h4 id="section-11.2.1" >Randomized Testing</h4>
<div class="hBody-4" >
<p>Table-driven tests are convenient for checking that a function works on inputs carefully selected to exercise interesting cases in the logic. Another approach, <em>randomized testing</em>, explores a broader range of inputs by constructing inputs at random.</p>
<p>How do we know what output to expect from our function, given a random input? There are two strategies. The first is to write an alternative implementation of the function that uses a less efficient but simpler and clearer algorithm, and check that both implementations give the same result. The second is to create input values according to a pattern so that we know what output to expect.</p>
<p>The example below uses the second approach: the <code>randomPalindrome</code> function generates words that are known to be palindromes by construction.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;math/rand&#34;</span>

<span class="c1">// randomPalindrome returns a palindrome whose length and contents
</span><span class="c1">// are derived from the pseudo-random number generator rng.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">randomPalindrome</span><span class="p">(</span><span class="nx">rng</span> <span class="o">*</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Rand</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// random length up to 24
</span><span class="c1"></span>  <span class="nx">runes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">rng</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">))</span> <span class="c1">// random rune up to &#39;\u0999&#39;
</span><span class="c1"></span>    <span class="nx">runes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
    <span class="nx">runes</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">runes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestRandomPalindromes</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Initialize a pseudo-random number generator.
</span><span class="c1"></span>  <span class="nx">seed</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">UTC</span><span class="p">().</span><span class="nx">UnixNano</span><span class="p">()</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&#34;Random seed: %d&#34;</span><span class="p">,</span> <span class="nx">seed</span><span class="p">)</span>
  <span class="nx">rng</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="nx">seed</span><span class="p">))</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">randomPalindrome</span><span class="p">(</span><span class="nx">rng</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;IsPalindrome(%q) = false&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Since randomized tests are nondeterministic, it is critical that the log of the failing test record sufficient information to reproduce the failure. In our example, the input <code>p</code> to <code>IsPalindrome</code> tells us all we need to know, but for functions that accept more complex inputs, it may be simpler to log the seed of the pseudo-random number generator (as we do above) than to dump the entire input data structure. Armed with that seed value, we can easily modify the test to replay the failure deterministically.</p>
<p>By using the current time as a source of randomness, the test will explore novel inputs each time it is run, over the entire course of its lifetime. This is especially valuable if your project uses an automated system to run all its tests periodically.</p>
<p><b>Exercise 11.3</b>: <code>TestRandomPalindromes</code> only tests palindromes. Write a randomized test that generates and verifies <em>non</em>-palindromes.</p>
<p><b>Exercise 11.4</b>: Modify <code>randomPalindrome</code> to exercise <code>IsPalindrome</code>’s handling of punctuation and spaces.</p>
</div>
<h4 id="section-11.2.2" >Testing a Command</h4>
<div class="hBody-4" >
<p>The <code class="command" >go test</code> tool is useful for testing library packages, but with a little effort we can use it to test commands as well. A package named <code>main</code> ordinarily produces an executable program, but it can be imported as a library too.</p>
<p>Let’s write a test for the <code class="command" >echo</code> program of <a href="#section-2.3.2" >Section 2.3.2</a>. We’ve split the program into two functions: <code>echo</code> does the real work, while <code>main</code> parses and reads the flag values and reports any errors returned by <code>echo</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch11/echo/echo.go" >gopl.io/ch11/echo</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Echo prints its command-line arguments.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;flag&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&#34;n&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;omit trailing newline&#34;</span><span class="p">)</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&#34;s&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;separator&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span> <span class="c1">// modified during testing
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">(!</span><span class="o">*</span><span class="nx">n</span><span class="p">,</span> <span class="o">*</span><span class="nx">s</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">());</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;echo: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">newline</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">sep</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">newline</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>From the test, we will call <code>echo</code> with a variety of arguments and flag settings and check that it prints the correct output in each case, so we’ve added parameters to <code>echo</code> to reduce its dependence on global variables. That said, we’ve also introduced another global variable, <code>out</code>, the <code>io.Writer</code> to which the result will be written. By having <code>echo</code> write through this variable, not directly to <code>os.Stdout</code>, the tests can substitute a different <code>Writer</code> implementation that records what was written for later inspection. Here’s the test, in file <span class="file" >echo_test.go</span>:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;bytes&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestEcho</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">newline</span> <span class="kt">bool</span>
    <span class="nx">sep</span>     <span class="kt">string</span>
    <span class="nx">args</span>    <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">want</span>    <span class="kt">string</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">&#34;\n&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">&#34;&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&#34;\t&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;one&#34;</span><span class="p">,</span> <span class="s">&#34;two&#34;</span><span class="p">,</span> <span class="s">&#34;three&#34;</span><span class="p">},</span> <span class="s">&#34;one\ttwo\tthree\n&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">},</span> <span class="s">&#34;a,b,c\n&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">},</span> <span class="s">&#34;1:2:3&#34;</span><span class="p">},</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="nx">descr</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;echo(%v, %q, %q)&#34;</span><span class="p">,</span>
      <span class="nx">test</span><span class="p">.</span><span class="nx">newline</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">sep</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span>

    <span class="nx">out</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// captured output
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">newline</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">sep</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s failed: %v&#34;</span><span class="p">,</span> <span class="nx">descr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">out</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s = %q, want %q&#34;</span><span class="p">,</span> <span class="nx">descr</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Notice that the test code is in the same package as the production code. Although the package name is <code>main</code> and it defines a <code>main</code> function, during testing this package acts as a library that exposes the function <code>TestEcho</code> to the test driver; its <code>main</code> function is ignored.</p>
<p>By organizing the test as a table, we can easily add new test cases. Let’s see what happens when the test fails, by adding this line to the table:</p>
<pre class="code" ><code class="chroma" ><span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">},</span> <span class="s">&#34;a b c\n&#34;</span><span class="p">},</span> <span class="c1">// NOTE: wrong expectation!
</span><span class="c1"></span></code></pre>
<p><code class="command" >go test</code> prints</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> gopl.io/ch11/echo
</span><span class="out" >--- FAIL: TestEcho (0.00s)
    echo_test.go:31: echo(true, &#34;,&#34;, [&#34;a&#34; &#34;b&#34; &#34;c&#34;]) = &#34;a,b,c&#34;, want &#34;a b c\n&#34;
FAIL
FAIL    gopl.io/ch11/echo   0.006s
</span></code></pre>
<p>The error message describes the attempted operation (using Go-like syntax), the actual behavior, and the expected behavior, in that order. With an informative error message such as this, you may have a pretty good idea about the root cause before you’ve even located the source code of the test.</p>
<p>It’s important that code being tested not call <code>log.Fatal</code> or <code>os.Exit</code>, since these will stop the process in its tracks; calling these functions should be regarded as the exclusive right of <code>main</code>.  If something totally unexpected happens and a function panics, the test driver will recover, though the test will of course be considered a failure. Expected errors such as those resulting from bad user input, missing files, or improper configuration should be reported by returning a non-nil <code>error</code> value. Fortunately (though unfortunate as an illustration), our <code class="command" >echo</code> example is so simple that it will never return a non-nil error.</p>
</div>
<h4 id="section-11.2.3" >White-Box Testing</h4>
<div class="hBody-4" >
<p>One way of categorizing tests is by the level of knowledge they require of the internal workings of the package under test. A <em>black-box</em> test assumes nothing about the package other than what is exposed by its API and specified by its documentation; the package’s internals are opaque. In contrast, a <em>white-box</em> test has privileged access to the internal functions and data structures of the package and can make observations and changes that an ordinary client cannot. For example, a white-box test can check that the invariants of the package’s data types are maintained after every operation. (The name <em>white box</em> is traditional, but <em>clear box</em> would be more accurate.)</p>
<p>The two approaches are complementary. Black-box tests are usually more robust, needing fewer updates as the software evolves. They also help the test author empathize with the client of the package and can reveal flaws in the API design. In contrast, white-box tests can provide more detailed coverage of the trickier parts of the implementation.</p>
<p>We’ve already seen examples of both kinds. <code>TestIsPalindrome</code> calls only the exported function <code>IsPalindrome</code> and is thus a black-box test. <code>TestEcho</code> calls the <code>echo</code> function and updates the global variable <code>out</code>, both of which are unexported, making it a white-box test.</p>
<p>While developing <code>TestEcho</code>, we modified the <code>echo</code> function to use the package-level variable <code>out</code> when writing its output, so that the test could replace the standard output with an alternative implementation that records the data for later inspection. Using the same technique, we can replace other parts of the production code with easy-to-test <q>fake</q> implementations.  The advantage of fake implementations is that they can be simpler to configure, more predictable, more reliable, and easier to observe. They can also avoid undesirable side effects such as updating a production database or charging a credit card.</p>
<p>The code below shows the quota-checking logic in a web service that provides networked storage to users. When users exceed 90% of their quota, the system sends them a warning email.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch11/storage1/storage.go" >gopl.io/ch11/storage1</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">storage</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;net/smtp&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">usage</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int64</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">usage</span><span class="p">[</span><span class="nx">username</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// Email sender configuration.
</span><span class="c1">// NOTE: never put passwords in source code!
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">sender</span> <span class="p">=</span> <span class="s">&#34;notifications@example.com&#34;</span>
<span class="kd">const</span> <span class="nx">password</span> <span class="p">=</span> <span class="s">&#34;correcthorsebatterystaple&#34;</span>
<span class="kd">const</span> <span class="nx">hostname</span> <span class="p">=</span> <span class="s">&#34;smtp.example.com&#34;</span>

<span class="kd">const</span> <span class="nx">template</span> <span class="p">=</span> <span class="s">`Warning: you are using %d bytes of storage, %d%% of your quota.`</span>

<span class="kd">func</span> <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">used</span> <span class="o">:=</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">quota</span> <span class="p">=</span> <span class="mi">1000000000</span> <span class="c1">// 1GB
</span><span class="c1"></span>  <span class="nx">percent</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">used</span> <span class="o">/</span> <span class="nx">quota</span>
  <span class="k">if</span> <span class="nx">percent</span> <span class="p">&lt;</span> <span class="mi">90</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// OK
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nx">used</span><span class="p">,</span> <span class="nx">percent</span><span class="p">)</span>
  <span class="nx">auth</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">PlainAuth</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">)</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">SendMail</span><span class="p">(</span><span class="nx">hostname</span><span class="o">+</span><span class="s">&#34;:587&#34;</span><span class="p">,</span> <span class="nx">auth</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">username</span><span class="p">},</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">msg</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;smtp.SendMail(%s) failed: %s&#34;</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>We’d like to test it, but we don’t want the test to send out real email. So we move the email logic into its own function and store that function in an unexported package-level variable, <code>notifyUser</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch11/storage2/storage.go" >gopl.io/ch11/storage2</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">auth</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">PlainAuth</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">)</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">SendMail</span><span class="p">(</span><span class="nx">hostname</span><span class="o">+</span><span class="s">&#34;:587&#34;</span><span class="p">,</span> <span class="nx">auth</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">username</span><span class="p">},</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">msg</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;smtp.SendMail(%s) failed: %s&#34;</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">used</span> <span class="o">:=</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">quota</span> <span class="p">=</span> <span class="mi">1000000000</span> <span class="c1">// 1GB
</span><span class="c1"></span>  <span class="nx">percent</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">used</span> <span class="o">/</span> <span class="nx">quota</span>
  <span class="k">if</span> <span class="nx">percent</span> <span class="p">&lt;</span> <span class="mi">90</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// OK
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nx">used</span><span class="p">,</span> <span class="nx">percent</span><span class="p">)</span>
  <span class="nx">notifyUser</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>We can now write a test that substitutes a simple fake notification mechanism instead of sending real email. This one records the notified user and the contents of the message.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">storage</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;strings&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestCheckQuotaNotifiesUser</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="kt">string</span>
  <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="p">=</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span>
  <span class="p">}</span>

  <span class="c1">// ...simulate a 980MB-used condition...
</span><span class="c1"></span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="p">=</span> <span class="s">&#34;joe@example.org&#34;</span>
  <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">notifiedUser</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">notifiedMsg</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;notifyUser not called&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">notifiedUser</span> <span class="o">!=</span> <span class="nx">user</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;wrong user (%s) notified, want %s&#34;</span><span class="p">,</span>
      <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">wantSubstring</span> <span class="p">=</span> <span class="s">&#34;98% of your quota&#34;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">notifiedMsg</span><span class="p">,</span> <span class="nx">wantSubstring</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unexpected notification message &lt;&lt;%s&gt;&gt;, &#34;</span><span class="o">+</span>
      <span class="s">&#34;want substring %q&#34;</span><span class="p">,</span> <span class="nx">notifiedMsg</span><span class="p">,</span> <span class="nx">wantSubstring</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>There’s one problem: after this test function has returned, <code>CheckQuota</code> no longer works as it should because it’s still using the test’s fake implementation of <code>notifyUsers</code>. (There is always a risk of this kind when updating global variables.) We must modify the test to restore the previous value so that subsequent tests observe no effect, and we must do this on all execution paths, including test failures and panics. This naturally suggests <code>defer</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCheckQuotaNotifiesUser</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Save and restore original notifyUser.
</span><span class="c1"></span>  <span class="nx">saved</span> <span class="o">:=</span> <span class="nx">notifyUser</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">notifyUser</span> <span class="p">=</span> <span class="nx">saved</span> <span class="p">}()</span>

  <span class="c1">// Install the test&#39;s fake notifyUser.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="kt">string</span>
  <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="p">=</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span>
  <span class="p">}</span>
  <span class="c1">// ...rest of test...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>This pattern can be used to temporarily save and restore all kinds of global variables, including command-line flags, debugging options, and performance parameters; to install and remove hooks that cause the production code to call some test code when something interesting happens; and to coax the production code into rare but important states, such as timeouts, errors, and even specific interleavings of concurrent activities.</p>
<p>Using global variables in this way is safe only because <code class="command" >go test</code> does not normally run multiple tests concurrently.</p>
</div>
<h4 id="section-11.2.4" >External Test Packages</h4>
<div class="hBody-4" >
<p>Consider the packages <code>net/url</code>, which provides a URL parser, and <code>net/http</code>, which provides a web server and HTTP client library. As we might expect, the higher-level <code>net/http</code> depends on the lower-level <code>net/url</code>. However, one of the tests in net/url is an example demonstrating the interaction between URLs and the HTTP client library. In other words, a test of the lower-level package imports the higher-level package.</p>
<div class="figure" >
<h1 class="figure">Figure 11.1. A test of <code>net/url</code> depends on <code>net/http</code>.</h1>
<figure>
<img src="img/Figure-11.1.jpg" />
</figure>
</div>
<p>Declaring this test function in the <code>net/url</code> package would create a cycle in the package import graph, as depicted by the upwards arrow in Figure 11.1, but as we explained in <a href="#section-10.1" >Section 10.1</a>, the Go specification forbids import cycles.</p>
<p>We resolve the problem by declaring the test function in an <em>external test package</em>, that is, in a file in the <code>net/url</code> directory whose package declaration reads package <code>url_test</code>. The extra suffix <code>_test</code> is a signal to <code class="command" >go test</code> that it should build an additional package containing just these files and run its tests. It may be helpful to think of this external test package as if it had the import path <code>net/url_test</code>, but it cannot be imported under this or any other name.</p>
<p>Because external tests live in a separate package, they may import helper packages that also depend on the package being tested; an in-package test cannot do this. In terms of the design layers, the external test package is logically higher up than both of the packages it depends upon, as shown in Figure 11.2.</p>
<div class="figure" >
<h1 class="figure">Figure 11.2. External test packages break dependency cycles.</h1>
<figure>
<img src="img/Figure-11.2.jpg" />
</figure>
</div>
<p>By avoiding import cycles, external test packages allow tests, especially <em>integration tests</em> (which test the interaction of several components), to import other packages freely, exactly as an application would.</p>
<p>We can use the <code class="command" >go list</code> tool to summarize which Go source files in a package directory are production code, in-package tests, and external tests. We’ll use the <code>fmt</code> package as an example.  <code>GoFiles</code> is the list of files that contain the production code; these are the files that <code class="command" >go build</code> will include in your application:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -f<span class="o">={{</span>.GoFiles<span class="o">}}</span> fmt
</span><span class="out" >[doc.go format.go print.go scan.go]
</span></code></pre>
<p><code>TestGoFiles</code> is the list of files that also belong to the <code>fmt</code> package, but these files, whose names all end in <span class="file" >_test.go</span>, are included only when building tests:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -f<span class="o">={{</span>.TestGoFiles<span class="o">}}</span> fmt
</span><span class="out" >[export_test.go]
</span></code></pre>
<p>The package’s tests would usually reside in these files, though unusually <code>fmt</code> has none; we’ll explain the purpose of <span class="file" >export_test.go</span> in a moment.</p>
<p><code>XTestGoFiles</code> is the list of files that constitute the external test package, <code>fmt_test</code>, so these files must import the <code>fmt</code> package in order to use it. Again, they are included only during testing:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go list -f<span class="o">={{</span>.XTestGoFiles<span class="o">}}</span> fmt
</span><span class="out" >[fmt_test.go scan_test.go stringer_test.go]
</span></code></pre>
<p>Sometimes an external test package may need privileged access to the internals of the package under test, if for example a white-box test must live in a separate package to avoid an import cycle. In such cases, we use a trick: we add declarations to an in-package <span class="file" >_test.go</span> file to expose the necessary internals to the external test. This file thus offers the test a <q>back door</q> to the package. If the source file exists only for this purpose and contains no tests itself, it is often called <span class="file" >export_test.go</span>.</p>
<p>For example, the implementation of the <code>fmt</code> package needs the functionality of <code>unicode.IsSpace</code> as part of <code>fmt.Scanf</code>. To avoid creating an undesirable dependency, <code>fmt</code> does not import the <code>unicode</code> package and its large tables of data; instead, it contains a simpler implementation, which it calls <code>isSpace</code>.</p>
<p>To ensure that the behaviors of <code>fmt.isSpace</code> and <code>unicode.IsSpace</code> do not drift apart, <code>fmt</code> prudently contains a test. It is an external test, and thus it cannot access <code>isSpace</code> directly, so <code>fmt</code> opens a back door to it by declaring an exported variable that holds the internal <code>isSpace</code> function. This is the entirety of the <code>fmt</code> package’s <span class="file" >export_test.go</span> file.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">var</span> <span class="nx">IsSpace</span> <span class="p">=</span> <span class="nx">isSpace</span>
</code></pre>
<p>This test file defines no tests; it just declares the exported symbol <code>fmt.IsSpace</code> for use by the external test. This trick can also be used whenever an external test needs to use some of the techniques of white-box testing.</p>
</div>
<h4 id="section-11.2.5" >Writing Effective Tests</h4>
<div class="hBody-4" >
<p>Many newcomers to Go are surprised by the minimalism of Go’s testing framework. Other languages’ frameworks provide mechanisms for identifying test functions (often using reflection or metadata), hooks for performing <q>setup</q> and <q>teardown</q> operations before and after the tests run, and libraries of utility functions for asserting common predicates, comparing values, formatting error messages, and aborting a failed test (often using exceptions). Although these mechanisms can make tests very concise, the resulting tests often seem like they are written in a foreign language. Furthermore, although they may report <code>PASS</code> or <code>FAIL</code> correctly, their manner may be unfriendly to the unfortunate maintainer, with cryptic failure messages like <code>&#34;assert: 0 == 1&#34;</code> or page after page of stack traces.</p>
<p>Go’s attitude to testing stands in stark contrast. It expects test authors to do most of this work themselves, defining functions to avoid repetition, just as they would for ordinary programs. The process of testing is not one of rote form filling; a test has a user interface too, albeit one whose only users are also its maintainers. A good test does not explode on failure but prints a clear and succinct description of the symptom of the problem, and perhaps other relevant facts about the context. Ideally, the maintainer should not need to read the source code to decipher a test failure. A good test should not give up after one failure but should try to report several errors in a single run, since the pattern of failures may itself be revealing.</p>
<p>The assertion function below compares two values, constructs a generic error message, and stops the program. It’s easy to use and it’s correct, but when it fails, the error message is almost useless. It does not solve the hard problem of providing a good user interface.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;strings&#34;</span>
  <span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="c1">// A poor assertion function.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">assertEqual</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="nx">y</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%d != %d&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="s">&#34;a:b:c&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">)</span>
  <span class="nx">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>In this sense, assertion functions suffer from <em>premature abstraction</em>: by treating the failure of this particular test as a mere difference of two integers, we forfeit the opportunity to provide meaningful context. We can provide a better message by starting from the concrete details, as in the example below. Only once repetitive patterns emerge in a given test suite is it time to introduce abstractions.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="o">:=</span> <span class="s">&#34;a:b:c&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span>
  <span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">want</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">),</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;Split(%q, %q) returned %d words, want %d&#34;</span><span class="p">,</span>
      <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Now the test reports the function that was called, its inputs, and the significance of the result; it explicitly identifies the actual value and the expectation; and it continues to execute even if this assertion should fail. Once we’ve written a test like this, the natural next step is often not to define a function to replace the entire <code>if</code> statement, but to execute the test in a loop in which <code>s</code>, <code>sep</code>, and <code>want</code> vary, like the table-driven test of <code>IsPalindrome</code>.</p>
<p>The previous example didn’t need any utility functions, but of course that shouldn’t stop us from introducing functions when they help make the code simpler. (We’ll look at one such utility function, <code>reflect.DeepEqual</code>, in <a href="#section-13.3" >Section 13.3</a>.) The key to a good test is to start by implementing the concrete behavior that you want and only then use functions to simplify the code and eliminate repetition. Best results are rarely obtained by starting with a library of abstract, generic testing functions.</p>
<p><b>Exercise 11.5</b>: Extend <code>TestSplit</code> to use a table of inputs and expected outputs.</p>
</div>
<h4 id="section-11.2.6" >Avoiding Brittle Tests</h4>
<div class="hBody-4" >
<p>An application that often fails when it encounters new but valid inputs is called <em>buggy</em>; a test that spuriously fails when a sound change was made to the program is called <em>brittle</em>. Just as a buggy program frustrates its users, a brittle test exasperates its maintainers. The most brittle tests, which fail for almost any change to the production code, good or bad, are sometimes called <em>change detector</em> or <em>status quo</em> tests, and the time spent dealing with them can quickly deplete any benefit they once seemed to provide.</p>
<p>When a function under test produces a complex output such as a long string, an elaborate data structure, or a file, it’s tempting to check that the output is exactly equal to some <q>golden</q> value that was expected when the test was written. But as the program evolves, parts of the output will likely change, probably in good ways, but change nonetheless. And it’s not just the output; functions with complex inputs often break because the input used in a test is no longer valid.</p>
<p>The easiest way to avoid brittle tests is to check only the properties you care about. Test your program’s simpler and more stable interfaces in preference to its internal functions. Be selective in your assertions. Don’t check for exact string matches, for example, but look for relevant substrings that will remain unchanged as the program evolves. It’s often worth writing a substantial function to distill a complex output down to its essence so that assertions will be reliable. Even though that may seem like a lot of up-front effort, it can pay for itself quickly in time that would otherwise be spent fixing spuriously failing tests.</p>
</div>
<h3 id="section-11.3" >Coverage</h3>
<div class="hBody-3" >
<p>By its nature, testing is never complete. As the influential computer scientist Edsger Dijkstra put it, <q>Testing shows the presence, not the absence of bugs.</q> No quantity of tests can ever prove a package free of bugs. At best, they increase our confidence that the package works well in a wide range of important scenarios.</p>
<p>The degree to which a test suite exercises the package under test is called the test’s <em>coverage</em>.  Coverage can’t be quantified directly—the dynamics of all but the most trivial programs are beyond precise measurement—but there are heuristics that can help us direct our testing efforts to where they are more likely to be useful.</p>
<p><em>Statement coverage</em> is the simplest and most widely used of these heuristics. The statement coverage of a test suite is the fraction of source statements that are executed at least once during the test. In this section, we’ll use Go’s <code class="command" >cover</code> tool, which is integrated into <code>go test</code>, to measure statement coverage and help identify obvious gaps in the tests.</p>
<p>The code below is a table-driven test for the expression evaluator we built back in <a href="#chapter-7" >Chapter 7</a>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch7/eval/coverage_test.go" >gopl.io/ch7/eval</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestCoverage</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="kt">string</span>
    <span class="nx">env</span>   <span class="nx">Env</span>
    <span class="nx">want</span>  <span class="kt">string</span> <span class="c1">// expected error from Parse/Check or result from Eval
</span><span class="c1"></span>  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&#34;x % 2&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;unexpected &#39;%&#39;&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;!true&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;unexpected &#39;!&#39;&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;log(10)&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">`unknown function &#34;log&#34;`</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;sqrt(1, 2)&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;call to sqrt has 2 args, want 1&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;sqrt(A / pi)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;A&#34;</span><span class="p">:</span> <span class="mi">87616</span><span class="p">,</span> <span class="s">&#34;pi&#34;</span><span class="p">:</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">},</span> <span class="s">&#34;167&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;pow(x, 3) + pow(y, 3)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="s">&#34;1729&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;5 / 9 * (F - 32)&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;F&#34;</span><span class="p">:</span> <span class="o">-</span><span class="mi">40</span><span class="p">},</span> <span class="s">&#34;-40&#34;</span><span class="p">},</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">{})</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s: got %q, want %q&#34;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%.6g&#34;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s: %v =&gt; %s, want %s&#34;</span><span class="p">,</span>
        <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>First, let’s check that the test passes:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -v -run<span class="o">=</span>Coverage gopl.io/ch7/eval
</span><span class="out" >=== RUN TestCoverage
--- PASS: TestCoverage (0.00s)
PASS
ok      gopl.io/ch7/eval    0.011s
</span></code></pre>
<p>This command displays the usage message of the coverage tool:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go tool cover
</span><span class="out" >Usage of &#39;go tool cover&#39;:
Given a coverage profile produced by &#39;go test&#39;:
    go test -coverprofile=c.out
Open a web browser displaying annotated source code:
    go tool cover -html=c.out
</span></code></pre>
<p>The <code class="command" >go tool</code> command runs one of the executables from the Go toolchain. These programs live in the directory <code>$GOROOT/pkg/tool/${GOOS}_${GOARCH}</code>. Thanks to <code class="command" >go build</code>, we rarely need to invoke them directly.</p>
<p>Now we run the test with the <code>-coverprofile</code> flag:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>Coverage -coverprofile<span class="o">=</span>c.out gopl.io/ch7/eval
</span><span class="out" >ok      gopl.io/ch7/eval    0.032s  coverage: 68.5% of statements
</span></code></pre>
<p>This flag enables the collection of coverage data by <em>instrumenting</em> the production code. That is, it modifies a copy of the source code so that before each block of statements is executed, a boolean variable is set, with one variable per block. Just before the modified program exits, it writes the value of each variable to the specified log file <span class="file" >c.out</span> and prints a summary of the fraction of statements that were executed. (If all you need is the summary, use <code class="command" >go test -cover</code>.)</p>
<p>If <code class="command" >go test</code> is run with the <code>-covermode=count</code> flag, the instrumentation for each block increments a counter instead of setting a boolean. The resulting log of execution counts of each block enables quantitative comparisons between <q>hotter</q> blocks, which are more frequently executed, and <q>colder</q> ones.</p>
<p>Having gathered the data, we run the <code class="command" >cover</code> tool, which processes the log, generates an HTML report, and opens it in a new browser window (Figure 11.3).</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go tool cover -html<span class="o">=</span>c.out
</span></code></pre>
<div class="figure" >
<h1 class="figure">Figure 11.3. A coverage report.</h1>
<figure>
<img src="img/Figure-11.3.jpg" />
</figure>
</div>
<p>Each statement is colored green if it was covered or red if it was not covered. For clarity, we’ve shaded the background of the red text. We can see immediately that none of our inputs exercised the unary operator <code>Eval</code> method. If we add this new test case to the table and re-run the previous two commands, the unary expression code becomes green:</p>
<pre class="code" ><code class="chroma" ><span class="p">{</span><span class="s">&#34;-x * -x&#34;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="s">&#34;4&#34;</span><span class="p">}</span>
</code></pre>
<p>The two <code>panic</code> statements remain red, however. This should not be surprising, because these statements are supposed to be unreachable.</p>
<p>Achieving 100% statement coverage sounds like a noble goal, but it is not usually feasible in practice, nor is it likely to be a good use of effort. Just because a statement is executed does not mean it is bug-free; statements containing complex expressions must be executed many times with different inputs to cover the interesting cases. Some statements, like the <code>panic</code> statements above, can never be reached. Others, such as those that handle esoteric errors, are hard to exercise but rarely reached in practice. Testing is fundamentally a pragmatic endeavor, a trade-off between the cost of writing tests and the cost of failures that could have been prevented by tests. Coverage tools can help identify the weakest spots, but devising good test cases demands the same rigorous thinking as programming in general.</p>
</div>
<h3 id="section-11.4" ><code>Benchmark</code> Functions</h3>
<div class="hBody-3" >
<p>Benchmarking is the practice of measuring the performance of a program on a fixed workload. In Go, a benchmark function looks like a test function, but with the <code>Benchmark</code> prefix and a <code>*testing.B</code> parameter that provides most of the same methods as a <code>*testing.T</code>, plus a few extra related to performance measurement. It also exposes an integer field <code>N</code>, which specifies the number of times to perform the operation being measured.</p>
<p>Here’s a benchmark for <code>IsPalindrome</code> that calls it <code>N</code> times in a loop.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;testing&#34;</span>
<span class="kd">func</span> <span class="nx">BenchmarkIsPalindrome</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;A man, a plan, a canal: Panama&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>We run it with the command below. Unlike tests, by default no benchmarks are run. The argument to the <code>-bench</code> flag selects which benchmarks to run. It is a regular expression matching the names of <code>Benchmark</code> functions, with a default value that matches none of them.  The <q><code>.</code></q> pattern causes it to match all benchmarks in the <code>word</code> package, but since there’s only one, <code>-bench=IsPalindrome</code> would have been equivalent.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span><span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch11/word2
</span><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -bench<span class="o">=</span>.
</span><span class="out" >PASS
BenchmarkIsPalindrome-8 1000000               1035 ns/op
ok      gopl.io/ch11/word2      2.179s
</span></code></pre>
<p>The benchmark name’s numeric suffix, <code>8</code> here, indicates the value of <code>GOMAXPROCS</code>, which is important for concurrent benchmarks.</p>
<p>The report tells us that each call to <code>IsPalindrome</code> took about 1.035 microseconds, averaged over 1,000,000 runs. Since the benchmark runner initially has no idea how long the operation takes, it makes some initial measurements using small values of <code>N</code> and then extrapolates to a value large enough for a stable timing measurement to be made.</p>
<p>The reason the loop is implemented by the benchmark function, and not by the calling code in the test driver, is so that the benchmark function has the opportunity to execute any necessary one-time setup code outside the loop without this adding to the measured time of each iteration. If this setup code is still perturbing the results, the <code>testing.B</code> parameter provides methods to stop, resume, and reset the timer, but these are rarely needed.</p>
<p>Now that we have a benchmark and tests, it’s easy to try out ideas for making the program faster. Perhaps the most obvious optimization is to make <code>IsPalindrome</code>’s second loop stop checking at the midpoint, to avoid doing each comparison twice:</p>
<pre class="code" ><code class="chroma" ><span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">letters</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">letters</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</code></pre>
<p>But as is often the case, an obvious optimization doesn’t always yield the expected benefit.  This one delivered a mere 4% improvement in one experiment.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -bench<span class="o">=</span>.
</span><span class="out" >PASS
BenchmarkIsPalindrome-8 1000000                992 ns/op
ok      gopl.io/ch11/word2      2.093s
</span></code></pre>
<p>Another idea is to pre-allocate a sufficiently large array for use by <code>letters</code>, rather than expand it by successive calls to <code>append</code>. Declaring <code>letters</code> as an array of the right size, like this,</p>
<pre class="code" ><code class="chroma" ><span class="nx">letters</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">letters</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">letters</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>yields an improvement of nearly 35%, and the benchmark runner now reports the average over 2,000,000 iterations.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -bench<span class="o">=</span>.
</span><span class="out" >PASS
BenchmarkIsPalindrome-8 2000000                697 ns/op
ok      gopl.io/ch11/word2      1.468s
</span></code></pre>
<p>As this example shows, the fastest program is often the one that makes the fewest memory allocations. The <code>-benchmem</code> command-line flag will include memory allocation statistics in its report. Here we compare the number of allocations before the optimization:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -bench<span class="o">=</span>. -benchmem
</span><span class="out" >PASS
BenchmarkIsPalindrome    1000000  1026 ns/op    304 B/op  4 allocs/op
</span></code></pre>
<p>and after it:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -bench<span class="o">=</span>. -benchmem
</span><span class="out" >PASS
BenchmarkIsPalindrome    2000000   807 ns/op    128 B/op  1 allocs/op
</span></code></pre>
<p>Consolidating the allocations in a single call to <code>make</code> eliminated 75% of the allocations and halved the quantity of allocated memory.</p>
<p>Benchmarks like this tell us the absolute time required for a given operation, but in many settings the interesting performance questions are about the <em>relative</em> timings of two different operations. For example, if a function takes 1ms to process 1,000 elements, how long will it take to process 10,000 or a million? Such comparisons reveal the asymptotic growth of the running time of the function. Another example: what is the best size for an I/O buffer?  Benchmarks of application throughput over a range of sizes can help us choose the smallest buffer that delivers satisfactory performance. A third example: which algorithm performs best for a given job? Benchmarks that evaluate two different algorithms on the same input data can often show the strengths and weaknesses of each one on important or representative workloads.</p>
<p>Comparative benchmarks are just regular code. They typically take the form of a single parameterized function, called from several <code>Benchmark</code> functions with different values, like this:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark10</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span>   <span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark100</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>  <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span>  <span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark1000</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
<p>The parameter <code>size</code>, which specifies the size of the input, varies across benchmarks but is constant within each benchmark. Resist the temptation to use the parameter <code>b.N</code> as the input size. Unless you interpret it as an iteration count for a fixed-size input, the results of your benchmark will be meaningless.</p>
<p>Patterns revealed by comparative benchmarks are particularly useful during program design, but we don’t throw the benchmarks away when the program is working. As the program evolves, or its input grows, or it is deployed on new operating systems or processors with different characteristics, we can reuse those benchmarks to revisit design decisions.</p>
<p><b>Exercise 11.6</b>: Write benchmarks to compare the <code>PopCount</code> implementation in <a href="#section-2.6.2" >Section 2.6.2</a> with your solutions to Exercise 2.4 and Exercise 2.5. At what point does the table-based approach break even?</p>
<p><b>Exercise 11.7</b>: Write benchmarks for <code>Add</code>, <code>UnionWith</code>, and other methods of <code>*IntSet</code> (<a href="#section-6.5" >§6.5</a>) using large pseudo-random inputs. How fast can you make these methods run? How does the choice of word size affect performance? How fast is <code>IntSet</code> compared to a set implementation based on the built-in map type?</p>
</div>
<h3 id="section-11.5" >Profiling</h3>
<div class="hBody-3" >
<p>Benchmarks are useful for measuring the performance of specific operations, but when we’re trying to make a slow program faster, we often have no idea where to begin. Every programmer knows Donald Knuth’s aphorism about premature optimization, which appeared in <q>Structured Programming with go to Statements</q> in 1974. Although often misinterpreted to mean performance doesn’t matter, in its original context we can discern a different meaning:</p>
<blockquote>
<p>There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We <em>should</em> forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.</p>
<p>Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only <em>after</em> that code has been identified. It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail.</p>
</blockquote>
<p>When we wish to look carefully at the speed of our programs, the best technique for identifying the critical code is <em>profiling</em>. Profiling is an automated approach to performance measurement based on sampling a number of profile <em>events</em> during execution, then extrapolating from them during a post-processing step; the resulting statistical summary is called a <em>profile</em>.</p>
<p>Go supports many kinds of profiling, each concerned with a different aspect of performance, but all of them involve recording a sequence of events of interest, each of which has an accompanying stack trace—the stack of function calls active at the moment of the event. The <code class="command" >go test</code> tool has built-in support for several kinds of profiling.</p>
<p>A <em>CPU profile</em> identifies the functions whose execution requires the most CPU time. The currently running thread on each CPU is interrupted periodically by the operating system every few milliseconds, with each interruption recording one profile event before normal execution resumes.</p>
<p>A <em>heap profile</em> identifies the statements responsible for allocating the most memory. The profiling library samples calls to the internal memory allocation routines so that on average, one profile event is recorded per 512KB of allocated memory.</p>
<p>A <em>blocking profile</em> identifies the operations responsible for blocking goroutines the longest, such as system calls, channel sends and receives, and acquisitions of locks. The profiling library records an event every time a goroutine is blocked by one of these operations.</p>
<p>Gathering a profile for code under test is as easy as enabling one of the flags below. Be careful when using more than one flag at a time, however: the machinery for gathering one kind of profile may skew the results of others.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -cpuprofile<span class="o">=</span>cpu.out
</span><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -blockprofile<span class="o">=</span>block.out
</span><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -memprofile<span class="o">=</span>mem.out
</span></code></pre>
<p>It’s easy to add profiling support to non-test programs too, though the details of how we do that vary between short-lived command-line tools and long-running server applications. Profiling is especially useful in long-running applications, so the Go runtime’s profiling features can be enabled under programmer control using the <code>runtime</code> API.</p>
<p>Once we’ve gathered a profile, we need to analyze it using the <code class="command" >pprof</code> tool. This is a standard part of the Go distribution, but since it’s not an everyday tool, it’s accessed indirectly using <code class="command" >go tool pprof</code>. It has dozens of features and options, but basic use requires only two arguments, the executable that produced the profile and the profile log.</p>
<p>To make profiling efficient and to save space, the log does not include function names; instead, functions are identified by their addresses. This means that <code class="command" >pprof</code> needs the executable in order to make sense of the log. Although <code class="command" >go test</code> usually discards the test executable once the test is complete, when profiling is enabled it saves the executable as <span class="file" >foo.test</span>, where <code>foo</code> is the name of the tested package.</p>
<p>The commands below show how to gather and display a simple CPU profile. We’ve selected one of the benchmarks from the <code>net/http</code> package. It is usually better to profile specific benchmarks that have been constructed to be representative of workloads one cares about.  Benchmarking test cases is almost never representative, which is why we disabled them by using the filter <code>-run=NONE</code>.</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go <span class="nb">test</span> -run<span class="o">=</span>NONE -bench<span class="o">=</span>ClientServerParallelTLS64
  -cpuprofile<span class="o">=</span>cpu.log net/http
</span><span class="out" >PASS
BenchmarkClientServerParallelTLS64-8 1000
   3141325 ns/op  143010 B/op  1747 allocs/op
ok      net/http       3.395s

</span><span class="in" ><span class="prompt" >&gt; </span>go tool pprof -text -nodecount<span class="o">=</span><span class="m">10</span> ./http.test cpu.log
</span><span class="out" >2570ms of 3590ms total (71.59%)
Dropped 129 nodes (cum &lt;= 17.95ms)
Showing top 10 nodes out of 166 (cum &gt;= 60ms)
flat    flat%   sum%     cum   cum%
1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree
230ms 6.41%   54.60%   250ms  6.96%  crypto/elliptic.p256Diff
120ms 3.34%   57.94%   120ms  3.34%  math/big.addMulVVW
110ms 3.06%   61.00%   110ms  3.06%  syscall.Syscall
 90ms 2.51%   63.51%  1130ms 31.48%  crypto/elliptic.p256Square
 70ms 1.95%   65.46%   120ms  3.34%  runtime.scanobject
 60ms 1.67%   67.13%   830ms 23.12%  crypto/elliptic.p256Mul
 60ms 1.67%   68.80%   190ms  5.29%  math/big.nat.montgomery
 50ms 1.39%   70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry
 50ms 1.39%   71.59%    60ms  1.67%  crypto/elliptic.p256Sum
</span></code></pre>
<p>The <code>-text</code> flag specifies the output format, in this case, a textual table with one row per function, sorted so the <q>hottest</q> functions—those that consume the most CPU cycles—appear first. The <code>-nodecount=10</code> flag limits the result to 10 rows. For gross performance problems, this textual format may be enough to pinpoint the cause.</p>
<p>This profile tells us that elliptic-curve cryptography is important to the performance of this particular HTTPS benchmark. By contrast, if a profile is dominated by memory allocation functions from the <code>runtime</code> package, reducing memory consumption may be a worthwhile optimization.</p>
<p>For more subtle problems, you may be better off using one of <code class="command" >pprof</code>’s graphical displays. These require GraphViz, which can be downloaded from <a href="www.graphviz.org" >www.graphviz.org</a>. The <code>-web</code> flag then renders a directed graph of the functions of the program, annotated by their CPU profile numbers and colored to indicate the hottest functions.</p>
<p>We’ve only scratched the surface of Go’s profiling tools here. To find out more, read the <q><a href="https://blog.golang.org/profiling-go-programs" >Profiling Go Programs</a></q> article on the Go Blog.</p>
</div>
<h3 id="section-11.6" ><code>Example</code> Functions</h3>
<div class="hBody-3" >
<p>The third kind of function treated specially by <code class="command" >go test</code> is an example function, one whose name starts with <code>Example</code>. It has neither parameters nor results. Here’s an example function for <code class="command" >IsPalindrome</code>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">ExampleIsPalindrome</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;A man, a plan, a canal: Panama&#34;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&#34;palindrome&#34;</span><span class="p">))</span>
  <span class="c1">// Output:
</span><span class="c1"></span>  <span class="c1">// true
</span><span class="c1"></span>  <span class="c1">// false
</span><span class="c1"></span><span class="p">}</span>
</code></pre>
<p>Example functions serve three purposes. The primary one is documentation: a good example can be a more succinct or intuitive way to convey the behavior of a library function than its prose description, especially when used as a reminder or quick reference. An example can also demonstrate the interaction between several types and functions belonging to one API, whereas prose documentation must always be attached to one place, like a type or function declaration or the package as a whole. And unlike examples within comments, example functions are real Go code, subject to compile-time checking, so they don’t become stale as the code evolves.</p>
<p>Based on the suffix of the <code>Example</code> function, the web-based documentation server <code class="command" >godoc</code> associates example functions with the function or package they exemplify, so <code>ExampleIsPalindrome</code> would be shown with the documentation for the <code>IsPalindrome</code> function, and an example function called just <code>Example</code> would be associated with the <code>word</code> package as a whole.</p>
<p>The second purpose is that examples are executable tests run by <code class="command" >go test</code>. If the example function contains a final <code>// Output:</code> comment like the one above, the test driver will execute the function and check that what it printed to its standard output matches the text within the comment.</p>
<p>The third purpose of an example is hands-on experimentation. The <code class="command" >godoc</code> server at <code>golang.org</code> uses the Go Playground to let the user edit and run each example function from within a web browser, as shown in Figure 11.4. This is often the fastest way to get a feel for a particular function or language feature.</p>
<div class="figure" >
<h1 class="figure">Figure 11.4. An interactive example of <code>strings.Join</code> in <code class="command" >godoc</code>.</h1>
<figure>
<img src="img/Figure-11.4.jpg" />
</figure>
</div>
<p>The final two chapters of the book examine the <code>reflect</code> and <code>unsafe</code> packages, which few Go programmers regularly use—and even fewer <em>need</em> to use. If you haven’t written any substantial Go programs yet, now would be a good time to do that.</p>
</div>
<h2 id="chapter-12" >Reflection</h2>
<div class="hBody-2" >
<p>Go provides a mechanism to update variables and inspect their values at run time, to call their methods, and to apply the operations intrinsic to their representation, all without knowing their types at compile time. This mechanism is called <em>reflection</em>. Reflection also lets us treat types themselves as first-class values.</p>
<p>In this chapter, we’ll explore Go’s reflection features to see how they increase the expressiveness of the language, and in particular how they are crucial to the implementation of two important APIs: string formatting provided by <code>fmt</code>, and protocol encoding provided by packages like <code>encoding/json</code> and <code>encoding/xml</code>. Reflection is also essential to the template mechanism provided by the <code>text/template</code> and <code>html/template</code> packages we saw in <a href="#section-4.6" >Section 4.6</a>. However, reflection is complex to reason about and not for casual use, so although these packages are implemented using reflection, they do not expose reflection in their own APIs.</p>
</div>
<h3 id="section-12.1" >Why Reflection?</h3>
<div class="hBody-3" >
<p>Sometimes we need to write a function capable of dealing uniformly with values of types that don’t satisfy a common interface, don’t have a known representation, or don’t exist at the time we design the function—or even all three.</p>
<p>A familiar example is the formatting logic within <code>fmt.Fprintf</code>, which can usefully print an arbitrary value of any type, even a user-defined one. Let’s try to implement a function like it using what we know already. For simplicity, our function will accept one argument and will return the result as a string like <code>fmt.Sprint</code> does, so we’ll call it <code>Sprint</code>.</p>
<p>We start with a type switch that tests whether the argument defines a <code>String</code> method, and call it if so. We then add switch cases that test the value’s dynamic type against each of the basic types—<code>string</code>, <code>int</code>, <code>bool</code>, and so on—and perform the appropriate formatting operation in each case.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Sprint</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="p">}</span>
  <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">stringer</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
  <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span>
  <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="c1">// ...similar cases for int16, uint32, and so on...
</span><span class="c1"></span>  <span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;true&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;false&#34;</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="c1">// array, chan, func, map, pointer, slice, struct
</span><span class="c1"></span>    <span class="k">return</span> <span class="s">&#34;???&#34;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>But how do we deal with other types, like <code>[]float64</code>, <code>map[string][]string</code>, and so on? We could add more cases, but the number of such types is infinite. And what about named types, like <code>url.Values</code>? Even if the type switch had a case for its underlying type <code>map[string][]string</code>, it wouldn’t match <code>url.Values</code> because the two types are not identical, and the type switch cannot include a case for each type like <code>url.Values</code> because that would require this library to depend upon its clients.</p>
<p>Without a way to inspect the representation of values of unknown types, we quickly get stuck.  What we need is reflection.</p>
</div>
<h3 id="section-12.2" ><code>reflect.Type</code> and <code>reflect.Value</code></h3>
<div class="hBody-3" >
<p>Reflection is provided by the <code>reflect</code> package. It defines two important types, <code>Type</code> and <code>Value</code>. A <code>Type</code> represents a Go type. It is an interface with many methods for discriminating among types and inspecting their components, like the fields of a struct or the parameters of a function. The sole implementation of <code>reflect.Type</code> is the type descriptor (<a href="#section-7.5" >§7.5</a>), the same entity that identifies the dynamic type of an interface value.</p>
<p>The <code>reflect.TypeOf</code> function accepts any <code>interface{}</code> and returns its dynamic type as a <code>reflect.Type</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">// a reflect.Type
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;int&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>          <span class="c1">// &#34;int&#34;
</span><span class="c1"></span></code></pre>
<p>The <code>TypeOf(3)</code> call above assigns the value 3 to the <code>interface{}</code> parameter. Recall from <a href="#section-7.5" >Section 7.5</a> that an assignment from a concrete value to an interface type performs an implicit interface conversion, which creates an interface value consisting of two components: its <em>dynamic type</em> is the operand’s type (<code>int</code>) and its <em>dynamic value</em> is the operand’s value (3).</p>
<p>Because <code>reflect.TypeOf</code> returns an interface value’s dynamic type, it always returns a concrete type. So, for example, the code below prints <q><code>*os.File</code></q>, not <q><code>*io.Writer</code></q>. Later, we will see that <code>reflect.Type</code> is capable of representing interface types too.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span> <span class="c1">// &#34;*os.File&#34;
</span><span class="c1"></span></code></pre>
<p>Notice that <code>reflect.Type</code> satisfies <code>fmt.Stringer</code>. Because printing the dynamic type of an interface value is useful for debugging and logging, <code>fmt.Printf</code> provides a shorthand, <code>%T</code>, that uses <code>reflect.TypeOf</code> internally:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// &#34;int&#34;
</span><span class="c1"></span></code></pre>
<p>The other important type in the <code>reflect</code> package is <code>Value</code>. A <code>reflect.Value</code> can hold a value of any type. The <code>reflect.ValueOf</code> function accepts any <code>interface{}</code> and returns a <code>reflect.Value</code> containing the interface’s dynamic value. As with <code>reflect.TypeOf</code>, the results of <code>reflect.ValueOf</code> are always concrete, but a <code>reflect.Value</code> can hold interface values too.</p>
<pre class="code" ><code class="chroma" ><span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">// a reflect.Value
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>           <span class="c1">// &#34;3&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>    <span class="c1">// &#34;3&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>  <span class="c1">// NOTE: &#34;&lt;int Value&gt;&#34;
</span><span class="c1"></span></code></pre>
<p>Like <code>reflect.Type</code>, <code>reflect.Value</code> also satisfies <code>fmt.Stringer</code>, but unless the <code>Value</code> holds a string, the result of the <code>String</code> method reveals only the type. Instead, use the <code>fmt</code> package’s <code>%v</code> verb, which treats <code>reflect.Values</code> specially.</p>
<p>Calling the <code>Type</code> method on a <code>Value</code> returns its type as a <code>reflect.Type</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>           <span class="c1">// a reflect.Type
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &#34;int&#34;
</span><span class="c1"></span></code></pre>
<p>The inverse operation to <code>reflect.ValueOf</code> is the <code>reflect.Value.Interface</code> method. It returns an <code>interface{}</code> holding the same concrete value as the <code>reflect.Value</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// a reflect.Value
</span><span class="c1"></span><span class="nx">x</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Interface</span><span class="p">()</span>      <span class="c1">// an interface{}
</span><span class="c1"></span><span class="nx">i</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>            <span class="c1">// an int
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>   <span class="c1">// &#34;3&#34;
</span><span class="c1"></span></code></pre>
<p>A <code>reflect.Value</code> and an <code>interface{}</code> can both hold arbitrary values. The difference is that an empty interface hides the representation and intrinsic operations of the value it holds and exposes none of its methods, so unless we know its dynamic type and use a type assertion to peer inside it (as we did above), there is little we can do to the value within. In contrast, a <code>Value</code> has many methods for inspecting its contents, regardless of its type. Let’s use them for our second attempt at a general formatting function, which we’ll call <code>format.Any</code>.</p>
<p>Instead of a type switch, we use <code>reflect.Value</code>’s <code>Kind</code> method to discriminate the cases.  Although there are infinitely many types, there are only a finite number of <code>kinds</code> of type: the basic types <code>Bool</code>, <code>String</code>, and all the numbers; the aggregate types <code>Array</code> and <code>Struct</code>; the reference types <code>Chan</code>, <code>Func</code>, <code>Ptr</code>, <code>Slice</code>, and <code>Map</code>; <code>Interface</code> types; and finally <code>Invalid</code>, meaning no value at all. (The zero value of a <code>reflect.Value</code> has kind <code>Invalid</code>.)</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/format/format.go" >gopl.io/ch12/format</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">format</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;reflect&#34;</span>
  <span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="c1">// Any formats any value as a string.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Any</span><span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// formatAtom formats a value without inspecting its internal structure.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">&#34;invalid&#34;</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Int</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Uint</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>
  <span class="c1">// ...floating-point and complex cases omitted for brevity...
</span><span class="c1"></span>  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatBool</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Bool</span><span class="p">())</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Quote</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Chan</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; 0x&#34;</span> <span class="o">+</span>
      <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()),</span> <span class="mi">16</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span> <span class="c1">// reflect.Array, reflect.Struct, reflect.Interface
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; value&#34;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>So far, our function treats each value as an indivisible thing with no internal structure—hence <code>formatAtom</code>. For aggregate types (structs and arrays) and interfaces it prints only the <em>type</em> of the value, and for reference types (channels, functions, pointers, slices, and maps), it prints the type and the reference address in hexadecimal. This is less than ideal but still a major improvement, and since <code>Kind</code> is concerned only with the underlying representation, <code>format.Any</code> works for named types too. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>                  <span class="c1">// &#34;1&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>                  <span class="c1">// &#34;1&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">([]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">x</span><span class="p">}))</span>         <span class="c1">// &#34;[]int64 0x8202b87b0&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">([]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">{</span><span class="nx">d</span><span class="p">}))</span> <span class="c1">// &#34;[]time.Duration 0x8202b87e0&#34;
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-12.3" ><code>Display</code>, a Recursive Value Printer</h3>
<div class="hBody-3" >
<p>Next we’ll take a look at how to improve the display of composite types. Rather than try to copy <code>fmt.Sprint</code> exactly, we’ll build a debugging utility function called <code>Display</code> that, given an arbitrarily complex value <code>x</code>, prints the complete structure of that value, labeling each element with the path by which it was found. Let’s start with an example.</p>
<pre class="code" ><code class="chroma" ><span class="nx">e</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">eval</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="s">&#34;sqrt(A / pi)&#34;</span><span class="p">)</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</code></pre>
<p>In the call above, the argument to <code>Display</code> is a syntax tree from the expression evaluator in <a href="#section-7.9" >Section 7.9</a>. The output of <code>Display</code> is shown below:</p>
<pre class="srci" ><code class="sh" ><span class="out" >Display e (eval.call):
e.fn = &#34;sqrt&#34;
e.args[0].type = eval.binary
e.args[0].value.op = 47
e.args[0].value.x.type = eval.Var
e.args[0].value.x.value = &#34;A&#34;
e.args[0].value.y.type = eval.Var
e.args[0].value.y.value = &#34;pi&#34;
</span></code></pre>
<p>Where possible, you should avoid exposing reflection in the API of a package. We’ll define an unexported function <code>display</code> to do the real work of the recursion, and export <code>Display</code>, a simple wrapper around it that accepts an <code>interface{}</code> parameter:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/display/display.go" >gopl.io/ch12/display</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">Display</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;Display %s (%T):\n&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="nx">display</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In <code>display</code>, we’ll use the <code>formatAtom</code> function we defined earlier to print elementary values—basic types, functions, and channels—but we’ll use the methods of <code>reflect.Value</code> to recursively display each component of a more complex type. As the recursion descends, the path string, which initially describes the starting value (for instance, <q><code>e</code></q>), will be augmented to indicate how we reached the current value (for instance, <q><code>e.args[0].value</code></q>).</p>
<p>Since we’re no longer pretending to implement <code>fmt.Sprint</code>, we will use the <code>fmt</code> package to keep our example short.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">display</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s = invalid\n&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s[%d]&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">fieldPath</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s.%s&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">)</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fieldPath</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapKeys</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;%s[%s]&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">key</span><span class="p">)),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">IsNil</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s = nil\n&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;(*%s)&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">IsNil</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s = nil\n&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s.type = %s\n&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">().</span><span class="nx">Type</span><span class="p">())</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">path</span><span class="o">+</span><span class="s">&#34;.value&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="k">default</span><span class="p">:</span> <span class="c1">// basic types, channels, funcs
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%s = %s\n&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Let’s discuss the cases in order.</p>
<dl>
<dt>Slices and arrays</dt>
<dd>
<p>The logic is the same for both. The Len method returns the number of elements of a slice or array value, and <code>Index(i)</code> retrieves the element at index <code>i</code>, also as a <code>reflect.Value</code>; it panics if <code>i</code> is out of bounds. These are analogous to the built-in <code>len(a)</code> and <code>a[i]</code> operations on sequences. The <code>display</code> function recursively invokes itself on each element of the sequence, appending the subscript notation <q><code>[i]</code></q> to the path.</p>
<p>Although <code>reflect.Value</code> has many methods, only a few are safe to call on any given value.  For example, the Index method may be called on values of kind <code>Slice</code>, <code>Array</code>, or <code>String</code>, but panics for any other kind.</p>
</dd>
<dt>Structs</dt>
<dd>
<p>The <code>NumField</code> method reports the number of fields in the struct, and <code>Field(i)</code> returns the value of the <span class="math" >i</span>-th field as a <code>reflect.Value</code>. The list of fields includes ones promoted from anonymous fields. To append the field selector notation <q><code>.f</code></q> to the path, we must obtain the <code>reflect.Type</code> of the struct and access the name of its <span class="math" >i</span>-th field.</p>
</dd>
<dt>Maps</dt>
<dd>
<p>The <code>MapKeys</code> method returns a slice of <code>reflect.Values</code>, one per map key. As usual when iterating over a map, the order is undefined. <code>MapIndex(key)</code> returns the value corresponding to <code>key</code>. We append the subscript notation <q><code>[key]</code></q> to the path. (We’re cutting a corner here. The type of a map key isn’t restricted to the types <code>formatAtom</code> handles best; arrays, structs, and interfaces can also be valid map keys. Extending this case to print the key in full is Exercise 12.1.)</p>
</dd>
<dt>Pointers</dt>
<dd>
<p>The <code>Elem</code> method returns the variable pointed to by a pointer, again as a <code>reflect.Value</code>. This operation would be safe even if the pointer value is <code>nil</code>, in which case the result would have kind <code>Invalid</code>, but we use IsNil to detect nil pointers explicitly so we can print a more appropriate message. We prefix the path with a <q><code>*</code></q> and parenthesize it to avoid ambiguity.</p>
</dd>
<dt>Interfaces</dt>
<dd>
<p>Again, we use <code>IsNil</code> to test whether the interface is nil, and if not, we retrieve its dynamic value using <code>v.Elem()</code> and print its type and value.</p>
</dd>
</dl>
<p>Now that our <code>Display</code> function is complete, let’s put it to work. The <code>Movie</code> type below is a slight variation on the one in <a href="#section-4.5" >Section 4.5</a>:</p>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">Movie</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span><span class="p">,</span> <span class="nx">Subtitle</span> <span class="kt">string</span>
  <span class="nx">Year</span>            <span class="kt">int</span>
  <span class="nx">Color</span>           <span class="kt">bool</span>
  <span class="nx">Actor</span>           <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
  <span class="nx">Oscars</span>          <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">Sequel</span>          <span class="o">*</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre>
<p>Let’s declare a value of this type and see what <code>Display</code> does with it:</p>
<pre class="code" ><code class="chroma" ><span class="nx">strangelove</span> <span class="o">:=</span> <span class="nx">Movie</span><span class="p">{</span>
  <span class="nx">Title</span><span class="p">:</span>    <span class="s">&#34;Dr. Strangelove&#34;</span><span class="p">,</span>
  <span class="nx">Subtitle</span><span class="p">:</span> <span class="s">&#34;How I Learned to Stop Worrying and Love the Bomb&#34;</span><span class="p">,</span>
  <span class="nx">Year</span><span class="p">:</span>     <span class="mi">1964</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span>    <span class="kc">false</span><span class="p">,</span>
  <span class="nx">Actor</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&#34;Dr. Strangelove&#34;</span><span class="p">:</span>            <span class="s">&#34;Peter Sellers&#34;</span><span class="p">,</span>
    <span class="s">&#34;Grp. Capt. Lionel Mandrake&#34;</span><span class="p">:</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">,</span>
    <span class="s">&#34;Pres. Merkin Muffley&#34;</span><span class="p">:</span>       <span class="s">&#34;Peter Sellers&#34;</span><span class="p">,</span>
    <span class="s">&#34;Gen. Buck Turgidson&#34;</span><span class="p">:</span>        <span class="s">&#34;George C. Scott&#34;</span><span class="p">,</span>
    <span class="s">&#34;Brig. Gen. Jack D. Ripper&#34;</span><span class="p">:</span>  <span class="s">&#34;Sterling Hayden&#34;</span><span class="p">,</span>
    <span class="s">`Maj. T.J. &#34;King&#34; Kong`</span><span class="p">:</span>      <span class="s">&#34;Slim Pickens&#34;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="nx">Oscars</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&#34;Best Actor (Nomin.)&#34;</span><span class="p">,</span>
    <span class="s">&#34;Best Adapted Screenplay (Nomin.)&#34;</span><span class="p">,</span>
    <span class="s">&#34;Best Director (Nomin.)&#34;</span><span class="p">,</span>
    <span class="s">&#34;Best Picture (Nomin.)&#34;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>
</code></pre>
<p>The call <code>Display(&#34;strangelove&#34;, strangelove)</code> prints:</p>
<div class="pre-block" >
<pre class="pre" >Display strangelove (display.Movie):
strangelove.Title = &#34;Dr. Strangelove&#34;
strangelove.Subtitle = &#34;How I Learned to Stop Worrying and Love the Bomb&#34;
strangelove.Year = 1964
strangelove.Color = false
strangelove.Actor[&#34;Gen. Buck Turgidson&#34;] = &#34;George C. Scott&#34;
strangelove.Actor[&#34;Brig. Gen. Jack D. Ripper&#34;] = &#34;Sterling Hayden&#34;
strangelove.Actor[&#34;Maj. T.J. \&#34;King\&#34; Kong&#34;] = &#34;Slim Pickens&#34;
strangelove.Actor[&#34;Dr. Strangelove&#34;] = &#34;Peter Sellers&#34;
strangelove.Actor[&#34;Grp. Capt. Lionel Mandrake&#34;] = &#34;Peter Sellers&#34;
strangelove.Actor[&#34;Pres. Merkin Muffley&#34;] = &#34;Peter Sellers&#34;
strangelove.Oscars[0] = &#34;Best Actor (Nomin.)&#34;
strangelove.Oscars[1] = &#34;Best Adapted Screenplay (Nomin.)&#34;
strangelove.Oscars[2] = &#34;Best Director (Nomin.)&#34;
strangelove.Oscars[3] = &#34;Best Picture (Nomin.)&#34;
strangelove.Sequel = nil
</pre>
</div>
<p>We can use <code>Display</code> to display the internals of library types, such as <code>*os.File</code>:</p>
<div class="pre-block" >
<pre class="pre" >Display(&#34;os.Stderr&#34;, os.Stderr)
// Output:
// Display os.Stderr (*os.File):
// (*(*os.Stderr).file).fd = 2
// (*(*os.Stderr).file).name = &#34;/dev/stderr&#34;
// (*(*os.Stderr).file).nepipe = 0
</pre>
</div>
<p>Notice that even unexported fields are visible to reflection. Beware that the particular output of this example may vary across platforms and may change over time as libraries evolve. (Those fields are private for a reason!) We can even apply <code>Display</code> to a <code>reflect.Value</code> and watch it traverse the internal representation of the type descriptor for <code>*os.File</code>. The output of the call <code>Display(&#34;rV&#34;, reflect.ValueOf(os.Stderr))</code> is shown below, though of course your mileage may vary:</p>
<div class="pre-block" >
<pre class="pre" >Display rV (reflect.Value):
(*rV.typ).size = 8
(*rV.typ).hash = 871609668
(*rV.typ).align = 8
(*rV.typ).fieldAlign = 8
(*rV.typ).kind = 22
(*(*rV.typ).string) = &#34;*os.File&#34;
(*(*(*rV.typ).uncommonType).methods[0].name) = &#34;Chdir&#34;
(*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string) = &#34;func() error&#34;
(*(*(*(*rV.typ).uncommonType).methods[0].typ).string) = &#34;func(*os.File) error&#34;
...
</pre>
</div>
<p>Observe the difference between these two examples:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="mi">3</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&#34;i&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// Display i (int):
</span><span class="c1">// i = 3
</span><span class="c1"></span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&#34;&amp;i&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// Display &amp;i (*interface {}):
</span><span class="c1">// (*&amp;i).type = int
</span><span class="c1">// (*&amp;i).value = 3
</span><span class="c1"></span></code></pre>
<p>In the first example, <code>Display</code> calls <code>reflect.ValueOf(i)</code>, which returns a value of kind <code>Int</code>.  As we mentioned in <a href="#section-12.2" >Section 12.2</a>, <code>reflect.ValueOf</code> always returns a Value of a concrete type since it extracts the contents of an interface value.</p>
<p>In the second example, <code>Display</code> calls <code>reflect.ValueOf(&amp;i)</code>, which returns a pointer to <code>i</code>, of kind <code>Ptr</code>. The switch case for <code>Ptr</code> calls <code>Elem</code> on this value, which returns a Value representing the <em>variable</em> <code>i</code> itself, of kind <code>Interface</code>. A <code>Value</code> obtained indirectly, like this one, may represent any value at all, including interfaces. The <code>display</code> function calls itself recursively and this time, it prints separate components for the interface’s dynamic type and value.</p>
<p>As currently implemented, <code>Display</code> will never terminate if it encounters a cycle in the object graph, such as this linked list that eats its own tail:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// a struct that points to itself
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cycle</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Value</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">Tail</span> <span class="o">*</span><span class="nx">Cycle</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Cycle</span>
<span class="nx">c</span> <span class="p">=</span> <span class="nx">Cycle</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">}</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</code></pre>
<p><code>Display</code> prints this ever-growing expansion:</p>
<pre class="code" ><code class="chroma" ><span class="nx">Display</span> <span class="nx">c</span> <span class="p">(</span><span class="nx">display</span><span class="p">.</span><span class="nx">Cycle</span><span class="p">):</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="o">...</span><span class="nx">ad</span> <span class="nx">infinitum</span><span class="o">...</span>
</code></pre>
<p>Many Go programs contain at least some cyclic data. Making <code>Display</code> robust against such cycles is tricky, requiring additional bookkeeping to record the set of references that have been followed so far; it is costly too. A general solution requires <code>unsafe</code> language features, as we will see in <a href="#section-13.3" >Section 13.3</a>.</p>
<p>Cycles pose less of a problem for <code>fmt.Sprint</code> because it rarely tries to print the complete structure. For example, when it encounters a pointer, it breaks the recursion by printing the pointer’s numeric value. It can get stuck trying to print a slice or map that contains itself as an element, but such rare cases do not warrant the considerable extra trouble of handling cycles.</p>
<p><b>Exercise 12.1</b>: Extend <code>Display</code> so that it can display maps whose keys are structs or arrays.</p>
<p><b>Exercise 12.2</b>: Make <code>display</code> safe to use on cyclic data structures by bounding the number of steps it takes before abandoning the recursion. (In <a href="#section-13.3" >Section 13.3</a>, we’ll see another way to detect cycles.)</p>
</div>
<h3 id="section-12.4" >Example: Encoding S-Expressions</h3>
<div class="hBody-3" >
<p><code>Display</code> is a debugging routine for displaying structured data, but it’s not far short of being able to encode or <em>marshal</em> arbitrary Go objects as messages in a portable notation suitable for inter-process communication.</p>
<p>As we saw in <a href="#section-4.5" >Section 4.5</a>, Go’s standard library supports a variety of formats, including JSON, XML, and ASN.1. Another notation that is still widely used is <em>S-expressions</em>, the syntax of Lisp. Unlike the other notations, S-expressions are not supported by the Go standard library, not least because they have no universally accepted definition, despite several attempts at standardization and the existence of many implementations.</p>
<p>In this section, we’ll define a package that encodes arbitrary Go objects using an S-expression notation that supports the following constructs:</p>
<table border="1">
<tbody>
<tr><td><p><code>42</code></p>
</td><td><p>integer</p>
</td></tr>
<tr><td><p><code>&#34;hello&#34;</code></p>
</td><td><p>string (with Go-style quotation)</p>
</td></tr>
<tr><td><p><code>foo</code></p>
</td><td><p>symbol (an unquoted name)</p>
</td></tr>
<tr><td><p><code>(1 2 3)</code></p>
</td><td><p>list   (zero or more items enclosed in parentheses)</p>
</td></tr>
</tbody>
</table>
<p>Booleans are traditionally encoded using the symbol <code>t</code> for true, and the empty list <code>()</code> or the symbol <code>nil</code> for false, but for simplicity, our implementation ignores them. It also ignores channels and functions, since their state is opaque to reflection. And it ignores real and complex floating-point numbers and interfaces. Adding support for them is Exercise 12.3.</p>
<p>We’ll encode the types of Go using S-expressions as follows. Integers and strings are encoded in the obvious way. Nil values are encoded as the symbol <code>nil</code>. Arrays and slices are encoded using list notation.</p>
<p>Structs are encoded as a list of field bindings, each field binding being a two-element list whose first element (a symbol) is the field name and whose second element is the field value. Maps too are encoded as a list of pairs, with each pair being the key and value of one map entry. Traditionally, S-expressions represent lists of key/value pairs using a single <em>cons</em> cell <code>(key . value)</code> for each pair, rather than a two-element list, but to simplify the decoding we’ll ignore dotted list notation.</p>
<p>Encoding is done by a single recursive function, <code>encode</code>, shown below. Its structure is essentially the same as that of <code>Display</code> in the previous section:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/sexpr/encode.go" >gopl.io/ch12/sexpr</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Uint</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;%q&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span> <span class="c1">// (value ...)
</span><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span> <span class="c1">// ((name value) ...)
</span><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&#34;(%s &#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span> <span class="c1">// ((key value) ...)
</span><span class="c1"></span>    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapKeys</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">default</span><span class="p">:</span> <span class="c1">// float, complex, bool, chan, func, interface
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unsupported type: %s&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>Marshal</code> function wraps the encoder in an API similar to those of the other <code>encoding/...</code> packages:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Marshal encodes a Go value in S-expression form.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Marshal</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Here’s the output of <code>Marshal</code> applied to the <code>strangelove</code> variable from <a href="#section-12.3" >Section 12.3</a>:</p>
<pre class="code" ><code class="chroma" ><span class="p">((</span><span class="nv">Title</span> <span class="s">&#34;Dr. Strangelove&#34;</span><span class="p">)</span> <span class="p">(</span><span class="nv">Subtitle</span> <span class="s">&#34;How I Learned to Stop Worrying and Love the Bomb&#34;</span><span class="p">)</span> <span class="p">(</span><span class="nv">Year</span> <span class="mi">1964</span><span class="p">)</span> <span class="p">(</span><span class="nv">Actor</span> <span class="p">((</span><span class="s">&#34;Grp. Capt. Lionel Mandrake&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;Pres. Merkin Muffley&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;Gen. Buck Turgidson&#34;</span> <span class="s">&#34;George C. Scott&#34;</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;Brig. Gen. Jack D. Ripper&#34;</span> <span class="s">&#34;Sterling Hayden&#34;</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;Maj. T.J. \&#34;King\&#34; Kong&#34;</span> <span class="s">&#34;Slim Pickens&#34;</span><span class="p">)</span> <span class="p">(</span><span class="s">&#34;Dr. Strangelove&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)))</span> <span class="p">(</span><span class="nv">Oscars</span> <span class="p">(</span><span class="s">&#34;Best Actor (Nomin.)&#34;</span> <span class="s">&#34;Best Adapted Screenplay (Nomin.)&#34;</span> <span class="s">&#34;Best Director (Nomin.)&#34;</span> <span class="s">&#34;Best Picture (Nomin.)&#34;</span><span class="p">))</span> <span class="p">(</span><span class="nv">Sequel</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>The whole output appears on one long line with minimal spaces, making it hard to read.  Here’s the same output manually formatted according to S-expression conventions. Writing a pretty-printer for S-expressions is left as a (challenging) exercise; the download from <code>gopl.io</code> includes a simple version.</p>
<pre class="code" ><code class="chroma" ><span class="p">((</span><span class="nv">Title</span> <span class="s">&#34;Dr. Strangelove&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Subtitle</span> <span class="s">&#34;How I Learned to Stop Worrying and Love the Bomb&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Year</span> <span class="mi">1964</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Actor</span> <span class="p">((</span><span class="s">&#34;Grp. Capt. Lionel Mandrake&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&#34;Pres. Merkin Muffley&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&#34;Gen. Buck Turgidson&#34;</span> <span class="s">&#34;George C. Scott&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&#34;Brig. Gen. Jack D. Ripper&#34;</span> <span class="s">&#34;Sterling Hayden&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&#34;Maj. T.J. \&#34;King\&#34; Kong&#34;</span> <span class="s">&#34;Slim Pickens&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&#34;Dr. Strangelove&#34;</span> <span class="s">&#34;Peter Sellers&#34;</span><span class="p">)))</span>
 <span class="p">(</span><span class="nv">Oscars</span> <span class="p">(</span><span class="s">&#34;Best Actor (Nomin.)&#34;</span>
          <span class="s">&#34;Best Adapted Screenplay (Nomin.)&#34;</span>
          <span class="s">&#34;Best Director (Nomin.)&#34;</span>
          <span class="s">&#34;Best Picture (Nomin.)&#34;</span><span class="p">))</span>
 <span class="p">(</span><span class="nv">Sequel</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>Like the <code>fmt.Print</code>, <code>json.Marshal</code>, and <code>Display</code> functions, <code>sexpr.Marshal</code> will loop forever if called with cyclic data.</p>
<p>In <a href="#section-12.6" >Section 12.6</a>, we’ll sketch out the implementation of the corresponding S-expression decoding function, but before we get there, we’ll first need to understand how reflection can be used to update program variables.</p>
<p><b>Exercise 12.3</b>: Implement the missing cases of the <code>encode</code> function. Encode booleans as <code>t</code> and <code>nil</code>, floating-point numbers using Go’s notation, and complex numbers like <span class="math" >1+2i</span> as <code>#C(1.0 2.0)</code>. Interfaces can be encoded as a pair of a type name and a value, for instance <code>(&#34;[</code>int&#34; (1 2 3))], but beware that this notation is ambiguous: the <code>reflect.Type.String</code> method may return the same string for different types.</p>
<p><b>Exercise 12.4</b>: Modify <code>encode</code> to pretty-print the S-expression in the style shown above.</p>
<p><b>Exercise 12.5</b>: Adapt <code>encode</code> to emit JSON instead of S-expressions. Test your encoder using the standard decoder, <code>json.Unmarshal</code>.</p>
<p><b>Exercise 12.6</b>: Adapt <code>encode</code> so that, as an optimization, it does not encode a field whose value is the zero value of its type.</p>
<p><b>Exercise 12.7</b>: Create a streaming API for the S-expression encoder, following the style of <code>json.Encoder</code> (<a href="#section-4.5" >§4.5</a>).</p>
</div>
<h3 id="section-12.5" >Setting Variables with <code>reflect.Value</code></h3>
<div class="hBody-3" >
<p>So far, reflection has only <em>interpreted</em> values in our program in various ways. The point of this section, however, is to <em>change</em> them.</p>
<p>Recall that some Go expressions like <code>x</code>, <code>x.f[1]</code>, and <code>*p</code> denote variables, but others like <code>x + 1</code> and <code>f(2)</code> do not. A variable is an <em>addressable</em> storage location that contains a value, and its value may be updated through that address.</p>
<p>A similar distinction applies to <code>reflect.Values</code>. Some are addressable; others are not.  Consider the following declarations:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>                     <span class="c1">// value   type   variable?
</span><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="c1">// 2       int    no
</span><span class="c1"></span><span class="nx">b</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>    <span class="c1">// 2       int    no
</span><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>   <span class="c1">// &amp;x      *int   no
</span><span class="c1"></span><span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Elem</span><span class="p">()</span>              <span class="c1">// 2       int    yes (x)
</span><span class="c1"></span></code></pre>
<p>The value within <code>a</code> is not addressable. It is merely a copy of the integer 2. The same is true of <code>b</code>. The value within <code>c</code> is also non-addressable, being a copy of the pointer value <code>&amp;x</code>. In fact, no <code>reflect.Value</code> returned by <code>reflect.ValueOf(x)</code> is addressable. But <code>d</code>, derived from <code>c</code> by dereferencing the pointer within it, refers to a variable and is thus addressable. We can use this approach, calling <code>reflect.ValueOf(&amp;x).Elem()</code>, to obtain an addressable <code>Value</code> for any variable <code>x</code>.</p>
<p>We can ask a <code>reflect.Value</code> whether it is addressable through its <code>CanAddr</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span></code></pre>
<p>We obtain an addressable <code>reflect.Value</code> whenever we indirect through a pointer, even if we started from a non-addressable <code>Value</code>. All the usual rules for addressability have analogs for reflection. For example, since the slice indexing expression <code>e[i]</code> implicitly follows a pointer, it is addressable even if the expression <code>e</code> is not. By analogy, <code>reflect.ValueOf(e).Index(i)</code> refers to a variable, and is thus addressable even if <code>reflect.ValueOf(e)</code> is not.</p>
<p>To recover the variable from an addressable <code>reflect.Value</code> requires three steps. First, we call <code>Addr()</code>, which returns a Value holding a pointer to the variable. Next, we call <code>Interface()</code> on this <code>Value</code>, which returns an <code>interface{}</code> value containing the pointer. Finally, if we know the type of the variable, we can use a type assertion to retrieve the contents of the interface as an ordinary pointer. We can then update the variable through the pointer:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>    <span class="c1">// d refers to the variable x
</span><span class="c1"></span><span class="nx">px</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Addr</span><span class="p">().</span><span class="nx">Interface</span><span class="p">().(</span><span class="o">*</span><span class="kt">int</span><span class="p">)</span>  <span class="c1">// px := &amp;x
</span><span class="c1"></span><span class="o">*</span><span class="nx">px</span> <span class="p">=</span> <span class="mi">3</span>                            <span class="c1">// x = 3
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>                     <span class="c1">// &#34;3&#34;
</span><span class="c1"></span></code></pre>
<p>Or, we can update the variable referred to by an addressable <code>reflect.Value</code> directly, without using a pointer, by calling the <code>reflect.Value.Set</code> method:</p>
<pre class="code" ><code class="chroma" ><span class="nx">d</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;4&#34;
</span><span class="c1"></span></code></pre>
<p>The same checks for assignability that are ordinarily performed by the compiler are done at run time by the <code>Set</code> methods. Above, the variable and the value both have type <code>int</code>, but if the variable had been an <code>int64</code>, the program would panic, so it’s crucial to make sure the value is assignable to the type of the variable:</p>
<pre class="code" ><code class="chroma" ><span class="nx">d</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span> <span class="c1">// panic: int64 is not assignable to int
</span><span class="c1"></span></code></pre>
<p>And of course calling <code>Set</code> on a non-addressable <code>reflect.Value</code> panics too:</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// panic: Set using unaddressable value
</span><span class="c1"></span></code></pre>
<p>There are variants of <code>Set</code> specialized for certain groups of basic types: <code>SetInt</code>, <code>SetUint</code>, <code>SetString</code>, <code>SetFloat</code>, and so on:</p>
<pre class="code" ><code class="chroma" ><span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &#34;3&#34;
</span><span class="c1"></span></code></pre>
<p>In some ways these methods are more forgiving. <code>SetInt</code>, for example, will succeed so long as the variable’s type is some kind of signed integer, or even a named type whose underlying type is a signed integer, and if the value is too large it will be quietly truncated to fit. But tread carefully: calling <code>SetInt</code> on a <code>reflect.Value</code> that refers to an <code>interface{}</code> variable will panic, even though <code>Set</code> would succeed.</p>
<pre class="code" ><code class="chroma" ><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">rx</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                     <span class="c1">// OK, x = 2
</span><span class="c1"></span><span class="nx">rx</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>       <span class="c1">// OK, x = 3
</span><span class="c1"></span><span class="nx">rx</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>            <span class="c1">// panic: string is not assignable to int
</span><span class="c1"></span><span class="nx">rx</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// panic: string is not assignable to int
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">ry</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">ry</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                     <span class="c1">// panic: SetInt called on interface Value
</span><span class="c1"></span><span class="nx">ry</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>       <span class="c1">// OK, y = int(3)
</span><span class="c1"></span><span class="nx">ry</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>            <span class="c1">// panic: SetString called on interface Value
</span><span class="c1"></span><span class="nx">ry</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">))</span> <span class="c1">// OK, y = &#34;hello&#34;
</span><span class="c1"></span></code></pre>
<p>When we applied <code>Display</code> to <code>os.Stdout</code>, we found that reflection can read the values of unexported struct fields that are inaccessible according to the usual rules of the language, like the <code>fd int</code> field of an <code>os.File</code> struct on a Unix-like platform. However, reflection cannot update such values:</p>
<pre class="code" ><code class="chroma" ><span class="nx">stdout</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span> <span class="c1">// *os.Stdout, an os.File var
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>                  <span class="c1">// &#34;os.File&#34;
</span><span class="c1"></span><span class="nx">fd</span> <span class="o">:=</span> <span class="nx">stdout</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&#34;fd&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span> <span class="c1">// &#34;1&#34;
</span><span class="c1"></span><span class="nx">fd</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>          <span class="c1">// panic: unexported field
</span><span class="c1"></span></code></pre>
<p>An addressable <code>reflect.Value</code> records whether it was obtained by traversing an unexported struct field and, if so, disallows modification. Consequently, <code>CanAddr</code> is not usually the right check to use before setting a variable. The related method <code>CanSet</code> reports whether a <code>reflect.Value</code> is addressable <em>and</em> settable:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">(),</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">CanSet</span><span class="p">())</span> <span class="c1">// &#34;true false&#34;
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-12.6" >Example: Decoding S-Expressions</h3>
<div class="hBody-3" >
<p>For each <code>Marshal</code> function provided by the standard library’s <code>encoding/...</code> packages, there is a corresponding <code>Unmarshal</code> function that does decoding. For example, as we saw in <a href="#section-4.5" >Section 4.5</a>, given a byte slice containing JSON-encoded data for our <code>Movie</code> type (<a href="#section-12.3" >§12.3</a>), we can decode it like this:</p>
<pre class="code" ><code class="chroma" ><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">movie</span> <span class="nx">Movie</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">movie</span><span class="p">)</span>
</code></pre>
<p>The <code>Unmarshal</code> function uses reflection to modify the fields of the existing <code>movie</code> variable, creating new maps, structs, and slices as determined by the type <code>Movie</code> and the content of the incoming data.</p>
<p>Let’s now implement a simple <code>Unmarshal</code> function for S-expressions, analogous to the standard <code>json.Unmarshal</code> function used above, and the inverse of our earlier <code>sexpr.Marshal</code>. We must caution you that a robust and general implementation requires substantially more code than will comfortably fit in this example, which is already long, so we have taken many shortcuts. We support only a limited subset of S-expressions and do not handle errors gracefully. The code is intended to illustrate reflection, not parsing.</p>
<p>The lexer uses the <code>Scanner</code> type from the <code>text/scanner</code> package to break an input stream into a sequence of tokens such as comments, identifiers, string literals, and numeric literals.  The scanner’s <code>Scan</code> method advances the scanner and returns the kind of the next token, which has type <code>rune</code>. Most tokens, like <code>&#39;(&#39;</code>, consist of a single rune, but the <code>text/scanner</code> package represents the kinds of the multi-character tokens <code>Ident</code>, <code>String</code>, and <code>Int</code> using small negative values of type <code>rune</code>. Following a call to <code>Scan</code> that returns one of these kinds of token, the scanner’s <code>TokenText</code> method returns the text of the token.</p>
<p>Since a typical parser may need to inspect the current token several times, but the <code>Scan</code> method advances the scanner, we wrap the scanner in a helper type called <code>lexer</code> that keeps track of the token most recently returned by <code>Scan</code>.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/sexpr/decode.go" >gopl.io/ch12/sexpr</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">type</span> <span class="nx">lexer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">scan</span>  <span class="nx">scanner</span><span class="p">.</span><span class="nx">Scanner</span>
  <span class="nx">token</span> <span class="kt">rune</span> <span class="c1">// the current token
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">next</span><span class="p">()</span>        <span class="p">{</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">=</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">text</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">TokenText</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">consume</span><span class="p">(</span><span class="nx">want</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span> <span class="c1">// NOTE: Not an example of good error handling.
</span><span class="c1"></span>    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;got %q, want %q&#34;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">(),</span> <span class="nx">want</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now let’s turn to the parser. It consists of two principal functions. The first of these, <code>read</code>, reads the S-expression that starts with the current token and updates the variable referred to by the addressable <code>reflect.Value v</code>.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Ident</span><span class="p">:</span>
    <span class="c1">// The only valid identifiers are
</span><span class="c1"></span>    <span class="c1">// &#34;nil&#34; and struct field names.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;nil&#34;</span> <span class="p">{</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Zero</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Unquote</span><span class="p">(</span><span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">())</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>    <span class="nx">v</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">())</span> <span class="c1">// NOTE: ignoring errors
</span><span class="c1"></span>    <span class="nx">v</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">:</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="nx">readList</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// consume &#39;)&#39;
</span><span class="c1"></span>    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;unexpected token %q&#34;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre>
<p>Our S-expressions use identifiers for two distinct purposes, struct field names and the <code>nil</code> value for a pointer. The <code>read</code> function only handles the latter case. When it encounters the <code>scanner.Ident</code> <q><code>nil</code></q>, it sets <code>v</code> to the zero value of its type using the <code>reflect.Zero</code> function.  For any other identifier, it reports an error. The <code>readList</code> function, which we’ll see in a moment, handles identifiers used as struct field names.</p>
<p>A <code>&#39;(&#39;</code> token indicates the start of a list. The second function, <code>readList</code>, decodes a list into a variable of composite type—a map, struct, slice, or array—depending on what kind of Go variable we’re currently populating. In each case, the loop keeps parsing items until it encounters the matching close parenthesis, <code>&#39;)&#39;</code>, as detected by the <code>endList</code> function.</p>
<p>The interesting part is the recursion. The simplest case is an array. Until the closing <code>&#39;)&#39;</code> is seen, we use <code>Index</code> to obtain the variable for each array element and make a recursive call to <code>read</code> to populate it. As in many other error cases, if the input data causes the decoder to index beyond the end of the array, the decoder panics. A similar approach is used for slices, except we must create a new variable for each element, populate it, then append it to the slice.</p>
<p>The loops for structs and maps must parse a <code>(key value)</code> sublist on each iteration. For structs, the key is a symbol identifying the field. Analogous to the case for arrays, we obtain the existing variable for the struct field using <code>FieldByName</code> and make a recursive call to populate it. For maps, the key may be of any type, and analogous to the case for slices, we create a new variable, recursively populate it, and finally insert the new key/value pair into the map.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">readList</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">:</span> <span class="c1">// (item ...)
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span> <span class="c1">// (item ...)
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">item</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Append</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">item</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span> <span class="c1">// ((name value) ...)
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="o">!=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Ident</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;got token %q, want field name&#34;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()))</span>
      <span class="p">}</span>
      <span class="nx">name</span> <span class="o">:=</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span> <span class="c1">// ((key value) ...)
</span><span class="c1"></span>    <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">MakeMap</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="nx">key</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Key</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
      <span class="nx">value</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">SetMapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="k">default</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&#34;cannot decode list into %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">EOF</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;end of file&#34;</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>
<p>Finally, we wrap up the parser in an exported function <code>Unmarshal</code>, shown below, that hides some of the rough edges of the implementation. Errors encountered during parsing result in a panic, so <code>Unmarshal</code> uses a deferred call to recover from the panic (<a href="#section-5.10" >§5.10</a>) and return an error message instead.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Unmarshal parses S-expression data and populates the variable
</span><span class="c1">// whose address is in the non-nil pointer out.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lex</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">lexer</span><span class="p">{</span><span class="nx">scan</span><span class="p">:</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Scanner</span><span class="p">{</span><span class="nx">Mode</span><span class="p">:</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">GoTokens</span><span class="p">}}</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// get the first token
</span><span class="c1"></span>  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// NOTE: this is not an example of ideal error handling.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;error at %s: %v&#34;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Position</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">out</span><span class="p">).</span><span class="nx">Elem</span><span class="p">())</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>A production-quality implementation should never panic for any input and should report an informative error for every mishap, perhaps with a line number or offset. Nonetheless, we hope this example conveys some idea of what’s happening under the hood of the packages like <code>encoding/json</code>, and how you can use reflection to populate data structures.</p>
<p><b>Exercise 12.8</b>: The <code>sexpr.Unmarshal</code> function, like <code>json.Unmarshal</code>, requires the complete input in a byte slice before it can begin decoding. Define a <code>sexpr.Decoder</code> type that, like <code>json.Decoder</code>, allows a sequence of values to be decoded from an <code>io.Reader</code>. Change <code>sexpr.Unmarshal</code> to use this new type.</p>
<p><b>Exercise 12.9</b>: Write a token-based API for decoding S-expressions, following the style of <code>xml.Decoder</code> (<a href="#section-7.14" >§7.14</a>). You will need five types of tokens: <code>Symbol</code>, <code>String</code>, <code>Int</code>, <code>StartList</code>, and <code>EndList</code>.</p>
<p><b>Exercise 12.10</b>: Extend <code>sexpr.Unmarshal</code> to handle the booleans, floating-point numbers, and interfaces encoded by your solution to Exercise 12.3. (Hint: to decode interfaces, you will need a mapping from the name of each supported type to its <code>reflect.Type</code>.)</p>
</div>
<h3 id="section-12.7" >Accessing Struct Field Tags</h3>
<div class="hBody-3" >
<p>In <a href="#section-4.5" >Section 4.5</a> we used struct <em>field tags</em> to modify the JSON encoding of Go struct values. The <code>json</code> field tag lets us choose alternative field names and suppress the output of empty fields. In this section, we’ll see how to access field tags using reflection.</p>
<p>In a web server, the first thing most HTTP handler functions do is extract the request parameters into local variables. We’ll define a utility function, <code>params.Unpack</code>, that uses struct field tags to make writing HTTP handlers (<a href="#section-7.7" >§7.7</a>) more convenient.</p>
<p>First, we’ll show how it’s used. The <code>search</code> function below is an HTTP handler. It defines a variable called <code>data</code> of an anonymous struct type whose fields correspond to the HTTP request parameters. The struct’s field tags specify the parameter names, which are often short and cryptic since space is precious in a URL. The <code>Unpack</code> function populates the struct from the request so that the parameters can be accessed conveniently and with an appropriate type.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/search/main.go" >gopl.io/ch12/search</a></h1>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;gopl.io/ch12/params&#34;</span>

<span class="c1">// search implements the /search URL endpoint.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">search</span><span class="p">(</span><span class="nx">resp</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Labels</span>     <span class="p">[]</span><span class="kt">string</span> <span class="s">`http:&#34;l&#34;`</span>
    <span class="nx">MaxResults</span> <span class="kt">int</span>      <span class="s">`http:&#34;max&#34;`</span>
    <span class="nx">Exact</span>      <span class="kt">bool</span>     <span class="s">`http:&#34;x&#34;`</span>
  <span class="p">}</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">MaxResults</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// set default
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Unpack</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span> <span class="c1">// 400
</span><span class="c1"></span>    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...rest of handler...
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">resp</span><span class="p">,</span> <span class="s">&#34;Search: %+v\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code>Unpack</code> function below does three things. First, it calls <code>req.ParseForm()</code> to parse the request. Thereafter, <code>req.Form</code> contains all the parameters, regardless of whether the HTTP client used the GET or the POST request method.</p>
<p>Next, <code>Unpack</code> builds a mapping from the <em>effective</em> name of each field to the variable for that field. The effective name may differ from the actual name if the field has a tag. The <code>Field</code> method of <code>reflect.Type</code> returns a <code>reflect.StructField</code> that provides information about the type of each field such as its name, type, and optional tag. The <code>Tag</code> field is a <code>reflect.StructTag</code>, which is a string type that provides a <code>Get</code> method to parse and extract the substring for a particular key, such as <code>http:&#34;...&#34;</code> in this case.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/params/params.go" >gopl.io/ch12/params</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Unpack populates the fields of the struct pointed to by ptr
</span><span class="c1">// from the HTTP request parameters in req.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Unpack</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">ptr</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// Build map of fields keyed by effective name.
</span><span class="c1"></span>  <span class="nx">fields</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">ptr</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span> <span class="c1">// the struct variable
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">fieldInfo</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// a reflect.StructField
</span><span class="c1"></span>    <span class="nx">tag</span> <span class="o">:=</span> <span class="nx">fieldInfo</span><span class="p">.</span><span class="nx">Tag</span>           <span class="c1">// a reflect.StructTag
</span><span class="c1"></span>    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&#34;http&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">name</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="nx">name</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">fieldInfo</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fields</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Update struct field for each parameter in the request.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">values</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Form</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">fields</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">f</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="c1">// ignore unrecognized HTTP parameters
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
        <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Append</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">elem</span><span class="p">))</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Finally, <code>Unpack</code> iterates over the name/value pairs of the HTTP parameters and updates the corresponding struct fields. Recall that the same parameter name may appear more than once. If this happens, and the field is a slice, then all the values of that parameter are accumulated into the slice. Otherwise, the field is repeatedly overwritten so that only the last value has any effect.</p>
<p>The <code>populate</code> function takes care of setting a single field <code>v</code> (or a single element of a slice field) from a parameter value. For now, it supports only strings, signed integers, and booleans.  Supporting other types is left as an exercise.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseBool</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetBool</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&#34;unsupported kind %s&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>If we add the <code>server</code> handler to a web server, this might be a typical session:</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch12/search
</span><span class="in" ><span class="prompt" >&gt; </span>./search <span class="p">&amp;</span>
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search&#39;</span>
</span><span class="out" >Search: {Labels:[] MaxResults:10 Exact:false}
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search?l=golang&amp;l=programming&#39;</span>
</span><span class="out" >Search: {Labels:[golang programming] MaxResults:10 Exact:false}
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100&#39;</span>
</span><span class="out" >Search: {Labels:[golang programming] MaxResults:100 Exact:false}
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming&#39;</span>
</span><span class="out" >Search: {Labels:[golang programming] MaxResults:10 Exact:true}
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search?q=hello&amp;x=123&#39;</span>
</span><span class="out" >x: strconv.ParseBool: parsing &#34;123&#34;: invalid syntax
</span><span class="in" ><span class="prompt" >&gt; </span>./fetch <span class="s1">&#39;http://localhost:12345/search?q=hello&amp;max=lots&#39;</span>
</span><span class="out" >max: strconv.ParseInt: parsing &#34;lots&#34;: invalid syntax
</span></code></pre>
<p><b>Exercise 12.11</b>: Write the corresponding <code>Pack</code> function. Given a struct value, <code>Pack</code> should return a URL incorporating the parameter values from the struct.</p>
<p><b>Exercise 12.12</b>: Extend the field tag notation to express parameter validity requirements. For example, a string might need to be a valid email address or credit-card number, and an integer might need to be a valid US ZIP code. Modify <code>Unpack</code> to check these requirements.</p>
<p><b>Exercise 12.13</b>: Modify the S-expression encoder (<a href="#section-12.4" >§12.4</a>) and decoder (<a href="#section-12.6" >§12.6</a>) so that they honor the <code>sexpr:&#34;...&#34;</code> field tag in a similar manner to <code>encoding/json</code> (<a href="#section-4.5" >§4.5</a>).</p>
</div>
<h3 id="section-12.8" >Displaying the Methods of a Type</h3>
<div class="hBody-3" >
<p>Our final example of reflection uses <code>reflect.Type</code> to print the type of an arbitrary value and enumerate its methods:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch12/methods/methods.go" >gopl.io/ch12/methods</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Print prints the method set of the value x.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;type %s\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumMethod</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">methType</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Type</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;func (%s) %s%s\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">,</span>
      <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimPrefix</span><span class="p">(</span><span class="nx">methType</span><span class="p">.</span><span class="nx">String</span><span class="p">(),</span> <span class="s">&#34;func&#34;</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Both <code>reflect.Type</code> and <code>reflect.Value</code> have a method called <code>Method</code>. Each <code>t.Method(i)</code> call returns an instance of <code>reflect.Method</code>, a struct type that describes the name and type of a single method. Each <code>v.Method(i)</code> call returns a <code>reflect.Value</code> representing a method value (<a href="#section-6.4" >§6.4</a>), that is, a method bound to its receiver. Using the <code>reflect.Value.Call</code> method (which we don’t have space to show here), it’s possible to call <code>Values</code> of kind <code>Func</code> like this one, but this program needs only its <code>Type</code>.</p>
<p>Here are the methods belonging to two types, <code>time.Duration</code> and <code>*strings.Replacer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="nx">methods</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="c1">// Output:
</span><span class="c1">// type time.Duration
</span><span class="c1">// func (time.Duration) Hours() float64
</span><span class="c1">// func (time.Duration) Minutes() float64
</span><span class="c1">// func (time.Duration) Nanoseconds() int64
</span><span class="c1">// func (time.Duration) Seconds() float64
</span><span class="c1">// func (time.Duration) String() string
</span><span class="c1"></span>
<span class="nx">methods</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Replacer</span><span class="p">))</span>
<span class="c1">// Output:
</span><span class="c1">// type *strings.Replacer
</span><span class="c1">// func (*strings.Replacer) Replace(string) string
</span><span class="c1">// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-12.9" >A Word of Caution</h3>
<div class="hBody-3" >
<p>There is a lot more to the reflection API than we have space to show, but the preceding examples give an idea of what is possible. Reflection is a powerful and expressive tool, but it should be used with care, for three reasons.</p>
<p>The first reason is that reflection-based code can be fragile. For every mistake that would cause a compiler to report a type error, there is a corresponding way to misuse reflection, but whereas the compiler reports the mistake at build time, a reflection error is reported during execution as a panic, possibly long after the program was written or even long after it has started running.</p>
<p>If the <code>readList</code> function (<a href="#section-12.6" >§12.6</a>), for example, should read a string from the input while populating a variable of type <code>int</code>, the call to <code>reflect.Value.SetString</code> will panic. Most programs that use reflection have similar hazards, and considerable care is required to keep track of the type, addressability, and settability of each <code>reflect.Value</code>.</p>
<p>The best way to avoid this fragility is to ensure that the use of reflection is fully encapsulated within your package and, if possible, avoid <code>reflect.Value</code> in favor of specific types in your package’s API, to restrict inputs to legal values. If this is not possible, perform additional dynamic checks before each risky operation. As an example from the standard library, when <code>fmt.Printf</code> applies a verb to an inappropriate operand, it does not panic mysteriously but prints an informative error message. The program still has a bug, but it is easier to diagnose.</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%d %s\n&#34;</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span> <span class="c1">// &#34;%!d(string=hello) %!s(int=42)&#34;
</span><span class="c1"></span></code></pre>
<p>Reflection also reduces the safety and accuracy of automated refactoring and analysis tools, because they can’t determine or rely on type information.</p>
<p>The second reason to avoid reflection is that since types serve as a form of documentation and the operations of reflection cannot be subject to static type checking, heavily reflective code is often hard to understand. Always carefully document the expected types and other invariants of functions that accept an <code>interface{}</code> or a <code>reflect.Value</code>.</p>
<p>The third reason is that reflection-based functions may be one or two orders of magnitude slower than code specialized for a particular type. In a typical program, the majority of functions are not relevant to the overall performance, so it’s fine to use reflection when it makes the program clearer. Testing is a particularly good fit for reflection since most tests use small data sets. But for functions on the critical path, reflection is best avoided.</p>
</div>
<h2 id="chapter-13" >Low-Level Programming</h2>
<div class="hBody-2" >
<p>The design of Go guarantees a number of safety properties that limit the ways in which a Go program can <q>go wrong.</q> During compilation, type checking detects most attempts to apply an operation to a value that is inappropriate for its type, for instance, subtracting one string from another. Strict rules for type conversions prevent direct access to the internals of built-in types like strings, maps, slices, and channels.</p>
<p>For errors that cannot be detected statically, such as out-of-bounds array accesses or nil pointer dereferences, dynamic checks ensure that the program immediately terminates with an informative error whenever a forbidden operation occurs. Automatic memory management (garbage collection) eliminates <q>use after free</q> bugs, as well as most memory leaks.</p>
<p>Many implementation details are inaccessible to Go programs. There is no way to discover the memory layout of an aggregate type like a struct, or the machine code for a function, or the identity of the operating system thread on which the current goroutine is running.  Indeed, the Go scheduler freely moves goroutines from one thread to another. A pointer identifies a variable without revealing the variable’s numeric address. Addresses may change as the garbage collector moves variables; pointers are transparently updated.</p>
<p>Together, these features make Go programs, especially failing ones, more predictable and less mysterious than programs in C, the quintessential low-level language. By hiding the underlying details, they also make Go programs highly portable, since the language semantics are largely independent of any particular compiler, operating system, or CPU architecture. (Not entirely independent: some details leak through, such as the word size of the processor, the order of evaluation of certain expressions, and the set of implementation restrictions imposed by the compiler.)</p>
<p>Occasionally, we may choose to forfeit some of these helpful guarantees to achieve the highest possible performance, to interoperate with libraries written in other languages, or to implement a function that cannot be expressed in pure Go.</p>
<p>In this chapter, we’ll see how the <code>unsafe</code> package lets us step outside the usual rules, and how to use the <code class="command" >cgo</code> tool to create Go bindings for C libraries and operating system calls.</p>
<p>The approaches described in this chapter should not be used frivolously. Without careful attention to detail, they may cause the kinds of unpredictable, inscrutable, non-local failures with which C programmers are unhappily acquainted. Use of <code>unsafe</code> also voids Go’s warranty of compatibility with future releases, since, whether intended or inadvertent, it is easy to depend on unspecified implementation details that may change unexpectedly.</p>
<p>The <code>unsafe</code> package is rather magical. Although it appears to be a regular package and is imported in the usual way, it is actually implemented by the compiler. It provides access to a number of built-in language features that are not ordinarily available because they expose details of Go’s memory layout. Presenting these features as a separate package makes the rare occasions on which they are needed more conspicuous. Also, some environments may restrict the use of the <code>unsafe</code> package for security reasons.</p>
<p>Package <code>unsafe</code> is used extensively within low-level packages like <code>runtime</code>, <code>os</code>, <code>syscall</code>, and <code>net</code> that interact with the operating system, but is almost never needed by ordinary programs.</p>
</div>
<h3 id="section-13.1" ><code>unsafe.Sizeof</code>, <code>Alignof</code>, and <code>Offsetof</code></h3>
<div class="hBody-3" >
<p>The <code>unsafe.Sizeof</code> function reports the size in bytes of the representation of its operand, which may be an expression of any type; the expression is not evaluated. A call to <code>Sizeof</code> is a constant expression of type <code>uintptr</code>, so the result may be used as the dimension of an array type, or to compute other constants.</p>
<pre class="code" ><code class="chroma" ><span class="kn">import</span> <span class="s">&#34;unsafe&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="c1">// &#34;8&#34;
</span><span class="c1"></span></code></pre>
<p><code>Sizeof</code> reports only the size of the fixed part of each data structure, like the pointer and length of a string, but not indirect parts like the contents of the string. Typical sizes for all nonaggregate Go types are shown below, though the exact sizes may vary by toolchain. For portability, we’ve given the sizes of reference types (or types containing references) in terms of words, where a word is 4 bytes on a 32-bit platform and 8 bytes on a 64-bit platform.</p>
<p>Computers load and store values from memory most efficiently when those values are properly <em>aligned</em>. For example, the address of a value of a two-byte type such as <code>int16</code> should be an even number, the address of a four-byte value such as a rune should be a multiple of four, and the address of an eight-byte value such as a <code>float64</code>, <code>uint64</code>, or 64-bit pointer should be a multiple of eight. Alignment requirements of higher multiples are unusual, even for larger data types such as <code>complex128</code>.</p>
<p>For this reason, the size of a value of an aggregate type (a struct or array) is at least the sum of the sizes of its fields or elements but may be greater due to the presence of <q>holes.</q> Holes are unused spaces added by the compiler to ensure that the following field or element is properly aligned relative to the start of the struct or array.</p>
<table border="1">
<thead>
<tr><th><p>Type</p>
</th><th><p>Size</p>
</th></tr>
</thead>
<tbody>
<tr><td><p><code>bool</code></p>
</td><td><p>1 byte</p>
</td></tr>
<tr><td><p><code>int</code><span class="math" >N</span>, <code>uint</code><span class="math" >N</span>, <code>float</code><span class="math" >N</span>, <code>complex</code><span class="math" >N</span></p>
</td><td><p><span class="math" >N</span> / 8 bytes (for example, <code>float64</code> is 8 bytes)</p>
</td></tr>
<tr><td><p><code>int</code>, <code>uint</code>, <code>uintptr</code></p>
</td><td><p>1 word</p>
</td></tr>
<tr><td><p><code>*T</code></p>
</td><td><p>1 word</p>
</td></tr>
<tr><td><p><code>string</code></p>
</td><td><p>2 words (data, len)</p>
</td></tr>
<tr><td><p><code>[]T</code></p>
</td><td><p>3 words (data, len, cap)</p>
</td></tr>
<tr><td><p><code>map</code></p>
</td><td><p>1 word</p>
</td></tr>
<tr><td><p><code>func</code></p>
</td><td><p>1 word</p>
</td></tr>
<tr><td><p><code>chan</code></p>
</td><td><p>1 word</p>
</td></tr>
<tr><td><p><code>interface</code></p>
</td><td><p>2 words (type, value)</p>
</td></tr>
</tbody>
</table>
<p>The language specification does not guarantee that the order in which fields are declared is the order in which they are laid out in memory, so in theory a compiler is free to rearrange them, although as we write this, none do. If the types of a struct’s fields are of different sizes, it may be more space-efficient to declare the fields in an order that packs them as tightly as possible. The three structs below have the same fields, but the first requires up to 50% more memory than the other two:</p>
<pre class="code" ><code class="chroma" >                                  <span class="c1">// 64-bit    32-bit
</span><span class="c1"></span><span class="kd">struct</span><span class="p">{</span> <span class="kt">bool</span><span class="p">;</span> <span class="kt">float64</span><span class="p">;</span> <span class="kt">int16</span> <span class="p">}</span>    <span class="c1">// 3 words   4 words
</span><span class="c1"></span><span class="kd">struct</span><span class="p">{</span> <span class="kt">float64</span><span class="p">;</span> <span class="kt">int16</span><span class="p">;</span> <span class="kt">bool</span> <span class="p">}</span>    <span class="c1">// 2 words   3 words
</span><span class="c1"></span><span class="kd">struct</span><span class="p">{</span> <span class="kt">bool</span><span class="p">;</span> <span class="kt">int16</span><span class="p">;</span> <span class="kt">float64</span> <span class="p">}</span>    <span class="c1">// 2 words   3 words
</span><span class="c1"></span></code></pre>
<p>The details of the alignment algorithm are beyond the scope of this book, and it’s certainly not worth worrying about every struct, but efficient packing may make frequently allocated data structures more compact and therefore faster.</p>
<p>The <code>unsafe.Alignof</code> function reports the required alignment of its argument’s type. Like <code>Sizeof</code>, it may be applied to an expression of any type, and it yields a constant. Typically, boolean and numeric types are aligned to their size (up to a maximum of 8 bytes) and all other types are word-aligned.</p>
<p>The <code>unsafe.Offsetof</code> function, whose operand must be a field selector <code>x.f</code>, computes the offset of field <code>f</code> relative to the start of its enclosing struct <code>x</code>, accounting for holes, if any.</p>
<p>Figure 13.1 shows a struct variable <code>x</code> and its memory layout on typical 32- and 64-bit Go implementations. The gray regions are holes.</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="kt">bool</span>
  <span class="nx">b</span> <span class="kt">int16</span>
  <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre>
<div class="figure" >
<h1 class="figure">Figure 13.1. Holes in a struct.</h1>
<figure>
<img src="img/Figure-13.1.jpg" />
</figure>
</div>
<p>The table below shows the results of applying the three <code>unsafe</code> functions to <code>x</code> itself and to each of its three fields:</p>
<dl>
<dt>Typical 32-bit platform</dt>
<dd>
<div class="pre-block" >
<pre class="pre" >Sizeof(x)   = 16  Alignof(x)   = 4
Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
Sizeof(x.c) = 12  Alignof(x.c) = 4  Offsetof(x.c) = 4
</pre>
</div>
</dd>
<dt>Typical 64-bit platform</dt>
<dd>
<div class="pre-block" >
<pre class="pre" >Sizeof(x)   = 32  Alignof(x)   = 8
Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
Sizeof(x.c) = 24  Alignof(x.c) = 8  Offsetof(x.c) = 8
</pre>
</div>
</dd>
</dl>
<p>Despite their names, these functions are not in fact unsafe, and they may be helpful for understanding the layout of raw memory in a program when optimizing for space.</p>
</div>
<h3 id="section-13.2" ><code>unsafe.Pointer</code></h3>
<div class="hBody-3" >
<p>Most pointer types are written <code>*T</code>, meaning <q>a pointer to a variable of type <code>T</code>.</q> The <code>unsafe.Pointer</code> type is a special kind of pointer that can hold the address of any variable. Of course, we can’t indirect through an <code>unsafe.Pointer</code> using <code>*p</code> because we don’t know what type that expression should have. Like ordinary pointers, <code>unsafe.Pointers</code> are comparable and may be compared with <code>nil</code>, which is the zero value of the type.</p>
<p>An ordinary <code>*T</code> pointer may be converted to an <code>unsafe.Pointer</code>, and an <code>unsafe.Pointer</code> may be converted back to an ordinary pointer, not necessarily of the same type <code>*T</code>. By converting a <code>*float64</code> pointer to a <code>*uint64</code>, for instance, we can inspect the bit pattern of a floating-point variable:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">math</span>

<span class="kd">func</span> <span class="nx">Float64bits</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&#34;%#016x\n&#34;</span><span class="p">,</span> <span class="nx">Float64bits</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span> <span class="c1">// &#34;0x3ff0000000000000&#34;
</span><span class="c1"></span></code></pre>
<p>Through the resulting pointer, we can update the bit pattern too. This is harmless for a floating-point variable since any bit pattern is legal, but in general, <code>unsafe.Pointer</code> conversions let us write arbitrary values to memory and thus subvert the type system.</p>
<p>An <code>unsafe.Pointer</code> may also be converted to a <code>uintptr</code> that holds the pointer’s numeric value, letting us perform arithmetic on addresses. (Recall from <a href="#chapter-3" >Chapter 3</a> that a <code>uintptr</code> is an unsigned integer wide enough to represent an address.) This conversion too may be applied in reverse, but again, converting from a <code>uintptr</code> to an <code>unsafe.Pointer</code> may subvert the type system since not all numbers are valid addresses.</p>
<p>Many <code>unsafe.Pointer</code> values are thus intermediaries for converting ordinary pointers to raw numeric addresses and back again. The example below takes the address of variable <code>x</code>, adds the offset of its <code>b</code> field, converts the resulting address to <code>*int16</code>, and through that pointer updates <code>x.b</code>:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch13/unsafeptr/main.go" >gopl.io/ch13/unsafeptr</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">x</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="kt">bool</span>
  <span class="nx">b</span> <span class="kt">int16</span>
  <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// equivalent to pb := &amp;x.b
</span><span class="c1"></span><span class="nx">pb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span>
  <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Offsetof</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)))</span>
<span class="o">*</span><span class="nx">pb</span> <span class="p">=</span> <span class="mi">42</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// &#34;42&#34;
</span><span class="c1"></span></code></pre>
</div>
<p>Although the syntax is cumbersome—perhaps no bad thing since these features should be used sparingly—do not be tempted to introduce temporary variables of type <code>uintptr</code> to break the lines. This code is incorrect:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// NOTE: subtly incorrect!
</span><span class="c1"></span><span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Offsetof</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="nx">pb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">tmp</span><span class="p">))</span>
<span class="o">*</span><span class="nx">pb</span> <span class="p">=</span> <span class="mi">42</span>
</code></pre>
<p>The reason is very subtle. Some garbage collectors move variables around in memory to reduce fragmentation or bookkeeping. Garbage collectors of this kind are known as <em>moving GCs</em>. When a variable is moved, all pointers that hold the address of the old location must be updated to point to the new one. From the perspective of the garbage collector, an <code>unsafe.Pointer</code> is a pointer and thus its value must change as the variable moves, but a <code>uintptr</code> is just a number so its value must not change. The incorrect code above <em>hides a pointer</em> from the garbage collector in the non-pointer variable <code>tmp</code>. By the time the second statement executes, the variable <code>x</code> could have moved and the number in <code>tmp</code> would no longer be the address <code>&amp;x.b</code>. The third statement clobbers an arbitrary memory location with the value 42.</p>
<p>There are myriad pathological variations on this theme. After this statement has executed:</p>
<pre class="code" ><code class="chroma" ><span class="nx">pT</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)))</span> <span class="c1">// NOTE: wrong!
</span><span class="c1"></span></code></pre>
<p>there are no pointers that refer to the variable created by <code>new</code>, so the garbage collector is entitled to recycle its storage when this statement completes, after which <code>pT</code> contains the address where the variable was but is no longer.</p>
<p>No current Go implementation uses a moving garbage collector (though future implementations might), but this is no reason for complacency: current versions of Go do move <em>some</em> variables around in memory. Recall from <a href="#section-5.2" >Section 5.2</a> that goroutine stacks grow as needed.  When this happens, all variables on the old stack may be relocated to a new, larger stack, so we cannot rely on the numeric value of a variable’s address remaining unchanged throughout its lifetime.</p>
<p>At the time of writing, there is little clear guidance on what Go programmers may rely upon after an <code>unsafe.Pointer</code> to <code>uintptr</code> conversion (see Go issue 7192), so we strongly recommend that you assume the bare minimum. Treat all <code>uintptr</code> values as if they contain the <em>former</em> address of a variable, and minimize the number of operations between converting an <code>unsafe.Pointer</code> to a <code>uintptr</code> and using that <code>uintptr</code>. In our first example above, the three operations—conversion to a <code>uintptr</code>, addition of the field offset, conversion back—all appeared within a single expression.</p>
<p>When calling a library function that returns a <code>uintptr</code>, such as those below from the <code>reflect</code> package, the result should be immediately converted to an <code>unsafe.Pointer</code> to ensure that it continues to point to the same variable.</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">reflect</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">Pointer</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">UnsafeAddr</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">InterfaceData</span><span class="p">()</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// (index 1)
</span><span class="c1"></span></code></pre>
</div>
<h3 id="section-13.3" >Example: Deep Equivalence</h3>
<div class="hBody-3" >
<p>The <code>DeepEqual</code> function from the <code>reflect</code> package reports whether two values are <q>deeply</q> equal. <code>DeepEqual</code> compares basic values as if by the built-in <code>==</code> operator; for composite values, it traverses them recursively, comparing corresponding elements. Because it works for any pair of values, even ones that are not comparable with <code>==</code>, it finds widespread use in tests.  The following test uses <code>DeepEqual</code> to compare two <code>[]string</code> values:</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">got</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="s">&#34;a:b:c&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">)</span>
  <span class="nx">want</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Although <code>DeepEqual</code> is convenient, its distinctions can seem arbitrary. For example, it doesn’t consider a nil map equal to a non-nil empty map, nor a nil slice equal to a non-nil empty one:</p>
<pre class="code" ><code class="chroma" ><span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p>In this section we’ll define a function Equal that compares arbitrary values. Like <code>DeepEqual</code>, it compares slices and maps based on their elements, but unlike <code>DeepEqual</code>, it considers a nil slice (or map) equal to a non-nil empty one. The basic recursion over the arguments can be done with reflection, using a similar approach to the <code>Display</code> program we saw in <a href="#section-12.3" >Section 12.3</a>.  As usual, we define an unexported function, <code>equal</code>, for the recursion. Don’t worry about the <code>seen</code> parameter just yet. For each pair of values <code>x</code> and <code>y</code> to be compared, <code>equal</code> checks that both (or neither) are valid and checks that they have the same type. The result of the function is defined as a set of switch cases that compare two values of the same type. For reasons of space, we’ve omitted several cases since the pattern should be familiar by now.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch13/equal/equal.go" >gopl.io/ch13/equal</a></h1>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">seen</span> <span class="kd">map</span><span class="p">[</span><span class="nx">comparison</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="c1">// ...cycle check omitted (shown later)...
</span><span class="c1"></span>
  <span class="k">switch</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Bool</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Bool</span><span class="p">()</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>

  <span class="c1">// ...numeric cases omitted for brevity...
</span><span class="c1"></span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Chan</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">UnsafePointer</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Elem</span><span class="p">(),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Elem</span><span class="p">(),</span> <span class="nx">seen</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nx">seen</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>

  <span class="c1">// ...struct and map cases omitted for brevity...
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>
<p>As usual, we don’t expose the use of reflection in the API, so the exported function <code>Equal</code> must call <code>reflect.ValueOf</code> on its arguments:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Equal reports whether x and y are deeply equal.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">comparison</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">y</span><span class="p">),</span> <span class="nx">seen</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">comparison</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="nx">t</span>
  <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>
<span class="p">}</span>
</code></pre>
<p>To ensure that the algorithm terminates even for cyclic data structures, it must record which pairs of variables it has already compared and avoid comparing them a second time. <code>Equal</code> allocates a set of <code>comparison</code> structs, each holding the address of two variables (represented as <code>unsafe.Pointer</code> values) and the type of the comparison. We need to record the type in addition to the addresses because different variables can have the same address. For example, if <code>x</code> and <code>y</code> are both arrays, <code>x</code> and <code>x[0]</code> have the same address, as do <code>y</code> and <code>y[0]</code>, and it is important to distinguish whether we have compared <code>x</code> and <code>y</code> or <code>x[0]</code> and <code>y[0]</code>.</p>
<p>Once <code>equal</code> has established that its arguments have the same type, and before it executes the switch, it checks whether it is comparing two variables it has already seen and, if so, terminates the recursion.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// cycle check
</span><span class="c1"></span><span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">xptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">UnsafeAddr</span><span class="p">())</span>
  <span class="nx">yptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">UnsafeAddr</span><span class="p">())</span>
  <span class="k">if</span> <span class="nx">xptr</span> <span class="o">==</span> <span class="nx">yptr</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span> <span class="c1">// identical references
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">c</span> <span class="o">:=</span> <span class="nx">comparison</span><span class="p">{</span><span class="nx">xptr</span><span class="p">,</span> <span class="nx">yptr</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Type</span><span class="p">()}</span>
  <span class="k">if</span> <span class="nx">seen</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span> <span class="c1">// already seen
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="nx">seen</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>
<p>Here’s our <code>Equal</code> function in action:</p>
<pre class="code" ><code class="chroma" ><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}))</span>        <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;foo&#34;</span><span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;bar&#34;</span><span class="p">}))</span>      <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}))</span>             <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span></code></pre>
<p>It even works on cyclic inputs similar to the one that caused the <code>Display</code> function from <a href="#section-12.3" >Section 12.3</a> to get stuck in a loop:</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Circular linked lists a -&gt; b -&gt; a and c -&gt; c.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">link</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kt">string</span>
  <span class="nx">tail</span> <span class="o">*</span><span class="nx">link</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&#34;a&#34;</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&#34;b&#34;</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">c</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="c1">// &#34;true&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="c1">// &#34;false&#34;
</span><span class="c1"></span></code></pre>
<p><b>Exercise 13.1</b>: Define a deep comparison function that considers numbers (of any type) equal if they differ by less than one part in a billion.</p>
<p><b>Exercise 13.2</b>: Write a function that reports whether its argument is a cyclic data structure.</p>
</div>
<h3 id="section-13.4" >Calling C Code with <code class="command" >cgo</code></h3>
<div class="hBody-3" >
<p>A Go program might need to use a hardware driver implemented in C, query an embedded database implemented in C++, or use some linear algebra routines implemented in Fortran. C has long been the lingua franca of programming, so many packages intended for widespread use export a C-compatible API, regardless of the language of their implementation.</p>
<p>In this section, we’ll build a simple data compression program that uses <code class="command" >cgo</code>, a tool that creates Go bindings for C functions. Such tools are called <em>foreign-function interfaces</em> (FFIs), and <code class="command" >cgo</code> is not the only one for Go programs. SWIG (<a href="http://swig.org/" >swig.org</a>) is another; it provides more complex features for integrating with C++ classes, but we won’t show it here.</p>
<p>The <code>compress/...</code> subtree of the standard library provides compressors and decompressors for popular compression algorithms, including LZW (used by the Unix <code class="command" >compress</code> command) and DEFLATE (used by the GNU <code class="command" >gzip</code> command). The APIs of these packages vary slightly in details, but they all provide a wrapper for an <code>io.Writer</code> that compresses the data written to it, and a wrapper for an <code>io.Reader</code> that decompresses the data read from it. For example:</p>
<pre class="code" ><code class="chroma" ><span class="kn">package</span> <span class="nx">gzip</span> <span class="c1">// compress/gzip
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nx">NewWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span>
<span class="kd">func</span> <span class="nx">NewReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre>
<p>The bzip2 algorithm, which is based on the elegant Burrows-Wheeler transform, runs slower than gzip but yields significantly better compression. The <code>compress/bzip2</code> package provides a decompressor for bzip2, but at the moment the package provides no compressor. Building one from scratch is a substantial undertaking, but there is a well-documented and high-performance open-source C implementation, the <code>libbzip2</code> package from <a href="http://bzip.org/" >bzip.org</a>.</p>
<p>If the C library were small, we would just port it to pure Go, and if its performance were not critical for our purposes, we would be better off invoking a C program as a helper subprocess using the <code>os/exec</code> package. It’s when you need to use a complex, performance-critical library with a narrow C API that it may make sense to wrap it using <code class="command" >cgo</code>. For the rest of this chapter, we’ll work through an example.</p>
<p>From the <code>libbzip2</code> C package, we need the <code>bz_stream</code> struct type, which holds the input and output buffers, and three C functions: <code>BZ2_bzCompressInit</code>, which allocates the stream’s buffers; <code>BZ2_bzCompress</code>, which compresses data from the input buffer to the output buffer; and <code>BZ2_bzCompressEnd</code>, which releases the buffers. (Don’t worry about the mechanics of the <code>libbzip2</code> package; the purpose of this example is to show how the parts fit together.)</p>
<p>We’ll call the <code>BZ2_bzCompressInit</code> and <code>BZ2_bzCompressEnd</code> C functions directly from Go, but for <code>BZ2_bzCompress</code>, we’ll define a wrapper function in C, to show how it’s done. The C source file below lives alongside the Go code in our package:</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch13/bzip/bzip2.c" >gopl.io/ch13/bzip</a></h1>
<pre class="code" ><code class="chroma" ><span class="cm">/* This file is gopl.io/ch13/bzip/bzip2.c,         */</span>
<span class="cm">/* a simple wrapper for libbzip2 suitable for cgo. */</span>
<span class="cp">#include</span> <span class="cpf">&lt;bzlib.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">bz2compress</span><span class="p">(</span><span class="n">bz_stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">action</span><span class="p">,</span>
                <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">inlen</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">outlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">=</span> <span class="o">*</span><span class="n">inlen</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">=</span> <span class="n">out</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">=</span> <span class="o">*</span><span class="n">outlen</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">BZ2_bzCompress</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
  <span class="o">*</span><span class="n">inlen</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
  <span class="o">*</span><span class="n">outlen</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">;</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now let’s turn to the Go code, the first part of which is shown below. The <code>import &#34;C&#34;</code> declaration is special. There is no package <code>C</code>, but this import causes <code class="command" >go build</code> to preprocess the file using the <code class="command" >cgo</code> tool before the Go compiler sees it.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Package bzip provides a writer that uses bzip2 compression (bzip.org).
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">bzip</span>

<span class="cm">/*
</span><span class="cm">#cgo CFLAGS: -I/usr/include
</span><span class="cm">#cgo LDFLAGS: -L/usr/lib -lbz2
</span><span class="cm">#include &lt;bzlib.h&gt;
</span><span class="cm">int bz2compress(bz_stream *s, int action,
</span><span class="cm">                char *in, unsigned *inlen, char *out, unsigned *outlen);
</span><span class="cm">*/</span>
<span class="kn">import</span> <span class="s">&#34;C&#34;</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">writer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">w</span>      <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="c1">// underlying output stream
</span><span class="c1"></span>  <span class="nx">stream</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">bz_stream</span>
  <span class="nx">outbuf</span> <span class="p">[</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">// NewWriter returns a writer for bzip2-compressed streams.
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">NewWriter</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">blockSize</span> <span class="p">=</span> <span class="mi">9</span>
    <span class="nx">verbosity</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">workFactor</span> <span class="p">=</span> <span class="mi">30</span>
  <span class="p">)</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">writer</span><span class="p">{</span><span class="nx">w</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">stream</span><span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">bz_stream</span><span class="p">)}</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">BZ2_bzCompressInit</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">blockSize</span><span class="p">,</span> <span class="nx">verbosity</span><span class="p">,</span> <span class="nx">workFactor</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">w</span>
<span class="p">}</span>
</code></pre>
<p>During preprocessing, <code class="command" >cgo</code> generates a temporary package that contains Go declarations corresponding to all the C functions and types used by the file, such as <code>C.bz_stream</code> and <code>C.BZ2_bzCompressInit</code>. The <code class="command" >cgo</code> tool discovers these types by invoking the C compiler in a special way on the contents of the comment that precedes the import declaration.</p>
<p>The comment may also contain <code>#cgo</code> directives that specify extra options to the C toolchain. The <code>CFLAGS</code> and <code>LDFLAGS</code> values contribute extra arguments to the compiler and linker commands so that they can locate the <code>bzlib.h</code> header file and the <span class="file" >libbz2.a</span> archive library. The example assumes that these are installed beneath <span class="file" >/usr</span> on your system. You may need to alter or delete these flags for your installation.</p>
<p><code>NewWriter</code> makes a call to the C function BZ2_bzCompressInit to initialize the buffers for the stream. The <code>writer</code> type includes another buffer that will be used to drain the decompressor’s output buffer.</p>
<p>The <code>Write</code> method, shown below, feeds the uncompressed <code>data</code> to the compressor, calling the function <code>bz2compress</code> in a loop until all the data has been consumed. Observe that the Go program may access C types like <code>bz_stream</code>, <code>char</code>, and <code>uint</code>, C functions like <code>bz2compress</code>, and even object-like C preprocessor macros such as <code>BZ_RUN</code>, all through the <code>C.x</code> notation. The <code>C.uint</code> type is distinct from Go’s <code>uint</code> type, even if both have the same width.</p>
<pre class="code" ><code class="chroma" ><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">writer</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;closed&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int</span> <span class="c1">// uncompressed bytes written
</span><span class="c1"></span>
  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">inlen</span><span class="p">,</span> <span class="nx">outlen</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">))</span>
    <span class="nx">C</span><span class="p">.</span><span class="nx">bz2compress</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_RUN</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">inlen</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">outlen</span><span class="p">)</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">inlen</span><span class="p">)</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">inlen</span><span class="p">:]</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">[:</span><span class="nx">outlen</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>
<p>Each iteration of the loop passes <code>bz2compress</code> the address and length of the remaining portion of <code>data</code>, and the address and capacity of <code>w.outbuf</code>. The two length variables are passed by their addresses, not their values, so that the C function can update them to indicate how much uncompressed data was consumed and how much compressed data was produced. Each chunk of compressed data is then written to the underlying <code>io.Writer</code>.</p>
<p>The <code>Close</code> method has a similar structure to <code>Write</code>, using a loop to flush out any remaining compressed data from the stream’s output buffer.</p>
<pre class="code" ><code class="chroma" ><span class="c1">// Close flushes the compressed data and closes the stream.
</span><span class="c1">// It does not close the underlying io.Writer.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">writer</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;closed&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">C</span><span class="p">.</span><span class="nx">BZ2_bzCompressEnd</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">)</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="p">}()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">inlen</span><span class="p">,</span> <span class="nx">outlen</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">))</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nx">bz2compress</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_FINISH</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inlen</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">outlen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">[:</span><span class="nx">outlen</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_STREAM_END</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Upon completion, <code>Close</code> calls <code>C.BZ2_bzCompressEnd</code> to release the stream buffers, using <code>defer</code> to ensure that this happens on all return paths. At this point the <code>w.stream</code> pointer is no longer safe to dereference. To be defensive, we set it to <code>nil</code>, and add explicit nil checks to each method, so that the program panics if the user mistakenly calls a method after <code>Close</code>.</p>
<p>Not only is <code>writer</code> not concurrency-safe, but concurrent calls to <code>Close</code> and <code>Write</code> could cause the program to crash in C code. Fixing this is Exercise 13.3.</p>
<p>The program below, <code>bzipper</code>, is a bzip2 compressor command that uses our new package. It behaves like the <code class="command" >bzip2</code> command present on many Unix systems.</p>
<div class="figure" >
<h1 class="figure"><a href="gopl.io/ch13/bzipper/main.go" >gopl.io/ch13/bzipper</a></h1>
<pre class="code" ><code class="chroma" ><span class="c1">// Bzipper reads input, bzip2-compresses it, and writes it out.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;gopl.io/ch13/bzip&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="nx">bzip</span><span class="p">.</span><span class="nx">NewWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;bzipper: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&#34;bzipper: close: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In the session below, we use <code class="command" >bzipper</code> to compress <code>/usr/share/dict/words</code>, the system dictionary, from 938,848 bytes to 335,405 bytes—about a third of its original size—then uncompress it with the system <code class="command" >bunzip2</code> command. The SHA256 hash is the same before and after, giving us confidence that the compressor is working correctly. (If you don’t have <code class="command" >sha256sum</code> on your system, use your solution to Exercise 4.2.)</p>
<pre class="srci" ><code class="sh" ><span class="in" ><span class="prompt" >&gt; </span>go build gopl.io/ch13/bzipper
</span><span class="in" ><span class="prompt" >&gt; </span>wc -c &lt; /usr/share/dict/words
</span><span class="out" >938848
</span><span class="in" ><span class="prompt" >&gt; </span>sha256sum &lt; /usr/share/dict/words
</span><span class="out" >126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -
</span><span class="in" ><span class="prompt" >&gt; </span>./bzipper &lt; /usr/share/dict/words <span class="p">|</span> wc -c
</span><span class="out" >335405
</span><span class="in" ><span class="prompt" >&gt; </span>./bzipper &lt; /usr/share/dict/words <span class="p">|</span> bunzip2 <span class="p">|</span> sha256sum
</span><span class="out" >126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -
</span></code></pre>
<p>We’ve demonstrated linking a C library into a Go program. Going in the other direction, it’s also possible to compile a Go program as a static archive that can be linked into a C program or as a shared library that can be dynamically loaded by a C program. We’ve only scratched the surface of <code class="command" >cgo</code> here, and there is much more to say about memory management, pointers, callbacks, signal handling, strings, <code>errno</code>, finalizers, and the relationship between goroutines and operating system threads, much of it very subtle. In particular, the rules for correctly passing pointers from Go to C or vice versa are complex, for reasons similar to those we discussed in <a href="#section-13.2" >Section 13.2</a>, and not yet authoritatively specified. For further reading, start with <a href="https://golang.org/cmd/cgo" >https://golang.org/cmd/cgo</a>.</p>
<p><b>Exercise 13.3</b>: Use <code>sync.Mutex</code> to make <code>bzip.writer</code> safe for concurrent use by multiple goroutines.</p>
<p><b>Exercise 13.4</b>: Depending on C libraries has its drawbacks. Provide an alternative pure-Go implementation of <code>bzip.NewWriter</code> that uses the <code>os/exec</code> package to run <code>/bin/bzip2</code> as a subprocess.</p>
</div>
<h3 id="section-13.5" >Another Word of Caution</h3>
<div class="hBody-3" >
<p>We ended the previous chapter with a warning about the downsides of the reflection interface. That warning applies with even more force to the <code>unsafe</code> package described in this chapter.</p>
<p>High-level languages insulate programs and programmers not only from the arcane specifics of individual computer instruction sets, but from dependence on irrelevancies like where in memory a variable lives, how big a data type is, the details of structure layout, and a host of other implementation details. Because of that insulating layer, it’s possible to write programs that are safe and robust and that will run on any operating system without change.</p>
<p>The <code>unsafe</code> package lets programmers reach through the insulation to use some crucial but otherwise inaccessible feature, or perhaps to achieve higher performance. The cost is usually to portability and safety, so one uses <code>unsafe</code> at one’s peril. Our advice on how and when to use <code>unsafe</code> parallels Knuth’s comments on premature optimization, which we quoted in <a href="#section-11.5" >Section 11.5</a>. Most programmers will never need to use <code>unsafe</code> at all. Nevertheless, there will occasionally be situations where some critical piece of code can be best written using <code>unsafe</code>.  If careful study and measurement indicates that <code>unsafe</code> really is the best approach, restrict it to as small a region as possible, so that most of the program is oblivious to its use.</p>
<p>For now, put the last two chapters in the back of your mind. Write some substantial Go programs. Avoid <code>reflect</code> and <code>unsafe</code>; come back to these chapters only if you must.</p>
<p>Meanwhile, happy Go programming. We hope you enjoy writing Go as much as we do.</p>
</div>
</body>
</html>
