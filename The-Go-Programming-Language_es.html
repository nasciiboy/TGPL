<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >
  <head>
    <title>El lenguaje de programacion Go</title>
    <meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
    
    <meta name="author"      content="Alan A. A. Donovan" /><meta name="author"      content="Brian W. Kernighan" />
    
    
    <meta name="id"          content="isbn-10 0-13-419044-0" />
    <meta name="date"        content="29/09/2015" />
    
    
    

    <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />

    
  </head>
  <body>



<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <span class="toc" ><a class="h2" href="#Prefacio" >Prefacio</a></span>
<span class="toc" ><a class="h3" href="#Los-Origenes-de-Go" >Los Origenes de Go</a></span>
<span class="toc" ><a class="h3" href="#El-Proyecto-Go" >El Proyecto Go</a></span>
<span class="toc" ><a class="h3" href="#Organizacion-del-Libro" >Organizacion del Libro</a></span>
<span class="toc" ><a class="h3" href="#Donde-Encontrar-Mas-Informacion" >Donde Encontrar Mas Informacion</a></span>
<span class="toc" ><a class="h3" href="#Agradecimientos" >Agradecimientos</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-1" >Tutorial</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.1" >Hola, Mundo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.2" >Argumentos de Linea de Comandos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.3" >Encontrar lineas duplicadas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.4" >GIF animados</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.5" >Obtener una URL</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.6" >Obteniendo URL Concurrentemente</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.7" >Un servidor Web</a></span>
<span class="toc" ><a class="h3" href="#Seccion-1.8" >Cabos sueltos</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-2" >Estructura del programa</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.1" >Nombres</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.2" >Declaraciones</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.3" >Variables</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.3.1" >Declaraciones de Variables Compacta</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.3.2" >Punteros</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.3.3" >La Funcion <code>new</code></a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.3.4" >Tiempo de Vida de las Variables</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.4" >Asignaciones</a></span>
<span class="toc" ><a class="h4" href="#seccion-2.4.1" >Asignacion de Tuplas</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.4.2" >Asignacion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.5" >Declaraciones de tipo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.6" >Paquetes y Ficheros</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.6.1" >Importaciones</a></span>
<span class="toc" ><a class="h4" href="#Seccion-2.6.2" >Inicializacion del paquete</a></span>
<span class="toc" ><a class="h3" href="#Seccion-2.7" >Alcance</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-3" >Tipos de datos basicos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.1" >Enteros</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.2" >Numeros de punto flotante</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.3" >Numeros complejos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.4" >Booleanos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.5" >Cadenas</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.5.1" >Cadenas Literales</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.5.2" >Unicode</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.5.3" >UTF-8</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.5.4" >Cadenas y Slices de Bytes</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.5.5" >Conversiones entre cadenas y numeros</a></span>
<span class="toc" ><a class="h3" href="#Seccion-3.6" >Constantes</a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.6.1" >El Generador Constante <code>iota</code></a></span>
<span class="toc" ><a class="h4" href="#Seccion-3.6.2" >Constantes Sin Tipo</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-4" >Tipos Compuestos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.1" >Arreglos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.2" >Slices</a></span>
<span class="toc" ><a class="h4" href="#Seccion-4.2.1" >La Funcion <code>append</code></a></span>
<span class="toc" ><a class="h4" href="#Seccion-4.2.2" >Tecnicas de Slices In Situ</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.3" >Mapas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.4" >Estructuras</a></span>
<span class="toc" ><a class="h4" href="#Seccion-4.4.1" >Estructuras Literales</a></span>
<span class="toc" ><a class="h4" href="#Seccion-4.4.2" >Comparacion de estructuras</a></span>
<span class="toc" ><a class="h4" href="#Seccion-4.4.3" >Estructura Enbebida y Campos Anonimos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.5" >JSON</a></span>
<span class="toc" ><a class="h3" href="#Seccion-4.6" >Plantillas de Texto y HTML</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-5" >Funciones</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.1" >Declaracion de Funciones</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.2" >Recursividad</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.3" >Multiples Valores de Retorno</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.4" >Errores</a></span>
<span class="toc" ><a class="h4" href="#Seccion-5.4.1" >Estrategias de Manejo de Errores</a></span>
<span class="toc" ><a class="h4" href="#Seccion-5.4.2" >Fin de Archivo (EOF)</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.5" >Valores de la Funcion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.6" >Funciones Anonimas</a></span>
<span class="toc" ><a class="h4" href="#Seccion-5.6.1" >Advertencia: Captura de Variables de Iteracion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.7" >Funciones Variadic</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.8" >Llamadas de Funcion Diferida</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.9" >Panico</a></span>
<span class="toc" ><a class="h3" href="#Seccion-5.10" >Recover</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-6" >Metodos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.1" >Declaracion de Metodos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.2" >Metodos con un Receptor de Puntero</a></span>
<span class="toc" ><a class="h4" href="#Seccion-6.2.1" >Nil es un Valor de Receptor Valido</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.3" >Composicion de Tipos por Estructuras Enbebidas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.4" >Valores y Expresiones de los Metodos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.5" >Ejemplo: Tipo de Vector de Bits</a></span>
<span class="toc" ><a class="h3" href="#Seccion-6.6" >Encapsulacion</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-7" >Interfaces</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.1" >Interfaces como Contratos</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.2" >Tipos de Interfaz</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.3" >Satisfaccion de la Interfaz</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.4" >Analizar Banderas con <code>flag.Value</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.5" >Valores de Interfaz</a></span>
<span class="toc" ><a class="h4" href="#Seccion-7.5.1" >Advertencia: Una interfaz que Contiene un Puntero Nil es No-Nil</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.6" >Ordenacion con <code>sort.Interface</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.7" >La Interfaz <code>http.Handler</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.8" >La Interfaz <code>error</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.9" >Ejemplo: Evaluador de Expresiones</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.10" >Afirmacion de Tipo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.11" >Discriminacion de Errores con Afirmaciones de Tipo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.12" >Consultar Comportamientos con Afirmaciones de Tipo de Interfaz</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.13" >Switches de Tipo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.14" >Ejemplo: Decodificacion XML Basada en Token</a></span>
<span class="toc" ><a class="h3" href="#Seccion-7.15" >Algunos Consejos</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-8" >Gorutinas y Canales</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.1" >Gorutinas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.2" >Ejemplo: Servidor de Reloj Concurrente</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.3" >Ejemplo: Servidor Echo Concurrente</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.4" >Canales</a></span>
<span class="toc" ><a class="h4" href="#Seccion-8.4.1" >Canales sin Buffer</a></span>
<span class="toc" ><a class="h4" href="#Seccion-8.4.2" >Tuberias</a></span>
<span class="toc" ><a class="h4" href="#Seccion-8.4.3" >Tipos de Canal Unidireccional</a></span>
<span class="toc" ><a class="h4" href="#Seccion-8.4.4" >Buffered Channels</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.5" >Bucle en Paralelo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.6" >Ejemplo: Rastreador Web Concurrente</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.7" >Multiplexacion con <code>select</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.8" >Ejemplo: Trayecto de Directorio Concurrente</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.9" >Cancelacion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-8.10" >Ejemplo: Server de Chat</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-9" >Concurrencia con Variables Compartidas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.1" >Condiciones de Carrera</a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.2" >Exclusion mutua: <code>sync.Mutex</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.3" >Mutex de Lectura/Escritura: <code>sync.RWMutex</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.4" >Sincronizacion de Memoria</a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.5" >Inicializacion Perezosa: <code>sync.Once</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.6" >El Detector de Carreras</a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.7" >Ejemplo: Cache Concurrente Sin Bloqueo</a></span>
<span class="toc" ><a class="h3" href="#Seccion-9.8" >Gorutinas e Hilos</a></span>
<span class="toc" ><a class="h4" href="#Seccion-9.8.1" >Pilas Expandibles</a></span>
<span class="toc" ><a class="h4" href="#Seccion-9.8.2" >Planificacion de Gorutina</a></span>
<span class="toc" ><a class="h4" href="#Seccion-9.8.3" ><code>GOMAXPROCS</code></a></span>
<span class="toc" ><a class="h4" href="#Seccion-9.8.4" >Las Gorutinas No Tienen Identidad</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-10" >Paquetes y la Herramienta Go</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.1" >Introduccion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.2" >Rutas de Importacion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.3" >La Declaracion <code>package</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.4" >Declaraciones Import</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.5" >Importaciones En Blanco</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.6" >Paquetes y Nombres</a></span>
<span class="toc" ><a class="h3" href="#Seccion-10.7" >La Herramienta Go</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.1" >Organizacion del Espacio de Trabajo</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.2" >Descargando paquetes</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.3" >Construccion de Paquetes</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.4" >Documentacion de Paquetes</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.5" >Paquetes Internos</a></span>
<span class="toc" ><a class="h4" href="#Seccion-10.7.6" >Consultando Paquetes</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-11" >Pruebas</a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.1" >La Herramienta <code class="command" >go test</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.2" >Funciones <code>Test</code></a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.1" >Pruebas Aleatorias</a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.2" >Probar un Comando</a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.3" >Prueba de Caja Blanca</a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.4" >Paquetes de Pruebas Externos</a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.5" >Escribir Pruebas Efectivas</a></span>
<span class="toc" ><a class="h4" href="#Seccion-11.2.6" >Evitar Pruebas Fragiles</a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.3" >Cobertura</a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.4" >Funciones <code>Benchmark</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.5" >Perfilado</a></span>
<span class="toc" ><a class="h3" href="#Seccion-11.6" >Funciones <code>Example</code></a></span>
<span class="toc" ><a class="h2" href="#Capitulo-12" >Reflexion</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.1" >¿Por que la Reflexion?</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.2" ><code>reflect.Type</code> y <code>reflect.Value</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.3" ><code>Display</code>, una Impresora Recursiva de Valor</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.4" >Ejemplo: Codificacion de Expressions-S</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.5" >Configurar Variables con <code>reflect.Value</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.6" >Ejemplo: Descodificar Expressions-S</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.7" >Accediendo a Etiquetas de Campo en Estructuras</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.8" >Visualizando los Motodos de Type</a></span>
<span class="toc" ><a class="h3" href="#Seccion-12.9" >Una Palabra de Precaucion</a></span>
<span class="toc" ><a class="h2" href="#Capitulo-13" >Programacion de Bajo Nivel</a></span>
<span class="toc" ><a class="h3" href="#Seccion-13.1" ><code>unsafe.Sizeof</code>, <code>Alignof</code>, y <code>Offsetof</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-13.2" ><code>unsafe.Pointer</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-13.3" >Ejemplo: Equivalencia profunda</a></span>
<span class="toc" ><a class="h3" href="#Seccion-13.4" >Llamar Codigo C con <code class="command" >cgo</code></a></span>
<span class="toc" ><a class="h3" href="#Seccion-13.5" >Otra Palabra de Precaucion</a></span>

  </div>
</div>


<h1>El lenguaje de programacion Go</h1>

<div class="hBody-1" >
<div class="center" >
<p>Para Leila y Meg</p>
</div>
</div>
<h2 id="Prefacio" >Prefacio</h2>
<div class="hBody-2" >
<blockquote>
<p><q>Go es un lenguaje de programacion de codigo abierto, que facilita la creacion de software simple, confiable y eficiente.</q></p>
<div class="quote-author" >
<p>(Desde el sitio web de Go en <a href="https://golang.org/" >golang.org</a>)</p>
</div>
</blockquote>
<p>Go fue concebido en septiembre de 2007 por Robert Griesemer, Rob Pike y Ken Thompson, todos de Google, y fue anunciado en noviembre de 2009. La meta del lenguaje y sus herramientas acompañantes es ser expresivos, eficientes en la compilacion y ejecucion, y eficaz en la escritura de programas fiables y robustos.</p>
<p>Go tiene una similitud superficial con C y, como C, es una herramienta para programadores profesionales, logrando el maximo efecto con un minimo de medios. Pero es mucho mas que una version actualizada de C. Obtiene y adapta buenas ideas de muchos otros lenguajes, evitando caracteristicas que han llevado a la complejidad y a un codigo poco confiable. Sus comodidades para la concurrencia son nuevas y eficientes, y su enfoque hacia la abstraccion de datos y la programacion orientada a objetos es inusualmente flexible. Tambien cuenta con gestion automatica de memoria o <em>recoleccion de basura</em>.</p>
<p>Go es especialmente adecuado para la construccion de infraestructura como servidores en red, y herramientas y sistemas para programadores, pero es realmente un lenguaje de uso general y se utiliza en dominios tan diversos como graficos, aplicaciones moviles y aprendizaje automatico. Se ha vuelto popular como un reemplazo para los lenguajes de scripting no tipados porque equilibra la expresividad con la seguridad: Los programas Go suelen funcionar mas rapido que los programas escritos en lenguajes dinamicos y sufren muchos menos accidentes debido a errores de tipado.</p>
<p>Go es un proyecto de codigo abierto, por lo que el codigo fuente de su compilador, librerias y herramientas esta disponible gratuitamente para cualquiera. Las contribuciones al proyecto provienen de una activa comunidad mundial. Go se ejecuta en sistemas tipo Unix–GNU/Linux, FreeBSD, OpenBSD, Mac OS X–y en Plan 9 y Microsoft Windows. Los programas escritos en uno de estos entornos generalmente funcionan sin modificacion en los otros.</p>
<p>Este libro esta diseñado para ayudarle a comenzar a usar Go efectivamente, de inmediato y utilizarlo bien, aprovechando al maximo las caracteristicas lingüisticas de Go y las librerias estandar para escribir programas claros, idiomaticos y eficientes.</p>
</div>
<h3 id="Los-Origenes-de-Go" >Los Origenes de Go</h3>
<div class="hBody-3" >
<p>Como las especies biologicas, los lenguajes exitosos engendran hijos que incorporan las ventajas de sus antepasados; El entrecruzamiento a veces conduce a fortalezas sorprendentes; Y, muy ocasionalmente, surge un nuevo rasgo radical sin precedentes. Podemos aprender mucho sobre por que un lenguaje es como es y a que entorno se ha adaptado para ver estas influencias.</p>
<p>La siguiente figura muestra las influencias mas importantes de los lenguajes de programacion anteriores en el diseño de Go.</p>
<figure>
<img src="img/go-influences.jpg" />
</figure>
<p>En ocaciones Go se describe como un <q>lenguaje de tipo C</q>, o como <q>C para el siglo 21</q>. De C, Go heredo su sintaxis de expresiones, instrucciones de flujo de control, tipos de datos basicos, paso de parametros por valor, punteros y, sobre todo, el enfasis de C en programas que compilan codigo maquina eficiente y cooperan naturalmente con las abstracciones de los sistemas operativos actuales.</p>
<p>Pero hay otros antepasados ​​en el arbol genealogico de Go. Una importante corriente de influencia proviene de lenguajes de Niklaus Wirth, comenzando con Pascal. Modula-2 inspiro el concepto de paquete. Oberon elimino la distincion entre los archivos de interfaz del modulo y los archivos de implementacion del modulo. Oberon-2 influyo en la sintaxis de importacion y declaracion de paquetes, y Object Oberon proporciono la sintaxis para la declararcion de metodos.</p>
<p>Otro linaje entre los antepasados de Go, y uno que hace a Go distinto entre los lenguajes de programacion mas recientes, es una secuencia de lenguajes de investigacion poco conocidos desarrollados en los Laboratorios Bell, todos ellos inspiradas en el concepto de comunicacion de procesos secuenciales (CSP) del seminal articulo de 1978 de Tony Hoare en los cimientos de la concurrencia. En CSP, un programa es una composicion paralela de procesos que no tienen estado compartido; Los procesos se comunican y sincronizan utilizando canales. Pero el CSP de Hoare era un lenguaje formal para describir los conceptos fundamentales de la concurrencia, no un lenguaje de programacion para escribir programas ejecutables.</p>
<p>Rob Pike y otros comenzaron a experimentar con implementaciones CSP como lenguajes reales. El primero fue llamado Squeak (<q>Un Lenguaje para comunicarce con ratones</q>), que proporcionaron un lenguaje para el manejo de eventos de raton y teclado, con canales estaticamente creados. Esto fue seguido por Newsqueak, que ofrecia declaraciones y sintaxis de expresion como C y la notacion de tipo Pascal. Se trataba de un lenguaje puramente funcional con recoleccion de basura, dirigido nuevamente a administrar eventos de teclado, raton y ventanas. Los canales se convirtieron en valores de primera clase, creados dinamicamente y almacenados en variables.</p>
<p>El sistema operativo Plan 9 llevo adelante estas ideas en un lenguaje llamado Alef. Alef trato de hacer de Newsqueak un lenguaje viable para la programacion de sistemas, pero su omision de un recoleccion de basura hizo que la concurrencia fuera demasiado dolorosa.</p>
<p>Otras construcciones en Go muestran la influencia de genes no ancestrales aqui y alla; Por ejemplo <code>iota</code> es tomado libremente de APL, y el ambito lexico con funciones anidadas es de Scheme (y la mayoria de lenguajes desde entonces). Aqui tambien encontramos mutaciones novedosas. Go innova proporcionando slices (arreglos dinamicos) con acceso aleatorio eficiente, pero tambien permite sofisticados arreglos compartidos que recuerdan a las listas enlazadas. Y la declaracion <code>defer</code> es nueva con Go.</p>
</div>
<h3 id="El-Proyecto-Go" >El Proyecto Go</h3>
<div class="hBody-3" >
<p>Todos los lenguajes de programacion reflejan la filosofia de programacion de sus creadores, que a menudo incluye un componente significativo de la reaccion a las deficiencias percibidas de los lenguajes anteriores. El proyecto Go fue frustrado con varios sistemas de software de Google que estaban sufriendo una explosion de complejidad. (Este problema no es exclusivo de Google.)</p>
<p>Como Rob Pike dijo, <q>la complejidad es multiplicativa</q>: solucionar un problema al hacer una parte del sistema mas compleja, lenta pero seguramente añade complejidad a otras partes. Con la presion constante para agregar caracteristicas y opciones y configuraciones, y para enviar codigo rapidamente, es facil olvidar la sencillez, aunque a la larga la simplicidad es la clave para un buen software.</p>
<p>La simplicidad requiere mas trabajo al comienzo de un proyecto para reducir una idea a su esencia y mas disciplina durante la vida de un proyecto para distinguir los buenos cambios, de los malos o perniciosos. Con un esfuerzo suficiente, un buen cambio se puede acomodar sin comprometer lo que Fred Brooks llamo la <q>integridad conceptual</q> del diseño, pero un mal cambio no puede, un cambio pernicioso negocia la sencillez por una conveniencia superficial. Solo a traves de la simplicidad del diseño un sistema puede permanecer estable, seguro y coherente a medida que crece.</p>
<p>El proyecto Go incluye el lenguaje mismo, sus herramientas y librerias estandar, y por ultimo, pero no menos importante, una agenda cultural de simplicidad radical. Como un lenguaje reciente de alto nivel, Go tiene el beneficio de la retrospectiva, y los fundamentos se hacen bien: tiene recoleccion de basura, un sistema de paquetes, funciones de primera clase, alcance lexico, una interfaz de llamadas de sistema y cadenas inmutables en las que el texto es generalmente codificado en UTF-8. Pero tiene comparativamente pocas caracteristicas y es poco probable que agregue mas. Por ejemplo, no tiene conversiones numericas implicitas, no hay constructores o destructores, no hay sobrecarga de operadores, no hay valores de parametros predeterminados, no hay herencia, no hay genericos, no hay excepciones, no hay macros, no hay anotaciones de funcion y no hay almacenamiento local de subprocesos. El lenguaje es maduro y estable y garantiza la compatibilidad con versiones anteriores: los programas Go mas antiguos se pueden compilar y ejecutar con versiones mas recientes de compiladores y librerias estandar.</p>
<p>Go tiene un sistema de tipado para evitar la mayoria de los errores descuidados que afectan a los programadores en lenguajes dinamicos, pero tiene un sistema de tipado mas simple que los lenguajes tipados comparables. Este enfoque puede conducir en ocaciones a baches de programacion <q>sin tipo</q> dentro de un marco mas amplio de tipos, y los programadores Go no van a las longitudes que hacen a los programadores C++ o Haskell expresar propiedades de seguridad como pruebas basadas en tipo. Pero en la practica, Go da a los programadores gran parte de los beneficios de seguridad y rendimiento en tiempo de ejecucion de un sistema de tipado relativamente fuerte sin la carga de complejidad.</p>
<p>Go fomenta una conciencia del diseño de sistemas informaticos contemporaneos, particularmente la importancia de la localidad. Sus tipos de datos incorporados y la mayoria de las estructuras de datos de la libreria estan diseñados para funcionar naturalmente sin inicializacion explicita o constructores implicitos, por lo que relativamente pocas asignaciones de memoria y escrituras de memoria estan ocultas en el codigo. Los tipos agregados de Go (estructuras y matrices) mantienen sus elementos directamente, requiriendo menos almacenamiento y menos asignaciones e indireccion de punteros, que los lenguajes que utilizan campos indirectos. Y como la computadora moderna es una maquina paralela, Go tiene caracteristicas de concurrencia basadas en CSP, como se menciono anteriormente. Los stacs de tamaño variable de los hilos ligeros de Go o <em>gorutinas</em> son inicialmente lo suficientemente pequeñas como para que crear una gorutina sea barato y crear un millon sea practico.</p>
<p>La libreria estandar de Go, a menudo descrita como con <q>baterias incluidas,</q> proporciona bloques de construccion limpios y APIs de E/S, procesamiento de texto, graficos, criptografia, redes y aplicaciones distribuidas, con soporte para muchos formatos de archivos y protocolos estandar. Las librerias y las herramientas hacen uso extensivo de la convencion para reducir la necesidad de configuracion y explicaciones, simplificando asi la logica del programa y haciendo que diversos programas Go sean mas similares entre si y, por lo tanto, mas faciles de aprender. Los proyectos creados con la herramienta <code class="command" >go</code> solo utilizan nombres de archivos e identificadores y un comentario especial ocasional para determinar todas las librerias, ejecutables, pruebas, referencias, ejemplos, variantes especificas de la plataforma y documentacion para un proyecto; El codigo fuente de Go en si contiene la especificacion de compilacion.</p>
</div>
<h3 id="Organizacion-del-Libro" >Organizacion del Libro</h3>
<div class="hBody-3" >
<p>Asumimos que usted ha programado en uno o mas lenguajes, compilados como C, C++ y Java, o interpretados como Python, Ruby y JavaScript, por lo que no solemos explicar todo como si fuera un completo principiante. La sintaxis superficial sera familiar, al igual que variables y constantes, expresiones, flujo de control y funciones.</p>
<p>El Capitulo 1 es un tutorial sobre las construcciones basicas de Go, introducido a traves de una docena de programas para tareas cotidianas como leer y escribir archivos, formatear texto, crear imagenes y comunicarse con clientes y servidores de Internet.</p>
<p>El Capitulo 2 describe los elementos estructurales de un programa Go–declaraciones, variables, nuevos tipos, paquetes y archivos, y alcance. El Capitulo 3 analiza numeros, booleanos, cadenas y constantes, y explica como procesar Unicode. El Capitulo 4 describe los tipos compuestos, es decir, los tipos construidos a partir de los mas sencillos utilizando arreglos, mapas, estructuras y slices, la aproximacion de Go para listas dinamicas. El Capitulo 5 cubre las funciones y discute el manejo de errores, <code>panic</code> y <code>recover</code>, y la sentencia <code>defer</code>.</p>
<p>Los Capitulos 1 a 5 son, son por lo tanto, lo basico, las cosas que forman parte de cualquier lenguaje imperativo popular. La sintaxis y el estilo de Go a veces difieren de otros lenguajes, pero la mayoria de los programadores los recogeran rapidamente. Los capitulos restantes se centran en temas en los que el enfoque de Go es menos convencional: metodos, interfaces, concurrencia, paquetes, pruebas y reflexion.</p>
<p>Go tiene un acercamiento inusual a la programacion orientada a objetos. No hay jerarquias de clase, o de hecho ninguna clase; Los comportamientos de objetos complejos se crean a partir de los mas simples por composicion, no por herencia. Los metodos pueden ser asociados con cualquier tipo definido por el usuario, no solo las estructuras, y la relacion entre tipos concretos y tipos abstractos (las <em>interfaces</em>) son implicitas, por lo que un tipo concreto puede satisfacer una interfaz que el diseñador del tipo desconocia. Los metodos estan cubiertos en el Capitulo 6, las interfaces en el Capitulo 7.</p>
<p>El Capitulo 8 presenta el enfoque de Go a la concurrencia, que se basa en la idea de comunicar procesos secuenciales (CSP), incorporados por goroutines y canales. El Capitulo 9 explica los aspectos mas tradicionales de la concurrencia basados ​​en variables compartidas.</p>
<p>El Capitulo 10 describe los paquetes, el mecanismo para organizar las librerias. Este capitulo tambien muestra como hacer un uso efectivo de la herramienta <code class="command" >go</code>, provista para la compilacion, pruebas, benchmarking, formateo del programa, documentacion y muchas otras tareas, todo dentro de un solo comando.</p>
<p>El Capitulo 11 trata de las pruebas, donde Go adopta un enfoque notablemente ligero, evitando framewoks cargados de abstraccion en favor de librerias y herramientas simples. Las librerias de pruebas proporcionan una base sobre la que se pueden construir abstracciones mas complejas si es necesario.</p>
<p>El Capitulo 12 discute la reflexion, la capacidad de un programa para examinar su propia representacion durante la ejecucion. La reflexion es una herramienta poderosa, aunque debe ser usada con cuidado; Este capitulo explica como encontrar el equilibrio correcto, mostrando como se utiliza para implementar algunas librerias importantes en Go. El Capitulo 13 explica los detalles morbosos de programacion a bajo nivel que utiliza el paquete <code>unsafe</code> para dar un paso alrededor del sistema de tipado de Go, y cuando eso es apropiada.</p>
<p>Cada capitulo tiene una serie de ejercicios que puedes usar para probar tu comprension de Go, y para explorar extensiones y alternativas a los ejemplos del libro.</p>
<p>Todos menos los ejemplos de codigo mas triviales en el libro estan disponibles para su descarga desde un repositorio Git publico en <a href="http://www.gopl.io/" >gopl.io</a>. Cada ejemplo se identifica por su ruta de importacion de paquete y puede ser convenientemente localizado, construido e instalado utilizando el comando <code class="command" >go get</code>. tendra que elegir un directorio para que sea su espacio de trabajo y establecer la variable de entorno <code>GOPATH</code> apuntando a este. La herramienta <code class="command" >go</code> creara el directorio si es necesario. Por ejemplo:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span><span class="nv">$HOME</span>/gobook        <span class="c1"># Elegir el directorio de trabajo</span>
$ go get gopl.io/ch1/helloworld     <span class="c1"># buscar, construir, instalar</span>
$ <span class="nv">$GOPATH</span>/bin/helloworld            <span class="c1"># ejecutar</span>
Hello, 世界
</pre></div>
<p>Para ejecutar los ejemplos, necesitara al menos la version 1.5 de Go.</p>
<div class="highlight"><pre><span></span>$ go version
go version go1.5 linux/amd64
</pre></div>
<p>Siga las instrucciones en <a href="https://golang.org/doc/install" >https://golang.org/doc/install</a> si en su equipo la herramienta <code class="command" >go</code> esta ausente o es anterior.</p>
</div>
<h3 id="Donde-Encontrar-Mas-Informacion" >Donde Encontrar Mas Informacion</h3>
<div class="hBody-3" >
<p>La mejor fuente para obtener mas informacion sobre Go es el sitio web oficial, <a href="https://golang.org" >https://golang.org</a>, que proporciona acceso a la documentacion, incluyendo la <em>Especificacion del Lenguaje de Programacion Go</em>, los paquetes estandar, y similares. Tambien hay tutoriales sobre como escribir Go y como escribirlo bien, y una amplia variedad de recursos de texto y video en linea que seran complementos valiosos para este libro. El Blog de Go se encuentra en <a href="https://blog.golang.org" >blog.golang.org</a> donde se publican algunos de los mejores escritos en Go, con articulos sobre el estado del lenguaje, los planes a futuro, los informes sobre conferencias y explicaciones en profundidad de una amplia variedad de temas relacionados.</p>
<p>Uno de los aspectos mas utiles del acceso en linea a Go (y una limitacion lamentable de un libro de papel) es la capacidad de ejecutar programas de Go desde las paginas web que los describen. Esta funcionalidad es proporcionada por Go Playground en <a href="https://play.golang.org" >play.golang.org</a>, y puede ser embebido dentro de otras paginas, como la pagina de inicio en <a href="https://golang.org" >golang.org</a> o las paginas de documentacion provistas por la herramienta <code class="command" >godoc</code>.</p>
<p>Playground hace que sea conveniente llevar a cabo experimentos sencillos para comprobar la propia comprension de la sintaxis, la semantica, o paquetes de librerias con programas cortos, y en muchos sentidos toma el lugar de un <em>bucle leer-evaluar-imprimir</em> (<em>read-eval-print loop</em> o REPL) de otros lenguajes. Sus URLs persistentes son ideales para compartir fragmentos de codigo con otros, para informar sobre errores o hacer sugerencias.</p>
<p>Construido sobre Playground, el Tour Go en <a href="https://tour.golang.org" >tour.golang.org</a> es una secuencia de breves lecciones interactivas sobre las ideas basicas y construcciones de Go, un paseo ordenado atraves del lenguaje.</p>
<p>El principal inconveniente del Playground y del Tour es que permiten que solo se importen librerias estandar, y muchas funciones de la libreria–por ejemplo, redes–estan restringidas por razones practicas o de seguridad. Tambien requiere de acceso a Internet para compilar y ejecutar cada programa. Asi que para experimentos mas elaborados, tendra que ejecutar programas Go en su propia computadora. Afortunadamente, el proceso de descarga es sencillo, por lo que no debe tomar mas de unos minutos para buscar su distribucion Go desde <a href="https://golang.org" >golang.org</a> y empezar a escribir y ejecutar programas por su cuenta.</p>
<p>Ya que Go es un proyecto de codigo abierto, se puede leer el codigo fuente de cualquier tipo o funcion en la libreria estandar en <a href="https://golang.org/pkg" >https://golang.org/pkg</a>; el mismo codigo forma parte de la distribucion descargada. Utilice esto para averiguar como funciona algo, o para responder a preguntas sobre los detalles, o simplemente para ver como los expertos escriben buen Go.</p>
</div>
<h3 id="Agradecimientos" >Agradecimientos</h3>
<div class="hBody-3" >
<p>Rob Pike y Russ Cox, miembros centrales del equipo de Go, leyeron el manuscrito varias veces con mucho cuidado; Sus comentarios sobre todo, desde la eleccion de palabras hasta la estructura general y la organizacion han sido invaluables. Mientras preparaba la traduccion japonesa, Yoshiki Shibata iba mucho mas alla del llamado del deber; Su ojo meticuloso observo numerosas inconsistencias en el texto ingles y errores en el codigo. Apreciamos grandemente revisiones completas y comentarios criticos en el manuscrito entero de Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, y Peter Weinberger.</p>
<p>Agradecemos a Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue, Jonathan Feinberg, Andrew Gerrand, Roberto Griesemer, John Linderman, Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao, y a Howard Trickey para muchas sugerencias utiles. Tambien damos las gracias a David Brailsford y Raph Levien por los consejos sobre composicion tipografica.</p>
<p>Nuestro redactor Greg Doench de Addison-Wesley consiguio hacer rodar la bola originalmente y ha estado ayunando continuamente desde entonces. El equipo de produccion de AW–John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith y Barbara Wood–ha sido excepcional; Los autores no podrian esperar un mejor apoyo.</p>
<p>Alan Donovan desea agradecer a: Sameer Ajmani, Chris Demetriou, Walt Drummond, y Reid Tatge en Google por permitirle tiempo para escribir; Stephen Donovan, por su consejo y oportuno estimulo; Y sobre todo a su esposa Leila Kazemi, por su entusiasmo y apoyo inquebrantable a este proyecto, a pesar de las largas horas de distraccion y ausentismo de la vida familiar que ello conllevaba.</p>
<p>Brian Kernighan esta profundamente agradecido a sus amigos y colegas por su paciencia y autodominio mientras avanzaba lentamente por el camino hacia la comprension, y especialmente a su esposa Meg, que ha sido infaliblemente favorable a la escritura de libros y mucho mas.</p>
<blockquote>
<div class="quote-author" >
<p>Nueva York</p>
</div>
<div class="quote-author" >
<p>Octubre 2015</p>
</div>
</blockquote>
</div>
<h2 id="Capitulo-1" >Tutorial</h2>
<div class="hBody-2" >
<p>Este capitulo es un recorrido por los componentes basicos de Go. Esperamos proporcionar suficiente informacion y ejemplos para sacarle del barro y hacer cosas utiles lo mas rapido posible. Los ejemplos aqui, y de hecho en todo el libro, estan dirigidos a tareas que usted podria tener que hacer en el mundo real. En este capitulo intentaremos darle una muestra de la diversidad de programas que uno podria escribir en Go, que van desde el simple procesamiento de archivos y un poco de graficos, a clientes y servidores de Internet concurrentes. Ciertamente no vamos a explicar todo en el primer capitulo, pero el estudio de estos programas en un nuevo lenguaje puede ser una manera eficaz de empezar.</p>
<p>Cuando estas aprendiendo un nuevo lenguaje, hay una tendencia natural a escribir codigo como lo habrias escrito en un languaje que ya conoces. Este consciente de este sesgo a medida que aprende Go y trate de evitarlo. Hemos tratado de ilustrar y explicar como escribir buen Go, asi que utilice el codigo aqui como guia cuando este escribiendo el suyo propio.</p>
</div>
<h3 id="Seccion-1.1" >Hola, Mundo</h3>
<div class="hBody-3" >
<p>Vamos a empezar con el ya tradicional ejemplo del <q>hola, mundo</q>, que aparece al comienzo de <em>El lenguaje de programacion C</em>, publicado en 1978. C es una de las influencias mas directas sobre Go, y <q>hola, mundo</q> ilustra una serie de ideas centrales.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/helloworld/main.go" >gopl.io/ch1/helloworld</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello, 世界&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Go es un lenguaje compilado. El conjunto de herramienta de Go convierte el codigo fuente de un programa y las cosas de las que depende, en instrucciones en el lenguaje maquina nativo de una computadora. Se puede acceder a estas herramientas a traves de un unico comando llamado <code class="command" >go</code> que tiene una serie de subcomandos. El mas simple de estos subcomandos es <code class="command" >run</code>, que compila el codigo fuente de uno o mas archivos de origen cuyos nombres terminan en <span class="file" >.go</span>, lo vincula con las librerias, y a continuacion, ejecuta el archivo ejecutable resultante. (Utilizaremos <code class="command" >$</code> como el simbolo del sistema en todo el libro.)</p>
<div class="highlight"><pre><span></span>$ go run helloworld.go
</pre></div>
<p>No es sorprendente que esto imprima</p>
<div class="highlight"><pre><span></span>Hello, 世界
</pre></div>
<p>Go maneja Unicode de forma nativa, por lo que puede procesar texto en todos los idiomas del mundo.</p>
<p>Si el programa es mas que un experimento de un solo disparo, es probable que quiera compilarlo una vez y guardar el resultado compilado para su uso posterior. Esto se hace con <code class="command" >go build</code>:</p>
<div class="highlight"><pre><span></span>$ go build helloworld.go
</pre></div>
<p>Esto crea un archivo binario ejecutable llamado <code class="command" >helloworld</code> que se pueden ejecutar en cualquier momento sin procesamiento adicional:</p>
<div class="highlight"><pre><span></span>$ ./helloworld
Hello, 世界
</pre></div>
<p>Hemos etiquetado cada ejemplo significativo como un recordatorio de que puede obtener el codigo fuente del libro desde el repositorio en <a href="http://www.gopl.io/" >(gopl.io</a>: <a href="http://www.gopl.io/ch1/helloworld" >gopl.io/ch1/helloworld</a></p>
<p>Si ejecuta <code class="command" >go get gopl.io/ch1/helloworld</code>, obtendra el codigo fuente y lo colocara en el directorio correspondiente. Hay mas informacion sobre este tema en la <a href="#Seccion-2.6" >Seccion 2.6</a> y la <a href="#Seccion-10.7" >Seccion 10.7</a>.</p>
<p>Hablemos ahora del programa en si. El codigo Go esta organizado en paquetes, que son similares a librerias o modulos en otros lenguajes. Un paquete se compone de uno o mas archivos de codigo <span class="file" >.go</span> en un unico directorio que definen lo que hace el paquete. Cada archivo de codigo inicia con una declaracion del paquete, aqui es <code>package main</code>, que declara a que paquete pertenece el archivo, seguido de una lista de otros paquetes que importa, y luego las declaraciones del programa que se almacena en el archivo.</p>
<p>La libreria estandar de Go tiene mas de 100 paquetes para tareas comunes como entrada y salida, clasificacion y manipulacion de texto. Por ejemplo, el paquete <code>fmt</code> contiene funciones para la impresion y entrada de datos con formato. <code>Println</code> es una de las funciones basicas de salida en <code>fmt</code>; esta imprime uno o mas valores, separados por espacios, con un caracter de nueva linea al final para que los valores aparezcan como una sola linea de salida.</p>
<p>El paquete <code>main</code> es especial. Define un programa ejecutable independiente, no una libreria. Dentro del paquete <code>main</code> la <em>funcion</em> <code>main</code> tambien es especial–es donde comienza la ejecucion del programa. Cualquier cosa que haga <code>main</code> es lo que hara el programa. Por supuesto, <code>main</code> sera normalmente un llamado a las funciones de otros paquetes que hacen gran parte del trabajo, como la funcion <code>fmt.Println</code>.</p>
<p>Debemos decirle al compilador que paquetes son necesarios para este archivo de codigo fuente; ese es el papel de la declaracion <code>import</code> seguida por la declaracion del <code>paquete</code>. El programa <q>hola, mundo</q> utiliza solo una funcion de otro paquete, pero en la mayoria de los programas importaran mas paquetes.</p>
<p>Debe importar exactamente los paquetes que necesita. Un programa no compilara si hay importaciones que faltan o si son innecesarias. Este estricto requisito impide que las referencias a paquetes no utilizados se acumulen a medida que los programas evolucionan.</p>
<p>Las declaraciones <code>import</code> deben ir luego de la declaracion <code>package</code>. Despues de eso, un programa consiste en la declaracion de funciones, variables, constantes y tipos (introducidos por las palabras clave <code>func</code>, <code>var</code>, <code>const</code>, y <code>type</code>); En su mayor parte, el orden de las declaraciones no importa. Este programa es lo mas corto posible, ya que declara solo una funcion, que a su vez solo llama a otra funcion. Para ahorrar espacio en la presentacion de ejemplos, a veces no mostramos las declaraciones <code>package</code> e <code>import</code>, pero estaran en el codigo del archivo y debemos estar alli para compilar el codigo.</p>
<p>Una declaracion de funcion consiste en la palabra clave <code>func</code>, el nombre de la funcion, una lista de parametros (vacia para <code>main</code>), una lista de resultados (aqui tambien vacia), y el cuerpo de la funcion–las declaraciones que definen lo que hace–encerradas entre llaves. Vamos a echar un vistazo mas de cerca a las funciones en el <a href="#Capitulo-5" >Capitulo 5</a>.</p>
<p>Go no requiere punto y coma al final de las sentencias o declaraciones, excepto donde aparecen dos o mas en la misma linea. En efecto, las nuevas lineas que siguen ciertas palabras se convierten en punto y coma, por lo que cuando se colocan nuevas lineas se colocan en funcion del correcto analisis del codigo Go. Por ejemplo, la llave de apertura <code>{</code> de la funcion, debe estar en la misma linea, que el final de la declaracion <code>func</code>, no en una linea distinta, y en la expresion <code>x + y</code>, se permite un salto de linea despues, pero no antes del operador <code>+</code>.</p>
<p>Go toma una fuerte postura en el formato del codigo. La herramienta <code class="command" >gofmt</code> reescribe el codigo en el formato estandar, y el subcomando <code class="command" >fmt</code> de la herramienta <code class="command" >go</code> aplica <code class="command" >gofmt</code> a todos los archivos en el paquete especificado, o por defecto, a los que estan en el directorio actual.  Se ha ejecutado <code class="command" >gofmt</code> sobre todos los archivos de codigo fuente en el libro, y usted debe optener el habito de hacer lo mismo con su propio codigo. Declarar un formato estandar por mandato elimina un monton de debate inutil sobre trivialidades y, lo que es mas importante, permite una variedad de transformaciones automatizadas de codigo fuente que serian imposibles si se permitiera el formato arbitrario.</p>
<p>Muchos editores de texto pueden ser configurados para ejecutar <code class="command" >gofmt</code> cada vez que se guarda un archivo, por lo que su codigo fuente siempre tendra el formato apropiado. Una herramienta relacionada, <code class="command" >goimports</code>, ademas, gestiona la insercion y extraccion de las declaraciones de importacion, segun sea necesario. No es parte de la distribucion estandar pero se puede obtener con este comando:</p>
<div class="highlight"><pre><span></span>$ go get golang.org/x/tools/cmd/goimports
</pre></div>
<p>Para la mayoria de los usuarios, la forma habitual de descargar y construir paquetes, ejecutar pruebas, mostrar su documentacion, y asi sucesivamente, es con la herramienta <code class="command" >go</code>, que vamos a ver en la <a href="#Seccion-10.7" >Seccion 10.7</a>.</p>
</div>
<h3 id="Seccion-1.2" >Argumentos de Linea de Comandos</h3>
<div class="hBody-3" >
<p>La mayoria de los programas procesan alguna entrada para producir alguna salida; Que es mas o menos la definicion de la computacion. Pero, ¿como un programa obtiene datos de entrada para operar? Algunos programas generan sus propios datos, pero mas a menudo, la entrada proviene de una fuente externa: un archivo, una conexion de red, la salida de otro programa, un usuario en un teclado, argumentos de linea de comandos o similares. Los siguientes ejemplos discutiran algunas de estas alternativas, comenzando con argumentos de linea de comandos.</p>
<p>El paquete <code>os</code> proporciona funciones y otros valores para relacionarse con el sistema operativo de una manera independiente de la plataforma. Los argumentos de linea de comandos estan disponibles para un programa en una variable denominada <code>Args</code> que forma parte del paquete <code>os</code>; por lo tanto su nombre en cualquier lugar fuera del paquete <code>os</code> es <code>os.Args</code>.</p>
<p>La variable <code>os.Args</code> es un <em>slice</em> de <code>strings</code>. Los slices son una nocion fundamental en Go, y hablaremos mucho mas sobre ellos pronto. Por ahora, piensa en un slice como una secuencia <code>s</code> de elementos de un arreglo de tamaño dinamico, donde los elementos individuales pueden accederse como <code>s[i]</code> y una subsecuencia contigua como <code>s[m:n]</code>. El numero de elementos esta dado por <code>len(s)</code>. Como en la la mayoria de los otros lenguajes de programacion, toda  indexacion en Go utiliza intervalos <em>semiabiertos</em> que incluyen el primer indice, pero no incluyen el ultimo, ya que simplifica la logica. Por ejemplo, el slice  <code>s[m:n]</code>, donde <code>0 ≤ m ≤ n ≤ len(s)</code>, contiene <code>n-m</code> elementos.</p>
<p>El primer elemento de <code>os.Args</code>, <code>os.Args[0]</code>, es el nombre del comando en si; Los otros elementos son los argumentos que se ofresieron al programa cuando se inicio la ejecucion. Una expresion de la forma <code>s[m:n]</code> produce un slice que hace referencia a los elementos entre <code>m</code> y <code>n-1</code>, por lo que los elementos que necesitamos para nuestro siguiente ejemplo corresponden al slice <code>os.Args[1:len(os.Args)]</code>. Si <code>m</code> o <code>n</code> se omite, el valor predeterminado es 0 o <code>len(s)</code>, respectivamente, por lo que se puede abreviar el slice deseado como <code>os.Args[1:]</code>.</p>
<p>Aqui esta una implementacion del comando <code class="command" >echo</code> de Unix, que imprime sus argumentos de linea de comandos en una sola linea. Importa dos paquetes, que se dan como una lista entre parentesis en lugar de como declaraciones de importacion individuales. Cualquiera de las formas es legal, pero convencionalmente se utiliza el formato de lista. El orden de las importaciones no importa; la herramienta <code class="command" >gofmt</code> ordena los nombres de los paquetes en orden alfabetico. (Cuando hay varias versiones de un ejemplo, a menudo las numeraremos para que pueda estar seguro de cual estamos hablando.)</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/echo1/main.go" >gopl.io/ch1/echo1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Echo1 imprime sus argumentos de linea de comandos</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">sep</span> <span class="p">=</span> <span class="s">&quot; &quot;</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los comentarios comienzan con <code>//</code>. Todo el texto desde <code>//</code> hasta el final de la linea es el comentario para los programadores y es ignorado por el compilador. Por convencion, describimos cada paquete en un comentario inmediatamente anterior a su declaracion del paquete; para un paquete <code>main</code>, este comentario es una o varias frases completas que describen el programa en su conjunto.</p>
<p>La declaracion <code>var</code> declara dos variables <code>s</code> y <code>sep</code>, de tipo <code>string</code>. Una variable se puede inicializar como parte de su declaracion. Si no se inicia de forma explicita, se inicializa de forma implicita al <em>valor cero</em> para su tipo, que es 0 para los tipos numericos y la cadena vacia <code>&quot;&quot;</code> para strings. Asi, en este ejemplo, la declaracion implicita inicializa <code>s</code> y <code>sep</code> como cadenas vacias. Tendremos mas que decir acerca de las variables y las declaraciones en el <a href="#Capitulo-2" >Capitulo 2</a>.</p>
<p>Para los numeros, Go proporciona los operadores aritmeticos y logicos habituales. Cuando se aplica a las cadenas, sin embargo, el operador <code>+</code> <em>concatena</em> los valores, por lo que la expresion</p>
<div class="highlight"><pre><span></span><span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</pre></div>
<p>representa la concatenacion de las cadenas <code>sep</code> y <code>os.Args[i]</code>. La declaracion que usamos en el programa,</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</pre></div>
<p>es una <em>sencencia de asignacion</em> que concatena el antiguo valor de <code>s</code> con <code>sep</code> y <code>os.Args[i]</code> y lo asigna de nuevo a <code>s</code>; Es equivalente a</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span> <span class="o">+</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</pre></div>
<p>El operador <code>+=</code> es un operador de asignacion. Cada operador aritmetico y logico como <code>+</code> o <code>*</code> tiene un operador de asignacion correspondiente.</p>
<p>El programa <code class="command" >echo</code> podria haber impreso su salida en un bucle de una sola pieza a la vez, pero en esta version, en su lugar se acumula una cadena añadiendo repetidamente nuevo texto hasta el final. La cadena de <code>s</code> comienza su vida vacia, es decir, con el valor <code>&quot;&quot;</code>, y cada ciclo a traves del bucle añade un poco de texto a ella; Despues de la primer iteracion, tambien se inserta un espacio para que cuando el bucle este terminado, haya un espacio entre cada argumento. Este es un proceso cuadratico que podria ser costoso si el numero de argumentos es grande, pero para <code class="command" >echo</code>, eso es poco probable. Vamos a mostrar una serie de versiones mejoradas de <code class="command" >echo</code> en este capitulo y el siguiente para hacer frente a cualquier ineficiencia real.</p>
<p>El indice variable <code>i</code> del bucle se declara en la primer parte del bucle <code>for</code>. El simbolo <code>:=</code> es parte de una <em>declaracion de variables compacta</em>, una sentencia que declara una o mas variables y les da los tipos apropiados basados en los valores del inicializador; Hay mas informacion al respecto en el proximo capitulo.</p>
<p>La declaracion de incremento <code>i++</code> añade 1 a <code>i</code>; que es equivalente a <code>i += 1</code>, que es a su vez equivalente a <code>i = i + 1</code>. Hay una declaracion de decremento correspondiente <code>i--</code> que resta 1. Estas son declaraciones, no expresiones como lo son en la mayoria de los lenguajes en la familia C, por lo que <code>j = i++</code> es ilegal, y solamente son de sufijo, asi <code>--i</code> tampoco es legal.</p>
<p>El bucle <code>for</code> es la unica sentencia de bucle en Go. Tiene una serie de formas, una de las cuales se ilustra aqui:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">inicializacion</span><span class="p">;</span> <span class="nx">condicion</span><span class="p">;</span> <span class="nx">incremento</span> <span class="p">{</span>
    <span class="c1">// cero o mas declaraciones</span>
<span class="p">}</span>
</pre></div>
<p>Los parentesis no se utilizan nunca alrededor de los tres componentes de un bucle <code>for</code>. Las llaves son obligatorias, sin embargo, y la llave de apertura deben estar en la misma linea que la declaracion <code>incremento</code>.</p>
<p>La declaracion opcional <code>inicializacion</code> se ejecuta antes de que comience el bucle. Si esta presente, debe ser una simple declaracion, es decir, una declaracion de variables compacta, una declaracion de incremento o asignacion, o una llamada a funcion. La <code>condition</code> es una expresion booleana que se evalua en al inicio de cada iteracion del bucle; si se evalua como <code>true</code>, las declaraciones controladas por el bucle se ejecutan. La declaracion <code>incremento</code> se ejecuta despues del cuerpo del bucle, luego la <code>condicion</code> se evalua de nuevo. El bucle termina cuando la condicion se convierte en falsa.</p>
<p>Cualquiera de estas partes puede omitirse. Si no hay <code>inicializacion</code> y ningun <code>incremento</code>, el punto y coma tambien pueden omitirse:</p>
<div class="highlight"><pre><span></span><span class="c1">// un tradicional bucle &quot;while&quot;</span>
<span class="k">for</span> <span class="nx">condicion</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Si la condicion se omite totalmente en cualquiera de estas formas, por ejemplo en</p>
<div class="highlight"><pre><span></span><span class="c1">// un tradicional bucle infinito</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>el bucle es infinito, aunque los bucles de esta forma se pueden terminar de alguna otra forma, como una declaracion <code>break</code> o <code>return</code>.</p>
<p>Otra forma en que el bucle <code>for</code> itera, es sobre un <em>rango</em> de valores de un tipo de datos como un string o un slice. Para ilustrar esto, he aqui una segunda version de <code class="command" >echo</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/echo2/main.go" >gopl.io/ch1/echo2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Echo2 imprime sus argumentos de linea de comandos</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">+=</span> <span class="nx">sep</span> <span class="o">+</span> <span class="nx">arg</span>
    <span class="nx">sep</span> <span class="p">=</span> <span class="s">&quot; &quot;</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En cada iteracion del bucle, <code>range</code> produce un par de valores: el indice y el valor del elemento en ese indice. En este ejemplo, no necesitamos el indice, pero la sintaxis de un bucle <code>range</code> requiere que si tratamos con el elemento, debemos tratar tambien con el indice. Una idea seria asignar el indice a una variable temporal, como <code>temp</code> y pasar por alto su valor, pero Go no permite tener variables locales sin utilizar, por lo que esto daria lugar a un error de compilacion.</p>
<p>La solucion es utilizar el <em>identificador en blanco</em>, cuyo nombre es <code>_</code> (esto es, un guion bajo). El identificador en blanco puede utilizarse siempre que la sintaxis requiera un nombre de variable, pero la logica del programa no lo haga, por ejemplo para descartar un indice no deseado del bucle cuando solo necesitamos el valor del elemento. La mayoria de los programadores Go probablemente usarian <code>range</code> y <code>_</code> para escribir el programa <code class="command" >echo</code> anterior, ya que la indexacion sobre <code>os.Args</code> es implicita, no explicita, y por lo tanto mas facil de hacerlo bien.</p>
<p>Esta version del programa utiliza una breve declaracion de variables para declarar e inicializar <code>s</code> y <code>sep</code>, pero podria igualmente haber declarado las variables por separado. Hay varias maneras de declarar una variable de cadena; Todas estas son equivalentes:</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
</pre></div>
<p>Por que usted deberia preferir una forma sobre otra? El primer formato, una declaracion de variable compacta, es el mas compacto, pero puede ser utilizado solo dentro de una funcion, no para variables de nivel de paquete. La segunda forma se basa en la inicializacion por defecto al valor cero para strings, que es <code>&quot;&quot;</code>. La tercera forma se utiliza raramente excepto cuando se declaran multiples variables. La cuarta forma es explicita sobre el tipo de la variable, que es redundante cuando es el mismo que el del valor inicial pero necesario en otros casos donde no son del mismo tipo. En la practica, generalmente debe utilizar una de las dos primeras formas, con inicializacion explicita para decir que el valor inicial es importante e implicita para decir que el valor inicial no importa.</p>
<p>Como se señalo anteriormente, cada iteracion alrededor del bucle, la cadena <code>s</code> obtiene contenidos completamente nuevos. La declaracion <code>+=</code> crea una nueva cadena mediante la concatenacion de la cadena antigua, un caracter de espacio, y el siguiente argumento, a continuacion, asigna la nueva cadena a <code>s</code>. El contenido antiguo del <code>s</code> ya no estan en uso, por lo que sera recolectado por el recolector de basura en su debido momento.</p>
<p>Si la cantidad de datos involucrados es grande, esto podria ser costoso. Una solucion mas simple y mas eficiente seria utilizar la funcion <code>Join</code> del paquete <code>strings</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/echo3/main.go" >gopl.io/ch1/echo3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Por ultimo, si no nos interesa el formato, y solo queremos ver los valores, tal vez para depuracion, podemos dejar que <code>Println</code> formatee el resultado por nosotros:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
<p>El resultado de esta sentencia es como la que se puede conseguir mediante <code>strings.Join</code>, pero con corchetes al rededor. Cualquier slice se puede imprimir de esta manera.</p>
<p><b>Ejercicio 1.1</b>: Modificar el programa <code class="command" >echo</code> para imprimir tambien <code>os.Args[0]</code>, el nombre del comando que lo invoco.</p>
<p><b>Ejercicio 1.2</b>: Modificar el programa <code class="command" >echo</code> para imprimir el indice y el valor de cada uno de sus argumentos, uno por linea.</p>
<p><b>Ejercicio 1.3</b>: Experimente para medir la diferencia en el tiempo de funcionamiento entre nuestras versiones potencialmente ineficientes y el que utiliza <code>strings.Join</code>. ( La <a href="#Seccion-1.6" >Seccion 1.6</a> ilustra parte del paquete <code>time</code>, y la <a href="#Seccion-11.4" >Seccion 11.4</a> muestra como escribir pruebas de referencia para la evaluacion sistematica del rendimiento.)</p>
</div>
<h3 id="Seccion-1.3" >Encontrar lineas duplicadas</h3>
<div class="hBody-3" >
<p>Los programas para copiar archivos, imprimir, buscar, clasificar, contar y similares tienen una estructura similar: un bucle sobre la entrada, algun calculo sobre cada elemento y generacion de salida al vuelo o al final. Mostraremos tres variantes de un programa llamado <code class="command" >dup</code>; se inspira en parte por el comando Unix <code class="command" >uniq</code>, que mira las lineas duplicadas adyacentes. Las estructuras y paquetes utilizados son modelos que se pueden adaptar facilmente.</p>
<p>La primer version de <code class="command" >dup</code> imprime cada linea que aparece mas de una vez en la entrada estandar, precedido por su recuento. Este programa presenta la declaracion <code>if</code>, el tipo de datos <code>map</code> y el paquete <code>bufio</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/dup1/main.go" >gopl.io/ch1/dup1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Dup1 imprime el texto de cada linea que aparece mas de</span>
<span class="c1">// una vez en la entrada estandar, precedida por su recuento.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;bufio&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="c1">// NOTA: ignorando posibles errores de input.Err ()</span>
  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%s\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Al igual que con <code>for</code>, nunca se usan parentesis alrededor de la declaracion de la condicion <code>if</code>, pero se requieren llaves para el cuerpo. Puede haber una parte <code>else</code> opcional que se ejecute si la condicion es falsa.</p>
<p>Un <em>mapa</em> contiene un conjunto de pares clave/valor y proporciona operaciones de tiempo constante para almacenar, recuperar, o comprobar un elemento en el conjunto. La clave puede ser de cualquier tipo cuyos valores puedan compararse con <code>==</code>, siendo strings el ejemplo mas comun; El valor puede ser de cualquier tipo en absoluto. En este ejemplo, las claves son <code>string</code>s, y los valores son <code>int</code>s. La funcion incorporada <code>make</code> crea un nuevo mapa vacio; Tiene otros usos tambien. Los mapas se discuten extensamente en la <a href="#Seccion-4.3" >Seccion 4.3</a>.</p>
<p>Cada vez que <code class="command" >dup</code> lee una linea de entrada, la linea se utiliza como una clave en el mapa y se incrementa el valor correspondiente. La declaracion <code>counts[input.Text()]++</code> es equivalente a estas dos afirmaciones:</p>
<div class="highlight"><pre><span></span><span class="nx">line</span> <span class="o">:=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
<span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="p">=</span> <span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
<p>No es un problema, si el mapa aun no contiene esa clave. La primera vez que se ve una nueva linea, la expresion <code>counts[line]</code> en el lado derecho se evalua al valor cero para su tipo, que es 0 para <code>int</code>.</p>
<p>Para imprimir los resultados, utilizamos otro bucle de repeticion <code>for</code> basado en <code>range</code>, esta vez sobre el mapa <code>counts</code>. Como antes, cada iteracion produce dos resultados, una clave y el valor del elemento del mapa para esa clave. El orden de la iteracion del mapa no es especifico, en la practica es aleatorio, variando de una ejecucion a otra. Este diseño es intencional, ya que impide que los programas se basen en cualquier orden particular donde no se garantiza ninguno.</p>
<p>El paquete <code>bufio</code>, ayuda a que la entrada y salida sea eficiente y conveniente. Una de sus caracteristicas mas utiles es un tipo llamado <code>Scanner</code> que lee la entrada y la rompe en lineas o palabras; A menudo es la manera mas facil de procesar la entrada que llega naturalmente en lineas.</p>
<p>El programa utiliza una breve declaracion de variables para crear una nueva variable de entrada que hace referencia a <code>bufio.Scanner</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
</pre></div>
<p>El escaner lee de la entrada estandar del programa. Cada llamada a <code>input.Scan()</code> lee la siguiente linea y elimina el caracter de nueva linea al final; el resultado puede ser recuperado llamando a <code>input.Text()</code>. La funcion <code>Scan</code> devuelve <code>true</code> si hay una linea y <code>false</code> cuando no hay mas entrada.</p>
<p>La funcion <code>fmt.Printf</code>, como <code>printf</code> en C y otros lenguajes, produce una salida con formato de una lista de expresiones. Su primer argumento es una cadena de formato que especifica como deben formatearse los argumentos posteriores. El formato de cada argumento esta determinado por un caracter de conversion, una letra siguiendo un signo de porcentaje. Por ejemplo, <code>%d</code> formatea un operando entero usando la notacion decimal, y <code>%s</code> se expande para el valor de un operando de cadena.</p>
<p><code>Printf</code> tiene mas de una docena de estas conversiones, que los programadores de Go llaman <em>verbos</em>. Esta tabla esta lejos de ser una especificacion completa, pero ilustra muchas de las caracteristicas que estan disponibles:</p>
<table>
<tbody>
<tr><td><code>%d</code></td><td>entero decimal</td></tr>
<tr><td><code>%x</code>, <code>%o</code>, <code>%b</code></td><td>entero en hexadecimal, octal, binario</td></tr>
<tr><td><code>%f</code>, <code>%g</code>, <code>%e</code></td><td>numero de coma flotante: 3.141593 3.141592653589793 3.141593e + 00</td></tr>
<tr><td><code>%t</code></td><td>booleano: <code>true</code> o <code>false</code></td></tr>
<tr><td><code>%c</code></td><td>runa (punto de codigo Unicode)</td></tr>
<tr><td><code>%s</code></td><td>string</td></tr>
<tr><td><code>%q</code></td><td>citar string <code>&quot;abc&quot;</code> o runa <code>'c'</code></td></tr>
<tr><td><code>%v</code></td><td>cualquier valor en un formato natural</td></tr>
<tr><td><code>%T</code></td><td>cualquier tipo de valor</td></tr>
<tr><td><code>%%</code></td><td>signo literal de porcentaje (sin operando)</td></tr>
</tbody>
</table>
<p>El formato de cadena en <code>dup1</code> tambien contiene una tabulacion <code>\t</code> y un salto de linea <code>\n</code>. Los literales de cadena pueden contener tales <em>secuencias de escape</em> para la representacion de caracteres de otra manera invisibles. <code>Printf</code> no escribe una nueva linea por defecto. Por convencion, las funciones de formato cuyos nombres terminan en <code>f</code>, tales como <code>log.Printf</code> y <code>fmt.Errorf</code>, utilizan las reglas de formato de <code>fmt.Printf</code>, mientras que aquellas cuyos nombres terminan en <code>ln</code> como <code>Println</code>, formatean sus argumentos con <code>%v</code>, seguido por una nueva linea.</p>
<p>Muchos programas leen ya sea a partir de su entrada estandar, como anteriormente, o de una secuencia de archivos con nombre. La proxima version de <code class="command" >dup</code> puede leer desde la entrada estandar o manejar una lista de nombres de archivos, utilizando <code>os.Open</code> para abrir cada uno de ellos:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/dup2/main.go" >gopl.io/ch1/dup2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Dup2 imprime el recuento y el texto de las lineas que aparecen mas de una vez</span>
<span class="c1">// en la entrada.  Se lee desde stdin o desde una lista de archivos con nombre.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;bufio&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="nx">files</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">countLines</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="nx">counts</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
      <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;dup2: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="nx">countLines</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">counts</span><span class="p">)</span>
      <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%s\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">countLines</span><span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">counts</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: Ignora errores potenciales de input.Err()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>os.Open</code> devuelve dos valores. El primero es un archivo abierto (<code>*os.File</code>) que se utiliza en lecturas posteriores por <code>Scanner</code>.</p>
<p>El segundo resultado de <code>os.Open</code> es un valor nativo de tipo <code>error</code>. Si <code>err</code> es igual al valor especial nativo <code>nil</code>, el archivo fue abierto correctamente. El archivo se lee, y cuando se llega al final de la entrada, <code>Close</code> cierra el archivo y libera cualquier recurso. Por otro lado, si <code>err</code> no es <code>nil</code>, algo salio mal. En ese caso, el valor de error describe el problema. Nuestro sencillo manejo de errores imprime un mensaje en el flujo de error estandar utilizando <code>Fprintf</code> y el verbo <code>%v</code>, que muestra un valor de cualquier tipo en un formato predeterminado, y luego <code>dup</code> continua con el siguiente archivo; la instruccion <code>continue</code> va a la siguiente iteracion del bucle <code>for</code>.</p>
<p>Con el fin de mantener los ejemplos de codigo de un tamaño razonable, nuestros primeros ejemplos son intencionalmente un tanto descuidados en el manejo de errores. Es evidente que hay que comprobar si hay un error de parte de <code>os.Open</code>; Sin embargo, estamos ignorando la menos probable posibilidad de que pueda producirse un error al leer el archivo con <code>input.Scan</code>. Anotaremos los lugares donde hemos omitido la comprobacion de errores, entraremos en detalles sobre el manejo de errores en la <a href="#Seccion-5.4" >Seccion 5.4</a>.</p>
<p>Observe que la llamada a <code>countLines</code> precede a su declaracion. Las funciones y otras entidades a nivel de paquete se pueden declarar en cualquier orden.</p>
<p>Un mapa es una referencia a la estructura de datos creada por <code>make</code>. Cuando un mapa se pasa a una funcion, la funcion recibe una copia de la referencia, De modo que cualquier cambio que haga la funcion llamada en la estructura de datos subyacente, sera tambien visible a traves de la referencia del mapa del llamador. En nuestro ejemplo, los valores insertados en el mapa <code>counts</code> por <code>countLines</code> son vistos por <code>main</code>.</p>
<p>Las versiones anteriores de <code class="command" >dup</code> operan en un modo <q>streaming</q> en el que la entrada se lee y divide en lineas segun sea necesario, por lo que, en principio, estos programas pueden manejar una cantidad arbitraria de entrada. Un enfoque alternativo es leer la entrada entera en la memoria de un solo trago, dividirlo en lineas a la vez, y luego procesar las lineas. La siguiente version, <code class="command" >dup3</code>, funciona de esa manera. Se introduce la funcion <code>ReadFile</code> (del paquete <code>io/ioutil</code>), que lee todo el contenido de un archivo, y <code>strings.Split</code>, que divide una cadena en un slice de subcadenas. (<code>Split</code> es lo contrario de <code>strings.Join</code>, que vimos anteriormente.)</p>
<p>Hemos simplificado un poco <code class="command" >dup3</code>. En primer lugar, solo lee archivos por su nombre, no la entrada estandar, ya que <code>ReadFile</code> requiere como argumento un nombre de archivo. En segundo lugar, se paso el conteo de las lineas de nuevo a <code>main</code>, ya que ahora solo es necesario un solo lugar.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/dup3/main.go" >gopl.io/ch1/dup3</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io/ioutil&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;dup3: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">line</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">counts</span><span class="p">[</span><span class="nx">line</span><span class="p">]</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%s\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code>ReadFile</code> devuelve un slice de <code>byte</code>s que se debe convertirse en un <code>string</code> para que pueda ser dividido por <code>strings.Split</code>. Vamos a discutir los strings y slices de bytes en detalle en la <a href="#Seccion-3.5.4" >Seccion 3.5.4</a>.</p>
<p>Bajo la cubierta, <code>bufio.Scanner</code>, <code>ioutil.ReadFile</code> y <code>ioutil.WriteFile</code> utilizan los metodos <code>Read</code> y <code>Write</code> de <code>*os.File</code>, pero es raro que la mayoria de los programadores necesiten acceder directamente a las rutinas de bajo nivel. Las funciones de nivel superior como <code>bufio</code> y <code>io/ioutil</code> son mas faciles de usar.</p>
<p><b>Ejercicio 1.4</b>: Modificar <code class="command" >dup2</code> para imprimir los nombres de todos los archivos en los que se produce cada linea duplicada.</p>
</div>
<h3 id="Seccion-1.4" >GIF animados</h3>
<div class="hBody-3" >
<p>El siguiente programa demuestra el uso basico de los paquetes de imagenes estandar en Go, que usaremos para crear una secuencia de imagenes de mapa de bits y luego codificar la secuencia como una animacion GIF. Las imagenes, llamadas <em>figuras de Lissajous</em>, eran un efecto visual basico en peliculas de ciencia ficcion de la decada de 1960. Son las curvas parametricas producidas por oscilacion armonica en dos dimensiones, tales como dos ondas sinusoidales alimentados en el entradas <span class="math" >x</span> e <span class="math" >y</span> de un osciloscopio. La Figura 1.1 muestra algunos ejemplos.</p>
<div class="figure" >
<p class="title">Figura 1.1. Cuatro figuras de Lissajous.</p>
<figure>
<img src="img/Figure-1.1.jpg" />
</figure>
<p>Hay varias nuevas construcciones en este codigo, incluyendo declaraciones const, tipos de estructura, y literales compuestos. A diferencia de la mayoria de nuestros ejemplos, este tambien implica calculos de punto flotante.  Aqui vamos a discutir estos temas solo brevemente, desplazando la mayoria de los detalles a los capitulos posteriores, ya que el objetivo principal en este momento es darle una idea de como se ve Go y el tipo de cosas que se pueden hacer facilmente con el lenguaje y sus librerias.</p>
</div>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/lissajous/main.go" >gopl.io/ch1/lissajous</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Lissajous genera GIF animados de figuras Lissajous aleatorias.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;image&quot;</span>
  <span class="s">&quot;image/color&quot;</span>
  <span class="s">&quot;image/gif&quot;</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;math&quot;</span>
  <span class="s">&quot;math/rand&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">palette</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">color</span><span class="p">.</span><span class="nx">Color</span><span class="p">{</span><span class="nx">color</span><span class="p">.</span><span class="nx">White</span><span class="p">,</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Black</span><span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">whiteIndex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// primer color en la paleta</span>
  <span class="nx">blackIndex</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// siguiente color en la paleta</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">lissajous</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">cycles</span>  <span class="p">=</span> <span class="mi">5</span>     <span class="c1">// numero de revoluciones completas del oscilador x</span>
    <span class="nx">res</span>     <span class="p">=</span> <span class="mf">0.001</span> <span class="c1">// resolucion angular</span>
    <span class="nx">size</span>    <span class="p">=</span> <span class="mi">100</span>   <span class="c1">// dimencion de la imagen [-size..+size]</span>
    <span class="nx">nframes</span> <span class="p">=</span> <span class="mi">64</span>    <span class="c1">// numero de cuadros de animacion</span>
    <span class="nx">delay</span>   <span class="p">=</span> <span class="mi">8</span>     <span class="c1">// retardo entre fotogramas en unidades de 10ms</span>
  <span class="p">)</span>
  <span class="nx">freq</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Float64</span><span class="p">()</span> <span class="o">*</span> <span class="mf">3.0</span> <span class="c1">// frecuencia relativa del oscilador y</span>
  <span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
  <span class="nx">phase</span> <span class="o">:=</span> <span class="mf">0.0</span> <span class="c1">// diferencia de fase</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nframes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">rect</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">img</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewPaletted</span><span class="p">(</span><span class="nx">rect</span><span class="p">,</span> <span class="nx">palette</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
      <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
      <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="nx">blackIndex</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">phase</span> <span class="o">+=</span> <span class="mf">0.1</span>
    <span class="nx">anim</span><span class="p">.</span><span class="nx">Delay</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">anim</span><span class="p">.</span><span class="nx">Delay</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span>
    <span class="nx">anim</span><span class="p">.</span><span class="nx">Image</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">anim</span><span class="p">.</span><span class="nx">Image</span><span class="p">,</span> <span class="nx">img</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">gif</span><span class="p">.</span><span class="nx">EncodeAll</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">anim</span><span class="p">)</span> <span class="c1">// NOTA: Ignorados errores de codificacion</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Despues de importar un paquete cuya ruta tiene multiples componentes, como <code>image/color</code>, nos referimos al paquete con el nombre que procede del ultimo componente. Por lo tanto la variable <code>color.White</code> pertenece al paquete <code>image/color</code> y <code>gif.GIF</code> pertenece a <code>image/gif</code>.</p>
<p>Una declaracion <code>const</code> (<a href="#Seccion-3.6" >§3.6</a>) da nombres a las constantes, es decir, valores que se establecen en tiempo de compilacion, tales como los parametros numericos para ciclos, cuadros, y el retardo. Igual a las declaraciones <code>var</code>, las declaraciones <code>const</code> pueden aparecer a nivel de paquete (por lo que los nombres son visibles en todo el paquete) o dentro de una funcion (por lo que los nombres son visibles solo dentro de esa funcion). El valor de una constante debe ser un numero, una cadena o un booleano.</p>
<p>Las expresiones <code>[]color.Color{...}</code> y <code>gif.GIF{...}</code> son <em>literales compuestos</em> (<a href="#Seccion-4.2" >§4.2</a>, <a href="#Seccion-4.4.1" >§4.4.1</a>), una notacion compacta de Go para instanciar cualquiera de los tipos compuestos de una secuencia de valores de los elementos. Aqui, la primera es un slice y la segunda es una <em>estructura</em>.</p>
<p>El tipo <code>gif.GIF</code> es de tipo struct (<a href="#Seccion-4.4" >§4.4</a>). Una estructura es un grupo de valores denominados <em>campos</em>, a menudo de diferentes tipos, que se recogen juntos en un unico objeto que puede tratarse como una unidad. La variable <code>anim</code> es una estructura de tipo <code>gif.GIF</code>. La estructura literal crea un valor estructura cuyo campo <code>LoopCount</code> se establece en <code>nframes</code>; Todos los demas campos tienen el valor cero para su tipo. Los campos individuales de una estructura se puede acceder usando la notacion punto, al igual que en las dos ultimas asignaciones que actualizan de forma explicita los campos <code>Delay</code> e <code>Image</code> de <code>anim</code>.</p>
<p>La funcion <code>lissajous</code> tiene dos bucles anidados. El bucle exterior se ejecuta 64 iteraciones, cada una produciendo un solo fotograma de la animacion. Crea una nueva imagen de 201x201 con una paleta de dos colores, blanco y negro. Todos los pixeles se ajustan inicialmente al valor cero de la paleta (el color cero de la paleta), que se establece en blanco. Cada paso a traves del bucle interno genera una nueva imagen estableciendo algunos pixeles en negro. El resultado se añade a una lista de cuadros en <code>anim</code> utilizando la funcion incorporada <code>append</code> (<a href="#Seccion-4.2.1" >§4.2.1</a>), junto con un retardo especificado de 80 ms. Por ultimo, la secuencia de cuadros y los retrasos se codifica en formato GIF y se escribe en la salida de fluje <code>out</code>. El tipo de <code>out</code> es <code>io.Writer</code>, lo que nos permite escribir a una amplia gama de posibles destinos, como vamos a mostrar pronto.</p>
<p>El bucle interior ejecuta los dos osciladores. El oscilador <code>x</code> es simplemente la funcion sinusoidal. El oscilador <code>y</code> es tambien una sinusoide, pero su frecuencia es relativa a la del oscilador <code>x</code> un numero aleatorio entre 0 y 3, y su fase relativa al oscilador <code>x</code> es inicialmente cero, pero aumenta con cada fotograma de la animacion. El bucle se ejecuta hasta que el oscilador <code>x</code> ha completado cinco ciclos completos. En cada paso, que llaman a <code>SetColorIndex</code> para colorear el pixel correspondiente en (<code>x</code>, <code>y</code>) negro, que es en la posicion 1 de la paleta.</p>
<p>La funcion <code>main</code> llama a la funcion <code>lissajous</code>, dirigiendola a escribir en la salida estandar, por lo que este comando produce un GIF animado con marcos como los de la Figura 1.1:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/lissajous
$ ./lissajous &gt;out.gif
</pre></div>
<p><b>Ejercicio 1.5</b>: Cambiar la paleta de colores del programa Lissajous a verde sobre negro, para mayor autenticidad. Para crear el color web <code>#RRGGBB</code>, utilice <code>color.RGBA{0xRR, 0xGG, 0xBB, 0xff}</code>, donde cada par de digitos hexadecimales representa la intensidad del componente de color rojo, verde o azul del pixel.</p>
<p><b>Ejercicio 1.6</b>: Modificar el programa Lissajous para producir imagenes de multiples colores mediante la adicion de mas valores a la paleta y luego mostrarlos cambiando el tercer argumento de <code>SetColorIndex</code> de alguna manera interesante.</p>
</div>
<h3 id="Seccion-1.5" >Obtener una URL</h3>
<div class="hBody-3" >
<p>Para muchas aplicaciones, el acceso a la informacion de Internet es tan importante como el acceso al sistema de archivos local. Go ofrece una coleccion de paquetes, agrupados bajo <code>net</code>, que hacen que sea facil de enviar y recibir informacion a traves de Internet, realizar conexiones de red de bajo nivel, y configurar servidores, por lo que las caracteristicas de concurrencia de Go (introducidas en el <a href="#Capitulo-8" >Capitulo 8</a>) son particularmente utiles.</p>
<p>Para ilustrar el minimo necesario para recuperar la informacion a traves de HTTP, aqui esta un programa simple llamado <code class="command" >fetch</code> que recupera el contenido de cada URL y lo imprime como texto sin interpretar; esta inspirado en la invaluable utilidad <code class="command" >curl</code> . Obviamente uno normalmente haria mas con tales datos, pero esto muestra la idea basica. Usaremos este programa con frecuencia en el libro.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/fetch/main.go" >gopl.io/ch1/fetch</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Fetch imprime el contenido encontrado en cada URL especificada.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io/ioutil&quot;</span>
  <span class="s">&quot;net/http&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;fetch: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;fetch: reading %s: %v\n&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Este programa introduce funciones a partir de dos paquetes, <code>net/http</code> y <code>io/ioutil</code>. La funcion <code>http.Get</code> realiza una peticion HTTP y, si no hay error, devuelve el resultado en la estructura <code>resp</code> . El campo <code>Body</code> de <code>resp</code> contiene la respuesta del servidor como un flujo legible. A continuacion, <code>ioutil.ReadAll</code> lee toda la respuesta; el resultado se almacena en <code>b</code>. El flujo <code>Body</code> es cerrado para evitar fuga de recursos y <code>Printf</code> escribe la respuesta a la salida estandar.</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ ./fetch http://gopl.io
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Go Programming Language&lt;/title&gt;
...
</pre></div>
<p>Si la solicitud HTTP falla, en su lugar, <code class="command" >fetch</code> reportara el error:</p>
<div class="highlight"><pre><span></span>$ ./fetch http://bad.gopl.io
fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
</pre></div>
<p>En cualquiera de los casos de error, <code>os.Exit(1)</code> hace que el proceso termine con un codigo de estado de valor 1.</p>
<p><b>Ejercicio 1.7</b>: La funcion <code>io.Copy(dst, src)</code> lee desde <code>src</code> y escribe en <code>dst</code>. Utilicelo en lugar de <code>ioutil.ReadAll</code> para copiar el cuerpo de la respuesta a <code>os.Stdout</code> sin requerir un buffer lo suficientemente grande como para contener todo el fluje de datos. Asegurese de comprobar el resultado del error de <code>io.Copy</code>.</p>
<p><b>Ejercicio 1.8</b>: Modificar <code class="command" >fetch</code> para agregar el prefijo <code>http://</code> a cada argumento URL si este so se proporciona. Es posible que desee utilizar <code>strings.HasPrefix</code>.</p>
<p><b>Ejercicio 1.9</b>: Modificar <code class="command" >fetch</code> para imprimir tambien el codigo de estado HTTP, que se encuentra en <code>resp.Status</code>.</p>
</div>
<h3 id="Seccion-1.6" >Obteniendo URL Concurrentemente</h3>
<div class="hBody-3" >
<p>Uno de los aspectos mas interesantes y novedosos de Go es su soporte para la programacion concurrente. Este es un tema muy amplio, al que se dedican el <a href="#Capitulo-8" >Capitulo 8</a> y el <a href="#Capitulo-9" >Capitulo 9</a>, asi que por ahora le daremos solo una muestra de los principales mecanismos de la concurrencia en Go, <em>gorutinas</em> y <em>canales</em>.</p>
<p>El siguiente programa, <code class="command" >fetchall</code>, realiza la misma busqueda del contenido de una URL como en el ejemplo anterior, pero obtiene muchas URL, todas al mismo tiempo, de modo que el proceso no tardara mas que la busqueda mas prolongada en lugar de la suma de todos los tiempos de busqueda. Esta version de <code class="command" >fetchall</code> descarta las respuestas, pero indica el tamaño y el tiempo transcurrido de cada una:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/fetchall/main.go" >gopl.io/ch1/fetchall</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Fetchall busca URLs en paralelo e informa de sus tiempos y tamaños.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;io/ioutil&quot;</span>
  <span class="s">&quot;net/http&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span> <span class="c1">// inicia una gorutina</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// recibir desde el canal ch</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%.2fs elapsed\n&quot;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nx">Seconds</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// enviar al canal ch</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// no pierdas recursos</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;while reading %s: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">secs</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nx">Seconds</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fs  %7d  %s&quot;</span><span class="p">,</span> <span class="nx">secs</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>He aqui un ejemplo:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetchall
$ ./fetchall https://golang.org http://gopl.io https://godoc.org
<span class="m">0</span>.14s     <span class="m">6852</span> https://godoc.org
<span class="m">0</span>.16s     <span class="m">7261</span> https://golang.org
<span class="m">0</span>.48s     <span class="m">2475</span> http://gopl.io
<span class="m">0</span>.48s elapsed
</pre></div>
<p>Una <em>gorutina</em> es una funcion de ejecucion concurrente. Un <em>canal</em> es un mecanismo de comunicacion que permite a una <em>gorutina</em> para pasar valores de un tipo especificado a otra <em>gorutina</em>. La funcion <em>main</em> se ejecuta en una gorutina y la sentencia <code>go</code> crea gorutinas adicionales.</p>
<p>La funcion <code>main</code> crea un canal de strings utilizando <code>make</code> . Para cada argumento de linea de comandos, la sentencia <code>go</code> en el primer bucle inicia una nueva gorutina que llama a <code>fetch</code> asincronamente para buscar la URL usando <code>http.Get</code>. La funcion <code>io.Copy</code> lee el cuerpo de la respuesta y la descarta escribiendo en el flujo de salida <code>ioutil.Discard</code>. <code>Copy</code> devuelve el numero de bytes, junto con cualquier error que prodicido. A medida que llega cada resultado, <code>fetch</code> envia una linea de resumen en el canal <code>ch</code>. El segundo bucle en <code>main</code> recibe e imprime esas lineas.</p>
<p>Cuando una gorutina intenta enviar o recibir en un canal, se bloquea hasta que otra gorutina intente la operacion correspondiente de recepcion o envio, momento en el cual se transfiere el valor y ambas gorutinas continuan. En este ejemplo, cada <code>fetch</code> envia un valor (<em>expresion</em> <code>ch &lt;-</code>) en el canal <code>ch</code>, y <code>main</code> recibe todos ellos (<code>&lt;-ch</code>). Tener a <code>main</code> haciendo toda la impresion, asegura que la salida de cada gorutina se procesa como una unidad, sin el peligro de entrelazado si dos gorutinas terminan al mismo tiempo.</p>
<p><b>Ejercicio 1.10</b>: Encontrar un sitio web que produce una gran cantidad de datos. Investiga el almacenamiento en cache mediante la ejecucion de <code class="command" >fetchall</code> dos veces consecutivas para ver si el tiempo reportado cambia mucho. ¿Obtienes el mismo contenido cada vez? Modificar <code class="command" >fetchall</code> para imprimir su salida a un archivo para que pueda ser examinado.</p>
<p><b>Ejercicio 1.11</b>: Pruebe <code class="command" >fetchall</code> con listas de argumentos mas extensas, como muestras de los mejores sitios web disponibles en <a href="http://www.alexa.com/" >alexa.com</a>. ¿Como se comporta el programa si un sitio web simplemente no responde? (La <a href="#Seccion-8.9" >Seccion 8.9</a> describe los mecanismos para hacer frente en estos casos.)</p>
</div>
<h3 id="Seccion-1.7" >Un servidor Web</h3>
<div class="hBody-3" >
<p>Las Librerias de Go hacen que sea facil escribir un servidor web que responde a las solicitudes de los clientes, como las realizadas por <code class="command" >fetch</code>. En esta seccion, mostraremos un servidor minimo que devuelve el componente de ruta de la URL utilizada para acceder al servidor. Es decir, si la solicitud es <code>http://localhost:8000/hello</code>, la respuesta sera <code>URL.Path = &quot;/hello&quot;</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/server1/main.go" >gopl.io/ch1/server1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Server1 es un servidor de &quot;eco&quot; minimo.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;net/http&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="c1">// cada solicitud llama a handler</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// handler hace eco del componente Path de la URL solicitida.</span>
<span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;URL.Path = %q\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El programa esta formado por solo un puñado de lineas, porque las funciones de la libreria hacen la mayor parte del trabajo. La funcion <code>main</code> conecta una funcion de manejo a las direcciones URL entrantes que comienzan con <code>/</code>, que son todas las direcciones URL, e inicia un servidor que escucha las peticiones entrantes en el puerto 8000. La solicitud se representa como una estructura de tipo <code>http.Request</code>, que contiene una serie de campos relacionados, uno de los cuales es la URL de la solicitud entrante. Cuando llega una peticion, se le da a la funcion de manejo, que extrae el componente de ruta (<code>/hello</code>) a partir de la URL de solicitud y la envia de vuelta como la respuesta, utilizando <code>fmt.Fprintf</code>. Los servidores web se explicaran en detalle en la <a href="#Seccion-7.7" >Seccion 7.7</a>.</p>
<p>Iniciemos el servidor en segundo plano. En Mac OS X o GNU/Linux, añadir un simbolo ampersand (<code>&amp;</code>) al comando; En Microsoft Windows, necesitara ejecutar el comando sin el signo ampersand en una ventana de comandos distinta.</p>
<div class="highlight"><pre><span></span>$ go run src/gopl.io/ch1/server1/main.go <span class="p">&amp;</span>
</pre></div>
<p>A continuacion, podemos hacer solicitudes desde la linea de comandos:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ ./fetch http://localhost:8000
URL.Path <span class="o">=</span> <span class="s2">&quot;/&quot;</span>
$ ./fetch http://localhost:8000/help
URL.Path <span class="o">=</span> <span class="s2">&quot;/help&quot;</span>
</pre></div>
<p>Como alternativa, podemos acceder al servidor desde un navegador web, como se muestra en la Figura 1.2.</p>
<div class="figure" >
<p class="title">Figura 1.2. Una respuesta del servidor de eco.</p>
<figure>
<img src="img/Figure-1.2.jpg" />
</figure>
</div>
<p>Es facil agregar funciones al servidor. Una adicion util es una URL especifica que devuelve un estado de algun tipo. Por ejemplo, esta version hace eco, pero tambien cuenta el numero de peticiones; una peticion a la URL <code>/count</code> devuelve el recuento hasta el momento, excluyendo la solicitud <code>/count</code> a si misma:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/server2/main.go" >gopl.io/ch1/server2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Server2 es un servidor de eco y conteo minimo</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;net/http&quot;</span>
  <span class="s">&quot;sync&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/count&quot;</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// handler hace eco del componente Path de la URL solicitida.</span>
<span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">count</span><span class="o">++</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;URL.Path = %q\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// counter hace eco del numero de lamadas hasta ahora.</span>
<span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Count %d\n&quot;</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El servidor tiene dos manejadores, y la URL de la solicitud determina cual se llama: una solicitud por <code>/count</code> invoca a <code>counter</code> y todas los demas invocan a <code>handler</code>. Un patron de manejo que termina con una barra diagonal coincide con cualquier URL que tenga el patron como prefijo. Detras de escena, el servidor ejecuta el controlador para cada solicitud entrante en una gorutina separada para que pueda servir multiples solicitudes simultaneamente. Sin embargo, si dos solicitudes simultaneas intentan actualizar <code>count</code> al mismo tiempo, es posible que no se incremente consistentemente; El programa tendria un error grave llamado <em>condicion de carrera</em> (<a href="#Seccion-9.1" >§9.1</a>). Para evitar este problema, debemos asegurarnos de que a lo sumo solo una gorutina accede a la variable a la vez, que es el proposito de las llamadas a <code>mu.Lock()</code> y <code>mu.Unlock()</code> que rodean el acceso a <code>count</code>. Examinaremos mas de cerca a la concurrencia con variables compartidas en el <a href="#Capitulo-9" >Capitulo 9</a>.</p>
<p>Como un ejemplo mas rico, la funcion de manejo puede informar sobre los encabezados y datos de formulario que recibe, haciendo que el servidor sea util para inspeccionar y depurar peticiones:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch1/server3/main.go" >gopl.io/ch1/server3</a></p>
<div class="highlight"><pre><span></span><span class="c1">// handler responde a la peticion HTTP.</span>
<span class="kd">func</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s %s %s\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Proto</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Header</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Header[%q] = %q\n&quot;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Host = %q\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;RemoteAddr = %q\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Form</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Form[%q] = %q\n&quot;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Este utiliza los campos de la estructura <code>http.Request</code> para producir una salida como esta:</p>
<pre class="pre" >GET /?q=query HTTP/1.1
Header[&quot;Accept-Encoding&quot;] = [&quot;gzip, deflate, sdch&quot;]
Header[&quot;Accept-Language&quot;] = [&quot;en-US,en;q=0.8&quot;]
Header[&quot;Connection&quot;] = [&quot;keep-alive&quot;]
Header[&quot;Accept&quot;] = [&quot;text/html,application/xhtml+xml,application/xml;...&quot;]
Header[&quot;User-Agent&quot;] = [&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)...&quot;]
Host = &quot;localhost:8000&quot;
RemoteAddr = &quot;127.0.0.1:59911&quot;
Form[&quot;q&quot;] = [&quot;query&quot;]</pre>
<p>Observe como la llamada a <code>ParseForm</code> esta anidada dentro de una sentencia <code>if</code>. Go permite una declaracion simple, como una declaracion de variable local para preceder la sentencia <code>if</code>, lo que es particularmente util para el tratamiento de errores como en este ejemplo. Podriamos haberlo escrito como</p>
<div class="highlight"><pre><span></span><span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>la combinacion de las sentencias es mas corta y reduce el alcance de la variable <code>err</code>, que es una buena practica. Vamos a definir el alcance en la <a href="#Seccion-2.7" >Seccion 2.7</a>.</p>
<p>En estos programas, hemos visto tres tipos muy diferentes utilizados como flujos de salida. El programa <code class="command" >fetch</code> copia datos de la respuesta HTTP a <code>os.Stdout</code>, a un archivo, al igual que el programa <code class="command" >lissajous</code>. El programa <code class="command" >fetchall</code> arroja la respuesta copiando el flujo (mientras cuenta su longitud) de forma trivial en <code>ioutil.Discard</code>. Y el anterior servidor web utiliza <code>fmt.Fprintf</code> para escribir una representacion del navegador <code>http.ResponseWriter</code>.</p>
<p>Aunque estos tres tipos difieren en los detalles de lo que hacen, todos ellos satisfacen una interfaz comun, permitiendo que cualquiera pueda ser utilizado cuando sea necesario crear un flujo de salida. Esa interfaz, llamada <code>io.Writer</code>, se discute en la <a href="#Seccion-7.1" >Seccion 7.1</a>.</p>
<p>El mecanismo de interfaz de Go es el tema del <a href="#Capitulo-7" >Capitulo 7</a>, pero para dar una idea de lo que es capaz de hacer, vamos a ver lo facil que es combinar el servidor web con la funcion <code>lissajous</code> para que los archivos GIF animados se escriben no en la salida estandar, en su lugar en el cliente HTTP. Simplemente agregue estas lineas al servidor web:</p>
<div class="highlight"><pre><span></span><span class="nx">handler</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
</pre></div>
<p>o su equivalente:</p>
<div class="highlight"><pre><span></span><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lissajous</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
<p>El segundo argumento de la funcion <code>HandleFunc</code> se conoce como una e(funcion literal), es decir, una funcion anonima definida en su punto de uso. Vamos a explicar mas a fondo en la <a href="#Seccion-5.6" >Seccion 5.6</a>.</p>
<p>Una vez que haya realizado este cambio, visite <a href="http://localhost:8000" >http://localhost:8000</a> en su navegador. Cada vez que cargue la pagina, vera una nueva animacion como la de la Figura 1.3.</p>
<p><b>Ejercicio 1.12</b>: Modificar el servidor de Lissajous para leer valores de los parametros de la URL. Por ejemplo, es posible disponer de forma que una URL como <code>http://localhost:8000/?cycles=20</code> establece el numero de ciclos a 20 en lugar del predeterminado 5. Utilice la funcion <code>strconv.Atoi</code> para convertir el parametro de string a un entero. Puede ver su mediante con <code class="command" >go doc strconv.Atoi</code>.</p>
<div class="figure" >
<p class="title">Figura 1.3. Figuras animadas de Lissajous en un navegador.</p>
<figure>
<img src="img/Figure-1.3.jpg" />
</figure>
</div>
</div>
<h3 id="Seccion-1.8" >Cabos sueltos</h3>
<div class="hBody-3" >
<p>Hay mucho mas de Go de lo que hemos cubierto en esta introduccion rapida. Aqui hay algunos temas que apenas hemos tocado o omitido por completo, con tratamiento suficiente para empezar a familiarizarse con ellos antes de un tratamiento completo.</p>
<dl>
<dt>Control flow</dt>
<dd>
<p>Cubrimos los dos estados de flujos de control fundamentales, <code>if</code> y <code>for</code>, pero no la sentencia <code>switch</code>, que es una via de multiples ramas. Aqui hay un pequeño ejemplo:</p>
<div class="highlight"><pre><span></span><span class="k">switch</span> <span class="nx">coinflip</span><span class="p">()</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&quot;heads&quot;</span><span class="p">:</span>
  <span class="nx">heads</span><span class="o">++</span>
<span class="k">case</span> <span class="s">&quot;tails&quot;</span><span class="p">:</span>
  <span class="nx">tails</span><span class="o">++</span>
<span class="k">default</span><span class="p">:</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;landed on edge!&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>El resultado de llamar a <code>coinflip</code> se compara con el valor de cada caso. Los casos se evaluan de arriba a abajo, por lo que se ejecuta la primera coincidencia. El caso opcional <code>default</code> coincide si ninguno de los otros casos lo hace; Puede colocarse en cualquier lugar. Los casos no caigan uno sobre otro, como en lenguajes tipo C (aunque hay una poco utilizada declaracion <code>fallthrough</code> que anula este comportamiento).</p>
<p>Un <code>switch</code> no necesita un operando; Solo puede enumerar los casos, cada uno de los cuales es una expresion booleana:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Signum</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">+</span><span class="mi">1</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Esta forma se llama <em>switch sin etiquetas</em>; que es equivalente a <code>switch true</code>.</p>
<p>Al igual que las sentencias <code>for</code> e <code>if</code>, un <code>switch</code> puede incluir una declaracion, una unica declaracion de variables compacta opcional, una declaracion de incremento o asignacion, o una funcion de llamada que se puede utilizar para establecer un valor antes de ser puesto a prueba.</p>
<p>Las declaraciones <code>break</code> y <code>continue</code> modifican el flujo de control. Un <code>break</code> proboca control se reanude la siguiente sentencia despues de la secuenca <code>for</code>, <code>switch</code>, o <code>select</code> (que veremos mas adelante) mas anidada, y como hemos visto en la <a href="#Seccion-1.3" >Seccion 1.3</a>, un <code>continue</code> proboca que el bucle <code>for</code> mas interno inicie su proxima iteracion. Las declaraciones pueden etiquetarse de forma que un <code>break</code> y <code>continue</code> pueden referirse a ellos, por ejemplo, para salir de varios bucles anidados a la vez o para iniciar la siguiente iteracion del bucle mas externo. Hay incluso una sentencia <code>goto</code>, aunque esta destinada para el codigo generado por la maquina, sin el uso regular por los programadores.</p>
</dd>
<dt>Tipos con nombre</dt>
<dd>
<p>Una declaracion <code>type</code> hace que sea posible dar un nombre a un tipo existente. Puesto que los tipos de la estructura son a menudo largos, se nombran casi siempre. Un ejemplo conocido es la definicion de un tipo para un sistema de graficos 2-D <code>Point</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</pre></div>
<p>Las declaracion de tipos y tipos con nombre se trata en el <a href="#Capitulo-2" >Capitulo 2</a>.</p>
</dd>
<dt>Punteros</dt>
<dd>
<p>Go proporciona punteros, es decir, los valores que contienen la direccion de una variable. En algunos lenguajes, notablemente C, los punteros son relativamente sin restricciones. En otros lenguajes, los punteros son disfrazados como <q>referencias</q>, y no hay mucho que se pueda hacer con ellos, excepto pasar a su alrededor. Go toma una posicion en algun lugar en el medio. Los punteros son explicitamente visibles. operador <code>&amp;</code> obtiene la direccion de una variable, y el operador <code>*</code> recupera la variable a la que se refiere el puntero, pero no hay aritmetica de punteros. Vamos a explicar los punteros en la <a href="#Seccion-2.3.2" >Seccion 2.3.2</a>.</p>
</dd>
<dt>Metodos e interfaces</dt>
<dd>
<p>Un metodo es una funcion asociada con un tipo de dato; Go es inusual en el echo que los metodos se pueden vincular a casi cualquier tipo nombrado. Los Metodos son cubiertos en el <a href="#Capitulo-6" >Capitulo 6</a>. Las interfaces son tipos abstractos que nos permiten manejar tipos concretos diferentes de la misma manera basados ​​en que metodos tienen, no como se representan o implementan. Las interfaces son el tema del <a href="#Capitulo-7" >Capitulo 7</a>.</p>
</dd>
<dt>Paquetes</dt>
<dd>
<p>Go llega con una extensa libreria de paquetes utiles estandar, y la comunidad Go ha creado y compartido muchas mas. La programacion es a menudo mas sobre el uso de paquetes existentes que sobre la escritura de codigo propio original. A lo largo del libro, vamos a señalar un par de docenas de los paquetes estandar mas importantes, pero hay muchos mas que no tenemos espacio para mencionar, y no podemos proporcionar nada remotamente cercana a una referencia completa para cualquier paquete.</p>
<p>Antes de embarcarse en cualquier programa nuevo, es una buena idea ver si ya existen paquetes que podrian ayudarle a hacer su trabajo mas facilmente. Puede encontrar un indice de los paquetes de librerias estandar en <a href="https://golang.org/pkg" >https://golang.org/pkg</a> y los paquetes aportados por la comunidad en <a href="https://godoc.org" >https://godoc.org</a>. La herramienta <code class="command" >go doc</code> hace que estos documentos sean facilmente accesibles desde la linea de comandos:</p>
<div class="highlight"><pre><span></span>$ go doc http.ListenAndServe
package http // import <span class="s2">&quot;net/http&quot;</span>

func ListenAndServe<span class="o">(</span>addr string, handler Handler<span class="o">)</span> error
    ListenAndServe listens on the TCP network address addr and <span class="k">then</span>
    calls Serve with handler to handle requests on incoming connections.
...
</pre></div>
</dd>
<dt>Comentarios</dt>
<dd>
<p>Ya hemos mencionado los comentarios de documentacion al inicio de un programa o paquete. Tambien es un buen estilo escribir un comentario antes de la declaracion de cada funcion para especificar su comportamiento. Estas convenciones son importantes, ya que se utilizan por herramientas como <code class="command" >go doc</code> y <code class="command" >godoc</code> para localizar y monstrar la documentacion en pantalla (<a href="#Seccion-10.7.4" >§10.7.4</a>).</p>
<p>Para los comentarios que abarcan varias lineas o aparecen dentro de una expresion o declaracion, tambien existe la conocida notacion <code>/* ... */</code> de otros lenguajes. Este tipo de comentarios se utilizan a veces al principio de un archivo en un gran bloque de texto explicativo para evitar un <code>//</code> en cada linea. Dentro de un comentario, <code>//</code> y <code>/*</code> no tienen ningun significado especial, por que los comentarios no se anidan.</p>
</dd>
</dl>
</div>
<h2 id="Capitulo-2" >Estructura del programa</h2>
<div class="hBody-2" >
<p>En Go, como en cualquier otro lenguaje de programacion, se construyen grandes programas a partir de un pequeño conjunto de construcciones basicas. Las variables almacenan los valores. Las expresiones simples se combinan en las mas grandes con operaciones como suma y resta. Los tipos basicos se reunen en agregados como matrices y estructuras. Las expresiones se utilizan en declaraciones cuyo orden de ejecucion es determinado por instrucciones de control de flujo como <code>if</code> y <code>for</code>. Las declaraciones se agrupan en funciones por aislamiento y reutilizacion. Las funciones se agrupan en archivos de codigo fuente y paquetes.</p>
<p>Vimos ejemplos de la mayoria de estos en el capitulo anterior. En este capitulo, vamos a entrar en mas detalles sobre los elementos estructurales basicos de un programa Go. Los programas de ejemplo son intencionalmente simples, por lo que podemos centrarnos en el lenguaje sin desviarnos de complicados algoritmos o estructuras de datos.</p>
</div>
<h3 id="Seccion-2.1" >Nombres</h3>
<div class="hBody-3" >
<p>Los nombres de las funciones Go, variables, constantes, tipos, etiquetas de instrucciones y paquetes siguen una regla simple: un nombre comienza con una letra (es decir, cualquier cosa que Unicode considera una letra) o un guion bajo y puede tener cualquier numero de letras adicionales, Digitos y giones bajos. Las mayusculas importan: <code>heapSort</code> y <code>Heapsort</code> son nombres diferentes.</p>
<p>Go tiene 25 <em>palabras claves</em> como <code>if</code> y <code>switch</code> que solo puede utilizarse cuando la sintaxis lo permita; No pueden usarse como nombres.</p>
<pre class="pre" >break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var</pre>
<p>Ademas, hay cerca de tres docenas de nombres <em>predeclarados</em> como <code>int</code> y <code>true</code> para las constantes, tipos y funciones incorporadas:</p>
<dl>
<dt>Constantes</dt>
<dd>
<pre class="pre" >true false iota nil

</pre>
</dd>
<dt>Tipos</dt>
<dd>
<pre class="pre" >int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error

</pre>
</dd>
<dt>Functions</dt>
<dd>
<pre class="pre" >make len cap new append copy close delete
complex real imag
panic recover


</pre>
</dd>
</dl>
<p>Estos nombres no estan reservados, por lo que puede utilizarlos en declaraciones. Vamos a ver un puñado de lugares donde redeclarar uno de ellos tiene sentido, pero tenga cuidado con la potencial confusion.</p>
<p>Si una entidad se declara dentro de una funcion, esta es <em>local</em> a esa funcion. Si se declara fuera de una funcion, sin embargo, es visible en todos los archivos del paquete al que pertenece. La primer letra de un nombre determina su visibilidad a traves de los limites del paquete. Si el nombre comienza con una letra mayuscula, se exporta, lo que significa que es visible y accesible fuera de su propio paquete y puede hacer referencia a otras partes del programa, al igual que con <code>Printf</code> en el paquete <code>fmt</code>. Los nombres de los paquetes estan siempre en minusculas.</p>
<p>No hay limite en la longitud del nombre, pero la convencion y el estilo en los programas de Go se inclinan hacia nombres cortos, especialmente para variables locales con ambitos pequeños; es mucho mas probable ver variables con nombre <code>i</code> que <code>indiceDelBucle</code>. Generalmente, cuanto mayor es el alcance de un nombre, mas largo y mas significativo debe ser.</p>
<p>Estilisticamente, los programadores Go utilizan la <q>notacion camello</q> cuando se forma nombres mediante la combinacion de palabras; Es decir, las letras mayusculas internas se prefieren sobre los subrayados interiores. Por lo tanto las librerias estandar tienen funciones con nombres como <code>QuoteRuneToASCII</code> y <code>parseRequestLine</code> pero nunca <code>quote_rune_to_ASCII</code> o <code>parse_request_line</code>. Las letras de acronimos y siglas como <span class="acronym" >ASCII</span> y <span class="acronym" >HTML</span> siempre se prestan en el mismo tipo, por lo que una funcion sera llamada <code>htmlEscape</code>, <code>HTMLEscape</code> o <code>escapeHTML</code>, pero no <code>escapeHtml</code>.</p>
</div>
<h3 id="Seccion-2.2" >Declaraciones</h3>
<div class="hBody-3" >
<p>Una <em>declaracion</em> nombra una entidad del programa y especifica todas o algunas de sus propiedades. Hay cuatro tipos principales de declaraciones: <code>var</code>, <code>const</code>, <code>type</code> y <code>func</code>. Hablaremos sobre variables y tipos en este capitulo, constantes en el <a href="#Capitulo-3" >Capitulo 3</a>, y funciones en el <a href="#Capitulo-5" >Capitulo 5</a>.</p>
<p>Un programa Go se almacena en uno o mas archivos cuyos nombres terminan en <span class="file" >.go</span>. Cada archivo comienza con una declaracion <code>package</code> que indica de que paquete forma parte el archivo. La declaracion <code>package</code> es seguido por cualquier declaraciones <code>import</code>, y luego una secuencia de declaraciones a nivel de paquete de tipos, variables, constantes y funciones, en cualquier orden. Por ejemplo, este programa declara una constante, una funcion y un par de variables:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/boiling/main.go" >gopl.io/ch2/boiling</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Boiling imprime el punto de ebullicion del agua.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">const</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">212.0</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">boilingF</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;boiling point = %g°F or %g°C\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="c1">// Salida:</span>
  <span class="c1">// boiling point = 212°F or 100°C</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La constante <code>boilingF</code> es una declaracion de nivel de paquete (como es <code>main</code>), mientras que las variables <code>f</code> y <code>c</code> son locales a la funcion <code>main</code>. El nombre de cada entidad de nivel de paquete es visible no solo en todo el archivo de origen que contiene su declaracion, sino en todos los archivos del paquete. Por el contrario, las declaraciones locales son visibles solo dentro de la funcion en la que se declaran y tal vez solo dentro de una pequeña parte de ella.</p>
<p>Una declaracion de funcion tiene un nombre, una lista de parametros (las variables cuyos valores se proporcionan por quien llama a la funcion), una lista opcional de resultados y el cuerpo de la funcion, que contiene las sentencias que definen lo que hace la funcion. La lista de resultados se omite si la funcion no devuelve nada. La ejecucion de la funcion comienza con la primer instruccion y continua hasta que encuentra una instruccion de retorno o llega al final de una funcion que no tiene resultados. El control y los resultados se devuelven a quien hiso la llamada.</p>
<p>Hemos visto un buen numero de funciones ya y hay muchas mas por venir, incluyendo una extenso tratamiento en el <a href="#Capitulo-5" >Capitulo 5</a>, asi que esto es solo un esbozo. La funcion <code>fToC</code> a continuacion, encapsula la logica de conversion de temperatura de manera que se define solo una vez, pero puede utilizarse desde multiples lugares. Aqui <code>main</code> llama dos veces, utilizando los valores de las constantes de dos locales diferentes:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/ftoc/main.go" >gopl.io/ch2/ftoc</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Ftoc imprime dos conversiones de Fahrenheit a Celsius.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">freezingF</span><span class="p">,</span> <span class="nx">boilingF</span> <span class="p">=</span> <span class="mf">32.0</span><span class="p">,</span> <span class="mf">212.0</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g°F = %g°C\n&quot;</span><span class="p">,</span> <span class="nx">freezingF</span><span class="p">,</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">freezingF</span><span class="p">))</span> <span class="c1">// &quot;32°F = 0°C&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g°F = %g°C\n&quot;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="p">,</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">boilingF</span><span class="p">))</span>   <span class="c1">// &quot;212°F = 100°C&quot;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fToC</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<h3 id="Seccion-2.3" >Variables</h3>
<div class="hBody-3" >
<p>Un declaracion <code>var</code> crea una variable de un tipo particular, vinculando un nombre a la misma, y se define su valor inicial. Cada declaracion tiene la forma general</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">nombre</span> <span class="nx">tipo</span> <span class="p">=</span> <span class="nx">expresion</span>
</pre></div>
<p>O bien el tipo o la parte <code>= expresion</code> pueden omitirse, pero no ambos. Si se omite el tipo, se determina mediante la expresion del inicializador. Si se omite la expresion, el valor inicial es el <em>valor cero</em> para el tipo, que es 0 para los numeros, <code>false</code> para booleanos, <code>&quot;&quot;</code> para string, y <code>nil</code> para interfaces y tipos de referencia (slices, punteros, mapa, canal, funcion). El valor cero de un tipo agregado como una matriz o una estructura tiene el valor cero de todos sus elementos o campos.</p>
<p>El mecanismo de valor cero asegura que una variable siempre tenga un valor bien definido de su tipo; En Go no hay tal cosa como una variable no inicializada. Esto simplifica el codigo y, a menudo, asegura un comportamiento sensible de las condiciones limite sin trabajo adicional. Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;&quot;</span>
</pre></div>
<p>Imprime una cadena vacia, en lugar de causar algun tipo de error o comportamiento impredecible. Los programadores Go, suelen hacer algun esfuerzo por hacer el valor cero de un tipo mas complicado significativo, por lo que las variables comienzan su vida en un estado util.</p>
<p>Es posible declarar y opcionalmente inicializar un conjunto de variables en una sola declaracion, con una lista de expresiones correspondiente. Omitir el tipo permite la declaracion de multiples variables de diferentes tipos:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span>                 <span class="c1">// int, int, int</span>
<span class="kd">var</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">s</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="s">&quot;four&quot;</span> <span class="c1">// bool, float64, string</span>
</pre></div>
<p>Los inicializadores pueden ser valores literales o expresiones arbitrarias. Las variables a nivel de paquete se inicializan antes del inicio de <code>main</code> (<a href="#Seccion-2.6.2" >§2.6.2</a>), y las variables locales se inicializan a medida que se encuentran sus declaraciones durante la ejecucion de la funcion.</p>
<p>Tambien se puede inicializar un conjunto de variables llamando a una funcion que devuelve valores multiples:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// os.Open returns a file and an error</span>
</pre></div>
</div>
<h4 id="Seccion-2.3.1" >Declaraciones de Variables Compacta</h4>
<div class="hBody-4" >
<p>Dentro de una funcion, una forma alternativa llamada <em>declaracion de variables compacta</em> se puede usar para declarar e inicializar las variables locales. Toma la forma <code>nombre := expresion</code>, y el tipo de <code>nombre</code> esta determinada por el tipo de <code>expresion</code>. Aqui estan tres de las muchas declaraciones de variables compacta en la funcion <code>lissajous</code> (<a href="#Seccion-1.4" >§1.4</a>):</p>
<div class="highlight"><pre><span></span><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
<span class="nx">freq</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Float64</span><span class="p">()</span> <span class="o">*</span> <span class="mf">3.0</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span>
</pre></div>
<p>Debido a su brevedad y flexibilidad, la declaracion compacta de variables se utilizan para declarar e inicializar la mayoria de las variables locales. Una sentencia <code>var</code> tiende a ser reservado para las variables locales que necesitan un tipo explicito que difiere de la de la expresion de inicializacion, o para cuando se le asignara un valor mas adelante la variable y su valor inicial no es importante.</p>
<div class="highlight"><pre><span></span><span class="nx">i</span> <span class="o">:=</span> <span class="mi">100</span>                  <span class="c1">// an int</span>
<span class="kd">var</span> <span class="nx">boiling</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// a float64</span>

<span class="kd">var</span> <span class="nx">names</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="nx">Point</span>
</pre></div>
<p>Como con las sentencias <code>var</code>, multiples variables pueden ser declaradas e inicializadas en la misma declaracion compacta de variables,</p>
<div class="highlight"><pre><span></span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
<p>pero las declaraciones con multiples expresiones de inicializador deben utilizarse solo cuando ayudan a la legibilidad, como en agrupaciones cortas y naturales, como la parte de inicializacion de un bucle <code>for</code>.</p>
<p>Tenga en cuenta que <code>:=</code> es una declaracion, mientras que <code>=</code> es una asignacion. Una declaracion de multiples variables no debe confundirse con una asignacion de tuplas (<a href="#Seccion-2.4.1" >§2.4.1</a>), en la que se asigna a cada variable en el lado de la izquierda el valor correspondiente de la parte derecha:</p>
<div class="highlight"><pre><span></span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">i</span> <span class="c1">// swap values of i and j</span>
</pre></div>
<p>Al igual que en declaraciones <code>var</code> ordinarias, la declaraciones de variables compacta se puede utilizar para las llamadas a funciones como <code>os.Open</code> que devuelve dos o mas valores:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="c1">// ...use f...</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</pre></div>
<p>Un punto sutil pero importante: una declaracion de variables compacta no declara necesariamente todas las variables en su lado izquierdo. Si algunos de ellos ya fueron declarados en el <em>mismo</em> bloque lexico (<a href="#Seccion-2.7" >§2.7</a>), entonces la declaracion de variables compacta se comporta como una asignacion a esas variables.</p>
<p>En el codigo siguiente, la primera sentencia declara tanto <code>in</code> como <code>err</code>. El segundo declara <code>out</code> pero solo asigna un valor a la variable <code>err</code> existente.</p>
<div class="highlight"><pre><span></span><span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span>
</pre></div>
<p>Sin embargo, una declaracion de variable corta debe declarar al menos una variable nueva, por lo que este codigo no compilara:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">infile</span><span class="p">)</span>
<span class="c1">// ...</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">outfile</span><span class="p">)</span> <span class="c1">// error de compilacion: no hay nuevas variables</span>
</pre></div>
<p>La correccion consiste en utilizar una asignacion ordinaria para la segunda instruccion.</p>
<p>Una declaracion de variable compacta actua como una asignacion solo a variables que ya estaban declaradas en el mismo bloque lexico; Las declaraciones en un bloque externo se ignoran. Veremos ejemplos de esto al final del capitulo.</p>
</div>
<h4 id="Seccion-2.3.2" >Punteros</h4>
<div class="hBody-4" >
<p>Una variable es una pieza de almacenamiento que contiene un valor. Las variables creadas por las declaraciones se identifican por un nombre, como <code>x</code>, pero muchas variables se idientifican solo por expresion como <code>x[i]</code> o <code>x.f</code>. Todas estas expresiones leen el valor de una variable, excepto cuando aparecen en el lado izquierdo de una asignacion, en cuyo caso se asigna un nuevo valor a la variable.</p>
<p>El valor de un <em>puntero</em> es la <em>direccion</em> de una variable. Un puntero es, por tanto, la ubicacion en la que se almacena un valor. No todos los valores tienen una direccion, pero todas las variables si. Con un puntero, podemos leer o actualizar el valor de una variable <em>indirectamente</em>, sin utilizar o incluso saber el nombre de la variable, si es que tiene un nombre.</p>
<p>Si se declara una variable <code>var x int</code>, la expresion <code>&amp;x</code> (<q>direccion de <code>x</code></q>) produce un puntero a una variable de de tipo entero, es decir, un valor de tipo <code>*int</code>, que se pronuncia <q>puntero a int.</q> Si este valor se llama <code>p</code>, decimos <q><code>p</code> apunta a <code>x</code>,</q>&quot; o equivalentemente <q><code>p</code> contiene la direccion de <code>x</code>.</q> La variable a la que <code>p</code> apunta se escribe <code>*p</code>. La expresion <code>*p</code> produce el valor de dicha variable, un <code>int</code>, pero desde <code>*p</code> indica una variable, tambien puede aparecer en la parte izquierda de una asignacion, en cuyo caso la asignacion actualiza la variable.</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">x</span>         <span class="c1">// p, of type *int, points to x</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;1&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>          <span class="c1">// equivalent to x = 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>  <span class="c1">// &quot;2&quot;</span>
</pre></div>
<p>Cada componente de una variable de tipo agregado–un campo de una estructura o un elemento de una matriz– es tambien una variable y por lo tanto tiene una direccion tambien.</p>
<p>Las variables se describen a veces como valores <em>direccionables</em>. Expresiones que denotan variables son las unicas expresiones a las que el operador de direccion <code>&amp;</code> se puede aplicar.</p>
<p>El valor cero de un puntero de cualquier tipo es <code>nil</code>. La prueba de <code>p != nil</code> es verdadera si <code>p</code> apunta a una variable. Los punteros son comparables; Dos punteros son iguales si y solo si apuntan a la misma variable o ambos son <code>nil</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// &quot;true false false&quot;</span>
</pre></div>
<p>Es perfectamente seguro para una funcion devolver la direccion de una variable local. Por ejemplo, en el codigo siguiente, la variable local <code>v</code> creada por la llamada a <code>f</code> seguira existiendo incluso despues de devolver la llamada, y el puntero <code>p</code> todavia se referira a ella:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="p">}</span>
</pre></div>
<p>Cada llamada a <code>f</code> devuelve un valor distinto:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">()</span> <span class="o">==</span> <span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>Debido a que un puntero contiene la direccion de una variable, pasar un argumento de puntero a una funcion hace posible que la funcion actualice la variable que se paso indirectamente. Por ejemplo, esta funcion incrementa la variable a la que apunta su argumento y devuelve el nuevo valor de la variable para que pueda ser utilizada en una expresion:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">incr</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">p</span><span class="o">++</span> <span class="c1">// incrementa a lo que apunta p; no cambia p</span>
  <span class="k">return</span> <span class="o">*</span><span class="nx">p</span>
<span class="p">}</span>

<span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>              <span class="c1">// efecto secundario: ahora v es 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">incr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &quot;3&quot; (y v es 3)</span>
</pre></div>
<p>Cada vez que se toma la direccion de una variable o se copia un puntero, creamos nuevos <em>alias</em> o maneras de identificar a la misma variable. Por ejemplo, <code>*p</code> es un alias para <code>v</code>. Los punteros como alias son utiles porque nos permite acceder a una variable sin usar su nombre, pero esto es una espada de doble filo: para encontrar todas las sentencias que acceden a una variable, tenemos que conocer todos sus alias. No son solo los punteros que crean alias; los alias tambien se crean cuando copiamos valores de otros tipos de referencia como slices, mapas y canales, e incluso estructuras, matrices e interfaces que contienen estos tipos.</p>
<p>Los punteros son clave para el paquete <code>flag</code>, que utiliza los argumentos de linea de comandos de un programa, para establecer los valores de ciertas variables distribuidas a lo largo del programa. Para ilustrar, esta variacion en el anterior comando <code class="command" >echo</code> tiene dos indicadores opcionales: <code>-n</code> provaca que <code class="command" >echo</code> omita el salto de linea final que normalmente se imprime, y <code>-s sep</code> hace que se separe los argumentos de salida por el contenido de la cadena <code>sep</code> en lugar de El espacio unico predeterminado. Como esta es nuestra cuarta version, el paquete se llama <span class="file" >gopl.io/ch2/echo4</span>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/echo4/main.go" >gopl.io/ch2/echo4</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Echo4 imprime sus argumentos de linea de comandos.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;flag&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;omit trailing newline&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">sep</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot;separator&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">(),</span> <span class="o">*</span><span class="nx">sep</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">!</span><span class="o">*</span><span class="nx">n</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>flag.Bool</code> crea una nueva variable bandera de tipo <code>bool</code>. Toma tres argumentos: el nombre de la bandera (<code>&quot;n&quot;</code>), el valor por defecto de la variable (<code>false</code>), y un mensaje que se imprimira si el usuario proporciona un argumento invalido, una bandera invalida, o <code>-h</code> o <code>-help</code>. Del mismo modo, <code>flag.String</code> toma un nombre, un valor por defecto, y un mensaje, y crea una variable <code>string</code>. Las variables <code>sep</code> y <code>n</code> son punteros a las variables de la bandera, que deben accederse indirectamente como <code>*sep</code> y <code>*n</code>.</p>
<p>Cuando se ejecuta el programa, debe llamar a <code>flag.Parse</code> antes de utilizar las banderas, para actualizar las variables bandera de sus valores por defecto. Los argumentos que no sean banderas estan disponibles mediante <code>flag.Args()</code> como un slice de strings. Si <code>flag.Parse</code> encuentra un error, se imprime un mensaje sobre el uso y llama a <code>os.Exit(2)</code> para terminar el programa.</p>
<p>Vamos a ejecutar algunos casos de prueba a <code class="command" >echo</code>:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch2/echo4
$ ./echo4 a bc def
a bc def
$ ./echo4 -s / a bc def
a/bc/def
$ ./echo4 -n a bc def
a bc def$
$ ./echo4 -help
Usage of ./echo4:
  -n    omit trailing newline
  -s string
        separator <span class="o">(</span>default <span class="s2">&quot; &quot;</span><span class="o">)</span>
</pre></div>
</div>
<h4 id="Seccion-2.3.3" >La Funcion <code>new</code></h4>
<div class="hBody-4" >
<p>Otra forma de crear una variable es utilizar la funcion nativa de <code>new</code>. La expresion <code>new(T)</code> crea una <em>variable sin nombre</em> del tipo <code>T</code>, la inicializa al valor cero de <code>T</code>, y devuelve su direccion, que es un valor de tipo <code>*T</code>.</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>   <span class="c1">//  p, de tipo *int, apunta a una varible int sin nombre</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//  &quot;0&quot;</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">2</span>          <span class="c1">//  establece el int sin nombre a 2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//  &quot;2&quot;</span>
</pre></div>
<p>Una variable creada con <code>new</code> no es diferente de una variable local ordinaria cuya direccion es tomada, excepto que no hay necesidad de inventar (y declarar) un nombre ficticio, y podemos usar <code>new(T)</code> en una expresion. De este modo <code>new</code> es solo una conveniencia sintactica, no es una idea fundamental:</p>
<p>las dos funciones <code>newInt</code> a continuacion tienen comportamientos identicos.</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">newInt</span><span class="p">()</span> <span class="o">*</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">dummy</span> <span class="kt">int</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">dummy</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Cada llamada a <code>new</code> devuelve una variable distinta con una direccion unica:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>Hay una excepcion a esta regla: dos variables cuyo tipo no lleva ninguna informacion y por lo tanto es de tamaño cero, como <code>struct{}</code> o <code>[0]int</code>, puede, dependiendo de la aplicacion, tener la misma direccion.</p>
<p>La funcion <code>new</code> se utiliza relativamente rara vez porque las variables sin nombre mas comunes son de tipo estructura, para el que la sintaxis literal <code>struct</code> (<a href="#Seccion-4.4.1" >§4.4.1</a>) es mas flexible.</p>
<p>Dado que <code>new</code> es una funcion nativa, no una palabra clave, es posible redefinir el nombre para algo distinto dentro de una funcion, por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">delta</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">new</span> <span class="o">-</span> <span class="nx">old</span> <span class="p">}</span>
</pre></div>
<p>Por supuesto, dentro de <code>delta</code>, la funcion nativa <code>new</code> no esta disponible.</p>
</div>
<h4 id="Seccion-2.3.4" >Tiempo de Vida de las Variables</h4>
<div class="hBody-4" >
<p>La <em>vida util</em> de una variable es el intervalo de tiempo durante el cual existe a medida que el programa se ejecuta. La duracion de una variable a nivel de paquete, es la ejecucion completa del programa. Por el contrario, las variables locales tienen una vida util dinamica: una nueva instancia se crea cada vez que se ejecuta la instruccion de declaracion, y la variable vive hasta que se vuelve <em>inaccesible</em>, momento en el que su almacenamiento se puede reciclar. Los parametros de funcion y los resultados tambien son variables locales; Se crean cada vez que se llama a la funcion que las encierra.</p>
<p>Por ejemplo, en este extracto del programa de Lissajous de la <a href="#Seccion-1.4" >Seccion 1.4</a>,</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">t</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="nx">t</span> <span class="p">&lt;</span> <span class="nx">cycles</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">;</span> <span class="nx">t</span> <span class="o">+=</span> <span class="nx">res</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">t</span><span class="o">*</span><span class="nx">freq</span> <span class="o">+</span> <span class="nx">phase</span><span class="p">)</span>
  <span class="nx">img</span><span class="p">.</span><span class="nx">SetColorIndex</span><span class="p">(</span><span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="nx">size</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="nx">y</span><span class="o">*</span><span class="nx">size</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="nx">blackIndex</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>la variable <code>t</code> se crea cada vez que el bucle <code>for</code> comienza, y nuevas variables <code>x</code> y <code>y</code> se crean en cada iteracion del bucle.</p>
<p>¿Como sabe el recolector de basura que el almacenamiento de una variable puede ser recuperado? La historia completa es mucho mas detallada de lo que necesitamos aqui, pero la idea basica es que cada variable a nivel de paquete, y cada variable local de cada funcion actualmente activa, puede ser el inicio o la raiz de una ruta a la variable en cuestion, sugiendo punteros y otros tipos de referencias que finalmente conducen a la variable. Si no existe tal ruta, la variable se ha vuelto inaccesible, por lo que ya no puede afectar el resto del calculo.</p>
<p>Debido a que el tiempo de vida de una variable se determina por ser o no accesible, una variable local puede sobrevivir a una sola iteracion del bucle que lo rodea. Puede seguir existiendo incluso despues de que su funcion de inclusion ha regresado.</p>
<p>Un compilador puede elegir por asignar las variables locales en el monticulo o en la pila, pero, tal vez sorprendentemente, esta eleccion no depende de si se utiliza <code>var</code> o <code>new</code> para declarar la variable.</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">global</span> <span class="o">*</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">global</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
  <span class="o">*</span><span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Aqui, <code>x</code> debe ser asignado al monticulo porque todavia es accesible desde la variable <code>global</code> despues de haber devuelto <code>f</code>, a pesar de ser declarado como una variable local; decimos que <code>x</code> escapa de <code>f</code>. Por el contrario, cuando <code>g</code> regresa la variable <code>*y</code> se vuelve inaccesible y se pueden reciclar. Dado que <code>*y</code> no escapa de <code>g</code>, es seguro para el compilador asignar <code>*y</code> en la pila, a pesar de que se asigno con <code>new</code>. En cualquier caso, la nocion de escapar no es algo de lo que tengas que preocuparte para escribir codigo correcto, aunque es bueno tenerlo en cuenta durante la optimizacion de rendimiento, ya que cada variable que escapa requiere una asignacion de memoria adicional.</p>
<p>La recoleccion de basura es una tremenda ayuda para escribir programas correctos, pero no elimina la carga de pensar en la memoria. No es necesario asignar y liberar memoria de forma explicita, pero para escribir programas eficientes es necesario tener en cuenta la duracion de las variables. Por ejemplo, mantener punteros innecesarios a objetos de corta duracion dentro de objetos de larga vida, especialmente variables globales, evitara que el recolector de basura recupere los objetos de corta duracion.</p>
</div>
<h3 id="Seccion-2.4" >Asignaciones</h3>
<div class="hBody-3" >
<p>El valor contenido en una variable es actualizado por una instruccion de asignacion, que en su forma mas simple tiene una variable a la izquierda del signo <code>=</code> y una expresion a la derecha.</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>                       <span class="c1">// variable con nombre</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="kc">true</span>                   <span class="c1">// variable indirecta</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&quot;bob&quot;</span>         <span class="c1">// campo de ustructura</span>
<span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">=</span> <span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">*</span> <span class="nx">scale</span> <span class="c1">// elemento de arreglo, slice o mapa</span>
</pre></div>
<p>Cada uno de los operadores aritmeticos y operadores binarios a nivel de bits tiene su correspondiente <em>operador de asignacion</em> permitiendo, por ejemplo, reescribir la ultima instruccion como</p>
<div class="highlight"><pre><span></span><span class="nx">count</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">*=</span> <span class="nx">scale</span>
</pre></div>
<p>Lo que nos ahorra tener que repetir (y reevaluar) la expresion de la variable.</p>
<p>Las variables numericas tambien se pueden incrementar y disminuir con las declaraciones <code>++</code> y <code>--</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">v</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">v</span><span class="o">++</span>    <span class="c1">// igual a v = v + 1; v es 2</span>
<span class="nx">v</span><span class="o">--</span>    <span class="c1">// igual a v = v - 1; v es 1 de nuevo</span>
</pre></div>
</div>
<h4 id="seccion-2.4.1" >Asignacion de Tuplas</h4>
<div class="hBody-4" >
<p>Otra forma de asignacion, conocida como <em>asignacion de tuplas</em>, permite asignar varias variables a la vez. Todas las expresiones del lado derecho se evaluan antes de actualizar cualquiera de las variables, haciendo que este formato sea mas util cuando algunas de las variables aparecen en ambos lados de la asignacion, como sucede, por ejemplo, al intercambiar los valores de dos variables:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</pre></div>
<p>O cuando se calcula el mayor comun divisor de dos enteros:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">gcd</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">%</span><span class="nx">y</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>
<p>O al calcular el n-esimo numero de Fibonacci iterativamente:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>
<p>La asignacion de tuplas tambien puede hacer una secuencia de tareas triviales mas compacta,</p>
<div class="highlight"><pre><span></span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
<p>Aunque por una cuestion de estilo, evite la forma de tupla si las expresiones son complejas; una secuencia de declaraciones separadas es mas facil de leer.</p>
<p>Ciertas expresiones, como una llamada a una funcion con resultados multiples, producen varios valores. Cuando se utiliza una llamada de este tipo en una instruccion de asignacion, el lado izquierdo debe tener tantas variables como la funcion tenga resultados.</p>
<div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">)</span> <span class="c1">// Llamada de funcion devuelve dos valores</span>
</pre></div>
<p>A menudo, las funciones utilizan estos resultados adicionales para indicar algun tipo de error, ya sea devolviendo un <code>error</code> como en la llamada a <code>os.Open</code>, o un <code>bool</code>, generalmente llamado <code>ok</code>. Como veremos en capitulos posteriores, hay tres operadores que a veces se comportan de esta manera tambien. Si la busqueda en un mapa (<a href="#Seccion-4.3" >§4.3</a>), un tipo de asercion (<a href="#Seccion-7.10" >§7.10</a>), o la recepcion de un canal (<a href="#Seccion-8.4.2" >§8.4.2</a>) aparece en una asignacion en la que se esperan dos resultados, cada una produce un resultado booleano adicional:</p>
<div class="highlight"><pre><span></span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>         <span class="c1">// map lookup</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>          <span class="c1">// type assertion</span>
<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>           <span class="c1">// channel receive</span>
</pre></div>
<p>Al igual que con la declaracion de variables, podemos asignar valores no deseados al identificador en blanco:</p>
<div class="highlight"><pre><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="c1">// discard byte count</span>
<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>              <span class="c1">// check type but discard result</span>
</pre></div>
</div>
<h4 id="Seccion-2.4.2" >Asignacion</h4>
<div class="hBody-4" >
<p>Las sentencias de asignacion son una forma explicita de asignacion, pero hay muchos lugares en un programa donde se produce una asignacion <em>implicita</em>: una llamada de funcion asigna implicitamente los valores de los argumentos a las variables de parametros correspondientes; una instruccion <code>return</code> asigna implicitamente los operandos de retorno a las variables de resultado correspondientes; y una expresion literal para un tipo compuesto (<a href="#Seccion-4.2" >§4.2</a>), tal como esta slice:</p>
<div class="highlight"><pre><span></span><span class="nx">medallas</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;oro&quot;</span><span class="p">,</span> <span class="s">&quot;plata&quot;</span><span class="p">,</span> <span class="s">&quot;bronce&quot;</span><span class="p">}</span>
</pre></div>
<p>Implicitamente asigna cada elemento, como si se hubiera escrito asi:</p>
<div class="highlight"><pre><span></span><span class="nx">medallas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;oro&quot;</span>
<span class="nx">medallas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;plata&quot;</span>
<span class="nx">medallas</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;bronce&quot;</span>
</pre></div>
<p>Los elementos de mapas y canales, aunque no son variables ordinarias, tambien estan sujetos a asignaciones implicitas similares.</p>
<p>Una asignacion, explicita o implicita, siempre es legal si el lado izquierdo (la variable) y el lado derecho (el valor) tienen el mismo tipo. En terminos mas generales, la asignacion es legal solo si el valor es <em>asignable</em> al tipo de la variable.</p>
<p>La regla para la <em>asignabilidad</em> tiene casos para varios tipos, por lo que vamos a explicar el caso relevante a medida que introducimos cada nuevo tipo. Para los tipos que hemos discutido hasta ahora, las reglas son simples: los tipos deben coincidir exactamente, y <code>nil</code> puede ser asignado a cualquier variable de interfaz o tipo de referencia. Las constantes (<a href="#Seccion-3.6" >§3.6</a>) tienen reglas mas flexibles para la asignacion que evitan la necesidad de conversiones mas explicitos.</p>
<p>Si dos valores pueden compararse con <code>==</code> y <code>!=</code> se relaciona con la asignacion: en cualquier comparacion, el primer operando debe ser asignable al tipo del segundo operando, o viceversa. Al igual que con la asignabilidad, vamos a explicar los casos relevantes para la comparabilidad cuando presentamos cada nuevo tipo.</p>
</div>
<h3 id="Seccion-2.5" >Declaraciones de tipo</h3>
<div class="hBody-3" >
<p>El tipo de una variable o expresion define las caracteristicas de los valores que puede tomar, como su tamaño (numero de bits o numero de elementos, tal vez), como se representan internamente, las operaciones intrinsecas que se pueden realizar en ellos, Y los metodos asociados con ellos.</p>
<p>En cualquier programa hay variables que comparten la misma representacion pero que significan conceptos muy diferentes. Por ejemplo, un <code>int</code> podria ser usado para representar un indice de bucle, una marca de tiempo, un descriptor de archivo, o un mes; un <code>float64</code> podria representar una velocidad en metros por segundo o una temperatura en una de varias escalas; y un <code>string</code> podria representar una contraseña o el nombre de un color.</p>
<p>Una declaracion <code>type</code> define un nuevo <em>tipo con nombre</em> que tiene el mismo <em>tipo subyacente</em> como un tipo existente. El tipo nombrado proporciona una manera de separar los diferentes usos y quizas incompatibles del tipo subyacente para que no puedan ser mezclados involuntariamente.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">name</span> <span class="nx">underlying</span><span class="o">-</span><span class="kd">type</span>
</pre></div>
<p>Las declaraciones de tipo aparecen mas a menudo en el nivel de paquete, donde el tipo nombrado es visible en todo el paquete, y si el nombre se exporta (inicia con una letra mayuscula), es accesible desde otros paquetes tambien.</p>
<p>Para ilustrar la declaracion de tipos, vamos a convertir las diferentes escalas de temperatura en tipos distintos:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/tempconv0/celsius.go" >gopl.io/ch2/tempconv0</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Paquete tempconv realiza calculos de temperatura Celsius y Fahrenheit.</span>
<span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
  <span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Este paquete define dos tipos, <code>Celsius</code> y <code>Fahrenheit</code>, para las dos unidades de temperatura. A pesar de que ambos tienen el mismo tipo subyacente, <code>float64</code>, no son del mismo tipo, por lo que no pueden compararse o ser combinados en expresiones aritmeticas. Distinguir los tipos hace posible evitar errores como combinar inadvertidamente temperaturas en las dos escalas diferentes; una conversion de tipo explicita como <code>Celsius(t)</code> o <code>Fahrenheit(t)</code> es necesario para convertir desde un <code>float64</code>. <code>Celsius(t)</code> y <code>Fahrenheit(t)</code> son conversiones, no llamadas a funcion. No cambian el valor o la representacion de ninguna manera, pero hacen que el cambio de significado sea explicito. Por otro lado, las funciones <code>CToF</code> y <code>FToC</code> convertir entre las dos escalas; Estas devuelven valores diferentes.</p>
<p>Para cada tipo <code>T</code>, hay una operacion de conversion correspondiente <code>T(x)</code> que convierte el valor <code>x</code> al tipo <code>T</code>. Se permite una conversion de un tipo a otro si ambos tienen el mismo tipo subyacente, o si ambos son tipos apuntador sin nombre que apuntan a variables del mismo tipo subyacente; Estas conversiones cambian el tipo pero no la representacion del valor. Si <code>x</code> es asignable a <code>T</code>, se permite una conversion, pero suele ser redundante,</p>
<p>Las conversiones tambien se permiten entre tipos numericos, y entre la cadena y algunos tipos de slices, como veremos en el siguiente capitulo. Estas conversiones pueden cambiar la representacion del valor. Por ejemplo, la conversion de un numero de coma flotante a un entero descarta cualquier parte fraccionaria, y la conversion de una cadena a un slice <code>[]byte</code> asigna una copia de los datos de cadena. En cualquier caso, una conversion nunca falla en tiempo de ejecucion.</p>
<p>El tipo subyacente de un tipo con nombre determina su estructura y representacion, asi como el conjunto de operaciones intrinsecas que admite, que son iguales que si el tipo subyacente se hubiera utilizado directamente. Eso significa que los operadores aritmeticos funcionan igual para <code>Celsius</code> y <code>Fahrenheit</code> como lo hacen para <code>float64</code>, como se podria esperar.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">BoilingC</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span>       <span class="c1">// &quot;100&quot; °C</span>
<span class="nx">boilingF</span> <span class="o">:=</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">BoilingC</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">FreezingC</span><span class="p">))</span> <span class="c1">// &quot;180&quot; °F</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">boilingF</span><span class="o">-</span><span class="nx">FreezingC</span><span class="p">)</span>       <span class="c1">// error de compilacion: tipo incorrecto</span>
</pre></div>
<p>Los operadores de comparacion como <code>==</code> y <code>&lt;</code> tambien se puede utilizar para comparar un valor de un tipo con nombre a otro del mismo tipo, o a un valor del tipo subyacente. Pero dos valores de diferentes tipos con nombre no pueden compararse directamente:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="nx">Celsius</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="nx">Fahrenheit</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">f</span><span class="p">)</span>          <span class="c1">// error de compilacion: tipo incorrecto</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// &quot;true&quot;!</span>
</pre></div>
<p>Anote cuidadosamente el ultimo caso. A pesar de su nombre, la conversion de tipo <code>Celsius(f)</code> no cambia el valor de su argumento, a su tipo. La prueba es cierto porque <code>c</code> y <code>f</code> son ambos cero.</p>
<p>Un tipo con nombre puede proporcionar conveniencia de notacion si ayuda a evitar escribir tipos complejos una y otra vez. La ventaja es pequeña cuando el tipo subyacente es tan simple como <code>float64</code>, pero grande para los tipos complicados, como veremos cuando hablemos de estructuras.</p>
<p>Los tipos nombrados tambien permiten definir nuevos comportamientos para los valores del tipo. Estos comportamientos se expresan como un conjunto de funciones asociadas con el tipo, llamado <em>metodos</em> del tipo. Veremos los metodos en detalle en el capitulo 6, pero daremos una idea del mecanismo aqui.</p>
<p>La siguiente declaracion, en la que el parametro <code>Celsius</code> <code>c</code> aparece antes del nombre de la funcion, se asocia con el tipo <code>Celsius</code> un metodo llamado <code>String</code> que devuelve <code>c</code> como un valor numerico seguido por <code>°C</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°C&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
<p>Muchos tipos declarar un metodo <code>String</code> de esta forma debido a que controla como aparecen los valores del tipo cuando se imprimen en una cadena con el paquete <code>fmt</code>, como veremos en la <a href="#Seccion-7.1" >Seccion 7.1</a>.</p>
<div class="highlight"><pre><span></span><span class="nx">c</span> <span class="o">:=</span> <span class="nx">FToC</span><span class="p">(</span><span class="mf">212.0</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100°C&quot;; no es necesario llamar a String explicitamente</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>          <span class="c1">// &quot;100°C&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>   <span class="c1">// &quot;100&quot;; no llama a String</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="c1">// &quot;100&quot;; no llama a String</span>
</pre></div>
</div>
<h3 id="Seccion-2.6" >Paquetes y Ficheros</h3>
<div class="hBody-3" >
<p>Los paquetes en Go sirven a los mismos propositos que las librerias o modulos en otros lenguajes, soportando modularidad, encapsulacion, compilacion separada y reutilizacion. El codigo fuente de un paquete reside en uno o mas archivos <span class="file" >.go</span>, por lo general en un directorio cuyo nombre termina con la ruta de importacion; por ejemplo, los archivos del paquete <code>gopl.io/ch1/helloworld</code> se almacenan en el directorio <code>$GOPATH/src/gopl.io/ch1/helloworld</code>.</p>
<p>Cada paquete sirve como un <em>espacio de nombres</em> separado para sus declaraciones. Dentro del paquete <code>image</code>, por ejemplo, el identificador <code>Decode</code> se refiere a una funcion diferente de la que el mismo identificador en el paquete <code>unicode/utf16</code>. Para hacer referencia a una funcion desde fuera de su paquete, debemos <em>calificar</em> el identificador para hacer explicito si nos referimos a <code>image.Decode</code> o <code>utf16.Decode</code>.</p>
<p>Los paquetes tambien nos permiten ocultar informacion controlando que nombres son visibles fuera del paquete, o <em>exportados</em>. En Go, una regla simple regula que identificadores se exportan y cuales no: los identificadores exportados comienzan con una letra mayuscula.</p>
<p>Para ilustrar los fundamentos, supongamos que nuestro software de conversion de temperatura se ha vuelto popular y queremos ponerlo a disposicion de la comunidad Go como un nuevo paquete. ¿Como hacemos eso?</p>
<p>Vamos a crear un paquete llamado <code>gopl.io/ch2/tempconv</code>, una variacion del ejemplo anterior. (Aqui hemos hecho una excepcion a nuestra regla habitual de ejemplos de numeracion en secuencia, de modo que la ruta del paquete puede ser mas realista.) El propio paquete se almacena en dos archivos para mostrar como se accede a las declaraciones en archivos separados de un paquete; En la vida real, un pequeño paquete como este solo necesitaria un archivo.</p>
<p>Hemos puesto las declaraciones de los tipos, sus constantes y sus metodos en <span class="file" >tempconv.go</span>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/tempconv/tempconv.go" >gopl.io/ch2/tempconv</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete tempconv realiza conversiones Celsius y Fahrenheit.</span>
<span class="kn">package</span> <span class="nx">tempconv</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float64</span>
<span class="kd">type</span> <span class="nx">Fahrenheit</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">AbsoluteZeroC</span> <span class="nx">Celsius</span> <span class="p">=</span> <span class="o">-</span><span class="mf">273.15</span>
	<span class="nx">FreezingC</span>     <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">BoilingC</span>      <span class="nx">Celsius</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>    <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°C&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°F&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>y las funciones de conversion en <span class="file" >conv.go</span>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">tempconv</span>

<span class="c1">// CToF convierte una temperatura Celsius a Fahrenheit.</span>
<span class="kd">func</span> <span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">Fahrenheit</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">c</span><span class="o">*</span><span class="mi">9</span><span class="o">/</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// FToC convierte una temperatura Fahrenheit a Celsius.</span>
<span class="kd">func</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Fahrenheit</span><span class="p">)</span> <span class="nx">Celsius</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Celsius</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
<p>Cada archivo comienza con una declaracion <code>package</code> que define el nombre del paquete. Cuando se importa el paquete, sus miembros se conocen como <code>tempconv.CToF</code> y asi. Los nombres a nivel de paquete como los tipos y las constantes declaradas en un archivo de un paquete son visibles para todos los otros archivos del paquete, como si el codigo fuente estuviera todo en un solo archivo. Observe que <span class="file" >tempconv.go</span> importa <code>fmt</code>, pero <span class="file" >conv.go</span> no lo hace, ya que no utiliza nada de <code>fmt</code>.</p>
<p>Debido a que los nombres <code>const</code> de nivel de paquete comienzan con letras mayusculas, tambien son accesibles con nombres calificados, por ejemplo, <code>tempconv.AbsoluteZeroC</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Brrrr! %v\n&quot;</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">AbsoluteZeroC</span><span class="p">)</span> <span class="c1">// &quot;Brrrr! -273.15°C&quot;</span>
</pre></div>
<p>Para convertir una temperatura Celsius a Fahrenheit en un paquete que importa <code>gopl.io/ch2/tempconv</code>, podemos escribir el siguiente codigo:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">tempconv</span><span class="p">.</span><span class="nx">BoilingC</span><span class="p">))</span> <span class="c1">// &quot;212°F&quot;</span>
</pre></div>
<p>El <code>comentario de documentacion</code> (<a href="#Seccion-10.7.4" >§10.7.4</a>) inmediatamente anterior a la declaracion del paquete, documenta el paquete en su conjunto. Convencionalmente, debe comenzar con una oracion de resumen en el estilo ilustrado. Solo un archivo en cada paquete debe tener un comentario de documentacion del paquete. Los comentarios de documentacion extensos, a menudo se colocan en su propio fichero, convencionalmente llamado <span class="file" >doc.go</span>.</p>
<p><b>Ejercicio 2.1</b>: Añadir tipos, constantes y funciones a <code>tempconv</code> para el procesamiento de temperaturas en la escala Kelvin, donde cero Kelvin es -273,15°C y una diferencia de 1K tiene la misma magnitud de 1°C.</p>
</div>
<h4 id="Seccion-2.6.1" >Importaciones</h4>
<div class="hBody-4" >
<p>Dentro de un programa Go, cada paquete se identifica por una cadena unica llamada la <em>ruta de importacion</em>. Estas son las cadenas que aparecen en una declaracion <code>import</code> como <code>&quot;gopl.io/ch2/tempconv&quot;</code>. La especificacion del lenguaje no define de donde provienen estas cadenas o lo que significan; Depende de las herramientas para interpretarlas. Cuando se utiliza la herramienta <code class="command" >go</code> de (<a href="#Capitulo-10" >Capitulo 10</a>), una ruta de importacion denota un directorio que contiene uno o mas archivos de codigo fuento Go que juntos componen el paquete.</p>
<p>Ademas de su ruta de importacion, cada paquete tiene un nombre de paquete, que es corto (y no necesariamente unico) nombre que aparece en su declaracion <code>package</code>. Por convencion, el nombre de un paquete coincide con el ultimo segmento de la ruta de importacion, por lo que es facil predecir que el nombre del paquete de <code>gopl.io/ch2/tempconv</code> es <code>tempconv</code>.</p>
<p>Para utilizar <code>gopl.io/ch2/tempconv</code>, hay que importarlo:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/cf/main.go" >gopl.io/ch2/cf</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Cf conviente su argumento numerico en Celsius y Fahrenheit.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;strconv&quot;</span>

  <span class="s">&quot;gopl.io/ch2/tempconv&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseFloat</span><span class="p">(</span><span class="nx">arg</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;cf: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">Celsius</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = %s, %s = %s\n&quot;</span><span class="p">,</span>
      <span class="nx">f</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">FToC</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">CToF</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La declaracion de importacion vincula un nombre corto al paquete importado que se puede utilizar para referirse a su contenido en todo el archivo. El <code>import</code> anterior nos permite referimos a nombres dentro de <code>gopl.io/ch2/tempconv</code> mediante el uso de un identificador calificado como <code>tempconv.CToF</code>. Por defecto, el nombre corto es el nombre del paquete–en este caso <code>tempconv</code>, pero una declaracion de importacion puede especificar un nombre alternativo para evitar un conflicto (<a href="#Seccion-10.3" >§10.3</a>).</p>
<p>El programa <code class="command" >cf</code> convierte un unico argumento numerico de la linea de comando a su valor en grados Celsius y Fahrenheit:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch2/cf
$ ./cf <span class="m">32</span>
<span class="m">32</span>°F <span class="o">=</span> <span class="m">0</span>°C, <span class="m">32</span>°C <span class="o">=</span> <span class="m">89</span>.6°F
$ ./cf <span class="m">212</span>
<span class="m">212</span>°F <span class="o">=</span> <span class="m">100</span>°C, <span class="m">212</span>°C <span class="o">=</span> <span class="m">413</span>.6°F
$ ./cf -40
-40°F <span class="o">=</span> -40°C, -40°C <span class="o">=</span> -40°F
</pre></div>
<p>Es un error importar un paquete y luego no hacer referencia a el. Esta verificacion ayuda a eliminar las dependencias que se hacen innecesarias, cuando el codigo evoluciona, aunque puede ser una molestia durante la depuracion, ya que al comentar una linea de codigo como <code>log.Print(&quot;got here!&quot;)</code> puede eliminar la unica referencia al de nombre de paquete <code>log</code>, probocando que el compilador emita un error. En esta situacion, es necesario comentar o eliminar el <code>import</code> innecesario.</p>
<p>Mejor aun, utilice la herramienta <code>golang.org/x/tools/cmd/goimports</code>, que inserta y elimina paquetes de la declaracion de importacion, segun sea necesario de forma automatica; la mayoria de los editores pueden configurarse para ejecutar <code class="command" >goimports</code> cada vez que se guarda un fichero. Al igual que la herramienta <code class="command" >gofmt</code>, tambien imprime bonitos ficheros de codigo fuene en el formato canonico.</p>
<p><b>Ejercicio 2.2</b>: Escribir un programa de proposito general para conversion de unidades analogo a <code class="command" >cf</code> que leea los numeros de sus argumentos de linea de comando o de la entrada estandar si no hay argumentos, y convierta cada numero en unidades como la temperatura en grados Celsius y Fahrenheit, longitud en Pies y metros, peso en libras y kilogramos y similares.</p>
</div>
<h4 id="Seccion-2.6.2" >Inicializacion del paquete</h4>
<div class="hBody-4" >
<p>La inicializacion del paquete comienza inicializando las variables a nivel de paquete en el orden en que se declaran, excepto que las dependencias se resuelven primero:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>      <span class="c1">// a inicializado tercero, a 3</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">f</span><span class="p">()</span>        <span class="c1">// b inicializado segundo, a 2, llamando a f</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">1</span>          <span class="c1">// c inicializado primero, a 1</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</pre></div>
<p>Si el paquete tiene multiples ficheros <span class="file" >.go</span>, se inicializan en el orden en que se dan los archivos al compilador; La herramienta <code class="command" >go</code> ordena los ficheros <span class="file" >.go</span> archivos por nombre antes de invocar el compilador.</p>
<p>Cada variable declarada en el nivel del paquete comienza su vida con el valor de su expresion de inicializador, pero para algunas variables, como tablas de datos, una expresion del inicializador no puede ser la manera mas simple de establecer su valor inicial. En ese caso, el mecanismo de la funcion <code>init</code> puede ser mas simple. Cualquier archivo puede contener cualquier numero de funciones cuya declaracion sea</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>No se puede llamar o hacer referencia a estas funciones <code>init</code>, pero por lo demas son funciones normales. Dentro de cada archivo, las funciones <code>init</code> se ejecutan automaticamente cuando se inicia el programa, en el orden en que se declaran.</p>
<p>Los paquetes se inician uno a la vez, en el orden de las importaciones en el programa, las dependencias en primer lugar, por lo que un paquete <code>p</code> que importa a <code>q</code> puede estar seguro de que <code>q</code> se inicializa completamente antes de la inicialiacion de <code>p</code>. La inicializacion procede de abajo hacia arriba; el paquete <code>main</code> es el ultimo en ser inicializado. De esta manera, todos los paquetes se inicializan completamente antes de que inicie la funcion <code>main</code>.</p>
<p>El paquete a continuacion define una funcion <code>PopCount</code> que devuelve el numero de bits establecidos, es decir, los bits cuyo valor es 1, en un valor <code>uint64</code>, que se llama <em>conteo de poblacion</em>. Utiliza una funcion <code>init</code> para calcular previamente una tabla de resultados, <code>pc</code>, para cada posible valor de 8 bits de modo que la funcion <code>PopCount</code> no necesite tomar 64 pasos, pero solo puede devolver la suma de ocho consultas de tabla. (Esto definitivamente no es el algoritmo mas rapido para el recuento de bits, pero es conveniente para ilustrar las funciones <code>init</code>, y para mostrar como calcular previamente una tabla de valores, que a menudo es una tecnica de programacion util).</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch2/popcount/main.go" >gopl.io/ch2/popcount</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">popcount</span>

<span class="c1">// pc[i] es el recuento de poblacion de i.</span>
<span class="kd">var</span> <span class="nx">pc</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// PopCount regresa el conteo de la poblacion (numero de bist establecidos) de x.</span>
<span class="kd">func</span> <span class="nx">PopCount</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="mi">8</span><span class="p">))]</span> <span class="o">+</span>
    <span class="nx">pc</span><span class="p">[</span><span class="nb">byte</span><span class="p">(</span><span class="nx">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">))])</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Observe que el rango del bucle en <code>init</code> utiliza solo el indice; El valor es innecesario y por lo tanto no necesita ser incluido. El bucle tambien podria haber sido escrito como</p>
<div class="highlight"><pre><span></span><span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pc</span> <span class="p">{</span>
</pre></div>
<p>Veremos otros usos de funciones <code>init</code> en la siguiente seccion y en la seccion <a href="#Seccion-10.5" >Seccion 10.5</a>.</p>
<p><b>Ejercicio 2.3</b>: Vuelve a escribir <code>PopCount</code> para utilizar un bucle en lugar de una sola expresion. Compare el rendimiento de las dos versiones. La (<a href="#Seccion-11.4" >Seccion 11.4</a> muestra como comparar el rendimiento de diferentes implementaciones de forma sistematica.)</p>
<p><b>Ejercicio 2.4</b>: Escribe una version de <code>PopCount</code> que cuenta los bits desplazando su argumento a traves de posiciones de 64 bits, poniendo a prueba el bit mas a la derecha cada vez. Compare su rendimiento con la version de buesqueda por la tabla.</p>
<p><b>Ejercicio 2.5</b>: La expresion </p>
</div>
<h3 id="Seccion-2.7" >Alcance</h3>
<div class="hBody-3" >
<p>Una declaracion asocia un nombre a una entidad de programa, como una funcion o una variable. El <em>alcance</em> de una declaracion es la parte del codigo fuente, donde el uso de un nombre declarado hace referencia a esa declaracion.</p>
<p>No confunda el alcance con el tiempo de vida. El alcance de una declaracion es una region del texto del programa; Es una propiedad de tiempo de compilacion. La vida util de una variable es el intervalo de tiempo durante la ejecucion cuando la variable puede ser referida por otras partes del programa; Es una propiedad en tiempo de ejecucion.</p>
<p>Un <em>bloque</em> sintactico es una secuencia de sentencias encerradas entre llaves como las que rodean el cuerpo de una funcion o bucle. Un nombre declarado dentro de un bloque sintactico no es visible fuera de ese bloque. El bloque incluye sus declaraciones y determina su alcance. Podemos generalizar esta nocion de bloques para incluir otras agrupaciones de declaraciones que no estan explicitamente rodeadas por llaves en el codigo fuente; los llamaremos a todos <em>bloques lexicos</em>. Hay un bloque lexico para todo el codigo fuente, llamado <em>bloque del universo</em>; para cada paquete; para cada archivo; para cada sentencia <code>for</code>, <code>if</code>, y <code>switch</code>; para cada caso en una sentencia <code>switch</code> o <code>select</code>; Y, por supuesto, para cada bloque sintactico explicito.</p>
<p>El bloque lexico de una declaracion determina su alcance, que puede ser grande o pequeño. Las declaracion de tipos nativos, funciones y constantes, por ejemplo <code>int</code>, <code>len</code>, y <code>true</code> estan en el bloque universo y pueden ser referidos a lo largo de todo el programa. Declaraciones fuera de cualquier funcion, es decir, a <em>nivel de paquete</em>, puede ser refenciadas en cualquier archivo en el mismo paquete. Paquetes importados, como <code>fmt</code> en el ejemplo <code>tempconv</code>, se declaran a <em>nivel de archivo</em>, por lo que se puede hacer referencia a partir del mismo archivo, pero no desde otro archivo en el mismo paquete sin otro <code>import</code>. Muchas declaraciones, como la de la variable <code>c</code> en la funcion <code>tempconv.CToF</code>, son <em>locales</em>, por lo que puden ser referidos solo desde dentro de la misma funcion o tal vez solo en una parte de ella.</p>
<p>El alcance de una etiqueta de flujo de control, tal como se utiliza por las sentencias <code>break</code>, <code>continue</code>, y <code>goto</code>, es toda la funcion que la rodea.</p>
<p>Un programa puede contener varias declaraciones del mismo nombre, siempre y cuando cada declaracion este en un bloque lexico diferente. Por ejemplo, puede declarar una variable local con el mismo nombre que una variable a nivel de paquete. O, como se muestra en la <a href="#Seccion-2.3.3" >Seccion 2.3.3</a>, se puede declarar un parametro de funcion llamado <code>new</code>, a pesar de tener una funcion con este nombre declarada con anterioridad en el bloque universo. No exagere, cuanto mayor sea el alcance de la redeclaracion, mas probable es que sorprenda al lector.</p>
<p>Cuando el compilador encuentra una referencia a un nombre, busca una declaracion, comenzando con el bloque lexico interno mas cercano y explorando hasta el bloque universo. Si el compilador no encuentra ninguna declaracion, se informa de un error de <q>nombre no declarado.</q> Si se declara un nombre tanto en un bloque externo como en un bloque interno, se encontrara primero la declaracion interna. En ese caso, se dice que la declaracion interna <em>obscurese</em> u <em>ocultar</em> la exterior, por lo que es inaccesible:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">g</span> <span class="p">=</span> <span class="s">&quot;g&quot;</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="s">&quot;f&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;f&quot;; la variable f local oculta la funcion f a nivel de paquete</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="c1">// &quot;g&quot;; variable a nivel de paquete</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span> <span class="c1">// error de compilacion: sin definir: h</span>
<span class="p">}</span>
</pre></div>
<p>Dentro de una funcion, los bloques lexicos pueden anidarse en una profundidad arbitraria, por lo que una declaracion local puede sombrear a otra. La mayoria de los bloques son creados por construcciones de flujo de control, como las declaraciones <code>if</code> y los bucles <code>for</code>. El programa siguiente tiene tres variables distintas llamadas <code>x</code>, ya que cada declaracion aparece en un bloque lexico diferente. (Este ejemplo ilustra las reglas de alcance, no es un buen estilo de programacion!)</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="s">&quot;hello!&quot;</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="sc">&#39;!&#39;</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;HELLO&quot; (una letra por iteracion)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Las expresiones <code>x[i]</code> y <code>x + 'A' - 'a'</code> se refieren cada una a una declaracion de <code>x</code> a partir de un bloque exterior; Lo explicaremos en un momento. (Tenga en cuenta que esta ultima expresion <em>no</em> es equivalente a <code>unicode.ToUpper</code>).</p>
<p>Como se menciono anteriormente, no todos los bloques lexicos corresponden con secuencias delimitadas explicitamente por llaves; Algunos simplemente son implicitos. El bucle <code>for</code> anterior crea dos bloques lexicos: el bloque explicito para el cuerpo del bucle, y un bloque implicito que adicionalmente encierra las variables declaradas por la clausula de inicializacion, como <code>i</code>. El alcance de una variable declarada en el bloque implicito es la condicion, post-declaracion (<code>i++</code>), y el cuerpo del comunicado <code>for</code>.</p>
<p>El siguiente ejemplo tambien tiene tres variables denominadas <code>x</code>, cada una declarada en un bloque distinto–una en el cuerpo de la funcion, una en un bloque de sentencia <code>for</code> y uno en el cuerpo del bucle–pero solo dos de los bloques son explicitos:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="s">&quot;hello&quot;</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;HELLO&quot; (una letra por iteracion)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Al igual que bucle <code>for</code>, las declaraciones <code>if</code> y <code>switch</code> tambien crean un bloque implicito que, ademas del cuerpo de sus bloques. El codigo en la siguiente cadena <code>if</code>-<code>else</code> muestra el alcance de <code>x</code> y <code>y</code>:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">();</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">y</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// error de compilacion: x y y no son visibles aqui</span>
</pre></div>
<p>La segunda declaracion <code>if</code> esta anidada dentro de la primera, por lo que las variables declaradas dentro de la inicializacion de la primer declaracion son visibles dentro de la segunda. Reglas similares se aplican a cada caso de una sentencia <code>switch</code>: hay un bloque para la condicion y un bloque para cada cuerpo de caso.</p>
<p>En el nivel de paquete, el orden en el que aparecen las declaraciones no tiene ningun efecto en su alcance, por lo que una declaracion puede referirse a si misma, o a otra que le sigue, permitiendonos declarar tipos y funciones recursivos o recursivos mutuamente. Sin embargo, el compilador reportara un error si una declaracion constante o variable se refiere a si misma.</p>
<p>En este programa:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// error de compilacion: sin usar: f</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span> <span class="c1">// error de compilacion: f sin definir</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>    <span class="c1">// error de compilacion: f sin definir</span>
</pre></div>
<p>el alcance de <code>f</code> es solo la sentencia <code>if</code>, por lo que <code>f</code> no es accesible a los estados que despues de enta, lo que resulta en errores de compilacion. Dependiendo del compilador, puede obtener un informe de errores adicional de que la variable local <code>f</code> nunca fue utilizada.</p>
<p>Por lo tanto, a menudo es necesario declarar <code>f</code> antes de la condicion de modo que sea accesible mas tarde:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
</pre></div>
<p>Es posible que se sienta tentado a evitar declarar <code>f</code> y <code>err</code> en el bloque externo moviendo las llamadas a <code>ReadByte</code> y <code>Close</code> dentro del bloque <code>else</code>:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">fname</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// f and err are visible here too</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
  <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>pero una practica normal en Go es tratar con el error en el bloque <code>if</code> y luego regresar, de modo que la ruta de ejecucion exitosa no este indentada.</p>
<p>Las declaracion de variables compacta exige un conocimiento del alcance. Considere el siguiente programa, que comienza obteniendo su directorio de trabajo actual y guardandolo en una variable a nivel de paquete. Esto podria hacerse llamando a <code>os.Getwd</code> en la funcion <code>main</code>, pero podria ser mejor separar esta preocupacion de la logica primaria, sobre todo si no podemos conseguir el directorio, es un error fatal. La funcion <code>log.Fatalf</code> imprime un mensaje y llama <code>os.Exit(1)</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// error de compilacion: sin usar: cwd</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>var cadena cwd</p>
<p>Dado que ni <code>cwd</code> ni <code>err</code> se declaran en el bloque de la funcion <code>init</code>, la sentencia <code>:=</code> declara ambas como variables locales. La declaracion interna de <code>cwd</code> hace que la externa sea inaccesible, por lo que la sentencia no actualiza la variable <code>cdw</code> de nivel de paquete como se pretende.</p>
<p>Los compiladores de Go actuales detectan que la variable local <code>cwd</code> nunca se utilza e informar de esto como un error, pero no son estrictamente necesarias para llevar a cabo esta comprobacion. Por otra parte, un cambio menor, como la adicion de una declaracion de registro que se hace referencia a la <code>cwd</code> local, anularia la comprobacion.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span> <span class="c1">// NOTA: incorrecto!</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Working directory = %s&quot;</span><span class="p">,</span> <span class="nx">cwd</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>La variable global <code>cwd</code> permanece sin inicializar, y la salida del registro aparentemente normal ofusca el fallo.</p>
<p>Hay un numero de maneras de lidiar con este problema potencial. La mas directa es evitar <code>:=</code> declarando <code>err</code> en una declaracion <code>var</code> separada:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">cwd</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
  <span class="nx">cwd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getwd</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;os.Getwd failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Hemos visto como los paquetes, archivos, declaraciones y declaraciones expresan la estructura de los programas. En los proximos dos capitulos, veremos la estructura de los datos.</p>
</div>
<h2 id="Capitulo-3" >Tipos de datos basicos</h2>
<div class="hBody-2" >
<p>En el fondo todo son solo bits, por supuesto, pero las computadoras operan fundamentalmente en numeros de tamaño fijo llamados palabras, que se interpretan como numeros enteros, numeros de punto flotante, conjuntos de bits, o direcciones de memoria, que luego se combinana en agregados mas grandes que representan paquetes, pixeles, carteras, poesia y todo lo demas. Go ofrece una variedad de formas de organizar los datos, con un espectro de tipos de datos que en un extremo coinciden con las caracteristicas del hardware y en el otro extremo proporcionan lo que los programadores necesitan para representar convenientemente estructuras de datos complicadas.</p>
<p>Los tipos de datos de Go se dividen en cuatro categorias: <em>tipos basicos</em>, <em>tipos de agregados</em>, <em>tipos de referencia</em>, y <em>tipos de interfaz</em>. Los tipos basicos, el tema de este capitulo, incluyen numeros, cadenas y booleanos. Los tipos agregados–arreglos (<a href="#Seccion-4.1" >§4.1</a>) y estructuras (<a href="#Seccion-4.4" >§4.4</a>)–forma tipos de datos mas complejos mediante la combinacion de otros valores mas simples. Los tipos de referencia son un grupo diverso, que incluye punteros (<a href="#Seccion-2.3.2" >§2.3.2</a>), slices (<a href="#Seccion-4.2" >§4.2</a>), mapas (<a href="#Seccion-4.3" >§4.3</a>), funciones (<a href="#Capitulo-5" >Capitulo 5</a>), y canales (<a href="#Capitulo-8" >Capitulo 8</a>), pero lo que tienen en comun es que se todos ellos se refieren a variables del programa o estados indirectamente, por lo que el efecto de una operacion que se aplica a una referencia es observado por todas las copias de esa referencia. Por ultimo, hablaremos de los tipos de interfaz en el <a href="#Capitulo-7" >Capitulo 7</a>.</p>
</div>
<h3 id="Seccion-3.1" >Enteros</h3>
<div class="hBody-3" >
<p>Los tipos de datos numericos de Go incluyen varios tamaños de enteros, numeros de coma flotante y numeros complejos. Cada tipo numerico determina el tamaño y la firma de sus valores. Comencemos con numeros enteros.</p>
<p>Go proporciona tanto aritmetica con y sin signo. Hay cuatro tamaños distintos de numeros enteros–8, 16, 32 y 64 bits–representados por los tipos <code>int8</code>, <code>int16</code>, <code>int32</code>, y <code>int64</code>, y las correspondientes versiones sin signo <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, y <code>uint64</code>.</p>
<p>Tambien hay dos tipos llamados simplemente <code>int</code> y <code>uint</code> que son del tamaño natural o mas eficiente para los numeros enteros con y sin signo en una plataforma en particular; <code>int</code> es de lejos el tipo numerico mas utilizado. Ambos tipos tienen el mismo tamaño, 32 o 64 bits, pero uno no debe hacer suposiciones sobre cual es; Diferentes compiladores pueden tomar diferentes opciones incluso en hardware identico.</p>
<p>El tipo <code>rune</code> es un sinonimo de <code>int32</code> y convencionalmente indica que un valor es un punto de codigo Unicode. Los dos nombres pueden utilizarse indistintamente. Del mismo modo, el tipo de <code>byte</code> es un sinonimo de <code>uint8</code>, y hace hincapie en que el valor es una pieza de datos en bruto mas que una pequeña cantidad numerica.</p>
<p>Por ultimo, existe un tipo entero sin signo <code>uintptr</code>, cuya anchura no se especifica, pero es suficiente para contener todos los bits de un valor de puntero. El tipo <code>uintptr</code> solo se utiliza para la programacion a bajo nivel, por ejemplo, en el limite de un programa Go con una libreria C o un sistema operativo. Veremos ejemplos de esto cuando nos ocupemos del paquete <code>unsafe</code> en el <a href="#Capitulo-13" >Capitulo 13</a>.</p>
<p>Independientemente de su tamaño, <code>int</code>, <code>uint</code> y <code>uintptr</code> son diferentes tipos de sus hermanos de tamaño de forma explicita. Por lo tanto <code>int</code> no es el mismo tipo que <code>int32</code>, incluso si el tamaño natural de enteros es de 32 bits, y requiere una conversion explicita utilizar un valor <code>int</code> donde se necesita un <code>int32</code>, y viceversa.</p>
<p>Numeros con signo se representan en forma de complemento a 2, en el que el bit de orden superior esta reservado para el signo del numero y la gama de valores de un numero de <span class="math" >n</span> bits es de -2ⁿ⁻¹ a 2ⁿ⁻¹-1. Los numeros enteros sin signo usan el rango completo de bits para valores no negativos y por lo tanto tienen el rango de 0 a 2ⁿ-1. Por ejemplo, la gama de <code>int8</code> entre -128 y 127, mientras que la gama de <code>uint8</code> es de 0 a 255.</p>
<p>En Go Los operadores binarios de aritmetica, logica y comparacion se enumeran aqui en orden decreciente de precedencia:</p>
<pre class="pre" >*   /   %  &lt;&lt;  &gt;&gt;  &amp;   &amp;^
+   -   |  ^
==  !=  &lt;  &lt;=  &gt;   &gt;=
&amp;&amp;
||</pre>
<p>Solo hay cinco niveles de precedencia para los operadores binarios. Los operadores en el mismo nivel se asocian a la izquierda, por lo que pueden ser necesarios parentesis, para mayor claridad, o para hacer que los operadores evaluan en el orden deseado en una expresion como <code>mask &amp; (1 &lt;&lt; 28)</code>.</p>
<p>Cada operador en las dos primeras lineas de la tabla anterior, por ejemplo <code>+</code>, tiene un operador de asignacion correspondiente como <code>+=</code> que pueden utilizarse para abreviar una instruccion de asignacion.</p>
<p>Los operadores aritmetica enteros <code>+</code>, <code>-</code>, <code>*</code>, y <code>/</code> pueden aplicarse a numeros enteros, de coma flotante, y numeros complejos, pero el operador <code>%</code> solo se aplica a numeros enteros. El comportamiento de <code>%</code> para los numeros negativos varia a traves de los lenguajes de programacion. En Go, el signo del resto es siempre el mismo que el signo del dividendo, por lo <code>-5%3</code> y <code>-5%-3</code> son ambos <code>-2</code>. El comportamiento de <code>/</code> depende de si sus operandos son numeros enteros, por lo que <code>5.0/4.0</code> es <code>1.25</code>, pero <code>5/4</code> es <code>1</code> porque la division entera trunca el resultado hacia cero.</p>
<p>Si el resultado de una operacion aritmetica, ya sea con o sin signo, tiene mas bits de los que pueden ser representados en el tipo del resultado, se dice que se <em>desborda</em>. Los bits de orden superior que no encajan se descartan silenciosamente. Si el numero original es un tipo con signo, el resultado podria ser negativo si el bit mas a la izquierda es un 1, como en el <code>int8</code> ejemplo aqui:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">u</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">255</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">u</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">u</span><span class="o">*</span><span class="nx">u</span><span class="p">)</span> <span class="c1">// &quot;255 0 1&quot;</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int8</span> <span class="p">=</span> <span class="mi">127</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// &quot;127 -128 1&quot;</span>
</pre></div>
<p>Dos numeros enteros del mismo tipo pueden compararse usando los operadores de comparacion binarios siguientes; El tipo de una expresion de comparacion es un booleano.</p>
<table>
<tbody>
<tr><td><code>==</code></td><td>igual a</td></tr>
<tr><td><code>!=</code></td><td>no igual a</td></tr>
<tr><td><code>&lt;</code></td><td>menor que</td></tr>
<tr><td><code>&lt;=</code></td><td>Menor que o igual a</td></tr>
<tr><td><code>&gt;</code></td><td>mayor que</td></tr>
<tr><td><code>&gt;=</code></td><td>Mayor que o igual a</td></tr>
</tbody>
</table>
<p>De hecho, todos los valores de tipo basico–booleanos, numeros y cadenas–son comparables, lo que significa que dos valores del mismo tipo pueden ser comparados con los operadores <code>==</code> y <code>!=</code>. Por otra parte, los numeros enteros, numeros de punto flotante y cadenas son <em>ordenados</em> por los operadores de comparacion. Los valores de muchos otros tipos no son comparables y no se ordenan otros tipos. A medida que nos encontramos cada tipo, vamos a presentar las normas que rigen la comparacion de sus valores.</p>
<p>Tambien hay operadores unarios de suma y resta:</p>
<table>
<tbody>
<tr><td><code>+</code></td><td>Unario positivo (sin efecto)</td></tr>
<tr><td><code>-</code></td><td>Negacion unaria</td></tr>
</tbody>
</table>
<p>Para enteros, <code>+x</code> es una abreviatura de <code>0+x</code> y <code>-x</code> es una abreviatura de <code>0-x</code>; para los numeros de punto flotante y complejos, <code>+x</code> es <code>x</code> y <code>-x</code> es la negacion de <code>x</code>.</p>
<p>Go tambien proporciona los siguientes operadores binarios a nivel de bits, cuyos cuatro primeros tratan a sus operandos como patrones de bits sin ningun concepto aritmetico o signo:</p>
<table>
<tbody>
<tr><td><code>&amp;</code></td><td>AND bit a bit</td></tr>
<tr><td><code>|</code></td><td>OR bit a bit</td></tr>
<tr><td><code>^</code></td><td>XOR bit a bit</td></tr>
<tr><td><code>&amp;^</code></td><td>AND NOT</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>desplazamiento a la izquierdo</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>desplazamiento a la derecha</td></tr>
</tbody>
</table>
<p>El operador bit a bit <code>^</code> es un OR exclusivo (XOR) cuando se utiliza como un operador binario (coloca un uno en cada posicion en donde sus operandos tienen bits distintos, y un cero en donde son iguales), pero cuando se utiliza como un operador de prefijo unario es el complemento a uno; es decir, devuelve un valor con cada bit en su operando invertido. El operador <code>&amp;^</code> es para lipiar bits (AND NOT): en la expresion <code>z = x &amp;^ y</code>, cada bit de <code>z</code> es 0 si el bit correspondiente de <code>y</code> es 1; de lo contrario es igual al bit correspondiente de <code>x</code>.</p>
<p>El siguiente codigo muestra como se pueden utilizar las operaciones a nivel de bit para interpretar un valor <code>uint8</code> como un conjunto compacto y eficiente de 8 bits independientes. Se utiliza el verbo <code>%b</code> de <code>Printf</code> para imprimir los digitos binarios de un numero; <code>08</code> modifica <code>%b</code> (un adverbio!)  para rellenar el resultado con ceros a exactamente 8 digitos.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span>
  <span class="kd">var</span> <span class="nx">y</span> <span class="kt">uint8</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>    <span class="c1">// &quot;00100010&quot;, el conjunto {1, 5}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>    <span class="c1">// &quot;00000110&quot;, el conjunto {1, 2}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &quot;00000010&quot;, la interseccion {1}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">|</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &quot;00100110&quot;, la union {1, 2, 5}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">^</span><span class="nx">y</span><span class="p">)</span>  <span class="c1">// &quot;00100100&quot;, la diferencia simetrica {2, 5}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&amp;^</span><span class="nx">y</span><span class="p">)</span> <span class="c1">// &quot;00100000&quot;, la diferencia {5}</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// prueba de pertenencia</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>   <span class="c1">// &quot;1&quot;, &quot;5&quot;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &quot;01000100&quot;, el conjunto {2, 6}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%08b\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// &quot;00010001&quot;, el conjunto {0, 4}</span>
<span class="p">}</span>
</pre></div>
<p>(La <a href="#Seccion-6.5" >Seccion 6.5</a> muestra una implementacion de conjuntos de numeros enteros que pueden ser mucho mas grande que un byte).</p>
<p>En las operaciones de desplazamiento <code>x&lt;&lt;n</code> y <code>x&gt;&gt;n</code>, el operando <code>n</code> determina el numero de posiciones de bits a cambiar y debe ser sin signo; el operando <code>x</code> puede tener o no signo. Aritmeticamente, el desplazamiento a la izquierda <code>x&lt;&lt;n</code> es equivalente a la multiplicacion por 2ⁿ y un desplazamiento a la derecha <code>x&gt;&gt;n</code> es equivalente a dividir por 2ⁿ.</p>
<p>Los desplazamientos a la izquierda o derecha en enteros sin singno llenan los bits desocupados con ceros, pero los desplazamientos a la derecha de numeros con signo llenan los bits desocupados con copias del bit de signo. Por esta razon, es importante utilizar aritmetica sin signo cuando se esta tratando un entero como un patron de bits.</p>
<p>Aunque Go proporciona aritmetica y numeros sin signo, se tiende a utilizar un int con signo incluso para cantidades que no pueden ser negativas, tales como la longitud de un arreglo, aunque <code>uint</code> puede parecer una eleccion mas obvia. De hecho, la funcion nativa <code>len</code> devuelve un <code>int</code> con signo, como en este bucle que anuncia medallas de premio en el orden inverso:</p>
<div class="highlight"><pre><span></span><span class="nx">medallas</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;oro&quot;</span><span class="p">,</span> <span class="s">&quot;plata&quot;</span><span class="p">,</span> <span class="s">&quot;bronce&quot;</span><span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">medallas</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">medallas</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// &quot;bornce&quot;, &quot;plata&quot;, &quot;oro&quot;</span>
<span class="p">}</span>
</pre></div>
<p>La alternativa seria calamitosa. Si <code>len</code> devuelve un numero sin signo, entonces <code>i</code> tambien seria un <code>uint</code>, y la condicion <code>i &gt;= 0</code> siempre seria verdadera por definicion. Despues de la tercera iteracion, en la cual <code>i == 0</code>, la instruccion <code>i--</code> no haria que <code>i</code> se volviera -1, en cambion seria el valor maximo de <code>uint</code> (es decir, 2⁶⁴-1), y la evaluacion de <code>medallas[i]</code> fallaria en tiempo de ejecucion, o de <em>panico</em> (<a href="#Seccion-5.9" >§5.9</a>), al tratar de acceder a un elemento fuera de los limites del slice.</p>
<p>Por esta razon, los numeros sin signo tienden a utilizarse solo cuando se requieren sus operadores bit a bit u operadores aritmeticos peculiares, como cuando se implementan conjuntos de bits, se analizan formatos binarios de archivos o se usan hash y criptografia. Normalmente no se usan para cantidades meramente no negativas.</p>
<p>En general, se requiere una conversion explicita para convertir un valor de un tipo a otro, y los operadores binarios para aritmetica y logica (excepto los desplazamientos) deben tener operandos del mismo tipo. Aunque esto resulta ocasionalmente en expresiones mas largas, tambien elimina toda una clase de problemas y hace que los programas sean mas faciles de entender.</p>
<p>Como ejemplo familiar de otros contextos, considere esta secuencia:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">manzanas</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">naranjas</span> <span class="kt">int16</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">var</span> <span class="nx">compota</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">manzanas</span> <span class="o">+</span> <span class="nx">naranjas</span> <span class="c1">// Error de compiacion</span>
</pre></div>
<p>Al intentar compilar estas tres declaraciones se genera un mensaje de error:</p>
<pre class="pre" >invalid operation: manzanas + naranjas (mismatched types int32 and int16)</pre>
<p>Este tipo de incompatibilidad se puede corregir de varias maneras, mas directamente convirtiendo todo a un tipo comun:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">compota</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">manzanas</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">naranjas</span><span class="p">)</span>
</pre></div>
<p>Como se describe en la <a href="#Seccion-2.5" >Seccion 2.5</a>, para cada tipo <code>T</code>, la operacion de conversion <code>T(x)</code> convierte el valor <code>x</code> a tipo <code>T</code> si se permite la conversion. Muchas conversiones de entero a entero no implican ningun cambio en el valor; Solo le dicen al compilador como interpretar un valor. Pero una conversion que reduce un entero grande a uno mas pequeño o una conversion de entero a punto flotante o viceversa, puede cambiar el valor o perder precision:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span> <span class="o">:=</span> <span class="mf">3.141</span>          <span class="c1">// un float64</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>   <span class="c1">// &quot;3.141 3&quot;</span>
<span class="nx">f</span> <span class="p">=</span> <span class="mf">1.99</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// &quot;1&quot;</span>
</pre></div>
<p>La conversion de float a entero descarta cualquier parte fraccional, truncando hacia cero. Debe evitar las conversiones en las que el operando este fuera del rango del tipo destino, ya que el comportamiento depende de la implementacion:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span> <span class="o">:=</span> <span class="mf">1e100</span>  <span class="c1">// un float64</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// el resultado depende de la implementacion</span>
</pre></div>
<p>Los literales enteros de cualquier tamaño y tipo se pueden escribir como numeros decimales ordinarios, o bien con numeros octales si comienzan con <code>0</code>, como en <code>0666</code>, o como hexadecimal si comienzan con <code>0x</code> o <code>0X</code>, como en <code>0xdeadbeef</code>. Los digitos hexadecimales pueden ser mayusculas o minusculas. Hoy en dia los numeros octales parecen ser utilizados para exactamente un proposito–permisos de archivo en sistemas POSIX–pero los numeros hexadecimales se utilizan ampliamente para enfatizar el patron de bits de un numero sobre su valor numerico.</p>
<p>Al imprimir numeros usando el paquete <code>fmt</code>, podemos controlar la base y el formato con los verbos <code>%d</code>, <code>%o</code>, y <code>%x</code>, como se muestra en este ejemplo:</p>
<div class="highlight"><pre><span></span><span class="nx">o</span> <span class="o">:=</span> <span class="mo">0666</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %[1]o %#[1]o\n&quot;</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span> <span class="c1">// &quot;438 666 0666&quot;</span>
<span class="nx">x</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="c1">// Salida:</span>
<span class="c1">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span>
</pre></div>
<p>Observe el uso de dos trucos de <code>fmt</code>. Por lo general, una cadena de formato <code>Printf</code> que contiene multiples verbos <code>%</code> requeriria el mismo numero de operandos adicionales, pero los <q>adverbios</q> <code>[1]</code> despues de <code>%</code> le indican a <code>Printf</code> utilizar el primer operando una y otra vez. En segundo lugar, el adverbio <code>#</code> enr <code>%o</code> o <code>%x</code> o <code>%X</code> indica a <code>Printf</code> emitir un prefijo <code>0</code> o <code>0x</code> o <code>0X</code> respectivamente.</p>
<p>Las literales de runa se escriben como un caracter entre comillas simples. El ejemplo mas simple es un caracter ASCII como <code>'a'</code>, pero es posible escribir cualquier punto de codigo Unicode directamente o con escapes numericos, como veremos en breve.</p>
<p>Las runas se imprimen con <code>%c</code>, o con <code>%q</code> si se desea citar:</p>
<div class="highlight"><pre><span></span><span class="nx">ascii</span> <span class="o">:=</span> <span class="sc">&#39;a&#39;</span>
<span class="nx">unicode</span> <span class="o">:=</span> <span class="sc">&#39;𢉩&#39;</span>
<span class="nx">newline</span> <span class="o">:=</span> <span class="sc">&#39;\n&#39;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %[1]c %[1]q\n&quot;</span><span class="p">,</span> <span class="nx">ascii</span><span class="p">)</span>   <span class="c1">// &quot;97 un &#39;a&#39;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %[1]c %[1]q\n&quot;</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">)</span> <span class="c1">// &quot;22269 𢉩 &#39;𢉩&#39;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %[1]q\n&quot;</span><span class="p">,</span> <span class="nx">newline</span><span class="p">)</span>       <span class="c1">// &quot;10 &#39;\n&#39;&quot;</span>
</pre></div>
</div>
<h3 id="Seccion-3.2" >Numeros de punto flotante</h3>
<div class="hBody-3" >
<p>Go ofrece dos tamaños de numeros de punto flotante, <code>float32</code> y <code>float64</code>. Sus propiedades aritmeticas se rigen por el estandar IEEE 754 implementado por todas las CPUs modernas.</p>
<p>Los valores de estos tipos numericos varian de pequeño a enorme. Los limites de valores de coma flotante se pueden encontrar en el paquete <code>math</code>. La constante <code>math.MaxFloat32</code>, el mayor valor de <code>float32</code>, es cerca de <code>3.4e38</code> y <code>math.MaxFloat64</code> es <code>1.8e308</code>. Los valores positivos mas pequeños son <code>1.4e-45</code> y <code>4.9e-324</code>, respectivamente.</p>
<p>Un <code>float32</code> proporciona aproximadamente seis digitos decimales de precision, mientras que un <code>float64</code> proporciona alrededor de 15 digitos; <code>float64</code> debe ser preferido para la mayoria de los propositos porque los calculos sobre <code>float32</code> acumulan errores rapidamente a menos que sea bastante cuidadoso, y el numero entero positivo mas pequeño que no se puede representar exactamente como <code>float32</code> no es grande:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">16777216</span> <span class="c1">// 1 &lt;&lt; 24</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span> <span class="o">==</span> <span class="nx">f</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c1">// &quot;true&quot;!</span>
</pre></div>
<p>Los numeros de punto flotante se pueden escribir literalmente usando decimales, asi:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">e</span> <span class="p">=</span> <span class="mf">2.71828</span> <span class="c1">// (aproximadamente)</span>
</pre></div>
<p>Pueden omitirse los digitos antes del punto decimal (<code>.707</code>) o despues de el (<code>1.</code>). Es mejor escribir numeros muy pequeños o muy grandes en notacion cientifica, con la letra <code>e</code> o <code>E</code> precediendo el exponente decimal:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">Avogadro</span> <span class="p">=</span> <span class="mf">6.02214129e23</span>
<span class="kd">const</span> <span class="nx">Planck</span>   <span class="p">=</span> <span class="mf">6.62606957e-34</span>
</pre></div>
<p>Los Valores de coma flotante se imprimen convenientemente con el verbo <code>%g</code> de <code>Printf</code>, que elige la representacion mas compacta con la precision adecuada, pero para las tablas de datos, es mas adecuado el formato <code>%e</code> (exponente) o %f (sin exponente). Los tres verbos permiten controlar el ancho del campo y la precision numerica.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;x = %d eˣ = %8.3f\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Exp</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
<span class="p">}</span>
</pre></div>
<p>El codigo anterior imprime las potencias de <em>e</em> con tres digitos decimales de precision, alineados en un campo de ocho caracteres:</p>
<pre class="pre" >x = 0 eˣ =    1.000
x = 1 eˣ =    2.718
x = 2 eˣ =    7.389
x = 3 eˣ =   20.086
x = 4 eˣ =   54.598
x = 5 eˣ =  148.413
x = 6 eˣ =  403.429
x = 7 eˣ = 1096.633</pre>
<p>Ademas de una gran coleccion de las funciones matematicas comunes, el paquete <code>math</code> tiene funciones para crear y detectar los valores especiales definidas por IEEE 754: los infinitos positivo y negativo, que representan los numeros de magnitud excesiva y el resultado de la division por cero; y NaN (<q>not a number</q>), el resultado de operaciones matematicamente dudosas como <code>0/0</code> o [Sqrt(-1)].</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">z</span> <span class="kt">float64</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="nx">z</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="nx">z</span><span class="p">,</span> <span class="nx">z</span><span class="o">/</span><span class="nx">z</span><span class="p">)</span> <span class="c1">// &quot;0 -0 +Inf -Inf NaN&quot;</span>
</pre></div>
<p>La funcion <code>math.IsNaN</code> prueba si su argumento es un valor no-numerico, y <code>math.NaN</code> devuelve ese valor. Es tentador utilizar NaN como un valor centinela en un calculo numerico, pero probar si el resultado de un calculo especifico es igual NaN esta lleno de peligros, ya que cualquier comparacion con NaN <em>siempre</em> produce <code>false</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">nan</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">NaN</span><span class="p">()</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">nan</span> <span class="o">==</span> <span class="nx">nan</span><span class="p">,</span> <span class="nx">nan</span> <span class="p">&lt;</span> <span class="nx">nan</span><span class="p">,</span> <span class="nx">nan</span> <span class="p">&gt;</span> <span class="nx">nan</span><span class="p">)</span> <span class="c1">// &quot;false false false&quot;</span>
</pre></div>
<p>Si una funcion que devuelve un resultado de coma flotante puede fallar, es mejor informar el error por separado, como aqui:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">compute</span><span class="p">()</span> <span class="p">(</span><span class="nx">value</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="nx">failed</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>El siguiente programa ilustra el calculo de graficos en coma flotante. Se traza una funcion de dos variables <code>z = f(x, y)</code> como una superficie de malla de alambre 3-D, utilizando graficos vectoriales escalables (SVG), en notacion XML estandar para dibujos lineales. La Figura 3.1 muestra un ejemplo de salida de la funcion <code>sin(r)/r</code>, donde <code>r</code> es <code>sqrt(x*x+y*y)</code>.</p>
<div class="figure" >
<p class="title">Figura 3.1. Un grafico superficial de la funcion <code>sin(r)/r</code>.</p>
<figure>
<img src="img/Figure-3.1.jpg" />
</figure>
</div>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/surface/main.go" >gopl.io/ch3/surface</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Surface calcula una representacion SVG de una funcion de superficie 3D</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="p">=</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">320</span>            <span class="c1">// tamaño de la superficie en pixeles</span>
  <span class="nx">cells</span>         <span class="p">=</span> <span class="mi">100</span>                 <span class="c1">// numero de celdas de la cuadricula</span>
  <span class="nx">xyrange</span>       <span class="p">=</span> <span class="mf">30.0</span>                <span class="c1">// ejes (-xyrange..+xyrange)</span>
  <span class="nx">xyscale</span>       <span class="p">=</span> <span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="nx">xyrange</span> <span class="c1">// pixeles por unidad x o y</span>
  <span class="nx">zscale</span>        <span class="p">=</span> <span class="nx">height</span> <span class="o">*</span> <span class="mf">0.4</span>        <span class="c1">// pixeles por unidad z</span>
  <span class="nx">angle</span>         <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span> <span class="o">/</span> <span class="mi">6</span>         <span class="c1">// angulo de ejes x, y (=30°)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">sin30</span><span class="p">,</span> <span class="nx">cos30</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">angle</span><span class="p">),</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Cos</span><span class="p">(</span><span class="nx">angle</span><span class="p">)</span> <span class="c1">// sin(30°), cos(30°)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &quot;</span><span class="o">+</span>
    <span class="s">&quot;style=&#39;stroke: grey; fill: white; stroke-width: 0.7&#39; &quot;</span><span class="o">+</span>
    <span class="s">&quot;width=&#39;%d&#39; height=&#39;%d&#39;&gt;&quot;</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">cells</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">cells</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">ax</span><span class="p">,</span> <span class="nx">ay</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">bx</span><span class="p">,</span> <span class="nx">by</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span> <span class="o">:=</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;&lt;polygon points=&#39;%g,%g %g,%g %g,%g %g,%g&#39;/&gt;\n&quot;</span><span class="p">,</span>
        <span class="nx">ax</span><span class="p">,</span> <span class="nx">ay</span><span class="p">,</span> <span class="nx">bx</span><span class="p">,</span> <span class="nx">by</span><span class="p">,</span> <span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;&lt;/svg&gt;&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">corner</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Hallar el punto (x,y) en la esquina de la celda (i,j).</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="nx">xyrange</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">/</span><span class="nx">cells</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nx">xyrange</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span><span class="o">/</span><span class="nx">cells</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

  <span class="c1">// Calcular la altura de la superficie z.</span>
  <span class="nx">z</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>

  <span class="c1">// Proyeccion isometrica (x,y,z) sobre superficie SVG 2-D (sx,sy).</span>
  <span class="nx">sx</span> <span class="o">:=</span> <span class="nx">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="nx">y</span><span class="p">)</span><span class="o">*</span><span class="nx">cos30</span><span class="o">*</span><span class="nx">xyscale</span>
  <span class="nx">sy</span> <span class="o">:=</span> <span class="nx">height</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span><span class="o">*</span><span class="nx">sin30</span><span class="o">*</span><span class="nx">xyscale</span> <span class="o">-</span> <span class="nx">z</span><span class="o">*</span><span class="nx">zscale</span>
  <span class="k">return</span> <span class="nx">sx</span><span class="p">,</span> <span class="nx">sy</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// distancia de (0,0)</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Observe que la esquina de funcion devuelve dos valores, las coordenadas de la esquina de la celda.</p>
<p>La explicacion de como funciona el programa requiere solo geometria basica, pero esta bien pasarla por alto, ya que el punto es ilustrar la computacion de punto flotante. La esencia del programa es el mapeo entre tres sistemas de coordenadas diferentes, como se muestra en la Figura 3.2. La primera es una red de 2D de 100 y 100 celdas identificadas por coordenadas enteras <span class="math" >(i, j)</span>, a partir de <span class="math" >(0, 0)</span> en la esquina mas lejanas. Trazamos desde la parte posterior al frente de modo que los poligonos del fondo puedan ser oscurecidos por los primeros.</p>
<p>El segundo sistema de coordenadas es una malla de coordenadas 3-D de punto flotante <span class="math" >(x, y, z)</span>, donde <span class="math" >x</span> e <span class="math" >y</span> son funciones lineales de <span class="math" >i</span> y <span class="math" >j</span>, traducido de manera que el origen esta en el centro, y escalado por la constante <code>xyrange</code>. La altura <span class="math" >z</span> es el valor de la funcion de superficie <span class="math" >ƒ(x, y)</span>.</p>
<p>El tercer sistema de coordenadas es la superficie 2-D de la imagen, con <span class="math" >(0, 0)</span> en la esquina superior izquierda. Los puntos en este plano se denotan <span class="math" >(sx, sy)</span>. Utilizamos una proyeccion isometrica para correlacionar cada punto 3D</p>
<div class="figure" >
<p class="title">Figura 3.2. Tres sistemas de coordenadas diferentes.</p>
<figure>
<img src="img/Figure-3.2.jpg" />
</figure>
</div>
<p><span class="math" >(x, y, z)</span> sobre la superficie 2-D. Un punto aparece mas a la derecha en la superficie cuanto mayor sera su valor <span class="math" >x</span> o menor sea su valor <span class="math" >y</span>. Y un punto aparece mas abajo en la superficie cuanto mayor sera su valor <span class="math" >x</span> o el valor <span class="math" >y</span>, y cuanto menor sea su valor <span class="math" >z</span>. Los factores de escala horizontal o vertical para <span class="math" >x</span> e <span class="math" >y</span> se derivan del seno y coseno de un angulo de 30°. El factor de escala para <span class="math" >z</span>, 0.4, es un parametro arbitrario.</p>
<p>Para cada celda de la cuadricula 2-D, la funcion principal calcula las coordenadas en la superficie de imagen de las cuatro esquinas del poligono ABCD, donde B corresponde a <span class="math" >(i, j)</span> y A, C, y D son sus vecinos, entonces imprime una instruccion SVG para dibujarla.</p>
<p><b>Ejercicio 3.1</b>: Si la funcion <code>f</code> devuelve un valor <code>float64</code> no-finito, el archivo SVG contendra elementos <code>&lt;polygon&gt;</code> no validos (aunque muchos procesadores SVG manejan esto con gracia). Modifique el programa para omitir poligonos no validos.</p>
<p><b>Ejercicio 3.2</b>: Experimente con visualizaciones de otras funciones del paquete <code>math</code>. ¿Puede usted producir una caja de huevos, moguls, o una montura?</p>
<p><b>Ejercicio 3.3</b>: El color de cada poligono en funcion de su altura, por lo que los picos son de color rojo (<code>#ff0000</code>) y los valles azul (<code>#0000ff</code>).</p>
<p><b>Ejercicio 3.4</b>: Siguiendo el enfoque del ejemplo Lissajous en la <a href="#Seccion-1.7" >Seccion 1.7</a>, construya un servidor web que calcule superficies y escriba los datos SVG al cliente. El servidor debe establecer el manejador <code>Content-Type</code> asi:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span><span class="p">.</span><span class="nx">Header</span><span class="p">().</span><span class="nx">Set</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">,</span> <span class="s">&quot;image/svg+xml&quot;</span><span class="p">)</span>
</pre></div>
<p>(Este paso no era necesario en el ejemplo de Lissajous porque el servidor utiliza la heuristica estandar para reconocer formatos comunes como PNG de los primeros 512 bytes de la respuesta y generar el encabezado adecuado). Permitir al cliente especificar valores como altura, ancho y color como parametros de peticion HTTP.</p>
</div>
<h3 id="Seccion-3.3" >Numeros complejos</h3>
<div class="hBody-3" >
<p>Go proporciona dos tamaños de numeros complejos, <code>complex64</code> y <code>complex128</code>, cuyos componentes son <code>float32</code> y <code>float64</code> respectivamente. La funcion nativa <code>complex</code> crea un numero complejo a partir de sus componentes real e imaginario, e incorpora funciones <code>real</code> y <code>imag</code> para extraer estos componentes:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 1+2i</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// 3+4i</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>                 <span class="c1">// &quot;(-5+10i)&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">))</span>           <span class="c1">// &quot;-5&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">imag</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">))</span>           <span class="c1">// &quot;10&quot;</span>
</pre></div>
<p>Si un punto flotante literal entero o decimal literal es seguido inmediatamente por <code>i</code>, como <code>3.141592i</code> o <code>2i</code>, se convierte en un literal imaginario, que denota un numero complejo con un componente real cero:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="m">1i</span> <span class="o">*</span> <span class="m">1i</span><span class="p">)</span> <span class="c1">// &quot;(-1+0i)&quot;, i² = -1</span>
</pre></div>
<p>Bajo las reglas de la aritmetica constante, constantes complejas se pueden añadir a otras constantes (enteras o de coma flotante, real o imaginarias), lo que nos permite escribir numeros complejos de forma natural, como <code>1+2i</code>, o equivalentemente, <code>2i+1</code> . Las anteriores declaraciones <code>x</code> y <code>y</code> se pueden simplificar:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">+</span> <span class="m">2i</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="mi">3</span> <span class="o">+</span> <span class="m">4i</span>
</pre></div>
<p>Los numeros complejos se pueden comparar por igualdad con <code>==</code> y <code>!=</code>. Dos numeros complejos son iguales si sus partes reales son iguales y sus partes imaginarias son iguales.</p>
<p>El paquete <code>math/cmplx</code> proporciona funciones de libreria para trabajar con numeros complejos, tales como las raiz cuadrada compleja y las funciones de exponenciacion.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cmplx</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// &quot;(0+1i)&quot;</span>
</pre></div>
<p>El siguiente programa utiliza aritmetica <code>complex128</code> para generar un conjunto de Mandelbrot.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/mandelbrot/main.go" >gopl.io/ch3/mandelbrot</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Mandelbrot emite una imagen PNG del fractal de Mandelbrot.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;image&quot;</span>
  <span class="s">&quot;image/color&quot;</span>
  <span class="s">&quot;image/png&quot;</span>
  <span class="s">&quot;math/cmplx&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">xmin</span><span class="p">,</span> <span class="nx">ymin</span><span class="p">,</span> <span class="nx">xmax</span><span class="p">,</span> <span class="nx">ymax</span> <span class="p">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span>
    <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span>          <span class="p">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span>
  <span class="p">)</span>

  <span class="nx">img</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">NewRGBA</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">py</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">py</span> <span class="p">&lt;</span> <span class="nx">height</span><span class="p">;</span> <span class="nx">py</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">py</span><span class="p">)</span><span class="o">/</span><span class="nx">height</span><span class="o">*</span><span class="p">(</span><span class="nx">ymax</span><span class="o">-</span><span class="nx">ymin</span><span class="p">)</span> <span class="o">+</span> <span class="nx">ymin</span>
    <span class="k">for</span> <span class="nx">px</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">px</span> <span class="p">&lt;</span> <span class="nx">width</span><span class="p">;</span> <span class="nx">px</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">px</span><span class="p">)</span><span class="o">/</span><span class="nx">width</span><span class="o">*</span><span class="p">(</span><span class="nx">xmax</span><span class="o">-</span><span class="nx">xmin</span><span class="p">)</span> <span class="o">+</span> <span class="nx">xmin</span>
      <span class="nx">z</span> <span class="o">:=</span> <span class="nb">complex</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
      <span class="c1">// El punto de imagen (px, py) representa el valor complejo z.</span>
      <span class="nx">img</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">px</span><span class="p">,</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">mandelbrot</span><span class="p">(</span><span class="nx">z</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">png</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">img</span><span class="p">)</span> <span class="c1">// NOTA: ignorando errores</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mandelbrot</span><span class="p">(</span><span class="nx">z</span> <span class="kt">complex128</span><span class="p">)</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Color</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">iterations</span> <span class="p">=</span> <span class="mi">200</span>
  <span class="kd">const</span> <span class="nx">contrast</span> <span class="p">=</span> <span class="mi">15</span>

  <span class="kd">var</span> <span class="nx">v</span> <span class="kt">complex128</span>
  <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">iterations</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="o">*</span><span class="nx">v</span> <span class="o">+</span> <span class="nx">z</span>
    <span class="k">if</span> <span class="nx">cmplx</span><span class="p">.</span><span class="nx">Abs</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Gray</span><span class="p">{</span><span class="mi">255</span> <span class="o">-</span> <span class="nx">contrast</span><span class="o">*</span><span class="nx">n</span><span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Black</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los dos bucles anidados iteran sobre cada punto en una imagen en cuadricula de escala de grises de 1024x1024 que representa la porcion de -2 a +2 del plano complejo. El programa prueba si repetidamente cuadrando y añadiendo el numero del punto representado eventualmente <q>escapa</q> el circulo de radio 2. Si es asi, el punto es sombreado por el numero de iteraciones que se tardo en escapar. Si no, el valor pertenece al conjunto de Mandelbrot, y el punto permanece negro. Finalmente, el programa escribe en su salida estandar la imagen codificada en PNG del iconico fractal, que se muestra en la Figura 3.3.</p>
<div class="figure" >
<p class="title">Figura 3.3. El conjunto de Mandelbrot.</p>
<figure>
<img src="img/Figure-3.3.jpg" />
</figure>
</div>
<p><b>Ejercicio 3.5</b>: Implementar a todo color el cojunto de Mandelbrot usando la funcion <code>image.NewRGBA</code> y el tipo <code>color.RGBA</code> o <code>color.YCbCr</code>.</p>
<p><b>Ejercicio 3.6</b>: Supermuestreo es una tecnica para reducir el efecto de pixelacion calculando el valor del color en varios puntos dentro de cada pixel y tomando el promedio. El metodo mas simple consiste en dividir cada pixel en cuatro <q>subpixeles.</q> Implementalo.</p>
<p><b>Ejercicio 3.7</b>: Otro fractal sencillo utiliza el metodo Newton para encontrar soluciones complejas a una funcion como <span class="math" >z⁴-1 = 0</span>. Sombrea cada punto de partida por el numero de iteraciones necesarias para acercarse a una de las cuatro raices. Colorea cada punto por la raiz que se aproxima.</p>
<p><b>Ejercicio 3.8</b>: La Representacion de fractales con altos niveles de zoom exige una gran precision aritmetica. Implementa el mismo fractal utilizando cuatro representaciones diferentes de numeros: <code>complex64</code>, <code>complex128</code>, <code>big.Float</code>, y <code>big.Rat</code>. (Los ultimos dos tipos se encuentran en el paquete <code>math/big</code>. <code>Float</code> utiliza arbitraria, pero delimitada precision de punto flotante; <code>Rat</code> utiliza numeros racionales sin limites de precision.)  ¿Como se comparan en el rendimiento y uso de memoria? ¿A que niveles de zoom se hacen visibles los artefactos de renderizacion?</p>
<p><b>Ejercicio 3.9</b>: Escriba un servidor web que procese fractales y escribe los datos de imagen al cliente. Permita que el cliente especifique las coordenadas <code>x</code>, <code>y</code>, y los valores de zoom como parametros en la peticion HTTP.</p>
</div>
<h3 id="Seccion-3.4" >Booleanos</h3>
<div class="hBody-3" >
<p>Un valor de tipo <code>bool</code>, o <em>booleano</em>, tiene solo dos valores posibles, <code>true</code> y <code>false</code>. Las condiciones en <code>if</code> y <code>for</code> son declaraciones booleanas, y los operadores de comparacion como <code>==</code> y <code>&lt;</code> producen un resultado booleano. El operador unario <code>!</code> es la negacion logica, de modo que <code>!true</code> es <code>false</code>, o, por decirlo asi, <code>(!true==false)==true</code>, aunque por cuestion de estilo, siempre simplificamos las expresiones booleanas redundantes como <code>x==true</code> a <code>x</code>.</p>
<p>Los valores booleanos pueden ser combinados con los operadores <code>&amp;&amp;</code> (AND) y <code>||</code> (OR), que tienen un comportamiento de <em>cortocircuito</em>: si la respuesta ya esta determinada por el valor del operando de la izquierda, el operando de la derecha no se evalua, por lo que es seguro para escribir expresiones como esta:</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span>
</pre></div>
<p>donde <code>s[0]</code> produciria un panico si se aplica a una cadena vacia.</p>
<p>Ya que <code>&amp;&amp;</code> tiene mayor precedencia que <code>||</code> (mnemonico: <code>&amp;&amp;</code> es la multiplicacion booleana, <code>||</code> es la adicion boolean), no se requieren parentesis para las condiciones de esta forma:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="o">||</span>
  <span class="sc">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span> <span class="o">||</span>
  <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">{</span>
  <span class="c1">// ...letra o digito ASCII...</span>
<span class="p">}</span>
</pre></div>
<p>No hay una conversion implicita de un valor booleano a un valor numerico como 0 o 1, o viceversa. Es necesario utilizar un <code>if</code> explicito, como en</p>
<div class="highlight"><pre><span></span><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
  <span class="nx">i</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>
<p>Podria valer la pena escribir una funcion de conversion si esta operacion se necesita a menudo:</p>
<div class="highlight"><pre><span></span><span class="c1">// btoi regresa 1 si b es verdadero y 0 sy es falso.</span>
<span class="kd">func</span> <span class="nx">btoi</span><span class="p">(</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
<p>La operacion inversa es tan simple que no necesita una funcion, pero por simetria aqui esta:</p>
<div class="highlight"><pre><span></span><span class="c1">// itob reporta cuando i no es cero.</span>
<span class="kd">func</span> <span class="nx">itob</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>
</pre></div>
</div>
<h3 id="Seccion-3.5" >Cadenas</h3>
<div class="hBody-3" >
<p>Una cadena es una secuencia inmutable de bytes. Las cadenas pueden contener datos arbitrarios, incluyendo bytes con valor 0, pero normalmente contienen texto legible por humanos. Las cadenas de texto se interpretan de forma convencional como secuencias codificadas en UTF-8 de puntos de codigo Unicode (runas), que exploraremos en detalle muy pronto.</p>
<p>La funcion nativa <code>len</code> devuelve el numero de bytes (no runas) en una cadena, y la operacion de indice <code>s[i]</code> recupera el <span class="math" >n</span>-esimo byte de la cadena <code>s</code>, donde <code>0</code> ≤ <code>i</code> &lt; <code>len(s)</code>.</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;hello, world&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>     <span class="c1">// &quot;12&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="c1">// &quot;104 119&quot;  (&#39;h&#39; and &#39;w&#39;)</span>
</pre></div>
<p>Intentar acceder a un byte fuera de este rango produce un panico:</p>
<div class="highlight"><pre><span></span><span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span> <span class="c1">// panico: indice fuera de rango</span>
</pre></div>
<p>El <span class="math" >n</span>-esimo byte de una cadena no es necesariamente el <span class="math" >n</span>-esimo caracter de una cadena, porque la codificacion UTF-8 de un punto de codigo no ASCII requiere dos o mas bytes. Como Trabajar con caracteres se discutira en breve.</p>
<p>La operacion de subcadena <code>s[i:j]</code> produce una nueva cadena que consta de los bytes de la cadena original a partir del indice <code>i</code> y continua hasta, pero no incluyendo, el byte en el indice <code>j</code>. El resultado contiene <code>j-i</code> bytes.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>
<p>De nuevo, se produce un panico si cualquiera de los indices esta fuera de limite o si <code>j</code> es menor que <code>i</code>.</p>
<p>Cualquiera o ambos operandos <code>i</code> y <code>j</code> pueden omitirse, en cuyo caso los valores por defecto son 0 (el inicio de la cadena) y <code>len(s)</code> (su final), respectivamente.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// &quot;hello&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">7</span><span class="p">:])</span> <span class="c1">// &quot;world&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span>  <span class="c1">// &quot;hello, world&quot;</span>
</pre></div>
<p>El operador c(+) crea una nueva cadena mediante la concatenacion de dos cadenas:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;goodbye&quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span> <span class="c1">// &quot;goodbye, world&quot;</span>
</pre></div>
<p>Las cadenas pueden compararse con los operadores de comparacion como <code>==</code> y <code>&lt;</code>; La comparacion se realiza byte a byte, por lo que el resultado es el orden lexicografico natural.</p>
<p>Los valores de cadena son inmutables: la secuencia de bytes contenidos en un valor de cadena no se puede cambiar, aunque, por supuesto, podemos asignar un nuevo valor a una variable de cadena. Para añadir una cadena a otra, por ejemplo, podemos escribir</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;left foot&quot;</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="nx">s</span>
<span class="nx">s</span> <span class="o">+=</span> <span class="s">&quot;, right foot&quot;</span>
</pre></div>
<p>Esto no modifica la cadena que retenia <code>s</code> originalmente, pero hace que <code>s</code> contenga la nueva cadena formada por la sentencia <code>+=</code>; Mientras tanto, <code>t</code> aun contiene la cadena antigua.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;left foot, right foot&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// &quot;left foot&quot;</span>
</pre></div>
<p>Dado que las cadenas son inmutables, no se permiten las construcciones que intentan modificar los datos de una cadena en su lugar:</p>
<div class="highlight"><pre><span></span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;L&#39;</span> <span class="c1">// error de compilacion: no se puede asignar a s[0]</span>
</pre></div>
<p>Inmutabilidad significa que es seguro que dos copias de una cadena compartan la misma memoria subyacente, por lo que es barato copiar cadenas de cualquier longitud. Del mismo modo, una cadena <code>s</code> y una subcadena como <code>s[7:]</code> pueden compartir de forma segura los mismos datos, por lo que la operacion subcadena tambien es barata. No se asigna ninguna memoria nueva en ningun caso. La Figura 3.4 ilustra la disposicion de una cadena y dos de sus subcadenas que comparten el mismo arreglo de bytes subyacente.</p>
<div class="figure" >
<p class="title">Figura 3.4. La cadena <code>&quot;hello, world&quot;</code> y dos subcadenas.</p>
<figure>
<img src="img/Figure-3.4.jpg" />
</figure>
</div>
</div>
<h4 id="Seccion-3.5.1" >Cadenas Literales</h4>
<div class="hBody-4" >
<p>Un valor de cadena se puede escribir como una <em>cadena literal</em>, una secuencia de bytes entre comillas dobles:</p>
<div class="highlight"><pre><span></span><span class="s">&quot;Hello, 世界&quot;</span>
</pre></div>
<p>Debido a que los archivos fuente de Go siempre estan codificados en UTF-8 y las cadenas de texto Go son interpretadas convencionalmente como UTF-8, podemos incluir puntos de codigo Unicode en literales de cadena.</p>
<p>Dentro de una literal de cadena entre comillas dobles, las secuencias de escape que comienzan con una barra invertida <code>\</code> se pueden utilizar para insertar valores arbitrarios de bytes en la cadena. Un conjunto de escape maneja codigos de control ASCII como newline, retorno de carro y tabulacion:</p>
<table>
<tbody>
<tr><td><code>\a</code></td><td><q>alerta</q> o campana</td></tr>
<tr><td><code>\b</code></td><td>retroceso</td></tr>
<tr><td><code>\f</code></td><td>form feed</td></tr>
<tr><td><code>\n</code></td><td>linea nueva</td></tr>
<tr><td><code>\r</code></td><td>retorno de carro</td></tr>
<tr><td><code>\t</code></td><td>tabulador</td></tr>
<tr><td><code>\v</code></td><td>tabulador vertical</td></tr>
<tr><td><code>\'</code></td><td>comilla simple (solo en la runa literal '\'')</td></tr>
<tr><td><code>\&quot;</code></td><td>comillas dobles (solo dentro de &quot;...&quot; literales)</td></tr>
<tr><td><code>\\</code></td><td>barra invertida</td></tr>
</tbody>
</table>
<p>Los bytes arbitrarios tambien se pueden incluir en cadenas literales usando escapes hexadecimales u octales. Un escape hexadecimal se escribe <code>\x</code><em>hh</em>, con exactamente dos digitos hexadecimales <em>h</em> (en mayusculas o minusculas). Un escape octal se escribe <em>\ooo</em> con exactamente tres digitos octales <em>o</em> (0 a 7) no superior a <code>\377</code>. Ambos denotan un solo byte con el valor especificado. Mas adelante, veremos como codificar numericamente los puntos de codigo Unicode en literales de cadena.</p>
<p>Una <em>literal de cadena sin formato</em> se escribe <code>`...`</code>, utilizando comillas inversas en lugar de comillas dobles. Dentro de una literal de cadena sin formato, no se procesan secuencias de escape; Los contenidos se toman literalmente, incluyendo barras invertidas y lineas nuevas, por lo que un literal de cadena sin formato puede extenderse por varias lineas en el codigo del programa. El unico procesamiento es que los retornos de carro se eliminan para que el valor de la cadena sea el mismo en todas las plataformas, incluidas aquellas que convencionalmente ponen retornos de carro en archivos de texto.</p>
<p>Las literales de cadenas sin formato son una manera conveniente de escribir expresiones regulares, que tienden a tener un monton de barras inversas. Tambien son utiles para plantillas HTML, literales JSON, mensajes de uso de comandos y similares, que a menudo se extienden sobre varias lineas.</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">GoUsage</span> <span class="p">=</span> <span class="s">`Go is a tool for managing Go source code.</span>

<span class="s">Usage:</span>
<span class="s">    go command [arguments]</span>
<span class="s">...`</span>
</pre></div>
</div>
<h4 id="Seccion-3.5.2" >Unicode</h4>
<div class="hBody-4" >
<p>Hace mucho tiempo, la vida era simple y habia, por lo menos un punto de vista parroquial, solo un conjunto de caracteres a manejar: ASCII, el codigo estandar americano para el intercambio de la informacion (<em>American Standard Code for Information Interchange</em>). ASCII, o mas precisamente US-ASCII, utiliza 7 bits para representar 128 <q>caracteres</q>: las letras mayusculas y minusculas del ingles, digitos y una variedad de caracteres de puntuacion y control de dispositivo. Durante gran parte de los primeros dias de la informatica, esto fue adecuado, pero dejo a una gran parte de la poblacion mundial incapaz de utilizar sus propios sistemas de escritura en las computadoras. Con el crecimiento de Internet, los datos en innumerables idiomas se han vuelto mucho mas comunes. ¿Como puede manejarse esta rica variedad y, si es posible, de forma eficiente?</p>
<p>La respuesta es Unicode (<a href="http://unicode.org/" >unicode.org</a>), que recoge todos los caracteres de todos los sistemas de escritura del mundo, ademas de acentos y otros signos diacriticos, codigos de control como tabulador y retorno de carro, y plenty of esoterica, y asigna a cada uno un numero estandar denominado <em>punto de codigo Unicode</em> o, en la terminologia Go, una runa.</p>
<p>Unicode version 8 define puntos de codigo para mas de 120.000 caracteres en mas de 100 idiomas y scripts. ¿Como se representan esto en los datos y programas de computadora? El tipo de datos naturales para almacenar una sola runa es <code>int32</code>, y eso es lo utiliza Go; tiene el sinonimo <code>rune</code> precisamente para este proposito.</p>
<p>Podriamos representar una secuencia de runas como una secuencia de valores <code>int32</code>. Esta representacion, se llama UTF-32 o UCS-4, la codificacion de cada punto de codigo Unicode tiene el mismo tamaño, 32 bits. Esto es simple y uniforme, pero utiliza mucho mas espacio de lo necesario, ya que la mayoria de texto legible por computadora esta en ASCII, que requiere solo 8 bits o 1 byte por caracter. Todos los caracteres en uso generalizado todavia aun son menos de 65.536, que cabrian en 16 bits. ¿Podemos hacerlo mejor?</p>
</div>
<h4 id="Seccion-3.5.3" >UTF-8</h4>
<div class="hBody-4" >
<p>UTF-8 es una codificacion de longitud variable de puntos de codigo Unicode como bytes. UTF-8 fue inventado por Ken Thompson y Rob Pike, dos de los creadores de Go, y ahora es un estandar Unicode. Utiliza entre 1 y 4 bytes para representar cada runa, pero solo 1 byte para caracteres ASCII y solo 2 o 3 bytes para la mayoria de runas en uso comun. Los bits de orden alto del primer byte de la codificacion de una runa indican cuantos bytes siguen. Un alto orden 0 indica ASCII de 7 bits, donde cada runa toma solo 1 byte, por lo que es identica a ASCII convencional. Un alto orden <code>110</code> indica que la runa toma 2 bytes; el segundo byte comienza con <code>10</code>. Las runas mas grandes tienen codificaciones analogas.</p>
<table>
<tbody>
<tr><td><code>0xxxxxx</code></td><td>runas 0−127</td><td>(ASCII)</td></tr>
<tr><td><code>11xxxxx 10xxxxxx</code></td><td>128−2047</td><td>(valores &lt;128 no utilizados)</td></tr>
<tr><td><code>110xxxx 10xxxxxx 10xxxxxx</code></td><td>2048−65535</td><td>(valores &lt;2048 no utilizados)</td></tr>
<tr><td><code>1110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></td><td>65536−0x10ffff</td><td>(otros valores no utiliados)</td></tr>
</tbody>
</table>
<p>Una codificacion de longitud variable impide la indexacion directa para acceder al <span class="math" >n</span>-esimo caracter de una cadena, pero UTF-8 tiene muchas propiedades deseables para compensar. La codificacion es compacta, compatible con ASCII y auto-sincronizada: es posible encontrar el inicio de un caracter al realizar una copia de seguridad de no mas de tres bytes. Tambien es un prefijo de codigo, por lo que se puede decodificar de izquierda a derecha sin ninguna ambigüedad o lookahead. La codificacion de ninguna runa es una subcadena de cualquier otra, o incluso de una secuencia de otras, por lo que puedes buscar una runa simplemente buscando sus bytes, sin preocuparte por el contexto anterior. El orden de bytes lexicografico es igual al orden de los puntos de codigo Unicode, por lo que la ordenacion de UTF-8 funciona de forma natural. No hay ningun NUL incrustado (cero) bytes, que es conveniente para los lenguajes de programacion que utilizan NUL para terminar cadenas.</p>
<p>Los archivos de codigo fuente de Go siempre estan codificados en UTF-8 y UTF-8 es la codificacion preferida para las cadenas de texto manipuladas por los programas Go. El paquete <code>unicode</code> proporciona funciones para trabajar con runas individuales (como distinguir letras de numeros, o la conversion de una letra mayuscula a una minuscula), y el paquete <code>unicode/utf8</code> proporciona funciones para codificar y decodificar runas como bytes usando UTF-8.</p>
<p>Muchos caracteres Unicode son dificiles de escribir en un teclado o distinguir visualmente de otros de similar aspecto; Algunos son incluso invisibles. Go nos permite el escape de literales Unicode en una cadena Go al especificarlos por su valor numerico. Hay dos formas, <code>\u</code><em>hhhh</em> para un valor de 16 bits y <code>\U</code><em>hhhhhhhh</em> para un valor de 32 bits, donde cada <em>h</em> es un digito hexadecimal; La necesidad de la forma de 32 bits se presenta con poca frecuencia. Cada uno denota la codificacion UTF-8 del punto de codigo especificado. Asi, por ejemplo, los siguientes literales de cadena representan la misma cadena de seis bytes:</p>
<div class="highlight"><pre><span></span><span class="s">&quot;世界&quot;</span>
<span class="s">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span>
<span class="s">&quot;\u4e16\u754c&quot;</span>
<span class="s">&quot;\U00004e16\U0000754c&quot;</span>
</pre></div>
<p>Las tres secuencias de escape anteriores proporcionan notaciones alternativas para la primera cadena, pero los valores que denotan son identicos. Los escapes Unicode tambien se puede utilizar en runas literales. Estos tres literales son equivalentes:</p>
<pre class="pre" >'世' '\u4e16' '\U00004e16'</pre>
<p>Una runa cuyo valor es menor que 256 se puede escribir con una sola de escape hexadecimal, por ejemplo <code>'\x41'</code> para <code>'A'</code>, pero para los valores mas altos, debe utilizar un <code>\u</code> o <code>\U</code> de escape. En consecuencia, <code>'\xe4\xb8\x96'</code> no es una runa literal legal, a pesar de que esos tres bytes son un UTF-8 valido de un unico punto de codigo.</p>
<p>Gracias a las buenas propiedades de UTF-8, muchas operaciones de cadena no requieren decodificacion. Podemos probar si una cadena contiene otra como prefijo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)]</span> <span class="o">==</span> <span class="nx">prefix</span>
<span class="p">}</span>
</pre></div>
<p>O como sufijo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">HasSuffix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">suffix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">suffix</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">suffix</span><span class="p">):]</span> <span class="o">==</span> <span class="nx">suffix</span>
<span class="p">}</span>
</pre></div>
<p>O como una subcadena:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">substr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">substr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>Utilizando la misma logica para un texto codificado en UTF-8 como para bytes sin procesar. Esto no es cierto para otras codificaciones. (Las funciones anteriores se han extraido del paquete <code>strings</code>, aunque su implementacion de <code>Contains</code> utiliza una tecnica de hash para buscar de manera mas eficiente.)</p>
<p>Por otro lado, si realmente nos preocupamos por los caracteres Unicode individuales, tenemos que usar otros mecanismos. Consideremos la cadena de nuestro primer ejemplo, la cual incluye dos caracteres asiaticos. La Figura 3.5 ilustra su representacion en la memoria. La cadena contiene 13 bytes, pero interpretada como UTF-8, codifica solo nueve puntos de codigo o runas:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;unicode/utf8&quot;</span>

<span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;Hello, 世界&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>                    <span class="c1">// &quot;13&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneCountInString</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// &quot;9&quot;</span>
</pre></div>
<p>Para procesar esos caracteres, necesitamos un decodificador UTF-8. El paquete <code>unicode/utf8</code> proporciona uno que podemos utilizar de la siguiente manera:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">DecodeRuneInString</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%c\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
  <span class="nx">i</span> <span class="o">+=</span> <span class="nx">size</span>
<span class="p">}</span>
</pre></div>
<p>Cada llamada a <code>DecodeRuneInString</code> regresa <code>r</code>, la runa en si, y <code>size</code>, el numero de bytes ocupados por la codificacion UTF-8 de <code>r</code>. El tamaño se utiliza para actualizar el indice del byte <code>i</code> de la siguiente runa en la cadena. Pero esto es torpe, y necesitamos bucles de este tipo todo el tiempo. Afortunadamente, Go tiene los bucles <code>range</code>, cuando se aplica a una cadena, realiza decodificacion UTF-8 de forma implicita. La salida del bucle de siguiente se muestra en la Figura 3.5; Observe como el indice salta en mas de 1 para cada runa no ASCII.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&quot;Hello, 世界&quot;</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%q\t%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<div class="figure" >
<p class="title">Figura 3.5. Un bucle <code>range</code> descodifica una cadena UTF-8-codificado.</p>
<figure>
<img src="img/Figure-3.5.jpg" />
</figure>
</div>
<p>Podriamos usar un simple bucle <code>range</code> para contar el numero de runas en una cadena, como aqui:</p>
<div class="highlight"><pre><span></span><span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="nx">n</span><span class="o">++</span>
<span class="p">}</span>
</pre></div>
<p>Al igual que con las otras formas de bucle <code>range</code>, podemos omitir las variables que no necesitamos:</p>
<div class="highlight"><pre><span></span><span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="nx">n</span><span class="o">++</span>
<span class="p">}</span>
</pre></div>
<p>O podemos simplemente llamar a <code>utf8.RuneCountInString(s)</code>.</p>
<p>Ya hemos mencionado que es sobre todo una cuestion de convencion en Go que las cadenas de texto se interpretan como secuencias codificadas en UTF-8 de puntos de codigo Unicode, pero para el uso correcto de bucles <code>range</code> de cadenas, es mas que una convencion, es una necesidad. ¿Que sucede si aplicamos <code>range</code> en cadena que contiene datos binarios arbitrarios o, de hecho, datos UTF-8 que contienen errores?</p>
<p>Cada vez que un decodificador UTF-8, ya sea explicito en una llamada a <code>utf8.DecodeRuneInString</code> o implicito en un bucle <code>range</code>, consume un byte de entrada inesperado, se genera un caracter Unicode de reemplazo especial, <code>'\uFFFD'</code>, que generalmente se impreme como un signo de interrogacion dentro de una forma hexagonal o un diamante negro �. Cuando un programa encuentra este valor de runa, a menudo es un signo de que parte del sistema que genero los datos de cadena ha sido descuidado en su tratamiento de las codificaciones de texto.</p>
<p>UTF-8 es excepcionalmente conveniente como un formato de intercambio, pero dentro de un programa las runas puede ser mas conveniente porque son de tamaño uniforme y por lo tanto, de facil indexado en arreglos y slices.</p>
<p>Una conversion <code>[]rune</code> aplicada a una cadena codificada en UTF-8 devuelve la secuencia de codigos Unicode:</p>
<div class="highlight"><pre><span></span><span class="c1">// &quot;programa&quot; en katakana</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;プログラム&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;% x\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span>
<span class="nx">r</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">rune</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%x\n&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>  <span class="c1">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span>
</pre></div>
<p>(El verbo <code>% x</code> en el primer <code>Printf</code> inserta un espacio entre cada par de digitos hexadecimales.)</p>
<p>Si un slice de runas se convierte en una cadena, produce la concatenacion de las codificaciones UTF-8 de cada runa:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span> <span class="c1">// &quot;プログラム&quot;</span>
</pre></div>
<p>Convertir un valor entero en una cadena interpre el entero como un valor de runa, y produce la representacion UTF-8 de esa runa:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mi">65</span><span class="p">))</span>     <span class="c1">// &quot;A&quot;, not &quot;65&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mh">0x4eac</span><span class="p">))</span> <span class="c1">// &quot;京&quot;</span>
</pre></div>
<p>Si la runa no es valida, se reemplasa por el caracter de sustitucion:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="mi">1234567</span><span class="p">))</span> <span class="c1">// &quot;�&quot;</span>
</pre></div>
</div>
<h4 id="Seccion-3.5.4" >Cadenas y Slices de Bytes</h4>
<div class="hBody-4" >
<p>cuatro paquetes estandar son particularmente importantes para la manipulacion de cadenas: <code>bytes</code>, <code>strings</code>, <code>strconv</code> y <code>unicode</code>. El paquete <code>strings</code> ofrece muchas funciones para busqueda, reemplazo, comparacion, recorte, division, y union en cadenas.</p>
<p>El paquete <code>bytes</code> tiene funciones similares para manipular slices de bytes, de tipo <code>[]byte</code>, que comparten algunas propiedades con <code>strings</code>. Debido a que las cadenas son inmutables, la construccion de cadenas de forma incremental puede implicar una gran cantidad de asignacion y copiado. En tales casos, es mas eficaz utilizar el tipo <code>bytes.Buffer</code>, que vamos a mostrar en un momento.</p>
<p>El paquete <code>strconv</code> proporciona funciones para convertir booleanos, enteros, y valores de coma flotante hacia y desde sus representaciones en cadenas, y funciones para citar y des-citar cadenas.</p>
<p>El paquete <code>unicode</code> proporciona funciones como <code>IsDigit</code>, <code>IsLetter</code>, <code>IsUpper</code> y <code>IsLower</code> para la clasificacion de runas. Cada funcion toma un unico argumento de tipo runa y devuelve un booleano. Las funciones de conversion como <code>ToUpper</code> y <code>ToLower</code> convierten una runa en el caso concreto si se trata de una letra. Todas estas funciones utilizan las categorias estandar de Unicode para las letras, los digitos, etc. El paquete <code>strings</code> tiene funciones similares, tambien llamadas <code>ToUpper</code> y <code>ToLower</code>, que devuelven una nueva cadena con la transformacion especificada aplicada a cada caracter de la cadena original.</p>
<p>La siguiente funcion <code>basename</code> se inspiro en la utilidad de shell Unix del mismo nombre. En nuestra version, <code>basename(s)</code> elimina cualquier prefijo de <code>s</code> que paresca una ruta de sistema con componentes separados por barras, y elimina cualquier sufijo que se parece a un tipo de archivo:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&quot;a/b/c.go&quot;</span><span class="p">))</span> <span class="c1">// &quot;c&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&quot;c.d.go&quot;</span><span class="p">))</span>   <span class="c1">// &quot;c.d&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">basename</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">))</span>      <span class="c1">// &quot;abc&quot;</span>
</pre></div>
<p>La primer version de basename hace todo el trabajo sin la ayuda de librerias:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/basename1/main.go" >gopl.io/ch3/basename1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// basename elimina los .subfijos y componentes de directorios.</span>
<span class="c1">// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.c</span>
<span class="kd">func</span> <span class="nx">basename</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="c1">// Descarta el ultimo &#39;/&#39; y todo lo anterior.</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
      <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Conserva todo antes del ultimo &#39;.&#39;.</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="p">{</span>
      <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Una version mas simple utiliza la funcion de libreria <code>strings.LastIndex</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/basename2/main.go" >gopl.io/ch3/basename2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">basename</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">slash</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">LastIndex</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">)</span> <span class="c1">// -1 si no se encuentra &quot;/&quot;</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">slash</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="nx">dot</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">LastIndex</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">);</span> <span class="nx">dot</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">dot</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los paquetes <code>path</code> y <code>path/filepath</code> proporcionan un conjunto general de funciones para manipular nombres jerarquicos. El paquete <code>path</code> funciona con rutas delimitada por barras en cualquier plataforma. No se debe utilizar para nombres de archivo, pero es apropiado para otros dominios, como los componente de ruta de una URL. Por el contrario, <code>path/filepath</code> manipula los nombres de archivos usando las reglas para la plataforma huesped, tales como <code>/foo/bar</code> para POSIX o <code>c:\foo\bar</code> en Microsoft Windows.</p>
<p>Vamos a continuar con otro ejemplo de subcadena. La tarea es tomar una representacion de cadena de un entero, como <code>&quot;12345&quot;</code>, e insertar comas cada tres posiciones, como en <code>&quot;12,345&quot;</code> . Esta version solo funciona para enteros; El manejo de numeros de coma flotante se deja como un ejercicio.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/comma/main.go" >gopl.io/ch3/comma</a></p>
<div class="highlight"><pre><span></span><span class="c1">// comma inserta comas en una cadena de numeros enteros decimales negativos.</span>
<span class="kd">func</span> <span class="nx">comma</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">comma</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="nx">n</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El argumento de <code>comma</code> es una cadena. Si su longitud es menor o igual a 3, no es necesaria una coma. De lo contrario, comma se llama a si misma de forma recursiva con una subcadena formada por todos menos los tres ultimos caracteres, y añåde una coma y los tres ultimos caracteres en el resultado de la llamada recursiva.</p>
<p>Una cadena contiene un arreglo de bytes que, una vez creado, es inmutable. Por el contrario, los elementos de una slice de bytes se pueden modificar libremente.</p>
<p>Las cadenas se pueden convertir en slices de bytes y viceversa:</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="s">&quot;abc&quot;</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</pre></div>
<p>Conceptualmente, la conversion <code>[]byte(s)</code> asigna un nuevo arreglo de bytes que guarda una copia de bytes de <code>s</code>, y produce un slice que hace referencia a la totalidad del arreglo. Un compilador optimizado puede ser capaz de evitar la asignacion y la copia en algunos casos, pero en general, la copia es necesaria para asegurar que los bytes de <code>s</code> se mantienen sin cambios incluso si los de <code>b</code> son modificados posteriormente. La conversion de slice de byte de nuevo a cadena con <code>string(b)</code> tambien genera una copia, para asegurar inmutabilidad de la cadena resultante <code>s2</code>.</p>
<p>Para evitar conversiones y asignacion de memoria innecesaria, muchas de las funciones de utilidad en el paquete <code>bytes</code> directamente paralelos a sus contrapartes en el paquete <code>strings</code>. Por ejemplo, aqui hay una media docena de funciones en <code>strings</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">substr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Fields</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span>
<span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
</pre></div>
<p>y las correspondientes en bytes :</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">subslice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Fields</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span>
<span class="kd">func</span> <span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prefix</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="nx">s</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">sep</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</pre></div>
<p>La unica diferencia es que las cadenas han sido reemplazadas por slices de bytes.</p>
<p>El paquete <code>bytes</code> proporciona el tipo <code>Buffer</code> para la manipulacion eficiente de slices de <code>byte</code>. Un <code>Buffer</code> comienza vacio, pero crece a medida que los datos de tipos como <code>string</code>, <code>byte</code>, y <code>[]byte</code> se escriben en el. Como muestra el siguiente ejemplo, una variable <code>bytes.Buffer</code> no requiere inicializacion porque su valor cero es utilizable:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/printints/main.go" >gopl.io/ch3/printints</a></p>
<div class="highlight"><pre><span></span><span class="c1">// intsToString es como fmt.Sprint(values) pero agrega comas.</span>
<span class="kd">func</span> <span class="nx">intsToString</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">intsToString</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}))</span> <span class="c1">// &quot;[1, 2, 3]&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cuando se agrega la codificacion UTF-8 de un runa arbitraria a un <code>bytes.Buffer</code>, lo mejor es utilizar el metodo <code>WriteRune</code> de <code>bytes.Buffer</code>, pero <code>WriteByte</code> esta bien para caracteres ASCII como <code>'['</code> y <code>']'</code>.</p>
<p>El tipo <code>bytes.Buffer</code> es extremadamente versatil, y cuando hablemos de interfaces en el <a href="#Capitulo-7" >Capitulo 7</a>, vamos a ver como se puede utilizar como un sustituto de un archivo cada vez que una funcion de E/S requiere un poso de bytes (<code>io.Writer</code>) como <code>Fprintf</code>, o una fuente de bytes (<code>io.Reader</code>).</p>
<p><b>Ejercicio 3.10</b>: Escribir una version no recursiva de <code>comma</code>, utilizando <code>bytes.Buffer</code> en lugar de la concatenacion de cadenas.</p>
<p><b>Ejercicio 3.11</b>: Mejorar <code>comma</code> para que se maneje correctamente los numeros de punto flotante y un opcionalmente con signo.</p>
<p><b>Ejercicio 3.12</b>: Escribir una funcion que informa de si dos cadenas son anagramas entre si, es decir, que contienen las mismas letras en un orden diferente.</p>
</div>
<h4 id="Seccion-3.5.5" >Conversiones entre cadenas y numeros</h4>
<div class="hBody-4" >
<p>Ademas de las conversiones entre cadenas, runas y bytes, a menudo es necesario convertir entre valores numericos y sus representaciones de cadena. Esto se realiza con las funciones del paquete <code>strconv</code>.</p>
<p>Para convertir un entero a una cadena, una opcion es utilizar <code>fmt.Sprintf</code>; otra es utilizar la funcion <code>strconv.Itoa</code> (<q>entero a ASCII</q>):</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">123</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="c1">// &quot;123 123&quot;</span>
</pre></div>
<p><code>FormatInt</code> y <code>FormatUint</code> se pueden utilizar para dar formato a numeros en una base diferente:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &quot;1111011&quot;</span>
</pre></div>
<p>Los verbos <code>%b</code>, <code>%d</code>, <code>%u</code> y <code>%x</code> de <code>fmt.Printf</code> a menudo son mas conveniente que las funciones <code>Format</code>, sobre todo si queremos incluir informacion adicional ademas del numero:</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;x=%b&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;x=1111011&quot;</span>
</pre></div>
<p>Para analizar una cadena que representa un numero entero, utilice las funciones de <code>strconv</code> como <code>Atoi</code> o <code>ParseInt</code>, o <code>ParseUint</code> para enteros sin signo:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">)</span>             <span class="c1">// x es un entero</span>
<span class="nx">y</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="c1">// base 10, hasta 64 bits</span>
</pre></div>
<p>El tercer argumento de <code>ParseInt</code> da el tamaño del tipo de entero que debe ser el resultado; por ejemplo, 16 implica <code>int16</code>, y el valor especial 0 implica <code>int</code> . En cualquier caso, el tipo del resultado <code>y</code> es siempre <code>int64</code>, que luego se puede convertir a un tipo mas pequeño.</p>
<p>A veces es util <code>fmt.Scanf</code> para el analisis de entrada que consta de mezclas ordenadas de cadenas y numeros todo en una sola linea, pero puede ser inflexible, especialmente cuando se maneja una entrada incompleta o irregular.</p>
</div>
<h3 id="Seccion-3.6" >Constantes</h3>
<div class="hBody-3" >
<p>Las constantes son expresiones cuyo valor es conocido por el compilador y cuya evaluacion se garantiza que se produzca en tiempo de compilacion, no en tiempo de ejecucion. El tipo subyacente de cada constante es un tipo basico: booleano, cadena o numero.</p>
<p>Una declaracion <code>const</code> define los valores que se ven sintacticamente como variables con nombre pero cuyo valor es constante, lo que evita cambios accidentales (o nefastos) durante la ejecucion del programa. Por ejemplo, una constante es mas apropiada que una variable para una constante matematica como <code>pi</code>, ya que su valor no cambiara:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.14159</span> <span class="c1">// aproximadamente; math.Pi un una mejor aproximacion</span>
</pre></div>
<p>Al igual que con las variables, una secuencia de constantes puede aparecer en una declaracion; Esto seria apropiado para un grupo de valores relacionados:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">e</span>  <span class="p">=</span> <span class="mf">2.71828182845904523536028747135266249775724709369995957496696763</span>
  <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.14159265358979323846264338327950288419716939937510582097494459</span>
<span class="p">)</span>
</pre></div>
<p>Muchos calculos de constantes pueden evaluarse completamente en tiempo de compilacion, reduciendo el trabajo necesario en tiempo de ejecucion y habilitando otras optimizaciones de compilador. Los errores ordinariamente detectados en tiempo de ejecucion pueden ser reportados en tiempo de compilacion cuando sus operandos son constantes, como la division entera por cero, una cadena de indexacion fuera de limites y cualquier operacion de punto flotante que daria lugar a un valor no finito.</p>
<p>Los resultados de toda la aritmetica, y operaciones de comparacion logicos aplicados a operandos constantes son en si mismas constantes, como son los resultados de las conversiones y las llamadas a ciertas funciones nativas como <code>len</code>, <code>cap</code>, <code>real</code>, <code>imag</code>, <code>complex</code>, y <code>unsafe.Sizeof</code> (<a href="#Seccion-13.1" >§13.1</a>).</p>
<p>Ya que sus valores son conocidos por el compilador, las expresiones constantes pueden aparecer en los tipos, especificamente como la longitud de un tipo de arreglo:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">IPv4Len</span> <span class="p">=</span> <span class="mi">4</span>

<span class="c1">// parseIPv4 analiza una direccion IPv4 (d.d.d.d).</span>
<span class="kd">func</span> <span class="nx">parseIPv4</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">IP</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="p">[</span><span class="nx">IPv4Len</span><span class="p">]</span><span class="kt">byte</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Una declaracion constante puede especificar un tipo como un valor, pero en ausencia de un tipo explicito, el tipo se infiere de la expresion en el lado derecho. En el siguiente ejemplo, <code>time.Duration</code> es un tipo con nombre cuyo tipo subyacente es <code>int64</code>, y <code>time.Minute</code> es una constante de ese tipo. Por lo tanto las dos constantes declaradas a continuacion tienen el tipo <code>time.Duration</code>, como lo revela <code>%T</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">noDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">const</span> <span class="nx">timeout</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T %[1]v\n&quot;</span><span class="p">,</span> <span class="nx">noDelay</span><span class="p">)</span>     <span class="c1">// &quot;time.Duration 0&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T %[1]v\n&quot;</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>     <span class="c1">// &quot;time.Duration 5m0s</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T %[1]v\n&quot;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span> <span class="c1">// &quot;time.Duration 1m0s&quot;</span>
</pre></div>
<p>Cuando una secuencia de constantes se declara como un grupo, la expresion del lado derecho se puede omitir para todas excepto para la primera del grupo, lo que implica que la expresion anterior y su tipo deben ser utilizados de nuevo. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="nx">b</span>
  <span class="nx">c</span> <span class="p">=</span> <span class="mi">2</span>
  <span class="nx">d</span>
<span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">// &quot;1 1 2 2&quot;</span>
</pre></div>
<p>Esto no es muy util si la expresion del lado derecho implicitamente copiada se evalua siempre con el mismo valor. Pero, ¿y si pudiera variar? Esto nos lleva a <code>iota</code>.</p>
</div>
<h4 id="Seccion-3.6.1" >El Generador Constante <code>iota</code></h4>
<div class="hBody-4" >
<p>Una declaracion <code>const</code> puede utilizar el generador de constante <code>iota</code>, que se utiliza para crear una secuencia de valores relacionados sin escribir cada uno de forma explicita. En una declaracion <code>const</code>, el valor de <code>iota</code> comienza en cero y se incrementa en uno en cada elemento de la secuencia.</p>
<p>He aqui un ejemplo del paquete <code>time</code>, que define constantes de tipo <code>Weekday</code> de los dias de la semana, a partir de cero para <code>Sunday</code>. Tipos de esta clase a menudo se conocen como <em>enumeraciones</em>, o <em>enums</em>, para abreviar.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Weekday</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">Sunday</span> <span class="nx">Weekday</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">Monday</span>
  <span class="nx">Tuesday</span>
  <span class="nx">Wednesday</span>
  <span class="nx">Thursday</span>
  <span class="nx">Friday</span>
  <span class="nx">Saturday</span>
<span class="p">)</span>
</pre></div>
<p>Esto declara que <code>Sunday</code> debe ser 0, <code>Monday</code> debe ser 1, y asi sucesivamente.</p>
<p>Podemos utilizar <code>iota</code> en expresiones mas complejas, como en este ejemplo del paquete <code>net</code> en el que se le da a cada uno de los 5 bits mas bajos de un entero sin signo un nombre distinto e interpretacion booleana:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Flags</span> <span class="kt">uint</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">FlagUp</span> <span class="nx">Flags</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// esta arriba</span>
  <span class="nx">FlagBroadcast</span>            <span class="c1">// soporta acceso broadcast</span>
  <span class="nx">FlagLoopback</span>             <span class="c1">// es una interface loopback</span>
  <span class="nx">FlagPointToPoint</span>         <span class="c1">// pertenece a un enlace punto-a-punto</span>
  <span class="nx">FlagMulticast</span>            <span class="c1">// soporta acceso multicast</span>
<span class="p">)</span>
</pre></div>
<p>Como <code>iota</code> incrementa, a cada constante se le asigna el valor de <code>1 &lt;&lt; iota</code>, que evalua a potencias consecutivas de dos, cada un corresponde a un solo bit. Podemos utilizar estas constantes dentro de funciones que prueban, establecen o borran uno o mas de estos bits:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch3/netflag/netflag.go" >gopl.io/ch3/netflag</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Flags</span><span class="p">)</span> <span class="kt">bool</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">v</span><span class="o">&amp;</span><span class="nx">FlagUp</span> <span class="o">==</span> <span class="nx">FlagUp</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TurnDown</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Flags</span><span class="p">)</span>     <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="o">&amp;^=</span> <span class="nx">FlagUp</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">SetBroadcast</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Flags</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="o">|=</span> <span class="nx">FlagBroadcast</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">IsCast</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Flags</span><span class="p">)</span> <span class="kt">bool</span>   <span class="p">{</span> <span class="k">return</span> <span class="nx">v</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">FlagBroadcast</span><span class="p">|</span><span class="nx">FlagMulticast</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="nx">Flags</span> <span class="p">=</span> <span class="nx">FlagMulticast</span> <span class="p">|</span> <span class="nx">FlagUp</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%b %t\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &quot;10001 true&quot;</span>
  <span class="nx">TurnDown</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%b %t\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &quot;10000 false&quot;</span>
  <span class="nx">SetBroadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%b %t\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsUp</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>   <span class="c1">// &quot;10010 false&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%b %t\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">IsCast</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// &quot;10010 true&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como un ejemplo mas complejo de <code>iota</code>, esta declaracion nombra las potencias de 1024:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">_</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
  <span class="nx">KiB</span> <span class="c1">// 1024</span>
  <span class="nx">MiB</span> <span class="c1">// 1048576</span>
  <span class="nx">GiB</span> <span class="c1">// 1073741824</span>
  <span class="nx">TiB</span> <span class="c1">// 1099511627776              (exede 1 &lt;&lt; 32)</span>
  <span class="nx">PiB</span> <span class="c1">// 1125899906842624</span>
  <span class="nx">EiB</span> <span class="c1">// 1152921504606846976</span>
  <span class="nx">ZiB</span> <span class="c1">// 1180591620717411303424     (exede 1 &lt;&lt; 64)</span>
  <span class="nx">YiB</span> <span class="c1">// 1208925819614629174706176</span>
<span class="p">)</span>
</pre></div>
<p>El mecanismo <code>iota</code> tiene sus limites. Por ejemplo, no es posible generar las potencias mas familiares de 1000 (KB, MB, etc.) porque no hay un operador de exponenciacion.</p>
<p><b>Ejercicio 3.13</b>: Escribir declaraciones <code>const</code> para KB, MB, hasta YB lo mas compacto como sea posible.</p>
</div>
<h4 id="Seccion-3.6.2" >Constantes Sin Tipo</h4>
<div class="hBody-4" >
<p>Las constantes en Go son un poco inusuales. Aunque una constante puede tener cualquiera de los tipos de datos basicos como <code>int</code> o <code>float64</code>, incluyendo tipos basicos con nombre como <code>time.Duration</code>, muchas constantes no estan comprometidas con un tipo particular. El compilador representa estas constantes no comprometidas con una precision numerica mucho mayor que los valores de tipos basicos, y la aritmetica en ellas es mas precisa que la aritmetica de la maquina; Puede suponer al menos 256 bits de precision. Hay seis sabores de estas constantes no comprometidos, llamado booleanos <em>sin tipo</em>, enteros sin tipo, runas sin tipo, punto flotante sin tipo, complejos sin tipo y cadenas sin tipo.</p>
<p>Al aplazar este compromiso, las constantes no tipificadas no solo conservan su mayor precision hasta mas tarde, sino que pueden participar en muchas mas expresiones que las constantes comprometidas sin requerir conversiones. Por ejemplo, los valores <code>ZiB</code> y <code>YiB</code> en el ejemplo anterior son demasiado grandes para almacenase en cualquier variable entera, pero son legitimas constantes que pueden utilizarse en las expresiones como esta:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">YiB</span><span class="o">/</span><span class="nx">ZiB</span><span class="p">)</span> <span class="c1">// &quot;1024&quot;</span>
</pre></div>
<p>Como otro ejemplo, la constante de coma flotante <code>math.Pi</code> puede utilizarse alli donde se necesite cualquier valor de coma flotante o complejo:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>
</pre></div>
<p>Si <code>math.Pi</code> entubiera comprometido con un tipo especifico, como <code>float64</code>, el resultado no seria tan preciso, y se requerira de conversion de tipos para usarlo con valores <code>float32</code> o <code>complex128</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">Pi64</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span>

<span class="kd">var</span> <span class="nx">x</span> <span class="kt">float32</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">Pi64</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="kt">complex128</span> <span class="p">=</span> <span class="nb">complex128</span><span class="p">(</span><span class="nx">Pi64</span><span class="p">)</span>
</pre></div>
<p>Para literales, la sintaxis determina el sabor. Los literales de <code>0</code>, <code>0.0</code>, <code>0i</code>, y <code>'\u0000'</code> representan constantes del mismo valor pero diferentes sabores: entero sin tipo, sin tipo de punto flotante, complejo sin tipo, y runa sin tipo, respectivamente. Del mismo modo, <code>true</code> y <code>false</code> son booleanos sin tipo y literales de cadena son cadenas sin tipo.</p>
<p>Recordemos que <code>/</code> puede representar un numero entero o division de punto flotante dependiendo de sus operandos. En consecuencia, la eleccion de literal puede afectar el resultado de una expresion de division constante:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">212</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">((</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span>     <span class="c1">// &quot;100&quot;; (f - 32) * 5 es un float64</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span> <span class="o">*</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">))</span>     <span class="c1">// &quot;0&quot;;   5/9 es un entero sin tipo, 0</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">9.0</span> <span class="o">*</span> <span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="mi">32</span><span class="p">))</span> <span class="c1">// &quot;100&quot;; 5.0/9.0 es un float sin tipo</span>
</pre></div>
<p>Solo las constantes pueden no tener tipo. Cuando una constante no tipificada se asigna a una variable, como en la primer instruccion a continuacion, o aparece en el lado derecho de una declaracion de variable con un tipo explicito, como en las otras tres sentencias, la constante se convierte implicitamente en el tipo de esa variable si es posible.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="m">0i</span> <span class="c1">// complejo sin tipo -&gt; float64</span>
<span class="nx">f</span> <span class="p">=</span> <span class="mi">2</span>                  <span class="c1">// entero sin tipo -&gt; float64</span>
<span class="nx">f</span> <span class="p">=</span> <span class="mf">1e123</span>              <span class="c1">// punto flotante sin tipo -&gt; float64</span>
<span class="nx">f</span> <span class="p">=</span> <span class="sc">&#39;a&#39;</span>                <span class="c1">// runa sin tipo -&gt; float64</span>
</pre></div>
<p>Las afirmaciones anteriores son, pues, equivalentes a estas:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="m">0i</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mf">1e123</span><span class="p">)</span>
<span class="nx">f</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
<p>Ya sea implicita o explicitamente, la conversion de una constante de un tipo a otro requiere que el tipo de destino pueda representar el valor original. Se permite el redondeo para numeros reales y complejos de coma flotante:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">deadbeef</span> <span class="p">=</span> <span class="mh">0xdeadbeef</span> <span class="c1">// int sin tipo con valor 3735928559</span>
  <span class="nx">a</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span>  <span class="c1">// uint32 con valor 3735928559</span>
  <span class="nx">b</span> <span class="p">=</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span> <span class="c1">// float32 con valor 3735928576 (rounded up)</span>
  <span class="nx">c</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span> <span class="c1">// float64 con valor 3735928559 (exact)</span>
  <span class="nx">d</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">deadbeef</span><span class="p">)</span>   <span class="c1">// error de compilacion: desbordamiento constante int32</span>
  <span class="nx">e</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="mf">1e309</span><span class="p">)</span>    <span class="c1">// error de compilacion: desbordamiento constante float64</span>
  <span class="nx">f</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>          <span class="c1">// error de compilacion: subdesbordamiento constante uint</span>
<span class="p">)</span>
</pre></div>
<p>En una declaracion de variable sin un tipo explicito (incluyendo declaracion de variables compacto), el sabor de la constante no tipificada determina implicitamente el tipo predeterminado de la variable, como en estos ejemplos:</p>
<div class="highlight"><pre><span></span><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>      <span class="c1">// entero sin tipo;         int(0) implicitio</span>
<span class="nx">r</span> <span class="o">:=</span> <span class="sc">&#39;\000&#39;</span> <span class="c1">// runa sin tipo;           rune(&#39;\000&#39;) implicitio</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="mf">0.0</span>    <span class="c1">// punto flotante sin tipo; float64(0.0) implicitio</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="m">0i</span>     <span class="c1">// complejo sin tipo;       complex128(0i) implicitio</span>
</pre></div>
<p>Observese la asimetria: los enteros sin tipo se convierten en <code>int</code>, cuyo tamaño no esta garantizado, pero los numeros de punto flotante y numeros complejos se convierten a los tipos de tamaño <code>float64</code> y <code>complex128</code> de forma explicita. El lenguaje no cuenta con tipos <code>float</code> y <code>complex</code> sin tamaño, analogos a <code>int</code> sin tamaño, porque es muy dificil escribir algoritmos numericos correctos sin conocer el tamaño de uno de los tipos de datos de punto flotante.</p>
<p>Para dar un tipo diferente a la variable, debemos convertir explicitamente la constante no tipificada en el tipo deseado o indicar el tipo deseado en la declaracion de variables, como en estos ejemplos:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="nb">int8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int8</span> <span class="p">=</span> <span class="mi">0</span>
</pre></div>
<p>Estos valores predeterminados son particularmente importantes cuando se convierte una constante sin tipo a un valor de interfaz (ver <a href="#Capitulo-7" >Capitulo 7</a>) ya que determinan su tipo dinamico.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">// &quot;int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>    <span class="c1">// &quot;float64&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="m">0i</span><span class="p">)</span>     <span class="c1">// &quot;complex128&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="sc">&#39;\000&#39;</span><span class="p">)</span> <span class="c1">// &quot;int32&quot; (rune)</span>
</pre></div>
<p>Ahora hemos cubierto los tipos de datos basicos de Go. El siguiente paso es mostrar como se pueden combinar en agrupaciones mas grandes como arreglos y estructuras, y luego en estructuras de datos para resolver problemas de programacion real; ese es el tema del <a href="#Capitulo-4" >Capitulo 4</a>.</p>
</div>
<h2 id="Capitulo-4" >Tipos Compuestos</h2>
<div class="hBody-2" >
<p>En el <a href="#Capitulo-3" >Capitulo 3</a> hablamos de los tipos basicos que sirven como bloques de construccion para estructuras de datos en un programa Go; Son los atomos de nuestro universo. En este capitulo, vamos a echar un vistazo a los tipos <em>compuestos</em>, las moleculas creadas mediante la combinacion de los tipos basicos de diversas maneras. Hablaremos de cuatro de estos tipos–arreglos, slices, mapas y estructuras–y al final del capitulo mostraremos como los datos estructurados que utilizan estos tipos pueden ser codificados y analizados a partir de datos JSON y usados ​​para generar HTML desde plantillas.</p>
<p>Arreglos y estructuras son tipos de <em>agregados</em>; Sus valores son concatenaciones de otros valores en la memoria. Los arreglos son homogeneos, sus elementos tienen el mismo tipo, mientras que las estructuras son heterogeneas. Los arreglos y las estructuras son de tamaño fijo. Por el contrario, slices y mapas son estructuras de datos dinamicas que crecen a medida que se agregan valores.</p>
</div>
<h3 id="Seccion-4.1" >Arreglos</h3>
<div class="hBody-3" >
<p>Un arreglo es una secuencia de longitud fija de cero o mas elementos de un tipo particular. Debido a su longitud fija, en Go raramente se utilizan arreglos directamente. Los slices, pueden crecer y encogerse, son mucho mas versatiles, pero para entender los slices primero debemos entender los arreglos.</p>
<p>Los elementos individuales de arreglo se acceden con la notacion de subindices convencional, donde los subindices abarcan desde cero a uno menos que la longitud de la arreglo. La funcion nativa <code>len</code> devuelve el numero de elementos de la arreglo.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>             <span class="c1">// arreglo de 3 enteros</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        <span class="c1">// imprime el primer elemento</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// imprime el ultime elemento, a[2]</span>

<span class="c1">// imprimir los indices y elementos.</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// imprimir solo los elementos.</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Por defecto, los elementos de un nuevo arreglo de variables estan configurados inicialmente a el valor cero para el tipo de elemento, que es 0 para los numeros. Podemos utilizar un <em>arreglo literal</em> para inicializar un arreglo con una lista de valores:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">q</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">r</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// &quot;0&quot;</span>
</pre></div>
<p>En un arreglo literal, si aparece una elipsis <code>&quot;...&quot;</code> aparece en lugar de la longitud, la longitud del arreglo se determina por el numero de inicializadores. La definicion de <code>q</code> se puede simplificar como</p>
<div class="highlight"><pre><span></span><span class="nx">q</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="c1">// &quot;[3]int&quot;</span>
</pre></div>
<p>El tamaño de un arreglo es parte de su tipo, por lo que <code>[3]int</code> y <code>[4]int</code> son tipos diferentes. El tamaño debe ser una expresion constante, es decir, una expresion cuyo valor se puede calcular a medida que se esta compilando el programa.</p>
<div class="highlight"><pre><span></span><span class="nx">q</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">q</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// error de compilacion: no puede asignar [4]int a [3]int</span>
</pre></div>
<p>Como veremos, la sintaxis literal es similar para arreglos, slices, mapas y estructuras. El formato especifico anterior es una lista de valores en orden, pero tambien es posible especificar una lista de pares de indice y valor, como aqui:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Currency</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">USD</span> <span class="nx">Currency</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">EUR</span>
  <span class="nx">GBP</span>
  <span class="nx">RMB</span>
<span class="p">)</span>
<span class="nx">symbol</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="nx">USD</span><span class="p">:</span> <span class="s">&quot;$&quot;</span><span class="p">,</span> <span class="nx">EUR</span><span class="p">:</span> <span class="s">&quot;€&quot;</span><span class="p">,</span> <span class="nx">GBP</span><span class="p">:</span> <span class="s">&quot;£&quot;</span><span class="p">,</span> <span class="nx">RMB</span><span class="p">:</span> <span class="s">&quot;¥&quot;</span><span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">RMB</span><span class="p">,</span> <span class="nx">symbol</span><span class="p">[</span><span class="nx">RMB</span><span class="p">])</span> <span class="c1">// &quot;3 ¥&quot;</span>
</pre></div>
<p>En esta forma, los indices pueden aparecer en cualquier orden y algunos pueden ser omitidos; Como antes, los valores no especificados toman el valor cero para el tipo de elemento. Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="nx">r</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">99</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
</pre></div>
<p>define un arreglo <code>r</code> con 100 elementos, todos en cero excepto para el ultimo, que tiene un valor -1.</p>
<p>Si el tipo de los elementos de un arreglo es <em>comparable</em> entonces, el tipo del arreglo tambien es comparable, asi que podemos comparar directamente dos arreglos de ese tipo usando el operador <code>==</code>, que informa de si todos los elementos correspondientes son iguales. El operador <code>!=</code> es su negacion.</p>
<div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;true false false&quot;</span>
<span class="nx">d</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">// error de compilacion: no puede comparar [2]int == [3]int</span>
</pre></div>
<p>Como un ejemplo mas plausible, la funcion <code>Sum256</code> en el paquete <code>crypto/sha256</code> produce el <em>digest</em> o hash criptografico SHA256 o DIGEST de un mensaje almacenado en un slice arbitrario de bytes. El hash tiene 256 bits, por lo que su tipo es <code>[32]byte</code> . Si dos hash son los mismos, es muy probable que los dos mensajes sean iguales; Si los hash difieren, los dos mensajes son diferentes. Este programa imprime y compara los hash SHA256 de <code>&quot;x&quot;</code> y <code>&quot;X&quot;</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/sha256/main.go" >gopl.io/ch4/sha256</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;crypto/sha256&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">c1</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nx">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">))</span>
  <span class="nx">c2</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nx">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%x\n%x\n%t\n%T\n&quot;</span><span class="p">,</span> <span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">c1</span> <span class="o">==</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">c1</span><span class="p">)</span>
  <span class="c1">// Output:</span>
  <span class="c1">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span>
  <span class="c1">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span>
  <span class="c1">// false</span>
  <span class="c1">// [32]uint8</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Las dos entradas difieren por un solo bit, pero aproximadamente la mitad de los bits son diferentes en los hash. Note las verbos <code>Printf</code>: <code>%x</code> para imprimir todos los elementos de un arreglo o una slice de bytes en hexadecimal, <code>%t</code> para mostrar un valor booleano, y <code>%T</code> para mostrar el tipo de un valor.</p>
<p>Cuando se llama a una funcion, se asigna una copia de cada valor de argumento a la variable de parametro correspondiente, por lo que la funcion recibe una copia, no el original. Pasar grandes arreglos de esta manera puede ser ineficiente, y cualquier cambio que la funcion hace a elementos de arreglo afectan solo a la copia, no al original. En este sentido, Go trata a los arreglos como a cualquier otro tipo, pero este comportamiento es diferente de otros lenguajes que implicitamente pasan arreglos por referencia.</p>
<p>Por supuesto, podemos pasar explicitamente un puntero a un arreglo para que cualquier modificacion que la funcion hace a los elementos del arreglo sean visibles para quien llama a la funcion. Esta funcion pone a cero el contenido de un arreglo <code>[32]byte</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ptr</span> <span class="p">{</span>
    <span class="nx">ptr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>El arreglo literal <code>[32]byte{}</code> produce una serie de 32 bytes. Cada elemento del arreglo tiene el valor cero para <code>byte</code>, que es cero. Podemos utilizar este hecho para escribir una version diferente de zero:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">ptr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
<p>El uso de un puntero a un arreglo es eficiente y permite que la funcion llamada mute la variable de quien la llama, pero los arreglos son intrinsecamente inflexibles debido a su tamaño fijo. La funcion <code>zero</code> no aceptara un puntero a una variable <code>[16]byte</code>, por ejemplo, ni hay ninguna manera de añadir o eliminar elementos del arreglo. Por estas razones, aparte de casos especiales como el hash SHA256 de tamaño fijo, rara vez se usan arreglos como parametros de funcion; En su lugar, utilizamos slices.</p>
<p><b>Ejercicio 4.1</b>: Escribir una funcion que cuente el numero de bits que son diferentes en dos hash SHA256. (Ver <code>PopCount</code> en la <a href="#Seccion-2.6.2" >Seccion 2.6.2</a>.)</p>
<p><b>Ejercicio 4.2</b>: Escribir un programa que imprima el hash SHA256 de su entrada estandar por defecto, pero que accepte una bandera de linea de comando para imprimir tambien los hash SHA384 o SHA512.</p>
</div>
<h3 id="Seccion-4.2" >Slices</h3>
<div class="hBody-3" >
<p>Los slices representan secuencias de longitud variable cuyos elementos tienen todos el mismo tipo. Un tipo slice se escribe <code>[]T</code>, donde los elementos tienen el tipo <code>T</code>; es como un tipo arreglo pero sin un tamaño.</p>
<p>Arreglos y slices estan intimamente conectados. Un slice es una estructura de datos ligera que da acceso a una subsecuencia de (o tal vez todos) los elementos de un arreglo, que se conoce como <em>arreglo subyacente</em> del slice. Una slice tiene tres componentes: un puntero, una longitud y una capacidad. El puntero apunta al primer elemento del arreglo que se puede acceder a traves del slice, que no es necesariamente el primer elemento del arreglo. La longitud es el numero de elementos del slice; No puede exceder la capacidad, que suele ser el numero de elementos entre el inicio de la division y el final del arreglo subyacente. Las funciones nativas <code>len</code> y <code>cap</code> regresan esos valores.</p>
<p>Multiples slices pueden compartir el mismo arreglo subyacente y pueden referirse a partes superpuestas de ese arreglo. La Figura 4.1 muestra un arreglo de cadenas para los meses del año, y dos slices superpuestos del mismo. El arreglo se declara como</p>
<div class="highlight"><pre><span></span><span class="nx">meses</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&quot;Enero&quot;</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="s">&quot;Diciembre&quot;</span><span class="p">}</span>
</pre></div>
<p>asi Enero es <code>meses[1]</code> y Diciembre es <code>meses[12]</code>. Normalmente, el elemento de arreglo en el indice 0 contendria el primer valor, pero como los meses siempre estan numerados apartir de 1, podemos dejarlo fuera de la declaracion y se inicializara en una cadena vacia.</p>
<div class="figure" >
<p class="title">Figura 4.1. Dos slices superpuestos de un arreglo de meses.</p>
<figure>
<img src="img/Figure-4.1.jpg" />
</figure>
</div>
<p>El <em>operador de slice</em> <code>s[i:j]</code>, donde <code>0</code> ≤ <code>i</code> ≤ <code>j</code> ≤ <code>cap(s)</code>, crea un nuevo segmento que se refiere a los elementos de <code>i</code> a <code>j-1</code> de la secuencia <code>s</code>, que puede ser una variable del arreglo, un puntero a un arreglo u otra porcion. El slice resultante tiene <code>j-i</code> elementos. Si <code>i</code> se omite, es 0, y si <code>j</code> se omite, es <code>len(s)</code>. Asi, el slice <code>meses[1:13]</code> se refiere a toda la gama de meses validos, como lo hace el slice <code>meses[1:]</code>; el slice <code>meses[:]</code> se refiere a todo el arreglo. Vamos a definir slices superpuestos para el segundo trimestre y el verano boreal:</p>
<div class="highlight"><pre><span></span><span class="nx">Q2</span> <span class="o">:=</span> <span class="nx">meses</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nx">verano</span> <span class="o">:=</span> <span class="nx">meses</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Q2</span><span class="p">)</span>     <span class="c1">// [&quot;Abril&quot; &quot;Mayo&quot; &quot;Junio&quot;]</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">verano</span><span class="p">)</span> <span class="c1">// [&quot;Junio&quot; &quot;Julio&quot; &quot;Augosto&quot;]</span>
</pre></div>
<p>Junio ​​se incluye en ambos y es la unica salida de esta (ineficiente) prueba para elementos comunes:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">verano</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">q</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">Q2</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">q</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s aparece en ambos\n&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Seccionar mas alla de <code>cap(s)</code> causa un panico, pero seccionar mas alla <code>len(s)</code> extiende el slice, por lo que el resultado puede ser mas largo que el original:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">verano</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>    <span class="c1">// panico: fuera de rango</span>

<span class="nx">veranoSinFin</span> <span class="o">:=</span> <span class="nx">verano</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">// ampliar slice (dentro de la capacidad)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">veranoSinFin</span><span class="p">)</span>  <span class="c1">// &quot;[Junio Julio Augosto Septiembre Octubre]&quot;</span>
</pre></div>
<p>Como anotacion, tenga en cuenta la similitud de la operacion de subcadena en cadenas con el operador slice en slices de <code>[]byte</code>. Ambos se escriben <code>x[m:n]</code>, y ambos vuelven una subsecuencia de los bytes originales, compartiendo la representacion subyacente de modo que ambas operaciones toman tiempo constante. La expresion <code>x[m:n]</code> produce una cadena si <code>x</code> es una cadena, o un <code>[]byte</code> si <code>x</code> es un <code>[]byte</code>.</p>
<p>Dado que un slice contiene un puntero a un elemento de un arreglo, el paso de un slice a una funcion permite a la funcion modificar los elementos del arreglo subyacente. En otras palabras, la copia de una slice crea un alias (<a href="#Seccion-2.3.2" >§2.3.2</a>) para el arreglo subyacente. La funcion <code>reverse</code> invierte los elementos de un slice <code>[]int</code> en su lugar, y se puede aplicar a slices de cualquier longitud.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/rev/main.go" >gopl.io/ch4/rev</a></p>
<div class="highlight"><pre><span></span><span class="c1">// reverse invierte un slice de enteros en su posicion.</span>
<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aqui invertimos todo el conjunto:</p>
<div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">a</span><span class="p">[:])</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// &quot;[5 4 3 2 1 0]&quot;</span>
</pre></div>
<p>Una forma sencilla de <em>rotar</em> un slice a la izquierda <span class="math" >n</span> elementos es aplicar la funcion <code>reverse</code> tres veces, primero a los <span class="math" >n</span> elementos iniciales, luego a los elementos restantes, y finalmente a todo el slice. (Para rotar a la derecha, primero haga la tercer llamada.)</p>
<div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="c1">// rotar s a la izquierda dos posiciones.</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="nx">reverse</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// &quot;[2 3 4 5 0 1]&quot;</span>
</pre></div>
<p>Observe como la expresion que inicializa el slice <code>s</code> difiere de la del arreglo de <code>a</code>. Una <em>slice literal</em> se ve similar a un arreglo literal, una secuencia de valores separados por comas y rodeada por llaves, pero el tamaño no se proporciona. Esto crea implicitamente una variable de arreglo del tamaño correcto y produce una division que apunta a el. Al igual que con los arreglos literales, los slices literales pueden especificar los valores en orden, o dar sus indices explicitamente, o usar una mezcla de los dos estilos.</p>
<p>A diferencia de los arreglos, los slices no son comparables, por lo que no pueden usar <code>==</code> para probar si dos slices contienen los mismos elementos. La libreria estandar proporciona la funcion <code>bytes.Equal</code> altamente optimizada para comparar dos slices de bytes (<code>[]byte</code>), pero para otros tipos de slice, tenemos que hacer la comparacion nosotros mismos:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>En vista de lo natural, que es esta prueba de igualdad de la <q>profundidad</q>, y que no es mas costosa en tiempo de ejecucion que el operador <code>==</code> para arreglos de cadenas, puede ser desconcertante que la comparacion de slice no funcionen tambien de esta manera. Hay dos razones por las cuales la equivalencia de profunda es problematica. En primer lugar, a diferencia de los elementos del arreglo, los elementos de un slice son indirectos, lo que hace posible que una slice se contenga a si mismo. Aunque hay maneras de tratar con tales casos, ninguno es simple, eficiente, y lo mas importante, obvio.</p>
<p>En segundo lugar, debido a que los elementos del slice son indirectos, un valor fijo del slice puede contener diferentes elementos en momentos diferentes a medida que se modifican los contenidos del arreglo subyacente. Dado que una tabla hash como el tipo de mapa de Go solo hace copias poco profundas de sus claves, requiere que la igualdad para cada clave permanezca igual durante toda la vida de la tabla hash. La equivalencia profunda haria asi que los slices no fueran adecuados para ser utilizados como mapas de claves. Para los tipos de referencia como punteros y canales, el operador <code>==</code> prueba la <em>identidad de la referencia</em>, es decir, si las dos entidades se refieren a la misma cosa. Una prueba de igualdad <q>superficial</q> similar para slices podria ser util, y resolveria el problema con los mapas, pero el tratamiento inconsistente de slices y arreglos por el operador <code>==</code> seria confuso. La opcion mas segura es no permitir comparaciones de slices por completo.</p>
<p>La unica comparacion legal en slices es contra <code>nil</code>, como en</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">summer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>El valor cero de un tipo slice es <code>nil</code>. Un slice nil no tiene arreglo subyacente. El slice nil tiene longitud y capacidad cero, pero tambien hay slices no nulos de longitud y capacidad cero, como <code>[]int{}</code> o <code>make([]int, 3)[3:]</code>. Como con cualquier tipo que puede tener valores nulos, el valor nulo de un tipo de segmento particular puede ser escrito utilizando una expresion de conversion como <code>[]int(nil)</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>    <span class="c1">// len(s) == 0, s == nil</span>
<span class="nx">s</span> <span class="p">=</span> <span class="kc">nil</span>        <span class="c1">// len(s) == 0, s == nil</span>
<span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// len(s) == 0, s == nil</span>
<span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>    <span class="c1">// len(s) == 0, s != nil</span>
</pre></div>
<p>Por lo tanto, si usted necesita probar si una slice esta vacio, utilice <code>len(s) == 0</code>, no <code>s == nil</code>. Ademas de comparar la igualdad con <code>nil</code>, una slice nil se comporta como cualquier otro slice de longitud cero; por ejemplo, <code>reverse(nil)</code> es perfectamente seguro. A menos que se demuestre claramente lo contrario, las funciones de Go deben tratar todos los slices de longitud cero de la misma manera, sea o no nulo.</p>
<p>La funcion nativa <code>make</code> crea un slice de un tipo de elemento, con longitud y capacidad especifico. Se puede omitir el argumento capacidad, en cuyo caso la capacidad es igual a la longitud.</p>
<div class="highlight"><pre><span></span><span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
<span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span> <span class="c1">// igual que make([]T, cap)[:len]</span>
</pre></div>
<p>Bajo el capo, <code>make</code> crea una variable de arreglo sin nombre y devuelve un slice de este; El arreglo es accesible solo a traves del slice devuelto. En la primera forma, el slice es una vista de todo el arreglo. En el segundo, el slice es una vista de solo los primeros <code>len</code> elementos, pero su capacidad incluye toda el arreglo arreglo. Los elementos adicionales se reservan para el futuro crecimiento.</p>
</div>
<h4 id="Seccion-4.2.1" >La Funcion <code>append</code></h4>
<div class="hBody-4" >
<p>La funcion nativa <code>append</code> agrega elementos a slices:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">runes</span> <span class="p">[]</span><span class="kt">rune</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&quot;Hello, 世界&quot;</span> <span class="p">{</span>
  <span class="nx">runes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">runes</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q\n&quot;</span><span class="p">,</span> <span class="nx">runes</span><span class="p">)</span> <span class="c1">// &quot;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; &#39; &#39; &#39;B&#39; &#39;F&#39;]&quot;</span>
</pre></div>
<p>El bucle utiliza <code>append</code> para construir el slice codificado de nueve runas literales, aunque este problema especifico se resuelve mas convenientemente mediante el uso de la conversion nativa <code>[]rune(&quot;Hello, 世界&quot;)</code>.</p>
<p>La funcion <code>append</code> es crucial para la comprension de como trabajan los slices, asi que vamos a echar un vistazo a lo que esta pasando. Aqui hay una version llamada <code>appendInt</code> que se especializa en slices <code>[]int</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/append/main.go" >gopl.io/ch4/append</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="nx">zlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="nx">zlen</span> <span class="o">&lt;=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Hay espacio para crecer. Extiende el slice</span>
    <span class="nx">z</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[:</span><span class="nx">zlen</span><span class="p">]</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// No hay suficiente espacio.  Asigna un nuevo arreglo.</span>
    <span class="c1">// Crecer al doble, para compenzar la complejidad lineal.</span>
    <span class="nx">zcap</span> <span class="o">:=</span> <span class="nx">zlen</span>
    <span class="k">if</span> <span class="nx">zcap</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zcap</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">z</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">zlen</span><span class="p">,</span> <span class="nx">zcap</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// a built-in function; see text</span>
  <span class="p">}</span>
  <span class="nx">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">y</span>
  <span class="k">return</span> <span class="nx">z</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cada llamada a <code>appendInt</code> debe comprobar si el slice tiene capacidad suficiente para contener los nuevos elementos en el arreglo existente. Si es asi, se extiende el slice mediante la definicion de una slice mas grande (todavia dentro de la arreglo original), copia el elemento <code>y</code> en el nuevo espacio, y devuelve el slice. La entrada <code>x</code> y el resultado <code>z</code> comparten el misma arreglo subyacente.</p>
<p>Si no hay suficiente espacio para el crecimiento, <code>appendInt</code> debe asignar un nueva arreglo lo suficientemente grande para contener el resultado, copiar los valores de <code>x</code> en el y, a continuacion, añadir el nuevo elemento <code>y</code>. Ahora el resultado <code>z</code> hace referencia a un arreglo subyacente diferente al que referia el arreglo <code>x</code>.</p>
<p>Seria facil copiar los elementos con bucles explicitas, pero es mas facil utilizar la funcion nativa <code>copy</code>, que copia los elementos de un slice a otro del mismo tipo. Su primer argumento es el destino y el segundo es la fuente, parecido al orden de los operandos de una asignacion como <code>dst = src</code>. Los slices pueden referirse al mismo arreglo subyacente; Incluso pueden superponerse. Aunque no lo usamos aqui, <code>copy</code> devuelve el numero de elementos copiados realmente, que es la longitud del menor de los slices, por lo que no hay peligro de se acabe o sobreescriba algo fuera del rango.</p>
<p>Por eficiencia, el nueva arreglo es generalmente algo mayor que el minimo necesario para almacenar <code>x</code> y <code>y</code>. La expandir el arreglo duplicando su tamaño en cada expansion evita un numero excesivo de asignaciones y asegura que anexar un solo elemento tome un tiempo constante en promedio. Este programa demuestra el efecto:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="p">=</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d cap=%d\t%v\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">y</span><span class="p">),</span> <span class="nx">y</span><span class="p">)</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">y</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Cada cambio de capacidad indica una asignacion y una copia:</p>
<pre class="pre" >0  cap=1     [0]
1  cap=2     [0 1]
2  cap=4     [0 1 2]
3  cap=4     [0 1 2 3]
4  cap=8     [0 1 2 3 4]
5  cap=8     [0 1 2 3 4 5]
6  cap=8     [0 1 2 3 4 5 6]
7  cap=8     [0 1 2 3 4 5 6 7]
8  cap=16    [0 1 2 3 4 5 6 7 8]
9  cap=16    [0 1 2 3 4 5 6 7 8 9]</pre>
<p>Echemos un vistazo mas cercano a la iteracion <code>i=3</code>. El slice <code>x</code> contiene tres elementos <code>[0 1 2]</code>, pero tiene la capacidad de 4, por lo que hay un solo elemento de holgura en el extremo, y agrerar el elemento 3 procede sin reasignacion en <code>appendInt</code>. El slice <code>y</code> resultante tiene longitud y capacidad 4, y tiene el mismo arreglo subyacente que el slice <code>x</code> original, como lo muestra la Figura 4.2.</p>
<div class="figure" >
<p class="title">Figura 4.2. Adicion con espacio para crecer.</p>
<figure>
<img src="img/Figure-4.2.jpg" />
</figure>
</div>
<p>En la siguiente iteracion, <code>i=4</code>, no hay holgura en absoluto, por lo que <code>appendInt</code> asigna un nueva arreglo de tamaño 8, copia los cuatro elementos de <code>x</code> (<code>[0 1 2 3]</code>), y agrega 4, el valor de <code>i</code>. El slice resultante <code>y</code> tiene una longitud de 5, pero una capacidad de 8; La holgura de 3 guardara las siguientes tres iteraciones. Las slices <code>y</code> y <code>x</code> son vistas de diferentes arreglos. Esta operacion se muestra en la Figura 4.3.</p>
<div class="figure" >
<p class="title">Figura 4.3. Adicion sin crear espacio.</p>
<figure>
<img src="img/Figure-4.3.jpg" />
</figure>
</div>
<p>La funcion nativa <code>append</code> puede utilizar una estrategia de crecimiento mas sofisticado que la simplista <code>appendInt</code>. Por lo general, no sabemos si una llamada a <code>append</code> provocara una reasignacion, asi que no podemos asumir que el slice original se refiere al mismo arreglo que el slice resultante, ni que este se refiere a uno diferente. Del mismo modo, no debemos suponer que las operaciones sobre los elementos del antiguo slice se reflejaran (o no) en la nuevo slice. Como resultado de ello, es habitual asignar el resultado de una llamada a <code>append</code> al mismo slice cuyo valor pasamos a <code>append</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">runes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">runes</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</pre></div>
<p>La actualizacion de la variable slice se requiere no solo al llamar a <code>append</code>, sino tambien a cualquier funcion que pueda cambiar la longitud o la capacidad de una slice o hacer que se refiere a un arreglo subyacente diferente. Para usar los slices correctamente, es importante tener en cuenta que aunque los elementos del arreglo subyacente son indirectos, el puntero, la longitud y la capacidad de la slice no lo son. Para actualizarlos se requiere una asignacion como la anterior. En este sentido, los slices no son los tipos de referencia <q>puros</q>, sino que se asemejan a un tipo de agregado como esta estructura:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntSlice</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ptr</span>      <span class="o">*</span><span class="kt">int</span>
  <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<p>Nuestra funcion <code>appendInt</code> añade un elemento a un slice, pero el <code>append</code> nativo nos permite añadir mas de un elemento nuevo, o incluso todo un slice de ellos.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="o">...</span><span class="p">)</span> <span class="c1">// añade el slice x</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>      <span class="c1">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span>
</pre></div>
<p>Con la pequeña modificacion se muestra a continuacion, podemos hacer coincidir el comportamiento con el <code>append</code> nativo. Los puntos suspensivos (<code>&quot;...&quot;</code>) en la declaracion de <code>appendInt</code> crean una funcion <em>variadic</em>: acepta cualquier numero de argumentos finales. Los puntos suspensivos en la llamada <code>append</code> anterior muestran como suministrar una lista de argumentos apartir de un slice. Vamos a explicar este mecanismo en detalle en la <a href="#Seccion-5.7" >Seccion 5.7</a>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">appendInt</span><span class="p">(</span><span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">z</span> <span class="p">[]</span><span class="kt">int</span>
  <span class="nx">zlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
  <span class="c1">// ...expand z to at least zlen...</span>
  <span class="nb">copy</span><span class="p">(</span><span class="nx">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">):],</span> <span class="nx">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">z</span>
<span class="p">}</span>
</pre></div>
<p>La logica para expandir el arreglo <code>z</code> subyacente, se mantiene sin cambios y no se muestra.</p>
</div>
<h4 id="Seccion-4.2.2" >Tecnicas de Slices In Situ</h4>
<div class="hBody-4" >
<p>Veamos mas ejemplos de funciones que, como <code>rotate</code> y <code>reverse</code>, modifican los elementos de un slice en su lugar. Dada una lista de cadenas, la funcion <code>nonempty</code> devuelve las que no estan vacias:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/nonempty/main.go" >gopl.io/ch4/nonempty</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Nonempty es un ejemplo de algoritmo in situ.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="c1">// nonempty regresa un slice que contiene solo las cadenas no vacias.</span>
<span class="c1">// El arreglo subyacente se modifica durante la llamada.</span>
<span class="kd">func</span> <span class="nx">nonempty</span><span class="p">(</span><span class="nx">strings</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
      <span class="nx">strings</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
      <span class="nx">i</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">strings</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La parte sutil es que la porcion de entrada y la porcion de salida comparten el mismo arreglo subyacente. Esto evita la necesidad de asignar otro arreglo, aunque por supuesto los contenidos de datos se sobrescriben en parte, como se evidencia por la segunda instruccion de impresion:</p>
<div class="highlight"><pre><span></span><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;uno&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;tres&quot;</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q\n&quot;</span><span class="p">,</span> <span class="nx">nonempty</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="c1">// `[&quot;uno&quot; &quot;tres&quot;]`</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q\n&quot;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>           <span class="c1">// `[&quot;uno&quot; &quot;tres&quot; &quot;tres&quot;]`</span>
</pre></div>
<p>Por lo tanto normalmente escribe: <code>data = nonempty(data)</code>.</p>
<p>La funcion <code>nonempty</code> tambien se puede escribir utilizando <code>append</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nonempty2</span><span class="p">(</span><span class="nx">strings</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">out</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// slice del original con longitud cero</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strings</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
      <span class="nx">out</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>
</pre></div>
<p>Cualquiera que sea la variante que utilicemos, la reutilizacion de un arreglo de este modo requiere que se produzca como maximo un valor de salida para cada valor de entrada, lo que es cierto para muchos algoritmos que filtran elementos de una secuencia o combinan elementos adyacentes. Este uso intrincado de un slice es la excepcion, no la regla, pero puede ser clara, eficiente y util en ocasiones.</p>
<p>Se puede usar un slice para implementar una pila. Dada que tenemos un slice vacio <code>stack</code>, podemos empujar un nuevo valor en el extremo del slice con <code>append</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="c1">// push v</span>
</pre></div>
<p>La parte superior del stack es el ultimo elemento:</p>
<div class="highlight"><pre><span></span><span class="nx">top</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// parte superior del stack</span>
</pre></div>
<p>y para  sacar el elemento del stack es</p>
<div class="highlight"><pre><span></span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// sacar</span>
</pre></div>
<p>Para eliminar un elemento a la mitad de una slice, preservando el orden de los elementos restantes, utilice <code>copy</code> para deslizar los elementos de numeros mas altos hacia abajo por uno, para llenar el hueco:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">return</span> <span class="nx">slice</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &quot;[5 6 8 9]&quot;</span>
<span class="p">}</span>
</pre></div>
<p>Y si no necesitamos preservar el orden, podemos solo mover el ultimo elemento al hueco:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="nx">slice</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// &quot;[5 6 9 8]</span>
<span class="p">}</span>
</pre></div>
<p><b>Ejercicio 4.3</b>: Reescribir <code>reverse</code> para utilizar un puntero a un arreglo en lugar de un slice.</p>
<p><b>Ejercicio 4.4</b>: Escribir una version de <code>rotate</code> que opere en una sola pasada.</p>
<p><b>Ejercicio 4.5</b>: Escribir una funcion in situ para eliminar duplicados adyacentes en una slice <code>[]string</code>.</p>
<p><b>Ejercicio 4.6</b>: Escribir una funcion in situ que aplaste cada sequencia Unicode de espacios adyacentes (ver <code>unicode.IsSpace</code>) en un slice <code>[]byte</code> codificado en UTF-8 en solo espacio ASCII.</p>
<p><b>Ejercicio 4.7</b>: Modificar <code>reverse</code> para invertir in situ los caracteres de una slice <code>[]byte</code> que represente una cadena codificado en UTF-8. ¿Puedes hacerlo sin asignar nueva memoria?</p>
</div>
<h3 id="Seccion-4.3" >Mapas</h3>
<div class="hBody-3" >
<p>La tabla hash es una de las mas ingeniosas y versatiles de todas las estructuras de datos. Es una coleccion desordenada de pares clave/valor en la que todas las claves son distintas, y el valor asociado con una clave dada puede ser recuperado, actualizado o eliminado, usando un numero constante de comparaciones clave en promedio, no importa cuan grande sea el tamaño de la tabla hash.</p>
<p>En Go, un <em>mapa</em> es una referencia a una tabla hash, y un tipo de mapa se escribe como <code>map[K]V</code>, en donde <code>K</code> y <code>V</code> son los tipos de sus claves y valores. Todas las claves en un mapa son del mismo tipo, y todos los valores son del mismo tipo, pero las claves no necesitan ser del mismo tipo que los valores. El tipo de clave <code>K</code> debe ser comparable usando <code>==</code>, de modo que el mapa puede probar si una clave dada es igual a una que ya esta dentro de ell. Aunque los numeros de punto flotante son comparables, es una mala idea comparar floats por igualdad y, como mencionamos en el <a href="#Capitulo-3" >Capitulo 3</a>, es especialmente malo si NaN es un valor posible. No hay restricciones sobre el tipo de valor <code>V</code>.</p>
<p>Se puede utilizar la funcion nativa <code>make</code> para crear un mapa:</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// mapeo de cadenas a ints</span>
</pre></div>
<p>Tambien podemos usar un <em>mapa literal</em> para crear un nuevo mapa poblada con algunos pares iniciales clave/valor:</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
  <span class="s">&quot;alice&quot;</span><span class="p">:</span>   <span class="mi">31</span><span class="p">,</span>
  <span class="s">&quot;charlie&quot;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
<p>Esto es equivalente a</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">edades</span><span class="p">[</span><span class="s">&quot;alice&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">31</span>
<span class="nx">edades</span><span class="p">[</span><span class="s">&quot;charlie&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">34</span>
</pre></div>
<p>por lo que una expresion alternativa para un nuevo mapa vacio es <code>map[string]int{}</code>.</p>
<p>Los elementos del mapa se acceden a traves de la notacion de subindice usual:</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span><span class="p">[</span><span class="s">&quot;alice&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">32</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">edades</span><span class="p">[</span><span class="s">&quot;alice&quot;</span><span class="p">])</span> <span class="c1">// &quot;32&quot;</span>
</pre></div>
<p>y se remueve con la funcion nativa <code>delete</code>:</p>
<div class="highlight"><pre><span></span><span class="nb">delete</span><span class="p">(</span><span class="nx">edades</span><span class="p">,</span> <span class="s">&quot;alice&quot;</span><span class="p">)</span> <span class="c1">// remover elemento ages[&quot;alice&quot;]</span>
</pre></div>
<p>Todas estas operaciones son seguras incluso si el elemento no esta en el mapa; una busqueda en el mapa utulizando una clave que no esta presente devuelve el valor cero para su tipo, por ejemplo, lo siguiente funciona incluso cuando <code>&quot;bob&quot;</code> aun no es una clave en el mapa, por lo que el valor de <code>edades[&quot;bob&quot;]</code> sera 0.</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">edades</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// feliz cumpleaños!</span>
</pre></div>
<p>Las formas de asignacion abreviada <code>x += y</code> y <code>x++</code> tambien funcionan para elementos del mapa, asi que podemos rescribir la sentencia anterior como</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
<p>O incluso mas conciso como</p>
<div class="highlight"><pre><span></span><span class="nx">edades</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span><span class="o">++</span>
</pre></div>
<p>Pero un elemento del mapa no es una variable, y no podemos tomar su direccion:</p>
<div class="highlight"><pre><span></span><span class="nx">_</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ages</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span> <span class="c1">// error de compilacion: no puede tomar la direccion del elemento mapa</span>
</pre></div>
<p>Una de las razones por las que no podemos tomar la direccion de un elemento de un mapa es que el crecimiento de un mapa podria provocar la reorganizacion de elementos existentes en nuevas ubicaciones de almacenamiento, lo que podria invalidar la direccion.</p>
<p>Para enumerar todos los pares clave/valor en el mapa, se utiliza un bucle <code>for</code> basado en <code>range</code> similar al que vimos para los slices. Las iteraciones sucesivas del bucle hacen que las variables <code>name</code> y <code>age</code> se establecen en el siguiente par clave/valor:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">nombre</span><span class="p">,</span> <span class="nx">edad</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">edades</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\t%d\n&quot;</span><span class="p">,</span> <span class="nx">nombre</span><span class="p">,</span> <span class="nx">edad</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>El orden de iteracion del mapa no se especifica, y las diferentes implementaciones pueden utilizar una funcion de hash diferente, lo que conduce a un orden diferente. En la practica, el orden es aleatorio, variando de una ejecucion a la siguiente. Esto es intencional; Haciendo que la secuencia varie ayuda a obligar a los programas a ser robustos en todas las implementaciones. Para enumerar los pares clave/valor en orden, hay que ordenar las claves de forma explicita, por ejemplo, mediante la funcion <code>Strings</code> del paquete <code>sort</code> si las claves son cadenas. Este es un patron comun:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;sort&quot;</span>

<span class="kd">var</span> <span class="nx">nombres</span> <span class="p">[]</span><span class="kt">string</span>
<span class="k">for</span> <span class="nx">nombre</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">edades</span> <span class="p">{</span>
  <span class="nx">nombres</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nombres</span><span class="p">,</span> <span class="nx">nombre</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">nombres</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">nombre</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nombres</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\t%d\n&quot;</span><span class="p">,</span> <span class="nx">nombre</span><span class="p">,</span> <span class="nx">edades</span><span class="p">[</span><span class="nx">nombre</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>
<p>Dado que sabemos el tamaño final de nombres desde el principio, es mas eficiente asignar un arreglo del tamaño requerido por adelantado. La siguiente declaracion crea un slice que esta inicialmente vacio, pero tiene la capacidad suficiente para contener todas las llaves del mapa <em>edades</em>:</p>
<div class="highlight"><pre><span></span><span class="nx">nombres</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">edades</span><span class="p">))</span>
</pre></div>
<p>En el primer <code>range</code> del bucle anterior, solo necesitamos las llaves claves del mapa <code>edades</code>, por lo que se omite la segunda variable de bucle. En el segundo bucle, se requieren solo los elementos del slice <code>nombres</code>, por lo que se utiliza el identificador en blanco <code>_</code> para ignorar la primer variable, el indice.</p>
<p>El valor cero para el tipo de un mapa es <code>nil</code>, es decir, una referencia a ninguna tabla hash en absoluto.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">edades</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">edades</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>    <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">edades</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// &quot;true&quot;</span>
</pre></div>
<p>La mayoria de las operaciones en los mapas, incluyendo las operaciones de busqueda, <code>delete</code>, <code>len</code> y bucles <code>range</code>, son seguros para llevar a cabo en un mapa de referencia a <code>nil</code>, ya que se comporta como un mapa vacio. Pero almacenar en un mapa nil provoca un panico:</p>
<div class="highlight"><pre><span></span><span class="nx">ages</span><span class="p">[</span><span class="s">&quot;carol&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">21</span> <span class="c1">// panic: assignment to entry in nil map</span>
</pre></div>
<p>Debe asignar el mapa antes de poder almacenarlo.</p>
<p>El acceso a un elemento de un mapa mediante subindice siempre produce un valor. Si la clave esta presente en el mapa, se obtiene el valor correspondiente; si no, se obtiene el valor cero para el tipo de elemento, como hemos visto con <code>edades[&quot;bob&quot;]</code>. Para muchos propositos eso esta bien, pero a veces necesitas saber si el elemento estaba realmente ahi o no. Por ejemplo, si el tipo de elemento es numerico, es posible que tenga que distinguir entre un elemento inexistente y un elemento que tiene el valor cero, mediante una prueba como esta:</p>
<div class="highlight"><pre><span></span><span class="nx">edad</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">edades</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">]</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="cm">/* &quot;bob&quot; no es una clave en este mapa; edad == 0. */</span> <span class="p">}</span>
</pre></div>
<p>A menudo vera estas dos afirmaciones combinadas, como aqui:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ages</span><span class="p">[</span><span class="s">&quot;bob&quot;</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>El subindice de un mapa en este contexto produce dos valores; El segundo es un booleano que informa si el elemento estaba presente. La variable booleana a menudo se denomina <code>ok</code>, especialmente si se utiliza inmediatamente en una condicion <code>if</code>.</p>
<p>Como con los slices, los mapas no pueden ser compararse uno con otro; la unica comparacion legal es con <code>nil</code>. Para probar si dos mapas contienen las mismas claves y los mismos valores asociados, debemos escribir un bucle:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">xv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">yv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">y</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">yv</span> <span class="o">!=</span> <span class="nx">xv</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Observe como se utiliza <code>!ok</code> para distinguir los casos <q>que faltan</q> y los <q>presentes, pero en cero</q>. Si hubieramos escrito ingenuamente <code>xv != y[k]</code>, la llamada de abajo reportaria incorrectamente sus argumentos como iguales:</p>
<div class="highlight"><pre><span></span><span class="c1">// Verdadero si equal esta escrito incorrectamente.</span>
<span class="nx">equal</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;B&quot;</span><span class="p">:</span> <span class="mi">42</span><span class="p">})</span>
</pre></div>
<p>Go no proporciona un tipo <code>set</code>, pero ya que las claves de un mapa son distintas, un mapa puede servir a este proposito. Para ilustrarlo, el programa <code class="command" >dedup</code> lee una secuencia de lineas e imprime solo la primera ocurrencia de cada linea distinta. (Es una variante del programa <code class="command" >dup</code> que mostramos en la <a href="#Seccion-1.3" >Seccion 1.3</a>). El programa <code class="command" >dedup</code> utiliza un mapa cuyas claves representan el conjunto de lineas que ya han aparecido para asegurar que las ocurrencias posteriores no se impriman.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/dedup/main.go" >gopl.io/ch4/dedup</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">consulta</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// un conjunto de cadenas</span>
  <span class="nx">entrada</span>  <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">entrada</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">linea</span> <span class="o">:=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">consulta</span><span class="p">[</span><span class="nx">linea</span><span class="p">]</span> <span class="p">{</span>
      <span class="nx">consulta</span><span class="p">[</span><span class="nx">linea</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">linea</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">entrada</span><span class="p">.</span><span class="nx">Err</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;dedup: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los programadores de Go a menudo describen un mapa de esta manera utilizandolo como un <q>conjunto de cadenas</q> sin mas preambulos, pero cuidado, no todo los valores <code>map[string]bool</code> son conjuntos simples; algunos pueden contener valores tanto <code>true</code> y <code>false</code>.</p>
<p>A veces necesitamos un mapa o conjunto cuyas claves sean slices, pero ya que las claves de un mapa deben ser comparables, esto se no puede expresar directamente. Sin embargo, se puede hacer en dos pasos. Primero definimos una funcion auxiliar <code>k</code> que mapea cada clave en una cadena, con la caracteristica que <code>k(x) == k(y)</code> si y solo si consideramos <code>x</code> e <code>y</code> equivalentes. Luego creamos un mapa cuyas claves son cadenas, aplicando la funcion auxiliar a cada clave antes de acceder al mapa.</p>
<p>El siguiente ejemplo utiliza un mapa para registrar el numero de veces que se ha llamado a <code>Add</code> con una lista dada de cadenas. Utiliza <code>fmt.Sprintf</code> para convertir un slice de cadenas en una sola cadena que es una clave de mapa adecuada, citando cada elemento del slice con <code>%q</code> para registrar los limites de las cadena fielmente:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">k</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>  <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%q&quot;</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>       <span class="p">{</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">(</span><span class="nx">list</span><span class="p">)]</span><span class="o">++</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Count</span><span class="p">(</span><span class="nx">list</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">(</span><span class="nx">list</span><span class="p">)]</span> <span class="p">}</span>
</pre></div>
<p>El mismo enfoque se puede utilizar para cualquier tipo de clave no comparable, no solo para slices. Incluso es util para este tipo de claves comparables cuando se desea una definicion de igualdad distinta de <code>==</code>, como comparaciones entre mayusculas y minusculas para cadenas. Y el tipo de <code>k(x)</code> no necesita ser una cadena; Cualquier tipo comparable con la propiedad de equivalencia deseada lo hara, como enteros, arreglos o estructuras.</p>
<p>Aqui hay otro ejemplo de mapas en accion, un programa que cuenta las apariciones de cada punto de codigo Unicode distinto en su entrada. Puesto que hay un gran numero de caracteres posibles, solo una pequeña fraccion de ellos aparecera en cualquier documento en particular, un mapa es una manera natural de hacer un seguimiento de solo los que se han visto y su conteo correspondiente.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/charcount/main.go" >gopl.io/ch4/charcount</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Charcount calcula la cuenta de caracteres Unicode.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;bufio&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;unicode&quot;</span>
  <span class="s">&quot;unicode/utf8&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counts</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>    <span class="c1">// cuenta de caracteres Unicode</span>
  <span class="kd">var</span> <span class="nx">utflen</span> <span class="p">[</span><span class="nx">utf8</span><span class="p">.</span><span class="nx">UTFMax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">int</span> <span class="c1">// cuenta de longitudes de codificaciones UTF-8</span>
  <span class="nx">invalid</span> <span class="o">:=</span> <span class="mi">0</span>                    <span class="c1">// cuenta de caracteres UTF-8 invalidos</span>

  <span class="nx">in</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">.</span><span class="nx">ReadRune</span><span class="p">()</span>    <span class="c1">// regresa runa, nbytes, error</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;charcount: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ReplacementChar</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="nx">invalid</span><span class="o">++</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">counts</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span><span class="o">++</span>
    <span class="nx">utflen</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;rune\tcount\n&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">counts</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q\t%d\n&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&quot;\nlen\tcount\n&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">utflen</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\t%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">invalid</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\n%d invalid UTF-8 characters\n&quot;</span><span class="p">,</span> <span class="nx">invalid</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El metodo <code>ReadRune</code> realiza la decodificacion UTF-8 y devuelve tres valores: la runa decodificada, la longitud en bytes de su codificacion UTF-8, y un valor de error. El unico error que esperamos es el fin de archivo. Si la entrada no era la codificacion UTF-8 legal de una runa, la runa devuelta es <code>unicode.ReplacementChar</code> y la su longitud es 1.</p>
<p>El programa <code class="command" >charcount</code> tambien imprime un recuento de las longitudes de las codificaciones UTF-8 de las runas que aparecieron en la entrada. Un mapa no es la mejor estructura de datos para eso; ya que las longitudes de codificacion varian solo de 1 a utf8.UTFMax (que tiene el valor 4), un arreglo es mas compacto.</p>
<p>Como un experimento, en un momento ejecutamos <code class="command" >charcount</code>. Aunque (originalmente) esta principalmente en Ingles, por supuesto, tiene un buen numero de caracteres no ASCII. Aqui estan los diez primeros:</p>
<pre class="pre" >° 27 世 15 界 14 é 13 ˣ 10 ≤ 5 × 5 𢉩 4 � 4 □ 3</pre>
<p>Y aqui esta la distribucion de las longitudes de todas las codificaciones UTF-8:</p>
<pre class="pre" >len  count
1    765391
2    60
3    70
4    0</pre>
<p>El tipo de valor de un mapa puede ser un tipo compuesto, como un mapa o un slice. En el siguiente codigo, el tipo de la clave de <code>graph</code> es <code>string</code> y el tipo de valor es <code>map[string]bool</code>, lo que representa un conjunto de cadenas. Conceptualmente, <code>graph</code> asigna una cadena a un conjunto de cadenas relacionadas, sus sucesores en un grafo dirigido.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/graph/main.go" >gopl.io/ch4/graph</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">graph</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">addEdge</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">edges</span> <span class="o">:=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">]</span>
  <span class="k">if</span> <span class="nx">edges</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">edges</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">]</span> <span class="p">=</span> <span class="nx">edges</span>
  <span class="p">}</span>
  <span class="nx">edges</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">hasEdge</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">from</span><span class="p">][</span><span class="nx">to</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>addEdge</code> muestra la forma idiomatica para poblar un mapa perezosamente, es decir, para inicializar cada valor como su clave cuando aparece por primera vez. La funcion <code>hasEdge</code> muestra como el valor cero de una entrada del mapa que falta se pone a trabajar: incluso si no estan precentes ni <code>from</code> ni <code>to</code>, <code>graph[from][to]</code> siempre dara un resultado significativo.</p>
<p><b>Ejercicio 4.8</b>: Modificar <code class="command" >charcount</code> para contar letras, digitos, y demas en sus categorias Unicode, utilizando funciones como <code>unicode.IsLetter</code>.</p>
<p><b>Ejercicio 4.9</b>: Escribir un programa <code class="command" >wordfreq</code> para reportar la frecuencia de cada palabra en un archivo de texto de entrada. Llamar a <code>input.Split(bufio.ScanWords)</code> antes de la primer llamada a <code>Scan</code> para romper la entrada en palabras en lugar de lineas.</p>
</div>
<h3 id="Seccion-4.4" >Estructuras</h3>
<div class="hBody-3" >
<p>Una <em>estructura</em> es un tipo de datos agregada que agrupa de cero a mas valores con nombre de tipos arbitrarios como una entidad unica. Cada valor se denomina <em>campo</em>. El ejemplo clasico de una estructura de procesamiento de datos es el registro de un empleado, cuyos campos son un identificador unico, el nombre del empleado, direccion, fecha de nacimiento, posicion, salario, gerente y similares. Todos estos campos se recopilan en una sola entidad que puede ser copiada como una unidad, pasada a funciones y devuelta por ellas, almacenada en arreglos, y demas.</p>
<p>Estas dos declaraciones declaran un tipo de estructura llamada <code>Empleado</code> y una variable llamada <code>dilbert</code> que es una instancia de un <code>Empleado</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Empleado</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>        <span class="kt">int</span>
  <span class="nx">Nombre</span>    <span class="kt">string</span>
  <span class="nx">Direccion</span> <span class="kt">string</span>
  <span class="nx">DoB</span>       <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">Posicion</span>  <span class="kt">string</span>
  <span class="nx">Salario</span>   <span class="kt">int</span>
  <span class="nx">GerenteID</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">dilbert</span> <span class="nx">Empleado</span>
</pre></div>
<p>Los campos individuales de <code>dilbert</code> se accede usando la notacion de punto como <code>dilbert.Nombre</code> y <code>dilbert.DoB</code>. Puesto que <code>dilbert</code> es una variable, sus campos son variables tambien, por lo que podemos establecer un campo:</p>
<div class="highlight"><pre><span></span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Salario</span> <span class="o">-=</span> <span class="mi">5000</span> <span class="c1">// Rebajado, por escribir muy pocas lineas de codigo</span>
</pre></div>
<p>O tomar su direccion y acceder a ella a traves de un puntero:</p>
<div class="highlight"><pre><span></span><span class="nx">posicion</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">Posicion</span>
<span class="o">*</span><span class="nx">posicion</span> <span class="p">=</span> <span class="s">&quot;Senior &quot;</span> <span class="o">+</span> <span class="o">*</span><span class="nx">posicion</span> <span class="c1">// promovido, para subcontrata a Elbonia</span>
</pre></div>
<p>La notacion de punto tambien funciona con un puntero a una estructura:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">empleadoDelMes</span> <span class="o">*</span><span class="nx">Empleado</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">dilbert</span>
<span class="nx">empleadoDelMes</span><span class="p">.</span><span class="nx">Posicion</span> <span class="o">+=</span> <span class="s">&quot; (proactive team player)&quot;</span>
</pre></div>
<p>La ultima sentencia es equivalente a</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="nx">empleadoDelMes</span><span class="p">).</span><span class="nx">Posicion</span> <span class="o">+=</span> <span class="s">&quot; (proactive team player)&quot;</span>
</pre></div>
<p>Ya que un empleado tiene un ID unico, la funcion <code>EmpleadoPorID</code> devuelve un puntero a una estructura <code>Empleado</code>. Podemos usar la notacion de punto para acceder a sus campos:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">EmpleadoPorID</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Empleado</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">EmpleadoPorID</span><span class="p">(</span><span class="nx">dilbert</span><span class="p">.</span><span class="nx">GerenteID</span><span class="p">).</span><span class="nx">Posicion</span><span class="p">)</span> <span class="c1">// &quot;Jefe de pelo puntiagudo&quot;</span>

<span class="nx">id</span> <span class="o">:=</span> <span class="nx">dilbert</span><span class="p">.</span><span class="nx">ID</span>
<span class="nx">EmpleadoPorID</span><span class="p">(</span><span class="nx">id</span><span class="p">).</span><span class="nx">Salario</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// despedido por... ninguna razon real</span>
</pre></div>
<p>La ultima instruccion actualiza la estructura <code>Empleado</code> a la que apunta el resultado de la llamada a <code>EmpleadoPorID</code>. Si el tipo de resultado de <code>EmpleadoPorID</code> se cambiara a <code>Empleado</code> en lugar de <code>*Empleado</code>, la instruccion de asignacion no compilara ya que su lado izquierdo no identificaria a una variable.</p>
<p>Generalmente, se escribe un campo por linea, con el nombre del campo que precede a su tipo, pero pueden combinarse los campos consecutivos del mismo tipo, como con <code>Nombre</code> y <code>Direccion</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Empleado</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">ID</span>                <span class="kt">int</span>
  <span class="nx">Nombre</span><span class="p">,</span> <span class="nx">Direccion</span> <span class="kt">string</span>
  <span class="nx">DoB</span>               <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">Posicion</span>          <span class="kt">string</span>
  <span class="nx">Salario</span>           <span class="kt">int</span>
  <span class="nx">GerenteID</span>         <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<p>El orden del campo es significativo para identificar el tipo. Si hubieramos combinado tambien la declaracion del campo <code>Posicion</code> (tambien una cadena), o intercambiado <code>Nombre</code> y <code>Direccion</code>, estariamos definiendo un tipo de estructura diferente. Normalmente solo combinamos la declaracion de campos relacionados.</p>
<p>El nombre de un campo en la estructura se exporta si comienza con una letra mayuscula; este es el mecanismo principal de control de acceso en Go. Una estructura puede contener una mezcla de campos exportados y no exportados.</p>
<p>Los tipos estructura tienden a ser detallados porque a menudo implican una linea para cada campo. Aunque podriamos escribir todo el tipo cada vez que sea necesario, la repeticion cansaria. En cambio, los tipos estructura suelen aparecer dentro de la declaracion de un tipo con nombre como <code>Empleado</code>.</p>
<p>Un llamado tipo de estructura <code>S</code> no puede declarar un campo del mismo tipo <code>S</code>: un valor agregado no puede contenerse a si mismo. (Una restriccion analoga se aplica a los arreglos.) Pero <code>S</code> puede declarar un campo del tipo puntero <code>*S</code>, lo que nos permite crear estructuras de datos recursivas como listas enlazadas y arboles. Esto se ilustra en el siguiente codigo, que utiliza un arbol binario para implementar un tipo de insercion:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/treesort/sort.go" >gopl.io/ch4/treesort</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">tree</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span>       <span class="kt">int</span>
  <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">tree</span>
<span class="p">}</span>

<span class="c1">// Sort ordena los valores en su lugar.</span>
<span class="kd">func</span> <span class="nx">Sort</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">root</span> <span class="o">*</span><span class="nx">tree</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
    <span class="nx">root</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">[:</span><span class="mi">0</span><span class="p">],</span> <span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// appendValues agrega los alementos de t a los valores en orden</span>
<span class="c1">// y devuelve el slice resultante.</span>
<span class="kd">func</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">tree</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="nx">appendValues</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">values</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">tree</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Equivalente a regresar &amp;tree{value: value}.</span>
    <span class="nx">t</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span>
    <span class="k">return</span> <span class="nx">t</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">value</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">value</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">left</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">right</span> <span class="p">=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El valor cero de una estructura se compone de los valores cero de cada uno de sus campos. Por lo general, es deseable que el valor cero sea un defecto natural o razonable. Por ejemplo, en <code>bytes.Buffer</code>, el valor inicial de la estructura es un buffer vacio listo para su uso, y el valor cero de <code>sync.Mutex</code>, que veremos en el <a href="#Capitulo-9" >Capitulo 9</a>, es un mutex desbloqueado listo para usas. A veces este comportamiento inicial razonable ocurre de forma gratuita, pero a veces el diseñador de tipo tiene que trabajar en ello.</p>
<p>El tipo de una estructura sin campos se denomina <em>estructura vacia</em>, se escribe <code>struct{}</code>. Tiene un tamaño cero y no lleva ninguna informacion, sin embargo puede ser util. Algunos programadores lo utilizan en lugar de <code>bool</code> como el tipo de valor de un mapa que representa un conjunto, hacer hincapie en que solo las claves son significativas, pero el ahorro de espacio es marginal y la sintaxis es mas engorrosa, por lo que generalmente lo evitamos.</p>
<div class="highlight"><pre><span></span><span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span> <span class="c1">// conjunto de strings</span>
<span class="c1">// ...</span>
<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">seen</span><span class="p">[</span><span class="nx">s</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">seen</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
  <span class="c1">// ...primera ves viendo s...</span>
<span class="p">}</span>
</pre></div>
</div>
<h4 id="Seccion-4.4.1" >Estructuras Literales</h4>
<div class="hBody-4" >
<p>Un valor de un tipo de estructura se puede escribir usando una estructura literal que especifique los valores de sus campos.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</pre></div>
<p>Hay dos formas de struct literal. La primer forma, mostrada arriba, requiere que se especifique un valor de <em>cada</em> campo, en el orden correcto. Se carga al escritor (y al lector) el recordar exactamente cuales son los campos, y hace que el codigo sea fragil si el conjunto de campos crece mas tarde o se reordena. En consequencia, esta forma tiende a ser utilizado solo dentro del paquete que define el tipo de estructura o con tipos de estructuras mas pequeños para los cuales existe una convencion de ordenacion de campos obvia, como <code>image.Point{x, y}</code> o <code>color.RGBA{red, green, blue, alpha}</code>.</p>
<p>Mas a menudo, se utiliza la segunda forma, en la que una estructura se inicia haciendo una lista de todos o algunos de los nombres de los campos y sus valores correspondientes, como en esta declaracion del programa Lissajous de la <a href="#Seccion-1.4" >Seccion 1.4</a>:</p>
<div class="highlight"><pre><span></span><span class="nx">anim</span> <span class="o">:=</span> <span class="nx">gif</span><span class="p">.</span><span class="nx">GIF</span><span class="p">{</span><span class="nx">LoopCount</span><span class="p">:</span> <span class="nx">nframes</span><span class="p">}</span>
</pre></div>
<p>Si se omite un campo en este tipo de literal, se establece en el valor cero para su tipo. Ya que los nombres se proporcionan, el orden de los campos no importa.</p>
<p>Las dos formas no se pueden mezclar en el mismo literal. Tampoco se puede usar la primer forma de literal (basada en ordenes) para colarse alrededor de la regla de que los identificadores no exportados no pueden ser referidos desde otro paquete.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">p</span>
<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span> <span class="p">}</span> <span class="c1">// no se exportan a y b</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">q</span>
<span class="kn">import</span> <span class="s">&quot;p&quot;</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// error de compilacion: no se puede referenciar a, b</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>       <span class="c1">// error de compilacion: no se puede referenciar a, b</span>
</pre></div>
<p>Aunque la ultima linea no menciona los identificadores de campo no exportados, realmente los esta usando implicitamente, por lo que no es permitido.</p>
<p>Los valores de una estructura se pueden pasar como argumentos a funciones y ser devueltos. Por ejemplo, esta funcion escala un <code>Point</code> por un factor especifico:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Scale</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">factor</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">factor</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">factor</span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Scale</span><span class="p">(</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">// &quot;{5 10}&quot;</span>
</pre></div>
<p>Por eficiencia, las estructuras mas grandes normalmente se pasan a las funciones o se devuelven indirectamente mediante un puntero,</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Bonus</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Employee</span><span class="p">,</span> <span class="nx">percent</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">*</span> <span class="nx">percent</span> <span class="o">/</span> <span class="mi">100</span>
<span class="p">}</span>
</pre></div>
<p>Y esto es necesario si la funcion debe modificar su argumento, ya que en un lenguaje de llamada por valor como Go, la funcion llamada recibe solo una copia, no una referencia al argumento original.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">AwardAnnualRaise</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Employee</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">*</span> <span class="mi">105</span> <span class="o">/</span> <span class="mi">100</span>
<span class="p">}</span>
</pre></div>
<p>Debido a que las estructuras se manejan tan comunmente mediante punteros, es posible utilizar esta notacion conpacta para crear e inicializar una estructura y obtener su direccion:</p>
<div class="highlight"><pre><span></span><span class="nx">pp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</pre></div>
<p>Es exactamente equivalente a</p>
<div class="highlight"><pre><span></span><span class="nx">pp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Point</span><span class="p">)</span>
<span class="o">*</span><span class="nx">pp</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</pre></div>
<p>pero <code>&amp;Point{1, 2}</code> se puede utilizar directamente dentro de una expresion, como una llamada de funcion.</p>
</div>
<h4 id="Seccion-4.4.2" >Comparacion de estructuras</h4>
<div class="hBody-4" >
<p>Si todos los campos de una estructura son comparables, la estructura en si es comparable, por lo que se puede comparar dos expresiones de ese tipo usando <code>==</code> o <code>!=</code>. La operacion <code>==</code> compara los campos correspondientes de las dos estructuras en orden, por lo que las dos expresiones a continuacion son equivalentes:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span> <span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="nx">q</span><span class="p">)</span>                   <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>Las estructuras de tipos comparables, al igual que otros tipos comparables, se pueden utilizar como la clave de un mapa.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">address</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">hostname</span> <span class="kt">string</span>
  <span class="nx">port</span>     <span class="kt">int</span>
<span class="p">}</span>

<span class="nx">hits</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">address</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">hits</span><span class="p">[</span><span class="nx">address</span><span class="p">{</span><span class="s">&quot;golang.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">}]</span><span class="o">++</span>
</pre></div>
</div>
<h4 id="Seccion-4.4.3" >Estructura Enbebida y Campos Anonimos</h4>
<div class="hBody-4" >
<p>En esta seccion, veremos como utilizar el inusual mecanismo de <em>estructura enbebida</em> de Go que nos permite usar una estructura como un <em>campo anonimo</em> de otra estructura, proporcionando un acceso directo, sintacticamente conveniente para que una simple expresion de punto como <code>x.f</code> puede representar una cadena de campos como <code>x.d.e.f</code>.</p>
<p>Considere un programa de dibujo 2-D que proporciona una libreria de formas, como rectangulos, elipses, estrellas y ruedas. Aqui hay dos de los tipos que podria definir:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Circulo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">,</span> <span class="nx">Radio</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Rueda</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">,</span> <span class="nx">Radio</span><span class="p">,</span> <span class="nx">Rayos</span> <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<p>Un <code>Circulo</code> tiene campos para las coordenadas de su centro <code>X</code> y <code>Y</code>, y un <code>Radio</code>. Una <code>Rueda</code> tiene todas las caracteristicas de un <code>Circulo</code>, ademas de <code>Rayos</code>, el numero de radios radiales inscritos. Vamos a crear una rueda:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Rueda</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Radio</span> <span class="p">=</span> <span class="mi">5</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Rayos</span> <span class="p">=</span> <span class="mi">20</span>
</pre></div>
<p>A medida que el conjunto de formas crece, estamos obligados a notar semejanzas y repeticiones entre ellos, por lo que puede ser conveniente factorizar sus partes comunes:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Punto</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Circulo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Centro</span> <span class="nx">Punto</span>
  <span class="nx">Radio</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Rueda</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Circulo</span> <span class="nx">Circulo</span>
  <span class="nx">Rayos</span>   <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<p>La aplicacion puede ser mas clara para ello, pero este cambio hace que el acceso a los campos de una Rueda sea mas detallado:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Rueda</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circulo</span><span class="p">.</span><span class="nx">Centro</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circulo</span><span class="p">.</span><span class="nx">Centro</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Circulo</span><span class="p">.</span><span class="nx">Radio</span> <span class="p">=</span> <span class="mi">5</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Rayos</span> <span class="p">=</span> <span class="mi">20</span>
</pre></div>
<p>Go nos permite declarar un campo con un tipo pero sin nombre; estos campos se denominan campos anonimos. El tipo del campo debe ser un tipo con nombre o un puntero a un tipo con nombre. Debajo, <code>Circulo</code> y <code>Rueda</code> tienen un campo anonimo cada uno. Se dice que un <code>Punto</code> esta enbebido dentro del <code>Circulo</code>, y un <code>Circulo</code> esta enbebido dentro de la <code>Rueda</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Circulo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Punto</span>
  <span class="nx">Radio</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Rueda</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Circulo</span>
  <span class="nx">Rayos</span>   <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<p>Gracias al embebido, podemos referirnos a los nombres en las hojas del arbol implicitamento sin dar los nombres participantes:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">Rueda</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span>        <span class="c1">// equivalente a w.Circulo.Punto.X = 8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">8</span>        <span class="c1">// equivalente a w.Circulo.Punto.Y = 8</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Radio</span> <span class="p">=</span> <span class="mi">5</span>    <span class="c1">// equivalente a w.Circulo.Radio = 5</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Rayos</span> <span class="p">=</span> <span class="mi">20</span>
</pre></div>
<p>Las formas explicitas que se muestran en los comentarios anteriores siguen siendo validas, sin embargo, demuestra que <q>campo anonimo</q> es un termino inapropiado. Los campos <code>Circulo</code> y <code>Punto</code> tienen nombres–del tipo nombrado–pero esos nombres son opcionales en las expresiones de punto. Podemos omitir cualquiera o todos los campos anonimos al seleccionar sus subcampos.</p>
<p>Desafortunadamente, no hay una sintaxis compacta correspondiente para una estructura literal, por lo que ninguna de ellas compilara:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">}</span>                       <span class="c1">// error de compilacion: campos desconocidos</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">Wheel</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Radius</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">Spokes</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// error de compilacion: campos desconocidos</span>
</pre></div>
<p>La estructura literal debe seguir el formato de la declaracion del tipo, por lo que debemos utilizar una de las siguientes dos formas, que son equivalentes entre si:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/embed/main.go" >gopl.io/ch4/embed</a></p>
<div class="highlight"><pre><span></span>  <span class="nx">w</span> <span class="p">=</span> <span class="nx">Rueda</span><span class="p">{</span><span class="nx">Circulo</span><span class="p">{</span><span class="nx">Punto</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span> <span class="mi">5</span><span class="p">},</span> <span class="mi">20</span><span class="p">}</span>

  <span class="nx">w</span> <span class="p">=</span> <span class="nx">Rueda</span><span class="p">{</span>
    <span class="nx">Circulo</span><span class="p">:</span> <span class="nx">Circulo</span><span class="p">{</span>
      <span class="nx">Punto</span><span class="p">:</span>  <span class="nx">Punto</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="mi">8</span><span class="p">},</span>
      <span class="nx">Radio</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nx">Rayos</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="c1">// NOTA: comma necesaria aqui (y en el Radio)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
  <span class="c1">// Salida:</span>
  <span class="c1">// Rueda{Circulo:Circulo{Punto:Punto{X:8, Y:8}, Radio:5}, Rayos:20}</span>

  <span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">42</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
  <span class="c1">// Salida:</span>
  <span class="c1">// Rueda{Circulo:Circulo{Punto:Punto{X:42, Y:8}, Radio:5}, Rayos:20}</span>
</pre></div>
</div>
<p>Observe como el adverbio <code>#</code> hace que el verbo <code>%v</code> de <code>Printf</code> muestre los valores en una forma similar a la sintaxis Go. Para los valores de estructura, este formato incluye el nombre de cada campo.</p>
<p>Dado que los campos <q>anonimos</q> tienen nombres implicitos, no se puede tener dos campos anonimos del mismo tipo, ya que sus nombres entran en conflicto. Y debido a que el nombre del campo esta implicitamente determinado por su tipo, tambien lo es la visibilidad del campo. En los ejemplos anteriores, se exportan campos anonimos <code>Punto</code> y <code>Circulo</code>. Si no hubieran sido exportados (<code>punto</code> y <code>circulo</code>), podriamos utilizar la forma compacta</p>
<div class="highlight"><pre><span></span><span class="nx">w</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// equivalente a w.circulo.punto.X = 8</span>
</pre></div>
<p>pero el fomato explicito que se muestra en el comentario estaria prohibido fuera del paquete porque <code>circulo</code> y <code>punto</code> serian inaccesibles.</p>
<p>Lo que hemos visto hasta ahora sobre estructuras enbebidas es solo una pisca de azucar sintactico en la notacion de punto utilizada para seleccionar los campos de la estructura. Mas adelante, veremos que los campos anonimos no necesitan ser de tipo estructura; puede ser cualquier tipo con nombre o puntero a un tipo con nombre. Pero, ¿para que querrias incorporar un tipo que no tiene subcampos?</p>
<p>La respuesta tiene que ver con los metodos. La notacion compacta utilizada para seleccionar los campos de un tipo enbebido funciona para seleccionar tambien sus metodos. En efecto, el tipo de estructura externa gana no solo los campos del tipo enbebido sino tambien sus metodos. Este mecanismo es la forma principal en que los comportamientos de objetos complejos se componen de los mas simples. La composicion es fundamental para la programacion orientada a objetos en Go, y la exploraremos mas adelante en la <a href="#Seccion-6.3" >Seccion 6.3</a>.</p>
</div>
<h3 id="Seccion-4.5" >JSON</h3>
<div class="hBody-3" >
<p>JavaScript Object Notation (JSON) es una notacion estandar para enviar y recibir informacion estructurada. JSON no es la unica notacion. XML (<a href="#Seccion-7.14" >§7.14</a>), ASN.1, y Google’s Protocol Buffers sirven a propositos similares y cada uno tiene su nicho, pero debido a su simplicidad, facilidad de lectura, y un apoyo universal, JSON es el mas utilizado.</p>
<p>Go tiene un excelente soporte para la codificacion y decodificacion de estos formatos, proporcionado por los paquetes de las librerias estandar <code>encoding/json</code>, <code>encoding/xml</code>, <code>encoding/asn1</code>, y demas, y todos estos paquetes tienen APIs similares. En esta seccion se presenta una breve descripcion de las partes mas importantes del paquete <code>encoding/json</code>.</p>
<p>JSON es una codificacion de valores JavaScript–cadenas, numeros, booleanos, arreglos y objetos–como texto Unicode. Es una representacion eficiente pero legible para los tipos de datos basicos del <a href="#Capitulo-3" >Capitulo 3</a> y los tipos compuestos de este capitulo–arreglos, slices, estructuras, y mapas.</p>
<p>Los tipos JSON basicos son numeros (en notacion decimal o cientifica), booleanos (<code>true</code> o <code>false</code>), y cadenas, que son secuencias de puntos de codigo Unicode entre comillas dobles, con escapes mediante la barra invertida utilizando una notacion similar a Go, aunque los escapes JSON <code>\U</code><em>hhhh</em> denotan codigos UTF-16, no runas.</p>
<p>Estos tipos basicos se pueden combinar recursivamente utilizando arreglos JSON y objetos. Un arreglo JSON es una secuencia ordenada de valores, escrita como una lista separada por comas entre corchetes; los arreglos JSON se utilizan para codificar arreglos Go y slices. Un objeto JSON es un mapeo de cadenas a valores, escrito como una secuencia de pares <code>nombre:valor</code> separados por comas y rodeados por llaves; Los objetos JSON se usan para codificar mapas Go (con claves de tipo cadena) y estructuras. Por ejemplo:</p>
<table>
<tbody>
<tr><td><code>booleano</code></td><td><code>true</code></td></tr>
<tr><td><code>numero</code></td><td><code>-273.15</code></td></tr>
<tr><td><code>cadena</code></td><td><code>&quot;She said \&quot;Hello, 世界\&quot;&quot;</code></td></tr>
<tr><td><code>arreglo</code></td><td><code>[&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;]</code></td></tr>
<tr><td><code>objeto</code></td><td><code>{&quot;year&quot;: 1980, &quot;event&quot;: &quot;archery&quot;, &quot;medals&quot;: [&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;]}</code></td></tr>
</tbody>
</table>
<p>Considere una aplicacion que reune reseñas de peliculas y ofrece recomendaciones. A continuacion se declara un tipo de datos <code>Movie</code> y luego una lista de estos valores. (Los literales de cadena despues de las declaraciones <code>Year</code> y <code>Color</code> son etiquetas de campo; las explicaremos en un momento.)</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/movie/main.go" >gopl.io/ch4/movie</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Movie</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span>  <span class="kt">string</span>
  <span class="nx">Year</span>   <span class="kt">int</span>  <span class="s">`json:&quot;released&quot;`</span>
  <span class="nx">Color</span>  <span class="kt">bool</span> <span class="s">`json:&quot;color,omitempty&quot;`</span>
  <span class="nx">Actors</span> <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">movies</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">Movie</span><span class="p">{</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&quot;Casablanca&quot;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1942</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Humphrey Bogart&quot;</span><span class="p">,</span> <span class="s">&quot;Ingrid Bergman&quot;</span><span class="p">}},</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&quot;Cool Hand Luke&quot;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1967</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Paul Newman&quot;</span><span class="p">}},</span>
  <span class="p">{</span><span class="nx">Title</span><span class="p">:</span> <span class="s">&quot;Bullitt&quot;</span><span class="p">,</span> <span class="nx">Year</span><span class="p">:</span> <span class="mi">1968</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">Actors</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Steve McQueen&quot;</span><span class="p">,</span> <span class="s">&quot;Jacqueline Bisset&quot;</span><span class="p">}},</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Las estructuras de datos como esta son un excelente ajuste para JSON, y es facil de convertir en ambas direcciones. Convertir una estructura de datos Go como <code>movies</code> a JSON se denomina <em>marshaling</em>. La ordenacion se se realiza con <code>json.Marshal</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshal</span><span class="p">(</span><span class="nx">movies</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;JSON marshaling failed: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</pre></div>
<p><code>Marshal</code> produce una slice de bytes que contiene una cadena muy grande sin ningun espacio en blanco:</p>
<div class="highlight"><pre><span></span><span class="p">[{</span><span class="s">&quot;Title&quot;</span><span class="p">:</span><span class="s">&quot;Casablanca&quot;</span><span class="p">,</span><span class="s">&quot;released&quot;</span><span class="p">:</span><span class="mi">1942</span><span class="p">,</span><span class="s">&quot;Actors&quot;</span><span class="p">:[</span><span class="s">&quot;Humphrey Bogart&quot;</span><span class="p">,</span><span class="s">&quot;Ingrid Bergman&quot;</span><span class="p">]},{</span><span class="s">&quot;Title&quot;</span><span class="p">:</span><span class="s">&quot;Cool Hand Luke&quot;</span><span class="p">,</span><span class="s">&quot;released&quot;</span><span class="p">:</span><span class="mi">1967</span><span class="p">,</span><span class="s">&quot;color&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="s">&quot;Actors&quot;</span><span class="p">:[</span><span class="s">&quot;Paul Newman&quot;</span><span class="p">]},{</span><span class="s">&quot;Title&quot;</span><span class="p">:</span><span class="s">&quot;Bullitt&quot;</span><span class="p">,</span><span class="s">&quot;released&quot;</span><span class="p">:</span><span class="mi">1968</span><span class="p">,</span><span class="s">&quot;color&quot;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="s">&quot;Actors&quot;</span><span class="p">:[</span><span class="s">&quot;Steve McQueen&quot;</span><span class="p">,</span><span class="s">&quot;Jacqueline Bisset&quot;</span><span class="p">]}]</span>
</pre></div>
<p>Esta representacion compacta contiene toda la informacion, pero es dificil de leer. Para el consumo humano, una variante llamada <code>json.MarshalIndent</code> produce una salida perfectamente indentada. Dos argumentos adicionales definen un prefijo para cada linea de salida y una cadena para cada nivel de sangria:</p>
<div class="highlight"><pre><span></span><span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">MarshalIndent</span><span class="p">(</span><span class="nx">movies</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;    &quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;JSON marshaling failed: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</pre></div>
<p>El codigo anterior</p>
<div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="p">{</span>
        <span class="s">&quot;Title&quot;</span><span class="p">:</span> <span class="s">&quot;Casablanca&quot;</span><span class="p">,</span>
        <span class="s">&quot;released&quot;</span><span class="p">:</span> <span class="mi">1942</span><span class="p">,</span>
        <span class="s">&quot;Actors&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&quot;Humphrey Bogart&quot;</span><span class="p">,</span>
            <span class="s">&quot;Ingrid Bergman&quot;</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&quot;Title&quot;</span><span class="p">:</span> <span class="s">&quot;Cool Hand Luke&quot;</span><span class="p">,</span>
        <span class="s">&quot;released&quot;</span><span class="p">:</span> <span class="mi">1967</span><span class="p">,</span>
        <span class="s">&quot;color&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="s">&quot;Actors&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&quot;Paul Newman&quot;</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&quot;Title&quot;</span><span class="p">:</span> <span class="s">&quot;Bullitt&quot;</span><span class="p">,</span>
        <span class="s">&quot;released&quot;</span><span class="p">:</span> <span class="mi">1968</span><span class="p">,</span>
        <span class="s">&quot;color&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="s">&quot;Actors&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">&quot;Steve McQueen&quot;</span><span class="p">,</span>
            <span class="s">&quot;Jacqueline Bisset&quot;</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
<p>Marshaling utiliza los nombres de los campos en la estructura Go como los nombres de campo de los objetos JSON (mediante <em>reflexion</em>, como veremos en la <a href="#Seccion-12.6" >Seccion 12.6</a>). Solo se exportan los campos exportables, por lo que elegimos nombres en mayusculas para todos los nombres de campo.</p>
<p>Habra notado que el nombre del campo <code>Year</code> cambia a <code>released</code> en la salida, y <code>Color</code> cambia a <code>color</code> . Eso es debido a las etiquetas de los campos. Una etiqueta de campo es una cadena de metadatos asociados en tiempo de compilacion con el campo de una estructura:</p>
<div class="highlight"><pre><span></span><span class="nx">Year</span>  <span class="kt">int</span>  <span class="s">`json:&quot;released&quot;`</span>
<span class="nx">Color</span> <span class="kt">bool</span> <span class="s">`json:&quot;color,omitempty&quot;`</span>
</pre></div>
<p>Una etiqueta de campo puede ser cualquier cadena literal, pero se interpreta convencionalmente como una lista separada por espacios de pares <code>clave:&quot;valor&quot;</code>; Ya que contiene comillas dobles, las etiquetas de campo normalmente se escriben con literales de cadena sin formato. La clave <code>json</code> controla el comportamiento del paquete <code>encoding/json</code>, y otros paquetes <code>encoding/...</code> siguen esta convencion. La primera parte de la etiqueta de campo <code>json</code> especifica un nombre JSON alternativo para el campo Go. Las etiquetas de los campos a menudo se utilizan para especificar un nombre JSON idiomatico como <code>total_count</code> para un campo Go llamado <code>TotalCount</code>. La etiqueta <code>Color</code> tiene una opcion adicional, <code>omitempty</code>, lo que indica que no se debe producir ninguna salida JSON si el campo tiene el valor cero para su tipo (<code>false</code>, aqui) o esta vacia. Efectivamente, la salida JSON para Casablanca, una pelicula en blanco y negro, no tiene el campo <code>color</code>.</p>
<p>La operacion inversa para marshaling, la decodificacion de JSON y rellenar una estructura de datos Go, se denomina <em>unmarshaling</em>, y se realiza por <code>json.Unmarshal</code>. El codigo de abajo descoloca los datos de la pelicula JSON en un slice de estructuras cuyo unico campo es Title . De esta manera, al definir estructuras de datos Go adecuadas, podemos seleccionar que partes de la entrada JSON se deben descifrar y cuales descartar. Cuando <code>Unmarshal</code> regresa, se ha llenado el slice con la informacion de <code>Title</code>; Otros nombres en el JSON se ignoran.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">titles</span> <span class="p">[]</span><span class="kd">struct</span><span class="p">{</span> <span class="nx">Title</span> <span class="kt">string</span> <span class="p">}</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">titles</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;JSON unmarshaling failed: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">titles</span><span class="p">)</span> <span class="c1">// &quot;[{Casablanca} {Cool Hand Luke} {Bullitt}]&quot;</span>
</pre></div>
<p>Muchos servicios web proporcionan una interfaz JSON–se hace una solicitud con HTTP y devuelve la informacion deseada en formato JSON. Para ilustrarlo, vamos a consultar el seguimiento de problemas en GitHub con su interfaz de servicio web. Primero definiremos los tipos y constantes necesarios:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/github/github.go" >gopl.io/ch4/github</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete github proporciana una API en Go para el seguimiento de problemas.</span>
<span class="c1">// Ver https://developer.github.com/v3/search/#search-issues.</span>
<span class="kn">package</span> <span class="nx">github</span>

<span class="kn">import</span> <span class="s">&quot;time&quot;</span>

<span class="kd">const</span> <span class="nx">IssuesURL</span> <span class="p">=</span> <span class="s">&quot;https://api.github.com/search/issues&quot;</span>

<span class="kd">type</span> <span class="nx">IssuesSearchResult</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">TotalCount</span> <span class="kt">int</span> <span class="s">`json:&quot;total_count&quot;`</span>
  <span class="nx">Items</span>      <span class="p">[]</span><span class="o">*</span><span class="nx">Issue</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Issue</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Number</span>    <span class="kt">int</span>
  <span class="nx">HTMLURL</span>   <span class="kt">string</span> <span class="s">`json:&quot;html_url&quot;`</span>
  <span class="nx">Title</span>     <span class="kt">string</span>
  <span class="nx">State</span>     <span class="kt">string</span>
  <span class="nx">User</span>      <span class="o">*</span><span class="nx">User</span>
  <span class="nx">CreatedAt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`json:&quot;created_at&quot;`</span>
  <span class="nx">Body</span>      <span class="kt">string</span>    <span class="c1">// En formato Markdown</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Login</span>   <span class="kt">string</span>
  <span class="nx">HTMLURL</span> <span class="kt">string</span> <span class="s">`json:&quot;html_url&quot;`</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como antes, los nombres de todos los campos de estructura deben estar en mayuscula incluso si sus nombres JSON no. Sin embargo, el proceso de coincidencia que asocia los nombres de JSON con los nombres de una estructura de Go durante el unmarshaling no distingue entre mayusculas y minusculas, por lo que solo es necesario utilizar una etiqueta de campo cuando hay un subrayado en el nombre JSON pero no en el nombre Go. Una vez mas, estamos siendo selectivos acerca de que campos decodificar; La respuesta de busqueda de GitHub contiene considerablemente mas informacion de la que mostramos aqui.</p>
<p>La funcion <code>SearchIssues</code> realiza una peticion HTTP y decodifica el resultado como JSON. Puesto que los terminos de consulta presentados por un usuario pueden contener caracteres como <code>?</code> y <code>&amp;</code> que tienen un significado especial en una URL, usamos <code>url.QueryEscape</code> para asegurar de que se tomen literalmente.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/github/search.go" >gopl.io/ch4/github</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">github</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;encoding/json&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;net/http&quot;</span>
  <span class="s">&quot;net/url&quot;</span>
  <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="c1">// SearchIssues consulta el seguimiento de problemas de GitHub.</span>
<span class="kd">func</span> <span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">terms</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">IssuesSearchResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">q</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">QueryEscape</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">terms</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">IssuesURL</span> <span class="o">+</span> <span class="s">&quot;?q=&quot;</span> <span class="o">+</span> <span class="nx">q</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// Debemos cerrar resp.Body en todas las rutas de ejecucion.</span>
  <span class="c1">// (El Capitulo 5 presenta &#39;defer&#39;, lo que simplifica esto.)</span>
  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;search query failed: %s&quot;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">result</span> <span class="nx">IssuesSearchResult</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nx">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los ejemplos anteriores utilizaron <code>json.Unmarshal</code> para decodificar todo el contenido de una slice de bytes como una sola entidad JSON. Para variar, este ejemplo utiliza el decodificador de <em>flujo</em>, <code>json.Decoder</code>, que permite que varias entidades JSON sean decodificados en secuencia desde el mismo flujo, aunque aqui no necesitamos esa caracteristica. Como era de esperar, hay un codificador de flujo correspondiente llamado <code>json.Encoder</code>.</p>
<p>La llamada a <code>Decode</code> rellena la variable <code>result</code>. Hay varias maneras en que podemos dar un formato agradable a su valor. A continuacion mostramos el mas simple, con el commando <code>issues</code>, es como una tabla de texto con columnas de ancho fijo, pero en la siguiente seccion vamos a ver un enfoque mas sofisticado basado en plantillas.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/issues/main.go" >gopl.io/ch4/issues</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Issues imprime una tabla de coincidencia de problemas que coinciden</span>
<span class="c1">// con los terminos de busqueda</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;os&quot;</span>

  <span class="s">&quot;gopl.io/ch4/github&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">github</span><span class="p">.</span><span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d issues:\n&quot;</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">TotalCount</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;#%-5d %9.9s %.55s\n&quot;</span><span class="p">,</span>
      <span class="nx">item</span><span class="p">.</span><span class="nx">Number</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">User</span><span class="p">.</span><span class="nx">Login</span><span class="p">,</span> <span class="nx">item</span><span class="p">.</span><span class="nx">Title</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los argumentos de linea de comandos especifican los terminos de busqueda. El comando siguiente consulta el rastreador de problemas del proyecto Go para la lista de errores abiertos relacionados con la descodificacion JSON:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch4/issues
$ ./issues repo:golang/go is:open json decoder
<span class="m">13</span> issues:
<span class="c1">#5680    eaigner encoding/json: set key converter on en/decoder</span>
<span class="c1">#6050  gopherbot encoding/json: provide tokenizer</span>
<span class="c1">#8658  gopherbot encoding/json: use bufio</span>
<span class="c1">#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span>
<span class="c1">#5901        rsc encoding/json: allow override type marshaling</span>
<span class="c1">#9812  klauspost encoding/json: string tag not symmetric</span>
<span class="c1">#7872  extempora encoding/json: Encoder internally buffers full output</span>
<span class="c1">#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin</span>
<span class="c1">#6716  gopherbot encoding/json: include field name in unmarshal error me</span>
<span class="c1">#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi</span>
<span class="c1">#6384    joeshaw encoding/json: encode precise floating point integers u</span>
<span class="c1">#6647    btracey x/tools/cmd/godoc: display type kind of each named type</span>
<span class="c1">#4237  gjemiller encoding/base64: URLEncoding padding is optional</span>
</pre></div>
<p>La interfaz de servicio web en GitHub <a href="https://developer.github.com/v3/" >https://developer.github.com/v3/</a> tiene muchas mas funciones delas que tenemos espacio para mostrar aqui.</p>
<p><b>Ejercicio 4.10</b>: Modificar <code>issues</code> para reportar los resultados en categorias de edad, es decir menos de un mes de edad, menos de un año de edad, y mas de un año de edad.</p>
<p><b>Ejercicio 4.11</b>: Construir una herramienta que permite a los usuarios crear, leer, actualizar y eliminar los problemas de GitHub desde la linea de comandos, invocando su editor de texto preferido cuando se requiera la introduccion de texto sustancial.</p>
<p><b>Ejercicio 4.12</b>: El popular comic web <em>xkcd</em> tiene una interfaz JSON. Por ejemplo, una solicitud a <a href="https://xkcd.com/571/info.0.json" >https://xkcd.com/571/info.0.json</a> produce una descripcion detallada del comic 571, uno de mis muchos favoritos. Descargue cada URL (una vez) y construya un indice sin conexion. Escriba una herramienta <code class="command" >xkcd</code> que, utilizando este indice, imprima la URL y transcripcion de cada comic que coincida con un termino de busqueda proporcionado en la linea de comandos.</p>
<p><b>Ejercicio 4.13</b>: El servicio web basado en JSON de Open Movie Database le permite buscar en <a href="https://omdbapi.com/" >https://omdbapi.com/</a> una pelicula por su nombre y descargar la su imagen del poster. Escriba una herramienta <code class="command" >poster</code> que descargue la imagen del poster de la pelicula que se nombre en la linea de comandos.</p>
</div>
<h3 id="Seccion-4.6" >Plantillas de Texto y HTML</h3>
<div class="hBody-3" >
<p>El ejemplo anterior muestra como hacer el formato lo mas simple posible, para lo cual <code>Printf</code> es completamente adecuado. Pero a veces el formato debe ser mas elaborado, y es deseable separar el formato del codigo completamente. Esto se puede hacer con los paquetes <code>text/template</code> y <code>html/template</code>, que proporcionan un mecanismo para la sustitucion de los valores de las variables en una plantilla de texto o HTML.</p>
<p>Una plantilla es una cadena o un archivo que contiene una o mas partes encerradas entre llaves dobles, <code>{{...}}</code>, llamadas <em>acciones</em>. La mayor parte de la cadena se imprime literalmente, pero las acciones desencadenan otros comportamientos. Cada accion contiene una expresion en el lenguaje de la plantilla, una notacion sencilla pero poderosa para imprimir valores, seleccionar de campos de la estructura, llamar a la funciones y metodos, expresar el flujo de control, como sentencias <code>if</code>-<code>else</code> y bucles <code>range</code>, y crear instancias de otras plantillas. A continuacion se muestra una cadena de plantilla simple:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/issuesreport/main.go" >gopl.io/ch4/issuesreport</a></p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">templ</span> <span class="p">=</span> <span class="s">`{{.TotalCount}} issues:</span>
<span class="s">{{range .Items}}----------------------------------------</span>
<span class="s">Number: {{.Number}}</span>
<span class="s">User:   {{.User.Login}}</span>
<span class="s">Title:  {{.Title | printf &quot;%.64s&quot;}}</span>
<span class="s">Age:    {{.CreatedAt | daysAgo}} days</span>
<span class="s">{{end}}`</span>
</pre></div>
</div>
<p>Esta plantilla primero imprime el numero de problemas encontrados, luego imprime el numero, usuario, titulo y edad en dias de cada uno. Dentro de una accion, hay una nocion del valor actual, denominado como <q>punto</q> y escrita como <q>.</q>, un punto. El punto se refiere inicialmente al parametro de la plantilla, que sera en este ejemplo <code>github.IssuesSearchResult</code>. La accion <code>{{.TotalCount}}</code> expande al valor del campo <code>TotalCount</code>, que se imprime en la forma habitual. Las acciones <code>{{range .Items}}</code> y <code>{{end}}</code> crean un bucle, por lo que el texto entre ellos se expande varias veces, con el punto ligado a elementos sucesivos de <code>Items</code>.</p>
<p>Dentro de una accion, la notacion <code>|</code> hace que el resultado de una operacion sea el argumento de otra, analoga a una tuberia del shell de Unix. En el caso de <code>Title</code>, la segunda operacion es la funcion <code>printf</code>, que es un sinonimo nativo para <code>fmt.Sprintf</code> en todas las plantillas. Para <code>Age</code>, la segunda operacion es la funcion, <code>daysAgo</code>, que convierte el campo <code>CreatedAt</code> en el tiempo transcurrido, usando <code>time.Since</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">daysAgo</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">t</span><span class="p">).</span><span class="nx">Hours</span><span class="p">()</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Observe que el tipo de <code>CreatedAt</code> es <code>time.Time</code>, no <code>string</code>. Del mismo modo que un tipo puede controlar su formato de cadena (<a href="#Seccion-2.5" >§2.5</a>) mediante la definicion de ciertos metodos, un tipo puede definir tambien metodos para controlar su comportamiento para el marshaling y unmarshaling JSON. El valor marshaling JSON de un <code>time.Time</code> es una cadena en un formato estandar.</p>
<p>Producir la salida con una plantilla es un proceso de dos pasos. Primero debemos analizar la plantilla en una representacion interna adecuada, y luego ejecutarla en entradas especificas. El analisis se debe hacer solo una vez. El siguiente codigo crea y analiza la plantilla templ definida anteriormente. Observe el encadenamiento de llamadas a metodos: <code>template.New</code> crea y devuelve una plantilla; <code>Funcs</code> añade <code>daysAgo</code> al conjunto de funciones accesibles dentro de esta plantilla, luego, devuelve esa plantilla; Por ultimo, se llama a <code>Parse</code> en el resultado.</p>
<div class="highlight"><pre><span></span><span class="nx">report</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;report&quot;</span><span class="p">).</span>
  <span class="nx">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span><span class="s">&quot;daysAgo&quot;</span><span class="p">:</span> <span class="nx">daysAgo</span><span class="p">}).</span>
  <span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Dado que las plantillas suelen fijarse en tiempo de compilacion, la falta de analisis de una plantilla indica un error fatal en el programa. La funcion auxiliar <code>template.Must</code> hace que el manejo de errores sea mas conveniente: acepta una plantilla y un error, comprueba que el error es nil (y panicos de lo contrario) y, luego devuelve la plantilla. Volveremos a esta idea en la <a href="#Seccion-5.9" >Seccion 5.9</a>.</p>
<p>Una vez la plantilla ha sido creada, aumentada con <code>daysAgo</code>, analizada y comprobada, podemos ejecutarla utilizando como fuente de datos <code>github.IssuesSearchResult</code> y <code>os.Stdout</code> como el destino:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">report</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;issuelist&quot;</span><span class="p">).</span>
  <span class="nx">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span><span class="s">&quot;daysAgo&quot;</span><span class="p">:</span> <span class="nx">daysAgo</span><span class="p">}).</span>
  <span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">))</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">github</span><span class="p">.</span><span class="nx">SearchIssues</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">report</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>El programa imprime un informe en texto plano como este:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch4/issuesreport
$ ./issuesreport repo:golang/go is:open json decoder
<span class="m">13</span> issues:
---------------------------------------
Number: <span class="m">5680</span>
User:   eaigner
Title:  encoding/json: <span class="nb">set</span> key converter on en/decoder
Age:    <span class="m">750</span> days
---------------------------------------
Number: <span class="m">6050</span>
User:   gopherbot
Title:  encoding/json: provide tokenizer
Age:    <span class="m">695</span> days
---------------------------------------
...
</pre></div>
<p>Ahora pasemos al paquete <code>html/template</code>. Utiliza el mismo API y el mismo lenguaje de expresion que <code>text/template</code> pero añade caracteristicas para el escape automatico y apropiado de cadanes que aparecen dentro de HTML, JavaScript, CSS o URLs. Estas caracteristicas pueden ayudar a evitar un problema de seguridad perenne de la generacion de HTML, un <em>ataque de inyeccion</em>, en el que un adversario crea un valor de cadena como el titulo de un tema, para incluir codigo malicioso, que cuando se escapa indebidamente por una plantilla, les da control sobre la pagina.</p>
<p>La plantilla siguiente muestra la lista de temas como una tabla HTML. Observe la diferente importacion:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/issueshtml/main.go" >gopl.io/ch4/issueshtml</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;html/template&quot;</span>

<span class="kd">var</span> <span class="nx">issueList</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;issuelist&quot;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="s">`</span>
<span class="s">&lt;h1&gt;{{.TotalCount}} issues&lt;/h1&gt;</span>
<span class="s">&lt;table&gt;</span>
<span class="s">&lt;tr style=&#39;text-align: left&#39;&gt;</span>
<span class="s">  &lt;th&gt;#&lt;/th&gt;</span>
<span class="s">  &lt;th&gt;State&lt;/th&gt;</span>
<span class="s">  &lt;th&gt;User&lt;/th&gt;</span>
<span class="s">  &lt;th&gt;Title&lt;/th&gt;</span>
<span class="s">&lt;/tr&gt;</span>
<span class="s">{{range .Items}}</span>
<span class="s">&lt;tr&gt;</span>
<span class="s">  &lt;td&gt;&lt;a href=&#39;{{.HTMLURL}}&#39;&gt;{{.Number}}&lt;/a&gt;&lt;/td&gt;</span>
<span class="s">  &lt;td&gt;{{.State}}&lt;/td&gt;</span>
<span class="s">  &lt;td&gt;&lt;a href=&#39;{{.User.HTMLURL}}&#39;&gt;{{.User.Login}}&lt;/a&gt;&lt;/td&gt;</span>
<span class="s">  &lt;td&gt;&lt;a href=&#39;{{.HTMLURL}}&#39;&gt;{{.Title}}&lt;/a&gt;&lt;/td&gt;</span>
<span class="s">&lt;/tr&gt;</span>
<span class="s">{{end}}</span>
<span class="s">&lt;/table&gt;</span>
<span class="s">`</span><span class="p">))</span>
</pre></div>
</div>
<p>El siguiente comando ejecuta la nueva plantilla en los resultados de una consulta ligeramente diferente:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch4/issueshtml
$ ./issueshtml repo:golang/go commenter:gopherbot json encoder &gt;issues.html
</pre></div>
<p>La figura 4.4 muestra la apariencia de la tabla en un navegador web. Los enlaces se conectan a las paginas web apropiadas en GitHub.</p>
<div class="figure" >
<p class="title">Figura 4.4. Una tabla HTML de los temas del proyecto Go relacionados con la codificacion JSON.</p>
<figure>
<img src="img/Figure-4.4.jpg" />
</figure>
</div>
<p>Ninguno de los temas en la Figura 4.4 representan un desafio para HTML, pero podemos ver el efecto mas claramente con temas cuyos titulos contienen metacaracteres HTML como <code>&amp;</code> y <code>&lt;</code>. Hemos seleccionado dos problemas para este ejemplo:</p>
<div class="highlight"><pre><span></span>$ ./issueshtml repo:golang/go <span class="m">3133</span> <span class="m">10535</span> &gt;issues2.html
</pre></div>
<p>La Figura 4.5 muestra el resultado de esta consulta. Observe que el paquete <code>html/template</code> de forma automatica escapa los titulos HTML de modo que aparezcan literalmente. Si por error hubieramos usado el paquete <code>text/template</code>, la cadena de cuatro caracteres &quot;&amp;lt;&quot; se habria convertido en el caracter <code>'&lt;'</code> y la cadena <code>&quot;&lt;link&gt;&quot;</code> se habria convertido en un elemento <code>link</code>, cambiando la estructura del documento HTML y tal vez comprometiendo su seguridad.</p>
<p>Podemos suprimir este comportamiento de auto-escape para los campos que contienen datos HTML confiables mediante el uso de un  tipo de cadena denominada <code>template.HTML</code> en lugar de <code>string</code> . Existen tipos con nombres similares para JavaScript, CSS y URL de confianza. El siguiente programa demuestra el principio usando  campos con el mismo valor, pero con diferentes tipos: c(A) es un <code>string</code> y <code>B</code> es un <code>template.HTML</code>.</p>
<div class="figure" >
<p class="title">Figura 4.5. Los metacaracteres HTML del titulos de temas se muestran correctamente.</p>
<figure>
<img src="img/Figure-4.5.jpg" />
</figure>
</div>
<div class="figure" >
<p class="title"><a href="gopl.io/ch4/autoescape/main.go" >gopl.io/ch4/autoescape</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">templ</span> <span class="p">=</span> <span class="s">`&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`</span>
  <span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;escape&quot;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">templ</span><span class="p">))</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">A</span> <span class="kt">string</span>        <span class="c1">// texto sin fiavilidad</span>
    <span class="nx">B</span> <span class="nx">template</span><span class="p">.</span><span class="nx">HTML</span> <span class="c1">// HTML confiable</span>
  <span class="p">}</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">A</span> <span class="p">=</span> <span class="s">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="s">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La Figura 4.6 muestra la salida de la plantilla tal como aparece en un navegador. Podemos ver que <code>A</code> esta sujeto a escapar, pero <code>B</code> no.</p>
<div class="figure" >
<p class="title">Figura 4.6. Los valores de cadena tinen escapado HTML escapado, pero los valores <code>template.HTML</code> no.</p>
<figure>
<img src="img/Figure-4.6.jpg" />
</figure>
</div>
<p>Tenemos espacio aqui para mostrar solo las caracteristicas mas basicas del sistema de plantillas. Como siempre, para obtener mas informacion, consulte la documentacion del paquete:</p>
<div class="highlight"><pre><span></span>$ go doc text/template
$ go doc html/template
</pre></div>
<p><b>Ejercicio 4.14</b>: Crear un servidor web que consulta GitHub una vez y luego permita la navegacion de la lista de informe de errores, hitos y usuarios.</p>
</div>
<h2 id="Capitulo-5" >Funciones</h2>
<div class="hBody-2" >
<p>Una funcion nos permite envolver una secuencia de sentencias como una unidad que se puede llamar desde cualquier lugar de un programa, tal vez varias veces. Las funciones hacen posible romper un gran trabajo en pedazos mas pequeños que bien podrian ser escritos por diferentes personas separadas por el tiempo y el espacio. Una funcion oculta sus detalles de implementacion a sus usuarios. Por todas estas razones, las funciones son una parte critica de cualquier lenguaje de programacion.</p>
<p>Ya hemos visto muchas funciones. Ahora tomaremos un tiempo para una discusion mas exhaustiva. El ejemplo de ejecucion de este capitulo es un rastreador web, es decir, el componente de un motor de busqueda web responsable de buscar paginas web, descubrir los vinculos dentro de ellas, buscar las paginas identificadas por dichos vinculos, etc. Un rastreador web nos da una amplia oportunidad para explorar la recursividad, funciones anonimas, manejo de errores y aspectos de funciones que son unicos de Go.</p>
</div>
<h3 id="Seccion-5.1" >Declaracion de Funciones</h3>
<div class="hBody-3" >
<p>Una declaracion de funcion tiene un nombre, una lista de parametros, una lista opcional de resultados y un cuerpo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">rombre</span><span class="p">(</span><span class="nx">lista</span><span class="o">-</span><span class="nx">de</span><span class="o">-</span><span class="nx">parametros</span><span class="p">)</span> <span class="p">(</span><span class="nx">lista</span><span class="o">-</span><span class="nx">de</span><span class="o">-</span><span class="nx">resultados</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">cuerpo</span>
<span class="p">}</span>
</pre></div>
<p>La lista de parametros especifica el nombres y tipos de los <em>parametros</em> de la funcion, que son las variables locales cuyos valores o argumentos son suministrados por quien hace la llamada. La lista de resultados especifica los tipos de los valores que devuelve la funcion. Si la funcion devuelve un resultado sin nombre o ningun resultado, los parentesis son opcionales y normalmente se omiten. Dejar fuera la lista de resultados declara completamente que una funcion que no devuelve ningun valor y se llama solo por sus efectos. En la funcion <code>hypot</code>,</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
</pre></div>
<p><code>x</code> y <code>y</code> son parametros en la declaracion, <code>3</code> y <code>4</code> son argumentos de la llamada, y la funcion devuelve un valor <code>float64</code>.</p>
<p>Al igual que los parametros, los resultados pueden tener nombre. En ese caso, cada nombre declara una variable local inicializada al valor cero para su tipo.</p>
<p>Una funcion que tiene una lista de resultados debe terminar con una declaracion <code>return</code>, a menos que la ejecucion claramente no pueda llegar al final de la funcion, tal vez porque la funcion termina con una llamada a <code>panic</code> o un bucle <code>for</code> infinito sin <code>break</code>.</p>
<p>Como hemos visto con <code>hypot</code>, una secuencia de parametros o resultados del mismo tipo puede ser un factor para que el propio tipo se escriba una sola vez. Estas dos declaraciones son equivalentes:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span>                <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>Aqui hay cuatro formas de declarar una funcion con dos parametros y un resultado, todos de tipo <code>int</code>. El identificador en blanco puede usarse para enfatizar que un parametro no se utiliza.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>   <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">z</span> <span class="kt">int</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">z</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">first</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">zero</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>      <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">add</span><span class="p">)</span>   <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">sub</span><span class="p">)</span>   <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">first</span><span class="p">)</span> <span class="c1">// &quot;func(int, int) int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">zero</span><span class="p">)</span>  <span class="c1">// &quot;func(int, int) int&quot;</span>
</pre></div>
<p>El tipo de una funcion a veces se denomina su <em>firma</em>. Dos funciones tienen el mismo tipo o firma si tienen la misma secuencia de tipos de parametros y la misma secuencia de tipos de resultados. Los nombres de los parametros y resultados no afectan al tipo, ni tampoco si se declararon utilizando el formto factorizado.</p>
<p>Cada llamada de funcion debe proporcionar un argumento para cada parametro, en el orden en que se declararon los parametros. Go no tiene concepto de valores de parametro predeterminados, ni ninguna forma de especificar argumentos por nombre, por lo que los nombres de parametros y resultados no importan al llamador, excepto como documentacion.</p>
<p>Los parametros son variables locales dentro del cuerpo de la funcion, con sus valores iniciales establecidos a los argumentos proporcionados por quien realiza la llamada. Los parametros de funcion y los resultados con nombre son variables en el mismo bloque lexico que las variables locales mas externas de la funcion.</p>
<p>Los argumentos se pasan por valor, por lo que la funcion recibe una copia de cada argumento; Las modificaciones a la copia no afectan a la persona que llama. Sin embargo, si el argumento contiene algun tipo de referencia, como un puntero, slice, mapa, funcion o canal, entonces la persona que llama puede verse afectada por las modificaciones que hace la funcion de las variables que referencian <em>indirectamente</em> por el argumento.</p>
<p>De vez en cuando puede encontrar una declaracion de funcion sin un cuerpo, lo que indica que la funcion se implementa en un idioma que no es Go. Dicha declaracion define la firma de la funcion.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">math</span>

<span class="kd">func</span> <span class="nx">Sin</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="c1">// implementado en lenguaje ensamblador</span>
</pre></div>
</div>
<h3 id="Seccion-5.2" >Recursividad</h3>
<div class="hBody-3" >
<p>Las funciones pueden ser <em>recursivas</em>, es decir, que pueden llamarse a si mismas, ya sea directa o indirectamente. La recursion es una tecnica poderosa para muchos problemas, y por supuesto es esencial para procesar estructuras de datos recursivas. En la <a href="#Seccion-4.4" >Seccion 4.4</a>, se utilizo la recursividad sobre un arbol para implementar un mecanismo de insercion sencillo. En esta seccion, volveremos a usarlo para procesar documentos HTML.</p>
<p>El siguiente programa de ejemplo utiliza un paquete no estandar, <code>golang.org/x/net/html</code>, que proporciona un analizador de HTML. Los repositorios <code>golang.org/x/...</code> tienen paquetes diseñados y mantenidos por el equipo de Go para aplicaciones tales como redes, procesamiento de texto internacionalizado, plataformas moviles, manipulacion de imagenes, criptografia, y herramientas de desarrollo. Estos paquetes no estan en la libreria estandar porque todavia estan en desarrollo o porque son raramente necesarios por la mayoria de los programadores de Go.</p>
<p>Las partes de  la API <code>golang.org/x/net/html</code> que tendremos que se muestran a continuacion. La funcion <code>html.Parse</code> lee una secuencia de bytes, los analiza, y devuelve la raiz del arbol del documento HTML, que es un <code>html.Node</code>. HTML tiene varios tipos de nodos–texto, comentarios, etc.–pero aqui solo nos interesan con nodos de elemento de la forma <code>&lt;nombre clave='valor'&gt;</code>.</p>
<div class="figure" >
<p class="title"><code>golang.org/x/net/html</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">html</span>
<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Type</span>                    <span class="nx">NodeType</span>
  <span class="nx">Data</span>                    <span class="kt">string</span>
  <span class="nx">Attr</span>                    <span class="p">[]</span><span class="nx">Attribute</span>
  <span class="nx">FirstChild</span><span class="p">,</span> <span class="nx">NextSibling</span> <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NodeType</span> <span class="kt">int32</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">ErrorNode</span> <span class="nx">NodeType</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">TextNode</span>
  <span class="nx">DocumentNode</span>
  <span class="nx">ElementNode</span>
  <span class="nx">CommentNode</span>
  <span class="nx">DoctypeNode</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Attribute</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Key</span><span class="p">,</span> <span class="nx">Val</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>La funcion <code>main</code> analiza la entrada estandar como HTML, extrae los enlaces usando un cuncion recursiva <code>visit</code>, e imprime cada enlace descubierto:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/findlinks1/main.go" >gopl.io/ch5/findlinks1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Findlinks1 imprime los enlaces en un documento HTML leido en la entrada estandar</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>

  <span class="s">&quot;golang.org/x/net/html&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;findlinks1: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>visit</code> atraviesa un arbol de nodos HTML, extrae el enlace desde el atributo <code>href</code> de cada elemento de <em>anclaje</em> <code>&lt;a href='...'&gt;</code>, añade los enlaces a un slice de strings, y devuelve el slice resultante:</p>
<div class="highlight"><pre><span></span><span class="c1">// visit agrega los enlaces de cada enlace encontrado en n y devuelve el resultado</span>
<span class="kd">func</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="s">&quot;href&quot;</span> <span class="p">{</span>
        <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">links</span> <span class="p">=</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">links</span>
<span class="p">}</span>
</pre></div>
<p>Para descender por el arbol a un nodo <code>n</code>, <code>visit</code> se llama a si misma recursivamente para cada uno de los hijos de <code>n</code>, que se mantienen en el lista enlazada <code>FirstChild</code>.</p>
<p>Vamos a ejecutar <code class="command" >findlinks</code> en la pagina principal de Go, canalizando el resultado de <code class="command" >fetch</code> (<a href="#Seccion-1.5" >§1.5</a>) a la entrada de <code class="command" >findlinks</code>. Hemos modificado la salida ligeramente por brevedad.</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ go build gopl.io/ch5/findlinks1
$ ./fetch https://golang.org <span class="p">|</span> ./findlinks1
<span class="c1">#</span>
/doc/
/pkg/
/help/
/blog/
http://play.golang.org/
//tour.golang.org/
https://golang.org/dl/
//blog.golang.org/
/LICENSE
/doc/tos.html
http://www.google.com/intl/en/policies/privacy/
</pre></div>
<p>Observe la variedad de formas de enlaces que aparecen en la pagina. Mas adelante veremos como resolverlos con relacion al URL base, <code>https://golang.org</code>, para crear URL absolutas.</p>
<p>El siguiente programa utiliza la recursion sobre el arbol de nodos HTML para imprimir la estructura del arbol en esquema. Cuando encuentra cada elemento, empuja la etiqueta del elemento sobre una pila, luego imprime la pila.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/outline/main.go" >gopl.io/ch5/outline</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;outline: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">outline</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span> <span class="c1">// push tag</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">outline</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Considere una sutileza: aunque <code>outline</code> <q>empuja</q> un elemento en el <code>stack</code>, no hay ninguna extraccion correspondiente. Cuando <code>outline</code> se llama a si misma de forma recursiva, el receptor recibe una copia del <code>stack</code>. Aunque el destinatario de la llamada puede añadir elementos a este slice, modificando de su arreglo subyacente e incluso asignando un nuevo arreglo, no modifica los elementos iniciales que son visibles para quien realiza la llamada, asi que cuando la funcion regresa, el <code>stack</code> del llamantede es tal cual antes de la llamada.</p>
<p>Aqui esta el esquema de <code>https://golang.org</code>, editado nuevamente por razones de brevedad:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch5/outline
$ ./fetch https://golang.org <span class="p">|</span> ./outline
<span class="o">[</span>html<span class="o">]</span>
<span class="o">[</span>html head<span class="o">]</span>
<span class="o">[</span>html head meta<span class="o">]</span>
<span class="o">[</span>html head title<span class="o">]</span>
<span class="o">[</span>html head link<span class="o">]</span>
<span class="o">[</span>html body<span class="o">]</span>
<span class="o">[</span>html body div<span class="o">]</span>
<span class="o">[</span>html body div<span class="o">]</span>
<span class="o">[</span>html body div div<span class="o">]</span>
<span class="o">[</span>html body div div form<span class="o">]</span>
<span class="o">[</span>html body div div form div<span class="o">]</span>
<span class="o">[</span>html body div div form div a<span class="o">]</span>
</pre></div>
<p>Como puede ver mediante la experimentacion con <code>outline</code>, la mayoria de los documentos HTML pueden ser procesados con solo unos pocos niveles de recursividad, pero no es dificil de construir paginas web patologicas que requieren una recursion extremadamente profunda.</p>
<p>Muchas implementaciones de lenguaje de programacion utilizan una funcion stack de tamaño fijo; Tamaños de 64KB a 2MB son tipicos. Pilas de tamaño fijo imponen un limite en la profundidad de la recursividad, por lo que hay que tener cuidado para evitar un desbordamiento de pila cuando se atraviesa grandes estructuras de datos de forma recursiva; Las pilas de tamaño fijo pueden incluso suponer un riesgo para la seguridad. En contraste, las implementaciones tipicas de Go usan pilas de tamaño variable que comienzan pequeñas y crecen segun sea necesario hasta un limite del orden de un gigabyte. Esto nos permite usar la recursion de forma segura y sin preocuparnos por el desbordamiento.</p>
<p><b>Ejercicio 5.1</b>: Cambiar el programa <code class="command" >findlinks</code> para atravesar la lista enlazada <code>n.FirstChild</code> mediante llamadas recursivas a <code>visit</code> en lugar de un bucle.</p>
<p><b>Ejercicio 5.2</b>: Escribir una funcion para rellenar un mapeo con los nombres de los elementos–<code>p</code>, <code>div</code>, <code>span</code>, y asi sucesivamente-al numero de elementos con ese nombre en un arbol de documentos HTML.</p>
<p><b>Ejercicio 5.3</b>: Escribir una funcion para imprimir el contenido de todos los nodos de texto en un arbol de documentos HTML. No descender dentro de elementos <code>&lt;script&gt;</code> o <code>&lt;style&gt;</code>, ya que sus contenidos no son visibles en un navegador web.</p>
<p><b>Ejercicio 5.4</b>: Extender la funcion <code>visit</code> para que los extractos otros tipos de enlaces desde el documento, como imagenes, scripts y hojas de estilo.</p>
</div>
<h3 id="Seccion-5.3" >Multiples Valores de Retorno</h3>
<div class="hBody-3" >
<p>Una funcion puede devolver mas de un resultado. Hemos visto muchos ejemplos de funciones de paquetes estandar que devuelven dos valores, el resultado computacional deseado y un valor de error o booleano que indica si el calculo funciono. El siguiente ejemplo muestra como escribir una nosotros mismos.</p>
<p>El programa siguiente es una variacion de <code class="command" >findlinks</code> que hace la peticion HTTP por si mismo, asi que ya no necesitamos para ejecutar <code class="command" >fetch</code>. Ya que las operaciones de analisis y HTTP pueden fallar, <code class="command" >findLinks</code> declara dos resultados: la lista de enlaces descubiertos y un error. Por cierto, el analizador de HTML por lo general puede recuperarse de una entrada incorrecta y construir un documento que contiene nodos de error, por lo <code>Parse</code> raramente falla; Cuando lo hace, normalmente se debe a errores de E/S subyacentes.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/findlinks2/main.go" >gopl.io/ch5/findlinks2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
    <span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;findlinks2: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">links</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// findLinks realiza una peticion HTTP GET por la url, analiza la</span>
<span class="c1">// respuesta como HTML, y extrae y regresa los enlaces.</span>
<span class="kd">func</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;getting %s: %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">visit</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">doc</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hay cuatro sentencias <code>return</code> en <code>findLinks</code>, cada uno de las cuales devuelve un par de valores. Los tres primeros <code>return</code> hacen la funcion pase los errores subyacentes de los paquetes <code>http</code> y <code>html</code> al llamador. En el primer caso, el error se devuelve sin cambios; en el segundo y tercero, que expande con informacion de contexto adicional con <code>fmt.Errorf</code> (<a href="#Seccion-7.8" >§7.8</a>). Si <code>findLinks</code> tiene exito, la ultima sentencia <code>return</code> devuelve el slice de enlaces, sin error.</p>
<p>Debemos asegurarnos de cerrar <code>resp.Body</code> para que los recursos de red se liberen adecuadamente, incluso en caso de error. El recolector de basura de Go recicla la memoria no utilizada, pero no asume que liberara recursos del sistema operativo no utilizados como archivos abiertos y conexiones de red. Deberan cerrarse explicitamente.</p>
<p>El resultado de llamar a una funcion multi-valor es una tupla de valores. El llamador de tal funcion debe asignar explicitamente los valores a las variables si se desea utilizar alguna de ellas:</p>
<div class="highlight"><pre><span></span><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</pre></div>
<p>Para ignorar uno de los valores, asintelo al identificador en blanco:</p>
<div class="highlight"><pre><span></span><span class="nx">links</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="c1">// errors ignored</span>
</pre></div>
<p>El resultado de una llamada multi-valor en si puede ser devuelto desde una llamada funcion (multi-valor), como en esta funcion que se comporta como <code>findLinks</code> pero registra su argumento:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">findLinksLog</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;findLinks %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Una llamada multi-valor puede aparecer como el unico argumento cuando se llama a una funcion de multiples parametros. Aunque rara vez se utiliza en codigo de produccion, esta caracteristica es a veces conveniente durante la depuracion, ya que nos permite imprimir todos los resultados de una llamada utilizando una sola sentencia. Las dos instrucciones de impresion siguientes tienen el mismo efecto.</p>
<div class="highlight"><pre><span></span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">))</span>

<span class="nx">links</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">findLinks</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</pre></div>
<p>Los nombres bien elegidos pueden documentar la importancia de los resultados de una funcion. Los nombres son particularmente valiosos cuando una funcion devuelve multiples resultados del mismo tipo, como</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Size</span><span class="p">(</span><span class="nx">rect</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">)</span> <span class="p">(</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">file</span> <span class="kt">string</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">HourMinSec</span><span class="p">(</span><span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">hour</span><span class="p">,</span> <span class="nx">minute</span><span class="p">,</span> <span class="nx">second</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>
<p>Pero no siempre es necesario nombrar multiples resultados unicamente para la documentacion. Por ejemplo, la convencion dicta que un resultado final <code>bool</code> indica el exito; un resultado erroneo a menudo no necesita explicacion.</p>
<p>En una funcion con resultados nombrados, se pueden omitir los operandos de una sentencia de devolucion. Esto se llama un <code>retorno desnudo</code>.</p>
<div class="highlight"><pre><span></span><span class="c1">// CountWordsAndImages realiza una peticion HTTP GET para la URL del</span>
<span class="c1">// documento HTML y regresa el numero de palabras e imagenes que contiene.</span>
<span class="kd">func</span> <span class="nx">CountWordsAndImages</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing HTML: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="p">=</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">countWordsAndImages</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">words</span><span class="p">,</span> <span class="nx">images</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>Un retorno desnudo es una forma abreviada de devolver cada una de las variables de resultado nombradas en orden, por lo que en la funcion anterior, cada sentencia <code>return</code> es equivalente a</p>
<div class="highlight"><pre><span></span><span class="k">return</span> <span class="nx">words</span><span class="p">,</span> <span class="nx">images</span><span class="p">,</span> <span class="nx">err</span>
</pre></div>
<p>En funciones como esta, con muchas declaraciones de retorno y varios resultados, los resultados desnudos pueden reducir la duplicacion de codigo, pero rara vez hacen que el codigo sea mas facil de entender. Por ejemplo, no es obvio a primera vista que los dos primeros resultados son equivalentes a <code>return 0, 0, err</code> (porque las variables de resultado <code>words</code> e <code>images</code> se inicializan con sus valores cero) y que el ultimo <code>return</code> es equivalente a <code>return words, images, nil</code>. Por esta razon, es mejor utilizar los resultados desnudos con moderacion.</p>
<p><b>Ejercicio 5.5</b>: Implementar <code>countWordsAndImages</code>. (Ver el ejercicio 4.9 para la division de palabras.)</p>
<p><b>Ejercicio 5.6</b>: Modificar la funcion <code>corner</code> en <code>gopl.io/ch3/surface</code> (<a href="#Seccion-3.2" >§3.2</a>) para utilizar resultados con nombre y una declaracion de retorno desnudo.</p>
</div>
<h3 id="Seccion-5.4" >Errores</h3>
<div class="hBody-3" >
<p>Algunas funciones siempre tienen exito en su tarea. Por ejemplo, <code>strings.Contains</code> y <code>strconv.FormatBool</code> tienen bien definidos todos los posibles valores de los argumentos y no pueden fallar–salvo escenarios catastroficos e impredecibles como quedarse sin memoria, donde el sintoma esta lejos de la causa y de la cual hay poca esperanza de recuperacion.</p>
<p>Otras funciones siempre tienen exito siempre y cuando se cumplan sus condiciones previas. Por ejemplo, la funcion <code>time.Date</code> siempre construye un <code>time.Time</code> a partir de sus componentes–año, mes, y asi sucesivamente–a menos que el ultimo argumento (la zona horaria) sea <code>nil</code>, en cuyo caso se entra en panico. Este panico es un signo seguro de un error en el codigo de llamada y nunca debe suceder en un programa bien escrito.</p>
<p>Para muchas otras funciones, incluso en un programa bien escrito, el exito no esta asegurado porque depende de factores ajenos al control del programador. Cualquier funcion que haga E/S, por ejemplo, debe enfrentarse a la posibilidad de error, y solo un programador ingenuo cree que una simple lectura o escritura no puede fallar. De hecho, es cuando las operaciones mas confiables fallan inesperadamente que necesitamos saber por que.</p>
<p>Los errores son, por lo tanto, una parte importante de la API de un paquete o de la interfaz de usuario de una aplicacion, y el error es solo uno de varios comportamientos esperados. Este es el enfoque que Go toma respecto al manejo de errores.</p>
<p>Una funcion cuyo fallo es un comportamiento esperado devuelve un resultado adicional, convencionalmente el ultimo. Si el fallo tiene solo una causa posible, el resultado es un valor booleano, generalmente llamado <code>ok</code>, como en este ejemplo de una busqueda en la cache que siempre tiene exito a menos que no hubiera ninguna entrada para esa clave:</p>
<div class="highlight"><pre><span></span><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...cache[key] does not exist...</span>
<span class="p">}</span>
</pre></div>
<p>Mas a menudo, y especialmente para E/S, el fallo puede tener una variedad de causas para las cuales el llamador necesitara una explicacion. En tales casos, el tipo del resultado adicional es <code>error</code>.</p>
<p>El tipo nativo <code>error</code> es un tipo de interfaz. Veremos mas de lo que esto significa y sus implicaciones para el manejo de errores en el <a href="#Capitulo-7" >Capitulo 7</a>. Por ahora es suficiente saber que un error puede ser o no <code>nil</code>, que nil implica el exito y no-nil implica el fracaso, y que un error no-nil tiene una cadena del mensaje de error que se puede obtener llamando a su metodo <code>Error</code> o imprimir mediante <code>fmt.Println(err)</code> o <code>fmt.Printf(&quot;%v&quot;, err)</code>.</p>
<p>Normalmente cuando una funcion devuelve un error no-nil, sus otros resultados son indefinidos y se deben ignorar. Sin embargo, algunas funciones pueden devolver resultados parciales en casos de error. Por ejemplo, si se produce un error durante la lectura de un archivo, una llamada a <code>Read</code> devuelve el numero de bytes que fue capaz de leer <em>y</em> un valor <code>error</code> que describe el problema. Para el comportamiento correcto, algunos llamadores pueden necesitar procesar los datos incompletos antes de manejar el error, por lo que es importante que estas funciones documente claramente sus resultados.</p>
<p>El enfoque de Go lo diferencia de muchos otros lenguajes en los que se reportan fallos utilizando <em>excepciones</em>, no valores normales. Aunque Go tiene un mecanismo de excepcion, como veremos en la <a href="#Seccion-5.9" >Seccion 5.9</a>, se utiliza solo para informar de los errores realmente inesperadas que indican un error, no los errores de rutina que un programa robusto deberia esperar.</p>
<p>La razon de este diseño es que las excepciones tienden a enredar la descripcion de un error con el flujo de control requerido para manejarlo, conduciendo a menudo a un resultado indeseable: los errores de rutina se informan al usuario final en forma de un rastro de pila incomprensible, lleno de informacion sobre la estructura del programa pero carece de un contexto inteligible sobre lo que salio mal.</p>
<p>Por el contrario, los programas Go utilizan mecanismos de control de flujo normales como <code>if</code> y <code>return</code> para responder a los errores. Este estilo indudablemente exige que se preste mas atencion a la logica de manejo de errores, pero ese es precisamente el punto.</p>
</div>
<h4 id="Seccion-5.4.1" >Estrategias de Manejo de Errores</h4>
<div class="hBody-4" >
<p>Cuando una llamada de funcion devuelve un error, es responsabilidad del llamador comprobarlo y tomar la accion apropiada. Dependiendo de la situacion, puede haber una serie de posibilidades. Echemos un vistazo a cinco de ellas.</p>
<p>La primera y mas comun, es <em>propagar</em> el error, por lo que un fallo en una subrutina se convierte en un fracaso de la rutina de llamada. Vimos ejemplos de esto en la funcion <code>findLinks</code> de la <a href="#Seccion-5.3" >Seccion 5.3</a>. Si la llamada a <code>http.Get</code> falla, <code>findLinks</code> devuelve el error HTTP a la persona al llamador sin mas preambulos:</p>
<div class="highlight"><pre><span></span><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>
<p>Por el contrario, si la llamada a <code>html.Parse</code> falla, <code>findLinks</code> no devuelve el error del analizador de HTML directamente, porque carece de dos piezas cruciales de informacion: que se produjo el error en el analizador, y la direccion URL del documento que se esta analizando. En este caso, <code>findLinks</code> construye un nuevo mensaje de error que incluye las dos piezas de informacion, asi como un analisis del error subyacente:</p>
<div class="highlight"><pre><span></span><span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>La funcion <code>fmt.Errorf</code> da formato a un mensaje de error utilizando <code>fmt.Sprintf</code> y devuelve un nuevo valor <code>error</code>. Lo utilizamos para generar errores descriptivos mediante el prefijo sucesivo de informacion de contexto adicional al mensaje de error original. Cuando el error es en ultima instancia, manejado por la funcion <code>main</code> del programa, se debe proporcionar una cadena causal clara a partir de la raiz del problema de la falta en su conjunto, que recuerda a una investigacion de accidentes de la NASA:</p>
<pre class="pre" >genesis: crashed: no parachute: G-switch failed: bad relay orientation</pre>
<p>Debido a que los mensajes de error con frecuencia se encadenan juntos, las cadenas de mensajes no deben ser mayusculas y las lineas nuevas deben evitarse. Los errores resultantes pueden ser largos, pero seran autocontenidos cuando sean encuontrados por herramientas como grep.</p>
<p>Cuando diseñe mensajes de error, sea deliberado, de modo que cada uno sea una descripcion significativa del problema con detalles suficientes y relevantes, y sea consistente, de modo que los errores devueltos por la misma funcion o por un grupo de funciones en el mismo paquete sean similares en forma y se puedan tratar de la misma manera.</p>
<p>Por ejemplo, el paquete <code>os</code> garantiza que cada error devuelto por una operacion de archivo, como <code>os.Open</code> o los metodos <code>Read</code>, <code>Write</code>, o <code>Close</code> de un archivo abierto, no describen solo la naturaleza de la falla (permiso denegado, directorio erroneo, etc), sino tambien el nombre del archivo, por lo el que llamador no necesita incluir esta informacion en el mensaje de error.</p>
<p>En general, la llamada <code>f(x)</code> es responsable de informar el intento de operacion <code>f</code> y el valor del argumento <code>x</code> en su relacion con el contexto del error. El llamador es responsable de añadir mas informacion que tiene, pero la llamada <code>f(x)</code> no, tal como la URL en la llamada a <code>html.Parse</code> anterior.</p>
<p>Pasemos a la segunda estrategia para manejar errores. Para errores que representan problemas transitorios o impredecibles, puede tener sentido volver a intentar la operacion fallida, posiblemente con un retardo entre intentos, y tal vez con un limite en el numero de intentos o el tiempo dedicado a tratar antes de renunciar por completo.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/wait/wait.go" >gopl.io/ch5/wait</a></p>
<div class="highlight"><pre><span></span><span class="c1">// WaitForServer intenta ponerse en contacto con el servidor de una URL</span>
<span class="c1">// Se intenta durante un minuto usando retroceso exponencial.</span>
<span class="c1">// Informa un error si todos los intentos fallan.</span>
<span class="kd">func</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">timeout</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span>
  <span class="nx">deadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">tries</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Before</span><span class="p">(</span><span class="nx">deadline</span><span class="p">);</span> <span class="nx">tries</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Head</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// exito</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;server not responding (%s); retrying...&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">&lt;&lt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">tries</span><span class="p">))</span> <span class="c1">// retroceso exponencial</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;server %s failed to respond after %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En tercer lugar, si el progreso es imposible, el llamante puede imprimir el error y detener el programa con gracia, pero este curso de accion generalmente debe reservarse para el paquete principal de un programa. Las funciones de la libreria normalmente deben propagar errores al llamante, a menos que el error sea un signo de una inconsistencia interna, es decir, un error.</p>
<div class="highlight"><pre><span></span><span class="c1">// (Dentro de la funcion main.)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Site is down: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Una forma mas conveniente para lograr el mismo efecto es llamar a <code>log.Fatalf</code>. Al igual que con todas las funciones <code>log</code>, por defecto se prefija la hora y la fecha para el mensaje de error.</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">WaitForServer</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Site is down: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>El formato predeterminado es util en un servidor de larga ejecucion, pero menos para una herramienta interactiva:</p>
<pre class="pre" >2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io</pre>
<p>Para una salida mas atractiva, podemos establecer el prefijo utilizado por el paquete <code>log</code> en el nombre del comando, y suprimir la visualizacion de la fecha y hora:</p>
<div class="highlight"><pre><span></span><span class="nx">log</span><span class="p">.</span><span class="nx">SetPrefix</span><span class="p">(</span><span class="s">&quot;wait: &quot;</span><span class="p">)</span>
<span class="nx">log</span><span class="p">.</span><span class="nx">SetFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
<p>En cuarto lugar, en algunos casos, basta con registrar el error y luego continuar, tal vez con funcionalidad reducida. Una vez mas hay una eleccion entre utilizar el paquete <code>log</code>, que añade el prefijo habitual:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;ping failed: %v; networking disabled&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>e imprimir directamente a flujo de error estardar:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Ping</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;ping failed: %v; networking disabled\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>(Todas las funciones log añaden un salto de linea si no hay uno presente).</p>
<p>Y quinto y ultimo, en casos raros podemos ignorar un error completamente:</p>
<div class="highlight"><pre><span></span><span class="nx">dir</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">TempDir</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;scratch&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;failed to create temp dir: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...use temp dir...</span>

<span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// ignorar errores; $TMPDIR se limpia periodicamente</span>
</pre></div>
<p>La llamada a os.RemoveAll puede fallar, pero el programa lo ignora porque el sistema operativo periodicamente limpia el directorio temporal. En este caso, descartar el error fue intencional, pero la logica del programa seria la misma si hubieramos olvidado tratar con el. Adquiera el habito de considerar errores despues de cada llamada de funcion, y cuando deliberadamente ignora uno, documente claramente su intencion.</p>
<p>El manejo de errores en Go tiene un ritmo particular. Despues de comprobar un error, el fracaso suele tratarse antes del exito. Si el fallo hace que la funcion regrese, la logica para el exito no se sangra dentro de un bloque <code>else</code>, pero continua en el nivel externo. Las funciones tienden a exhibir una estructura comun, con una serie de comprobaciones iniciales para rechazar errores, seguidas por la esencia de la funcion al final, minimamente indentada.</p>
</div>
<h4 id="Seccion-5.4.2" >Fin de Archivo (EOF)</h4>
<div class="hBody-4" >
<p>Normalmente, la variedad de errores que una funcion puede devolver es interesante para el usuario final, pero no para la logica del programa intermedio. En ocasiones, sin embargo, un programa debe tomar diferentes acciones dependiendo del tipo de error que se ha producido. Considere un intento de leer <span class="math" >n</span> bytes de datos de un archivo. Si se elige <span class="math" >n</span> para ser la longitud del archivo, cualquier error representa un fracaso. Por otro lado, si el llamador trata repetidamente de leer fragmentos de tamaño fijo hasta que el archivo se agote, el llamador debe responder de manera diferente a una condicion de fin de archivo que a todos los demas errores. Por esta razon, el paquete <code>io</code> garantiza que cualquier daño causado por una condicion de fin de archivo siempre informa de un error distinguida, <code>io.EOF</code>, que se define de la siguiente manera:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">io</span>

<span class="kn">import</span> <span class="s">&quot;errors&quot;</span>

<span class="c1">// EOF es el error devuelto por Read cuando no hay mas entrada disponible.</span>
<span class="kd">var</span> <span class="nx">EOF</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">)</span>
</pre></div>
<p>El llamador puede detectar esta condicion usando una comparacion simple, como en el bucle siguiente, que lee runas de la entrada estandar. (El programa <code class="command" >charcount</code> en la <a href="#Seccion-4.3" >Seccion 4.3</a> ofrece un ejemplo mas completo.)</p>
<div class="highlight"><pre><span></span><span class="nx">in</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">.</span><span class="nx">ReadRune</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
    <span class="k">break</span> <span class="c1">// lectura terminada</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;read failed: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...usar r...</span>
<span class="p">}</span>
</pre></div>
<p>Puesto que en una condicion de fin de archivo no existe informacion que informar ademas del hecho de que, <code>io.EOF</code> tiene un mensaje de error fijo, <code>&quot;EOF&quot;</code>. Para otros errores, es posible que tengamos que informar tanto la calidad como la cantidad del error, por asi decirlo, por lo que un valor de error fijo no lo hara. En la <a href="#Seccion-7.11" >Seccion 7.11</a>, vamos a presentar de manera mas sistematica a distinguir ciertos valores de error de los demas.</p>
</div>
<h3 id="Seccion-5.5" >Valores de la Funcion</h3>
<div class="hBody-3" >
<p>En Go las funciones son valores de primera clase: al igual que otros valores, los valores de funcion tienen tipos, y pueden ser asignados a variables o pasarse a o regresarlas de funciones. Un valor de funcion puede ser llamado como cualquier otra funcion. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">square</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">negative</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>   <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">product</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span> <span class="o">*</span> <span class="nx">n</span> <span class="p">}</span>

<span class="nx">f</span> <span class="o">:=</span> <span class="nx">square</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>     <span class="c1">// &quot;9&quot;</span>

<span class="nx">f</span> <span class="p">=</span> <span class="nx">negative</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>     <span class="c1">// &quot;-3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;func(int) int&quot;</span>

<span class="nx">f</span> <span class="p">=</span> <span class="nx">product</span> <span class="c1">// error de compilacion: no se puede asignar f(int, int) int a f(int) int</span>
</pre></div>
<p>El valor cero para el tipo funcion es <code>nil</code>. Llamar a un valor de funcion nulo produce un panico:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// panico: llamar a funcion nil</span>
</pre></div>
<p>Los valores de funcion pueden compararse con <code>nil</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
<span class="k">if</span> <span class="nx">f</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Pero no son comparables, por lo que no pueden comparse entre si o utilizarse como claves en un mapa.</p>
<p>Los valores de las funciones nos permiten parametrizar nuestras funciones no solo sobre los datos sino tambien sobre el comportamiento. Las librerias estandar contienen muchos ejemplos. Por ejemplo, <code>strings.Map</code> aplica una funcion a cada caracter de una cadena, uniendo los resultados para formar otra cadena.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">add1</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;HAL-9000&quot;</span><span class="p">))</span> <span class="c1">// &quot;IBM.:111&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;VMS&quot;</span><span class="p">))</span>      <span class="c1">// &quot;WNT&quot;</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">add1</span><span class="p">,</span> <span class="s">&quot;Admix&quot;</span><span class="p">))</span>    <span class="c1">// &quot;Benjy&quot;</span>
</pre></div>
<p>La funcion <code>findLinks</code> de la <a href="#Seccion-5.2" >Seccion 5.2</a> utiliza una funcion auxiliar, <code>visit</code>, para visitar todos los nodos en un documento HTML y aplicar una accion a cada uno. Usando el valor de una funcion, podemos separar la logica del recorrido del arbol de la logica para la accion a aplicar a cada nodo, permitiendonos reutilizar el recorrido con diferentes acciones.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/outline2/outline.go" >gopl.io/ch5/outline2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// forEachNode llama a las funciones pre(x) y post(x) para cada nodo</span>
<span class="c1">// x en el arbol originado en n. Ambas funciones son opcionales.</span>
<span class="c1">// pre se llama antes de que los hijos sean visitados (preorden) y</span>
<span class="c1">// post se llama despues (postorden).</span>
<span class="kd">func</span> <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">pre</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">pre</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
    <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">post</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">post</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">post</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>forEachNode</code> acepta dos argumentos de funcion, una para llamar antes de que se visiten los hijos de un nodo y otra para llamar despues. Esta disposicion da a al lamador una gran flexibilidad. Por ejemplo, las funciones <code>startElement</code> y <code>endElement</code> imprimen las etiquetas de inicio y fin de un elemento HTML, como <code>&lt;b&gt;...&lt;/b&gt;</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">depth</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">startElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%*s&lt;%s&gt;\n&quot;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="nx">depth</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">endElement</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
    <span class="nx">depth</span><span class="o">--</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%*s&lt;/%s&gt;\n&quot;</span><span class="p">,</span> <span class="nx">depth</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Las funciones tambien indentan la salida usando otro truco de <code>fmt.Printf</code>. El adverbio <code>*</code> en <code>%*s</code> imprime una cadena rellena con un numero variable de espacios. La anchura y la cadena se proporcionan por los argumentos <code>depth*2</code> y <code>&quot;&quot;</code>.</p>
<p>Si llamamos a <code>forEachNode</code> en un documento HTML, de esta forma:</p>
<div class="highlight"><pre><span></span><span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">startElement</span><span class="p">,</span> <span class="nx">endElement</span><span class="p">)</span>
</pre></div>
<p>obtenemos una variacion mas elaborada en la salida de nuestra programa <code class="command" >outline</code> anterior:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch5/outline2
$ ./outline2 http://gopl.io
&lt;html&gt;
  &lt;head&gt;
    &lt;meta&gt;
    &lt;/meta&gt;
    &lt;title&gt;
    &lt;/title&gt;
    &lt;style&gt;
    &lt;/style&gt;
  &lt;/head&gt;
&lt;body&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;
          &lt;a&gt;
            &lt;img&gt;
            &lt;/img&gt;
...
</pre></div>
<p><b>Ejercicio 5.7</b>: Desarrolla <code>startElement</code> y <code>endElement</code> en una agradable impresora HTML general. Imprime los nodos de comentarios, nodos de texto y los atributos de cada elemento (<code>&lt;a href='...'&gt;</code>). Utilizar formas cortas como <code>&lt;img/&gt;</code> en lugar de <code>&lt;img&gt;&lt;/img&gt;</code> cuando un elemento no tiene hijos. Escribir una prueba para asegurarse de que la salida se puede analizar con exito. (Vease el <a href="#Capitulo-11" >Capitulo 11</a>).</p>
<p><b>Ejercicio 5.8</b>: Modificar <code>forEachNode</code> para que las funciones <code>pre</code> y <code>post</code> devuelvan un resultado booleano que señale si se debe continuar el recorrido. Utilicelo para escribir una funcion <code>ElementByID</code> con la siguiente firma que se encuentra el primer elemento HTML con el atributo id especificado. La funcion debe detener el recorrido tan pronto como se encuentre una coincidencia.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ElementByID</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>
</pre></div>
<p><b>Ejercicio 5.9</b>: Escribir una funcion <code>expand(s string, f func(string) string) string</code> que reemplaze cada subcadena <code>&quot;$foo&quot;</code> dentro de <code>s</code> con el texto devuelto por <code>f(&quot;foo&quot;)</code>.</p>
</div>
<h3 id="Seccion-5.6" >Funciones Anonimas</h3>
<div class="hBody-3" >
<p>Funciones con nombre se pueden declarar solo a nivel de paquete, pero podemos utilizar un <em>literal de funcion</em> para denotar un valor de funcion dentro de cualquier expresion. Un literal funcion se escribe como una declaracion de la funcion, pero sin un nombre despues de la palabra clave <code>func</code>. Es una expresion, y su valor se denomina <em>funcion anonima</em>.</p>
<p>Los literales de la funcion definen una funcion en su punto de uso. A modo de ejemplo, la llamada anterior a <code>strings.Map</code> se puede reescribir como</p>
<div class="highlight"><pre><span></span><span class="nx">strings</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">},</span> <span class="s">&quot;HAL-9000&quot;</span><span class="p">)</span>
</pre></div>
<p>Mas importante aun, las funciones definidas de esta manera tienen acceso a todo el entorno lexico, por lo que la funcion interna puede referirse a variables de la funcion de inclusion, como muestra este ejemplo:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/squares/main.go" >gopl.io/ch5/squares</a></p>
<div class="highlight"><pre><span></span><span class="c1">// squares regresa una funcion que devuelve el siguiente</span>
<span class="c1">// cuadrado del numero cada ves que se llama.</span>
<span class="kd">func</span> <span class="nx">squares</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">x</span><span class="o">++</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">squares</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;1&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;4&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;9&quot;</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">())</span> <span class="c1">// &quot;16&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>squares</code> devuelve otra funcion, de tipo <code>func() int</code>. Una llamada a <code>squares</code> crea una variable local <code>x</code> y devuelve una funcion anonima que, cada vez que se llama, incrementa <code>x</code> y devuelve su cuadrado. Una segunda llamada a <code>squares</code> crearia una segunda variable <code>x</code> y devolvera una nueva funcion anonima que incremente esa variable.</p>
<p>El ejemplo <code>squares</code> demuestra que los valores de funcion no son solo codigo, sino que pueden tener estado. La funcion anonima interna puede acceder y actualizar las variables locales dentro de la funcion <code>squares</code>. Estas referencias de variables ocultas son el por que clasificamos a las funciones como tipos de referencia y motivo de que los valores de las funciones no sean comparables. Los valores de funcion como estos se implementan utilizando una tecnica llamada <em>closures</em>, y los programadores Go a menudo utilizan este termino para los valores de la funcion.</p>
<p>Aqui de nuevo vemos un ejemplo donde el tiempo de vida de una variable no esta determinada por su ambito de aplicacion: la variable <code>x</code> existe despues del retorno de <code>squares</code> dentro de <code>main</code>, aunque <code>x</code> este oculta dentro de <code>f</code>.</p>
<p>Como un ejemplo un tanto academico de funciones anonimas, considere el problema de calcular una secuencia de los cursos de ciencias de la computacion que satisfagan los requisitos previos de cada uno. Los prerequisitos se dan en la tabla <code>prereqs</code> de abajo, que es un mapeo de cada curso a la lista de cursos que se deben completar antes de ella.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/toposort/main.go" >gopl.io/ch5/toposort</a></p>
<div class="highlight"><pre><span></span><span class="c1">// prereqs asigna cursos de ciencia de la computacion a sus prerequisitos.</span>
<span class="kd">var</span> <span class="nx">prereqs</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{</span>
  <span class="s">&quot;algoritmos&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;estructura de datos&quot;</span><span class="p">},</span>
  <span class="s">&quot;calculo&quot;</span><span class="p">:</span>   <span class="p">{</span><span class="s">&quot;algebra lineal&quot;</span><span class="p">},</span>

  <span class="s">&quot;compiladores&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">&quot;estructura de datos&quot;</span><span class="p">,</span>
    <span class="s">&quot;lenguajes formales&quot;</span><span class="p">,</span>
    <span class="s">&quot;organizacion de computadoras&quot;</span><span class="p">,</span>
  <span class="p">},</span>

  <span class="s">&quot;estructura de datos&quot;</span><span class="p">:</span>       <span class="p">{</span><span class="s">&quot;matematicas discretas&quot;</span><span class="p">},</span>
  <span class="s">&quot;bases de datos&quot;</span><span class="p">:</span>            <span class="p">{</span><span class="s">&quot;estructura de datos&quot;</span><span class="p">},</span>
  <span class="s">&quot;matematicas discretas&quot;</span><span class="p">:</span>     <span class="p">{</span><span class="s">&quot;introduccion a la programacion&quot;</span><span class="p">},</span>
  <span class="s">&quot;lenguajes formales&quot;</span><span class="p">:</span>        <span class="p">{</span><span class="s">&quot;matematicas discretas&quot;</span><span class="p">},</span>
  <span class="s">&quot;redes&quot;</span><span class="p">:</span>                     <span class="p">{</span><span class="s">&quot;sitemas operativos&quot;</span><span class="p">},</span>
  <span class="s">&quot;sistemas operativos&quot;</span><span class="p">:</span>       <span class="p">{</span><span class="s">&quot;estructura de datos&quot;</span><span class="p">,</span> <span class="s">&quot;organizacion de computadoras&quot;</span><span class="p">},</span>
  <span class="s">&quot;lenguajes de programacion&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;estructura de datos&quot;</span><span class="p">,</span> <span class="s">&quot;organizacion de computadoras&quot;</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Este tipo de problema se conoce como clasificacion topologica. Conceptualmente, la informacion de los requisitos previos forma un grafico dirigido con un nodo para cada curso y los bordes de cada curso a los cursos de los que depende. El grafico es aciclico: no hay camino de un curso que vuelva a si mismo. Podemos calcular una secuencia valida usando la busqueda de profundidad en el grafico con el siguiente codigo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">course</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">prereqs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d:\t%s\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">course</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">topoSort</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">order</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">visitAll</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

  <span class="nx">visitAll</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
        <span class="nx">order</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">order</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">keys</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
  <span class="nx">visitAll</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">order</span>
<span class="p">}</span>
</pre></div>
<p>Cuando una funcion anonima requiere recursion, como en este ejemplo, primero debemos declarar una variable, y luego asignar la funcion anonima a esa variable. Si estos dos pasos estuvieran combinados en la declaracion, la funcion literal no estaria dentro del alcance de la variable <code>visitAll</code> por lo que no tendria ninguna manera de llamarse a si misma de forma recursiva:</p>
<div class="highlight"><pre><span></span><span class="nx">visitAll</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="nx">visitAll</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span> <span class="c1">// compile error: undefined: visitAll</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>La salida del programa <code class="command" >toposort</code> se muestra a continuacion. Es determinista, una propiedad a menudo deseable que no siempre viene de forma gratuita. En este caso, los valores del mapa <code>prereqs</code> son slices, no mas mapas, por lo que su orden de iteracion es determinista, y ordenamos las llaves de <code>prereqs</code> antes de hacer las llamadas iniciales a <code>visitAll</code> .</p>
<pre class="pre" >1:      introduccion a la programacion
2:      matematicas discretas
3:      estructura de datos
4:      algoritmos
5:      algebra lineal
6:      calculo
7:      lenguajes formales
8:      organizacion de computadoras
9:      compiladores
10:     bases de datos
11:     sistemas operativos
12:     redes
13:     Lenguajes de programacion</pre>
<p>Volvamos a nuestro ejemplo <code>findLinks</code>. Hemos movido la funcion de extraccion de enlaces <code>links.Extract</code> a su propio paquete, ya que la usaremos de nuevo en el <a href="#Capitulo-8" >Capitulo 8</a>. Hemos sustituido la funcion <code>visit</code> con una funcion anonima que agrega directamente los <code>links</code> al slice, y utilizamos <code>forEachNode</code> para manejar el recorrido. Ya que <code>Extract</code> solo necesita la funcion <code>pre</code>, se pasa <code>nil</code> para el argumento <code>post</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/links/links.go" >gopl.io/ch5/links</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete links proporciona una funcion de extraccion de links.</span>
<span class="kn">package</span> <span class="nx">links</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;net/http&quot;</span>

  <span class="s">&quot;golang.org/x/net/html&quot;</span>
<span class="p">)</span>

<span class="c1">// Extract hace una peticion HTTP GET a la URL especificada, analiza</span>
<span class="c1">// la respuesta como HTML, y regresa el enlace en el documento HTML.</span>
<span class="kd">func</span> <span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;getting %s: %s&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">links</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">!=</span> <span class="s">&quot;href&quot;</span> <span class="p">{</span>
          <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">link</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">continue</span> <span class="c1">// ignora URLs incorrectas</span>
        <span class="p">}</span>
        <span class="nx">links</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">links</span><span class="p">,</span> <span class="nx">link</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">links</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En lugar de añadir el atributo <code>href</code> en bruto al slice <code>links</code>, esta version lo analiza como una direccion URL relativa a la URL base del documento, <code>resp.Request.URL</code>. El enlace resultante esta en formato absoluta, adecuado para su uso en una llamada a <code>http.Get</code>.</p>
<p>El rastreador web es, en su corazon, un problema de grafico transversal. El ejemplo <code>topoSort</code> mostra un recorrido en profundidad; Para nuestro rastreador web, vamos a utilizar la anchura de primera transversal, al menos inicialmente. En el <a href="#Capitulo-8" >Capitulo 8</a>, vamos a explorar el recorrido concurrente.</p>
<p>La siguiente funcion encapsula la esencia de un recorrido de primer-anchura. El llamador proporciona una lista inicial <code>worklist</code> de elementos a visitar y un valor de la funcion <code>f</code> a llamar para cada elemento. Cada elemento se identifica mediante una cadena. La funcion <code>f</code> devuelve una lista de elementos nuevos a añadir a la lista de trabajo. La funcion <code>breadthFirst</code> regresa cuando todos los elementos han sido visitados. Mantiene un conjunto de cadenas para garantizar que ningun elemento se visita dos veces.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/findlinks3/findlinks.go" >gopl.io/ch5/findlinks3</a></p>
<div class="highlight"><pre><span></span><span class="c1">// breadthFirst llama a f para cada elemento en worklist.</span>
<span class="c1">// Todos los elementos devueltos por f se agregan a worklist.</span>
<span class="c1">// f se llama como maximo una vez para cada elemento.</span>
<span class="kd">func</span> <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">item</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">worklist</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">worklist</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">items</span> <span class="o">:=</span> <span class="nx">worklist</span>
    <span class="nx">worklist</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">worklist</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">worklist</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como explicamos al pasar por el <a href="#Capitulo-3" >Capitulo 3</a>, el argumento de <q><code>f(item)...</code></q>  hace que todos los elementos de la lista devuelta por f que se añadan a la lista de trabajo.</p>
<p>En nuestro rastreador, los elementos son URL. La funcion <code>crawl</code> que suministramos a <code>breadthFirst</code> imprime la URL, extrae sus enlaces, y los devuelve para que tambien se visiten..</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>
<p>Para iniciar el rastreador, utilizaremos los argumentos de la linea de comandos como las URL iniciales.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Rastrear la web la primer-anchura,</span>
  <span class="c1">// partiendo de los argumentos de la linea de comandos.</span>
  <span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">crawl</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>
</pre></div>
<p>Vamos a rastrear la web desde <code>https://golang.org</code>. Estos son algunos de los enlaces resultantes:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch5/findlinks3
$ ./findlinks3 https://golang.org
https://golang.org/
https://golang.org/doc/
https://golang.org/pkg/
https://golang.org/project/
https://code.google.com/p/go-tour/
https://golang.org/doc/code.html
https://www.youtube.com/watch?v<span class="o">=</span>XCsL89YtqCs
http://research.swtch.com/gotour
https://vimeo.com/53221560
</pre></div>
<p>El proceso finaliza cuando todas las paginas web alcanzables se han rastreado o se ha agotado la memoria del equipo.</p>
<p><b>Ejercicio 5.10</b>: Vuelve a escribir <code>topoSort</code> para utilizar mapas en lugar de slices y eliminar la clasificacion inicial. Verifique que los resultados, aunque no deterministicos, sean ordenamientos topologicos validos.</p>
<p><b>Ejercicio 5.11</b>: El instructor del curso de algebra lineal decide que ahora es un requisito previo. Extender la funcion <code>topoSort</code> para reportar ciclos.</p>
<p><b>Ejercicio 5.12</b>: Las funciones <code>startElement</code> y <code>endElement</code> en <code>gopl.io/ch5/outline2</code> (<a href="#Seccion-5.5" >§5.5</a>) comparten una variable global, <code>depth</code>. Conviertalas en funciones anonimas que compartan una variable local de la funcion <code>outline</code>.</p>
<p><b>Ejercicio 5.13</b>: Modificar <code>crawl</code> para hacer copias locales de las paginas que encuentre, la creando directorios segun sea necesario. No haga copias de paginas que provengan de un dominio diferente. Por ejemplo, si la pagina original proviene de <a href="https://golang.org" >golang.org</a>, guarda todos los archivos de alli, pero excluyen los de <a href="https://vimeo.com" >vimeo.com</a>.</p>
<p><b>Ejercicio 5.14</b>: Usar la funcion <code>breadthFirst</code> para explorar una estructura diferente. Por ejemplo, podria utilizar las dependencias de cursos del ejemplo <code>topoSort</code> (un grafo dirigido), la jerarquia del sistema de archivos en el ordenador (un arbol), o una lista de rutas de autobus o de metro descargados desde el sitio web de su gobierno de la ciudad (un grafo no dirigido).</p>
</div>
<h4 id="Seccion-5.6.1" >Advertencia: Captura de Variables de Iteracion</h4>
<div class="hBody-4" >
<p>En esta seccion, veremos una trampa de las reglas de alcance lexico de Go que pueden causar resultados sorprendentes. Le recomendamos que comprenda el problema antes de proceder, porque la trampa puede atrapar incluso a programadores experimentados.</p>
<p>Considere un programa que debe crear un conjunto de directorios y luego eliminarlos. Podemos usar una porcion de valores de funcion para mantener las operaciones de limpieza. (Para mayor brevedad, hemos omitido todo el manejo de errores en este ejemplo.)</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">d</span>               <span class="c1">// NOTA: necesario!</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// tambien crea los directorios padre</span>
  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// ...algo de trabajo...</span>

<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rmdir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rmdirs</span> <span class="p">{</span>
  <span class="nx">rmdir</span><span class="p">()</span> <span class="c1">// clean up</span>
<span class="p">}</span>
</pre></div>
<p>Es posible que se pregunte por que asignamos la variable de bucle <code>d</code> a una nueva variable local <code>dir</code> dentro del cuerpo del bucle, en lugar de simplemente nombrar a la variable de bucle <code>dir</code> que en esta variante sutil incorrectos:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="c1">// NOTA: incorrecto!</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
<p>La razon es una consecuencia de las reglas de alcance para variables de bucle. En el programa inmediatamente anterior, el bucle <code>for</code> introduce un nuevo bloque lexico en el que se declara la variable <code>dir</code>. Todos los valores de la funcion creados por esta bucle <q>capturan</q> y comparten la misma variable–Un lugar de almacenamiento direccionable, no su valor en ese momento en particular. El valor de <code>dir</code> se actualiza en iteraciones sucesivas, de manera que cuando las funciones de limpieza son llamados, la variable <code>dir</code> ha sido actualizado varias veces por el ahora completado bucle <code>for</code>. Por lo tanto <code>dir</code> mantiene el valor de la iteracion final, y por lo tanto todas las llamadas a <code>os.RemoveAll</code> intentaran eliminar el mismo directorio.</p>
<p>Con frecuencia, la variable interna introducido para evitar este problema–<code>dir</code> en nuestro ejemplo–se le da exactamente el mismo nombre que la variable externa de la que es una copia, lo que lleva a las declaraciones de variables de aspecto extraño pero cruciales como este:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dir</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tempDirs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dir</span> <span class="o">:=</span> <span class="nx">dir</span> <span class="c1">// declara dir interno, inicializado a dir externo</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>El riesgo no es unica para bucles <code>for</code> basados en <code>range</code>. El bucle en el siguiente ejemplo adolece del mismo problema debido a la captura no intencionada de la variable de indice <code>i</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">rmdirs</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="nx">dirs</span> <span class="o">:=</span> <span class="nx">tempDirs</span><span class="p">()</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dirs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">MkdirAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mo">0755</span><span class="p">)</span> <span class="c1">// OK</span>
  <span class="nx">rmdirs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rmdirs</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">RemoveAll</span><span class="p">(</span><span class="nx">dirs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// NOTA: incorrecto!</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
<p>El problema de la iteracion de captura variable se encuentran mas a menudo cuando se utiliza la sentencia <code>go</code> (<a href="#Capitulo-8" >Capitulo 8</a>) o con <code>defer</code> (que veremos en un momento), ya que ambos pueden retrasar la ejecucion de un valor de funcion hasta despues de que el bucle ha finalizado. Pero el problema no es inherente a <code>go</code> o <code>defer</code>.</p>
</div>
<h3 id="Seccion-5.7" >Funciones Variadic</h3>
<div class="hBody-3" >
<p>Una <em>funcion variadic</em> es uno que se puede llamar con un numero de argumentos variable. Los ejemplos mas conocidos son <code>fmt.Printf</code> y sus variantes. <code>Printf</code> requiere un argumento fijo al principio, luego acepta cualquier numero de argumentos posteriores.</p>
<p>Para declarar una funcion variadic, el tipo del parametro final va precedida por una elipsis, <q><code>...</code></q>, que indica que la funcion puede ser llamada con cualquier numero de argumentos de este tipo.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/sum/main.go" >gopl.io/ch5/sum</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">total</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">val</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>sum</code> anterior devuelve la suma de cero o mas argumentos <code>int</code>. Dentro del cuerpo de la funcion, el tipo de <code>vals</code> es un slice <code>[]int</code>. Cuando llame a <code>sum</code>, cualquier numero de valores puede ser proporcionado pora su parametro <code>vals</code>.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">())</span>           <span class="c1">// &quot;0&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>          <span class="c1">// &quot;3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>
<p>Implicitamente, el llamador asigna un arreglo, copia los argumentos en ell y pasa un slice de toda la arreglo a la funcion. La llamada anterior se comporta de la misma manera que la llamada que se muestra a continuacion, que muestra como invocar una funcion variadica cuando los argumentos ya estan en un slice: coloca una elipsis despues del argumento final.</p>
<div class="highlight"><pre><span></span><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="nx">values</span><span class="o">...</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>
<p>Aunque el parametro <code>...int</code> se comporta como una slice dentro del cuerpo de la funcion, el tipo de una funcion variadic es distinto del tipo de una funcion con un parametro slice ordinario.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">g</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// &quot;func(...int)&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="c1">// &quot;func([]int)&quot;</span>
</pre></div>
<p>Las funciones variadic se utilizan a menudo para el formato de la secuencia. La funcion <code>errorf</code> a continuacion construye un mensaje de error con formato con un numero de linea en el principio. El sufijo <code>f</code> es una convencion de nomenclatura ampliamente seguido para funciones variadic que aceptan una cadena de formato de estilo <code>Printf</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Line %d: &quot;</span><span class="p">,</span> <span class="nx">linenum</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">linenum</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;count&quot;</span>
<span class="nx">errorf</span><span class="p">(</span><span class="nx">linenum</span><span class="p">,</span> <span class="s">&quot;undefined: %s&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="c1">// &quot;Linea 12: sin definir: count&quot;</span>
</pre></div>
<p>El tipo <code>interface{}</code> significa que esta funcion puede aceptar cualquier valor en absoluto para sus argumentos finales, como explicaremos en el <a href="#Capitulo-7" >Capitulo 7</a>.</p>
<p><b>Ejercicio 5.15</b>: Escribir funciones variadic <code>max</code> y <code>min</code>, analoga a <code>sum</code>. ¿Que deben hacer estas funciones cuando se llaman sin argumentos? Escribir variantes que requieren al menos un argumento.</p>
<p><b>Ejercicio 5.16</b>: Escribir una version variadic <code>de strings.Join</code> .</p>
<p><b>Ejercicio 5.17</b>: Escribir una funcion variadic <code>ElementsByTagName</code> que, dado un arbol de nodos HTML y cero o mas nombres, devuelve todos los elementos que coinciden con uno de esos nombres. Aqui hay dos ejemplos de llamadas:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">name</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>

<span class="nx">images</span> <span class="o">:=</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="s">&quot;img&quot;</span><span class="p">)</span>
<span class="nx">headings</span> <span class="o">:=</span> <span class="nx">ElementsByTagName</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="s">&quot;h1&quot;</span><span class="p">,</span> <span class="s">&quot;h2&quot;</span><span class="p">,</span> <span class="s">&quot;h3&quot;</span><span class="p">,</span> <span class="s">&quot;h4&quot;</span><span class="p">)</span>
</pre></div>
</div>
<h3 id="Seccion-5.8" >Llamadas de Funcion Diferida</h3>
<div class="hBody-3" >
<p>Nuestros ejemplos <code>findLinks</code> utilizan la salida de <code>http.Get</code> como la entrada de <code>html.Parse</code>. Esto funciona bien si el contenido de la URL solicitada es de hecho HTML, pero muchas paginas contienen imagenes, texto sin formato y otros formatos de archivo. La alimentacion de estos archivos en un analizador HTML podria tener efectos no deseados.</p>
<p>El siguiente programa recupera un documento HTML e imprime su titulo. La funcion <code>title</code> inspecciona la cabecera <code>Content-Type</code> de la respuesta del servidor y devuelve un error si el documento no es HTML.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/title1/title.go" >gopl.io/ch5/title1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// Comprueba que Content-Type sea HTML (e.g., &quot;text/html; charset=utf-8&quot;).</span>
  <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&quot;text/html&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&quot;text/html;&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s has type %s, not text/html&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">visitNode</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;title&quot;</span> <span class="o">&amp;&amp;</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">visitNode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aqui esta una sesion tipica, ligeramente editada para encajar:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch5/title1
$ ./title1 http://gopl.io
The Go Programming Language
$ ./title1 https://golang.org/doc/effective_go.html
Effective Go - The Go Programming Language
$ ./title1 https://golang.org/doc/gopher/frontpage.png
title: https://golang.org/doc/gopher/frontpage.png
    has <span class="nb">type</span> image/png, not text/html
</pre></div>
<p>Observe la llamada duplicada <code>resp.Body.Close()</code>, que asegura que <code>title</code> se cierre la conexion de red en todas las rutas de ejecucion, incluyendo las fallas. A medida que las funciones se vuelven mas complejas y tienen que manejar mas errores, tal duplicacion de la logica de limpieza puede convertirse en un problema de mantenimiento. Veamos como el nuevo mecanismo <code>defer</code> de Go hace las cosas mas sencillas.</p>
<p>Sintacticamente, una sentencia <code>defer</code> es una funcion ordinaria o una llamada a un metodo con la palabra clave <code>defer</code> como prefijo. Las expresiones de funcion y los argumentos se evaluan cuando se ejecuta la instruccion, pero la llamada real se aplaza hasta que la funcion que contiene la declaracion <code>defer</code> ha terminado, ya sea ejecutando una instruccion de retorno o llegando al final, o anormalmente, por un panico. Cualquier numero de llamadas puede ser diferido; se ejecutan en el orden inverso en que fueron aplazadas.</p>
<p>Una sentencia <code>defer</code> se utiliza a menudo con operaciones pareadas como abrir y cerrar, conectar y desconectar o bloquear y desbloquear para garantizar que los recursos se liberan en todos los casos, independientemente de la complejidad del flujo de control. El lugar adecuado para una sentencia <code>defer</code> que libera un recurso es inmediatamente despues de que el recurso se ha adquirido con exito. En la funcion <code>title</code> a continuacion, una sola llamada diferida sustituye a las dos llamadas anteriores de <code>resp.Body.Close()</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/title2/title.go" >gopl.io/ch5/title2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">title</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="nx">ct</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ct</span> <span class="o">!=</span> <span class="s">&quot;text/html&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">ct</span><span class="p">,</span> <span class="s">&quot;text/html;&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s has type %s, not text/html&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">ct</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">doc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;parsing %s as HTML: %v&quot;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// ...imprimir los elementos title del documento...</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El mismo patron se puede utilizar para otros recursos ademas de las conexiones de red, por ejemplo para cerrar un archivo abierto:</p>
<div class="figure" >
<p class="title"><code>io/ioutil</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">ioutil</span>

<span class="kd">func</span> <span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">ReadAll</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>o para desbloquear un mutex (<a href="#Seccion-9.2" >§9.2</a>):</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
<p>La sentencia <code>defer</code> tambien se puede utilizar para emparejar acciones de <q>entrada</q> y <q>salida</q> al depurar una funcion compleja. A continuacion la funcion <code>bigSlowOperation</code> llama inmediatamente a <code>trace</code>, lo que la hace una accion de <q>entrada</q> que devuelve un valor de funcion que, cuando se le llama, hace la accion de <q>salida</q>.  Al diferir una llamada a la funcion devuelta de esta manera, podemos instrumentar el punto de entrada y todos los puntos de salida de una funcion en una sola declaracion, e incluso pasar valores, como el tiempo de inicion <code>start</code>, entre las dos acciones. Pero no se olvide de los parentesis finales en el sentencia <code>defer</code>, o la accion de <q>entrada</q> ocurrira en la salida y la accion en la salida no ocurrira en absoluto!</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/trace/main.go" >gopl.io/ch5/trace</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">bigSlowOperation</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">trace</span><span class="p">(</span><span class="s">&quot;bigSlowOperation&quot;</span><span class="p">)()</span> <span class="c1">// no olvide los parentesis adicionales</span>
  <span class="c1">// ...mucho trabajo...</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>      <span class="c1">// simula el funcionamiento lento durmiendo</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;enter %s&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;exit %s (%s)&quot;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cada vez <code>bigSlowOperation</code> se llama, registra su entrada y salida y el tiempo transcurrido entre ellos. (Utilizamos <code>time.Sleep</code> para simular una operacion lenta.)</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch5/trace
$ ./trace
<span class="m">2015</span>/11/18 <span class="m">09</span>:53:26 enter bigSlowOperation
<span class="m">2015</span>/11/18 <span class="m">09</span>:53:36 <span class="nb">exit</span> bigSlowOperation <span class="o">(</span><span class="m">10</span>.000589217s<span class="o">)</span>
</pre></div>
<p>Las funciones diferidas se ejecutan despues de las declaraciones de retorno han actualizado las variables de resultado de la funcion. Debido a que una funcion anonima puede acceder a las variables de su funcion de inclusion, incluidos los resultados con nombra, una funcion anonima diferida puede observar los resultados de la funcion.</p>
<p>Considere la funcion <code>doble</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">doble</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>
</pre></div>
<p>Al nombrar a su variable de resultado y agregar una sentecia <code>defer</code>, podemos hacer que la funcion imprimir sus argumentos y resultados cada vez que se llame.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">doble</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">resultado</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;doble(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resultado</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="nx">_</span> <span class="p">=</span> <span class="nx">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1">// Salida:</span>
<span class="c1">// &quot;doble(4) = 8&quot;</span>
</pre></div>
<p>Este truco es exesivo para una funcion tan simple como <code>doble</code>, pero puede ser util en funciones con muchas declaraciones de retorno.</p>
<p>Una funcion anonima diferida puede incluso cambiar los valores que la funcion devuelve a su interlocutor:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">triple</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">+=</span> <span class="nx">x</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">doble</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">triple</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>
<p>Dado que las funciones diferidos no se ejecutan hasta el final de la ejecucion de una funcion, una declaracion <code>defer</code> en un bucle merece un escrutinio adicional. El codigo siguiente podria quedar sin los descriptores de archivo ya que ningun archivo se cerrara hasta que todos los archivos se hayan procesado:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// NOTA: arriesgado; podria quedarse sin los descriptores de archivo</span>
  <span class="c1">// ...procesando f...</span>
<span class="p">}</span>
</pre></div>
<p>Una solucion es mover el cuerpo del bucle, incluyendo la declaracion <code>defer</code>, a otra funcion que se llame en cada iteracion.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">filename</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">doFile</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="c1">// ...procesando f...</span>
<span class="p">}</span>
</pre></div>
<p>El siguiente ejemplo es una mejora del programa <code class="command" >fetch</code> (<a href="#Seccion-1.5" >§1.5</a>) que escribe la respuesta HTTP a un archivo local en lugar de a la salida estandar. Deriva el nombre del archivo del el ultimo componente de la ruta URL, que obtiene utilizando la funcion <code>path.Base</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/fetch/main.go" >gopl.io/ch5/fetch</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Fetch descarga la URL y regresa el rombre</span>
<span class="c1">// y la longitud del archivo local.</span>
<span class="kd">func</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

  <span class="nx">local</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">Base</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">local</span> <span class="o">==</span> <span class="s">&quot;/&quot;</span> <span class="p">{</span>
    <span class="nx">local</span> <span class="p">=</span> <span class="s">&quot;index.html&quot;</span>
  <span class="p">}</span>
  <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">local</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
  <span class="c1">// Close file, but prefer error from Copy, if any.</span>
  <span class="k">if</span> <span class="nx">closeErr</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">closeErr</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">local</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La llamada diferida a <code>resp.Body.Close</code> deberia resultar familiar por ahora. Es tentador utilizar una segunda llamada diferida, a <code>f.Close</code>, para cerrar el archivo local, pero esto seria sutilmente incorrecto porque <code>os.Create</code> abre un archivo para escribir, crear, segun sea necesario. En muchos sistemas de archivos, notablemente NFS, los errores de escritura no se informan inmediatamente pero se pueden posponer hasta que se cierre el archivo. Si no se comprueba el resultado de la operacion de cierre, la perdida de datos graves podria pasar desapercibida. Sin embargo, si ambos <code>io.Copy</code> y <code>f.Close</code> fallan, debemos preferir reportar el error de <code>io.Copy</code> desde que ocurre por primera vez y es mas probable que nos diga la causa raiz.</p>
<p><b>Ejercicio 5.18</b>: Sin cambiar su comportamiento, reescriba la funcion <code>fetch</code> utilizando <code>defer</code> para cerrar el archivo de escritura.</p>
</div>
<h3 id="Seccion-5.9" >Panico</h3>
<div class="hBody-3" >
<p>El sistema de tipado de Go captura muchos errores en tiempo de compilacion, pero otros, como un acceso a un arreglo fuera de limites o una desreferencia de puntero nulo, requieren comprobaciones en tiempo de ejecucion. Cuando go detecta errores en tiempo de ejecucion, entra en <em>panico</em>.</p>
<p>Durante un panico tipico, la ejecucion normal se detiene, todas las llamadas de funcion diferida en esa gorutina se ejecutan, y el programa se bloquea con un mensaje de registro. Este mensaje de registro incluye el <em>valor de panico</em>, que suele ser un mensaje de error de algun tipo, y, para cada goroutine, un <em>seguimiento de pila</em> que muestra la pila de llamadas a funciones que estaban activas en el momento del panico. Este mensaje de registro a menudo tiene suficiente informacion para diagnosticar la causa raiz del problema sin ejecutar el programa de nuevo, por lo que siempre debe incluirse en un informe de error acerca de un programa de panico.</p>
<p>No todos los panicos provienen del tiempo de ejecucion. La funcion nativa <code>panic</code> se puede llamar directamente; acepta cualquier valor como argumento. Un panico es a menudo lo mejor que puede hacer cuando ocurre alguna situacion <q>imposible</q>, por ejemplo, la ejecucion llega a un caso que logicamente, no puede suceder:</p>
<div class="highlight"><pre><span></span><span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nx">suit</span><span class="p">(</span><span class="nx">drawCard</span><span class="p">());</span> <span class="nx">s</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">&quot;Spades&quot;</span><span class="p">:</span>   <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Hearts&quot;</span><span class="p">:</span>   <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Diamonds&quot;</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="s">&quot;Clubs&quot;</span><span class="p">:</span>    <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;invalid suit %q&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">))</span> <span class="c1">// Joker?</span>
<span class="p">}</span>
</pre></div>
<p>Es una buena practica afirmar que las precondiciones de una funcion se mantienen, pero esto puede hacerse facilmente en exceso. A menos que pueda proporcionar un mensaje de error mas informativo o detectar un error antes, no tiene sentido afirmar una condicion que el tiempo de ejecucion comprobara por usted.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Reset</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;x is nil&quot;</span><span class="p">)</span> <span class="c1">// innecesario!</span>
  <span class="p">}</span>
  <span class="nx">x</span><span class="p">.</span><span class="nx">elements</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Aunque el mecanismo de panico de Go se parece a las excepciones de otros lenguajes, las situaciones en las que se utiliza el panico son muy diferentes. Puesto que un panico hace que el programa se bloquee, generalmente se usa para errores graves, como una inconsistencia logica en el programa; Los programadores diligentes consideran cualquier accidente como prueba de un error en su codigo. En un programa robusto, los errores <q>esperados</q>, el tipo que surgen de una entrada incorrecta, mala configuracion, o un defecto de E/S, deben manejarse con gracia; se tratan mejor con el uso de valores de <code>error</code>.</p>
<p>Considere la funcion <code>regexp.Compile</code>, que compila una expresion regular en una forma eficiente para la coincidencia. Se devuelve un <code>error</code> si se llama con un patron mal formado, pero la comprobacion de este error es innecesaria y onerosa si la persona que llama sabe que una llamada en particular no puede fallar. En tales casos, es razonable que el llamador maneje un error con un panico, ya que se cree que es imposible.</p>
<p>Como la mayoria de las expresiones regulares son literales en el codigo fuente del programa, la paquete <code>regexp</code> proporciona una funcion de envoltura <code>regexp.MustCompile</code> que hace esta comprobacion:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">regexp</span>

<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">MustCompile</span><span class="p">(</span><span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Regexp</span> <span class="p">{</span>
  <span class="nx">re</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">re</span>
<span class="p">}</span>
</pre></div>
<p>La funcion de envoltura hace que sea conveniente para los clientes inicializar una variable de nivel de paquete con una expresion regular compilada, como esta:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">httpSchemeRE</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="s">`^https?:`</span><span class="p">)</span> <span class="c1">// &quot;http:&quot; or &quot;https:&quot;</span>
</pre></div>
<p>Por supuesto, <code>MustCompile</code> no debe ser llamada con valores de entrada no confiables. El prefijo <code>Must</code> es una convencion de nomenclatura comun para este tipo de funciones, como <code>template.Must</code> en la <a href="#Seccion-4.6" >Seccion 4.6</a>.</p>
<p>Cuando se produce una situacion de panico, todas las funciones diferidas se ejecutan en orden inverso, comenzando con las funciones en lo mas alto de la pila y procediendo hasta <code>main</code>, como muestra el siguiente programa:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/defer1/defer.go" >gopl.io/ch5/defer1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;f(%d)\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="mi">0</span><span class="o">/</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// panics if x == 0</span>
  <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;defer %d\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cuando se ejecuta, el programa imprime lo siguiente en la salida estandar:</p>
<pre class="pre" >f(3)
f(2)
f(1)
defer 1
defer 2
defer 3</pre>
<p>Un panico se produce durante la llamada a <code>f(0)</code>, provocando que se ejecuten las tres llamadas diferidas a <code>fmt.Printf</code>. A continuacion, el tiempo de ejecucion finaliza el programa, imprimiendo el mensaje de panico y un volcado de pila en el flujo de error estandar (simplificado para mayor claridad):</p>
<pre class="pre" > panic: runtime error: integer divide by zero
 main.f(0)
         src/gopl.io/ch5/defer1/defer.go:14
 main.f(1)
         src/gopl.io/ch5/defer1/defer.go:16
 main.f(2)
         src/gopl.io/ch5/defer1/defer.go:16

 main.f(3)
         src/gopl.io/ch5/defer1/defer.go:16
 main.main()
         src/gopl.io/ch5/defer1/defer.go:10</pre>
<p>Como veremos mas adelante, es posible que una funcion se recupere de un panico para que no termine el programa.</p>
<p>Por propositod de diagnostico, el paquete <code>runtime</code> permite al programador volcar la pila utilizando la misma maquinaria. Al diferir una llamada a <code>printStack</code> en <code>main</code>,</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/defer2/defer.go" >gopl.io/ch5/defer2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">printStack</span><span class="p">()</span>
  <span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printStack</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="kt">byte</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:],</span> <span class="kc">false</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El siguiente texto adicional (simplificado de nuevo para mayor claridad) se imprime a la salida estandar:</p>
<pre class="pre" > goroutine 1 [running]:
 main.printStack()
   src/gopl.io/ch5/defer2/defer.go:20
 main.f(0)
   src/gopl.io/ch5/defer2/defer.go:27
 main.f(1)
   src/gopl.io/ch5/defer2/defer.go:29
 main.f(2)
   src/gopl.io/ch5/defer2/defer.go:29
 main.f(3)
   src/gopl.io/ch5/defer2/defer.go:29
 main.main()
   src/gopl.io/ch5/defer2/defer.go:15</pre>
<p>Los lectores familiarizados con excepciones en otros lenguajes pueden sorprenderse de que <code>runtime.Stack</code> pueda imprimir informacion sobre funciones que parecen haber sido <q>desenrolladas</q>. El Mecanismo de panico de Go ejecuta las funciones diferidos antes de desenrollar la pila.</p>
</div>
<h3 id="Seccion-5.10" >Recover</h3>
<div class="hBody-3" >
<p>Desistir es generalmente la respuesta correcta a un panico, pero no siempre. Podria ser posible recuperarse de alguna manera, o al menos limpiar el lio antes de marcharse. Por ejemplo, un servidor web que encuentra un problema inesperado podria cerrar la conexion en lugar de dejar al cliente colgado y, durante el desarrollo, podria informar el error al cliente tambien.</p>
<p>Si la funcion nativa <code>recover</code> se llama dentro de una funcion diferida y la funcion que contiene la sentencia <code>defer</code> es presa del panico, <code>recover</code> termina el actual estado de panico y devuelve el valor de panico. La funcion que estaba en panico no continua donde lo dejo pero devuelve normalmente. Si <code>recover</code> se llama en cualquier otro momento, no tiene ningun efecto y devuelve <code>nil</code>.</p>
<p>Para ilustrar, considere el desarrollo de un analizador para un lenguaje. Incluso cuando parece estar funcionando bien, dada la complejidad de su trabajo, los bichos todavia pueden acechar en esquinas oscuras. Podriamos preferir que, en lugar de fallar, el analizador convierta estos panicos en errores comunes de analisis, quizas con un mensaje extra exhortando al usuario a presentar un informe de error.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">input</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Syntax</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;internal error: %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="c1">// ...analizador...</span>
<span class="p">}</span>
</pre></div>
<p>La funcion diferida en <code>Parse</code> se recupera de una situacion de panico, utilizando el valor de panico para construir un mensaje de error; una version mas elegante podria incluir toda la pila de llamadas usando <code>runtime.Stack</code>. Luego la funcion diferida, asigna <code>err</code> al resultado, que se devuelve al llamador.</p>
<p>La recuperacion indiscriminada de los panicos es una practica dudosa porque el estado de las variables de un paquete despues de un panico raramente esta bien definido o documentado. Quizas una actualizacion critica de una estructura de datos estaba incompleta, se abrio una conexion de archivo o de red pero no se cerro o se obtuvo un bloqueo pero no se libero. Ademas, al reemplazar un bloqueo con, por ejemplo, una linea en un archivo de registro, la recuperacion indiscriminada puede hacer que los errores pasen desapercibidos.</p>
<p>La recuperacion de un panico dentro del mismo paquete puede ayudar a simplificar el manejo de errores complejos o inesperados, pero como regla general, no debe intentar recuperarse del panico de otro paquete. Las APIs publicas deben informar de fallos como <code>errores</code>. Del mismo modo, no debe recuperarse de un panico que puede pasar a traves de una funcion que no mantiene, como una llamador de devolucion de lllamada, ya que no puede razonar sobre su seguridad.</p>
<p>Por ejemplo, el paquete <code>net/http</code> proporciona un servidor web que envia las solicitudes entrantes a funciones de controlador proporcionados por el usuario. En lugar de permitir que un panico en uno de estos controladores elimine el proceso, el servidor llama a <code>recover</code>, imprime un seguimiento de la pila, y sigue atendiendo. Esto es conveniente en la practica, pero se corre el riesgo de perder recursos o dejar al manejador fallido en un estado no especificado que podria conducir a otros problemas.</p>
<p>Por todas las razones anteriores, es mas seguro recuperarse selectivamente si es necesario. En otras palabras, recuperar solo de los panicos que estaban destinados a ser recuperados, lo que deberia ser raro. Esta intencion puede ser codificado mediante el uso de un tipo distinto, sin exportar para el valor de panico y probar si el valor devuelto por <code>recover</code> tiene ese tipo. (Veremos una manera de hacer esto en el siguiente ejemplo.) Si es asi, el informamos el panico como un error ordinario; si no, que llamamos a <code>panic</code> con el mismo valor para reanudar el estado de panico.</p>
<p>El ejemplo siguiente es una variacion sobre el programa <code class="command" >title</code> que informa de un error si el documento HTML contiene multiples elementos <code>&lt;title&gt;</code>. Si es asi, se aborta la recursividad llamando a <code>panic</code> con un valor del tipo especial <code>bailout</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch5/title3/title.go" >gopl.io/ch5/title3</a></p>
<div class="highlight"><pre><span></span><span class="c1">// soleTitle regresa el siguiente texto del primer elemento title no vacio</span>
<span class="c1">// en doc, y un error si no existiera exactamente uno.</span>
<span class="kd">func</span> <span class="nx">soleTitle</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">title</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">bailout</span> <span class="kd">struct</span><span class="p">{}</span>

  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
      <span class="c1">// sin panico</span>
    <span class="k">case</span> <span class="nx">bailout</span><span class="p">{}:</span>
      <span class="c1">// panico &quot;esperado&quot;</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;multiple title elements&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="nb">panic</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// panico inersperado; continuar el panico</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Bail out de recursion si encontramos mas de un titulo no vacio.</span>
  <span class="nx">forEachNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s">&quot;title&quot;</span> <span class="o">&amp;&amp;</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">title</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">bailout</span><span class="p">{})</span> <span class="c1">// multiples elementos titulo</span>
      <span class="p">}</span>
      <span class="nx">title</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">.</span><span class="nx">Data</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="kc">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">title</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;no title element&quot;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">title</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion diferida que llama a <code>recover</code>, comprueba el valor de panico, e informa de un error ordinario si el valor era <code>bailout{}</code>. Todos los demas valores no nulos indican un panico inesperados, en cuyo caso el controlador llama a <code>panic</code> con ese valor, deshace el efecto de <code>recover</code> y reanuda el estado original de panico. (Este ejemplo viola algo nuestro consejo acerca de no usar panicos para errores <q>esperados</q>, pero proporciona una ilustracion compacta de la mecanica).</p>
<p>De algunas condiciones no hay recuperacion. La falta de memoria, por ejemplo, provoca en tiempo de ejecucion que el programa termine con un error grave.</p>
<p><b>Ejercicio 5.19</b>: Utilice <code>panic</code> y <code>recover</code> para escribir una funcion que no contenga ninguna sentencia <code>return</code> y devuelva un valor distinto de cero.</p>
</div>
<h2 id="Capitulo-6" >Metodos</h2>
<div class="hBody-2" >
<p>Desde principios de los noventa, la programacion orientada a objetos (OOP) ha sido el paradigma de programacion dominante en la industria y la educacion, y casi todos las lenguajes ampliamente utilizadas desarrolladas desde entonces han incluido el soporte para ello. Go no es una excepcion.</p>
<p>Aunque no existe una definicion universalmente aceptada de la programacion orientada a objetos, para nuestros propositos, un <em>objeto</em> es simplemente un valor o variable que tiene metodos, y un metodo es una funcion asociada a un tipo particular. Un programa orientado a objetos es aquel que utiliza metodos para expresar las propiedades y operaciones de cada estructura de datos de modo que los clientes no necesitan acceder directamente a la representacion del objeto.</p>
<p>En los capitulos anteriores, hemos hecho uso regular de metodos de la libreria estandar, como el metodo <code>Seconds</code> del tipo <code>time.Duration</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">day</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">day</span><span class="p">.</span><span class="nx">Seconds</span><span class="p">())</span> <span class="c1">// &quot;86400&quot;</span>
</pre></div>
<p>y definimos un metodo de propia en la <a href="#Seccion-2.5" >Seccion 2.5</a>, una metodo <code>String</code> para el Tipo <code>Celsius</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Celsius</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%g°C&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
<p>En este capitulo, el primero de dos en la programacion orientada a objetos, mostraremos como definir y utilizar metodos de manera eficaz. Tambien vamos a cubrir dos principios fundamentales de la programacion orientada a objetos, encapsulacion y composicion.</p>
</div>
<h3 id="Seccion-6.1" >Declaracion de Metodos</h3>
<div class="hBody-3" >
<p>Se declara un metodo con una variante de la declaracion de funcion ordinaria en la que aparece un parametro extra antes del nombre de la funcion. El parametro asigna la funcion al tipo de ese parametro.</p>
<p>Vamos a escribir nuestro primer metodo en un simple paquete de geometria plana:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch6/geometry/geometry.go" >gopl.io/ch6/geometry</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">geometria</span>

<span class="kn">import</span> <span class="s">&quot;math&quot;</span>

<span class="kd">type</span> <span class="nx">Punto</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="c1">// funcion tradicional</span>
<span class="kd">func</span> <span class="nx">Distancia</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Punto</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// lo mismo, pero como un metodo del tipo Punto</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Punto</span><span class="p">)</span> <span class="nx">Distancia</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Punto</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El parametro extra <code>p</code> se denomina el <em>receptor</em> del metodo, un legado de los primeros lenguajes orientados a objetos que describen la llamada a un metodo como <q>el envio de un mensaje a un objeto</q>.</p>
<p>En Go, no utilizamos un nombre especial como <code>this</code> o <code>self</code> para el receptor; Elegimos los nombres de los receptores tal como lo hariamos para cualquier otro parametro. Pusto que el nombre del receptor se utilizara con frecuencia, es una buena idea elegir algo corto y ser coherente entre los metodos. Una opcion comun es la primer letra del nombre del tipo, como <code>p</code> por <code>Point</code>.</p>
<p>En una llamada al metodo, el argumento del receptor aparece antes del nombre del metodo. Esto es paralelo a la declaracion, en la que el parametro del receptor aparece antes del nombre del metodo.</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Punto</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Punto</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Distancia</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span> <span class="c1">// &quot;5&quot;, llamada a funcion</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distancia</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>  <span class="c1">// &quot;5&quot;, llamada a metodo</span>
</pre></div>
<p>No hay conflicto entre las dos declaraciones de funcion llamadas <code>Distancia</code> anteriores. La primera declara una funcion de nivel paquete llamada <code>geometria.Distancia</code>. La segunda declara un procedimiento del tipo <code>Punto</code>, por lo que su nombre es <code>Punto.Distancia</code>.</p>
<p>La expresion <code>p.Distancia</code> se denomina un <em>selector</em>, porque selecciona el metodo apropiado <code>Distancia</code> para el receptor <code>p</code> de tipo <code>Punto</code>. Los selectores tambien se utilizan para seleccionar los campos de un tipo estructura, como en <code>p.X</code>. Dado que los metodos y campos habitan el mismo espacio de nombres, si declara un metodo <code>X</code> para el tipo de estructura <code>Punto</code> seria ambiguo y el compilador lo rechazara.</p>
<p>Debido a que cada tipo tiene su propio espacio de nombres para los metodos, podemos usar el nombre <code>Distancia</code> para otros metodos, siempre y cuando pertenecen a diferentes tipos. Vamos a definir un tipo <code>Ruta</code> que representa una secuencia de segmentos de linea y a darle un metodo <code>Distancia</code> tambien.</p>
<div class="highlight"><pre><span></span><span class="c1">// Una Ruta es un caminoA que conecta los puntos con lineas reactas.</span>
<span class="kd">type</span> <span class="nx">Ruta</span> <span class="p">[]</span><span class="nx">Punto</span>

<span class="c1">// Distancia devuelve la distancia recorrida a lo largo de la Ruta.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ruta</span> <span class="nx">Ruta</span><span class="p">)</span> <span class="nx">Distancia</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">:=</span> <span class="mf">0.0</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ruta</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">ruta</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Distancia</span><span class="p">(</span><span class="nx">ruta</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span>
<span class="p">}</span>
</pre></div>
<p><code>Ruta</code> es un tipo de slice con nombre, no un tipo de estructura como <code>Punto</code>, sin embargo, podemos definir metodos para el. Al permitir que los metodos se asocien con cualquier tipo, Go es diferente de muchos otros lenguajes orientados a objetos. A menudo es conveniente definir comportamientos adicionales para tipos simples como numeros, cadenas, slices, mapas, y a veces, incluso funciones. Los metodos pueden ser declarados en cualquier tipo con nombre definido en el mismo paquete, siempre y cuando su tipo subyacente no sea un puntero ni una interfaz.</p>
<p>Las dos metodos <code>Distancia</code> tienen diferentes tipos. No estan relacionados entre si en absoluto, aunque <code>Ruta.Distancia</code> utiliza a <code>Punto.Distancia</code> internamente para calcular la longitud de cada segmento que une los puntos adyacentes.</p>
<p>Vamos a llamar al nuevo metodo para calcular el perimetro de un triangulo rectangulo:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span><span class="nx">perim</span> <span class="o">:=</span> <span class="nx">Ruta</span><span class="p">{</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
  <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distancia</span><span class="p">())</span> <span class="c1">// &quot;12&quot;</span>
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<figure>
<img src="img/perim.Distance.jpg" />
</figure>
</div>
</div>
<p>En las dos llamadas anterior a metodos con nombre <code>Distancia</code>, el compilador determina que funcion debe llamar basandose tanto en el nombre del metodo y el tipo de receptor. En el primero, <code>ruta[i-1]</code> tiene tipo <code>Punto</code>, asi que se llama a <code>Punto.Distancia</code>; en el segundo, <code>perim</code> tiene el tipo Ruta, por lo que se llama a <code>Ruta.Distancia</code>.</p>
<p>Todos los metodos de un tipo dado deben tener nombres unicos, pero diferentes tipos pueden utilizar el mismo nombre para un metodo, al igual que los metodos <code>Distancia</code> para <code>Punto</code> y <code>Ruta</code>; no hay necesidad de calificar los nombres de funcion (por ejemplo, <code>RutaDistancia</code>) para eliminar la ambigüedad. Aqui vemos el primer beneficio al usar metodos sobre funciones ordinarias: los nombres de metodos pueden ser mas cortos. El beneficio se magnifica para las llamadas que se originan fuera del paquete, ya que pueden utilizar el nombre mas corto y omitir el nombre del paquete:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;gopl.io/ch6/geometry&quot;</span>

<span class="nx">perim</span> <span class="o">:=</span> <span class="nx">geometry</span><span class="p">.</span><span class="nx">Path</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">PathDistance</span><span class="p">(</span><span class="nx">perim</span><span class="p">))</span> <span class="c1">// &quot;12&quot;, funcion independiente</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">perim</span><span class="p">.</span><span class="nx">Distance</span><span class="p">())</span>             <span class="c1">// &quot;12&quot;, metodo de geometry.Path</span>
</pre></div>
</div>
<h3 id="Seccion-6.2" >Metodos con un Receptor de Puntero</h3>
<div class="hBody-3" >
<p>Ya que llamar a una funcion crea una copia de cada valor de argumento, si una funcion necesita actualizar una variable, o si un argumento es tan grande que queremos evitar copiarlo, debemos pasar la direccion de la variable usando un puntero. Lo mismo ocurre con los metodos que necesitan actualizar la variable del receptor: los adjudicamos al tipo como puntero, como <code>*Point</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">*=</span> <span class="nx">factor</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*=</span> <span class="nx">factor</span>
<span class="p">}</span>
</pre></div>
<p>El nombre de este metodo es <code>(*Point).ScaleBy</code>. Los parentesis son necesarios; sin ellos, la expresion se analiza como <code>*(Point.ScaleBy)</code>.</p>
<p>En un programa realista, la convencion dicta que si cualquier metodo de <code>Point</code> tiene un receptor puntero, entonces todos los metodos de <code>Point</code> deben tener un receptor puntero, incluso los que no lo necesitan estrictamente. Hemos roto esta regla para <code>Point</code> de modo que podamos mostrar ambos tipos de metodo.</p>
<p>Tipos con nombre (<code>Point</code>) y punteros a ellos <code>(*Point)</code> son los unicos tipos que pueden aparecer en una declaracion receptor. Ademas, para evitar ambigüedades, las declaraciones de metodos no estan permitidas en tipos con nombre que son ellos mismos tipos de puntero:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">P</span> <span class="o">*</span><span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">P</span><span class="p">)</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// error de compilacion: tipo de receptor invalido</span>
</pre></div>
<p>El metodo <code>(*Point).ScaleBy</code> se puede llamar al proporcionar un receptor <code>*Point</code>, asi:</p>
<div class="highlight"><pre><span></span><span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">r</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>
<p>o asi:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">pptr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>
<p>o asi:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">).</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// &quot;{2, 4}&quot;</span>
</pre></div>
<p>Pero los dos ultimos casos son desagradables. Afortunadamente, el lenguaje nos ayuda aqui. Si el receptor <code>p</code> es una variable de tipo <code>Point</code>, pero el metodo requiere un receptor <code>*Point</code>, podemos emplear esta abreviatura:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>y el compilador realizara un <code>&amp;p</code> implicito sobre la variable. Esto solo funciona para las variables, incluyendo los campos de la estructura como <code>p.X</code> y elementos de la arreglo o slice como <code>perim[0]</code>. No podemos llamar a un metodo <code>*Point</code> en un receptor <code>Point</code> no direccionable, porque no hay manera de obtener la direccion de un valor temporal.</p>
<div class="highlight"><pre><span></span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// compile error: can&#39;t take address of Point literal</span>
</pre></div>
<p>Sin embargo, podemos llamar a un metodo <code>Point</code> como <code>Point.Distance</code> con un receptor <code>*Point</code>, porque hay una manera de obtener el valor de la direccion: solo tiene que cargar el valor apuntado por el receptor. El compilador inserta una operacion <code>*</code> implicita por nosotros. Estas dos llamadas de funcion son equivalentes:</p>
<div class="highlight"><pre><span></span><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="nx">pptr</span><span class="p">).</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
</pre></div>
<p>Vamos a resumir estos tres casos de nuevo, ya que son un punto frecuente de confusion. En cada expresion de llamada de metodo valida, exactamente una de estas tres sentencias es verdadera.</p>
<p>O bien el argumento receptor tiene el mismo tipo que el parametro del receptor, por ejemplo ambos tienen tipo <code>T</code> o ambos tienen tipo <code>*T</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">//  Point</span>
<span class="nx">pptr</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1">// *Point</span>
</pre></div>
<p>O el argumento de receptor es una variable de tipo <code>T</code> y el parametro receptor tiene tipo <code>*T</code>. El compilador toma implicitamente la direccion de la variable:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// implicit (&amp;p)</span>
</pre></div>
<p>O el argumento receptor tiene tipo <code>*T</code> y el parametro receptor tiene tipo <code>T</code>. El compilador dereferencia implicitamente al receptor, en otras palabras, carga el valor:</p>
<div class="highlight"><pre><span></span><span class="nx">pptr</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// implicit (*pptr)</span>
</pre></div>
<p>Si todos los metodos de un tipo con nombre <code>T</code> tienen un tipo de receptor <code>T</code> en si (no <code>*T</code>), es seguro copiar las instancias de ese tipo; Llamar a cualquiera de sus metodos necesariamente hace una copia. Por ejemplo, los valores <code>time.Duration</code> se copian liberalmente, incluyendo como argumentos a las funciones. Pero si cualquier metodo tiene un receptor de puntero, se debe evitar copiar instancas de <code>T</code>, ya que hacerlo puede violar invariantes internos. Por ejemplo, copiar una instancia de <code>bytes.Buffer</code> haria que el original y la copia como alias (<a href="#Seccion-2.3.2" >§2.3.2</a>) tubieran el mismo arreglo subyacente de bytes. Las llamadas de metodo subsiguientes tendrian efectos impredecibles.</p>
</div>
<h4 id="Seccion-6.2.1" >Nil es un Valor de Receptor Valido</h4>
<div class="hBody-4" >
<p>Al igual que algunas funciones permiten punteros nulos como argumentos, tambien lo hacen algunos metodos para su receptor, especialmente si <code>nil</code> es un valor cero significativo del tipo, al igual que con los mapas y los slices. En esta sencilla lista enlazada de numeros enteros, <code>nil</code> representa la lista vacia:</p>
<div class="highlight"><pre><span></span><span class="c1">// Un IntList es una lista enlazada de enteros.</span>
<span class="c1">// Un nil *IntList representa la lista vacia.</span>
<span class="kd">type</span> <span class="nx">IntList</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Value</span> <span class="kt">int</span>
  <span class="nx">Tail</span> <span class="o">*</span><span class="nx">IntList</span>
<span class="p">}</span>

<span class="c1">// Sum regresa la suma de la lista de elementos.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">list</span> <span class="o">*</span><span class="nx">IntList</span><span class="p">)</span> <span class="nx">Sum</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">list</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>Cuando se define un tipo cuyos metodos permiten <code>nil</code> como valor receptor, vale la pena señalar esto explicitamente en su comentario de documentacion, como lo hicimos arriba.</p>
<p>Aqui esta parte de la definicion del tipo <code>Values</code> del paquete <code>net/url</code>:</p>
<div class="figure" >
<p class="title"><code>net/url</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">url</span>

<span class="c1">// Values map asigna clave de cadena a una lista de valores.</span>
<span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>

<span class="c1">// Get devuelve el primer valor asociado con la clave dada,</span>
<span class="c1">// o &quot;&quot; si no hay nada.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">vs</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s">&quot;&quot;</span>
<span class="p">}</span>

<span class="c1">// Add agrega el valor a la clave.</span>
<span class="c1">// Se añade a cualquier valor existente asociado con la clave.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Expone su representacion como un mapa, pero tambien proporciona metodos para simplificar el acceso al mapa, cuyos valores son slices de cadenas–es un <em>mapa multiple</em>. Sus clientes pueden utilizar sus operadores intrinsecos (<code>make</code>, slice literales, <code>m[key]</code>, etc.), o sus metodos, o ambos, como prefiera:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch6/urlvalues/main.go" >gopl.io/ch6/urlvalues</a></p>
<div class="highlight"><pre><span></span><span class="nx">m</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">{</span><span class="s">&quot;lang&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;en&quot;</span><span class="p">}}</span> <span class="c1">// construccion directa</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;lang&quot;</span><span class="p">))</span> <span class="c1">// &quot;en&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">))</span>    <span class="c1">// &quot;&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;1&quot;      (primer valor)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;item&quot;</span><span class="p">])</span>     <span class="c1">// &quot;[1 2]&quot;  (acceso directo al mapa)</span>

<span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">))</span> <span class="c1">// &quot;&quot;</span>
<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">)</span>         <span class="c1">// panico: asignacion a ingresar en un mapa nil</span>
</pre></div>
</div>
<p>En la llamada final a <code>Get</code>, el receptor <code>nil</code> se comporta como un mapa vacio. Podriamos haberlo escrito como <code>Values(nil).Get(&quot;item&quot;)</code>, pero <code>nil.Get(&quot;item&quot;)</code> no se compilara porque el tipo <code>nil</code> no se ha determinado. Por el contrario, la llamada final a <code>Add</code> proboca un panico, ya que trata de actualizar un mapa nil.</p>
<p>Debido a que <code>url.Values</code> es un tipo de mapa y un mapa se refiere a sus pares clave/valor indirectamente, las actualizaciones y supresiones que <code>url.Values.Add</code> hace a los elementos del mapa son visibles para el llamador. Sin embargo, al igual que con las funciones ordinarias, los cambios que un metodo hace a la propia referencia, como establecerlo en <code>nil</code> o hacer que se refiera a una estructura de mapa de datos diferente, no se reflejaran en el llamador.</p>
</div>
<h3 id="Seccion-6.3" >Composicion de Tipos por Estructuras Enbebidas</h3>
<div class="hBody-3" >
<p>Considere el tipo <code>ColoredPoint</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch6/coloredpoint/main.go" >gopl.io/ch6/coloredpoint</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;image/color&quot;</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Point</span>
  <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Podriamos haber definido <code>ColoredPoint</code> como una estructura de tres campos, pero en su lugar, <em>enbebimos</em> un <code>Point</code> para proporcionar los campos <code>X</code> e <code>Y</code>. Como vimos en la <a href="#Seccion-4.4.3" >Seccion 4.4.3</a>, la incrustacion nos permite tomar un atajo sintactico para definir un tipo <code>ColoredPoint</code> que contiene todos los campos de <code>Point</code>, ademas de un poco mas. Si queremos, podemos seleccionar los campos de <code>ColoredPoint</code> que fueron aportados por el <code>Point</code> embebido sin mencionar a <code>Point</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">cp</span> <span class="nx">ColoredPoint</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span> <span class="c1">// &quot;1&quot;</span>
<span class="nx">cp</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="mi">2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>       <span class="c1">// &quot;2&quot;</span>
</pre></div>
<p>Un mecanismo similar se aplica a los <em>metodos</em> de <code>Point</code>. Podemos llamar a los metodos del enbebido <code>Point</code> utilizando un receptor de tipo <code>ColoredPoint</code>, a pesar de que <code>ColoredPoint</code> no tiene metodos declarados:</p>
<div class="highlight"><pre><span></span><span class="nx">red</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="nx">blue</span> <span class="o">:=</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">q</span> <span class="p">=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;10&quot;</span>
</pre></div>
<p>Los metodos de <code>Point</code> han sido <em>promovidos</em> a <code>ColoredPoint</code>. De esta manera, la incrustacion permite tipos complejos con muchos metodos que se construiran por la composicion de varios campos, cada uno proporcionando unos pocos metodos.</p>
<p>Los lectores familiarizados con lenguajes orientados a objetos basados en clases pueden ser tentados a ver <code>Point</code> como una clase base y <code>ColoredPoint</code> como una subclase o clase derivada, o a interpretar la relacion entre estos tipos como si <code>ColoredPoint</code> <q>es un</q> <code>Point</code>. Pero eso seria un error. Observe las llamadas a <code>Distance</code> arriba. <code>Distance</code> tiene un parametro de tipo <code>Point</code>, ya que <code>q</code> no es un <code>Point</code>, asi que aunque <code>q</code> tiene un campo enbebido de ese tipo, debemos seleccionarlo explicitamente. Si intenta pasar <code>q</code> seria un error:</p>
<div class="highlight"><pre><span></span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="c1">// error de compilacion: no se puede utilizar q (ColoredPoint) como Point</span>
</pre></div>
<p>Un <code>ColoredPoint</code> no es un <code>Point</code>, pero <q>tiene un</q> <code>Point</code>, y tiene dos metodos adicionales <code>Distance</code> y <code>ScaleBy</code> promocionados desde <code>Point</code>. Si prefiere pensar en terminos de implementacion, el campo enbebido instruye al compilador a generar metodos de envoltura adicionales que delegan en los metodos declarados, equivalentes a los siguientes:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ColoredPoint</span><span class="p">)</span> <span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="nx">factor</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Cuando <code>Point.Distance</code> es llamado por el primero de estos metodos de envoltura, su valor receptor es <code>p.Point</code>, no <code>p</code>, y no hay manera de que el metodo accededa a <code>ColoredPoint</code> en el que <code>Point</code> esta enbebido.</p>
<p>El tipo de un campo anonimo puede ser un <em>puntero</em> a un tipo con nombre, en cuyo caso los campos y metodos se promueven indirectamente del puntero al objeto. Agregar otro nivel de indireccion nos permite compartir estructuras comunes y variar las relaciones entre los objetos dinamicamente. La declaracion de <code>ColoredPoint</code> a continuacion incorpora un <code>*Point</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">Point</span>
  <span class="nx">Color</span> <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>

<span class="nx">p</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">red</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">ColoredPoint</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Point</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="nx">blue</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span><span class="p">(</span><span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">))</span> <span class="c1">// &quot;5&quot;</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">Point</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Point</span>                 <span class="c1">// ahora p y q comparten el mismo Point</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">Point</span><span class="p">,</span> <span class="o">*</span><span class="nx">q</span><span class="p">.</span><span class="nx">Point</span><span class="p">)</span>   <span class="c1">// &quot;{2 2} {2 2}&quot;</span>
</pre></div>
<p>Un tipo de estructura puede tener mas de un campo anonimo. Si hubieramos declarado <code>ColoredPoint</code> como</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ColoredPoint</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Point</span>
  <span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span>
<span class="p">}</span>
</pre></div>
<p>entonces un valor de este tipo tendria todos los metodos de <code>Point</code>, todos los metodos de <code>RGBA</code>, y cualesquiera otros metodos declarados en <code>ColoredPoint</code> directamente. Cuando el compilador resuelve un selector como <code>p.ScaleBy</code> a un metodo, primero se busca un metodo llamado directamente declarada <code>ScaleBy</code>, luego, para los metodos promovidos de campos incrustados en <code>ColoredPoint</code>, luego, para los metodos promovidos dos veces de campos incrustados dentro <code>Point</code> y <code>RGBA</code>, y asi sucesivamente. El compilador informa de un error si el selector es ambiguo porque se promocionaron dos metodos desde el mismo rango.</p>
<p>Los metodos pueden ser declaradas solo en tipos con nombre (como <code>Point</code>) y punteros a ellos (<code>*Point</code>), pero gracias al embedido, es posible y, a veces util que los tipos de estructura <em>sin nombre</em> tambien tengan metodos.</p>
<p>Aqui hay un buen truco para ilustrarlo. Este ejemplo muestra parte de una cache simple implementada usando dos variables a nivel de paquete, un mutex (<a href="#Seccion-9.2" >§9.2</a>) y el mapa que lo protege:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// protege a mapping</span>
  <span class="nx">mapping</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
<p>La version de abajo es funcionalmente equivalente pero agrupa a las dos variables relacionadas en una unica variable de nivel de paquete, <code>cache</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">cache</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
  <span class="nx">mapping</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span> <span class="p">{</span>
  <span class="nx">mapping</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Lookup</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">cache</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">mapping</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">cache</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
<p>La nueva variable da nombres mas expresivos a las variables relacionadas con la <code>cache</code>, y debido a que el campo <code>sync.Mutex</code> esta enbebido dentro de ella, su metodos <code>Lock</code> y <code>Unlock</code> se promueven al tipo de estructura sin nombre, lo que nos permite bloquear la <code>cache</code> con una sintaxis auto explicativa.</p>
</div>
<h3 id="Seccion-6.4" >Valores y Expresiones de los Metodos</h3>
<div class="hBody-3" >
<p>Normalmente seleccionamos y llamamos a un metodo en la misma expresion, como en <code>p.Distance()</code>, pero es posible separar estas dos operaciones. El selector <code>p.Distance</code> produce un <em>valor de metodo</em>, una funcion une un metodo (<code>Point.Distance</code>) a un valor de receptor especifico <code>p</code>. Esta funcion puede entonces ser invocada sin un valor de receptor; Solo necesita los argumentos del no receptor.</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

<span class="nx">distanceFromP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Distance</span>        <span class="c1">// volor del metodo</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span>      <span class="c1">// &quot;5&quot;</span>
<span class="kd">var</span> <span class="nx">origin</span> <span class="nx">Point</span>                   <span class="c1">// {0, 0}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distanceFromP</span><span class="p">(</span><span class="nx">origin</span><span class="p">))</span> <span class="c1">// &quot;2.23606797749979&quot;, √5</span>

<span class="nx">scaleP</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ScaleBy</span> <span class="c1">// valor del metodo</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>           <span class="c1">// p se vuelve (2, 4)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>           <span class="c1">//       luego (6, 12)</span>
<span class="nx">scaleP</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>          <span class="c1">//       luego (60, 120)</span>
</pre></div>
<p>Los valores de metodo son utiles cuando la API de un paquete solicita un valor de funcion y el comportamiento deseado del cliente para esa funcion es llamar a un metodo en un receptor especifico. Por ejemplo, la funcion <code>time.AfterFunc</code> llama a un valor de funcion despues de un retardo especificado. Este programa lo utiliza para lanzar el cohete <code>r</code> despues de 10 segundos:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Rocket</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Rocket</span><span class="p">)</span> <span class="nx">Launch</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nx">r</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Rocket</span><span class="p">)</span>
<span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">()</span> <span class="p">})</span>
</pre></div>
<p>La sintaxis del valor del metodo es mas corta:</p>
<div class="highlight"><pre><span></span><span class="nx">time</span><span class="p">.</span><span class="nx">AfterFunc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Launch</span><span class="p">)</span>
</pre></div>
<p>En relacion con el valor del metodo es la <em>expresion del metodo</em>. Al llamar a un metodo, a diferencia de una funcion ordinaria, debemos suministrar al receptor de una manera especial usando la sintaxis del selector. Una expresion de metodo, escrita <code>T.f</code> o <code>(*T).f</code> donde <code>T</code> es un tipo, produce un valor de funcion con un primer parametro tomando el lugar del receptor, por lo que puede ser llamado de la manera habitual.</p>
<div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">q</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

<span class="nx">distance</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Distance</span>   <span class="c1">// expresion del metodo</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">distance</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">))</span>  <span class="c1">// &quot;5&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">distance</span><span class="p">)</span> <span class="c1">// &quot;func(Point, Point) float64&quot;</span>

<span class="nx">scale</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nx">ScaleBy</span>
<span class="nx">scale</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>            <span class="c1">// &quot;{2 4}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">scale</span><span class="p">)</span> <span class="c1">// &quot;func(*Point, float64)&quot;</span>
</pre></div>
<p>Las expresiones de metodo pueden ser utiles cuando se necesita un valor para representar una eleccion entre varios metodos pertenecientes al mismo tipo para que pueda llamar al metodo elegido con muchos receptores diferentes. En el siguiente ejemplo, la variable <code>op</code> representa el metodo de suma o resta del tipo <code>Point</code>, y <code>Path.TranslateBy</code> lo llama para cada punto en <code>Path</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Sub</span><span class="p">(</span><span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Point</span><span class="p">{</span><span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Y</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="p">[]</span><span class="nx">Point</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">path</span> <span class="nx">Path</span><span class="p">)</span> <span class="nx">TranslateBy</span><span class="p">(</span><span class="nx">offset</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">add</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">op</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="nx">Point</span><span class="p">)</span> <span class="nx">Point</span>
  <span class="k">if</span> <span class="nx">add</span> <span class="p">{</span>
    <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Add</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">op</span> <span class="p">=</span> <span class="nx">Point</span><span class="p">.</span><span class="nx">Sub</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">path</span> <span class="p">{</span>
    <span class="c1">// llama en cada path[i].Add(offset) o path[i].Sub(offset).</span>
    <span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">offset</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<h3 id="Seccion-6.5" >Ejemplo: Tipo de Vector de Bits</h3>
<div class="hBody-3" >
<p>Los conjuntos en Go se implementan generalmente como un <code>map[T]bool</code>, donde <code>T</code> es el tipo del elemento. Un conjunto representado por un mapa es muy flexible pero, para ciertos problemas, una representacion especializada puede superarla. Por ejemplo, en dominios tales como el analisis de flujo de datos donde los elementos del conjunto son pequeños numeros enteros no negativos, los conjuntos tienen muchos elementos, y las operaciones de conjunto como union e interseccion son comunes, un vector de bits es ideal.</p>
<p>Un vector de bits utiliza una slice de valores o <q>palabras</q> de enteros sin signo, cada bit de los cuales representa un posible elemento del conjunto. El conjunto contiene <code>i</code> si se establece el enesimo bit. El siguiente programa muestra un tipo de vector de bits simple con tres metodos:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch6/intset/intset.go" >gopl.io/ch6/intset</a></p>
<div class="highlight"><pre><span></span><span class="c1">// un IntSet es us conjunto pequeño de enteros no negativos.</span>
<span class="c1">// El valor cero representa un conjunto vacio.</span>
<span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>

<span class="c1">// Has Informa cuando el conjunto contiene valores x no negativos.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Has</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">word</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">bit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// Add agrega el valor x no negativo al conjunto.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">word</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">64</span><span class="p">,</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">64</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">word</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">word</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bit</span>
<span class="p">}</span>

<span class="c1">// UnionWith establece s a la union de s y t.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">UnionWith</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tword</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">tword</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">words</span><span class="p">,</span> <span class="nx">tword</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ya que cada palabra tiene 64 bits, para localizar el bit para <code>x</code>, se utiliza el cociente <code>x/64</code> como el indice de la palabra y el resto <code>x%64</code> como el indice de bit dentro de esa palabra. La operacion <code>UnionWith</code> utiliza el operador binario OR <code>|</code> Para calcular la union de 64 elementos a la vez. (Vamos a revisar la eleccion de palabras de 64 bits en el Ejercicio 6.5.)</p>
<p>Esta aplicacion carece de muchas caracteristicas deseables, algunas de las cuales se plantean como ejercicios, pero es dificil vivir sin : una forma de imprimir un <code>IntSet</code> como una cadena. Vamos a darle una String metodo como lo hicimos con <code>Celsius</code> en la <a href="#Seccion-2.5" >Seccion 2.5</a>:</p>
<div class="highlight"><pre><span></span><span class="c1">// String regresa el conjunto como una cadena de la forma &quot;{1 2 3}&quot;.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;{&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">words</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">word</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">word</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s">&quot;{&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;}&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>Note la similitud del metodo anterior <code>String</code> con <code>intsToString</code> en la <a href="#Seccion-3.5.4" >Seccion 3.5.4</a>; <code>bytes.Buffer</code> se utiliza a menudo de esta manera en metodos <code>String</code>. El paquete <code>fmt</code> maneja tipos con un metodo <code>String</code> especialmente para que los valores de los tipos complicados se puedan mostrar de una manera amigable para el usuario. En lugar de imprimir la representacion del valor en bruto (una estructura en este caso), <code>fmt</code> llama al metodo <code>String</code>. El mecanismo se basa en interfaces y tipo de afirmaciones, que vamos a explicar en el <a href="#Capitulo-7" >Capitulo 7</a>.</p>
<p>Ahora podemos demostrar <code>IntSet</code> en accion:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">IntSet</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">144</span><span class="p">)</span>
<span class="nx">x</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 144}&quot;</span>

<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{9 42}&quot;</span>

<span class="nx">x</span><span class="p">.</span><span class="nx">UnionWith</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span> <span class="c1">// &quot;true false&quot;</span>
</pre></div>
<p>Una palabra de precaucion: declaramos <code>String</code> y <code>Has</code> como metodos del tipo de puntero <code>*IntSet</code> no por necesidad, sino por coherencia con los otros dos metodos, los cuales necesitan un receptor puntero porque asignan a <code>s.words</code>. En consecuencia, un valor <code>IntSet</code> no tiene una metodo <code>String</code>, en ocasiones, conduce a sorpresas como esta:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>         <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;{1 9 42 144}&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>          <span class="c1">// &quot;{[4398046511618 0 65536]}&quot;</span>
</pre></div>
<p>En el primer caso, Imprimimos un puntero <code>*IntSet</code>, que tiene un metodo <code>String</code>. En el segundo caso, que llamamos a <code>String()</code> en una variable <code>IntSet</code>; el compilador inserta la operacion <code>&amp;</code> implicita, que nos da un puntero, que tiene el metodo <code>String</code>. Sin embargo, en el tercer caso, debido a que el valor <code>IntSet</code> no tiene un metodo <code>String</code>, fmt.Println imprime la representacion de la estructura en su lugar. Es importante no olvidar el operador <code>&amp;</code>. Hacer <code>String</code> un metodo de <code>IntSet</code>, no <code>*IntSet</code>, podria ser una buena idea, pero esto es un juicio caso por caso.</p>
<p><b>Ejercicio 6.1</b>: Implementar estos metodos adicionales:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>      <span class="c1">// regresa el numero de elementos</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Remove</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">// elimina x del conjunto</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Clear</span><span class="p">()</span>        <span class="c1">// elimina todos los elementos del conjunto</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">Copy</span><span class="p">()</span> <span class="o">*</span><span class="nx">IntSet</span> <span class="c1">// regresa una copia del conjunto</span>
</pre></div>
<p><b>Ejercicio 6.2</b>: Definir una metodo variadic <code>(*IntSet).AddAll(...int)</code> que permita añadir una lista de valores, como <code>s.AddAll(1, 2, 3)</code>.</p>
<p><b>Ejercicio 6.3</b>: <code>(*IntSet).UnionWith</code> calcula la union de dos conjuntos utilizando <code>|</code>, el operador OR binario. Implementar metodos para <code>IntersectWith</code>, <code>DifferenceWith</code>, y <code>SymmetricDifference</code> para las operaciones de conjuntos correspondientes. (La diferencia simetrica de dos conjuntos contiene los elementos presentes en un conjunto o el otro, pero no ambos.)</p>
<p><b>Ejercicio 6.4</b>: añadir un metodo <code>Elems</code> que devuelve una slice que contiene los elementos del conjunto, apto para iterar sobre el con una bucle <code>range</code>.</p>
<p><b>Ejercicio 6.5</b>: El tipo de cada palabra usada por <code>IntSet</code> es <code>uint64</code>, pero la aritmetica de 64 bits puede ser ineficiente en una plataforma de 32 bits. Modificar el programa para usar el tipo <code>uint</code>, que es el tipo entero sin signo mas eficiente para la plataforma. En lugar de dividir por 64, definir una constante que almacene el tamaño efectivo de <code>uint</code> en bits, 32 o 64. Se puede utilizar la expresion tal vez demasiado inteligente <code>32 &lt;&lt; (^uint(0) &gt;&gt; 63)</code> para este proposito.</p>
</div>
<h3 id="Seccion-6.6" >Encapsulacion</h3>
<div class="hBody-3" >
<p>Se dice que una variable o metodo de un objeto esta encapsulado si es inaccesible para los clientes del objeto. La encapsulacion, a veces llamado ocultacion de la informacion, es un aspecto clave de la programacion orientada a objetos.</p>
<p>Go solo tiene un mecanismo para controlar la visibilidad de los nombres: los identificadores en mayusculas se exportan desde el paquete en el que estan definidos y los nombres no capitalizados no. El mismo mecanismo que limita el acceso a los miembros de un paquete tambien limita el acceso a los campos de una estructura o los metodos de un tipo. Como consecuencia, para encapsular un objeto, debemos hacer que sea una estructura.</p>
<p>Esa es la razon por la que el tipo <code>IntSet</code> de la seccion anterior fue declarado como un tipo de estructura a pesar de que solo tiene un unico campo:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="p">[]</span><span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>
<p>En cambio podriamos definir <code>IntSet</code> como un tipo de slice de la siguiente manera, aunque por supuesto tendriamos que sustituir cada ocurrencia de <code>s.words</code> por <code>*s</code> en sus metodos:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntSet</span> <span class="p">[]</span><span class="kt">uint64</span>
</pre></div>
<p>Aunque esta version de <code>IntSet</code> esencialmente seria equivalente, permitiria a clientes de otros paquetes leer y modificar el slice directamente. Dicho de otra manera, mientras que la expresion <code>*s</code> se podrian utilizar en cualquier paquete, <code>s.words</code> solo puede aparecer en el paquete que define <code>IntSet</code>.</p>
<p>Otra consecuencia de este mecanismo basado en el nombre es que la unidad de encapsulacion es el paquete, no el tipo como en muchos otros lenguajes. Los campos de un tipo de estructura son visibles para todo el codigo dentro del mismo paquete. Si el codigo aparece en una funcion o un metodo no hace ninguna diferencia.</p>
<p>La encapsulacion proporciona tres beneficios. En primer lugar, debido a que los clientes no pueden modificar directamente las variables del objeto, es necesario inspeccionar menos enunciados para comprender los valores posibles de esas variables.</p>
<p>En segundo lugar, ocultar los detalles de la implementacion impide que los clientes dependan de las cosas que podrian cambiar, lo que le da al diseñador mayor libertad para evolucionar la implementacion sin romper la compatibilidad de la API.</p>
<p>Como ejemplo, considere el tipo <code>bytes.Buffer</code> tipo. Se utiliza con frecuencia para acumular cadenas muy cortas, por lo que es una optimizacion rentable para reservar un poco mas de espacio en el objeto para evitar la asignacion de memoria en este caso comun. Ya que <code>Buffer</code> es un tipo <code>struct</code>, este espacio tiene la forma de un campo adicional de tipo <code>[64]byte</code> con un nombre en minusculas. Cuando se añadio este campo, ya que no se exporto, los clientes de <code>Buffer</code> fuera del paquete <code>bytes</code> no eran conscientes de ningun cambio, excepto un rendimiento mejorado. <code>Buffer</code> y su metodo <code>Grow</code> se muestran a continuacion, simplificado para mayor claridad:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Buffer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">buf</span>     <span class="p">[]</span><span class="kt">byte</span>
  <span class="nx">initial</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
  <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="c1">// Grow apmlia la capacidad del buffer, si es necesario,</span>
<span class="c1">// para garantizar espacio por otron n bytes. [...]</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nx">Grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">initial</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// use preallocated space initially</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">Len</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>El tercer beneficio de la encapsulacion, y en muchos casos el mas importante, es que impide que los clientes establezcan arbitrariamente las variables de un objeto. Debido a que las variables del objeto solo pueden ser definidas por funciones en el mismo paquete, el autor de ese paquete puede garantizar que todas esas funciones mantengan las invariantes internas del objeto. Por ejemplo, el tipo <code>Counter</code> continuacion permite a los clientes incrementar el contador o reestablecerlo a cero, pero no ponerlo en un valor arbitrario:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">n</span> <span class="kt">int</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">N</span><span class="p">()</span> <span class="kt">int</span>     <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Increment</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">Reset</span><span class="p">()</span>     <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
</pre></div>
<p>Las Funciones que simplemente acceso o modifican los valores internos de un tipo, como los metodos del tipo <code>Logger</code> del paquete <code>log</code>, a continuacion, se denominan <em>getters</em> (optenedores) y <em>setters</em> (definidores). Sin embargo, al nombrar a un metodo getter, por lo general omitimos el prefijo <code>Get</code>. Esta preferencia por razones de brevedad se extiende a todos los metodos, no solo a los accesores de campo, y para otros prefijos redundantes, asi como <code>Fetch</code>, <code>Find</code>, y <code>Lookup</code>.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">log</span>

<span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">flags</span>  <span class="kt">int</span>
  <span class="nx">prefix</span> <span class="kt">string</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Flags</span><span class="p">()</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetFlags</span><span class="p">(</span><span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Prefix</span><span class="p">()</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">SetPrefix</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">)</span>
</pre></div>
<p>El stilo de Go no prohibe exportar los campos. Por supuesto, una vez exportado, un campo no puede ser exportado sin un cambio incompatible a la API, por lo que la eleccion inicial debe ser deliberada y debe considerar la complejidad de los invariantes que deben mantenerse, la probabilidad de cambios futuros y la cantidad del codigo cliente que se veria afectado por un cambio.</p>
<p>La encapsulacion no siempre es deseable. Al revelar su representacion como un numero <code>int64</code> de nanosegundos, <code>time.Duration</code> nos permite usar todas las operaciones aritmeticas y de comparacion con duraciones habituales, e incluso para definir constantes de este tipo:</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">day</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">day</span><span class="p">.</span><span class="nx">Seconds</span><span class="p">())</span> <span class="c1">// &quot;86400&quot;</span>
</pre></div>
<p>Como otro ejemplo, contraste <code>IntSet</code> con el tipo <code>geometry.Path</code> al principio de este capitulo. <code>Path</code> se definio como un tipo de slice, permitiendo a sus clientes construir instancias utilizando la sintaxis literal de slice, para iterar sobre sus puntos usando un bucle de rango, y asi sucesivamente, mientras que estas operaciones se le niegan a los clientes de <code>IntSet</code>.</p>
<p>Esta es la diferencia fundamental: <code>geometry.Path</code> es intrinsecamente una secuencia de puntos, ni mas ni menos, y no prevemos la adicion de nuevos campos a la misma, asi que tiene sentido para el paquete <code>geometry</code> revelar que <code>Path</code> es un slice. En contraste, un <code>IntSet</code> simplemente pasa a ser representado como un slice <code>[]uint64</code>. Podria haber sido representado mediante <code>[]uint</code>, o algo completamente diferente para los conjuntos que son escasos o muy pequeños, y que tal vez podrian beneficiarse de caracteristicas adicionales como un campo adicional para registrar el numero de elementos en el conjunto. Por estas razones, tiene sentido que <code>IntSet</code> sea opaco.</p>
<p>En este capitulo, aprendimos como asociar metodos con tipos con nombre y como llamar a esos metodos. Aunque los metodos son cruciales para la programacion orientada a objetos, son solo la mitad de la imagen. Para completarla, necesitamos <em>interfaces</em>, el tema del proximo capitulo.</p>
</div>
<h2 id="Capitulo-7" >Interfaces</h2>
<div class="hBody-2" >
<p>Los tipos de interfaz expresan generalizaciones o abstracciones sobre los comportamientos de otros tipos. Al generalizar, las interfaces nos permiten escribir funciones que son mas flexibles y adaptables porque no estan vinculadas a los detalles de una implementacion en particular.</p>
<p>Muchos lenguajes orientados a objetos tienen alguna nocion de interfaces, pero lo que hace las interfaces de Go sean tan distintivas es que se <em>satisfacen de manera implicita</em>. En otras palabras, no hay necesidad de declarar todas las interfaces que satisface un tipo determinado en concreto; Basta con poseer los metodos necesarios. Este diseño le permite crear nuevas interfaces que sean satisfechas por tipos concretos existentes sin cambiar los tipos existentes, lo cual es particularmente util para tipos definidos en paquetes que no controla.</p>
<p>En este capitulo, comenzaremos examinando la mecanica basica de los tipos de interfaz y sus valores. En el camino, estudiaremos varias interfaces importantes de la libreria estandar. Muchos programas Go hacen uso intensivo de interfaces estandar como lo hacen con sus propios. Por ultimo, examinaremos los <em>tipos de aserciones</em> (<a href="#Seccion-7.10" >§7.10</a>) y <em>switches de tipo</em> (<a href="#Seccion-7.13" >§7.13</a>) y veremos como permiten un tipo diferente de generalidad.</p>
</div>
<h3 id="Seccion-7.1" >Interfaces como Contratos</h3>
<div class="hBody-3" >
<p>Todos los tipos que hemos visto hasta ahora han sido <em>tipos concretos</em>. Un tipo concreto especifica la representacion exacta de sus valores y expone las operaciones intrinsecas de esa representacion, como la aritmetica para numeros, o indexacion, <code>append</code>, y <code>range</code> para slices. Un tipo concreto tambien puede proporcionar comportamientos adicionales a traves de sus metodos. Cuando se tiene un valor de un tipo concreto, usted sabe exactamente lo que es y lo que puede hacer con el.</p>
<p>Hay otro tipo en Go llama un <em>tipo de interfaz</em>. Una interfaz es un tipo abstracto. No expone la representacion o estructura interna de sus valores, ni el conjunto de operaciones basicas que soporta; Revela solo algunos de sus metodos. Cuando se tiene un valor de un tipo interfaz, que no saben nada de lo que es; solo se sabe lo que puede hacer, o mas exactamente, que comportamientos son proporcionados por sus metodos.</p>
<p>A lo largo del libro, hemos estado utilizando dos funciones similares para el formateo de cadenas: <code>fmt.Printf</code>, que escribe el resultado a la salida estandar (un archivo), y <code>fmt.Sprintf</code>, que devuelve el resultado como un <code>string</code>. Seria lamentable que la parte dificil, el formato del resultado, tuviera que ser duplicado debido a estas diferencias superficiales en la forma en que el resultado se utiliza. Gracias a las interfaces, no lo hace. Ambas funciones son, en efecto, envolturas alrededor de una tercer funcion, <code>fmt.Fprintf</code>, que es agnostico acerca de lo que ocurre con el resultado que calcula:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>El prefijo <code>F</code> de <code>Fprintf</code> significa <em>file</em> (archivo) e indica que la salida formateada se debe escribir en el fichero proporcionado como primer argumento. En el caso de <code>Printf</code>, el argumento, <code>os.Stdout</code>, es un <code>*os.File</code>. En el caso <code>Sprintf</code>, sin embargo, el argumento no es un archivo, aunque se asemeja superficialmente a uno: <code>&amp;buf</code> es un puntero a un bufer de memoria a la que se pueden escribir bytes.</p>
<p>El primer parametro de <code>Fprintf</code> no es un archivo cualquiera. Es un <code>io.Writer</code>, que es un tipo de interfaz con la siguiente declaracion:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">io</span>

<span class="c1">// Writer es la interfaz que envuelve el metodo de escritura basico.</span>
<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// Write escribe len(p) bytes de p en el flujo de datos subyacentes.</span>
  <span class="c1">// Devuelve el numero de bytes escritos de p (0 &lt;= n &lt;= len(p))</span>
  <span class="c1">// y cualquier error encontrado que causo un paro temprano en la escritura.</span>
  <span class="c1">// Write debe regresar un error no-nil si devulve n &lt; len(p).</span>
  <span class="c1">// Write no debe modificar los datol del slice, ni siquier temporalmente.</span>
  <span class="c1">//</span>
  <span class="c1">// Las imprementaciones no deben retener a p.</span>
  <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>La interfaz <code>io.Writer</code> define el contrato entre <code>Fprintf</code> y sus interlocutores. Por un lado, el contrato requiere que el llamador proporcione un valor de un tipo concreto como <code>*os.File</code> o <code>*bytes.Buffer</code> que tiene un metodo denominado <code>Write</code> con la firma y el comportamiento apropiado. Por otra parte, el contrato garantiza que <code>Fprintf</code> hara su trabajo dando cualquier valor que satisfaga la interfaz <code>io.Writer</code>. <code>Fprintf</code> no puede asumir que se esta escribiendo en un archivo o en la memoria, solo que se puede llamar a <code>Write</code>.</p>
<p>Ya que <code>fmt.Fprintf</code> no asume nada acerca de la representacion del valor y se basa unicamente en los comportamientos garantizados por el contrato <code>io.Writer</code>, podemos pasar con seguridad un valor concreto de cualquier tipo que satisfaga <code>io.Writer</code> como primer argumento de <code>fmt.Fprintf</code>. Esta libertad para sustituir un tipo por otro que satisface la misma interfaz se denomina <em>sustituibilidad</em>, y es una caracteristica de la programacion orientada a objetos.</p>
<p>Vamos a probar esto usando un nuevo tipo. A continuacion el metodo <code>Write</code> del tipo <code>*ByteCounter</code> simplemente cuenta los bytes escritos antes de descartarlos. (La conversion se requiere para hacer que los tipos de <code>len(p)</code> y <code>*c</code> coincidan en la sentencia de asignacion <code>+=</code>.)</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/bytecounter/main.go" >gopl.io/ch7/bytecounter</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ByteCounter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ByteCounter</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">c</span> <span class="o">+=</span> <span class="nx">ByteCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="c1">// convert int to ByteCounter</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Puesto que <code>*ByteCounter</code> satisface el contrato <code>io.Writer</code>, podemos pasarlo a <code>Fprintf</code>, que hace su formato de cadenas ajeno a este cambio; <code>ByteCounter</code> acumula correctamente la longitud del resultado.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">c</span> <span class="nx">ByteCounter</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;5&quot;, = len(&quot;hello&quot;)</span>

<span class="nx">c</span> <span class="p">=</span> <span class="mi">0</span>          <span class="c1">// reinicia el contador</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="p">=</span> <span class="s">&quot;Dolly&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;hello, %s&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span>
</pre></div>
<p>Ademas de <code>io.Writer</code>, hay otra interfaz de gran importancia para el paquete <code>fmt</code>. <code>Fprintf</code> y <code>Fprintln</code> proporcionan una forma para que los tipos controles como se imprimen sus valores. En la <a href="#Seccion-2.5" >Seccion 2.5</a>, definimos un metodo <code>String</code> para el tipo <code>Celsius</code> de modo que las temperaturas se impriman como <code>&quot;100°C&quot;</code>, y en la <a href="#Seccion-6.5" >Seccion 6.5</a> hemos equipado a <code>*IntSet</code> con un metodo <code>String</code> de modo que los conjuntos fueran renderizados utilizando la notacion de conjuntos tradicional como <code>&quot;{1 2 3}&quot;</code>. La declaracion de un metodo <code>String</code> hace que un tipo satisfaga una de las interfaces mas utilizados de todas, <code>fmt.Stringer</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// El metodo String se utiliza para imprimr los valores recividos</span>
<span class="c1">// como un operando de cualquier formato que acepte una cadena</span>
<span class="c1">// o una impresion sin formato como Print.</span>
<span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
<p>Vamos a explicar como el paquete <code>fmt</code> descubre que valores satisfacen esta interfaz en la <a href="#Seccion-7.10" >Seccion 7.10</a>.</p>
<p><b>Ejercicio 7.1</b>: Haciendo uso de las ideas de <code>ByteCounter</code>, implementar contadores para lineas y palabras. Puedes encontrar util <code>bufio.ScanWords</code>.</p>
<p><b>Ejercicio 7.2</b>: Escribir una funcion <code>CountingWriter</code> con la firma de abajo que, pasando un <code>io.Writer</code>, devuelva un nuevo <code>Writer</code> que envuelva el original, y un puntero a una variable <code>int64</code> que contenga en cualquier momento el numero de bytes escritos en el nuevo <code>Writer</code> .</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">CountingWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span>
</pre></div>
<p><b>Ejercicio 7.3</b>: Escribir un metodo <code>String</code> para el tipo <code>*tree</code> de <code>gopl.io/ch4/treesort</code> (<a href="#Seccion-4.4" >§4.4</a>) que revela la secuencia de valores en el arbol.</p>
</div>
<h3 id="Seccion-7.2" >Tipos de Interfaz</h3>
<div class="hBody-3" >
<p>Un tipo de interfaz especifica un conjunto de metodos que un tipo de concreto debe poseer para ser considerado una instancia de esa interfaz.</p>
<p>El tipo <code>io.Writer</code> es una de las interfaces mas utilizados, ya que proporciona una abstraccion de todos los tipos a los que se pueden escribir bytes, que incluye archivos, buffers de memoria, conexiones de red, clientes HTTP, archivadores, hashers, etc. El paquete <code>io</code> define muchas otras interfaces utiles. Un <code>Reader</code> representa cualquier tipo del que se puede leer bytes, y un <code>Closer</code> es cualquier valor que se puede cerrar, como un archivo o una conexion de red. (Por ahora probablemente has notado la convencion de nomenclatura para muchas de las interfaces de metodo unico de Go).</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">io</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>
<p>Mirando mas lejos, encontramos declaraciones de nuevos tipos de interfaz como combinaciones de los ya existentes. He aqui dos ejemplos:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Reader</span>
  <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Reader</span>
  <span class="nx">Writer</span>
  <span class="nx">Closer</span>
<span class="p">}</span>
</pre></div>
<p>La sintaxis utilizada, se asemeja al enbebido de estructuras, nos permite nombrar otra interfaz como una abreviatura para escribir todos sus metodos. Esto se conoce denomina como <em>embeber</em> una interfaz. Podriamos haber escrito <code>io.ReadWriter</code> sin enbeberla, aunque de manera menos sucinta, como aqui:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>o incluso utilizando una mezcla de los dos estilos:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>
<p>Las tres declaraciones tienen el mismo efecto. El orden en que aparecen los metodos es irrelevante. Todo lo que importa es el conjunto de metodos.</p>
<p><b>Ejercicio 7.4</b>: La funcion <code>strings.NewReader</code> devuelve un valor que satisface la interfaz <code>io.Reader</code> (y otras) mediante la lectura de su argumento, una cadena. Implementa tu mismo una version simple de <code>NewReader</code>, y utilizala para hacer que el analizador de HTML (<a href="#Seccion-5.2" >§5.2</a>) tome la entrada de una cadena.</p>
<p><b>Ejercicio 7.5</b>: La funcion <code>LimitReader</code> en el paquete <code>io</code> acepta un <code>io.Reader</code> <code>r</code> y un numero de bytes <code>n</code>, y devuelve otro <code>Reader</code> que lee desde <code>r</code> pero reporta una condicion de fin de archivo despues de <code>n</code> bytes. Implementalo.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">LimitReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
</pre></div>
</div>
<h3 id="Seccion-7.3" >Satisfaccion de la Interfaz</h3>
<div class="hBody-3" >
<p>Un tipo satisface una interfaz si posee todos los metodos que la interfaz requiere. Por ejemplo, un <code>*os.File</code> satisface <code>io.Reader</code>, <code>Writer</code>, <code>Closer</code>, y <code>ReadWriter</code>. Un <code>*bytes.Buffer</code> satisface <code>Reader</code>, <code>Writer</code>, y <code>ReadWriter</code>, pero no satisfacer <code>Closer</code>, ya que no tiene un metodo <code>Close</code>. Como una abreviatura, los programadores de Go a menudo dicen que un tipo concreto <q>es un</q> tipo de interfaz en particular, lo que significa que satisface la interfaz. Por ejemplo, un <code>*bytes.Buffer</code> es un <code>io.Writer</code>; un <code>*os.File</code> es un <code>io.ReadWriter</code>.</p>
<p>La regla de asignabilidad (<a href="#Seccion-2.4.2" >§2.4.2</a>) para interfaces es muy simple: una expresion puede ser asignada a una interfaz solo si su tipo se ajusta a la interfaz. Asi que:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>           <span class="c1">// OK: *os.File tiene metodo Write</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>   <span class="c1">// OK: *bytes.Buffer tiene metodo Write</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>         <span class="c1">// error de compilacion: time.Duration carece de metodo Write</span>

<span class="kd">var</span> <span class="nx">rwc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriteCloser</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>         <span class="c1">// OK: *os.File tiene metodos Read, Write, Close</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// error de compilacion: *bytes.Buffer carece de metodo Close</span>
</pre></div>
<p>Esta regla se aplica incluso cuando el lado derecho es en si mismo una interfaz:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">rwc</span>                 <span class="c1">// OK: io.ReadWriteCloser tiene metodo Write</span>
<span class="nx">rwc</span> <span class="p">=</span> <span class="nx">w</span>                 <span class="c1">// error de compilacion: io.Writer carece de metodo Close</span>
</pre></div>
<p>Como <code>ReadWriter</code> y <code>ReadWriteCloser</code> incluyen todos los metodos de <code>Writer</code>, cualquier tipo que satisface <code>ReadWriter</code> o <code>ReadWriteCloser</code> satisface <code>Writer</code> necesariamente.</p>
<p>Antes de ir mas lejos, debemos explicar una sutileza en lo que significa para un tipo tener un metodo. Recuerde de la <a href="#Seccion-6.2" >Seccion 6.2</a> que para cada tipo concreto llamado <code>T</code>, algunos de sus metodos tienen un receptor de tipo <code>T</code>, mientras que otros requieren un puntero <code>*T</code>. Recordemos tambien que es legal para llamar a un metodo <code>*T</code> en un argumento de tipo <code>T</code>, siempre y cuando el argumento sea una variable; El compilador toma implicitamente su direccion. Pero esto es mero azucar sintactico: un valor de tipo <code>T</code> no posee todos los metodos que tiene un puntero <code>*T</code>, y como resultado podria satisfacer menos interfaces.</p>
<p>Un ejemplo lo hara claro. El metodo <code>String</code> del tipo <code>IntSet</code> de la <a href="#Seccion-6.5" >Seccion 6.5</a> requiere un receptor puntero, asi que no podemos llamar a ese metodo en un valor <code>IntSet</code> no direccionable:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntSet</span> <span class="kd">struct</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">IntSet</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">IntSet</span><span class="p">{}.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// error de compilacion: String requiere un receptor *intSet</span>
</pre></div>
<p>pero podemos decir que es una variables <code>IntSet</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="nx">IntSet</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// OK: s es una variable y &amp;s tiene el metodo String</span>
</pre></div>
<p>Sin embargo, puesto que solamente <code>*IntSet</code> tiene un metodo <code>String</code>, solamente <code>*IntSet</code> satisface la interfaz <code>fmt.Stringer</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">s</span> <span class="c1">// OK</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span> <span class="p">=</span> <span class="nx">s</span>  <span class="c1">// error de compilacion: IntSet carece de metodo String</span>
</pre></div>
<p>La <a href="#Seccion-12.8" >Seccion 12.8</a> incluye un programa que imprime los metodos de un valor arbitrario, y la herramienta <code class="command" >godoc -analysis=type</code> (<a href="#Seccion-10.7.4" >§10.7.4</a>) muestra los metodos de cada tipo y la relacion entre las interfaces y tipos concretos.</p>
<p>Como un sobre que envuelve y oculta la carta que contiene, una interfaz envuelve y oculta el tipo concreto y el valor que contiene. Solo los metodos revelados por el tipo de interfaz pueden ser llamados, incluso si el tipo concreto tiene otros:</p>
<div class="highlight"><pre><span></span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: *os.File tiene el metodo Write</span>
<span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// OK: *os.File tiene el metodo Close</span>

<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK: io.Writer tiene el metodo Write</span>
<span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>                <span class="c1">// compile error: io.Writer carece del metodo Close</span>
</pre></div>
<p>Una interfaz con mas metodos, como <code>io.ReadWriter</code>, nos dice mas acerca de los valores que contiene, y coloca mayores demandas sobre los tipos que la implementan, que un interfaz con un menos metodos como <code>io.Reader</code>. Entonces, que hace el tipo <code>interface{}</code>, que no tiene ningun metodo en absoluto, nos cuenta sobre los tipos concretos que lo satisfacen?</p>
<p>Eso es correcto: nada. Esto puede parecer inutil, pero en realidad el tipo <code>interface{}</code>, que se denomina el tipo de <em>interfaz vacia</em>, es indispensable. Debido a que el tipo de interfaz vacia no impone exigencias a los tipos que lo satisfacen, podemos asignar <em>cualquier</em> valor a la interfaz vacia.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">any</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">any</span> <span class="p">=</span> <span class="mf">12.34</span>
<span class="nx">any</span> <span class="p">=</span> <span class="s">&quot;hello&quot;</span>
<span class="nx">any</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">any</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>
<p>A pesar de que no ser obvio, hemos utilizando el tipo de interfaz vacia desde el primer ejemplo en este libro, porque es lo que permite que funciones como <code>fmt.Println</code>, o <code>errorf</code> en la <a href="#Seccion-5.7" >Seccion 5.7</a>, acepten argumentos de cualquier tipo.</p>
<p>Por supuesto, despues de crear un valor <code>interface{}</code> que contiene un valor booleano, float, string, mapa, puntero, o de cualquier otro tipo, no podemos hacer nada directamente con el valor que posee ya que la interfaz no tiene metodos. Necesitamos una forma de recuperar el valor nuevamente. Veremos como hacerlo utilizando un <em>tipo de asercion</em> en la <a href="#Seccion-7.10" >Seccion 7.10</a>.</p>
<p>Dado que la satisfaccion de la interfaz depende solo de los metodos de los dos tipos implicados, no hay necesidad de declarar la relacion entre un tipo concreto y las interfaces que satisface. Dicho esto, ocasionalmente es util documentar y afirmar la relacion cuando se pretende, pero no se aplica de otro modo por el programa. La declaracion a continuacion afirma en tiempo de compilacion que un valor de tipo <code>*bytes.Buffer</code> satisface <code>io.Writer</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// *bytes.Buffer debe satirfacer io.Writer</span>
<span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>
<p>No tenemos que asignar una nueva variable, ya que cualquier valor de tipo <code>*bytes.Buffer</code> lo hara, incluso <code>nil</code>, que escribimos como <code>(*bytes.Buffer)(nil)</code> mediante una conversion explicita. Y ya que nunca intentamos referirnos a <code>w</code>, podemos sustituirlo por el identificador en blanco. Juntos, estos cambios nos dan esta variante mas frugal:</p>
<div class="highlight"><pre><span></span><span class="c1">// *bytes.Buffer debe satisfacer io.Writer</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</pre></div>
<p>Los tipos de interfaces no-vacios como io.Writer suelen ser satisfechos por un tipo de puntero, sobre todo cuando uno o mas de los metodos de interfaz implica algun tipo de mutacion en el receptor, como la hace el metodo <code>Write</code>. Un puntero a una estructura es un tipo de metodo especialmente comun.</p>
<p>Pero los tipos de puntero no son de ninguna manera los unicos tipos que satisfacen las interfaces, e incluso las interfaces con los metodos mutator pueden ser satisfechas por uno de los otros tipos de referencia de Go. Hemos visto ejemplos de tipos de slice con metodos (<code>geometry.Path</code>, <a href="#Seccion-6.1" >§6.1</a>) y tipos de mapas con metodos (<code>url.Values</code>, <a href="#Seccion-6.2.1" >§6.2.1</a>), y mas adelante veremos un tipo de funcion con metodos (<code>http.HandlerFunc</code>, <a href="#Seccion-7.7" >§7.7</a>). Incluso los tipos basicos pueden satisfacer interfaces; como vimos en la <a href="#Seccion-7.4" >Seccion 7.4</a>, <code>time.Duration</code> satisface <code>fmt.Stringer</code>.</p>
<p>Un tipo concreto puede satisfacer muchas interfaces no relacionadas. Considere un programa que organiza o vende artefactos culturales digitalizados como musica, peliculas y libros. Podria definir el siguiente conjunto de tipos concretos:</p>
<pre class="pre" >Album
Book
Movie
Magazine
Podcast
TVEpisode
Track</pre>
<p>Podemos expresar cada abstraccion de interes como una interfaz. Algunas propiedades son comunes a todos los artefactos, como un titulo, una fecha de creacion y una lista de creadores (autores o artistas).</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Artifact</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Title</span><span class="p">()</span> <span class="kt">string</span>
  <span class="nx">Creators</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">Created</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</pre></div>
<p>Otras propiedades estan restringidas a ciertos tipos de artefactos. Las propiedades de <code>printed_word</code> solo son relevantes para libros y revistas, mientras que solo las peliculas y episodios de television tienen una resolucion de pantalla.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Text</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Pages</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">Words</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">PageSize</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Audio</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Video</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span> <span class="c1">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span>
  <span class="nx">Resolution</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Estas interfaces no son sino una forma util de agrupar tipos concretos relacionados y expresar las facetas que comparten en comun. Podemos descubrir otras agrupaciones mas tarde. Por ejemplo, si descubrimos que necesitamos manejar elementos de <code>Audio</code> y <code>Video</code> de la misma manera, podemos definir una interfaz <code>Streamer</code> para representar sus aspectos comunes sin cambiar ninguna declaracion de tipos existentes.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Streamer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Stream</span><span class="p">()</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
  <span class="nx">RunningTime</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
  <span class="nx">Format</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
<p>Cada agrupacion de tipos concretos basados ​​en sus comportamientos compartidos puede expresarse como un tipo de interfaz. A diferencia de los lenguajes basados ​​en clases, en los que el conjunto de interfaces satisfecho por una clase es explicito, en Go podemos definir nuevas abstracciones o agrupaciones de interes cuando las necesitamos, sin modificar la declaracion del tipo concreto. Esto es particularmente util cuando el tipo concreto proviene de un paquete escrito por un autor diferente. Por supuesto, es necesario que haya puntos comunes subyacentes en los tipos concretos.</p>
</div>
<h3 id="Seccion-7.4" >Analizar Banderas con <code>flag.Value</code></h3>
<div class="hBody-3" >
<p>En esta seccion, vamos a ver como otro interfaz estandar, <code>flag.Value</code>, nos ayuda a definir nuevas notaciones de opciones de linea de comandos. Considere el programa a continuacion, que duerme durante un periodo de tiempo especificado.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/sleep/sleep.go" >gopl.io/ch7/sleep</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">period</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="s">&quot;period&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="s">&quot;sleep period&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Sleeping for %v...&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">period</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="o">*</span><span class="nx">period</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Antes de que se vaya a dormir imprime el periodo de tiempo. El paquete <code>fmt</code> llama al metodo <code>String</code> de <code>time.Duration</code> para imprimir el periodo no como un numero de nanosegundos, sino en una notacion facil de usar:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch7/sleep
$ ./sleep
Sleeping <span class="k">for</span> 1s...
</pre></div>
<p>Por defecto, el periodo de sueño es de un segundo, pero se puede controlar a traves de la bandera de linea de comandos <code>-period</code>. La funcion <code>flag.Duration</code> crea una variable de tipo bandera <code>time.Duration</code> y permite al usuario especificar la duracion en una variedad de formatos faciles de usar, incluyendo la misma notacion que imprime el metodo <code>String</code>. Esta simetria de diseño conduce a una interfaz de usuario agradable.</p>
<div class="highlight"><pre><span></span>$ ./sleep -period 50ms
Sleeping <span class="k">for</span> 50ms...
$ ./sleep -period 2m30s
Sleeping <span class="k">for</span> 2m30s...
$ ./sleep -period <span class="m">1</span>.5h
Sleeping <span class="k">for</span> 1h30m0s...
$ ./sleep -period <span class="s2">&quot;1 day&quot;</span>
invalid value <span class="s2">&quot;1 day&quot;</span> <span class="k">for</span> flag -period: time: invalid duration <span class="m">1</span> day
</pre></div>
<p>Debido a que las banderas de valor de duracion son tan utiles, esta caracteristica esta integrada en el paquete <code>flag</code>, pero es facil de definir nuevas notaciones bandera para nuestros propios tipos de datos. Solo necesitamos definir un tipo que satisfaga la interfaz <code>flag.Value</code>, cuya declaracion es la siguiente:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">flag</span>

<span class="c1">// Value es la interfaz con el valor almacenado en un indicador.</span>
<span class="kd">type</span> <span class="nx">Value</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>
<p>El metodo <code>String</code> formatea el valor de la bandera para su uso en los mensajes de ayuda de linea de comandos; Asi, cada <code>flag.Value</code> es tambien un <code>fmt.Stringer</code>. El metodo <code>Set</code> analiza su argumento de cadena y actualiza el valor del indicador. En efecto, el metodo <code>Set</code> es el inverso del metodo <code>String</code>, y es una buena practica para que puedan utilizar la misma notacion.</p>
<p>Vamos a definir un tipo <code>celsiusFlag</code> que permite una temperatura que se especifica en <code>Celsius</code> o en <code>Fahrenheit</code> con una conversion apropiada. Observe que <code>celsiusFlag</code> incorpora un<code>Celsius</code> (<a href="#Seccion-2.5" >§2.5</a>), consiguiendo asi un metodo <code>String</code> de forma gratuita. Para satisfacer <code>flag.Value</code>, solo tenemos que declarar el metodo <code>Set</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/tempconv/tempconv.go" >gopl.io/ch7/tempconv</a></p>
<div class="highlight"><pre><span></span><span class="c1">// *celsiusFlag satisface la interfaz flag.Value.</span>
<span class="kd">type</span> <span class="nx">celsiusFlag</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Celsius</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">celsiusFlag</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">unit</span> <span class="kt">string</span>
  <span class="kd">var</span> <span class="nx">value</span> <span class="kt">float64</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sscanf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot;%f%s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">unit</span><span class="p">)</span> <span class="c1">// no es necesario comprobar el error</span>
  <span class="k">switch</span> <span class="nx">unit</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="s">&quot;°C&quot;</span><span class="p">:</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="k">case</span> <span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;°F&quot;</span><span class="p">:</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span> <span class="p">=</span> <span class="nx">FToC</span><span class="p">(</span><span class="nx">Fahrenheit</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid temperature %q&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La llamada a <code>fmt.Sscanf</code> analiza un numero de coma flotante (<code>value</code>) y una cadena (<code>unit</code>) de la entrada <code>s</code>. Aunque por lo general se debe comprobar el resultado error de <code>Sscanf</code>, en este caso, no lo necesitamos porque si habia un problema, ningun caso coincidira con el <code>swich</code>.</p>
<p>La funcion <code>CelsiusFlag</code> a continuacion de lo envuelve todo. Al llamador, devuelve un puntero al campo <code>Celsius</code> enbebido dentro de la variable <code>f</code> de <code>celsiusFlag</code>. El campo <code>Celsius</code> es la variable que sera actualizada por el metodo <code>Set</code> durante el procesamiento de banderas. La llamada a <code>Var</code> agrega la bandera al conjunto de banderas de linea de comando, la variable global <code>flag.CommandLine</code>. Los programas con interfaces de linea de comandos inusualmente complejos pueden tener varias variables de este tipo. La llamada a <code>Var</code> asigna un argumento <code>*celsiusFlag</code> a un parametro <code>flag.Value</code>, haciendo que el compilador compruebe que <code>*celsiusFlag</code> tiene los metodos necesarios.</p>
<div class="highlight"><pre><span></span><span class="c1">// CelsiusFlag define una bandera Celsius con el nombre especificado,</span>
<span class="c1">// valor predeterminado, y uso, y devuelve la direccion de la variable flag.</span>
<span class="c1">// El argumento flag debe tener una cantidad y una unidad, por ejemplo, &quot;100C&quot;.</span>
<span class="kd">func</span> <span class="nx">CelsiusFlag</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">Celsius</span><span class="p">,</span> <span class="nx">usage</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Celsius</span> <span class="p">{</span>
  <span class="nx">f</span> <span class="o">:=</span> <span class="nx">celsiusFlag</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">CommandLine</span><span class="p">.</span><span class="nx">Var</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">usage</span><span class="p">)</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">f</span><span class="p">.</span><span class="nx">Celsius</span>
<span class="p">}</span>
</pre></div>
<p>Ahora podemos empezar a usar la nueva bandera en nuestros programas:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/tempflag/tempflag.go" >gopl.io/ch7/tempflag</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">temp</span> <span class="p">=</span> <span class="nx">tempconv</span><span class="p">.</span><span class="nx">CelsiusFlag</span><span class="p">(</span><span class="s">&quot;temp&quot;</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="s">&quot;the temperature&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">temp</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aqui hay una sesion tipica:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch7/tempflag
$ ./tempflag
<span class="m">20</span>°C
$ ./tempflag -temp -18C
-18°C
$ ./tempflag -temp <span class="m">212</span>°F
<span class="m">100</span>°C
$ ./tempflag -temp <span class="m">273</span>.15K
invalid value <span class="s2">&quot;273.15K&quot;</span> <span class="k">for</span> flag -temp: invalid temperature <span class="s2">&quot;273.15K&quot;</span>
Usage of ./tempflag:
  -temp value
        the temperature <span class="o">(</span>default <span class="m">20</span>°C<span class="o">)</span>
$ ./tempflag -help
Usage of ./tempflag:
  -temp value
        the temperature <span class="o">(</span>default <span class="m">20</span>°C<span class="o">)</span>
</pre></div>
<p><b>Ejercicio 7.6</b>: Añadir soporte para temperaturas Kelvin a <code>tempflag</code>.</p>
<p><b>Ejercicio 7.7</b>: Explicar por que el mensaje de ayuda contiene <code>°C</code> cuando el valor por defecto de <code>20.0</code> no.</p>
</div>
<h3 id="Seccion-7.5" >Valores de Interfaz</h3>
<div class="hBody-3" >
<p>Conceptualmente, un valor de un tipo de interfaz, o el valor de la interfaz, tiene dos componentes, un tipo concreto y un valor de ese tipo. Estos se llaman <em>tipo dinamico</em> de la interfaz y el <em>valor dinamico</em>.</p>
<p>Para un lenguaje de tipo estatico como Go, los tipos son un concepto de compilacion, por lo que un tipo no es un valor. En nuestro modelo conceptual, un conjunto de valores denominados <em>descriptores de tipo</em> proporcionan informacion sobre cada tipo, como su nombre y metodos. En un valor de interfaz, el componente de tipo esta representado por el descriptor de tipo apropiado.</p>
<p>En las siguientes cuatro declaraciones, la variable <code>w</code> toma tres valores diferentes. (Los valores inicial y final son los mismos.)</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</pre></div>
<p>Echemos un vistazo mas de cerca el valor y el comportamiento dinamico de <code>w</code> despues de cada declaracion. La primera sentencia declara a <code>w</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
</pre></div>
<p>En Go, las variables siempre se inicializan en un valor bien definido, y las interfaces no son la excepcion. El valor cero para una interfaz tiene ambos componentes de tipo y valor establecidos en <code>nil</code> (Figura 7.1).</p>
<div class="figure" >
<p class="title">Figura 7.1. Una interfaz de valor nil.</p>
<pre class="art" >       w
       ┏━━━━━━━━━━━━┓
 tipo  ┃    nil     ┃
       ┣━━━━━━━━━━━━┫
valor  ┃    nil     ┃
       ┗━━━━━━━━━━━━┛</pre>
</div>
<p>Un valor de interfaz se describe como <code>nil</code> o no <code>nil</code> basado en su tipo dinamico, por lo que este es un valor de interfaz nil. Puede probar si un valor de interfaz es nil usando <code>w == nil</code> o <code>w != nil</code>. Llamar a cualquier metodo de un valor de interfaz nil causa un panico:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// panico: desreferencia de puntero nil</span>
</pre></div>
<p>La segunda instruccion asigna un valor de tipo <code>*os.File</code> a <code>w</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
</pre></div>
<p>Esta asignacion implica una conversion implicita de un tipo concreto para un tipo de interfaz, y es equivalente a la conversion explicita <code>io.Writer(os.Stdout)</code>. Una conversion de este tipo, ya sea explicita o implicita, captura el tipo y el valor de su operando. Tipo dinamico del valor de la interfaz se establece en el descriptor de tipo para el tipo de puntero <code>*os.File</code>, y su valor dinamico contiene una copia de <code>os.Stdout</code>, que es un puntero a la variable <code>os.File</code> que representa la salida estandar del proceso (Figura 7.2).</p>
<div class="figure" >
<p class="title">Figura 7.2. Un valor de interfaz contiene un puntero <code>*os.File</code>.</p>
<figure>
<img src="img/Figure-7.2.jpg" />
</figure>
</div>
<p>Llamar al metodo <code>Write</code> en un valor de interfaz que contiene un puntero <code>*os.File</code> hace que se llama al metodo <code>(*os.File).Write</code>. La llamada imprime <code>&quot;hello&quot;</code>.</p>
<div class="highlight"><pre><span></span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>
<p>En general, no podemos saber en tiempo de compilacion cual sera el tipo dinamico de un valor interfaz, por lo que una llamada a traves de una interfaz debe utilizar el <em>envio dinamico</em>. En lugar de una llamada directa, el compilador debe generar codigo para obtener la direccion del metodo con nombre <code>Write</code> desde el descriptor de tipos, y luego, realizar una llamada indirecta a esa direccion. El argumento del receptor de la llamada es una copia del valor dinamico de la interfaz, <code>os.Stdout</code>. El efecto es como si hubieramos hecho esta llamada directamente:</p>
<div class="highlight"><pre><span></span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// &quot;hello&quot;</span>
</pre></div>
<p>La tercera instruccion asigna un valor de tipo <code>*bytes.Buffer</code> al valor de la interfaz:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
</pre></div>
<p>El tipo dinamico es ahora <code>*bytes.Buffer</code> y el valor dinamico es un puntero a al buffer recien asignado (Figura 7.3).</p>
<div class="figure" >
<p class="title">Figura 7.3. Un valor de interfaz que contiene un puntero <code>*bytes.Buffer</code>..</p>
<figure>
<img src="img/Figure-7.3.jpg" />
</figure>
</div>
<p>Una llamada al metodo <code>Write</code> utiliza el mismo mecanismo que antes:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// escribe &quot;hello&quot; en bytes.Buffer</span>
</pre></div>
<p>Esta vez, el tipo de descriptor es <code>*bytes.Buffer</code>, por lo que se llama al metodo <code>(*bytes.Buffer).Write</code> con la direccion del buffer como el valor del parametro de receptor. La llamada agrega <code>&quot;hello&quot;</code> al buffer.</p>
<p>Por ultimo, la cuarta instruccion asigna <code>nil</code> al valor de la interfaz:</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="kc">nil</span>
</pre></div>
<p>Esto restablece sus dos componentes a <code>nil</code>, restaurando <code>w</code> al mismo estado que cuando fue declarado, que se muestra en la Figura 7.1.</p>
<p>Un valor de interfaz puede contener valores dinamicos arbitrariamente grandes. Por ejemplo, el tipo <code>time.Time</code>, que representa un instante en el tiempo, es un tipo struct con varios campos no exportadas. Si creamos un valor de interfaz de ella,</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
</pre></div>
<p>El resultado podria ser similar al de la Figura 7.4. Conceptualmente, el valor dinamico siempre se ajusta dentro del valor de la interfaz, no importa cuan grande sea su tipo. (Esto es solo un modelo conceptual, una implementacion realista es muy diferente.)</p>
<div class="figure" >
<p class="title">Figura 7.4. Un valor de interfaz que contiene una estructura <code>time.Time</code>.</p>
<figure>
<img src="img/Figure-7.4.jpg" />
</figure>
</div>
<p>Los valores de interfaz se pueden comparar usando <code>==</code> y <code>!=</code>. Dos valores de la interfaz son iguales si ambos son nil, o si sus tipos dinamicos son identicos y sus valores dinamicos son iguales de acuerdo con el comportamiento usual de <code>==</code> para ese tipo. Dado que los valores de interfaz son comparables, pueden utilizarse como las claves de un mapa o como el operando de una instruccion <code>switch</code>.</p>
<p>Sin embargo, si se comparan dos valores de interfaz y tienen el mismo tipo dinamico, pero ese tipo no es comparable (por ejemplo, un slice), entonces la comparacion falla con un panico:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// panico: comparacion de tipo incompatible []int</span>
</pre></div>
<p>En este sentido, los tipos de interfaz son inusuales. Otros tipos son comparables de forma segura (como tipos basicos y punteros) o no son comparables en absoluto (como slices, mapas y funciones), pero cuando se comparan valores de interfaz o tipos agregados que contienen valores de interfaz, debemos estar conscientes del potencial de una panico. Un riesgo similar existe cuando se utilizan interfaces como claves de mapa u operandos de conmutador. Solo compare valores de interfaz si esta seguro de que contienen valores dinamicos de tipos comparables.</p>
<p>Cuando se manejan errores o durante la depuracion, a menudo es util informar el tipo dinamico de un valor de interfaz. Para ello, utilizamos el verbo <code>%T</code> del paquete <code>fmt</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;&lt;nil&gt;&quot;</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;*os.File&quot;</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span> <span class="c1">// &quot;*bytes.Buffer&quot;</span>
</pre></div>
<p>Internamente, <code>fmt</code> utiliza la reflexion para obtener el nombre del tipo dinamico de la interfaz. Veremos la reflexion en el <a href="#Capitulo-12" >Capitulo 12</a>.</p>
</div>
<h4 id="Seccion-7.5.1" >Advertencia: Una interfaz que Contiene un Puntero Nil es No-Nil</h4>
<div class="hBody-4" >
<p>Un valor de interfaz nil, que no contiene ningun valor, no es el mismo que un valor de interfaz que contiene un puntero que pasa a ser nil. Esta sutil distincion crea una trampa en la que cada programador de Go se ha tropezado.</p>
<p>Considere el programa a continuacion. Con <code>debug</code> establecido en <code>true</code>, la funcion <code>main</code> recoge la salida de la funcion <code>f</code> en un <code>bytes.Buffer</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">debug</span> <span class="p">=</span> <span class="kc">true</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
    <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// Habilitar la recopilacion de la salida</span>
  <span class="p">}</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>                    <span class="c1">// NOTA: sutilmente incorrecto!</span>
  <span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
    <span class="c1">// ...use buf...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Si out no es nil, la salida se escribe en este.</span>
<span class="kd">func</span> <span class="nx">f</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...hacer algo...</span>
  <span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;done!\n&quot;</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Podriamos esperar que el cambio de <code>debug</code> a <code>false</code> podria desactivar la recoleccion de la salida, pero en realidad hace que el programa entre en panico durante la llamada <code>out.Write</code>:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">out</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">out</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;done!\n&quot;</span><span class="p">))</span> <span class="c1">// panico: desreferencia de puntero nil</span>
<span class="p">}</span>
</pre></div>
<p>Cuando <code>main</code> llamada a <code>f</code>, asigna un puntero nil del tipo <code>*bytes.Buffer</code> al parametro <code>out</code>, por lo que el valor dinamico de <code>out</code> es <code>nil</code>. Sin embargo, su tipo dinamico es <code>*bytes.Buffer</code>, lo que significa que <code>out</code> es una interfaz no-nil que contiene un valor de puntero nulo (Figura 7.5), por lo que la comprobacion defensiva <code>out != nil</code> sigue siendo verdadero.</p>
<div class="figure" >
<p class="title">Figura 7.5. Una interfaz no-nil que contiene un puntero nil.</p>
<pre class="art" >      w
      ┏━━━━━━━━━━━━━━━━━┓
 type ┃  *bytes.Buffer  ┃
      ┣━━━━━━━━━━━━━━━━━┫
value ┃       nil       ┃
      ┗━━━━━━━━━━━━━━━━━┛</pre>
</div>
<p>Como antes, el mecanismo de envio dinamico determina que <code>(*bytes.Buffer).Write</code> debe ser llamado pero esta vez con un valor receptor que es nil. Para algunos tipos, como <code>*os.File</code>, nil es un receptor valido (<a href="#Seccion-6.2.1" >§6.2.1</a>), pero <code>*bytes.Buffer</code> no esta entre ellos. El metodo se llama, pero entra en panico al intentar acceder al bufer.</p>
<p>El problema es que aunque un puntero <code>*bytes.Buffer</code> nulo tiene los metodos necesarios para satisfacer la interfaz, no satisface los requisitos de comportamiento de la interfaz. En particular, la llamada viola la condicion implicita de <code>(*bytes.Buffer).Write</code> de que receptor no sea nil, por lo que la asignacion de puntero nulo a la interfaz fue un error. La solucion es cambiar el tipo de <code>buf</code> en <code>main</code> a <code>io.Writer</code>, evitando de ese modo la asignacion del valor disfuncional a la interfaz en el primer lugar:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">buf</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="k">if</span> <span class="nx">debug</span> <span class="p">{</span>
  <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// Habilitar la recopilacion de la salida</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="c1">// OK</span>
</pre></div>
<p>Ahora que hemos cubierto la mecanica de los valores de interfaz, echemos un vistazo a algunas de las interfaces mas importantes de la libreria estandar. En las tres siguientes secciones, veremos como se utilizan las interfaces para ordenacion, para servir en la web y gestionar errores.</p>
</div>
<h3 id="Seccion-7.6" >Ordenacion con <code>sort.Interface</code></h3>
<div class="hBody-3" >
<p>Al igual que el formateo de cadenas, la ordenacion es una operacion frecuentemente utilizada en muchos programas. Aunque un Quicksort minimo se puede escribir en unas 15 lineas, una implementacion robusta es mucho mas larga, y no es el tipo de codigo que deberiamos escribir de nuevo o copiar cada vez que lo necesitamos.</p>
<p>Afortunadamente, el paquete <code>sort</code> provee in situ la ordenacion de cualquier sequencia de acuerdo con cualquier funcion de ordenacion. Su diseño es bastante inusual. En muchos lenguajes, el algoritmo de ordenacion esta asociado con el tipo de datos de la secuencia, mientras que la funcion de ordenacion esta asociada con el tipo de los elementos. Por el contrario, la funcion <code>sort.Sort</code> de Go, no asume nada sobre de la representacion de la secuencia o de sus elementos. En su lugar, utiliza una interfaz, <code>sort.Interface</code>, para especificar el contrato entre el algoritmo de ordenacion generica y cada tipo de secuencia que puede ser ordenada. Una implementacion de esta interfaz determina tanto la representacion concreta de la secuencia, que es a menudo un slice, y el orden deseado de sus elementos.</p>
<p>Un algoritmo de ordenacion in situ necesita tres cosas–la longitud de la secuencia, una forma de comparar dos elementos, y una manera de intercambiar dos elementos–por lo que son los tres metodos de <code>sort.Interface</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">sort</span>

<span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="c1">// i, j son indices de la sequencia de elementos</span>
  <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Para ordenar cualquier secuencia, es necesario definir un tipo que implemente estos tres metodos, luego, aplicar <code>sort.Sort</code> a una instancia de ese tipo. Como quizas el ejemplo mas simple, considere clasificar un slice de cadenas. El nuevo tipo <code>StringSlice</code> y sus metodos <code>Len</code>, <code>Less</code>, y <code>Swap</code> se muestran a continuacion.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">StringSlice</span> <span class="p">[]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">StringSlice</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>Ahora podemos ordenar una slice de strings, <code>names</code>, convirtiendo el slice a un <code>StringSlice</code> como aqui:</p>
<div class="highlight"><pre><span></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">StringSlice</span><span class="p">(</span><span class="nx">names</span><span class="p">))</span>
</pre></div>
<p>La conversion produce un valor de slice con la misma longitud, capacidad, y arreglo subyacente como <code>names</code>, pero con un tipo que tiene los tres metodos necesarios para la clasificacion.</p>
<p>Ordenar un slice de strings es tan comun que el paquete sort proporciona el tipo <code>StringSlice</code>, asi como una funcion llamada <code>Strings</code> por lo que la llamada anterior se puede simplificar a <code>sort.Strings(names)</code>.</p>
<p>La tecnica aqui se adapta facilmente a otros ordenes de clasificacion, por ejemplo, para ignorar mayusculas o caracteres especiales. (El programa Go que ordena los terminos del indice y el numero de paginas de este libro hace esto, con una logica adicional para los numeros romanos.) Para una ordenacion mas complicada, usamos la misma idea, pero con estructuras de datos mas complicadas o implementaciones mas complicadas de los metodos <code>sort.Interface</code>.</p>
<p>Nuestro ejemplo de ejecucion para la clasificacion sera una lista de reproduccion de musica, mostrada como una tabla. Cada pista es una sola fila y cada columna es un atributo de esa pista, como artista, titulo y tiempo de ejecucion. Imagine que una interfaz grafica de usuario presenta la tabla y que al hacer clic en la cabecera de una columna, la lista de reproduccion se clasifica por ese atributo; Haciendo clic en la misma columna, vuelve a invertir el orden. Echemos un vistazo a lo que podria suceder en respuesta a cada clic.</p>
<p>La siguiente variable <code>tracks</code> contiene una lista de reproduccion. (Uno de los autores se disculpa por los gustos musicales del otro autor.) Cada elemento es indirecto, un puntero a un <code>Track</code>. Aunque el codigo de abajo funcionaria si almacenamos los <code>Tracks</code> directamente, la funcion de clasificacion intercambiara muchos pares de elementos, por lo que se ejecutara mas rapido si cada elemento es un puntero, que es una sola palabra de la maquina, en lugar de un <code>Track</code> completo, lo que podrian ser ocho o mas palabras.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/sorting/main.go" >gopl.io/ch7/sorting</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Track</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span>  <span class="kt">string</span>
  <span class="nx">Artist</span> <span class="kt">string</span>
  <span class="nx">Album</span>  <span class="kt">string</span>
  <span class="nx">Year</span>   <span class="kt">int</span>
  <span class="nx">Length</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">tracks</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">{</span>
  <span class="p">{</span><span class="s">&quot;Go&quot;</span><span class="p">,</span> <span class="s">&quot;Delilah&quot;</span><span class="p">,</span> <span class="s">&quot;From the Roots Up&quot;</span><span class="p">,</span> <span class="mi">2012</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;3m38s&quot;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&quot;Go&quot;</span><span class="p">,</span> <span class="s">&quot;Moby&quot;</span><span class="p">,</span> <span class="s">&quot;Moby&quot;</span><span class="p">,</span> <span class="mi">1992</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;3m37s&quot;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&quot;Go Ahead&quot;</span><span class="p">,</span> <span class="s">&quot;Alicia Keys&quot;</span><span class="p">,</span> <span class="s">&quot;As I Am&quot;</span><span class="p">,</span> <span class="mi">2007</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;4m36s&quot;</span><span class="p">)},</span>
  <span class="p">{</span><span class="s">&quot;Ready 2 Go&quot;</span><span class="p">,</span> <span class="s">&quot;Martin Solveig&quot;</span><span class="p">,</span> <span class="s">&quot;Smash&quot;</span><span class="p">,</span> <span class="mi">2011</span><span class="p">,</span> <span class="nx">length</span><span class="p">(</span><span class="s">&quot;4m24s&quot;</span><span class="p">)},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">length</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
  <span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">ParseDuration</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>printTracks</code> imprime la lista de reproduccion como una tabla. Una pantalla grafica seria mejor, pero esta pequeña rutina utiliza el paquete <code>text/tabwriter</code> para producir una tabla cuyas columnas estan perfectamente alineadas y rellenas, como se muestra a continuacion. Observe que <code>*tabwriter.Writer</code> satisface <code>io.Writer</code>. Recoge cada pieza de datos escrita en ella; su metodo <code>Flush</code> da formato a toda la tabla y lo escribe en <code>os.Stdout</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">printTracks</span><span class="p">(</span><span class="nx">tracks</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">format</span> <span class="p">=</span> <span class="s">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span>
  <span class="nx">tw</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">tabwriter</span><span class="p">.</span><span class="nx">Writer</span><span class="p">).</span><span class="nx">Init</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&quot;Title&quot;</span><span class="p">,</span> <span class="s">&quot;Artist&quot;</span><span class="p">,</span> <span class="s">&quot;Album&quot;</span><span class="p">,</span> <span class="s">&quot;Year&quot;</span><span class="p">,</span> <span class="s">&quot;Length&quot;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s">&quot;-----&quot;</span><span class="p">,</span> <span class="s">&quot;------&quot;</span><span class="p">,</span> <span class="s">&quot;-----&quot;</span><span class="p">,</span> <span class="s">&quot;----&quot;</span><span class="p">,</span> <span class="s">&quot;------&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tracks</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Title</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Artist</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Album</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Year</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">tw</span><span class="p">.</span><span class="nx">Flush</span><span class="p">()</span> <span class="c1">// calculate column widths and print table</span>
<span class="p">}</span>
</pre></div>
<p>Para ordenar la lista de reproduccion por el campo <code>Artist</code>, definimos un nuevo tipo de slice con los necesarios metodos <code>Len</code>, <code>Less</code>, y <code>Swap</code>, analogos a lo que hicimos para <code>StringSlice</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">byArtist</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Artist</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byArtist</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>Para llamar a la rutina de ordenacion generica, primero debemos convertir <code>tracks</code> al nuevo tipo, <code>byArtist</code>, que define el orden:</p>
<div class="highlight"><pre><span></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">))</span>
</pre></div>
<p>Despues de ordenar el slice por artista, la salida de <code>printTracks</code> es</p>
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Go          Delilah         From the Roots Up  2012  3m38s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Moby            Moby               1992  3m37s</pre>
<p>Si el usuario solicita <q>ordenar por artista</q> una segunda vez, vamos a resolver los tracks en orden inverso. No tenemos que definir un nuevo tipo <code>byReverseArtist</code> con un metodo <code>Less</code> invertido, ya que el paquete <code>sort</code> proporciona una funcion <code>Reverse</code> que transforma cualquier orden a su inversa.</p>
<div class="highlight"><pre><span></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">byArtist</span><span class="p">(</span><span class="nx">tracks</span><span class="p">)))</span>
</pre></div>
<p>Despues de la ordenacin inversa del slice por artista, la salida de <code>printTracks</code> es</p>
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s</pre>
<p>La funcion <code>sort.Reverse</code> merece un vistazo mas de cerca, ya que utiliza la composicion (<a href="#Seccion-6.3" >§6.3</a>), que es una idea importante. El paquete <code>sort</code> define un tipo no exportado <code>reverse</code>, que es una estructura que enbebe un <code>sort.Interface</code>. El metodo <code>Less</code> de <code>reverse</code> llama al <code>Less</code> del varol enbebido <code>sort.Interface</code>, pero con los indices invertidos, invirtiendo el orden de los resultados.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">sort</span>

<span class="kd">type</span> <span class="nx">reverse</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Interface</span> <span class="p">}</span> <span class="c1">// that is, sort.Interface</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">reverse</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nx">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Reverse</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span> <span class="p">}</span>
</pre></div>
<p><code>Len</code> y <code>Swap</code>, los otros dos metodos de <code>reverse</code>, son proporcionados implicitamente por el valor original <code>sort.Interface</code> porque es un campo enbebido. La funcion exportada <code>Reverse</code> devuelve una instancia del tipo <code>reverse</code> que contiene el valor original <code>sort.Interface</code>.</p>
<p>Para ordenar por una columna diferente, hay que definir un nuevo tipo, como <code>byYear</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">byYear</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Year</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">byYear</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>Despues de ordenamos los <code>tracks</code> por año usando <code>sort.Sort(byYear(tracks))</code>, <code>printTracks</code> muestra una lista cronologica:</p>
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s</pre>
<p>Para cada tipo de slice y cada funcion de ordenacion necesitamos, declarar una nueva implementacion de <code>sort.Interface</code>. Como se puede ver, los metodos <code>Len</code> y <code>Swap</code> tienen definiciones identicas para todos los tipos de slice. En el siguiente ejemplo, el tipo concreto <code>customSort</code> combina un slice con una funcion, permitiendo definir un nuevo orden de clasificacion escribiendo unicamente la funcion de comparacion. Por cierto, los tipos concretos que implementan <code>sort.Interface</code> no siempre son slices; <code>customSort</code> es un tipo struct.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">customSort</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">t</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Track</span>
  <span class="nx">less</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">less</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">customSort</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>Vamos a definir una funcion de ordenamiento de multiples niveles cuya clave de ordenacion principal es <code>Title</code>, cuya clave secundaria es <code>Year</code>, y cuya clave terciaria es el tiempo de ejecucion, <code>Length</code>. Aqui esta la llamada a <code>Sort</code> usando una funcion de ordenacion anonima:</p>
<div class="highlight"><pre><span></span><span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">customSort</span><span class="p">{</span><span class="nx">tracks</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span><span class="nx">Track</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Title</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Title</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Year</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Year</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Length</span> <span class="p">&lt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Length</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}})</span>
</pre></div>
<p>Y aqui esta el resultado. Observe que el empate entre las dos pistas tituladas <q>Go</q> se rompe en favor de la mas antigua.</p>
<pre class="pre" >Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s</pre>
<p>Aunque la clasificacion de una secuencia de longitud <span class="math" >n</span> requiere <span class="math" >O(n log n)</span> operaciones de comparacion, probar si una secuencia ya esta ordenada requiere al menos <span class="math" >n-1</span> comparaciones. La funcion <code>IsSorted</code> del paquete <code>sort</code> comprueba esto para nosotros. Al igual que <code>sort.Sort</code>, abstrae tanto la secuencia y su funcion de ordenacion utilizando <code>sort.Interface</code>, pero nunca llama al metodo <code>Swap</code>: Este codigo muestra las funciones <code>IntsAreSorted</code> y <code>Ints</code> y el tipo <code>IntSlice</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &quot;[1 1 3 4]&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
<span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">Reverse</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">values</span><span class="p">)))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>                     <span class="c1">// &quot;[4 3 1 1]&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">IntsAreSorted</span><span class="p">(</span><span class="nx">values</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>Por conveniencia, el paquete <code>sort</code> proporciona versiones de sus funciones y tipos especializados para c([]int), <code>[]string</code>, y <code>[]float64</code> usando sus ordenamientos naturales. Para otros tipos, como <code>[]int64</code> o <code>[]uint</code>, estamos por nuestra cuenta, aunque el camino es corto.</p>
<p><b>Ejercicio 7.8</b>: Muchas interfaces graficas de usuario proporcionan un widget de tabla con ordenacion de multiple nivel: la clave de ordenacion principal es la primer columna, la segunda clae de ordenacion es la segunda columna, y asi sucesivamente. Defina una implementacion de <code>sort.Interface</code> para utilizar con dicha tabla. Compare este enfoque con repetidos ordenamientos utilizando <code>sort.Stable</code>.</p>
<p><b>Ejercicio 7.9</b>: Utilice el paquete <code>html/template</code> (<a href="#Seccion-4.6" >§4.6</a>) para reemplazar <code>printTracks</code> con una funcion que muestre los tracks como una tabla HTML. Utilice la solucion del ejercicio anterior para organizar que cada clic en un encabezado de columna haga una solicitud HTTP para ordenar la tabla.</p>
<p><b>Ejercicio 7.10</b>: El tipo <code>sort.Interface</code> se puede adaptar a otros usos. Escriba una funcion <code>IsPalindrome(s sort.Interface) bool</code> que informe si la secuencia <code>s</code> es un palindromo, es decir, la inversion de la secuencia no lo cambiaria. Suponga que los elementos en los indices <code>i</code> y <code>j</code> son iguales si <code>!s.Less(i, j) &amp;&amp; !s.Less(j, i)</code>.</p>
</div>
<h3 id="Seccion-7.7" >La Interfaz <code>http.Handler</code></h3>
<div class="hBody-3" >
<p>En el <a href="#Capitulo-1" >Capitulo 1</a>, vimos una idea de como utilizar el paquete <code>net/http</code> para implementar clientes web (<a href="#Seccion-1.5" >§1.5</a>) y servidores (<a href="#Seccion-1.7" >§1.7</a>). En esta seccion, vamos a ver mas de cerca la API del servidor, cuyo fundamento es la interfaz <code>http.Handler</code>:</p>
<div class="figure" >
<p class="title"><code>net/http</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">ListenAndServe</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">Handler</span><span class="p">)</span> <span class="kt">error</span>
</pre></div>
</div>
<p>La función <code>ListenAndServe</code> requiere una dirección de servidor, como <code>&quot;localhost:8000&quot;</code>, y una instancia de la interfaz <code>Handler</code> a la que todas las solicitudes deben enviarse. Se ejecuta para siempre, o hasta que el servidor falla (o no se inicia) con un error, que siempre devuelve no-nil.</p>
<p>Imagine un sitio de comercio electronico con una base de datos de los articulos a la venta con sus precios en dolares. El siguiente programa muestra la implementacion imaginable mas sencilla. Modelos del inventario como un tipo de mapa, <code>database</code>, a la que ha adjuntado un metodo <code>ServeHTTP</code> para que satisfaga la interfaz <code>http.Handler</code>. El controlador se extiende sobre el mapa e imprime los elementos.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/http1/main.go" >gopl.io/ch7/http1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">dollars</span> <span class="kt">float32</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">dollars</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;$%.2f&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Si iniciamos el servidor,</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch7/http1
$ ./http1 <span class="p">&amp;</span>
</pre></div>
<p>luego conectamos con el con el programa <code class="command" >fetch</code> de la <a href="#Seccion-1.5" >Seccion 1.5</a> (o con un navegador web, si lo prefiere), obtenemos el siguiente resultado:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ ./fetch http://localhost:8000
shoes: <span class="nv">$50</span>.00
socks: <span class="nv">$5</span>.00
</pre></div>
<p>Hasta ahora, el servidor solo puede enumerar su inventario completo y lo hara para cada solicitud, independientemente de la URL. Un servidor mas realista define varias URL diferentes, cada una desencadenando un comportamiento diferente. Vamos a llamar al comportamiento existente <code>/list</code> y añadamos otra que se llame <code>/price</code> que informa el precio de un solo articulo, especificado como un parametro de la peticion, por ejemplo <code>/price?item=socks</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/http2/main.go" >gopl.io/ch7/http2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&quot;/list&quot;</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="s">&quot;/price&quot;</span><span class="p">:</span>
    <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">)</span>
    <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such item: %q\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span>  <span class="c1">// 404</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such page: %s\n&quot;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora el controlador decide que logica hay que usar basado en el componente de la ruta de la URL, <code>req.URL.Path</code>. Si el controlador no reconoce la ruta, se informa de un error HTTP al cliente llamando a <code>w.WriteHeader(http.StatusNotFound)</code>; esto debe hacerse antes de escribir cualquier texto a <code>w</code>. (Por cierto, <code>http.ResponseWriter</code> es otra interfaz. aumenta a <code>io.Writer</code> con metodos para enviar cabeceras de respuesta HTTP.) De manera equivalente, podriamos utilizar la funcion de utilidad <code>http.Error</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;no such page: %s\n&quot;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
</pre></div>
<p>El argumento <code>/price</code> llama al metodo <code>Query</code> de la URL para analizar los parametros de la peticion HTTP como un mapa, o mas precisamente, un mapa multiple de tipo <code>url.Values</code> (<a href="#Seccion-6.2.1" >§6.2.1</a>) del paquete <code>net/url</code>. A continuacion, busca el primer parametro <code>item</code> y mira su precio. Si no se encontro el elemento, informa de un error.</p>
<p>He aqui una sesion de ejemplo con el nuevo servidor:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch7/http2
$ go build gopl.io/ch1/fetch
$ ./http2 <span class="p">&amp;</span>
$ ./fetch http://localhost:8000/list
shoes: <span class="nv">$50</span>.00
socks: <span class="nv">$5</span>.00
$ ./fetch http://localhost:8000/price?item<span class="o">=</span>socks
<span class="nv">$5</span>.00
$ ./fetch http://localhost:8000/price?item<span class="o">=</span>shoes
<span class="nv">$50</span>.00
$ ./fetch http://localhost:8000/price?item<span class="o">=</span>hat
no such item: <span class="s2">&quot;hat&quot;</span>
$ ./fetch http://localhost:8000/help
no such page: /help
</pre></div>
<p>Obviamente podriamos seguir añadiendo casos a <code>ServeHTTP</code>, pero en una aplicacion real, es conveniente definir la logica para cada caso en una funcion o un metodo independiente. Ademas, las URL relacionadas pueden necesitar una logica similar; varios archivos de imagen pueden tener URLs de tipo <code>/images/*.png</code>, por ejemplo. Por estas razones, <code>net/http</code> proporciona <code>ServeMux</code>, una solicitud multiplexor, para simplificar la asociacion entre las direcciones URL y manipuladores. <code>ServeMux</code> agrega una coleccion de <code>http.Handlers</code> en un solo <code>http.Handler</code>. Una vez mas, vemos que los diferentes tipos que satisfacen la misma interfaz son <em>sustituibles</em>: el servidor web es capaz de consultar a cualquier <code>http.Handler</code>, independientemente del tipo concreto esta detras de el.</p>
<p>Para una aplicacion mas compleja, varios <code>ServeMuxes</code> pueden estar compuestos para manejar requerimientos de secuenciacion mas intrincados. Go no tiene un framework web canonico analogo a Rails de Ruby o a Django de Python. Esto no quiere decir que tales frameworks no existan, pero los bloques de construccion en la libreria estandar de Go son lo suficientemente flexibles como para que los frameworks sean a menudo innecesarios. Ademas, aunque los frameworks son convenientes en las primeras fases de un proyecto, su complejidad adicional puede hacer que el mantenimiento a largo plazo sea mas dificil.</p>
<p>En el siguiente programa, creamos un <code>ServeMux</code> y lo usamos para asociar las direcciones URL con los controladores correspondientes para las operaciones <code>/list</code> y <code>/price,</code> que se han dividido en metodos separados. A continuacion, utilizamos <code>ServeMux</code> como el controlador principal en la llamada a <code>ListenAndServe</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/http3/main.go" >gopl.io/ch7/http3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">NewServeMux</span><span class="p">()</span>
  <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/list&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">))</span>
  <span class="nx">mux</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/price&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">))</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">database</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">dollars</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">list</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="nx">database</span><span class="p">)</span> <span class="nx">price</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">item</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Query</span><span class="p">().</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;item&quot;</span><span class="p">)</span>
  <span class="nx">price</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span> <span class="c1">// 404</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;no such item: %q\n&quot;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Centremonos en las dos llamadas a <code>mux.Handle</code> que registran los manejadores. En la primera, <code>db.list</code> es un valor de metodo (<a href="#Seccion-6.4" >§6.4</a>), es decir, un valor de tipo</p>
<div class="highlight"><pre><span></span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
</pre></div>
<p>que, cuando se llama, invoca el metodo <code>database.list</code> con el valor receptor <code>db</code>. Asi que <code>db.list</code> es una funcion que implementa el comportamiento manipulador, pero ya que no tiene metodos, no satisface la interfaz <code>http.Handler</code> y no se puede pasar directamente a <code>mux.Handle</code>.</p>
<p>La expresion <code>http.HandlerFunc(db.list)</code> es una conversion, no una llamada de funcion, ya que <code>http.HandlerFunc</code> es un tipo. Tiene la siguiente definicion:</p>
<div class="figure" >
<p class="title"><code>net/http</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code>HandlerFunc</code> demuestra algunas caracteristicas inusuales del mecanismo de interfaz de Go. Es un tipo de funcion que tiene metodos y satisface una interfaz, <code>http.Handler</code>. El comportamiento de su <code>ServeHTTP</code> metodo es llamar a la funcion subyacente. <code>HandlerFunc</code> es, por tanto, un adaptador que permite que un valor de funcion de satisfaga una interfaz, donde la funcion y el unico metodo de la interfaz tienen la misma firma. En efecto, este truco permite que un solo tipo, como <code>database</code> cumpla con la interfaz <code>http.Handler</code> de varias maneras: una vez a traves de su <code>list</code> metodo, una vez que a traves de su metodo <code>price</code>, y asi sucesivamente.</p>
<p>Debido a que el registro de un manejador de esta manera es tan comun, <code>ServeMux</code> tiene un metodo de conveniencia llamado <code>HandleFunc</code> que lo hace por nosotros, por lo que podemos simplificar el codigo de registro del manejador a esto:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/http3a/main.go" >gopl.io/ch7/http3a</a></p>
<div class="highlight"><pre><span></span><span class="nx">mux</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/list&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
<span class="nx">mux</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/price&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">)</span>
</pre></div>
</div>
<p>Es facil ver desde el codigo anterior como uno podria construir un programa en el que hay dos servidores web diferentes, escuchando en diferentes puertos, definiendo diferentes URL y enviando a diferentes manejadores. Simplemente construiriamos otro ServeMux y hariamos otra llamada a <code>ListenAndServe</code>, tal vez al mismo tiempo. Pero en la mayoria de los programas, un servidor web es suficiente. Ademas, es tipico definir manejadores HTTP a traves de muchos archivos de una aplicacion, y seria una molestia si todos tuvieran que ser registrados de manera explicita con la instancia de la aplicacion <code>ServeMux</code>.</p>
<p>Asi que, por conveniencia, <code>net/http</code> proporciona unna instancia global <code>ServeMux</code> llamada <code>DefaultServeMux</code> y funciones a nivel de paquete llamadas <code>http.Handle</code> y <code>http.HandleFunc</code>. Para utilizar <code>DefaultServeMux</code> como manejador principal del servidor, no es necesario pasarlo a <code>ListenAndServe</code>; <code>nil</code> lo hara.</p>
<p>La funcion principal del servidor se puede simplificar a</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/http4/main.go" >gopl.io/ch7/http4</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span> <span class="o">:=</span> <span class="nx">database</span><span class="p">{</span><span class="s">&quot;shoes&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">&quot;socks&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/list&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
  <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/price&quot;</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">price</span><span class="p">)</span>
  <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:8000&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Por ultimo, un recordatorio importante: como mencionamos en la <a href="#Seccion-1.7" >Seccion 1.7</a>, el servidor web invoca cada manejador en una nueva goroutine, por lo que los manipuladores deben tomar precauciones como el <em>bloqueo</em> al acceder a variables de otras gorutinas, incluyendo otras solicitudes al mismo manejador. Hablaremos de concurrencia en los proximos dos capitulos.</p>
<p><b>Ejercicio 7.11</b> Agregar manejadores adicionales para que los clientes pueden crear, leer, actualizar y eliminar entradas de <code>database</code>. Por ejemplo, una solicitud con formato <code>/update?item=socks&amp;price=6</code> actualizara el precio de un articulo en el inventario e informar un error si el elemento no existe o si el precio no es valido. (Advertencia: este cambio introduce actualizacion de variables concurrentes.)</p>
<p><b>Ejercicio 7.12</b>: Cambiar el manejador de <code>/list</code> para imprimir su salida como una tabla HTML, no como texto. Puede que el paquete <code>html/template</code> (<a href="#Seccion-4.6" >§4.6</a>) sea util.</p>
</div>
<h3 id="Seccion-7.8" >La Interfaz <code>error</code></h3>
<div class="hBody-3" >
<p>Desde el comienzo de este libro, hemos estado usando y creando valores del misterioso tipo predeclarado <code>error</code> sin explicar lo que realmente es. De hecho, es solo un tipo de interfaz con un unico metodo que devuelve un mensaje de error:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
<p>La forma mas sencilla de crear un <code>error</code> es llamando a <code>errors.New,</code> que devuelve un nuevo <code>error</code> para un mensaje de error dado. Todo el paquete <code>errors</code> solo son cuatro lineas:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">errors</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">text</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">errorString</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">text</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">text</span> <span class="p">}</span>
</pre></div>
<p>El tipo subyacente de <code>errorString</code> es una estructura, no una cadena, para proteger su representacion de cambios involuntarios (o premeditados). Y la razon de que el tipo de puntero sea <code>*errorString</code>, no es solo <code>errorString</code>, para satisfacer la interfaz <code>error</code> es para que cada llamada a <code>New</code> asigne una instancia de error distinta que no es igual a ninguna otra. No queremos que un error distinguido como <code>io.EOF</code> sea igual a o uno que simplemente contien el mismo mensaje.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;EOF&quot;</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>Las llamadas a <code>errors.New</code> son relativamente poco frecuentes porque hay una funcion de envoltura conveniente, <code>fmt.Errorf</code>, que tambien hace formateo de cadenas. Lo usamos varias veces en el <a href="#Capitulo-5" >Capitulo 5</a>.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kn">import</span> <span class="s">&quot;errors&quot;</span>

<span class="kd">func</span> <span class="nx">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>Aunque <code>*errorString</code> puede ser el tipo mas sencillo de <code>error</code>, esta lejos de ser el unico. Por ejemplo, el paquete <code>syscall</code> proporciona la API de llamadas a bajo nivel de Go. En muchas plataformas, define un tipo numerico <code>Errno</code> que satisface <code>error</code>, y en plataformas Unix, el metodo <code>Errno</code> de <code>Error</code> realiza una busqueda en una tabla de cadenas, como se muestra a continuacion:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">syscall</span>

<span class="kd">type</span> <span class="nx">Errno</span> <span class="kt">uintptr</span> <span class="c1">// codigos de error del sistema operativo</span>

<span class="kd">var</span> <span class="nx">errors</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="s">&quot;operation not permitted&quot;</span><span class="p">,</span>   <span class="c1">// EPERM</span>
  <span class="mi">2</span><span class="p">:</span> <span class="s">&quot;no such file or directory&quot;</span><span class="p">,</span> <span class="c1">// ENOENT</span>
  <span class="mi">3</span><span class="p">:</span> <span class="s">&quot;no such process&quot;</span><span class="p">,</span>           <span class="c1">// ESRCH</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Errno</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">[</span><span class="nx">e</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;errno %d&quot;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>La siguiente sentencia crea un valor de interfaz que contiene el valor <code>Errno</code> 2, que significa la condicion POSIX <code>ENOENT</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Errno</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span> <span class="c1">// &quot;el fichero o directorio no existe&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// &quot;el fichero o directorio no existe&quot;</span>
</pre></div>
<p>El valor de <code>err</code> se muestra graficamente en la Figura 7.6.</p>
<div class="figure" >
<p class="title">Figura 7.6. Un valor de interfaz que contiene un entero <code>syscall.Errno</code>.</p>
<pre class="art" >      err
      ┏━━━━━━━━━━━━━━━━━┓
 tipo ┃  syscall.Errno  ┃
      ┣━━━━━━━━━━━━━━━━━┫
valor ┃        2        ┃
      ┗━━━━━━━━━━━━━━━━━┛</pre>
</div>
<p><code>Errno</code> es una representacion eficiente de los errores de llamada del sistema extraidos de un conjunto finito, y satisface la interfaz estandar <code>error</code>. Veremos otros tipos que satisfacen esta interfaz en la <a href="#Seccion-7.11" >Seccion 7.11</a>.</p>
</div>
<h3 id="Seccion-7.9" >Ejemplo: Evaluador de Expresiones</h3>
<div class="hBody-3" >
<p>En esta seccion, crearemos un evaluador para expresiones aritmeticas simples. Vamos a utilizar una interfaz, <code>Expr</code>, para representar cualquier expresion en este lenguaje. Por ahora, esta interfaz no necesita metodos, pero agregaremos algunos mas tarde.</p>
<div class="highlight"><pre><span></span><span class="c1">// Un Expr es una expresion aritmetica.</span>
<span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span><span class="p">{}</span>
</pre></div>
<p>Nuestro lenguaje de expresiones consiste en literales de punto flotante; los operadores binarios <code>+</code>, <code>-</code>, <code>*</code> y <code>/</code>; los operadores unarios <code>-x</code> y <code>+x</code>; llamadas de funcion <code>pow(x,y)</code>, <code>sin(x)</code>, y <code>sqrt(x)</code>; variables como <code>x</code> y <code>pi</code>; Y por supuesto los parentesis y la precedencia estandar de operadores. Todos los valores son del tipo <code>float64</code>. Aqui hay algunas expresiones de ejemplo:</p>
<div class="highlight"><pre><span></span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">A</span> <span class="o">/</span> <span class="nx">pi</span><span class="p">)</span>
<span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nx">F</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
</pre></div>
<p>Los cinco tipos concretos de abajo representan tipos particulares de expresiones. un <code>Var</code> representa una referencia a una variable. (Pronto veremos por que se exporta.) Un <code>literal</code> representa una constante de coma flotante. Los tipos <code>unary</code> y <code>binary</code> representan expresiones de operador con uno o dos operandos, que pueden ser cualquier tipo de <code>Expr</code>. Un <code>call</code> es una llamada de funcion; restringiremos este campo <code>fn</code> a <code>pow</code>, <code>sin</code>, o <code>sqrt</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/eval/ast.go" >gopl.io/ch7/eval</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Un Var identifica una variable, por ejemplo, x.</span>
<span class="kd">type</span> <span class="nx">Var</span> <span class="kt">string</span>

<span class="c1">// Un literal es un numero constante, por ejemplo, 3.141.</span>
<span class="kd">type</span> <span class="nx">literal</span> <span class="kt">float64</span>

<span class="c1">// Un unary representa una expresion de operador unario, por ejemplo, -x.</span>
<span class="kd">type</span> <span class="nx">unary</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span> <span class="kt">rune</span> <span class="c1">// one of &#39;+&#39;, &#39;-&#39;</span>
  <span class="nx">x</span>  <span class="nx">Expr</span>
<span class="p">}</span>

<span class="c1">// Un binary representa una expresion de operador binario, por ejemplo, x+y.</span>
<span class="kd">type</span> <span class="nx">binary</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span>   <span class="kt">rune</span> <span class="c1">// one of &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">Expr</span>
<span class="p">}</span>

<span class="c1">// Un call representa una expresion de llamada a funcion, por ejemplo, sin(x).</span>
<span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">fn</span>   <span class="kt">string</span> <span class="c1">// uno de &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;</span>
  <span class="nx">args</span> <span class="p">[]</span><span class="nx">Expr</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Para evaluar una expresion que contiene variables, necesitaremos un entorno que asigne nombres de variables a valores:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Env</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">float64</span>
</pre></div>
<p>Tambien necesitaremos cada tipo de expresion para definir un metodo <code>Eval</code> que devuelva el valor de la expresion en un entorno determinado. Puesto que cada expresion debe proporcionar este metodo, lo añadimos a la interfaz <code>Expr</code>. El paquete exporta unicamente los tipos <code>Expr</code>, <code>Env</code>, y <code>Var</code>; Los clientes pueden utilizar el evaluador sin acceso a los otros tipos de expresion.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="c1">// Eval devuelve el valor de este Expr en el entorno env.</span>
  <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span>
<span class="p">}</span>
</pre></div>
<p>Los metodos concretos de <code>Eval</code> se muestran a continuacion. El metodo de <code>Var</code> realiza una busqueda de entorno, que devuelve cero si la variable no esta definida, y el metodo de <code>literal</code> simplemente devuelve el valor literal.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Var</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">env</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">literal</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">_</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Los metodos <code>Eval</code> de <code>unary</code> y <code>binary</code> evaluan de forma recursiva sus operandos, luego aplican la operacion <code>op</code> a ellos. No consideramos divisiones por cero o infinito como errores, ya que producen un resultado, no finito. Finalmente, el metodo de <code>call</code> evalua los argumentos de la funcion <code>pow</code>, <code>sin</code>, o <code>sqrt</code>, y luego llama a la funcion correspondiente en el paquete <code>math</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">unary</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span> <span class="p">{</span>
  <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">+</span><span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unsupported unary operator: %q&quot;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">binary</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span> <span class="p">{</span>
  <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">*</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span> <span class="o">/</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unsupported binary operator: %q&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">call</span><span class="p">)</span> <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">&quot;pow&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">),</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="k">case</span> <span class="s">&quot;sin&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sin</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="k">case</span> <span class="s">&quot;sqrt&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unsupported function call: %s&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>Varios de estos metodos pueden fallar. Por ejemplo, una expresion <code>call</code> podria tener una funcion desconocida o el numero incorrecto de argumentos. Tambien es posible construir una expresion <code>unary</code> o <code>binary</code> con un operador no valido como <code>!</code> o <code>&lt;</code> (aunque la funcion <code>Parse</code> mencionada a continuacion nunca hara esto). Estos errores hacen que <code>Eval</code> entre en panico. Otros errores, la evaluacion de un <code>Var</code> no presente en el entorno, simplemente hacen que <code>Eval</code> devuelva el resultado incorrecto. Todos estos errores podrian ser detectados por la inspeccion de <code>Expr</code> antes de su evaluacion. Ese sera el trabajo del metodo <code>Check</code>, que mostraremos pronto, pero primero vamos a probar <code>Eval</code>.</p>
<p>La funcion <code>TestEval</code> a continuacion, es una prueba del evaluador. Utiliza el paquete <code>testing</code>, que explicaremos en el <a href="#Capitulo-11" >Capitulo 11</a>, pero por ahora es suficiente saber que llamar a <code>t.Errorf</code> informa de un error. La funcion recorre una tabla de entradas que define tres expresiones y entornos diferentes para cada una. La primer expresion calcula el radio de un circulo dada su area <code>A</code>, la segunda calcula la suma de los cubos de dos variables <code>x</code> e <code>y</code>, y la tercera convierte una temperatura <code>Fahrenheit</code> de <code>F</code> a <code>Celsius</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestEval</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">expr</span> <span class="kt">string</span>
    <span class="nx">env</span>  <span class="nx">Env</span>
    <span class="nx">want</span> <span class="kt">string</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&quot;sqrt(A / pi)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">:</span> <span class="mi">87616</span><span class="p">,</span> <span class="s">&quot;pi&quot;</span><span class="p">:</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">},</span> <span class="s">&quot;167&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;pow(x, 3) + pow(y, 3)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s">&quot;1729&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;pow(x, 3) + pow(y, 3)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="s">&quot;1729&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;5 / 9 * (F - 32)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;F&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">40</span><span class="p">},</span> <span class="s">&quot;-40&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;5 / 9 * (F - 32)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;F&quot;</span><span class="p">:</span> <span class="mi">32</span><span class="p">},</span> <span class="s">&quot;0&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;5 / 9 * (F - 32)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;F&quot;</span><span class="p">:</span> <span class="mi">212</span><span class="p">},</span> <span class="s">&quot;100&quot;</span><span class="p">},</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">prevExpr</span> <span class="kt">string</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="c1">// Imprime expr solo cuando hay cambios.</span>
    <span class="k">if</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span> <span class="o">!=</span> <span class="nx">prevExpr</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\n%s\n&quot;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">)</span>
      <span class="nx">prevExpr</span> <span class="p">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span>
    <span class="p">}</span>
    <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// analiza error</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.6g&quot;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\t%v =&gt; %s\n&quot;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s.Eval() in %s = %q, want %q\n&quot;</span><span class="p">,</span>
        <span class="nx">test</span><span class="p">.</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Para cada entrada en la tabla, la prueba analiza la expresion, la evalua en el entorno e imprime el resultado. No tenemos espacio para mostrar la funcion <code>Parse</code> aqui, pero lo encontrara si se descarga el paquete usando <code class="command" >go get</code>.</p>
<p>El comando <code class="command" >go test</code> (<a href="#Seccion-11.1" >§11.1</a>) ejecuta las pruebas de un paquete:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -v gopl.io/ch7/eval
</pre></div>
<p>La bandera <code>-v</code> nos permite ver la salida impresa de la prueba, que normalmente se suprime para una prueba exitosa como esta. Aqui esta la salida de la prueba de las sentencias <code>fmt.Printf</code>:</p>
<div class="highlight"><pre><span></span>sqrt<span class="o">(</span>A / pi<span class="o">)</span>
    map<span class="o">[</span>A:87616 pi:3.141592653589793<span class="o">]</span> <span class="o">=</span>&gt; <span class="m">167</span>

pow<span class="o">(</span>x, <span class="m">3</span><span class="o">)</span> + pow<span class="o">(</span>y, <span class="m">3</span><span class="o">)</span>
    map<span class="o">[</span>x:12 y:1<span class="o">]</span> <span class="o">=</span>&gt; <span class="m">1729</span>
    map<span class="o">[</span>x:9 y:10<span class="o">]</span> <span class="o">=</span>&gt; <span class="m">1729</span>

<span class="m">5</span> / <span class="m">9</span> * <span class="o">(</span>F - <span class="m">32</span><span class="o">)</span>
    map<span class="o">[</span>F:-40<span class="o">]</span> <span class="o">=</span>&gt; -40
    map<span class="o">[</span>F:32<span class="o">]</span> <span class="o">=</span>&gt; <span class="m">0</span>
    map<span class="o">[</span>F:212<span class="o">]</span> <span class="o">=</span>&gt; <span class="m">100</span>
</pre></div>
<p>Afortunadamente hasta ahora los datos de entrada han sido bien formados, pero es poco probable que dure nuestra suerte. Incluso en los lenguajes interpretados, es comun comprobar la sintaxis de errores <em>estaticos</em>, es decir, errores que pueden ser detectados sin ejecutar el programa. Al separar los controles estaticos de los dinamicos, podemos detectar errores antes y realizar muchas verificaciones solo una vez en lugar de cada vez que se evalua una expresion.</p>
<p>Vamos a añadir otro metodo a la interfaz <code>Expr</code>. El metodo <code>Check</code> comprueba si hay errores estaticos en un arbol de sintaxis de expresiones. Vamos a explicar su parametro <code>vars</code> en un momento.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Expr</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Eval</span><span class="p">(</span><span class="nx">env</span> <span class="nx">Env</span><span class="p">)</span> <span class="kt">float64</span>
  <span class="c1">// Check informa errores en este Expr y agrega sus Vars al conjunto.</span>
  <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>
<p>El metodo concreto <code>Check</code> se muestran a continuacion. La evaluacion de <code>literal</code> y <code>Var</code> no puede fallar, por lo que los metodos <code>Check</code> para estos tipos devuelven <code>nil</code>. Los metodos para <code>unary</code> y <code>binary</code> primera verifican que el operador es valido, luego comprueban recursivamente los operandos. Del mismo modo, el metodo para de <code>call</code> comprueba primero que la funcion se conoce y tiene el numero correcto de argumentos, entonces, de forma recursiva comprueba cada argumento.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Var</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">vars</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">literal</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="nx">unary</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ContainsRune</span><span class="p">(</span><span class="s">&quot;+-&quot;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unexpected unary op %q&quot;</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">binary</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">ContainsRune</span><span class="p">(</span><span class="s">&quot;+-*/&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unexpected binary op %q&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">op</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">call</span><span class="p">)</span> <span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">arity</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">numParams</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unknown function %q&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">arity</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;call to %s has %d args, want %d&quot;</span><span class="p">,</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">args</span><span class="p">),</span> <span class="nx">arity</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">numParams</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;pow&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;sin&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;sqrt&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
<p>Hemos listado una seleccion de entradas defectuosas y los errores que provocan, en dos grupos. La funcion <code>Parse</code> (no se muestra) informa de errores de sintaxis y la funcion <code>Check</code> de informes de errores semanticos.</p>
<pre class="pre" >x % 2             unexpected '%'
math.Pi           unexpected '.'
!true             unexpected '!'
&quot;hello&quot;           unexpected '&quot;'

log(10)           unknown function &quot;log&quot;
sqrt(1, 2)        call to sqrt has 2 args, want 1</pre>
<p>El argumento de <code>Check</code>, un conjunto de <code>Vars</code>, acumula el conjunto de nombres de variables que se encuentran dentro de la expresion. Cada una de estas variables debe estar presente en el entorno para que la evaluacion tenga exito. Este conjunto es, logicamente, el <em>resultado</em> de la llamar a <code>Check</code>, pero debido a que el metodo es recursivo, es mas conveniente para <code>Check</code> llenar el conjunto pasandolo como parametro. El cliente debe proporcionar un conjunto vacio en la llamada inicial.</p>
<p>En la <a href="#Seccion-3.2" >Seccion 3.2</a>, se represento una funcion <code>f(x,y)</code> que se establece en tiempo de compilacion. Ahora que podemos analizar, comprobar y evaluar expresiones en cadenas, podemos construir una aplicacion web que recibe una expresion en tiempo de ejecucion del cliente y traza la superficie de esa funcion. Podemos utilizar los <code>vars</code> establecidos para comprobar que la expresion es una funcion de dos variables, <code>x</code> e <code>y</code>–tres, en realidad, ya que proporcionamos <code>r</code>, el radio, como una conveniencia. Y usaremos el metodo <code>Check</code> para rechazar expresiones mal formadas antes de que comience la evaluacion, de mono que no repitamos esas verificaciones durante las 40.000 evaluaciones (100×100 celulas, cada una con cuatro esquinas) de la funcion que le sigue.</p>
<p>La funcion <code>parseAndCheck</code> combina estos pasos de analisis y comprobacion:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/surface/surface.go" >gopl.io/ch7/surface</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;gopl.io/ch7/eval&quot;</span>

<span class="kd">func</span> <span class="nx">parseAndCheck</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Expr</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;empty expression&quot;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">eval</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">vars</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="nx">vars</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vars</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&quot;x&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&quot;y&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">!=</span> <span class="s">&quot;r&quot;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;undefined variable: %s&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">expr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Para hacer de esto una aplicacion web, todo lo que necesitamos es la siguiente funcion <code>plot</code>, que tiene la firma familiar de un <code>http.HandlerFunc</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">plot</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">r</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">()</span>
  <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parseAndCheck</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Form</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;expr&quot;</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;bad expr: &quot;</span><span class="o">+</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">Header</span><span class="p">().</span><span class="nx">Set</span><span class="p">(</span><span class="s">&quot;Content-Type&quot;</span><span class="p">,</span> <span class="s">&quot;image/svg+xml&quot;</span><span class="p">)</span>
  <span class="nx">surface</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// distance from (0,0)</span>
    <span class="k">return</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">eval</span><span class="p">.</span><span class="nx">Env</span><span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">:</span> <span class="nx">r</span><span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
</pre></div>
<p>La funcion <code>plot</code> analiza y comprueba la expresion especificada en la peticion HTTP y la utiliza para crear una funcion anonima de dos variables. La funcion anonima tiene la misma firma que la funcion fija <code>f</code> del programa de trazado de la superficie original, pero evalua la expresion proporcionada por el usuario. El entorno define <code>x</code>, <code>y</code>, y el radio <code>r</code>. Finalmente, <code>plot</code> llama a <code>surface</code>, que es solo la funcion <code>main</code> de <code>gopl.io/ch3/surface</code>, modificado para tomar la funcion de trazar y la salida de <code>io.Writer</code> como parametros, en lugar de utilizar la funcion fija <code>f</code> y <code>os.Stdout</code>. La Figura 7.7 muestra tres superficies producidas por el programa.</p>
<div class="figure" >
<p class="title">Figura 7.7. Las superficies de tres funciones: (a) <code>sin(-x)*pow(1.5,-r)</code>; (b) <code>pow(2,sin(y))*pow(2,sin(x))/12</code>; (c) <code>sin(x*y/10)/10</code>.</p>
<figure>
<img src="img/Figure-7.7.a.jpg" />
</figure>
<figure>
<img src="img/Figure-7.7.b.jpg" />
</figure>
<figure>
<img src="img/Figure-7.7.c.jpg" />
</figure>
</div>
<p><b>Ejercicio 7.13</b>: Agregue una metodo <code>String</code> a <code>Expr</code> para imprimir el arbol de sintaxis. Compruebe que los resultados, cuando se analiza de nuevo, producen un arbol equivalente.</p>
<p><b>Ejercicio 7.14</b>: Definir un nuevo tipo concreto que satisfaga la interfaz <code>Expr</code> y ofrece una nueva operacion como calcular el valor minimo de sus operandos. Ya que la funcion <code>Parse</code> no crea instancias de este nuevo tipo, para usarlo necesitara construir un arbol de sintaxis directamente (o extender el analizador).</p>
<p><b>Ejercicio 7.15</b>: Escriba un programa que lee una sola expresion de la entrada estandar, solicita al usuario que proporcione valores para las variables, y luego  evalue la expresion en el medio ambiente resultante. Maneje todos los errores con gracia.</p>
<p><b>Ejercicio 7.16</b>: Escribia un programa de calculadora basado en la web.</p>
</div>
<h3 id="Seccion-7.10" >Afirmacion de Tipo</h3>
<div class="hBody-3" >
<p>Una <em>afirmacion de tipo</em> es una operacion aplicada a un valor de interfaz. Sintacticamente, se ve como <code>x.(T)</code>, donde <code>x</code> es una expresion de un tipo de interfaz y <code>T</code> es un tipo, denominado el tipo <q>afirmado</q>. Una afirmacion de tipo comprueba que el tipo dinamico de su operando coincide con el tipo declarado.</p>
<p>Hay dos posibilidades. En primer lugar, si el tipo afirmado <code>T</code> es un tipo concreto, entonces la asercion de tipo comprueba si el tipo dinamico <code>x</code> es <em>identico a</em> <code>T</code>. Si esta comprobacion tiene exito, el resultado de la afirmacion tipo es el valor dinamico <code>x</code>, cuyo tipo es, por supuesto, <code>T</code>. En otras palabras, una afirmacion de tipo a un tipo concreto extrae el valor concreto de su operando. Si la comprobacion falla, entonces la operacion entra en panico. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// exito: f == os.Stdout</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// panico: interfaz contiene *os.File, no *bytes.Buffer</span>
</pre></div>
<p>En segundo lugar, si en lugar del tipo afirmado <code>T</code> es un tipo de interfaz, entonces, la afirmacion de tipo comprueba si el tipo dinamico <code>x</code> <em>satisface</em> a <code>T</code>. Si esta comprobacion tiene exito, el valor dinamico no se extrae; el resultado sigue siendo un valor de interfaz con el mismo y varol de componentes, pero el resultado tiene el tipo de interfaz <code>T</code>. En otras palabras, una asercion de tipo a un tipo de interfaz cambia el tipo de la expresion, haciendo accesible un conjunto de metodos diferente (y generalmente mas grande), pero conserva los componentes dinamicos de tipo y valor dentro del valor de la interfaz.</p>
<p>Despues de la afirmacion del primer tipo a continuacion, tanto <code>w</code> y <code>rw</code> contienen <code>os.Stdout</code> por lo que cada uno tiene un tipo dinamico de <code>*os.File</code>, pero <code>w</code>, un <code>io.Writer</code>, expone solo el metodo <code>Write</code> del archivo, mientras que <code>rw</code> expone tambien su metodo <code>Read</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">rw</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span> <span class="c1">// exito: *os.File tiene tanto Read como Write</span>

<span class="nx">w</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">ByteCounter</span><span class="p">)</span>
<span class="nx">rw</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadWriter</span><span class="p">)</span>  <span class="c1">// panico: *ByteCounter no tiene metodo Read</span>
</pre></div>
<p>No importa que tipo se afirmo, si el operando es un valor de interfaz nil, la afirmacion de tipo falla. Rara vez se necesita una asercion de tipo a un tipo de interfaz menos restrictivo (uno con menos metodos), ya que se comporta como una asignacion, excepto en el caso nulo.</p>
<div class="highlight"><pre><span></span><span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span>             <span class="c1">// io.ReadWriter es asignable a io.Writer</span>
<span class="nx">w</span> <span class="p">=</span> <span class="nx">rw</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="c1">// falla solo si rw == nil</span>
</pre></div>
<p>A menudo no estamos seguros del tipo dinamico de un valor de interfaz, y nos gustaria probar si es algun tipo particular. Si la afirmacion de tipo aparece en una asignacion en la que se esperan dos resultados, como las siguientes declaraciones, la operacion no entra en panico cuando se produce un error, sino que devuelve un segundo resultado adicional, un booleano que indica exito:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span>      <span class="c1">// exito: ok, f == os.Stdout</span>
<span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// fallo: !ok, b == nil</span>
</pre></div>
<p>El segundo resultado es asignado convencionalmente a una variable llamada <code>ok</code>. Si la operacion ha fallado, <code>ok</code> es falso, y el primer resultado es igual al valor cero del tipo afirmado, que en este ejemplo es nil <code>*bytes.Buffer</code>.</p>
<p>El resultado <code>ok</code> a menudo se utiliza de inmediato para decidir que hacer a continuacion. La forma extendida de la sentencia <code>if</code> hace esto muy compacto:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...use f...</span>
<span class="p">}</span>
</pre></div>
<p>Cuando el operando de una afirmacion de tipo es una variable, en lugar de inventar otro nombre para la nueva variable local, a veces vera el nombre original reutilizado, ocultando el original, asi:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="c1">// ...utilizar w...</span>
<span class="p">}</span>
</pre></div>
</div>
<h3 id="Seccion-7.11" >Discriminacion de Errores con Afirmaciones de Tipo</h3>
<div class="hBody-3" >
<p>Consideremos el conjunto de errores devueltos por las operaciones de archivos en el paquete <code>os</code>. Las E/S pueden fallar por varias razones, pero tres tipos de fallos a menudo deben manejarse de manera diferente: el archivo ya existe (para las operaciones de creacion), el archivo no se encuentra (para operaciones de lectura) y el permiso esta denegado. El paquete <code>os</code> proporciona estas tres funciones de ayuda para clasificar el fallo indicado por un determinado valor <code>error</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">os</span>

<span class="kd">func</span> <span class="nx">IsExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">IsPermission</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
</pre></div>
<p>Una implementacion naïve de uno de estos predicados podria comprobar que el mensaje de error contenga una cierta subcadena,</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="c1">// NOTA: no es robusto!</span>
  <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="s">&quot;file does not exist&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Pero debido a que la logica para manejar los errores de E/S puede variar de una plataforma a otra, este enfoque no es robusto y el mismo fallo puede ser reportado con una variedad de diferentes mensajes de error. La comprobacion de subcadenas de mensajes de error puede ser util durante la prueba para asegurarse de que las funciones fallan de la manera esperada, pero es inadecuado para el codigo en produccion.</p>
<p>Un enfoque mas confiable es representar valores de error estructurados utilizando un tipo especifico. El paquete OS define un tipo llamado <code>PathError</code> para describir las fallas que implican una operacion en una ruta de archivo, como <code>Open</code> o <code>Delete</code>, y una variante llamada <code>LinkError</code> para describir los frallos de las operaciones que implican dos rutas de archivos, como <code>Symlink</code> y <code>Rename</code>. Aqui esta <code>os.PathError</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">os</span>

<span class="c1">// PathError registra un error y la operacion y ruta de archivo que lo causo.</span>
<span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Op</span>   <span class="kt">string</span>
  <span class="nx">Path</span> <span class="kt">string</span>
  <span class="nx">Err</span>  <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">PathError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Path</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>La mayoria de los clientes no son conscientes de <code>PathError</code> y el manejo con todos los errores de una manera uniforme llamando a sus metodos de <code>Error</code>. Aunque el metodo <code>Error</code> de <code>PathError</code> forma un mensaje simplemente concatenando los campos, la estructura de <code>PathError</code> conserva los componentes subyacentes del error. Los clientes que necesitan distinguir un tipo de fallo de otro pueden usar una afirmacion de tipo para detectar el tipo especifico del error; el tipo especifico proporciona mas detalle que una simple cadena.</p>
<div class="highlight"><pre><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;/no/such/file&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// &quot;open /no/such/file: No such file or directory&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// Salida:</span>
<span class="c1">// &amp;os.PathError{Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2}</span>
</pre></div>
<p>Asi funcionan las tres funciones auxiliares. Por ejemplo, <code>IsNotExist</code>, que se muestra a continuacion, informa si un error es igual a <code>syscall.ENOENT</code> (<a href="#Seccion-7.8" >§7.8</a>) o al error distinguido <code>os.ErrNotExist</code> (vea <code>io.EOF</code> en la <a href="#Seccion-5.4.2" >§5.4.2</a>), o es un <code>*PathError</code> cuyo error subyacente es uno de esos dos.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;errors&quot;</span>
  <span class="s">&quot;syscall&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">ErrNotExist</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;file does not exist&quot;</span><span class="p">)</span>

<span class="c1">// IsNotExist regresa un booleano que indica si se conoce el error</span>
<span class="c1">// informa que no existe un archivo o directorio. Se satisface por</span>
<span class="c1">// ErrNotExist asi como algunos errores syscall.</span>
<span class="kd">func</span> <span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">pe</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">PathError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">pe</span><span class="p">.</span><span class="nx">Err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ENOENT</span> <span class="o">||</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrNotExist</span>
<span class="p">}</span>
</pre></div>
<p>Y aqui esta en accion:</p>
<div class="highlight"><pre><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;/no/such/file&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
</pre></div>
<p>Por supuesto, la estructura <code>PathError</code> se pierde pierde si el mensaje de error se combina en una cadena mas grande, por ejemplo, mediante una llamada a <code>fmt.Errorf</code>. La discriminacion de errores se debe hacer generalmente inmediatamente despues de la operacion fallida, antes de que un error se propague al llamador.</p>
</div>
<h3 id="Seccion-7.12" >Consultar Comportamientos con Afirmaciones de Tipo de Interfaz</h3>
<div class="hBody-3" >
<p>La siguiente logica es similar a la parte del servidor web <code>net/http</code> responsable de escribir campos de cabecera HTTP como <code>&quot;Content-type: text/html&quot;</code>. El <code>io.Writer</code> <code>w</code> representa la respuesta HTTP; Los bytes escritos en el, se envian en ultima instancia a algun navegador web.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Content-Type: &quot;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">contentType</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Debido a que el metodo <code>Write</code> requiere una slice de bytes, y el valor que desea escribir es una cadena, se requiere una conversion <code>[]byte(...)</code>. Esta conversion asigna memoria y hace una copia, pero la copia se tira casi inmediatamente despues. Vamos a pretender que esta es una parte fundamental del servidor web y que nuestro perfil ha revelado que esta asignacion de memoria se esta ralentizando. ¿Podemos evitar asignar memoria aqui?</p>
<p>La interfaz <code>io.Writer</code> nos informa solo un hecho sobre el tipo concreto que <code>w</code> almacena: que los bytes se pueden escribir en el. Si miramos detras de cortinas del paquete <code>net/http</code>, vemos que el tipo dinamico que <code>w</code> tiene en este programa tambien tiene un metodo <code>WriteString</code> que permite que las cadenas sean escritas eficientemente, evitando la necesidad de asignar una copia temporal. (Esto puede parecer un disparo en la oscuridad, pero una serie de tipos importantes que satisfacen <code>io.Writer</code> tambien tienen un metodo <code>WriteString</code>, incluyendo <code>*bytes.Buffer</code>, <code>*os.File</code> y <code>*bufio.Writer</code>).</p>
<p>No podemos asumir que un <code>w</code> <code>io.Writer</code> arbitrario tambien tiene el metodo <code>WriteString</code>. Pero podemos definir una nueva interfaz que tiene solo este metodo y utilizar una afirmacion de tipo para probar si el tipo dinamico de <code>w</code> satisface esta nueva interfaz.</p>
<div class="highlight"><pre><span></span><span class="c1">// writeString escribe s a w.</span>
<span class="c1">// Si w tiene un metodo WriteString, se invoca en lugar de w.Write.</span>
<span class="kd">func</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">stringWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">WriteString</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">sw</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">stringWriter</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sw</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// evitar copia</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="c1">// almacena una copia temporal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">writeHeader</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentType</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Content-Type: &quot;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">writeString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Para evitar repetirnos a nosotros mismos, hemos movido la comprobacion a la funcion de utilidad <code>writeString</code>, pero es tan util que la libreria estandar la proporciona como <code>io.WriteString</code>. Es la forma recomendada de escribir una cadena a un <code>io.Writer</code>.</p>
<p>Lo curioso en este ejemplo es que no existe una interfaz estandar que defina el metodo <code>WriteString</code> y especifique su comportamiento requerido. Ademas, si un tipo concreto satisface o no la interfaz <code>stringWriter</code> se determina solo por sus metodos, y no por ninguna relacion declarada entre el y el tipo de interfaz. Lo que esto significa es que la tecnica anterior se basa en la suposicion de que <em>si</em> un tipo satisface la interfaz de abajo, <em>entonces</em> <code>WriteString(s)</code> debe tener el mismo efecto que <code>Write([]byte(s))</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
  <span class="nx">WriteString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Aunque <code>io.WriteString</code> documenta su suposicion, pocas funciones que la llaman probablemente documenten que estas tambien hacen el mismo supuesto. Definir un metodo de un tipo particular se toma como un asentimiento implicito para un determinado contrato de comportamiento. Los recien llegados a Go, especialmente aquellos de un fondo en lenguajes fuertemente tipados, pueden encontrar esta falta de intencion explicita inquietante, pero rara vez es un problema en la practica. Con la excepcion de la interfaz vacia <code>interface{}</code>, los tipos de interfaz rara vez son satisfechas por coincidencia involuntaria.</p>
<p>La anterior funcion <code>writeString</code> utiliza una afirmacion de tipo para ver si un valor de un tipo de interfaz general tambien satisface un tipo de interfaz mas especifico, y de ser asi, se utiliza el comportamiento de la interfaz especifica. Esta tecnica se puede poner en uso, sea o no la interfaz a consultar estandar como <code>io.ReadWriter</code> o definida por el usuario como <code>stringWriter</code>.</p>
<p>Tambien es como <code>fmt.Fprintf</code> distingue valores que satisfacen <code>error</code> o <code>fmt.Stringer</code> de todos los demas valores. Dentro de <code>fmt.Fprintf</code>, hay un paso que convierte un unico operando en una cadena, algo asi:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">func</span> <span class="nx">formatOneValue</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">error</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// ...all other types...</span>
<span class="p">}</span>
</pre></div>
<p>Si <code>x</code> satisface cualquiera de las dos interfaces, eso determina el formato del valor. Si no, el caso por defecto maneja todos los demas tipos mas o menos uniformemente usando la reflexion; vamos a averiguar como en el <a href="#Capitulo-12" >Capitulo 12</a>.</p>
<p>De nuevo, esto hace la suposicion de que cualquier tipo con un metodo <code>String</code> satisface el contrato de comportamiento de <code>fmt.Stringer</code>, que es devolver una cadena adecuada para la impresion.</p>
</div>
<h3 id="Seccion-7.13" >Switches de Tipo</h3>
<div class="hBody-3" >
<p>Las interfaces se utilizan en dos estilos distintos. En el primer estilo, ejemplificado por <code>io.Reader</code>, <code>io.Writer</code>, <code>fmt.Stringer</code>, <code>sort.Interface</code>, <code>http.Handler</code> y <code>error</code>, los metodos de una interfaz expresan las similitudes de los tipos concretos que satisfacen la interfaz, pero ocultan los detalles de representacion y operaciones intrinsecas de esos tipos concretos. El enfasis esta en los metodos, no en los tipos concretos.</p>
<p>El segundo estilo explota la capacidad de un valor interfaz para contener valores de una variedad de tipos concretos y considera que la interfaz es la <em>union</em> de esos tipos. Las afirmaciones de tipo se utilizan para discriminar entre estos tipos dinamicamente y tratar cada caso de manera diferente. En este estilo, el enfasis esta en los tipos concretos que satisfacen la interfaz, no en los metodos de la interfaz (si de hecho tiene alguno), y no se oculta la informacion. Vamos a describir interfaces utilizadas de esta manera como los <em>uniones discriminadas</em>.</p>
<p>Si esta familiarizado con la programacion orientada a objetos, es posible reconocer estos dos estilos como <em>polimorfismo de subtipos</em> y el <em>polimorfismo ad hoc</em>, pero no necesita recordar esos terminos. Para el resto de este capitulo, presentaremos ejemplos del segundo estilo.</p>
<p>La API de Go para consultar una base de datos SQL, como las de otros lenguajes, nos permite separar de forma clara la parte fija de una consulta de las partes variables. Un ejemplo de cliente podria tener este aspecto:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;database/sql&quot;</span>

<span class="kd">func</span> <span class="nx">listTracks</span><span class="p">(</span><span class="nx">db</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">artist</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">Exec</span><span class="p">(</span>
    <span class="s">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span><span class="p">,</span>
    <span class="nx">artist</span><span class="p">,</span> <span class="nx">minYear</span><span class="p">,</span> <span class="nx">maxYear</span><span class="p">)</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>El metodo <code>Exec</code> reemplaza cada <code>'?'</code> en la cadena de consulta con un literal SQL que denota el valor del argumento correspondiente, que puede ser un valor booleano, un numero, una cadena, o <code>nil</code>. La construccion de consultas de esta manera ayuda a evitar ataques de inyeccion SQL, en el que un adversario toma el control de la consulta mediante la explotacion de una cita incorrecta de datos de entrada. Dentro de <code>Exec</code>, podriamos encontrar una funcion como la siguiente, que convierte cada valor de argumento para su notacion SQL.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;NULL&quot;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">int</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">uint</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">bool</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">b</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;TRUE&quot;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;FALSE&quot;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// (no se muestra)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T: %v&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Una sentencia <code>switch</code> simplifica una cadena <code>if</code>-<code>else</code> que realiza una serie de pruebas de igualdad de valor. De forma analoga una sentencia <code>switch de tipos</code> simplifica una cadena <code>if</code>-<code>else</code> de afirmaciones de tipo.</p>
<p>En su forma mas simple, un switch de tipos se parece a una sentencia switch ordinaria en la que el operando es <code>x.(type)</code>–esto es, literalmente, la palabra clave <code>type</code>–y cada caso tiene uno o mas tipos. Un conmutador de tipo habilita una ramificacion multidireccional basada en el tipo dinamico del valor de la interfaz. El caso <code>nil</code> coincide si <code>x == nil</code>, y el caso <code>default</code> coincide si lo hace ningun otro caso. Un switch de tipos para <code>sqlQuote</code> tendria estos casos:</p>
<div class="highlight"><pre><span></span><span class="k">switch</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>       <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span> <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>      <span class="c1">// ...</span>
<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>    <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>        <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Al igual que con una sentencia <code>switch</code> ordinaria (<a href="#Seccion-1.8" >§1.8</a>), los casos se consideran en orden y, cuando se encuentra una coincidencia, se ejecuta el cuerpo del caso. El orden de los casos se vuelve significativo cuando uno o mas tipos de casos son interfaces, ya que entonces existe la posibilidad de que dos casos coincidan. La posicion del caso <code>default</code> en relacion con los demas es irrelevante. no esta permitido <code>fallthrough</code>.</p>
<p>Observe que en la funcion original, la logica de los casos <code>bool</code> y <code>string</code> necesita acceso al valor extraido por la afirmacion tipo. Dado que esto es tipico, la instruccion switch de tipo tiene una forma extendida que enlaza el valor extraido con una nueva variable dentro de cada caso:</p>
<div class="highlight"><pre><span></span><span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>Aqui hemos llamado las nuevas variables <code>x</code> tambien; Como con las aserciones de tipo, la reutilizacion de nombres de variables es comun. Al igual que una instruccion <code>switch</code>, un switch de tipo crea implicitamente un bloque lexico, por lo que la declaracion de la nueva variable llamada <code>x</code> no entra en conflicto con una variable <code>x</code> en un bloque externo. Cada <code>case</code> tambien crea implicitamente un bloque lexico independiente.</p>
<p>Reescribiendo <code>sqlQuote</code> para utilizar la forma extendida de un switch de tipo lo hace significativamente mas claro:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sqlQuote</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">&quot;NULL&quot;</span>
  <span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">uint</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// aqui x tiene tipo interface{}.</span>
  <span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;TRUE&quot;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;FALSE&quot;</span>
  <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">sqlQuoteString</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// (no se muestra)</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T: %v&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>En esta version, dentro del bloque de cada caso de tipo unico, la variable <code>x</code> tiene el mismo tipo que el caso. Por ejemplo, <code>x</code> tiene tipo <code>bool</code> dentro del caso <code>bool</code> y <code>string</code> dentro del caso <code>string</code>. En todos los demas casos, <code>x</code> tiene el tipo (interfaz) del <code>switch</code> operante, que es <code>interface{}</code> en este ejemplo. Cuando se requiere la misma accion para varios casos, como <code>int</code> y <code>uint</code>, el switch de tipo hace que sea facil combinarlos.</p>
<p>Aunque <code>sqlQuote</code> acepta un argumento de cualquier tipo, la funcion solo se ejecuta si el tipo del argumento coincide con uno de los casos en el switch de tipo; de lo contrario, entra en panico con un mensaje de <q>tipo inesperado</q>. Aunque el tipo de <code>x</code> es <code>interface{}</code>, lo consideramos una union discriminada de <code>int</code>, <code>uint</code>, <code>bool</code>, <code>string</code>, y <code>nil</code>.</p>
</div>
<h3 id="Seccion-7.14" >Ejemplo: Decodificacion XML Basada en Token</h3>
<div class="hBody-3" >
<p>La <a href="#Seccion-4.5" >Seccion 4.5</a> mostro como decodificar documentos JSON en estructuras de datos Go con las funciones <code>Marshal</code> y <code>Unmarshal</code> del paquete <code>encoding/json</code>. El paquete <code>encoding/xml</code> proporciona una API similar. Este enfoque es conveniente cuando queremos construir una representacion del arbol de documentos, pero eso es innecesario para muchos programas. El paquete <code>encoding/xml</code> tambien proporciona una API de bajo nivel <em>basada en tokens</em> para decodificar XML. En el estilo basada en tokens, el analizador consume la entrada y produce un flujo de tokens, principalmente de cuatro tipos–<code>StartElement</code>, <code>EndElement</code>, <code>CharData</code>, y <code>Comment</code>–cada uno de los cuales es un tipo concreto en el paquete <code>encoding/xml</code>. Cada llamada a <code>(*xml.Decoder).Token</code> devuelve un token.</p>
<p>Las partes relevantes de la API se muestran aqui:</p>
<div class="figure" >
<p class="title"><code>encoding/xml</code></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">xml</span>

<span class="kd">type</span> <span class="nx">Name</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Local</span> <span class="kt">string</span>     <span class="c1">// por ejemplo, &quot;Title&quot; o &quot;id&quot;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Attr</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// por ejemplo, name=&quot;value&quot;</span>
  <span class="nx">Name</span> <span class="nx">Name</span>
  <span class="nx">Value</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Un Token incluye StartElement, EndElement, CharData,</span>
<span class="c1">// y Comment, mas algunos tipos esotericos (no mostrados).</span>
<span class="kd">type</span> <span class="nx">Token</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="kd">type</span> <span class="nx">StartElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">// por ejemplo, &lt;name&gt;</span>
  <span class="nx">Name</span> <span class="nx">Name</span>
  <span class="nx">Attr</span> <span class="p">[]</span><span class="nx">Attr</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">EndElement</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">Name</span> <span class="nx">Name</span> <span class="p">}</span> <span class="c1">// por ejemplo, &lt;/name&gt;</span>
<span class="kd">type</span> <span class="nx">CharData</span> <span class="p">[]</span><span class="kt">byte</span>                 <span class="c1">// por ejemplo, &lt;p&gt;CharData&lt;/p&gt;</span>
<span class="kd">type</span> <span class="nx">Comment</span> <span class="p">[]</span><span class="kt">byte</span>                  <span class="c1">// por ejemplo, &lt;!-- Comment --&gt;</span>

<span class="kd">type</span> <span class="nx">Decoder</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">*</span><span class="nx">Decoder</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Decoder</span><span class="p">)</span> <span class="nx">Token</span><span class="p">()</span> <span class="p">(</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="c1">// regresa el sigiente token en la sequencia</span>
</pre></div>
</div>
<p>La interfaz <code>Token</code>, que no tiene metodos, es tambien un ejemplo de una union discriminada. El proposito de una interfaz tradicional como <code>io.Reader</code> es ocultar los detalles de los tipos concretos que lo satisfagan para que se puedan crear las nuevas implementaciones; cada tipo concreto es tratado uniformemente. Por el contrario, el conjunto de tipos concretos que satisfacen una union discriminada es fijada por el diseño y expuesto, no ocultado. Los tipos de union discriminados tienen pocos metodos; las funciones que actuan sobre ellas se expresan como un conjunto de casos utilizando un switch de tipo, con logica diferente en cada caso.</p>
<p>El programa <code class="command" >xmlselect</code> a continuacion, extrae e imprime el texto encontrado bajo de ciertos elementos en un arbol de documentos XML. Usando la API anterior, puede hacer su trabajo en un solo paso sobre la entrada sin materializar el arbol.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/xmlselect/main.go" >gopl.io/ch7/xmlselect</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Xmlselect imprime el texto de los elemenos seleccionados de un documento XML.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;encoding/xml&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">dec</span> <span class="o">:=</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">NewDecoder</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="kt">string</span> <span class="c1">// stack de nombres de elementos</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">tok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">dec</span><span class="p">.</span><span class="nx">Token</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;xmlselect: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">tok</span> <span class="o">:=</span> <span class="nx">tok</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">StartElement</span><span class="p">:</span>
      <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">tok</span><span class="p">.</span><span class="nx">Name</span><span class="p">.</span><span class="nx">Local</span><span class="p">)</span> <span class="c1">// push</span>
    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">EndElement</span><span class="p">:</span>
      <span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// pop</span>
    <span class="k">case</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">CharData</span><span class="p">:</span>
      <span class="k">if</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s: %s\n&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span> <span class="nx">tok</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// containsAll informa si x contiene los elementos de y, en orden.</span>
<span class="kd">func</span> <span class="nx">containsAll</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
      <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cada vez que el bucle en <code>main</code> encuentra un <code>StartElement</code>, empuja el nombre del elemento en una pila, y para cada <code>EndElement</code> saca el nombre de la pila. La API garantiza que la secuencia de tokens de <code>StartElement</code> y <code>EndElement</code> se correspondan correctamente, incluso en documentos con formato incorrecto. Los <code>Comments</code> se ignoran. Cuando <code>xmlselect</code> encuentra un <code>CharData</code>, imprime el texto solo si la pila contiene todos los elementos nombrados por los argumentos de linea de comandos, en orden.</p>
<p>El siguiente comando imprime el texto de cualquier elemento <code>h2</code> que aparezca debajo de dos niveles de elementos <code>div</code>. Su entrada es la especificacion XML, en un documento XML.</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 <span class="p">|</span>
    ./xmlselect div div h2
html body div div h2: <span class="m">1</span> Introduction
html body div div h2: <span class="m">2</span> Documents
html body div div h2: <span class="m">3</span> Logical Structures
html body div div h2: <span class="m">4</span> Physical Structures
html body div div h2: <span class="m">5</span> Conformance
html body div div h2: <span class="m">6</span> Notation
html body div div h2: A References
html body div div h2: B Definitions <span class="k">for</span> Character Normalization
...
</pre></div>
<p><b>Ejercicio 7.17</b>: Extiende <code class="command" >xmlselect</code> para que los elementos puedan ser seleccionados no solo por su nombre, sino tambien por sus atributos, a la manera de CSS, de modo que, por ejemplo, un elemento como <code>&lt;div id=&quot;page&quot; class=&quot;wide&quot;&gt;</code> podria ser seleccionado encontrando su <code>id</code> o <code>class</code>, asi como su nombre.</p>
<p><b>Ejercicio 7.18</b>: Utilizando el API decodificador basado en token, escribir un programa que lea un documento XML arbitrario y construya un arbol de nodos genericos que lo represente. Los nodos son de dos tipos: los nodos <code>CharData</code> representan cadenas de texto, y los nodos <code>Element</code> representan elementos con nombre y atributos. Cada nodo de elemento tiene un slice de nodos secundarios.</p>
<p>Puede que las siguientes declaraciones sean utiles.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;encoding/xml&quot;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// CharData or *Element</span>

<span class="kd">type</span> <span class="nx">CharData</span> <span class="kt">string</span>

<span class="kd">type</span> <span class="nx">Element</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Type</span>     <span class="nx">xml</span><span class="p">.</span><span class="nx">Name</span>
  <span class="nx">Attr</span>     <span class="p">[]</span><span class="nx">xml</span><span class="p">.</span><span class="nx">Attr</span>
  <span class="nx">Children</span> <span class="p">[]</span><span class="nx">Node</span>
<span class="p">}</span>
</pre></div>
</div>
<h3 id="Seccion-7.15" >Algunos Consejos</h3>
<div class="hBody-3" >
<p>Al diseñar un nuevo paquete, los programadores novatos en Go a menudo comienzan creando un conjunto de interfaces y solo mas tarde definen los tipos concretos que los satisfacen. Este enfoque resulta en muchas interfaces, cada una de las cuales tiene una sola implementacion. No lo hagas. Tales interfaces son abstracciones innecesarias; Tambien tienen un costo de tiempo de ejecucion. Puede restringir que metodos de un tipo o campos de una estructura son visibles fuera de un paquete utilizando el mecanismo de exportacion (<a href="#Seccion-6.6" >§6.6</a>). Las interfaces solo son necesarias cuando hay dos o mas tipos concretos que deben tratarse de manera uniforme.</p>
<p>Hacemos una excepcion a esta regla cuando una interfaz es satisfecha por un solo tipo concreto pero ese tipo no puede vivir en el mismo paquete que la interfaz debido a sus dependencias. En ese caso, una interfaz es una buena manera de desacoplar dos paquetes.</p>
<p>Debido a que las interfaces se usan en Go solo cuando estan satisfechas por dos o mas tipos, necesariamente se abstraen de los detalles de cualquier implementacion en particular. El resultado es interfaces mas pequeños con pocos, metodos mas simples, a menudo, solo como uno con <code>io.Writer</code> o <code>fmt.Stringer</code>. Las interfaces pequeñas son mas faciles de satisfacer cuando aparecen nuevos tipos. Una buena regla de oro para el diseño de interfaces es <em>pedir solo lo que necesitas</em>.</p>
<p>Esto concluye nuestro recorrido de metodos e interfaces. Go tiene un gran soporte para el estilo de programacion orientado a objetos, pero esto no significa que necesite usarlo exclusivamente. No todo debe ser un objeto; Las funciones independientes tienen su lugar, al igual que los tipos de datos no encapsulados. Observe que, en conjunto, los ejemplos en los primeros cinco capitulos de este libro llaman no mas de dos docenas de metodos, como <code>input.Scan</code>, a diferencia de las llamadas de funcion ordinaria como <code>fmt.Printf</code>.</p>
</div>
<h2 id="Capitulo-8" >Gorutinas y Canales</h2>
<div class="hBody-2" >
<p>La programación concurrente, la expresión de un programa como una composición de varias actividades autónomas, nunca ha sido tan importante como lo es hoy en día. Los servidores Web gestionan solicitudes para miles de clientes a la vez. Las aplicaciones de tabletas y teléfonos generan animaciones en la interfaz de usuario al tiempo que realizan simultáneamente solicitudes de cálculo y de red en segundo plano. Incluso los problemas tradicionales de lotes–leer algunos datos, calcular, escribir algo–utilizan concurrencia para ocultar la latencia de operaciones E/S y para explotar los procesadores de una computadora moderna, que cada año crecen en número pero no en velocidad.</p>
<p>Go permite dos estilos de programación concurrente. Este capítulo presenta las goroutines y canales que soportan <em>procesos secuenciales comunicantes</em> o <span class="acronym" >CSP</span>, un modelo de concurrencia en el cual los valores se pasan entre actividades independientes (goroutines) pero las variables están en su mayor parte confinadas a una sola actividad. El <a href="#Capítulo-9" >Capítulo 9</a> cubre algunos aspectos del modelo más tradicional de memoria compartida multihilo, que será familiar si ha utilizado hilos en otros lenguajes populares. El <a href="#Capítulo-9" >Capítulo 9</a> también señala algunos peligros y trampas importantes de la programación concurrente que no profundizaremos en este capítulo.</p>
<p>A pesar de que el soporte de Go para la concurrencia es una de sus grandes fortalezas, el razonamiento sobre los programas concurrentes es intrínsecamente más difícil que los secuenciales, y las intuiciones adquiridas a partir de la programación secuencial pueden a veces desviarnos. Si este es tu primer encuentro con la concurrencia, recomendamos dedicar un poco más de tiempo para pensar en los ejemplos de estos dos capítulos.</p>
</div>
<h3 id="Seccion-8.1" >Gorutinas</h3>
<div class="hBody-3" >
<p>En Go, cada actividad que se ejecuta simultáneamente se denomina <em>gorutina</em>. Considere un programa que tiene dos funciones, una que hace algún cálculo y otra que escribe alguna salida, y asume que ninguna de las dos funciones llama a la otra. Un programa secuencial puede llamar a una función y luego llamar a la otra, pero en un programa <em>concurrente</em> con dos o más gorutinas, las llamadas a <em>ambas</em> funciones pueden estar activas al mismo tiempo. Veremos tal programa en un momento.</p>
<p>Si ha utilizado subprocesos o subprocesos del sistema operativo en otros lenguajes, puede suponer que una gorutina es similar a un subproceso y que podrá escribir programas correctos. Las diferencias entre hilos y gorutinas son esencialmente cuantitativas, no cualitativas, y serán descritas en la <a href="#Sección-9.8" >Sección 9.8</a>.</p>
<p>Cuando un programa inicia, su única goroutine es el que a llama la función <code>main</code>, así que la llamamos la <em>gorutina principal</em>. Las nuevos gorutinas son creados por la declaración <code>go</code>. Sintácticamente, una sentencia <code>go</code> es una función ordinaria o un llamado a un método prefijado por la palabra clave <code>go</code>. Una sentencia <code>go</code> hace que la función sea llamada en una gorutina recién creada. La sentencia <code>go</code> en si misma se completa inmediatamente:</p>
<div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">()</span>    <span class="c1">// llamar a f(); Espera el retorno</span>
<span class="k">go</span> <span class="nx">f</span><span class="p">()</span> <span class="c1">// crea una nueva gorutina que llama a f(); no espera</span>
</pre></div>
<p>En el ejemplo a continuación, la gorutina principal calcula el 45 número de Fibonacci. Dado que utiliza un algoritmo recursivo terriblemente ineficiente, se ejecuta durante un tiempo apreciable, durante el cual nos gustaría proporcionar al usuario una indicación visual de que el programa sigue en ejecución, mediante la visualización de un texto animado <q>spinner</q>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/spinner/main.go" >gopl.io/ch8/spinner</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">spinner</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">n</span> <span class="p">=</span> <span class="mi">45</span>
  <span class="nx">fibN</span> <span class="o">:=</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="c1">// lento</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\rFibonacci(%d) = %d\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fibN</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">spinner</span><span class="p">(</span><span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">`-\|/`</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;\r%c&quot;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Después de varios segundos de animación, la llamada <code>fib(45)</code> regresa y la función <code>main</code> imprime su resultado:</p>
<pre class="pre" >Fibonacci(45) = 1134903170</pre>
<p>Luego regresa la función <code>main</code> principal. Cuando esto sucede, todas las gorutinas terminan abruptamente y el programa sale. Aparte de regresar de <code>main</code> o salir del programa, no hay ninguna forma programática para que una goroutine detenga a otra, pero como veremos más adelante, hay maneras de comunicarse con una gorutina para pedirle que se detenga.</p>
<p>Observe cómo el promaga se expresa como la composición de dos actividades autónomas, <code>spinning</code> y el cálculo de Fibonacci. Cada uno se escribe como una función separada pero ambos hacen progreso simultáneamente.</p>
</div>
<h3 id="Seccion-8.2" >Ejemplo: Servidor de Reloj Concurrente</h3>
<div class="hBody-3" >
<p>El trabajo en red es un dominio natural en el que se utiliza la concurrecia, ya que los servidores suelen manejar muchas conexiones de sus clientes a la vez, cada cliente es esencialmente independiente de los demás. En esta sección, presentaremos el paquete <code>net</code>, que proporciona los componentes para construir programas de cliente y servidor en red que se comunican a través de TCP, UDP o sockets de dominio Unix. El paquete <code>net/http</code> que hemos estado utilizando desde el <a href="#Capitulo-1" >Capitulo 1</a> se construye en la parte superior de las funciones del paquete <code>net</code>.</p>
<p>Nuestro primer ejemplo es un servidor de reloj secuencial que escribe el tiempo actual al cliente una vez por segundo:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/clock1/clock.go" >gopl.io/ch8/clock1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Clock1 es un servidor TCP que escribe periodicamente la hora.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;net&quot;</span>
  <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., coneccion abortada</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// maneja una coneccion a la vez</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Format</span><span class="p">(</span><span class="s">&quot;15:04:05\n&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="c1">// e.g., cliente desconectado</span>
    <span class="p">}</span>
    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La función <code>Listen</code> crea un <code>net.Listener</code>, un objeto que escucha las conexiones entrantes en un puerto de red, en este caso el puerto TCP <code>localhost:8000</code>. El método <code>Accept</code> del oyente se bloquea hasta que se realiza una petición de conexión entrante, y luego devuelve un objeto <code>net.Conn</code> que representa la conexión.</p>
<p>La función <code>handleConn</code> maneja una conexión completa del cliente. En un bucle, escribe el tiempo actual, <code>time.Now()</code>, al cliente. Ya que <code>net.Conn</code> satisface la interfaz <code>io.Writer</code>, podemos escribir en el directamente. El bucle termina cuando falla la escritura, lo más probable es porque el cliente se haya desconectado, momento en el que <code>handleConn</code> cierra su lado de la conexión usando una llamada diferida a <code>Close</code> y vuelve a esperar otra solicitud de conexión.</p>
<p>El método <code>time.Time.Format</code> proporciona una forma de dar formato a la información de fecha y hora por ejemplo. Su argumento es una plantilla que indica la forma de dar formato a un tiempo de referencia, específicamente <code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>. El tiempo de referencia tiene ocho componentes (día de la semana, mes, día del mes, etc.). Cualquier colección de ellos puede aparecer en la cadena <code>Format</code> en cualquier orden y en varios formatos; Los componentes seleccionados de la fecha y la hora se mostrarán en los formatos seleccionados. Aquí estamos usando la hora, minuto y segundo del tiempo. El paquete <code>time</code> define plantillas para muchos formatos de hora estándar, como <code>time.RFC1123</code>. El mismo mecanismo se utiliza a la inversa al analizar un tiempo usando <code>time.Parse</code>.</p>
<p>Para conectarse al servidor, necesitaremos un programa cliente como <code class="command" >nc</code> (<q>netcat</q>), un programa de utilidad estándar para manipular conexiones de red:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/clock1
$ ./clock1 <span class="p">&amp;</span>
$ nc localhost <span class="m">8000</span>
<span class="m">13</span>:58:54
<span class="m">13</span>:58:55
<span class="m">13</span>:58:56
<span class="m">13</span>:58:57
^C
</pre></div>
<p>El cliente muestra el tiempo enviado por el servidor cada segundo hasta que interrumpimos el cliente con Control-C, que en los sistemas Unix se hace eco como <code>^C</code> por el shell. Si <code class="command" >nc</code> o netcat no está instalado en su sistema, puede usar <code class="command" >telnet</code> o esta versión simple de <code class="command" >netcat</code> que utiliza <code>net.Dial</code> para conectarse a un servidor TCP:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/netcat1/netcat.go" >gopl.io/ch8/netcat1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Netcat1 es un cliente TCP de solo lectura.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;net&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Este programa lee datos de la conexión y los escribe en la salida estándar hasta que se produce una condición de fin de archivo o un error. La función <code>mustCopy</code> es una utilidad utilizada en varios ejemplos en esta sección. Vamos a correr dos clientes al mismo tiempo en diferentes terminales, una mostrada a la izquierda y otra a la derecha:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/netcat1
$ ./netcat1
<span class="m">13</span>:58:54
<span class="m">13</span>:58:55
<span class="m">13</span>:58:56
^C
</pre></div>
<div class="highlight"><pre><span></span>$ killall clock1
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<div class="highlight"><pre><span></span>$ ./netcat1

<span class="m">13</span>:58:57
<span class="m">13</span>:58:58
<span class="m">13</span>:58:59
^C
</pre></div>
</div>
</div>
<p>El comando <code class="command" >killall</code> es una utilidad Unix que elimina todos los procesos con el nombre dado.</p>
<p>El segundo cliente debe esperar hasta que finalice el primer cliente porque el servidor es secuencial; Sólo se maneja un cliente a la vez. Sólo se necesita un pequeño cambio para hacer que el servidor sea concurrente: agregar la palabra clave <code>go</code> a la llamada a <code>handleConn</code> hace que cada llamada se ejecute en su propia goroutine.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/clock2/clock.go" >gopl.io/ch8/clock2</a></p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// e.g., connection aborted</span>
    <span class="k">continue</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="c1">// handle connections concurrently</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora, varios clientes pueden recivir el tiempo a la vez:</p>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/clock2
$ ./clock2 <span class="p">&amp;</span>
$ go build gopl.io/ch8/netcat1
$ ./netcat1
<span class="m">14</span>:02:54
<span class="m">14</span>:02:55
<span class="m">14</span>:02:56
<span class="m">14</span>:02:57
<span class="m">14</span>:02:58
<span class="m">14</span>:02:59
<span class="m">14</span>:03:00
<span class="m">14</span>:03:01
^C
</pre></div>
<div class="highlight"><pre><span></span>$ killall clock1
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<div class="highlight"><pre><span></span>$ ./netcat1
<span class="m">14</span>:02:55
<span class="m">14</span>:02:56
^C
</pre></div>
<div class="highlight"><pre><span></span>$ ./netcat1
<span class="m">14</span>:03:00
<span class="m">14</span>:03:01
<span class="m">14</span>:03:02
^C
</pre></div>
</div>
</div>
<p><b>Ejercicio 8.1</b>: Modificar <code class="command" >clock2</code> para aceptar un número de puerto y escribir un programa, <code class="command" >clockwall</code>, que actúe como cliente de varios servidores de reloj a la vez, leyendo los tiempos de cada uno y mostrando los resultados en una tabla, similar a la pared de los relojes que se ven en algunas oficinas de negocios. Si tiene acceso a equipos distribuidos geográficamente, ejecute instancias de forma remota; De lo contrario, ejecute instancias locales en diferentes puertos con zonas horarias falsas.</p>
<div class="highlight"><pre><span></span>$ <span class="nv">TZ</span><span class="o">=</span>US/Eastern    ./clock2 -port <span class="m">8010</span> <span class="p">&amp;</span>
$ <span class="nv">TZ</span><span class="o">=</span>Asia/Tokyo    ./clock2 -port <span class="m">8020</span> <span class="p">&amp;</span>
$ <span class="nv">TZ</span><span class="o">=</span>Europe/London ./clock2 -port <span class="m">8030</span> <span class="p">&amp;</span>
$ clockwall <span class="nv">NewYork</span><span class="o">=</span>localhost:8010 <span class="nv">London</span><span class="o">=</span>localhost:8020 <span class="nv">Tokyo</span><span class="o">=</span>localhost:8030
</pre></div>
<p><b>Ejercicio 8.2</b>: Implementar un servidor de transferencia de archivos simultáneo (FTP). El servidor debe interpretar los comandos de cada cliente como <code class="command" >cd</code> para cambiar el directorio, <code class="command" >ls</code> para listar un directorio, <code class="command" >get</code> para enviar el contenido de un archivo y <code class="command" >close</code> para cerrar la conexión. Puede utilizar el comando <code class="command" >ftp</code> estándar como cliente o escribir el suyo.</p>
</div>
<h3 id="Seccion-8.3" >Ejemplo: Servidor Echo Concurrente</h3>
<div class="hBody-3" >
<p>El servidor de reloj utiliza una gorutina por conexión. En esta sección, crearemos un servidor de eco que utiliza múltiples gorutinas por conexión. La mayoría de los servidores de eco simplemente escriben lo que lean, lo que se puede hacer con esta trivial versión de <code>handleConn</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// NOTA: Ignorando errores</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>Un servidor de eco más interesante podría simular las reverberaciones de un eco real, con la respuesta fuerte al principio (<code>&quot;HELLO!&quot;</code>), Luego moderado (<code>&quot;¡Hello!&quot;</code>) después de un retraso, luego callado (<code>&quot;¡hola!&quot;</code> como en esta versión de <code>handleConn</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/reverb1/reverb.go" >gopl.io/ch8/reverb1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">shout</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">shout</span><span class="p">)</span>
  <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">shout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// NOTE: ignoring potential errors from input.Err()</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Necesitaremos actualizar nuestro programa cliente para que envíe la entrada del terminal al servidor mientras copia la respuesta del servidor a la salida, lo que presenta otra oportunidad de utilizar la concurrencia:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/netcat2/netcat.go" >gopl.io/ch8/netcat2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">go</span> <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mientras la gorutina principal lee la entrada estándar y la envía al servidor, una segunda gorutina lee e imprime la respuesta del servidor. Cuando la gorutina principal encuentra el final de la entrada, por ejemplo, después de que el usuario teclee Control-D (<code>^D</code>) en el terminal (o el equivalente Control-Z en Microsoft Windows), el programa se detiene, incluso si el otra gorutina aun tiene trabajo que hacer. (Veremos cómo hacer que el programa espere a que ambos lados terminen una vez que hayamos introducido los canales en <a href="#Sección-8.4.1" >Sección 8.4.1</a>.)</p>
<p>En la siguiente sesión, la entrada del cliente está alineada a la izquierda y las respuestas del servidor tienen indentacion. El cliente grita en el servidor de eco tres veces:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/reverb1
$ ./reverb1 <span class="p">&amp;</span>
$ go build gopl.io/ch8/netcat2
$ ./netcat2
Hello?
    HELLO?
    Hello?
    hello?
Is there anybody there?
    IS THERE ANYBODY THERE?
Yooo-hooo!
    Is there anybody there?
    is there anybody there?
    YOOO-HOOO!
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb1
</pre></div>
<p>Tenga en cuenta que el tercer grito del cliente no se maneja hasta que el segundo grito se ha agotado, lo que no es muy realista. Un eco real consistiría en la <em>composición</em> de los tres gritos independientes. Para simularlo, necesitaremos más goroutines. Una vez más, todo lo que tenemos que hacer es añadir la palabra clave <code>go</code>, esta vez a la llamada a <code>eco</code></p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/reverb2/reverb.go" >gopl.io/ch8/reverb2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">(),</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// NOTA: Ignorando errores potenciales de input.Err()</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los argumentos a la función iniciada por <code>go</code> se evalúan cuando se ejecuta la instrucción <code>go</code>; Así <code>input.Text()</code> se evalúa en la gorutina principal. Ahora los ecos son simultáneos y se superponen en el tiempo:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/reverb2
$ ./reverb2 <span class="p">&amp;</span>
$ ./netcat2
Is there anybody there?
    IS THERE ANYBODY THERE?

Yooo-hooo!
    Is there anybody there?
    YOOO-HOOO!
    is there anybody there?
    Yooo-hooo!
    yooo-hooo!
^D
$ killall reverb2
</pre></div>
<p>Todo lo que se requería para hacer que el servidor utilizara la concurrencia, no sólo para manejar las conexiones de varios clientes, sino incluso dentro de una sola conexión, era la inserción de dos palabras clave.</p>
<p>Sin embargo, al agregar estas palabras clave, tuvimos que considerar cuidadosamente que métodos de <code>net.Conn</code> es seguro llamar simultáneamente, lo cual no es cierto para la mayoría de los tipos. Discutiremos el concepto crucial de la seguridad de la concurrencia en el próximo capítulo.</p>
</div>
<h3 id="Seccion-8.4" >Canales</h3>
<div class="hBody-3" >
<p>Si las gorutinas son las actividades concurrentes de un programa Go, los <em>canales</em> son las conexiones entre ellas. Un canal es un mecanismo de comunicacion que permite a un gorutina enviar valores a otra gorutina. Cada canal es un conducto para los valores de un tipo particular, llamado canal de <em>tipo canal</em>. El tipo de un canal cuyos elementos tienen tipo <code>int</code> se escribe <code>chan int</code>.</p>
<p>Para crear un canal, se utiliza la funcion nativa <code>make</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ch tiene tipo &#39;chan int&#39;</span>
</pre></div>
<p>Al igual que con los mapas, un canal es una referencia a la estructura de datos creada por <code>make</code>. Cuando copiamos un canal o pasamos uno como argumento a una funcion, estamos copiando una referencia, de modo que el llamador y el receptor llaman a la misma estructura de datos. Como con otros tipos de referencia, el valor cero de un canal es <code>nil</code>.</p>
<p>Dos canales del mismo tipo pueden compararse usando <code>==</code>. La comparacion es verdadera si ambas son referencias a la misma estructura de datos de canal. Un canal puede tambien ser comparado con <code>nil</code>.</p>
<p>Un canal tiene dos operaciones principales, <em>enviar</em> y <em>recibir</em>, conocidas colectivamente como <em>comunicaciones</em>. Una sentencia de envio transmite un valor de una gorutina, a traves del canal, a otra gorutina ejecutando una expresion de recepcion correspondiente. Ambas operaciones se escriben utilizando el operador <code>&lt;-</code>. En una declaracion de envio, el <code>&lt;-</code> separa los operandos de canal y de valor. En una expresion de recepcion, <code>&lt;-</code> precede al operando del canal. Una expresion de recepcion cuyo resultado no se utiliza es una sentencia valida.</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">x</span>  <span class="c1">// una sentencia de envio</span>

<span class="nx">x</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">// una sentencia de recepcion en una instruccion de asignacion</span>
<span class="o">&lt;-</span><span class="nx">ch</span>     <span class="c1">// una sentencia de recepcion; el resultado se descarta</span>
</pre></div>
<p>Los canales soportan una tercera operacion, <em>cierre</em>, que establece una bandera que indica que no se eviaran mas valores en este canal; los intentos subsiguientes de envio seran panico. Las operaciones de recepcion en un canal cerrado generan los valores que se han enviado hasta que no quedan mas valores; Cualquier operacion de recepcion se completa inmediatamente y produce el valor cero del tipo de elemento del canal.</p>
<p>Para cerrar un canal, que llamamos la funcion nativa <code>close</code>:</p>
<div class="highlight"><pre><span></span><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</pre></div>
<p>Un canal creado con una simple llamada a <code>make</code> se denomina un canal <em>sin bufer</em>, pero <code>make</code> acepta un segundo argumento opcional, un entero llamado la <em>capacidad</em> del canal. Si la capacidad es distinta de cero, <code>make</code> crea un canal <em>con bufer</em>.</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    <span class="c1">// canal sin bufer</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// canal sin bufer</span>
<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// canal cor bufer con capacidad 3</span>
</pre></div>
<p>Veremos primero los canales sin bufer y canales con buffer en la <a href="#Seccion-8.4.4" >Seccion 8.4.4</a>.</p>
</div>
<h4 id="Seccion-8.4.1" >Canales sin Buffer</h4>
<div class="hBody-4" >
<p>Una operacion de envio en un canal sin bufer, bloquea la gorutina enviada hasta que otra gorutina ejecute una recepcion correspondiente en el mismo canal, momento en el que se transmite el valor y ambas gorutinas pueden continuar. Por el contrario, si la operacion de recepcion se intento en primer lugar, la gorutina de recepcion se bloquea hasta que otra gorutina realice un envio en el mismo canal.</p>
<p>La comunicacion a traves de un canal sin bufer hace que las gorutinas de envio y recepcion se sincronicen. Debido a esto, los canales sin bufer a veces se llaman canales sincronos. Cuando se envia un valor en un canal sin bufer, la recepcion del valor <em>ocurre antes</em> del re-despertar de la gorutina enviada.</p>
<p>En discusiones de concurrencia, cuando decimos <em>x sucede antes de y</em>, no queremos decir simplemente que <em>x</em> ocurre antes en el tiempo que <em>y</em>; queremos decir que esta garantizado para hacerlo y que todos sus efectos anteriores, como actualizaciones a las variables, estan completos y que usted puede confiar en ellos.</p>
<p>Cuando <em>x</em> no ocurre antes de <em>y</em> ni despues <em>y</em>, decimos que <em>x es concurrente con y</em>. Esto no significa que <em>x</em> e <em>y</em> son necesariamente simultaneas, simplemente que no podemos asumir nada acerca de su ordenacion. Como veremos en el siguiente capitulo, es necesario ordenar ciertos eventos durante la ejecucion del programa para evitar los problemas que surgen cuando dos gorutinas acceden simultaneamente a la misma variable.</p>
<p>El programa cliente en la <a href="#Seccion-8.3" >Seccion 8.3</a> copia la entrada al servidor en su gorutina principal, por lo que el programa cliente termina tan pronto como la corriente de entrada se cierra, incluso si la gorutina de fondo continua trabajando. Para hacer que el programa espere a que la gorutina de fondo se complete antes de salir, usamos un canal para sincronizar las dos gorutinas:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/netcat3/netcat.go" >gopl.io/ch8/netcat3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Dial</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">conn</span><span class="p">)</span> <span class="c1">// NOTA: ignorando errores</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>       <span class="c1">// señala la gorutina principal</span>
  <span class="p">}()</span>
  <span class="nx">mustCopy</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
  <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="o">&lt;-</span><span class="nx">done</span> <span class="c1">// espera a que la gorutina de fondo termine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cuando el usuario cierra el flujo de entrada estandar, <code>mustCopy</code> regresa y la gorutina principal llama a <code>conn.Close()</code>, cerrando las dos mitades de la conexion de red. Cerrar la mitad de escritura de la conexion hace que el servidor vea una condicion de fin de archivo. Cerrar la mitad de leectura hace que la gorutina de fondo llame a <code>io.Copy</code> para devolver <q>error de lectura por conexion cerrada</q>, por lo que hemos eliminado el registro de errores; El ejercicio 8.3 sugiere una mejor solucion. (Observe que la sentencia go llama a una funcion literal, una construccion comun.)</p>
<p>Antes de que regrese, la gorutina de fondo registra un mensaje, luego envia un valor en el canal <code>done</code>. La gorutina principal espera hasta que haya recibido este valor antes de volver. Como resultado, el programa siempre registra el mensaje <q>done</q> antes de salir.</p>
<p>Los mensajes enviados a traves de canales tienen dos aspectos importantes. Cada mensaje tiene un valor, pero a veces el hecho de la comunicacion y el momento en que ocurre son igualmente importantes. Llamamos a los mensajes <em>eventos</em> cuando se quiere hacer hincapie en este aspecto. Cuando el evento no contiene informacion adicional, es decir, su unico proposito es la sincronizacion, vamos a enfatizar esto mediante el uso de un canal cuyo tipo de elemento es <code>struct{}</code>, aunque es comun el uso de un canal de <code>bool</code> o <code>int</code> para el mismo proposito, ya <code>done &lt;- 1</code> es mas corto que <code>done &lt;- struct{}{}</code>.</p>
<p><b>Ejercicio 8.3</b>: En <code class="command" >netcat3</code>, el valor de interfaz <code>conn</code> tiene el tipo concreto <code>*net.TCPConn</code>, lo que representa una conexion TCP. Una conexion TCP se compone de dos mitades que pueden ser cerradas de forma independiente utilizando sus metedos <code>CloseRead</code> y <code>CloseWrite</code>. Modifica la gorutina principal de <code class="command" >netcat3</code> para cerrar solo la mitad de escritura de la conexion para que el programa continue imprimiendo los ultimos ecos del servidor <code class="command" >reverb1</code> incluso despues de que la entrada estandar ha sido cerrada. (Hacer esto para el servidor <code class="command" >reverb2</code> es mas dificil; Consulte el Ejercicio 8.4.)</p>
</div>
<h4 id="Seccion-8.4.2" >Tuberias</h4>
<div class="hBody-4" >
<p>Los canales se pueden utilizar para conectar gorutinas a la vez, de modo que la salida de una sea la entrada a otra. Esto se llama una tuberia. El programa siguiente consta de tres gorutas conectadas por dos canales, como se muestra esquematicamente en la Figura 8.1.</p>
<div class="figure" >
<p class="title">Figura 8.1. Una tuberia de tres etapas.</p>
<figure>
<img src="img/Figure-8.1.jpg" />
</figure>
</div>
<p>La primer gorutina, <em>counter</em>, genera los numeros enteros 0, 1, 2, ..., y los envia sobre un canal a la segunda gorutina, <em>squarer</em>, que recibe cada valor, optiene su cuadrado, y envia el resultado a traves de otro canal a la tercer gorutina, <em>printer</em>, que recibe los valores al cuadrado y los imprime. Para mayor claridad de este ejemplo, hemos elegido intencionalmente funciones muy simples, aunque por supuesto son demasiado computacionalmente triviales para justificar sus propias gorutinas en un programa realista.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/pipeline1/main.go" >gopl.io/ch8/pipeline1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="c1">// Counter</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Squarer</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
      <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}()</span>

  <span class="c1">// Printer (in main goroutine)</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">squares</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como es de esperar, el programa imprime la serie infinita de cuadrados 0, 1, 4, 9 y asi sucesivamente. Pipelines como este se pueden encontrar en los programas de servidor de larga duracion donde los canales se utilizan para la comunicacion a lo largo de la vida entre gorutinas que contienen bucles infinitos. Pero ¿y si queremos enviar solo un numero finito de valores a traves de la tuberia?</p>
<p>Si el remitente sabe que nunca se enviaran valores adicionales en un canal, es util comunicar este hecho a las gorutinas receptor para que puedan dejar de esperar. Esto se logra cerrando el cierre utilizando la funcion nativa <code>close</code>:</p>
<div class="highlight"><pre><span></span><span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
</pre></div>
<p>Despues de que se haya cerrado un canal, cualquier otra operacion de envio se pondra en panico. Despues de que el canal cerrado ha sido drenado, es decir, despues de que el ultimo elemento enviado ha sido recibido, todas las operaciones subsigientes de recepcion se llevaran a cabo si bloqueo, pero daran un valor cero. Cerrar el canal <code>naturals</code> haria que el bucle de cuadrados girara mientras recive un flujo interminable de valores cero que recibe un flujo interminable de valores cero, y enviar estos ceros a la impresora.</p>
<p>No hay manera de probar directamente si un canal ha sido cerrado, pero hay una variante de la operacion de recepcion que produce dos resultados: el elemento de canal recibido, ademas de un valor booleano, convencionalmente llamado <code>ok</code>, que es <code>true</code> para una recepcion exitosa y <code>false</code> para una recepcion en un canal cerrado y drenado. Usando esta caracteristica, podemos modificar el bucle de <code>squares</code> para parar cuando el canal <code>naturals</code> se drene y cerrar el canal <code>squares</code> a su vez.</p>
<div class="highlight"><pre><span></span><span class="c1">// Squarer</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">naturals</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
      <span class="k">break</span> <span class="c1">// el canal estaba cerrado y drenado</span>
    <span class="p">}</span>
    <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}()</span>
</pre></div>
<p>Debido a que la sintaxis anterior es torpe y este patron es comun, el lenguaje nos permite utilizar un bucle <code>range</code> para iterar a traves de canales tambien. Esta es una sintaxis mas conveniente para recibir todos los valores enviados en un canal y finalizar el bucle despues del ultimo.</p>
<p>En la tuberia de abajo, cuando la gorutina <code>counter</code> termina su bucle despues de 100 elementos, se cierra el canal <code>naturals</code>, haciendo que <code>squarer</code> termine su bucle y cerrar el canal <code>squares</code>. (En un programa mas complejo, podria tener sentido para el contador y las funciones de <code>squarer</code> con llamadas diferidas a <code>close</code> desde el principio.) Por ultimo, la gorutina principal termina su bucle y el programa se cierra.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/pipeline2/main.go" >gopl.io/ch8/pipeline2</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="c1">// Counter</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">naturals</span> <span class="o">&lt;-</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Squarer</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">naturals</span> <span class="p">{</span>
      <span class="nx">squares</span> <span class="o">&lt;-</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Printer (in main goroutine)</span>
  <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">squares</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>No es necesario cerrar cada canal cuando haya terminado con el. Solo es necesario cerrar un canal cuando es importante decir a los receptores que todos los datos han sido enviados. Un canal que el recolector de basura determine que no puede ser alcanzado tendra sus recursos recuperados, independientemente de si esta o no cerrado. (No hay que confundir esto con la operacion de cierre de los archivos abiertos. Es importante llamar al metodo <code>Close</code> en todos los archivos cuando haya terminado con ellos.)</p>
<p>Intentar cerrar un canal ya cerrado provoca un panico, al igual que el cierre de un canal nil. El cierre de los canales tiene otro uso como un mecanismo de difusion, que cubriremos en la <a href="#Seccion-8.9" >Seccion 8.9</a>.</p>
</div>
<h4 id="Seccion-8.4.3" >Tipos de Canal Unidireccional</h4>
<div class="hBody-4" >
<p>A medida que los programas crecen, es natural dividir grandes funciones en piezas mas pequeñas. Nuestro ejemplo anterior utiliza tres gorutinas, comunicandoce a traves de dos canales, que eran variables locales de <code>main</code>. El programa se divide naturalmente en tres funciones:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>
<p>La funcion <code>squarer</code>, situada en el centro de la tuberia, toma dos parametros, el canal de entrada y el canal de salida. Ambos tienen el mismo tipo, pero sus usos previstos son opuestas: <code>in</code> es solo para ser recibida desde, y <code>out</code> es solo para enviar a. Los nombres <code>in</code> y <code>out</code> transmiten esta intencion, pero aun asi, nada impide que <code>squarer</code> enviar enviar a <code>in</code> o recibir desde <code>out</code>.</p>
<p>Esta disposicion es tipica. Cuando un canal se suministra como un parametro de funcion, es casi siempre con la intencion de que se utilice exclusivamente para enviar o exclusivamente para recibir.</p>
<p>Para documentar esta intencion y evitar el mal uso, el sistema de tipos Go proporciano tipos de canale <em>unidireccionales</em> que exponen solo una u otra de las operaciones de envio y recepcion. El tipo <code>chan&lt;- int</code>, un canal <em>solo de envio</em> de <code>int</code>, permite envio pero no recepcion. Por el contrario, el tipo <code>&lt;-chan int</code>, <code>&lt;-chan int</code> un canal solo de recepcion de <code>int</code>, permite recivir pero enviar. (La posicion de la flecha <code>&lt;-</code> en relacion con la palabra clave <code>chan</code> es un mnemonico. Las infracciones de esta disciplina se detectan en tiempo de compilacion.</p>
<p>Dado que la operacion <code>close</code> asegura que no se produciran mas envios en un canal, solo el envio de gorutina esta en una posicion llamarlo, y por esta razon es un error en tiempo de compilacion intentar cerrar un canal solo de recepcion.</p>
<p>Esta es la tuberia de <code>squaring</code> una vez mas, esta vez con canales unidireccionales:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/pipeline3/main.go" >gopl.io/ch8/pipeline3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">x</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
    <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">v</span> <span class="o">*</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printer</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">naturals</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">squares</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="k">go</span> <span class="nx">counter</span><span class="p">(</span><span class="nx">naturals</span><span class="p">)</span>
  <span class="k">go</span> <span class="nx">squarer</span><span class="p">(</span><span class="nx">squares</span><span class="p">,</span> <span class="nx">naturals</span><span class="p">)</span>
  <span class="nx">printer</span><span class="p">(</span><span class="nx">squares</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La llamada <code>counter(naturals)</code> convierte implicitamente <code>naturals</code>, en un valor de tipo <code>chan int</code>, con el tipo del parametro, <code>chan&lt;- int</code>. La llamada <code>printer(squares)</code> hace una conversion implicita a <code>&lt;-chan int</code>. Las conversiones de tipos de canal bidireccionales a unidireccionales se permiten en cualquier asignacion. Sin embargo, no hay vuelta atras: una vez que tenga un valor de un tipo unidireccional como <code>chan&lt;- int</code>, no hay forma de obtener de el un valor de tipo <code>chan int</code> que se refiera a la misma estructura de datos del canal..</p>
</div>
<h4 id="Seccion-8.4.4" >Buffered Channels</h4>
<div class="hBody-4" >
<p>un canal almacenado en bufer tiene una cola de elementos. El tamaño maximo de la cola se determina cuando se crea, por el argumento de capacidad de <code>make</code>. La declaracion siguiente crea un canal de buffer capaz de mantener tres valores <code>string</code>. La Figura 8.2 es una representacion grafica de <code>ch</code> y el canal al que se refiere.</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<div class="figure" >
<p class="title">Figura 8.2. Un canal de buffer vacio.</p>
<figure>
<img src="img/Figure-8.2.jpg" />
</figure>
</div>
<p>Una operacion de envio en un canal de buffer inserta un elemento en la parte posterior de la cola, y una operacion de recepcion elimina un elemento del frente. Si el canal esta lleno, la operacion de envio bloquea su canal hasta que el espacio sea puesto a disposicion por otro receptor de gorutina. Por el contrario, si el canal esta vacio, una operacion de recepcion se bloquea hasta que un valor es enviado por otro canal.</p>
<p>Podemos enviar hasta tres valores en este canal sin bloquear la gorutina:</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;A&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;B&quot;</span>
<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;C&quot;</span>
</pre></div>
<p>En este punto, el canal esta lleno (Figura 8.3), y una cuarta sentencia de envio lo bloquearia.</p>
<div class="figure" >
<p class="title">Figura 8.3. Un canal completo con bufer.</p>
<figure>
<img src="img/Figure-8.3.jpg" />
</figure>
</div>
<p>Si recibimos un valor,</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;A&quot;</span>
</pre></div>
<p>El canal no esta lleno ni vacio (Figura 8.4), de modo que una operacion de envio o de recepcion podria continuar sin bloquear. De esta manera, el bufer del canal desacopla los canales de envio y recepcion de gorutinas.</p>
<div class="figure" >
<p class="title">Figura 8.4. Un canal parcialmente almacenado en buffer.</p>
<figure>
<img src="img/Figure-8.3.jpg" />
</figure>
</div>
<p>En el caso improbable de que un programa necesita saber la capacidad de buffer del canal, se puede obtener llamando a la funcion nawiva <code>cap</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;3&quot;</span>
</pre></div>
<p>Cuando se aplica a un canal, la funcion nativa <code>len</code> devuelve el numero de elementos actualmente almacenados en el buffer. Ya que en un programa concurrente esta informacion es probable que sea obsoleta tan pronto como se recupera, su valor es limitado, pero podria ser util durante el diagnostico de fallos u optimizacion de rendimiento.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span> <span class="c1">// &quot;2&quot;</span>
</pre></div>
<p>Despues de dos operaciones de recepcion mas, el canal esta vacio de nuevo, y un cuarto podria bloquearlo:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;B&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &quot;C&quot;</span>
</pre></div>
<p>En este ejemplo, las operaciones de envio y recepcion fueron todas realizadas por la misma gorutina, pero en programas reales generalmente son ejecutadas por gorutinas diferentes. Los principiantes a veces se sienten tentados a usar canales de buffer dentro de una unica gorutina como una cola, atraidos por su sintaxis agradablemente sencilla, pero esto es un error. Los canales estan profundamente conectados con la programacion de las gorutas, y sin que otra gorutina que recibe del canal, un remitente –y tal vez todo el programa–corre el riesgo de quedar bloqueado para siempre. Si todo lo que necesita es una simple cola, haga una utilizando un slice.</p>
<p>El siguiente ejemplo muestra una aplicacion de un canal con bufer. Se realiza solicitudes paralelas a tres <code>mirrors</code>, es decir, servidores equivalente pero geograficamente distribuidos. Envia sus respuestas a traves de un canal con bufer, luego recibe y devuelve solo la primer respuesta, que es la mas rapida en llegar. Por lo tanto <code>mirroredQuery</code> devuelve un resultado incluso antes de que los dos servidores mas lentos han respondido. (Por cierto, es normal que varias gorutinas envien valores al mismo canal de forma concurrente, como en este ejemplo, o para recibir del mismo canal).</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">mirroredQuery</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">responses</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;asia.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;europe.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">responses</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">(</span><span class="s">&quot;americas.gopl.io&quot;</span><span class="p">)</span> <span class="p">}()</span>
  <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">responses</span> <span class="c1">// devuelve la respuesta mas rapida</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">request</span><span class="p">(</span><span class="nx">hostname</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">response</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>Si hubieramos utilizado un canal sin bufer, las dos gorutinas mas lentos se habrian atascado tratando de enviar sus respuestas en un canal del cual ninguna gorutina jamas recibira. Esta situacion, denominada una <em>fuga de gorutina</em>, seria un error. A diferencia de las variables basura, las gorutinas filtradas no se recogen automaticamente, por lo que es importante asegurarse de que las gorutinas terminan cuando ya no se necesitan.</p>
<p>La eleccion entre canales con o sin bufer, y la eleccion de la capacidad de un canal con bufer, pueden afectar a la correccion de un programa. Los canales sin bufer proporcionan mayores garantias de sincronizacion porque cada operacion de envio se sincroniza con su recepcion correspondiente; Con canales con buffer, estas operaciones se desacoplan. Ademas, cuando conocemos un limite superior en el numero de valores que se enviaran en un canal, no es inusual crear un canal con buffer de ese tamaño y realizar todos los envios antes de que se reciba el primer valor. Si no se asigna suficiente capacidad de buffer, el programa se bloqueara.</p>
<p>Los canales con buffer tambien puede afectar el rendimiento del programa. Imaginese tres cocineros en una pasteleria, una horno, y un frigorifico y otra decorando cada pastel antes de pasarlo al siguiente cocinero en la linea de montaje. En una cocina con poco espacio, cada cocinero que ha terminado un pastel debe esperar a que el cocinero siguiente este listo para aceptarlo; Esta cita es analoga a la comunicacion a traves de un canal sin bufer.</p>
<p>Si hay espacio para un pastel entre cada cocinero, un cocinero puede colocar un pastel terminado alli e inmediatamente comenzar a trabajar en el siguiente; Esto es analogo a un canal con buffer con capacidad 1. Mientras los cocineros trabajen aproximadamente a la misma velocidad en promedio, la mayoria de estos traspasos proceden rapidamente, suavizando las diferencias transitorias en sus respectivas velocidades. Mas espacio entre los cocineros–buffers mas grandes–puede suavizar las variaciones transitorias mas grandes en sus tarifas sin parar la linea de ensamblaje, tal como sucede cuando un cocinero toma una pequeño descanso, luego se apresura para alcanzar a los demas.</p>
<p>Por otro lado, si una etapa anterior de la linea de montaje es consistentemente mas rapida que la siguiente etapa, el buffer entre ellos pasara la mayor parte de su tiempo lleno. Por el contrario, si la etapa posterior es mas rapida, el bufer estara normalmente vacio. Un buffer no proporciona ningun beneficio en este caso.</p>
<p>La metafora de la linea de montaje es util para los canales y gorutinas. Por ejemplo, si la segunda etapa es mas elaborada, un solo cocinero puede no ser capaz de mantenerse al dia con el suministro del primer cocinero o satisfacer la demanda del tercero. Para resolver el problema, podriamos contratar a otro cocinero para ayudar al segundo, realizando la misma tarea pero trabajando independientemente. Esto es analogo a crear otra gorutina que se comunica sobre los mismos canales.</p>
<p>No tenemos espacio para mostralo aqui, pero el paquete <code>gopl.io/ch8/cake</code> simula esta pasteleria, con varios parametros que se pueden variar. Incluye comparativas (<a href="#Seccion-11.4" >§11.4</a>) para algunos de los escenarios descritos anteriormente.</p>
</div>
<h3 id="Seccion-8.5" >Bucle en Paralelo</h3>
<div class="hBody-3" >
<p>En esta seccion, exploraremos algunos patrones de concurrencia comunes para ejecutar todas las iteraciones de un bucle en paralelo. Consideraremos el problema de producir imagenes en miniatura de un conjunto de imagenes de tamaño completo. El paquete <code>gopl.io/ch8/thumbnail</code> proporciona un funcion <code>ImageFile</code> que puede escalar una sola imagen. No vamos a mostrar su implementacion, pero se puede descargar desde <a href="http://www.gopl.io/" >gopl.io</a>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/thumbnail/thumbnail_test.go" >gopl.io/ch8/thumbnail</a></p>
<div class="highlight"><pre><span></span><span class="c1">// ImageFile lee una imagen de infile y escribe</span>
<span class="c1">// una version en miniatura de la misma en el mismo directorio.</span>
<span class="c1">// Devuelve el nombre del archivo generado, por ejemplo. &quot;foo.thumb.jpeg&quot;.</span>
<span class="kd">func</span> <span class="nx">ImageFile</span><span class="p">(</span><span class="nx">infile</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>El siguiente programa realiza un bucle sobre una lista de nombres de archivo de imagen y produce una miniatura para cada uno:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/thumbnail/thumbnail_test.go" >gopl.io/ch8/thumbnail</a></p>
<div class="highlight"><pre><span></span><span class="c1">// makeThumbnails crea miniaturas de los archivos especificados.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Obviamente, el orden en que procesamos los archivos no importa, ya que cada operacion de escalado es independiente de todas los demas. Problemas como este que consisten enteramente de subproblemas que son completamente independientes entre si se describen como <em>vergonzosamente paralelos</em>.  Los problemas vergonzosamente paralelos son el tipo mas facil para implementar concurrencia y disfrutar de un rendimiento que linealmente escala con la cantidad de paralelismo.</p>
<p>Vamos a ejecutar todas estas operaciones en paralelo, ocultando asi la latencia de la E/S de archivos y el uso de varias CPU para los calculos de escalado de imagen. Nuestro primer intento de una version concurrente solo añade una palabras clave <code>go</code>. Ignoraremos los errores por ahora y los abordaremos mas adelante.</p>
<div class="highlight"><pre><span></span><span class="c1">// NOTA: incorrecto!</span>
<span class="kd">func</span> <span class="nx">makeThumbnails2</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTA: ignorando errores</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Esta version se ejecuta realmente rapido–demasiado rapido, de hecho, tarda menos tiempo que el original, incluso cuando la porcion de nombres de archivo contiene solo un elemento. Si no hay paralelismo, ¿como puede la version concurrente posiblemente correr mas rapido? La respuesta es que <code>makeThumbnails</code> regresa antes de que haya terminado de hacer lo que tenia que hacer. Comienza todas las gorutinas, una por cada nombre de archivo, pero no espera a que terminen.</p>
<p>No hay manera directa de esperar hasta que una gorutina haya terminado, pero podemos cambiar la gorutina interior para reportar su terminacion a la gorutina exterior enviando un acontecimiento en un canal compartido. Dado que sabemos que hay exactamente <code>len(filenames)</code> gorutinas interiores, la gorutina exterior solo necesita contar estos eventos antes de que regresar:</p>
<div class="highlight"><pre><span></span><span class="c1">// makeThumbnails3 crea miniaturas de los archivos especificados en paralelo.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails3</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTA: ignorando errores</span>
      <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Esperar a que los gourutines terminen</span>
  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="o">&lt;-</span><span class="nx">ch</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Notese que pasamos el valor de f como argumento explicito a la funcion literal en lugar de utilizar la declaracion de <code>f</code> envolviendo el bucle <code>for</code>:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="c1">// NOTA: incorrecto!</span>
    <span class="c1">// ...</span>
  <span class="p">}()</span>
<span class="p">}</span>
</pre></div>
<p>Recordemos que el problema de la capturar la variable del bucle dentro de una funcion anonima, se describe en la <a href="#Seccion-5.6.1" >Seccion 5.6.1</a>. Arriba, la unica variable <code>f</code> es compartida por todos los valores de la funcion anonima y actualizado por sucesivas iteraciones del bucle. Por el momento las nuevas gorutinas comenzar a ejecutar la funcion literal, el bucle <code>for</code> puede tener actualizada <code>f</code> e iniciar otra iteracion o (mas probablemente) terminado en su totalidad, por lo que cuando estas gorutinas leen el valor de <code>f</code>, todas ellas observan tener el valor del elemento final del slice. Mediante la adicion de un parametro explicito, nos aseguramos de que se utiliza el valor de <code>f</code> actual cuando se ejecuta la sentencia <code>go</code>.</p>
<p>¿Que pasa si queremos devolver los valores de cada trabajador a la principal? Si la llamada a <code>thumbnail.ImageFile</code> no puede crear un archivo, se devuelve un error. La proxima version de <code>makeThumbnails</code> devuelve el primer error que recibe de cualquiera de las operaciones de escalado:</p>
<div class="highlight"><pre><span></span><span class="c1">// makeThumbnails4 crea miniaturas de los archivos especificados en paralelo.</span>
<span class="c1">// Devuelve un error si ocurrio alguno.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails4</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">errors</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="nx">errors</span> <span class="o">&lt;-</span> <span class="nx">err</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errors</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span> <span class="c1">// NOTA: incorrecto: fuga de gorutina!</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Esta funcion tiene un error sutil. Cuando encuentra el primer error no nil, se devuelve el error al llamador, sin dejar drenado la gorutina de canal <code>errors</code>. Cada gorutina trabajador restante se bloqueara para siempre cuando intente enviar un valor en ese canal, y nunca terminara. Esta situacion, una fuga de gorutina (<a href="#Seccion-8.4.4" >§8.4.4</a>), puede hacer que todo el programa se atasque o se quede sin memoria.</p>
<p>La solucion mas sencilla es utilizar un canal con capacidad suficiente que ningun trabajador bloqueara cuando envie un mensaje. (Una solucion alternativa es crear otro canal para drenar el canal, mientras que la gorutina principal devuelve el primer error sin demora).</p>
<p>La siguiente version de <code>makeThumbnails</code> utiliza un canal tamponada para devolver los nombres de los archivos de imagen generados junto con cualquier error.</p>
<div class="highlight"><pre><span></span><span class="c1">// makeThumbnails5 crea miniaturas de los archivos especificados en paralelo.</span>
<span class="c1">// Devuelve los errores de archivo generados en un orden arbitrario,</span>
<span class="c1">// o un error si algun paso falla.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails5</span><span class="p">(</span><span class="nx">filenames</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">thumbfiles</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">thumbfile</span> <span class="kt">string</span>
    <span class="nx">err</span>       <span class="kt">error</span>
  <span class="p">}</span>

  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">filenames</span><span class="p">))</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">it</span> <span class="nx">item</span>
      <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">it</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="nx">it</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
    <span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">thumbfiles</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">thumbfiles</span><span class="p">,</span> <span class="nx">it</span><span class="p">.</span><span class="nx">thumbfile</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">thumbfiles</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Nuestra version final de <code>makeThumbnails</code>, a continuacion, devuelve el numero total de bytes ocupados por los nuevos archivos. A diferencia de las versiones anteriores, sin embargo, recibe los nombres de archivo no como un slice sino a traves de un canal de cadenas, por lo que no podemos predecir el numero de iteraciones del bucle.</p>
<p>Para saber cuando ha terminado la ultima gorutina (que puede no ser el ultimo en comenzar), necesitamos incrementar un contador antes de que cada gorutina comience y decrementarlo cuando cada gorutina termine. Esto exige un tipo especial de contador, que se puede manipular con seguridad desde multiples gorutinas y que proporciona una manera de esperar hasta que se convierte en cero. Este tipo de contador se conoce como <code>sync.WaitGroup</code>, y el codigo siguiente muestra como usarlo:</p>
<div class="highlight"><pre><span></span><span class="c1">// makeThumbnails6 crea miniaturas de los archivos especificados en paralelo.</span>
<span class="c1">// Devuelve el numero de bytes ocupados por los archives que crea.</span>
<span class="kd">func</span> <span class="nx">makeThumbnails6</span><span class="p">(</span><span class="nx">filenames</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
  <span class="nx">sizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// numero de gorutinas de trabajo</span>
  <span class="k">for</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">filenames</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">// trabajador</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">f</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
      <span class="nx">thumb</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">thumbnail</span><span class="p">.</span><span class="nx">ImageFile</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="nx">info</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">thumb</span><span class="p">)</span> <span class="c1">// OK para ignorar el error</span>
      <span class="nx">sizes</span> <span class="o">&lt;-</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}(</span><span class="nx">f</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// closer</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">sizes</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
  <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sizes</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">size</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</pre></div>
<p>Observe la asimetria en los metodos <code>Add</code> y <code>Done</code>. <code>Add</code>, que incrementa el contador, debe ser llamado antes de que el trabajador empiece la gorutina, no dentro de ella; de lo contrario no estariamos seguros de que el <code>Add</code> <em>ocurre antes</em> antes de que la gorutina <q>close</q> llame a <code>Wait</code>. Ademas, <code>Add</code> toma un parametro, pero <code>Done</code> no; que es equivalente a <code>Add(-1)</code>. Utilizamos <code>defer</code> para asegurar que el contador se decrementa incluso en el caso de error. La estructura del codigo anterior es un patron comun e idiomatico para realizar bucle en paralelo cuando no conocemos el numero de iteraciones.</p>
<p>El canal <code>sizes</code> lleva cada tamaño de archivo de nuevo a la gorutina principal, que recibe de ellos usando un range de bucle y calcula la suma. Observamos como creamos un gorutina mas cerca que espera a los trabajadores para terminar antes de cerrar el canal <code>sizes</code>. Estas dos operaciones, <q>wait</q> y <q>close</q>, deben ser concurrentes con el bucle sobre <code>sizes</code>. Consideremos las alternativas: si la operacion de espera se coloca en la goruta principal antes del bucle, nunca terminaria, y si se colocaba despues del bucle, seria inalcanzable ya que sin nada cerrando el canal, el bucle nunca terminaria.</p>
<p>La Figura 8.5 ilustra la secuencia de eventos en la funcion <code>makeThumbnails6</code>. Las lineas verticales representan gorutinas. Los segmentos delgados indican el sueño, los segmentos gruesos actividad. Las flechas diagonales indican eventos que sincronizan una gorutina con otra. El tiempo fluye hacia abajo. Notese como la gorutina principal pasa la mayor parte de su tiempo en el range de bucle dormido, esperando a que un trabajador para enviar un valor o el mas cerca para cerrar el canal.</p>
<div class="figure" >
<p class="title">Figura 8.5. La secuencia de eventos en <code>makeThumbnails6</code>.</p>
<figure>
<img src="img/Figure-8.5.jpg" />
</figure>
</div>
<p><b>Ejercicio 8.4</b>: Modificar el servidor <code class="command" >reverb2</code> para utilizar un <code>sync.WaitGroup</code> por conexion para contar el numero de gorutinas <code>echo</code> activas. Cuando cae a cero, cierre la mitad de escritura de la conexion TCP como se describe en el Ejercicio 8.3. Compruebe que su cliente <code class="command" >netcat3</code> modificado de ese ejercicio espera los ecos finales de varios gritos simultaneos, incluso despues de la entrada estandar ha sido cerrada.</p>
<p><b>Ejercicio 8.5</b>: Tome un programa secuencial CPU dependiente existente, tal como el programa de Mandelbrot de la <a href="#Seccion-3.3" >Seccion 3.3</a> o el calculo de superficie 3-D de la <a href="#Seccion-3.2" >Seccion 3.2</a>, y ejecutar su bucle principal utilizando canales paralelos para la comunicacion. ¿Cuanto mas rapido se ejecuta en una maquina multiprocesador? ¿Cual es el numero optimo de gorutinas a usar?</p>
</div>
<h3 id="Seccion-8.6" >Ejemplo: Rastreador Web Concurrente</h3>
<div class="hBody-3" >
<p>En la <a href="#Seccion-5.6" >Seccion 5.6</a>, hicimos un simple rastreador web que exploro el grafico de enlace de la web con primer onden de amplitud. En esta seccion, lo haremos concurrente para que las llamadas independientes a <code>crawl</code> puedan explotar el paralelismo de E/S disponible en la web. la funcion <code>crawl</code> sigue siendo exactamente como lo fue en <code>gopl.io/ch5/findlinks3</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/crawl1/findlinks.go" >gopl.io/ch8/crawl1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion principal se asemeja a <code>breadthFirst</code> (<a href="#Seccion-5.6" >§5.6</a>). Como antes, una lista de trabajo registra la cola de elementos que necesitan procesamiento, cada elemento que es una lista de URL para rastrear, pero esta vez, en lugar de representar la cola utilizando un slice, usamos un canal. Cada llamada al <code>crawl</code> se produce en su propia gorutina y envia los enlaces que descubre de nuevo a la lista de trabajo.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

  <span class="c1">// Comiencza con los argumentos de la linea de comandos.</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Rastrea la red concurrentemente.</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Observe que la gouritina de rastreo toma <code>link</code> como un parametro explicito para evitar el problema de captura de variables de bucle que vimos por primera vez en la <a href="#Seccion-5.6.1" >Seccion 5.6.1</a>. Observe tambien que el envio inicial de los argumentos de linea de comandos a la lista de trabajo debe ejecutarse en su propia gorutina para evitar un <em>punto muerto</em>, una situacion en la cual tanto la gorutina principal y como la gorutina de rastreo intentan enviarse el uno al otro mientran que ninguno esta recibiendo. Una solucion alternativa seria utilizar un canal con buffer.</p>
<p>El rastreador ahora es altamente concurrente e imprime una tormenta de direcciones URL, pero tiene dos problemas. El primer problema se manifiesta como mensajes de error en el registro despues de unos segundos de operacion:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/crawl1
$ ./crawl1 http://gopl.io/
http://gopl.io/
https://golang.org/help/

https://golang.org/doc/
https://golang.org/blog/
...
<span class="m">2015</span>/07/15 <span class="m">18</span>:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
<span class="m">2015</span>/07/15 <span class="m">18</span>:22:12 Get ...: dial tcp <span class="m">23</span>.21.222.120:443: socket: too many open files
...
</pre></div>
<p>El mensaje inicial de error es un informe sorprendente de un fallo de busqueda de DNS para un dominio confiable. El mensaje de error siguiente revela la causa: el programa a creado tantas conexiones de red a la vez que se supero el limite por proceso en el numero de archivos abiertos, haciendo que operaciones como las busquedas de DNS y la llama a <code>net.Dial</code> empiecen a fallar.</p>
<p>El programa es demasiado paralelo. El paralelismo ilimitado rara vez es una buena idea ya que siempre hay un factor limitante en el sistema, como el numero de nucleos de CPU para cargas de trabajo de calculo, el numero de husos y cabeceras para operaciones de E/S de disco local, el ancho de banda de la red para descargas de streaming, o la capacidad de servicio de un servicio web. La solucion es limitar el numero de usos paralelos del recurso para que coincida con el nivel de paralelismo que esta disponible. Una manera sencilla de hacerlo en nuestro ejemplo es asegurarse de que no hay mas de <em>n</em> llamadas a <code>links.Extract</code> activas a la vez, donde <em>n</em> esta comodamente inferior que el descriptor de ficheros limite–20 por ejemplo. Esto es analogo a la manera en que un portero en un club nocturno atestado admite a un huesped solamente cuando algun otro huesped sale.</p>
<p>Podemos limitar el paralelismo utilizando un canal con buffer de capacidad <em>n</em> para modelar una concurrencia primitiva denominada <em>semaforo contador</em>.</p>
<p>Conceptualmente, cada una de las <em>n</em> ranuras vacantes en el buffer del canal representa una señal que autoriza al titular a proceder. Enviar un valor al canal adquiere un token, y recibir un valor del canal libera un token, creando una nueva ranura vacante. Esto asegura que a la mayoria de los <em>n</em> envios puedan producirse sin una recepcion intermedia. (Aunque podria ser mas intuitivo tratar las ranuras <em>ocupadas</em> en canal con bufer como tokens, utilizando ranuras vacias evita la necesidad de llenar el buffer.) Dado que el tipo de elemento de canal no es importante, vamos a utilizar <code>struct{}</code>, Que tiene el tamaño cero.</p>
<p>Vamos a reescribir la funcion <code>crawl</code> para que la llamada a <code>links.Extract</code> se encuentre entre corchetes por las operaciones de adquirir y liberar un token, asegurando asi que a lo sumo 20 llamadas activas al mismo tiempo. Es una buena practica mantener las operaciones de semaforo lo mas cerca posible de la operacion de E/S que regulan.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/crawl2/findlinks.go" >gopl.io/ch8/crawl2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// tokens es un semaforo de conteo usado para</span>
<span class="c1">// imponer un limite de 20 petiones concurrentes.</span>
<span class="kd">var</span> <span class="nx">tokens</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">tokens</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// aquirir un token</span>
  <span class="nx">list</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">Extract</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="o">&lt;-</span><span class="nx">tokens</span>             <span class="c1">// liberar el token</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">list</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El segundo problema es que el programa nunca termina, incluso cuando ha descubierto todos los enlaces accesibles desde las URLs iniciales. (Por supuesto, es poco probable que note este problema a menos que elija las URL inicialmente o implemente la caracteristica de limitacion de profundidad del Ejercicio 8.6). Para que el programa termine, necesitamos romper el bucle principal cuando la lista de trabajo este <em>y</em> no existan gorutinas de rastreo activas.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span> <span class="c1">// numero de envios pendientes a la lista de trabajo</span>

  <span class="c1">// Start with the command-line arguments.</span>
  <span class="nx">n</span><span class="o">++</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Rastradeor web concurrente.</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">list</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">worklist</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">n</span><span class="o">++</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">link</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">link</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>En esta version, el contador <code>n</code> mantiene un registro del numero de envios a la lista de trabajo que aun esta por ocurrir. Cada vez que sabemos que un elemento necesita ser enviado a la lista de trabajo, incrementamos <code>n</code>, una vez antes de enviar los argumentos iniciales de linea de comandos, y de nuevo cada vez que se inicie una gorutina rastreador. El bucle principal termina cuando <code>n</code> cae a cero, ya que no hay mas trabajo por hacer.</p>
<p>Ahora el rastreador concurrente se ejecuta aproximadamente 20 veces mas rapido que el rastreador primero con primer orden de amplitud de la <a href="#Seccion-5.6" >Seccion 5.6</a>, sin errores, y termina correctamente si se debe completar su tarea.</p>
<p>El siguiente programa muestra una solucion alternativa al problema de la concurrencia excesiva. Esta version utiliza la funcion de rastreo original que no tiene semaforo de conteo, sino que la llama desde una de las 20 rutinas de rastreo de larga duracion, garantizando asi que al menos 20 solicitudes HTTP esten activas simultaneamente.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/crawl3/findlinks.go" >gopl.io/ch8/crawl3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">worklist</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>  <span class="c1">// lista de URLs, puede tener duplicados</span>
  <span class="nx">unseenLinks</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// URLs desduplicadas</span>

  <span class="c1">// Agrega argumentos de linea de comandos a la lista de trabajo.</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">}()</span>

  <span class="c1">// Crea 20 gorutinas de rastreo para buscar cada enlace no visto.</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">unseenLinks</span> <span class="p">{</span>
        <span class="nx">foundLinks</span> <span class="o">:=</span> <span class="nx">crawl</span><span class="p">(</span><span class="nx">link</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">worklist</span> <span class="o">&lt;-</span> <span class="nx">foundLinks</span> <span class="p">}()</span>
      <span class="p">}</span>
    <span class="p">}()</span>
  <span class="p">}</span>

  <span class="c1">// La gorutina principal desduplica los elementos de la lista de trabajo</span>
  <span class="c1">// y envia los no vistos a los rastreadores.</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">list</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">worklist</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">link</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">seen</span><span class="p">[</span><span class="nx">link</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">unseenLinks</span> <span class="o">&lt;-</span> <span class="nx">link</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Las gorutinas de rastreo son todas alimentadas por el mismo canal, <code>unseenLinks</code>.  la gorutina principal es responsable de deduplicar los elementos que recibe de la lista de trabajo, y luego enviar cada enlace no visto sobre el canal <code>unseenLinks</code> a un gorutina rastreador.</p>
<p>El mapa <code>seen</code> esta <em>confinado</em> dentro de la gorutina principal; Es decir, solo puede ser accedido por ese gorutina. Al igual que otras formas de ocultar la informacion, el confinamiento nos ayuda a razonar sobre la correccion de un programa. Por ejemplo, las variables locales no pueden mencionarse por su nombre fuera de la funcion en la que se declaran; variables que no escapan (<a href="#Seccion-2.3.4" >§2.3.4</a>) de una funcion no se puede acceder desde fuera de esa funcion; Y los campos encapsulados de un objeto no se puede acceder excepto por los metodos de ese objeto. En todos los casos, la ocultacion de la informacion ayuda a limitar las interacciones no deseadas entre partes del programa.</p>
<p>Los enlaces encontrados por <code>crawl</code> se envian a la lista de trabajo desde una gorutina dedicada para evitar un punto muerto.</p>
<p>Para ahorrar espacio, no hemos abordado el problema de la terminacion en este ejemplo.</p>
<p><b>Ejercicio 8.6</b>: Añadir limite de profundidad al rastreador concurrente. Es decir, si el usuario establece <code>-depth=3</code>, entonces solo se obtendran las URL accesibles como un maximo de tres enlaces.</p>
<p><b>Ejercicio 8.7</b>: Escribir un programa concurrente que cree un espejo local de un sitio web, obteniendo cada pagina accesible y escribiendola en un directorio en el disco local. Solo se deben buscar las paginas dentro del dominio original (por ejemplo, <a href="https://golang.org" >golang.org</a>). Las URL de las paginas reflejadas deben modificarse segun sea necesario para que se refieran a la pagina reflejada, no al original.</p>
</div>
<h3 id="Seccion-8.7" >Multiplexacion con <code>select</code></h3>
<div class="hBody-3" >
<p>El programa a continuacion realiza la cuenta atras para un lanzamiento de cohetes. la funcion <code>time.Tick</code> devuelve un canal en el que se envia eventos periodicamente, actuando como un metronomo. El valor de cada evento es una marca de tiempo, pero rara vez es tan interesante como el hecho de su entrega.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/countdown1/countdown.go" >gopl.io/ch8/countdown1</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.&quot;</span><span class="p">)</span>
  <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
    <span class="o">&lt;-</span><span class="nx">tick</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora vamos a añadir la capacidad de abortar la secuencia de lanzamiento presionando la tecla de retorno durante la cuenta atras. En primer lugar, empezamos un gorutina que intenta leer un solo byte de la entrada estandar y, si tiene exito, envia un valor en un canal llamado <code>abort</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/countdown2/countdown.go" >gopl.io/ch8/countdown2</a></p>
<div class="highlight"><pre><span></span><span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// lee un solo byte</span>
  <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}()</span>
</pre></div>
</div>
<p>Ahora cada iteracion del bucle de cuenta atras tiene que esperar a que un evento llegue a uno de los dos canales: el canal tinker si todo esta bien (<q>nominal</q> en la jerga de la NASA) o un evento de aborto si hubo una anomalia. No podemos recibir solo de cada canal porque cualquiera de las operaciones que intentamos primero bloqueara hasta su finalizacion. Necesitamos multiplexar estas operaciones, y para ello, necesitamos una (sentencia de selecion).</p>
<div class="highlight"><pre><span></span><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
  <span class="c1">// ...</span>
<span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
  <span class="c1">// ...use x...</span>
<span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">:</span>
  <span class="c1">// ...</span>
<span class="k">default</span><span class="p">:</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>La forma general de una sentencia <code>select</code> se muestra arriba. Al igual que una sentencia <code>switch</code>, tiene un numero de casos y una opcion <code>default</code>. Cada caso especifica una comunicacion (un envio o recepcion en el algun canal) y un bloque asociado de los estados. Una expresion de recepcion puede aparecer por si misma, como en el primer caso, o dentro de una declaracion de variable compacta, como en el segundo caso; La segunda forma le permite referirse al valor recibido.</p>
<p>Un <code>select</code> espera hasta que una comunicacion por algun caso esta lista para proceder. A continuacion, realiza esa comunicacion y ejecuta las declaraciones asociadas del caso; Las otras comunicaciones no suceden. Un <code>select</code> sin casos, <code>select{}</code>, espera por siempre.</p>
<p>Volvamos a nuestro programa de lanzamiento de cohetes. la funcion <code>time.After</code> devuelve inmediatamente un canal, e inicia una nueva gorutina que envia un unico valor en ese canal despues del tiempo especificado. La instruccion de seleccion a continuacion espera hasta que llegue el primero de dos eventos, ya sea un evento de anulacion o el evento que indica que han transcurrido 10 segundos. Si pasan 10 segundos sin abortar, el lanzamiento continua.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...crear canal abort...</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown. Press return to abort.&quot;</span><span class="p">)</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
    <span class="c1">// no hacer nada.</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>El siguiente ejemplo es mas sutil. El canal <code>ch</code>, cuyo bufer es de tamaño 1, esta alternativamente vacio y luego lleno, por lo que solo uno de los casos puede proceder, ya sea enviando cuando <em>i</em> es par, o bien recibiendo cuando <code>i</code> es impar. Siempre imprime <code>0 2 4 6 8</code>.</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span>
  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Si varios casos estan listos, <code>select</code> toma uno al azar, lo que asegura que cada canal tiene la misma probabilidad de ser seleccionado. Aumentar el tamaño del bufer del ejemplo anterior hace que su salida no sea determinista, porque cuando el bufer no esta lleno ni vacio, la sentencia <code>select</code> en sentido figurado arroja una moneda.</p>
<p>Hagamos que nuestro programa de lanzamiento imprima la cuenta regresiva. La siguiente instruccion <code>select</code> hace que cada iteracion del bucle espere hasta 1 segundo para un aborto, pero no mas.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/countdown3/countdown.go" >gopl.io/ch8/countdown3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...crear canal abort...</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Commencing countdown.  Press return to abort.&quot;</span><span class="p">)</span>
  <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
      <span class="c1">// no hacer nada.</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Launch aborted!&quot;</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">launch</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>la funcion <code>time.Tick</code> se comporta como si se crea un gorutina que llama a <code>time.Sleep</code> en un bucle, enviando un evento cada vez que se despierta. Cuando la funcion de cuenta atras regresa, se detiene la recepcion de eventos de <code>tick</code>, pero la gorutina ticker sigue  alli, tratando en vano de enviar en un canal desde el que no esta recibiendo gorutina–una fuga de gorutina (<a href="#Seccion-8.4.4" >§8.4.4</a>).</p>
<p>la funcion <code>Tick</code> es conveniente, pero es apropiada solo cuando se necesitan los ticks durante todo el tiempo de vida de la aplicacion. De lo contrario, deberiamos usar este patron:</p>
<div class="highlight"><pre><span></span><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">NewTicker</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

<span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span>    <span class="c1">// recibir desde el canal tiker</span>

<span class="nx">ticker</span><span class="p">.</span><span class="nx">Stop</span><span class="p">()</span> <span class="c1">// hace que la gorutina tiker termine</span>
</pre></div>
<p>A veces queremos intentar enviar o recibir en un canal, pero evitando el bloqueo si el canal no esta listo–una comunicacion <em>no bloqueante</em>. Una sentencia <code>select</code> puede hacer eso tambien. Un <code>select</code> pueden tener un caso <code>default</code> que especifica que hacer cuando ninguna de las otras comunicaciones puede proceder de inmediato.</p>
<p>La instruccion <code>select</code> a continuacion recibe un valor del canal <code>abort</code> si hay uno para recibir; De lo contrario no hace nada. Se trata de una operacion de recepcion no bloqueante; haciendolo repetidamente se denomina un canal de <em>sondeo</em>.</p>
<div class="highlight"><pre><span></span><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Launch aborted!\n&quot;</span><span class="p">)</span>
  <span class="k">return</span>
<span class="k">default</span><span class="p">:</span>
  <span class="c1">// no hacer nada</span>
<span class="p">}</span>
</pre></div>
<p>El valor cero para un canal es <code>nil</code>. Tal vez sorprendentemente, los canales nil a veces son utiles. Debido a que las operaciones de envio y recepcion en un bloque de canal nil, nunca se selecciona un caso en una sentencia <code>select</code> cuyo canal es <code>nil</code>. Esto nos permite utilizar <code>nil</code> para activar o desactivar los casos que corresponden a caracteristicas como el manejo de tiempos de espera o cancelacion, en respuesta a otros eventos de entrada o de salida que emite. Veremos un ejemplo en la siguiente seccion.</p>
<p><b>Ejercicio 8.8</b>: Utilizando una instruccion <code>select</code>, agregue un tiempo de espera al servidor de eco de la <a href="#Seccion-8.3" >Seccion 8.3</a> para que se desconecte cualquier cliente que no grite nada en 10 segundos.</p>
</div>
<h3 id="Seccion-8.8" >Ejemplo: Trayecto de Directorio Concurrente</h3>
<div class="hBody-3" >
<p>En esta seccion, vamos a construir un programa que informa del uso de disco de uno o mas directorios especificados en la linea de comandos, como el comando Unix <code class="command" >du</code>. La mayor parte de su trabajo es realizado por la funcion <code>walkDir</code> a continuacion, que enumera las entradas del directorio <code>dir</code> utilizando la funcion auxiliar <code>dirents</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/du1/main.go" >gopl.io/ch8/du1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// walkDir camina recursivamente el arbol de archivos raiz en dir</span>
<span class="c1">// y envia el tamaño de cada archivo encontrado en fileSize.</span>
<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
      <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// dirents devuelve las entradas del directorio dir.</span>
<span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="nx">entries</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadDir</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;du1: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">entries</span>
<span class="p">}</span>
</pre></div>
</div>
<p>la funcion <code>ioutil.ReadDir</code> devuelve una slice de <code>os.FileInfo</code>–la misma informacion que una llamada a <code>os.Stat</code> regresa para un solo archivo. Para cada subdirectorio, <code>walkDir</code> se llama a si misma recursivamente, y para cada archivo, <code>walkDir</code> envia un mensaje en el canal <code>fileSizes</code>. El mensaje es el tamaño del archivo en bytes.</p>
<p>La funcion principal, que se muestra a continuacion, utiliza dos gorutinas. La gorutina de fondo se llama <code>walkDir</code> por cada directorio especificado en la linea de comandos y finalmente cierra el canal <code>fileSizes</code>. la gorutina principal calcula la suma de los tamaños del archivo que recibe del canal y finalmente imprime el total.</p>
<div class="highlight"><pre><span></span><span class="c1">// El comando du1 calcula el uso de disco de los archivos en el directorio.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;flag&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io/ioutil&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;path/filepath&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Determina los directorios iniciales.</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="nx">roots</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">()</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">roots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">roots</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;.&quot;</span><span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Recorre el arbol de archivos.</span>
  <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
      <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}()</span>

  <span class="c1">// Imprime los reslutados.</span>
  <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
  <span class="k">for</span> <span class="nx">size</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
    <span class="nx">nfiles</span><span class="o">++</span>
    <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
  <span class="p">}</span>
  <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d files %.1f GB\n&quot;</span><span class="p">,</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">nbytes</span><span class="p">)</span><span class="o">/</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Este programa hace una pausa durante mucho tiempo antes de imprimir su resultado:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/du1
$ ./du1 <span class="nv">$HOME</span> /usr /bin /etc
<span class="m">213201</span> files <span class="m">62</span>.7 GB
</pre></div>
<p>El programa seria mas agradable si nos mantiene informados de su progreso. Sin embargo, simplemente moviendo el llamada a <code>printDiskUsage</code> en el bucle, lo haria que imprimir miles de lineas de salida.</p>
<p>La variante de <code class="command" >du</code> a continuacion, imprime los totales de forma periodica, pero solo si se especifica la bandera <code>-v</code> ya que no todos los usuarios querra ver mensajes de progreso. la gorutina de fondo que se repite sobre <code>roots</code> se mantiene sin cambios. la gorutina principal ahora utiliza un <code>ticker</code> para generar acontecimientos cada 500ms, y una declaracion <code>select</code> para esperar un mensaje del tamaño del archivo, en cuyo caso actualiza el total, o un evento tick, en cuyo caso imprime el total actual. Si no se especifica la bandera <code>-v</code>, el canal <code>tick</code> sigue siendo nil, y en efecto se desactiva en su caso en el <code>select</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/du2/main.go" >gopl.io/ch8/du2</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">verbose</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;show verbose progress messages&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...inicia gorutina de fondo...</span>

  <span class="c1">// Imprime el resultado periodicamente.</span>
  <span class="kd">var</span> <span class="nx">tick</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="k">if</span> <span class="o">*</span><span class="nx">verbose</span> <span class="p">{</span>
    <span class="nx">tick</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span> <span class="kt">int64</span>
<span class="nx">loop</span><span class="p">:</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">break</span> <span class="nx">loop</span> <span class="c1">// fileSizes es cerrado</span>
      <span class="p">}</span>
      <span class="nx">nfiles</span><span class="o">++</span>
      <span class="nx">nbytes</span> <span class="o">+=</span> <span class="nx">size</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
      <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">printDiskUsage</span><span class="p">(</span><span class="nx">nfiles</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">)</span> <span class="c1">// total final</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Dado que el programa ya no utiliza una bucle <code>range</code>, el primer caso <code>select</code> debe probar explicitamente si el canal <code>fileSizes</code> se ha cerrado, utilizando la forma de dos resultado de recepcion de operacion. Si el canal se ha cerrado, el programa rompe fuera del bucle. Las sentencia <code>break</code> rompe la etiqueta tanto en <code>selec</code> y el bucle <code>for</code>; una marcada <code>break</code> no etiquetada saldria solo fera de <code>select</code>, haciendo que el bucle comience la siguiente iteracion.</p>
<p>El programa ahora nos da un flujo de actualizaciones:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/du2
$ ./du2 -v <span class="nv">$HOME</span> /usr /bin /etc
<span class="m">28608</span> files <span class="m">8</span>.3 GB
<span class="m">54147</span> files <span class="m">10</span>.3 GB
<span class="m">93591</span> files <span class="m">15</span>.1 GB
<span class="m">127169</span> files <span class="m">52</span>.9 GB
<span class="m">175931</span> files <span class="m">62</span>.2 GB
<span class="m">213201</span> files <span class="m">62</span>.7 GB
</pre></div>
<p>Sin embargo, todavia toma demasiado tiempo para terminar. No hay ninguna razon por la cual todas las llamadas a <code>walkDir</code> no se pueden hacer al mismo tiempo, explotando de esta manera el paralelismo en el disco del sistema. La tercera version de <code class="command" >du</code>, a continuacion, crea una nueva gorutina para cada llamada a <code>walkDir</code>. Se utiliza un <code>sync.WaitGroup</code> (<a href="#Seccion-8.5" >§8.5</a>) para contar el numero de llamadas a <code>walkDir</code> que aun estan activas, y una gorutina mas cerca para cerrar el canal <code>fileSizes</code> cuando el contador llega a cero.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/du3/main.go" >gopl.io/ch8/du3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...determina roots...</span>

  <span class="c1">// Recorre cada raiz del arbol de archivos en paralelo.</span>
  <span class="nx">fileSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int64</span><span class="p">)</span>
  <span class="kd">var</span> <span class="nx">n</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">root</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">roots</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">fileSizes</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="c1">// ...bucle select...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">subdir</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
      <span class="k">go</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">subdir</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">fileSizes</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fileSizes</span> <span class="o">&lt;-</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">Size</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ya que este programa crea miles de gorutinas en su apogeo, tenemos que cambiar <code>dirents</code> para utilizar un semaforo contador para evitar que se abran demasiados archivos a la vez, tal como lo hicimos para el rastreador web en la <a href="#Seccion-8.6" >Seccion 8.6</a>:</p>
<div class="highlight"><pre><span></span><span class="c1">// sema es un semaforo de conteo para limitar la concurrencia en dirents</span>
<span class="kd">var</span> <span class="nx">sema</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">20</span><span class="p">)</span>

<span class="c1">// dirents devuelve las entradas de directorio dir</span>
<span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
  <span class="c1">// adquirir token</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// liberar token</span>
  <span class="c1">// ...</span>
</pre></div>
<p>Esta version se ejecuta varias veces mas rapido que la anterior, aunque hay mucha variabilidad de sistema a sistema.</p>
<p><b>Ejercicio 8.9</b>: Escribir una version de <code class="command" >du</code> que calcule y muestre periodicamente totales separados para cada una de los directorios <code>root</code>.</p>
</div>
<h3 id="Seccion-8.9" >Cancelacion</h3>
<div class="hBody-3" >
<p>A veces necesitamos instruir a una gorutina para que detenga lo que esta haciendo, por ejemplo, en un servidor web que realiza un calculo en nombre de un cliente que se ha desconectado.</p>
<p>No hay manera de que una gorutina termine directamente a otra, ya que dejaria todas sus variables compartidas en estados indefinidos. En el programa de lanzamiento de cohetes (<a href="#Seccion-8.7" >§8.7</a>) enviamos un solo valor en un canal llamado <code>abort</code>, que la gorutina de cuenta regresiva interpreto como una peticion para detenerse. Pero ¿y si necesitamos cancelar dos gorutinas, o un numero arbitrario?</p>
<p>Una posibilidad podria ser la de enviar tantos eventos en el canal <code>abort</code> como gorutinas haya que cancelar. Sin embargo, si algunas de las gorutinas ya se han terminado, nuestra cuenta sera demasiado grande, y nuestros envios quedaran atascados. Por otra parte, si esas gorutinas han generado otros gorutinas, nuestra cuenta sera demasiado pequeña, y algunas gorutinas permaneceran inconscientes de la cancelacion. En general, es dificil saber cuantos gorutinas estan trabajando en nuestro nombre en un momento dado. Ademas, cuando un gorutina recibe un valor del canal <code>abort</code>, consume ese valor para que otros gorutinas no lo vean. Para la cancelacion, lo que necesitamos es un mecanismo fiable para <em>transmitir</em> un evento sobre un canal de modo que muchos gorutinas puedan verlo <em>tal</em> como ocurre y ver mas tarde que <em>ha</em> ocurrido.</p>
<p>Recuerde que despues de que un canal ha sido cerrado y drenado de todos los valores enviados, las operaciones de recepcion posteriores proceden inmediatamente, dando valores cero. Podemos explotar esto para crear un mecanismo de difusion: no enviar un valor en el canal, cerrarlo.</p>
<p>Podemos agregar la cancelacion al programa <code class="command" >du</code> de la seccion anterior con algunos cambios simples. En primer lugar, creamos un canal de cancelacion en el que no se envian valores, pero cuyo cierre indica que es hora de que el programa detenga lo que esta haciendo. Tambien definimos una funcion de utilidad, <code>cancelled</code>, que verifica o sondea el estado de cancelacion en el instante en que se llama.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/du4/main.go" >gopl.io/ch8/du4</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

<span class="kd">func</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A continuacion, creamos una gorutina que leera desde la entrada estandar, que normalmente esta conectada al terminal. Tan pronto como se lee cualquier entrada (por ejemplo, el usuario pulsa la tecla de retorno), este gorutina difunde la cancelacion cerrando el canal <code>done</code>.</p>
<div class="highlight"><pre><span></span><span class="c1">// cancelar el recorrido cuando se detecta entrada</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// lee un solo byte</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}()</span>
</pre></div>
<p>Ahora necesitamos hacer que nuestras gorutinas respondan a la cancelacion. En la gorutina principal, se añade un tercer caso a la instruccion <code>select</code> que trata de recibir desde el canal <code>done</code>. La funcion regresa si se selecciona este caso, pero antes de regresar debe drenar el canal <code>fileSizes</code>, descartando todos los valores hasta que el canal esta cerrado. Esto se hace para asegurar que todas las llamadas activas a <code>walkDir</code> puedan correr hasta el final sin quedar atascado enviando a <code>fileSizes</code>.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="c1">// Drenar fileSizes para permitir que las gorutinas existentes terminen.</span>
    <span class="k">for</span> <span class="k">range</span> <span class="nx">fileSizes</span> <span class="p">{</span>
      <span class="c1">// no hacer nada.</span>
    <span class="p">}</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">fileSizes</span><span class="p">:</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>La gorutina <code>walkDir</code> escruta el estado de cancelacion cuando empieza y regresa sin hacer nada si se establece el estado. Esto convierte todas las gorutinas creadas despues de la cancelacion en no-ops:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">walkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">,</span> <span class="nx">fileSizes</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">defer</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">cancelled</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Puede ser que sea rentable sondear el estado de cancelacion de nuevo dentro del bucle <code>walkDir</code>, para evitar la creacion gorutinas despues del evento de cancelacion. La cancelacion implica un trade-off; Una respuesta mas rapida a menudo requiere cambios mas intrusivos a la logica del programa. Asegurarse de que ninguna operacion costosa ocurre despues del evento de cancelacion puede requerir la actualizacion de muchos lugares en su codigo, pero a menudo la mayoria del beneficio se puede obtener comprobando la cancelacion en algunos lugares importantes.</p>
<p>Un poco de perfilado de este programa revelo que el cuello de botella es la adquisicion de un token de semaforos en <code>dirents</code>. El <code>select</code> a continuacion hace que esta operacion sea cancelable y reduce la latencia tipica del programa de cientos a decenas de milisegundos:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">dirents</span><span class="p">(</span><span class="nx">dir</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">os</span><span class="p">.</span><span class="nx">FileInfo</span> <span class="p">{</span>
  <span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span>  <span class="c1">// aquirir token</span>
  <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">nil</span> <span class="c1">// cancelled</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="o">&lt;-</span><span class="nx">sema</span> <span class="p">}()</span> <span class="c1">// liberar token</span>

  <span class="c1">// ...leer directorio...</span>
<span class="p">}</span>
</pre></div>
<p>Ahora, cuando se produce la cancelacion, todas las gorutinas de fondo se detienen rapidamente y la funcion <code>main</code> regresa. Por supuesto, cuando <code>main</code> regresa, un programa sale, por lo que puede ser dificil distinguir una funcion principal que limpia despues de si mismo de una que no lo hace. Hay un truco muy util que podemos utilizar durante las pruebas: si en lugar de regresar de <code>main</code> en caso de cancelacion, llevamos a cabo una llamada a <code>panic</code>, entonces en tiempo de ejecucion se volcara la pila de cada gorutina en el programa. Si la gorutina principal es la unica que queda, sera limpiada despues a si misma. Pero si otros gorutinas permanecen, pueden no haber sido canceladas correctamente, o quizas se han cancelado pero la cancelacion toma tiempo; Una pequeña investigacion puede valer la pena. El volcado de un panico a menudo contiene informacion suficiente para distinguir estos casos.</p>
<p><b>Ejercicio 8.10</b>: Las peticiones HTTP pueden cancelarce cerrando el canal opcional <code>Cancel</code> en la estructura <code>http.Request</code>. Modificar el rastreador web de la <a href="#Seccion-8.6" >Seccion 8.6</a> para admitir la cancelacion.</p>
<p>Sugerencia: la conveniente funcion <code>http.Get</code> no le brinda la oportunidad de personalizar una <code>Request</code>. En su lugar, cree la solicitud utilizando <code>http.NewRequest</code>, establezca su campo <code>Cancel</code> y, a continuacion, realice la solicitud llamando a <code>http.DefaultClient.Do(req)</code>.</p>
<p><b>Ejercicio 8.11</b>: Siguiendo el enfoque de <code>mirroredQuery</code> en la <a href="#Seccion-8.4.4" >Seccion 8.4.4</a>, impremente una variante de <code class="command" >fetch</code> que solicite varias direcciones URL al mismo tiempo. Tan pronto como llegue la primera respuesta, cancele las otras solicitudes.</p>
</div>
<h3 id="Seccion-8.10" >Ejemplo: Server de Chat</h3>
<div class="hBody-3" >
<p>Terminaremos este capitulo con un servidor de chat que permite a varios usuarios difundir mensajes de texto entre si. Hay cuatro tipos de gorutina en este programa. Hay una instancia por cada gorutina <code>main</code> y <code>broadcaster</code>, y para cada conexion de cliente hay una gorutina <code>handleConn</code> y <code>clientWriter</code>. El emisor un buen ejemplo de como se utiliza <code>select</code>, ya que tiene que responder a tres diferentes tipos de mensajes.</p>
<p>El trabajo de la gorutina principal, demostrado abajo, es escuchar y aceptar conexiones entrantes de la red de clientes. Para cada uno, crea una nueva gorutina <code>handleConn</code>, al igual que en el servidor eco concurrente que vimos al principio de este capitulo.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch8/chat/chat.go" >gopl.io/ch8/chat</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">listener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listen</span><span class="p">(</span><span class="s">&quot;tcp&quot;</span><span class="p">,</span> <span class="s">&quot;localhost:8000&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">go</span> <span class="nx">broadcaster</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A continuacion esta el emisor. Sus variable local <code>clients</code> registra el conjunto actual de los clientes conectados. La unica informacion registrada sobre cada cliente es la identidad de su canal de mensajes salientes, sobre el cual mas tarde.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">client</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span>          <span class="c1">// un canal de mensajes salientes</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">entering</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
  <span class="nx">leaving</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">client</span><span class="p">)</span>
  <span class="nx">messages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>     <span class="c1">// todos los mensajes de los clientes entrantes</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">broadcaster</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">clients</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">client</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="c1">// todos los clientes conectados</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">messages</span><span class="p">:</span>
      <span class="c1">// Difusion de mensajes entrantes a todos</span>
      <span class="c1">// Canales de mensajes salientes de los clientes.</span>
      <span class="k">for</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">clients</span> <span class="p">{</span>
        <span class="nx">cli</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
      <span class="p">}</span>
    <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">entering</span><span class="p">:</span>
      <span class="nx">clients</span><span class="p">[</span><span class="nx">cli</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="nx">cli</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">leaving</span><span class="p">:</span>
      <span class="nb">delete</span><span class="p">(</span><span class="nx">clients</span><span class="p">,</span> <span class="nx">cli</span><span class="p">)</span>
      <span class="nb">close</span><span class="p">(</span><span class="nx">cli</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>La emisora escucha los canales globales <code>entering</code> y <code>leaving</code> para anuncios la llegada y salida de <code>clients</code>. Cuando recibe uno de estos eventos, actualiza el conjunto de clientes, y si el evento fue una salida, cierra el canal de mensajes de salida del cliente. La emisora tambien escucha los eventos globales en el canal <code>messages</code>, a la que cada cliente envia todos sus mensajes entrantes. Cuando el emisor recibe uno de estos eventos, transmite el mensaje a cada cliente conectado.</p>
<p>Ahora echemos un vistazo a las gorutinas por cliente. La funcion <code>handleConn</code> crea un nuevo canal de mensaje de salida para su cliente y anuncia la llegada de este cliente a la emisora atravez del canal <code>entering</code>. A continuacion, lee cada linea de texto del cliente, enviando cada linea a la emisora ​​a traves del canal de mensajes entrantes global, prefijando cada mensaje con la identidad de su remitente. Una vez que no hay nada mas que leer desde el cliente, <code>handleConn</code> anuncia la salida del cliente a traves del canal <code>leaving</code> y cierra la conexion.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// mensajes salientes del cliente</span>
  <span class="k">go</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

  <span class="nx">who</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&quot;You are &quot;</span> <span class="o">+</span> <span class="nx">who</span>
  <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot; has arrived&quot;</span>
  <span class="nx">entering</span> <span class="o">&lt;-</span> <span class="nx">ch</span>

  <span class="nx">input</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">NewScanner</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Text</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// NOTA: ignorando errores potenciales de input.Err()</span>

  <span class="nx">leaving</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
  <span class="nx">messages</span> <span class="o">&lt;-</span> <span class="nx">who</span> <span class="o">+</span> <span class="s">&quot; has left&quot;</span>
  <span class="nx">conn</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">clientWriter</span><span class="p">(</span><span class="nx">conn</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="c1">// NOTA: ignorando errores de red</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Ademas, <code>handleConn</code> crea una gorutina <code>clientWriter</code> para cada cliente que recibe los mensajes difundidos al canal de mensaje de salida del cliente y los escribe en la conexion de red del cliente. El bucle del criente escritor termina cuando el difusor cierra el canal despues de recibir una notificacion de salida (<code>leaving</code>).</p>
<p>La pantalla muestra el servidor en accion con dos clientes en ventanas separadas en el mismo equipo, utilizando <code>netcat</code> para charlar:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch8/chat
$ go build gopl.io/ch8/netcat3
</pre></div>
<div class="cols" style="width: 100%; display: inline-flex; flex-flow: row nowrap; flex-direction: row; ">
<div class="cols-element" style=" order: 1; width: 50%; ">
<div class="highlight"><pre><span></span>$ ./chat <span class="p">&amp;</span>
$ ./netcat3
You are <span class="m">127</span>.0.0.1:64208
<span class="m">127</span>.0.0.1:64211 has arrived
Hi!
<span class="m">127</span>.0.0.1:64208: Hi!

<span class="m">127</span>.0.0.1:64211: Hi yourself.
^C
</pre></div>
<div class="highlight"><pre><span></span>$ ./netcat3
You are <span class="m">127</span>.0.0.1:64216

<span class="m">127</span>.0.0.1:64211: Welcome.

<span class="m">127</span>.0.0.1:64211 has left
</pre></div>
</div>
<div class="cols-element" style=" order: 2; width: 50%; ">
<div class="highlight"><pre><span></span>$ ./netcat3
You are <span class="m">127</span>.0.0.1:64211
<span class="m">127</span>.0.0.1:64208: Hi!
Hi yourself.
<span class="m">127</span>.0.0.1:64211: Hi yourself.

<span class="m">127</span>.0.0.1:64208 has left

<span class="m">127</span>.0.0.1:64216 has arrived
Welcome.
<span class="m">127</span>.0.0.1:64211: Welcome.
^C
</pre></div>
</div>
</div>
<p>Al hospedar una sesion de chat para <span class="math" >n</span> clientes, este programa ejecuta <span class="math" >2n+2</span> gorutinas al mismo tiempo que se comunican, sin embargo, no necesita operaciones de bloqueo explicitas (<a href="#Seccion-9.2" >§9.2</a>). El mapa <code>clients</code> se limita a solo una gorutina, el emisor, por lo que no se puede acceder al mismo tiempo. Las unicas variables que son compartidos por gorutinas multiples son canales e instancias de <code>net.Conn</code>, ambos concurrentemente seguros. Hablaremos mas sobre el confinamiento, la seguridad de la concurrencia y las implicaciones de compartir las variables a traves de gorutinas en el proximo capitulo.</p>
<p><b>Ejercicio 8.12</b>: Hacer que el emisor anuncia el conjunto actual de clientes para cada nueva llegada. Esto requiere que los clientes establecidos (<code>clients</code>) y los canales de entrada (<code>entering</code> y salida registren tambien el nombre del cliente.</p>
<p><b>Ejercicio 8.13</b>: Hacer que el servidor de chat desconecte clientes inactivos, como los que no han enviado ningun mensaje en los ultimos cinco minutos. Sugerencia: llamar a <code>conn.Close()</code> en otra gorutina desbloquea las llamadas activas <code>Read</code> como la realizada por <code>input.Scan()</code>.</p>
<p><b>Ejercicio 8.14</b>: Cambiar el protocolo de red del servidor de chat para que cada cliente proporcione su nombre al entrar. Utilice ese nombre en lugar de la direccion de red cuando prefija cada mensaje con la identidad de su remitente.</p>
<p><b>Ejercicio 8.15</b>: El fallo de cualquier programa cliente para leer datos de manera oportuna en ultima instancia, hace que todos los clientes queden atascados. Modifique el emisor ​​para omitir un mensaje en lugar de esperar si un escritor de cliente no esta listo para aceptarlo. Como alternativa, agregue un bufer en el canal de mensajes saliente de cada cliente para que la mayoria de los mensajes no se descarten; El emisor debe utilizar un envio sin bloqueo a este canal.</p>
</div>
<h2 id="Capitulo-9" >Concurrencia con Variables Compartidas</h2>
<div class="hBody-2" >
<p>En el capitulo anterior presentamos varios programas que utilizan gorutinas y canales para expresar la concurrencia de forma directa y natural. Sin embargo, al hacerlo, pasamos revista a una serie de cuestiones importantes y sutiles que los programadores deben tener en cuenta al escribir codigo concurrente.</p>
<p>En este capitulo, examinaremos mas de cerca la mecanica de la concurrencia. En particular, señalaremos algunos de los problemas asociados con el intercambio de variables entre multiples gorutinas, las tecnicas analiticas para reconocer esos problemas y los patrones para resolverlos. Finalmente, explicaremos algunas de las diferencias tecnicas entre gorutinas y los hilos del sistema operativo.</p>
</div>
<h3 id="Seccion-9.1" >Condiciones de Carrera</h3>
<div class="hBody-3" >
<p>En un programa secuencial, es decir, un programa con solo una gorutina, los pasos del programa ocurren en el orden de ejecucion familiar determinado por la logica del programa. Por ejemplo, en una secuencia de declaraciones, la primera sucede antes de la segunda, y asi sucesivamente. En un programa con dos o mas gorutinas, los pasos dentro de cada gorutina suceden en el orden familiar, pero, en general, no sabemos si un evento <em>x</em> en una gorutina sucede antes de un evento <em>y</em> en otra gorutina, o pasa despues de ella, o es simultaneo con ella. Cuando no podemos decir con confianza que un evento <em>ocurre antes</em> que el otro, entonces los eventos de <em>x</em> y <em>y</em> son <em>concurrentes</em>.</p>
<p>Considere una funcion que funcione correctamente en un programa secuencial. Esa funcion es <em>segura para la concurrencia</em> seguira trabajando correctamente incluso cuando se llame concurrentemente, es decir, a partir de dos o mas gorutinas sin sincronizacion adicional. Podemos generalizar esta nocion a un conjunto de funciones en colaboracion, como los metodos y operaciones de un tipo particular. Un tipo es seguro para la concurrencia si todos sus metodos y operaciones accesibles son seguros para la simultaneidad.</p>
<p>Podemos hacer un programa seguro para la concurrencia sin hacer que cada tipo concreto en el programa sea seguro para la concurrencia. De hecho, los tipos concurrentemente seguros simultaneidad son la excepcion en lugar de la regla, por lo que debe acceder a una variable simultaneamente solo si la documentacion de su tipo indica que esto es seguro. Evitamos el acceso concurrente a la mayoria de las variables, ya sea mediante su <em>confinamiento</em> a una sola gorutina o manteniendo una invariante de mas alto nivel de exclusion mutua. Explicaremos estos terminos en este capitulo.</p>
<p>En contarste, se espera que las funciones a nivel de paquete <em>sean</em> compatibles con la concurrencia. Ya que las variables de nivel de paquete no pueden limitarse a una sola gorutina, las funciones que las modifican deben imponer la exclusion mutua.</p>
<p>Existen muchas razones por las que una funcion puede no funcionar cuando se llama concurrentement, incluyendo el punto muerto, el bloqueo vivo y la inanicion de recursos. No tenemos espacio para discutir todos ellos, por lo que nos centraremos en la mas importante, la <em>condicion de carrera</em>.</p>
<p>Una condicion de carrera es una situacion en la que el programa no da el resultado correcto para algunas intercalaciones de las operaciones de multiples gorutinas. Las condiciones de carrera son perniciosas porque pueden permanecer latentes en un programa y aparecen con poca frecuencia, quizas solo bajo carga pesada o cuando se utilizan ciertos compiladores, plataformas o arquitecturas. Esto los hace dificiles de reproducir y diagnosticar.</p>
<p>Es tradicional para explicar la gravedad de las condiciones de la carrera a traves de la metafora de la perdida financiera, por lo que vamos a considerar un programa de cuenta bancaria simple.</p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete bank implementa un banco con solo una cuenta.</span>
<span class="kn">package</span> <span class="nx">bank</span>

<span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">balance</span> <span class="p">}</span>
</pre></div>
<p>(Podriamos haber escrito el cuerpo de la funcion <code>Deposit</code> como <code>balance += amount</code>, lo que es equivalente, pero la forma mas larga simplificara la explicacion.)</p>
<p>Para este programa trivial, podemos ver a simple vista que cualquier secuencia de llamadas a <code>Deposit</code> y <code>Balance</code> dara la respuesta correcta, es decir, <code>Balance</code> reportara la suma de todas las cantidades depositadas previamente. Sin embargo, si llamamos a estas funciones no en una secuencia, sino al mismo tiempo, no se garantiza que <code>Balance</code> de la respuesta correcta. Considere las dos siguientes gorutinas, que representan dos transacciones en una cuenta bancaria conjunta:</p>
<div class="highlight"><pre><span></span><span class="c1">// Alice:</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">bank</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>                <span class="c1">// A1</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">,</span> <span class="nx">bank</span><span class="p">.</span><span class="nx">Balance</span><span class="p">())</span> <span class="c1">// A2</span>
<span class="p">}()</span>

<span class="c1">// Bob:</span>
<span class="k">go</span> <span class="nx">bank</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>               <span class="c1">// B</span>
</pre></div>
<p>Alice deposita $200, luego comprueba su balance, mientras que Bob deposita $100. Dado que los pasos <code>A1</code> y <code>A2</code> se producen simultaneamente con <code>B</code>, no podemos predecir el orden en que se producen. Intuitivamente, podria parecer que solo hay tres posibles ordenaciones, que llamaremos a <q>Alicia primero</q>, a <q>Bob primero</q>, y <q>Alice/Bob/Alice</q>. La siguiente tabla muestra el valor de la variable de balance despues de cada paso. Las cadenas entre comillas representan los resbalones impresos.</p>
<pre class="pre" >Alice primero           Bob primero          Alice/Bob/Alice
            0                     0                        0
    A1    200             B     100                A1    200
    A2 &quot;= 200&quot;            A1    300                B     300
    B     300             A2 &quot;= 300&quot;               A2 &quot;= 300&quot;</pre>
<p>En todos los casos el balance es de $300. La unica variacion es si el balance de Alice incluye la transaccion de Bob o no, pero los clientes estan satisfechos de cualquier manera.</p>
<p>Pero esta intuicion es incorrecta. Hay una cuarto resultado posible, en el que el deposito de Bob se produce en medio de deposito de Alice, despues de que el equilibrio se ha leido (<code>balance + amount</code>), pero antes de que haya sido actualizada (<code>balance = ...</code>), haciendo que la transaccion de Bob desaparezca. Esto se debe a que la operacion de deposito de Alice <code>A1</code> es realmente una secuencia de dos operaciones, una lectura y una escritura; llamarlos <code>A1r</code> y <code>A1w</code>. Aqui esta la intercalacion problematica:</p>
<pre class="pre" >Data race
         0
A1r      0          ... = balance + amount
B      100
A1w    200          balance = ...
A2  &quot;= 200&quot;</pre>
<p>Despues de <code>A1r</code>, la expresion <code>balance + amount</code> se evalua a 200, por lo que este es el valor escrito durante <code>A1w</code>, a pesar del deposito intermedio. El saldo final es de solo $200. El banco es $100 mas rico a expensas de Bob.</p>
<p>Este programa contiene un determinado tipo de condicion de carrera llamado <code>carrera de datos</code>. Una carrera de datos ocurre cuando dos gorutinas acceden simultaneamente a la misma variable y al menos uno de los accesos es una escritura.</p>
<p>Las cosas se ponen aun mas desordenadas si la carrera de datos implica una variable de un tipo que es mas grande que una sola palabra de maquina, como una interfaz, una cadena o un slice. Este codigo actualiza <code>x</code> concurrentemente a dos slices de diferentes longitudes:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">}()</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">x</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">}()</span>
<span class="nx">x</span><span class="p">[</span><span class="mi">999999</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// NOTA: comportamiento no definido; posible corrupcion de memoria!</span>
</pre></div>
<p>El valor de <code>x</code> en la declaracion final no esta definido; Podria ser nil, o un slice de longitud 10, o un slice de longitud 1,000,000. Pero recuerda que hay tres partes en un slice: el puntero, la longitud y la capacidad. Si el puntero viene de la primera llamada a realizar y la duracion viene de la segunda, <code>x</code> sera una quimera, un slice cuya longitud nominal es de 1,000,000, pero cuya matriz subyacente tiene solo 10 elementos. En esta eventualidad, el almacenamiento en el elemento 999.999 bloquearia una ubicacion de memoria aleatoria arbitraria, con consecuencias imposibles de predecir y dificiles de depurar y localizar. Este campo de minas semantica se llama un <em>comportamiento indefinido</em> y es bien conocido por los programadores de C; Afortunadamente rara vez es tan problematico en Go como en C.</p>
<p>Incluso la nocion de que un programa concurrente es una intercalacion de varios programas secuenciales es una falsa intuicion. Como veremos en la <a href="#Seccion-9.4" >Seccion 9.4</a>, las carreras de datos pueden tener resultados aun mas extrañas. Muchos programadores–incluso algunos muy inteligentes–en ocasiones ofrecen justificaciones para carreras de datos conocidos en sus programas: <q>el costo de la exclusion mutua es demasiado alto</q>, <q>esta logica es solo para el registro</q>, <q>no me importa si dejo caer algunos mensajes</q>, y asi sucesivamente. La ausencia de problemas en un compilador y una plataforma dados puede darles una falsa confianza. Una buena regla general es que no hay tal cosa como una carrera de datos benigna. Entonces, ¿como evitamos las carreras de datos en nuestros programas?</p>
<p>Vamos a repetir la definicion, ya que es tan importante: Una carrera de datos se produce cuando dos gorutinas acceder a la misma variable al mismo tiempo y al menos uno de los accesos es una escritura. De esta definicion se deduce que hay tres maneras de evitar una carrera de datos.</p>
<p>La primera manera es no escribir la variable. Considere el siguiente mapa, que es poblado perezosamente, ya que cada clave se solicita por primera vez. Si <code>Icon</code> se llama secuencialmente, el programa funciona bien, pero si <code>Icon</code> se llama al mismo tiempo, hay una carrera de datos accediendo al mapa.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">icons</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// NOTA: no es seguro para la concurrencia!</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">icon</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">icon</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
    <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">icon</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icon</span>
<span class="p">}</span>
</pre></div>
<p>Si en lugar de eso inicializamos el mapa con todas las entradas necesarias antes de crear gorutinas adicionales y nunca lo modificamos de nuevo, entonces cualquier numero de gorutinas puede llamar de forma segura a <code>Icon</code> simultaneamente puesto que cada uno solo lee el mapa.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">icons</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">{</span>
  <span class="s">&quot;spades.png&quot;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;spades.png&quot;</span><span class="p">),</span>
  <span class="s">&quot;hearts.png&quot;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;hearts.png&quot;</span><span class="p">),</span>
  <span class="s">&quot;diamonds.png&quot;</span><span class="p">:</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;diamonds.png&quot;</span><span class="p">),</span>
  <span class="s">&quot;clubs.png&quot;</span><span class="p">:</span>    <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;clubs.png&quot;</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1">// Seguro para la concurrencia.</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>En el ejemplo anterior, la variable <code>icons</code> se asigna durante la inicializacion del paquete, lo que ocurre antes de que comience la funcion principal del programa. Una vez inicializado, <code>icons</code> no se modifica. Las estructuras de datos que nunca se modifican o son inmutables son intrinsecamente seguras y no necesitan sincronizacion. Pero, obviamente, no podemos utilizar este enfoque si las actualizaciones son esenciales, como con una cuenta bancaria.</p>
<p>La segunda forma de evitar una carrera de datos es evitar el acceso a la variable desde multiples gorutinas. Este es el enfoque adoptado por muchos de los programas del capitulo anterior. Por ejemplo, la gorutina principal en el rastreador web concurrente (<a href="#Seccion-8.6" >§8.6</a>) es la unica gorutina que tiene acceso a el mapa <code>seen</code> y la gorutina <code>broadcaster</code> en el servidor de chat (<a href="#Seccion-8.10" >§8.10</a>) es la unica gorutina que accede al mapa <code>clients</code>. Estas variables se limitan a una sola gorutina.</p>
<p>Ya que otras gorutinas no pueden acceder a la variable directamente, deben usar un canal para enviar al gorutina de confinamiento una solicitud para consultar o actualizar la variable. Esto es lo que se quiere decir con el mantra Go <q>No se comunique compartiendo memoria; en su lugar, comparta la memoria mediante la comunicacion</q>. Una gorutina por la que los corredores acceden a una variable confinada usando solicitudes de canal se denomina <em>gorutina monitor</em> para esa variable. Por ejemplo, la gorutina <code>broadcaster</code> monitorea el acceso al mapa de clientes.</p>
<p>Aqui esta el ejemplo del banco reescrito con la variable <code>balance</code> confinada a una gorutina monitor llamada <code>teller</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/bank1/bank.go" >gopl.io/ch9/bank1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete bank seguro para la concurrencia con solo una cuenta.</span>
<span class="kn">package</span> <span class="nx">bank</span>

<span class="kd">var</span> <span class="nx">deposits</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// enviar la cantidad a depositar</span>
<span class="kd">var</span> <span class="nx">balances</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// recive el balance</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">deposits</span> <span class="o">&lt;-</span> <span class="nx">amount</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span>       <span class="p">{</span> <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">balances</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">teller</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span> <span class="c1">// balance esta confinado a la gorutina teller</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">amount</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">deposits</span><span class="p">:</span>
      <span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span>
    <span class="k">case</span> <span class="nx">balances</span> <span class="o">&lt;-</span> <span class="nx">balance</span><span class="p">:</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">teller</span><span class="p">()</span> <span class="c1">// inicia la gorutina momitor</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Incluso cuando una variable no puede ser confinada a una sola gorutina durante toda su vida, el confinamiento todavia puede ser una solucion al problema del acceso concurrente. Por ejemplo, es comun compartir una variable entre gorutinas en una tuberia, pasando su direccion de una etapa a la siguiente a traves de un canal. Si cada etapa de la tuberia se abstiene de acceder a la variable despues de enviarla a la siguiente etapa, entonces todos los accesos a la variable son secuenciales. En efecto, la variable esta confinada a una etapa de la tuberia, luego confinada a la siguiente, y asi sucesivamente. Esta disciplina es a veces llamado el <em>confinamiento en serie</em>.</p>
<p>En el siguiente ejemplo, <code>Cakes</code> se confina en serie, primero a la gorutina <code>baker</code>, despues, a la gorutina <code>icer</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Cake</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">state</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">baker</span><span class="p">(</span><span class="nx">cooked</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">cake</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Cake</span><span class="p">)</span>
    <span class="nx">cake</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="s">&quot;cooked&quot;</span>
    <span class="nx">cooked</span> <span class="o">&lt;-</span> <span class="nx">cake</span> <span class="c1">// baker nunca toca este pastel de nuevo</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">icer</span><span class="p">(</span><span class="nx">iced</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">,</span> <span class="nx">cooked</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Cake</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">cake</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cooked</span> <span class="p">{</span>
    <span class="nx">cake</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="s">&quot;iced&quot;</span>
    <span class="nx">iced</span> <span class="o">&lt;-</span> <span class="nx">cake</span>   <span class="c1">// icer nunca toca este pastel de nuevo</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>La tercera manera de evitar una carrera de datos es permitir que muchas gorutinas accedan a la variable, pero solo una a la vez. Este enfoque se conoce como <em>exclusion mutua</em> y es el objeto de la siguiente seccion.</p>
<p><b>Ejercicio 9.1</b>: Añadir una funcion <code>Withdraw(amount int) bool</code> al programa <code>gopl.io/ch9/bank1</code>. El resultado debe indicar si la transaccion tuvo exito o fracaso debido a fondos insuficientes. El mensaje enviado a la gorutina monitor debe contener tanto la cantidad a retirar y un nuevo canal por el cual la gorutina monitor puede enviar el resultado booleano de nuevo a <code>Withdraw</code>.</p>
</div>
<h3 id="Seccion-9.2" >Exclusion mutua: <code>sync.Mutex</code></h3>
<div class="hBody-3" >
<p>En la <a href="#Seccion-8.6" >Seccion 8.6</a>, se utilizo un canal con buffer como un <em>semaforo contador</em> para asegurar que no mas de 20 gorutinas hacen peticiones HTTP simultaneas. Con la misma idea, podemos usar un canal de capacidad 1 para asegurar que a lo sumo una gorutina acceda a una variable compartida a la vez. Un semaforo que cuenta solamente a 1 se denomina <em>semaforo binario</em>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/bank2/bank.go" >gopl.io/ch9/bank2</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
  <span class="nx">sema</span>    <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">//  un semaforo binario custodia balance</span>
  <span class="nx">balance</span> <span class="kt">int</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// aquirir token</span>
  <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
  <span class="o">&lt;-</span><span class="nx">sema</span>             <span class="c1">// liberar token</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">sema</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// aquirir token</span>
  <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
  <span class="o">&lt;-</span><span class="nx">sema</span>             <span class="c1">// liberar token</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Este patron de <em>exclusion mutua</em> es tan util que esta soportado directamente por el tipo de objeto <code>mutex</code> del paquete <code>sync</code>. Su metodo <code>Lock</code> adquiere el token (llamado <em>bloqueo</em>) y su metodo <code>Unlock</code> lo libera:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/bank3/bank.go" >gopl.io/ch9/bank3</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;sync&quot;</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// custodia balance</span>
  <span class="nx">balance</span> <span class="kt">int</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">balance</span> <span class="p">=</span> <span class="nx">balance</span> <span class="o">+</span> <span class="nx">amount</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">b</span> <span class="o">:=</span> <span class="nx">balance</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cada vez que una gorutina accede a las variables del banco (aqui solo <code>balance</code>), debe llamar a la metodo <code>Lock</code> de mutex para adquirir un bloqueo exclusivo. Si alguna otra gorutina ha adquirido el bloqueo, esta operacion se bloqueara hasta que la otra gorutina llame a <code>Unlock</code> y el bloqueo vuelva a estar disponible. La exclusion mutua <em>custodia</em> las variables compartidas. Por convencion, las variables custodiadas por un mutex se declaran inmediatamente despues de la declaracion del propio mutex. Si se desvia de esto, asegurese de documentarlo.</p>
<p>La region de codigo entre <code>Lock</code> y <code>Unlock</code> en la que un gorutina es libre de leer y modificar las variables compartidas se denomina <em>seccion critica</em>. Llama a <code>Unlock</code> de parte del poseeodor del bloqueo <em>ocurrira antes</em> de que cualquier otra gorutina pueda adquirir el bloqueo para si. Es esencial que la gorutina libire el bloqueo una vez que haya terminado, en toda las rutas a traves de la funcion, incluyendo rutas de error.</p>
<p>El programa bancario anterior ejemplifica un patron de concurrencia comun. Un conjunto de funciones exportadas encapsula una o mas variables de manera que la unica forma de acceder a las variables es a traves de estas funciones (o metodos, para las variables de un objeto). Cada funcion adquiere un bloqueo mutex al principio y lo libera al final, asegurando asi que las variables compartidas no se acceden simultaneamente. Esta disposicion de las funciones de bloqueo, mutex y variables se denomina <em>monitor</em>. (Este uso anterior de la palabra del monitor inspiro el termino <q>gorutina monitor</q>. Ambos usos comparten el significado de un agente que asegura el acceso sequencial a las variables.)</p>
<p>Dado que las secciones criticas en las funciones <code>Deposit</code> y <code>Balance</code> son tan cortas–una sola linea, ninguna ramificacion–llamar a <code>Unlock</code> al final es sencillo. En las secciones criticas mas complejas, especialmente aquellas en los que los errores deben resolverse regregando antes, puede ser dificil saber que las llamadas a <code>Lock</code> y <code>Unlock</code> estan estrictamente emparejado en todas las rutas. La declaracion <code>defer</code> de Go viene al rescate: al diferir una llamada a <code>Unlock</code>, la seccion critica se extiende implicitamente al final de la funcion actual, liberandonos de tener que insertar una llamada <code>Unlock</code> en uno o mas lugares lejos de la llamada a <code>Lock</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>
</pre></div>
<p>En el ejemplo anterior, <code>Unlock</code> se ejecuta <em>despues</em> de que la instruccion de retorno ha leido el valor de <code>balance</code>, por lo que la funcion <code>Balance</code> es segura para la concurrencia. Como beneficio adicional, ya no necesitamos la variable local <code>b</code>.</p>
<p>Por otra parte, un <code>Unlock</code> diferido funcionara incluso si la seccion critica entra en panico, lo que puede ser importante en los programas que hacen uso de <code>recover</code> (<a href="#Seccion-5.10" >§5.10</a>). Un <code>defer</code> es ligeramente mas caro que una llamada explicita a <code>Unlock</code>, pero no lo suficiente para justificar codigo de menos claro. En programas concurrentes, siempre favoresca la claridad y resista la optimizacion prematura. Siempre que sea posible, utilice <code>defer</code> y dejar que las secciones criticas se extienden hasta el final de una funcion.</p>
<p>Considere la funcion <code>Withdraw</code> a continuacion. En caso de exito, reduce el balance en la cantidad especificada y devuelve <code>true</code>. Pero si la cuenta tiene fondos suficientes para la transaccion, <code>Withdraw</code> restaura el balance y devuelve <code>false</code>.</p>
<div class="highlight"><pre><span></span><span class="c1">// NOTA: no atomico!</span>
<span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">Deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// fondos insuficientes</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Esta funcion finalmente da el resultado correcto, pero tiene un efecto secundario desagradable. Cuando se intenta una retiro excesivo, el balance transitoriamente se sumerge por debajo de cero. Esto puede causar una retirada simultanea de una suma modesta que se rechazara espuriosamente. Asi que si Bob trata de comprar un coche deportivo, Alice no puede pagar por su cafe de la mañana. El problema es que <code>Withdraw</code> no es <em>atomico</em>: consiste en una secuencia de tres operaciones separadas, cada una de las cuales adquiere y luego libera el bloqueo de exclusion mutua, pero nada bloquea toda la secuencia.</p>
<p>Idealmente, <code>Withdraw</code> debe adquirir el bloqueo mutex una vez alrededor de toda la operacion. Sin embargo, este intento no funcionara:</p>
<div class="highlight"><pre><span></span><span class="c1">// NOTA: incorrecto!</span>
<span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">Deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// fondos insuficientes</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p><code>Deposit</code> intenta adquirir el bloqueo mutex una segunda vez llamando a <code>mu.Lock()</code>, pero debido a que los bloqueos de exclusion mutua no son <em>reentrantes</em>–No es posible bloquear un mutex que ya esta bloqueado–esto lleva a un punto muerto en el que nada puede proceder, y <code>Withdraw</code> se bloqua para siempre.</p>
<p>Hay una buena razon para que los mutex de Go no vuelvan a entrar. El proposito de un mutex es asegurar que ciertos invariantes de las variables compartidas se mantengan en puntos criticos durante la ejecucion del programa. Una de las invariantes es que la <q>gorutina no esta accediendo a las variables compartidas</q>, pero puede haber invariantes adicionales especificas a las estructuras de datos que custodia el mutex. Cuando una gorutina adquiere un bloqueo mutex, puede suponer que los invariantes se mantienen. Mientras mantiene el bloqueo, puede actualizar las variables compartidas para que los invariantes se violen temporalmente. Sin embargo, cuando se libera el bloqueo, debe garantizar que el orden ha sido restaurado y mantiene los invariantes una vez mas. Aunque un mutex reentrante aseguraria que ninguna otra parte acceda a las variables compartidas, no puede proteger las invariantes adicionales de esas variables.</p>
<p>Una solucion comun es dividir una funcion como <code>Deposit</code> en dos: una funcion no exportada, <code>deposit</code>, que asume que el bloqueo ya se retiene y hace el trabajo real, y una funcion exportada <code>Deposit</code> que adquiere el bloqueo antes de llamar a <code>deposit</code>. Podemos expresar <code>Withdraw</code> en terminos de <code>deposit</code> de la siguiente manera:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Withdraw</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">deposit</span><span class="p">(</span><span class="o">-</span><span class="nx">amount</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">balance</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// fondos insuficientes</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>

<span class="c1">// Esta funcion requiere que se mantenga el bloqueo.</span>
<span class="kd">func</span> <span class="nx">deposit</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">balance</span> <span class="o">+=</span> <span class="nx">amount</span> <span class="p">}</span>
</pre></div>
<p>Por supuesto, la funcion <code>deposit</code> mostrada aqui es tan trivial que una funcion <code>Withdraw</code> realista no se molestaria en llamarla, no obstante, ilustra el principio.</p>
<p>La encapsulacion (<a href="#Seccion-6.6" >§6.6</a>), mediante la reduccion de las interacciones inesperadas en un programa, nos ayuda a mantener la estructura de datos invariantes. Por la misma razon, la encapsulacion tambien nos ayuda a mantener invariantes concurrentes. Cuando utilice un mutex, asegurese de que tanto el como las variables que protege no se exportan, ya sean variables a nivel de paquete o campos de una estructura.</p>
</div>
<h3 id="Seccion-9.3" >Mutex de Lectura/Escritura: <code>sync.RWMutex</code></h3>
<div class="hBody-3" >
<p>En un ataque de ansiedad despues de ver su deposito de $100 desaparecer sin dejar rastro, Bob escribe un programa para comprobar su saldo bancario cientos de veces por segundo. El lo ejecuta en casa, en el trabajo, y en su telefono. El banco se da cuenta de que el aumento del trafico esta retrasando los depositos y retiros, porque todas las peticiones de <code>Balance</code> se ejecutan secuencialmente, manteniendo el bloqueo exclusivo, inpidiendo temporalmente otras gorutinas se ejecute.</p>
<p>Dado que la funcion <code>Balance</code> solo tiene que leer el estado de la variable, de echo, seria seguro que multiples llamadas <code>Balance</code> se ejecuten concurrentemente, siempre y cuando no se ejecute ninguna llamada a <code>Deposit</code> o <code>Withdraw</code>. En este escenario necesitamos un tipo especial de bloqueo que permita que las operaciones de solo lectura se realicen en paralelo entre si, pero que las operaciones de escritura tengan acceso totalmente exclusivo. Este bloqueo se denomina <em>lectores multiples, escritor unico</em>, y en Go es proporcionado por <code>sync.RWMutex</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="kd">var</span> <span class="nx">balance</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">Balance</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span> <span class="c1">// bloqueo de lectores</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">balance</span>
<span class="p">}</span>
</pre></div>
<p>La funcion <code>Balance</code> ahora llama a los metodos <code>RLock</code> y <code>RUnlock</code> para adquirir y liberar a <em>lectores</em> o bloqueo <em>compartido</em>. la funcion <code>Deposit</code>, queda sin cambios, llama a los metodos <code>mu.Lock</code> y <code>mu.Unlock</code> para adquirir y liberar un <em>escritor o bloqueo</em> exclusivo.</p>
<p>Despues de este cambio, la mayor parte de peticion <code>Balance</code> de Bob se ejecutan en paralelo entre si y terminar mas rapidamente. El bloqueo esta disponible la mayoria del tiempo, y las solicitudes <code>Deposit</code> puede proceder de manera oportuna.</p>
<p>RLock solo se puede utilizar si no hay escritura en variables compartidas en la seccion critica. En general, no debemos suponer que la funciones de solo lectura <em>logicamente</em> no actualizan algunas variables. Por ejemplo, un metodo que parece ser un simple accesorio tambien puede incrementar un contador de uso interno o actualizar un cache para que las llamadas repetidas sean mas rapidas. En caso de duda, utilice un <code>Lock</code> exclusivo .</p>
<p>Solo es rentable utilizar <code>RWMutex</code> cuando la mayoria de las gorutinas que adquieren el bloqueo son lectores, y el bloqueo esta bajo <em>contencion</em>, es decir, las gorutinas rutinariamente tienen que esperar para adquirirla. Un <code>RWMutex</code> requiere contabilidad interna mas compleja, por lo que es mas lento que un mutex regular para bloqueos sin contencion.</p>
</div>
<h3 id="Seccion-9.4" >Sincronizacion de Memoria</h3>
<div class="hBody-3" >
<p>Usted puede preguntarse por que el metodo <code>Balance</code> necesita exclusion mutua, ya sea basada en canales o basada en mutex. Despues de todo, a diferencia de <code>Deposit</code>, que consiste solo en una sola operacion, por lo que no hay peligro de otra gorutina se ejecute <q>en medio</q> de la misma. Hay dos razones por las que necesitamos un mutex. La primera es que es igualmente importante que <code>Balance</code> no se ejecute en medio de alguna otra operacion como <code>Withdraw</code>. La segunda (y mas sutil) razon es que la sincronizacion es mas que solo el orden de ejecucion de multiples gorutinas; La sincronizacion tambien afecta a la memoria.</p>
<p>En una computadora moderna puede haber decenas de procesadores, cada uno con su propia cache local de memoria principal. Por razones de eficiencia, las escrituras en memoria se almacenan en el buffer de cada procesador y se descargan en la memoria principal solo cuando es necesario. Incluso pueden estar comprometidos con la memoria principal en un orden diferente de lo que fueron escritos por la gorutina de escritura. Las primitivas de sincronizacion como las comunicaciones de canal y las operaciones de mutex hacen que el procesador descargue y comprometa todas sus escrituras acumuladas de modo que los efectos de la ejecucion de gorutina hasta ese punto esten garantizados para ser visibles para gorutinas que se ejecutan en otros procesadores.</p>
<p>Considere las posibles salidas del siguiente fragmento de codigo:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="c1">// A1</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&quot;y:&quot;</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="c1">// A2</span>
<span class="p">}()</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">y</span> <span class="p">=</span> <span class="mi">1</span>
  <span class="c1">// B1</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&quot;x:&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="c1">// B2</span>
<span class="p">}()</span>
</pre></div>
<p>Dado que estas dos gorutinas son concurrentes y acceden a variables compartidas sin exclusion mutua, existe una carrera de datos, por lo que no debe sorprendernos que el programa no sea determinista. Podemos esperar que imprima cualquiera de estos cuatro resultados, que corresponden a intercalaciones intuitivas de las declaraciones etiquetadas del programa:</p>
<pre class="pre" >y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1</pre>
<p>La cuarta linea podria explicarse por la secuencia <code>A1</code>, <code>B1</code>, <code>A2</code>, <code>B2</code> o por <code>B1</code>, <code>A1</code>, <code>A2</code>, <code>B2</code>, por ejemplo. Sin embargo, estos dos resultados podrian ser una sorpresa:</p>
<pre class="pre" >x:0 y:0
y:0 x:0</pre>
<p>Pero dependiendo del compilador, la CPU, y muchos otros factores, pueden suceder tambien. ¿Que posible intercalacion de los cuatro enunciados podria explicarlos?</p>
<p>Dentro de una sola gorutina, los efectos de cada declaracion se garantizan para ocurrir en el orden de la ejecucion; las gorutinas son <em>secuencialmente consistentes</em>. Pero en ausencia de sincronizacion explicita utilizando un canal o mutex, no hay garantia de que los eventos sean vistos en el mismo orden por todas las gorutinas. Aunque la gorutina A debe observar el efecto de la escritura <code>x = 1</code> antes de que se lea el valor de <code>y</code>, no necesariamente observar la escritura a <code>y</code> realizada por la gorutina B, por lo que A puede imprimir un valor obsoleto de <code>y</code>.</p>
<p>Es tentador tratar de entender la concurrencia como si se correspondiera a <em>alguna</em> intercalacion de los estados de cada gorutina, pero como muestra el ejemplo anterior, no es asi como un compilador o una CPU moderna. Debido a que la asignacion y <code>Print</code> se refieren a diferentes variables, un compilador puede concluir que el orden de las dos declaraciones no puede afectar el resultado, e intercambiarlos. Si las dos gorutinas se ejecutan en diferentes CPUs, cada uno con su propia memoria cache, las escrituras de una gorutina no son visibles para el <code>Print</code> de la otra gorutina hasta que las caches se sincronizan con la memoria principal.</p>
<p>Todos estos problemas de concurrencia pueden ser evitados por el uso consistente de patrones simples y establecidos. Siempre que sea posible, limite las variables a una unica gorutina; Para todas las demas variables, utilice la exclusion mutua.</p>
</div>
<h3 id="Seccion-9.5" >Inicializacion Perezosa: <code>sync.Once</code></h3>
<div class="hBody-3" >
<p>Es una buena practica diferir un costoso paso de inicializacion hasta el momento en que se necesita. Inicializar una variable de antemano aumenta la latencia de inicio de un programa y es innecesario si la ejecucion no siempre alcanza la parte del programa que utiliza esa variable. Volvamos a la variable <code>icons</code> que vimos en el capitulo anterior:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>
</pre></div>
<p>Esta version de <code>Icon</code> utiliza <em>inicializacion perezosa</em>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">loadIcons</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">icons</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">{</span>
    <span class="s">&quot;spades.png&quot;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;spades.png&quot;</span><span class="p">),</span>
    <span class="s">&quot;hearts.png&quot;</span><span class="p">:</span>   <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;hearts.png&quot;</span><span class="p">),</span>
    <span class="s">&quot;diamonds.png&quot;</span><span class="p">:</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;diamonds.png&quot;</span><span class="p">),</span>
    <span class="s">&quot;clubs.png&quot;</span><span class="p">:</span>    <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;clubs.png&quot;</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NOTA: no es concurrentemente seguro!</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">loadIcons</span><span class="p">()</span> <span class="c1">// inicializacion unica</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
<p>Para una variable accedida por solo una gorutina, podemos usar el patron anterior, pero este patron no es seguro si <code>Icon</code> se llama concurrentemente.</p>
<p>Al igual la funcion original <code>Deposit</code> del banco, <code>Icon</code> consta de varios pasos: Comprueba si <code>icons</code> es nil, entonces carga los iconos, luego, carga <code>icons</code> a un valor no nil. La intuicion podria sugerir que el peor resultado posible de la condicion de carrera anterior es que la funcion <code>loadIcons</code> se llame varias veces. Mientras que la primera gorutina esta ocupada cargando los iconos, otra gorutina que entre a <code>Icon</code> encontraria que la variable sigue siendo igual a <code>nil</code>, y podria tambien llamar a <code>loadIcons</code>.</p>
<p>Pero esta intuicion tambien es incorrecta. (Esperamos que a estas alturas esta desarrollando una nueva intuicion sobre la concurrencia, que no deba confiar en las intuiciones sobre la concurrencia!) Recordemos la discusion de la memoria de la <a href="#Seccion-9.4" >Seccion 9.4</a>. En ausencia de sincronizacion explicita, el compilador y la CPU son libres de reordenar los accesos a la memoria en cualquier numero de maneras, siempre y cuando el comportamiento de cada gorutina sea consistente secuencialmente. Una posible reordenacion de las declaraciones de <code>loadIcons</code> se muestra a continuacion. Se almacena el mapa vacio en la variable <code>icons</code> antes de poblarlo:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">loadIcons</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">icons</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&quot;spades.png&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;spades.png&quot;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&quot;hearts.png&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;hearts.png&quot;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&quot;diamonds.png&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;diamonds.png&quot;</span><span class="p">)</span>
  <span class="nx">icons</span><span class="p">[</span><span class="s">&quot;clubs.png&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">loadIcon</span><span class="p">(</span><span class="s">&quot;clubs.png&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>En consecuencia, un gorutina que encuentre a <code>icons</code> siendo no-nil no puede asumir que la inicializacion de la variable esta completa.</p>
<p>La forma mas sencilla de garantizar que todas las gorutinas observan los efectos de <code>loadIcons</code> es sincronizarlos utilizando un mutex:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards icons</span>
<span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// concurrentemente seguro.</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">loadIcons</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
<p>Sin embargo, el costo de aplicar el acceso mutuamente excluyente a <code>icons</code> es que dos gorutinas no pueden acceder a la variable al mismo tiempo, incluso una vez que la variable se ha inicializado de forma segura y nunca sera modificada de nuevo. Esto sugiere un bloqueo de lectores multiples:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span> <span class="c1">// custodia icons</span>
<span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// concurrentemente seguro.</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">icon</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">icon</span>
  <span class="p">}</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>

  <span class="c1">// adquiere un bloqueo exclusivo</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">icons</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// NOTA: debe volver a comprobar por nil</span>
    <span class="nx">loadIcons</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">icon</span> <span class="o">:=</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
  <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">icon</span>
<span class="p">}</span>
</pre></div>
<p>Ahora hay dos secciones criticas. la primer gorutina adquiere un bloqueo de lectura, consulta el mapa, despues libera el bloqueo. Si se encontro una entrada (el caso comun), se devuelve. Si no se encontro ninguna entrada, la gorutina adquiere un bloqueo de escritura. No hay manera de actualizar un bloqueo compartido a un exclusiva sin liberar primero el bloqueo compartido, por lo que debemos volver a comprobar la variable <code>icons</code> en caso de que otra gorutina ya la haya inicializado en el interin.</p>
<p>El patron anterior nos da mayor concurrencia, pero es complejo y, por tanto, propenso a errores. Afortunadamente, el paquete <code>sync</code> proporciona una solucion especializada para el problema de la inicializacion unica: <code>sync.Once</code>. Conceptualmente, un <code>Once</code> se compone de un mutex y una variable booleana que registra si la inicializacion ha tenido lugar; El mutex protege tanto las estructuras de datos booleanas como las del cliente. El unico metodo, <code>Do</code>, acepta la funcion de inicializacion como su argumento. Vamos utilizar <code>Once</code> para simplificar la funcion <code>Icon</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">loadIconsOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">icons</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span>

<span class="c1">// concurrentemente seguro.</span>
<span class="kd">func</span> <span class="nx">Icon</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Image</span> <span class="p">{</span>
  <span class="nx">loadIconsOnce</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="nx">loadIcons</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">icons</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
<p>Cada llamada a <code>Do(loadIcons)</code> bloquea el mutex y comprueba la variable booleana. En la primer llamada, en la que la variable es falsa, <code>Do</code> llama a <code>loadIcons</code> y la variable se establece a verdadero. Las llamadas posteriores no hacen nada, pero la sincronizacion de exclusion mutua asegura que los efectos de <code>loadIcons</code> sobre la memoria (en concreto, <code>icons</code>) se hacen visibles a todas las gorutinas. Usando <code>sync.Once</code> de esta manera, podemos evitar compartir las variables con otras gorutinas hasta que se han construido correctamente.</p>
<p><b>Ejercicio 9.2</b>: Vuelva a escribir el ejemplo <code>PopCount</code> de la <a href="#Seccion-2.6.2" >Seccion 2.6.2</a> de manera que inicialice la tabla de consulta utilizando <code>sync.Once</code> la primera vez que sea necesario. (Siendo realistas, el costo de la sincronizacion seria prohibitivo para una pequeña y altamente optimizado funcion como <code>PopCount</code>.)</p>
</div>
<h3 id="Seccion-9.6" >El Detector de Carreras</h3>
<div class="hBody-3" >
<p>Incluso con el mayor cuidado, es demasiado facil crear errores de concurrencia. Afortunadamente, el runtime y herramientas de Go esta equipado con una herramienta sofisticada y facil de usar de analisis dinamico, el <em>detector de carrera</em>.</p>
<p>Simplemente agregue la bandera <code>-race</code> al comando <code class="command" >go build</code>, <code class="command" >go run</code> o <code class="command" >go test</code>. Esto hace que el compilador construya una version modificada de su aplicacion o pruebe con instrumentacion adicional que registre efectivamente todos los accesos a variables compartidas que ocurrieron durante la ejecucion, junto con la identidad de la gorutina que leyo o escribio la variable. Ademas, el programa modificado registra todos los eventos de sincronizacion, por ejemplo, declaraciones <code>go</code>, operaciones de canal, y llamadas a <code>(*sync.Mutex).Lock</code>, <code>(*sync.WaitGroup).Wait</code>, etc. (El conjunto completo de eventos de sincronizacion se especifica en el documento <em>The Go Memory Model</em> que acompaña a la especificacion del lenguaje.)</p>
<p>El detector de carreras estudia esta corriente de eventos, buscando casos en los que una gorutina lee o escribe una variable compartida que fue escrita recientemente por una gorutina diferente sin una operacion de sincronizacion intermedia. Esto indica un acceso simultaneo a la variable compartida y, por tanto, una carrera de datos. La herramienta imprime un informe que incluye la identidad de la variable y las pilas de las llamadas de funcion activas en la seccion de lectura y la nota de escritura. Esto suele ser suficiente para identificar el problema. Seccion 9.7 contiene un ejemplo del detector de carrera en accion.</p>
<p>El detector de carreras informa todas las carreras de datos que se ejecutaron realmente. Sin embargo, solo puede detectar las condiciones de carrera que se producen durante una carrera; No puede demostrar que nunca ocurrira ninguna. Para obtener los mejores resultados, asegurese de que sus pruebas utilizan sus paquetes concurrentemente.</p>
<p>Debido a la contabilidad adicional, un programa construido con la deteccion de la raza necesita mas tiempo y memoria para funcionar, pero la sobrecarga es tolerable incluso para muchos trabajos en produccion. Para condiciones de carrera poco frecuentes, dejar que el detector de carrera haga su trabajo puede ahorrar horas o dias de depuracion.</p>
</div>
<h3 id="Seccion-9.7" >Ejemplo: Cache Concurrente Sin Bloqueo</h3>
<div class="hBody-3" >
<p>En esta seccion, vamos a construir una <em>memoria cache concurrente sin bloqueo</em>, una abstraccion que resuelve un problema que se presenta con frecuencia en programas concurrentes del mundo real, pero no esta bien dirigido por las bibliotecas existentes. Este es el problema de <em>momorizar</em> una funcion, es decir, poner en cache el resultado de una funcion de modo que tiene que ser calculada solamente una vez. Nuestra solucion sera segura para la concurrencia y evitara la contencion asociada con diseños basados ​​en un bloqueo unico para toda la memoria cache.</p>
<p>Usaremos la funcion <code>httpGetBody</code> a continuacion como ejemplo del tipo de funcion que podriamos desear memorizar. Hace una peticion HTTP GET y lee el cuerpo de la solicitud. Las llamadas a esta funcion son relativamente caras, por lo que nos gustaria evitar repetirlas innecesariamente.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">httpGetBody</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>La linea final esconde una sutileza menor. <code>ReadAll</code> devuelve dos resultados, <code>[]byte</code> y un <code>error</code>, pero ya que estos son asignables a los tipos de resultados declarados de <code>httpGetBody</code>–<code>interface{}</code> y <code>error</code>, respectivamente–podemos devolver el resultado de la llamada sin mas preambulos. Hemos Elegimos este tipo retorno para <code>httpGetBody</code> para que se ajuste al tipo de funciones que nuestra memoria cache esta diseñado para memorizar.</p>
<p>Aqui esta el primer borrador de la cache:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/memo1/memo.go" >gopl.io/ch9/memo1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete memo proporciona concurrencia segura.</span>
<span class="c1">// momoizacion de una funcion de tipo Func.</span>
<span class="kn">package</span> <span class="nx">memo</span>

<span class="c1">// Un Memo almacena en cache los resultados de lamar a Func</span>
<span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// Func es el tipo de la funcion a memorizar.</span>
<span class="kd">type</span> <span class="nx">Func</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">result</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">err</span>   <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">cache</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span><span class="p">)}</span>
<span class="p">}</span>

<span class="c1">// NOTA: no es seguro concurrentemente!</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Una instancia de <code>Memo</code> almacena la funcion <code>f</code> a memorizar, de tipo <code>Func</code>, y la memoria cache, que es una correspondencia de strings a <code>results</code>. Cada <code>result</code> es simplemente el par de resultados devueltos por una llamada a <code>f</code>–un valor y un error. Vamos a mostrar algunas variaciones de <code>Memo</code> a medida que avanza el diseño, pero todos compartiran estos aspectos basicos.</p>
<p>A continuacion se muestra un ejemplo de como utilizar <code>Memo</code>. Para cada elemento en una corriente de URLs entrantes, llamamos a <code>Get</code>, registrando la latencia de la llamada y la cantidad de datos que devuelve:</p>
<div class="highlight"><pre><span></span><span class="nx">m</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">httpGetBody</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">incomingURLs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
  <span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s, %s, %d bytes\n&quot;</span><span class="p">,</span>
    <span class="nx">url</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">.([]</span><span class="kt">byte</span><span class="p">)))</span>
<span class="p">}</span>
</pre></div>
<p>Podemos utilizar el paquete <code>testing</code> (el tema del <a href="#Capitulo-11" >Capitulo 11</a>) para investigar sistematicamente el efecto de memorizacion. A partir de la salida de la prueba a continuacion, vemos que la corriente URL contiene duplicados, y que aunque la primer llamada a <code>(*Memo).Get</code> para cada URL toma cientos de milisegundos, la segunda peticion devuelve la misma cantidad de datos en menos de un milisegundo.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -v gopl.io/ch9/memo1
<span class="o">===</span> RUN   Test
https://golang.org, <span class="m">175</span>.026418ms, <span class="m">7537</span> bytes
https://godoc.org, <span class="m">172</span>.686825ms, <span class="m">6878</span> bytes
https://play.golang.org, <span class="m">115</span>.762377ms, <span class="m">5767</span> bytes
http://gopl.io, <span class="m">749</span>.887242ms, <span class="m">2856</span> bytes
https://golang.org, 721ns, <span class="m">7537</span> bytes
https://godoc.org, 152ns, <span class="m">6878</span> bytes
https://play.golang.org, 205ns, <span class="m">5767</span> bytes
http://gopl.io, 326ns, <span class="m">2856</span> bytes
--- PASS: Test <span class="o">(</span><span class="m">1</span>.21s<span class="o">)</span>
PASS
ok gopl.io/ch9/memo1   <span class="m">1</span>.257s
</pre></div>
<p>Esta prueba ejecuta todas las llamadas a <code>Get</code> secuencialmente.</p>
<p>Dado que las solicitudes HTTP son una gran oportunidad para el paralelismo, cambiemos la prueba para que realice todas las solicitudes simultaneamente. La prueba utiliza un <code>sync.WaitGroup</code> que esperar hasta la ultima solicitud se ha completada antes de regresar.</p>
<div class="highlight"><pre><span></span><span class="nx">m</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">httpGetBody</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="k">for</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">incomingURLs</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s, %s, %d bytes\n&quot;</span><span class="p">,</span>
      <span class="nx">url</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">.([]</span><span class="kt">byte</span><span class="p">)))</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
  <span class="p">}(</span><span class="nx">url</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">n</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
</pre></div>
<p>La prueba se ejecuta mucho mas rapido, pero por desgracia es poco probable que funcione correctamente todo el tiempo. Podemos notar fallos inesperados de cache, o resultados de cache que devuelven valores incorrectos, o incluso se bloquea.</p>
<p>Peor aun, es probable que funcione correctamente <em>algunas</em> de las veces, por lo que ni siquiera se puede notar que tiene un problema. Pero si ejecutamos con la bandera <code>-race</code>, el detector de carrera (<a href="#Seccion-9.6" >§9.6</a>) a menudo imprime un informe como este:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -run<span class="o">=</span>TestConcurrent -race -v gopl.io/ch9/memo1
<span class="o">===</span> RUN   TestConcurrent
...
WARNING: DATA RACE
Write by goroutine <span class="m">36</span>:
  runtime.mapassign1<span class="o">()</span>
      ~/go/src/runtime/hashmap.go:411 +0x0
  gopl.io/ch9/memo1.<span class="o">(</span>*Memo<span class="o">)</span>.Get<span class="o">()</span>
      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
Previous write by goroutine <span class="m">35</span>:
  runtime.mapassign1<span class="o">()</span>
      ~/go/src/runtime/hashmap.go:411 +0x0
  gopl.io/ch9/memo1.<span class="o">(</span>*Memo<span class="o">)</span>.Get<span class="o">()</span>
      ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
...
Found <span class="m">1</span> data race<span class="o">(</span>s<span class="o">)</span>
FAIL    gopl.io/ch9/memo1   <span class="m">2</span>.393s
</pre></div>
<p>La referencia a <code>memo.go:32</code> nos dice que dos goroutines han actualizado el mapa <code>cache</code> sin ninguna sincronizacion intermedia. <code>Get</code> no es concurrentemente segura: tiene una carrera de datos.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</pre></div>
<p>La manera mas sencilla de hacer que la cache sea concurrentemente segura es utilizar sincronizacion basada en monitor. Todo lo que tenemos que hacer es añadir un mutex a <code>Memo</code>, adquirir el bloqueo de exclusion mutua en el inicio de <code>Get</code> y liberarlo despues de su regreso, de modo que las dos operaciones <code>cache</code> ocurran dentro de la seccion critica:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/memo2/memo.go" >gopl.io/ch9/memo2</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// custodia a cache</span>
  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// Get es concurrentemente segura.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora el detector de carreras esta en silencio, incluso cuando se ejecutan las pruebas concurrentemente. Desafortunadamente este cambio a <code>Memo</code> invierte nuestras mejoras de rendimiento anteriores. Al mantener el bloquo durante la duracion de cada llamada a <code>f</code>, <code>Get</code> serializa todas las operaciones de E/S que pretendiamos poner en paralelo. Lo que necesitamos es una cache <em>sin bloqueo</em>, una que no serialice las llamadas a la funcion que memoizes.</p>
<p>En la proxima implementacion de <code>Get</code>, a continuacion, la llamada gorutina adquiere el bloqueo  dos veces: una vez para la busqueda, y luego una segunda vez para la actualizacion si la busqueda devuelve nada. En el medio, otras gorutinas son libres de usar la memoria cache.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/memo3/memo.go" >gopl.io/ch9/memo3</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

    <span class="c1">// Entre las dos secciones criticas, varias gorutinas</span>
    <span class="c1">// pueden correr para calcular f(key) y actualizar el mapa.</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>El rendimiento mejora de nuevo, pero ahora observamos que algunas URL se estan recuperando dos veces. Esto ocurre cuando dos o mas gorutinas llaman a <code>Get</code> para la misma URL o casi al mismo tiempo. Ambos consultar la memoria cache, no encontran ningun valor, y luego llama a la funcion lenta <code>f</code>. Luego ambos actualizan el mapa con el resultado que obtuvieron. Uno de los resultados es sobrescrito por el otro.</p>
<p>Idealmente, nos gustaria evitar este trabajo redundante. Esta caracteristica a veces se denomina <em>supresion de duplicados</em>. En la version de <code>Memo</code> a continuacion, cada elemento del mapa es un puntero a una estructura <code>entry</code>. Cada <code>entry</code> contiene el resultado memorizado de una llamada a la funcion <code>f</code>, como antes, pero, ademas, contiene un canal llamado <code>ready</code>. Justo despues de establecer <code>result</code> con <code>entry</code>, este canal se cerrara, a <em>emitir</em> (<a href="#Seccion-8.9" >§8.9</a>) a cualquier otra gorutina que ahora es seguro para ellos leer el resultado de la entrada.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/memo4/memo.go" >gopl.io/ch9/memo4</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">res</span>   <span class="nx">result</span>
  <span class="nx">ready</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// cerrado cuando res esta listo</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">f</span><span class="p">:</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">cache</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span><span class="p">)}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">f</span>     <span class="nx">Func</span>
  <span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards cache</span>
  <span class="nx">cache</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
  <span class="nx">e</span> <span class="o">:=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// Esta es la primer solicitud de esta clave.</span>
    <span class="c1">// Esta gorutina se hare rosponsable de calcular</span>
    <span class="c1">// el valor  y transmitir la condicion de ready.</span>
    <span class="nx">e</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entry</span><span class="p">{</span><span class="nx">ready</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})}</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

    <span class="nb">close</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span><span class="p">)</span> <span class="c1">// condicion de transmicion lista</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// This is a repeat request for this key.</span>
    <span class="nx">memo</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="o">&lt;-</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span>      <span class="c1">// esperar condicion de ready</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Una llamada a <code>Get</code> ahora implica la adquisicion del bloqueo mutex que custodia el mapa <code>cache</code>, buscando en el mapa un puntero a una <code>entry</code> existente, asignando e insertando una nueva <code>entry</code> si no se encontro ninguna, y luego liberando el bloqueo. Si habia una <code>entry</code> existente, su valor no esta necesariamente listo aun–otra gorutina podria estar llamando a la funcion lenta <code>f</code>–por lo que la gorutina que llama debe esperar la condicion <q>ready</q> de <code>entry</code> antes de leer el <code>entry</code> de <code>result</code>. Esto se hace leyendo un valor del canal <code>ready</code>, ya que esto bloquea la operacion hasta que el canal esta cerrado.</p>
<p>Si no hay una <code>entry</code> existente, a continuacion, insenta una nueva <code>entry</code> <q>no listo</q> en el mapa, la gorutina actual se hace responsable de la invocacion de la funcion lenta, actualizacion <code>entry</code>, y trasmitiendo la disponibilidad de la nueva <code>entry</code> a cualquier otra gorutina que podria (para entonces) estar esperando.</p>
<p>Observe que las variables <code>e.res.value</code> y <code>e.res.err</code> en <code>entry</code> se comparten entre varias gorutinas. la gorutina que crea <code>entry</code> establece sus valores, y otras gorutinas leer sus valores una vez que la condicion <q>ready</q> ha sido transmitida. A pesar de ser accedido por multiples gorutinas, no es necesario el bloqueo mutex. El cierre del canal <code>ready</code> <em>sucede antes</em> de cualquier otra gorutina reciba el evento de transmision, por lo que la escritura a esas variables en la primer gorutina <em>sucede antes</em> de que sean leidos por gorutinas posteriores. No hay carrera de datos.</p>
<p>Nuestra cache concurrente, que suprime duplicados y no bloquea, esta completa.</p>
<p>La implementacion de <code>Memo</code> anterior utiliza un mutex para custodiar una variable de un mapa que es compartida por cada gorutina que llame a <code>Get</code>. Es interesante contrastar este diseño con uno alternativo en el que la variable de mapa se confina a una <em>gorutina monitor</em> a la que los llamantes de <code>Get</code> deben enviar un mensaje.</p>
<p>Las declaraciones de <code>Func</code>, <code>result</code>, y <code>entry</code> se mantienen como antes:</p>
<div class="highlight"><pre><span></span><span class="c1">// Func es el tipo de la funcion a memorizar.</span>
<span class="kd">type</span> <span class="nx">Func</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>

<span class="c1">// Un result es el resultado de llamar a un Func</span>
<span class="kd">type</span> <span class="nx">result</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">err</span>   <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">res</span>   <span class="nx">result</span>
  <span class="nx">ready</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// cerrado cuando res esta listo</span>
<span class="p">}</span>
</pre></div>
<p>Sin embargo, el typo <code>Memo</code> ahora consiste en un canal, <code>requests</code>, a traves del cual el llamador de <code>Get</code> se comunica con la gorutina monitor. El tipo de elemento del canal es un <code>request</code>. Con este esquema el llamador de <code>Get</code> envia a la gorutina monitor la clave, es decir, el argumento de la funcion a memorizar, y otro canal, <code>response</code>, sobre el cual el resultado debe ser enviado de vuelta cuando este disponible. Este canal llevara un solo valor.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch9/memo5/memo.go" >gopl.io/ch9/memo5</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Un request es un mensaje solicitado para que Func aplique la clave</span>
<span class="kd">type</span> <span class="nx">request</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">key</span>      <span class="kt">string</span>
  <span class="nx">response</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">result</span> <span class="c1">// el cliente quiere un solo resultado</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Memo</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">requests</span> <span class="kd">chan</span> <span class="nx">request</span> <span class="p">}</span>

<span class="c1">// New regresa una memorizacion de f. Los clientes deben llamar posteriormente a Close.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="o">*</span><span class="nx">Memo</span> <span class="p">{</span>
  <span class="nx">memo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Memo</span><span class="p">{</span><span class="nx">requests</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">request</span><span class="p">)}</span>
  <span class="k">go</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">server</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">memo</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">response</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">result</span><span class="p">)</span>
  <span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span> <span class="o">&lt;-</span> <span class="nx">request</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span> <span class="nx">response</span><span class="p">}</span>
  <span class="nx">res</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">response</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span> <span class="nb">close</span><span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>El metodo <code>Get</code>, arriba, crea un canal de respuesta, lo pone en la solicitud, lo envia a la gorutina monitor, despues recibe inmediatamente de esta.</p>
<p>La <code>cache</code> variable se confina a la gorutina monitor <code>(*Memo).server</code>, que se muestra a continuacion. El monitor lee las peticiones en un bucle hasta que el canal de solicitud es cierra mediente el metodo <code>Close</code>. Para cada solicitud, consulta la cache, creando e insertando una nueva <code>entry</code> si no se encontro ninguna.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">memo</span> <span class="o">*</span><span class="nx">Memo</span><span class="p">)</span> <span class="nx">server</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">cache</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">entry</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">memo</span><span class="p">.</span><span class="nx">requests</span> <span class="p">{</span>
    <span class="nx">e</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// Esta es la primer solicitud para esta clave</span>
      <span class="nx">e</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entry</span><span class="p">{</span><span class="nx">ready</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})}</span>
      <span class="nx">cache</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
      <span class="k">go</span> <span class="nx">e</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// llama a f(key)</span>
    <span class="p">}</span>
    <span class="k">go</span> <span class="nx">e</span><span class="p">.</span><span class="nx">deliver</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">response</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nx">call</span><span class="p">(</span><span class="nx">f</span> <span class="nx">Func</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Evalua la funcion.</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  <span class="c1">// Transmite la condicion ready.</span>
  <span class="nb">close</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nx">deliver</span><span class="p">(</span><span class="nx">response</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Espera por la condicion ready.</span>
  <span class="o">&lt;-</span><span class="nx">e</span><span class="p">.</span><span class="nx">ready</span>
  <span class="c1">// Envia el resultado al cliente.</span>
  <span class="nx">response</span> <span class="o">&lt;-</span> <span class="nx">e</span><span class="p">.</span><span class="nx">res</span>
<span class="p">}</span>
</pre></div>
<p>De manera similar a la version basada en mutex, la primer solicitud de una clave dada se convierte en responsable de llamar a la funcion <code>f</code> de esa clave, almacenar el resultado en <code>entry</code>, y la difundir la disponibilidad de <code>entry</code> al cerrar el canal <code>ready</code>. Esto se hace mediante <code>(*entry).call</code>.</p>
<p>Una solicitud posterior para la misma clave se encuentra el <code>entry</code> existente en el mapa, espera a que el resultado este listo, y envia el resultado a traves del canal de respuesta a la gorutina cliente que llama a <code>Get</code>. Esto se hace mediante <code>(*entry).deliver</code>. Los metodos <code>call</code> y <code>deliver</code> deben ser llamados en sus propias gorutinas para asegurar que el monitor de gorutina no detiene el procesamiento de nuevas solicitudes.</p>
<p>Este ejemplo muestra que es posible construir muchas estructuras simultaneas utilizando cualquiera de los dos enfoques–variables compartidas y bloqueos, o comunicacion de procesos secuenciales–sin excesiva complejidad.</p>
<p>No siempre es obvio que enfoque es preferible en una situacion dada, pero vale la pena saber como se corresponden. A veces, cambiar de un enfoque a otro puede hacer que su codigo sea mas sencillo.</p>
<p><b>Ejercicio 9.3</b>: Extender el tipo <code>Func</code> y el metodo <code>(*Memo).Get</code> para que los llamantes puedan proporcionar un canal <code>done</code> opcional a traves del cual se puede cancelar la operacion (<a href="#Seccion-8.9" >§8.9</a>). Los resultados de una <code>Func</code> cancelada no deben almacenarse en cache.</p>
</div>
<h3 id="Seccion-9.8" >Gorutinas e Hilos</h3>
<div class="hBody-3" >
<p>En el capitulo anterior dijimos que la diferencia entre gorutinas e hilos del sistema operativo (OS) ser podrian ignorar hasta mas tarde. Aunque las diferencias entre ellas son esencialmente cuantitativas, una diferencia cuantitativa lo suficientemente grande se convierte en una cualitativa, y lo mismo sucede con las gorutinas y los hilos. Ha llegado el momento de distinguirlos.</p>
</div>
<h4 id="Seccion-9.8.1" >Pilas Expandibles</h4>
<div class="hBody-4" >
<p>Cada hilo del Sistema Operativo tiene un bloque de tamaño fijo de memoria (a menudo tan grande como 2 MB) para su pila, el area de trabajo donde se guarda las variables locales de las llamadas a funciones que estan en curso o suspendidos temporalmente mientras que otra funcion se llama. Esta pila de tamaño fijo es simultaneamente demasiado y muy poco. Una pila de 2MB seria una enorme desperdicio de memoria para una pequeña gorutina, como una que simplemente espera un <code>WaitGroup</code> y luego cierra un canal. No es raro que un programa Go cree cientos de miles de gorutinas al mismo tiempo, lo que seria imposible con pilas tan grandes. Sin embargo, a pesar de su tamaño, las pilas de tamaño fijo no siempre son lo suficientemente grandes para las funciones mas complejas y profundamente recursivas. Cambiar el tamaño fijo puede mejorar la eficiencia del espacio y permitir que se creen mas subprocesos, o puede permitir funciones mas profundamente recursivas, pero no puede hacer ambas cosas.</p>
<p>En contraste, un gorutina comienza su vida con una pequeña pila, tipicamente 2KB. La pila de una gorutina, como la pila de un subproceso de sistema operativo, contiene las variables locales de las llamadas de funcion activas y suspendidas, pero a diferencia de un subproceso de sistema operativo, la pila de una gorutina no es fija; Crece y se encoge segun sea necesario. El limite de tamaño para una pila de gorutina puede ser tanto como 1 GB, varios ordenes de magnitud mas grande que la pila de un hilo de tamaño fijo, aunque por supuesto algunas gorutinas utilizan mucho.</p>
<p><b>Ejercicio 9.4</b>: Construir una tuberia que conecta un numero arbitrario de gorutinas con canales. ¿Cual es el numero maximo de etapas de canalizacion que puede crear sin quedarse sin memoria? ¿Cuanto tarda un valor en transitar por toda la tuberia?</p>
</div>
<h4 id="Seccion-9.8.2" >Planificacion de Gorutina</h4>
<div class="hBody-4" >
<p>Los subprocesos del sistema operativo estan programados por el kernel del sistema operativo. Cada pocos milisegundos, un temporizador de hardware interrumpe el procesador, lo que hace que se invoque una funcion del nucleo llamada el <em>planificador</em>. Esta funcion suspende el subproceso actualmente en ejecucion y guarda sus registros en la memoria, revisa la lista de subprocesos y decide cual deberia ejecutar a continuacion, restaura los registros de ese subproceso de la memoria y reanuda la ejecucion de ese subproceso. Debido a que los hilos del SO estan programadas por el nucleo, pasar el control de un hilo a otro requiere un <em>cambio de contexto</em> completo, es decir, guardar el estado del hilo de un usuario en memoria, restaurando el estado de otro, y actualizar las estructuras de datos del planificador. Esta operacion es lenta, debido a su pobre localidad y el numero de accesos de memoria requeridos, e historicamente solo ha empeorado a medida que aumenta el numero de ciclos de CPU requeridos para acceder a la memoria.</p>
<p>El runtime de Go contiene su propio planificador que utiliza una tecnica conocida como <em>planificacion m:n</em>, ya que multiplexa (o planifica) <em>m</em> gorutinas en <span class="math" >n</span> hilos del SO. El trabajo del planificador Go es analogo al del planificador del nucleo, pero solo se refiere a las gorutinas de un solo programa Go.</p>
<p>A diferencia del planificador de hilos del sistema operativo, el programador Go no se invoca periodicamente por un temporizador de hardware, sino implicitamente por ciertas construcciones en lenguaje Go. Por ejemplo, cuando una gorutina llama a <code>time.Sleep</code> o bloquea en una operacion de canal o mutex, el planificador la pone a dormir y se ejecuta otra gorutina hasta que es hora de despertar el primero. Debido a que no necesita un cambio al contexto del kernel, la reprogramacion de una gorutina es mucho mas barata que la reprogramacion de un hilo.</p>
<p><b>Ejercicio 9.5</b>: Escribir un programa con dos gorutinas que envien mensajes de ida y vuelta sobre dos canales sin bufer en modo ping-pong. ¿Cuantas comunicaciones por segundo puede mantener el programa?</p>
</div>
<h4 id="Seccion-9.8.3" ><code>GOMAXPROCS</code></h4>
<div class="hBody-4" >
<p>El planificador Go utiliza un parametro llamado <code>GOMAXPROCS</code> para determinar cuantos hilos del OS puede estar ejecutando activamente en ejecucion el codigo Go al mismo tiempo. Su valor predeterminado es el numero de CPUs en la maquina, por lo que en una maquina con 8 CPUs, el planificador programara el codigo Go en hasta 8 hilos del SO a la vez. (<code>GOMAXPROCS</code> es la <em>n</em> en la planificacion <em>m:n</em>). Las Gorutinas que estan durmiendo o bloqueadas en una comunicacion no necesitan un hilo en absoluto. Las Gorutinas que estan bloqueando llamadas E/S u otro tipo llamadas al sistema o llamadas a funciones no Go, no necesita un hilo del SO, por lo que <code>GOMAXPROCS</code> no tienen por que dar cuenta de ellas.</p>
<p>Puede controlar de forma explicita este parametro mediante la variable de entorno <code>GOMAXPROCS</code> o la funcion <code>runtime.GOMAXPROCS</code>. Podemos ver el efecto de <code>GOMAXPROCS</code> en este pequeño programa, que imprime un flijo sin fin de unos y ceros:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">{</span>
  <span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span></span>$ <span class="nv">GOMAXPROCS</span><span class="o">=</span><span class="m">1</span> go run hacker-cliche.go
<span class="m">111111111111111111110000000000000000000011111</span>...
$ <span class="nv">GOMAXPROCS</span><span class="o">=</span><span class="m">2</span> go run hacker-cliche.go
<span class="m">010101010101010101011001100101011010010100110</span>...
</pre></div>
<p>En la primera ejecucion, al menos una gorutina fue ejecutada a la vez. Inicialmente, era la gorutina principal, que imprime unos. Despues de un periodo de tiempo, el programador de Go lo puso a dormir y desperto la gorutina que imprime ceros, dandole un giro para correr en el hilo del SO. En la segunda ejecucion, habia dos subprocesos de sistema operativo disponibles, por lo que ambos gorutinas se ejecutaron simultaneamente, imprimiendo digitos en la misma tasa. Debemos destacar que muchos factores estan involucrados en la programacion de gorutinas, y el tiempo de ejecucion esta en constante evolucion, por lo que sus resultados pueden diferir de los anteriores.</p>
<p><b>Ejercicio 9.6</b>: Medir como varia el desempeño de un programa paralelo ligado a calculo (vease el Ejercicio 8.5) con <code>GOMAXPROCS</code>. ¿Cual es el valor optimo en su computadora? ¿Cuantas CPU tiene su computadora?</p>
</div>
<h4 id="Seccion-9.8.4" >Las Gorutinas No Tienen Identidad</h4>
<div class="hBody-4" >
<p>En la mayoria de los sistemas operativos y lenguajes de programacion que admiten multihilo, el subproceso actual tiene una identidad distinta que se puede obtener facilmente como un valor ordinario, normalmente un entero o puntero. Esto hace que sea facil de construir una abstraccion denominada <em>almacenamiento local de hilos</em>, que es esencialmente un mapa global con clave de identidad de hilos, de modo que cada hilo puede almacenar y recuperar valores independientes de los otros hilos.</p>
<p>Las gorutinas no tienen ninguna nocion de la identidad que es accesible al programador. Esto es por diseño, ya que el almacenamiento local de hilos tiende a ser abusado. Por ejemplo, en un servidor web implementado en un lenguaje con almacenamiento local de hilos, es comun que muchas funciones busquen informacion sobre la solicitud HTTP en cuyo nombre estan trabajando actualmente buscando en ese almacenamiento. Sin embargo, al igual que con los programas que dependen excesivamente de las variables globales, esto puede conducir a una <q>accion a distancia</q> malsana en la que el comportamiento de una funcion no esta determinado unicamente por sus argumentos, sino por la identidad del hilo en el que se ejecuta. Por lo tanto, si la identidad del hilo debe cambiar–algunos hilos de trabajo se alistan para ayudar, a–la funcion se comporta de forma misteriosa.</p>
<p>Go fomenta un estilo de programacion mas simple en el que los parametros que afectan al comportamiento de una funcion son explicitos. Esto no solo hace que los programas sean mas faciles de leer, sino que nos permite asignar libremente subtareas de una funcion dada a muchas gorutinas diferentes sin preocuparnos por su identidad.</p>
<p>Ahora ha aprendido sobre todas las caracteristicas del lenguje que necesita para escribir programas Go. En los proximos dos capitulos, retrocederemos para ver algunas de las practicas y herramientas que soportan la programacion en general: como estructurar un proyecto como un conjunto de paquetes, y como obtener, construir, probar, evaluar, evaluar, documentar, y compartir esos paquetes.</p>
</div>
<h2 id="Capitulo-10" >Paquetes y la Herramienta Go</h2>
<div class="hBody-2" >
<p>A dia de hoy un programa de tamaño modesto podria contener 10.000 funciones. Sin embargo, su autor tiene que pensar en solo unas pocas de ellas y el diseñar aun menos, porque la gran mayoria fueron escritas por otros y puestas a disposicion para su reutilizacion a traves de paquetes.</p>
<p>Go incluye mas de 100 paquetes estandar que proporcionan las bases para la mayoria de las aplicaciones. La comunidad Go, con un prospero ecosistema para diseñar, compartir, reutilizar y mejorar paquetes ha publicado muchos mas, y usted puede encontrar un indice de busqueda en <a href="http://godoc.org" >http://godoc.org</a>. En este capitulo, mostraremos como utilizar los paquetes existentes y crear otros nuevos.</p>
<p>Go tambien viene con la herramienta <code class="command" >go</code>, un comando sofisticado pero facil de usar para gestionar los espacios de trabajo de los paquetes de Go. Desde el comienzo del libro, hemos estado mostrando como utilizar la herramienta <code class="command" >go</code> para descargar, compilar y ejecutar programas de ejemplo. En este capitulo, vamos a ver los conceptos subyacentes de la herramienta y daremos un paseo por sus capacidades, que incluyen la impresion de documentacion y la consulta de metadatos sobre los paquetes en el espacio de trabajo. En el siguiente capitulo vamos a explorar sus caracteristicas para realizar pruebas.</p>
</div>
<h3 id="Seccion-10.1" >Introduccion</h3>
<div class="hBody-3" >
<p>El proposito de cualquier sistema de paquetes es hacer que el diseño y mantenimiento de programas grandes sea practico, agrupando las caracteristicas relacionadas en unidades que puedan ser facilmente comprendidas y cambiadas, independientemente de los otros paquetes del programa. Esta <em>modularidad</em> permite que los paquetes sean compartidos y reutilizados por diferentes proyectos, distribuidos dentro de una organizacion, o puestos a disposicion del resto del mundo.</p>
<p>Cada paquete define un espacio de nombre distinto que incluye sus identificadores. Cada nombre esta asociado con un paquete en particular, lo que nos permite elegir nombres cortos y claros para los tipos, funciones, etc., que usamos con mas frecuencia, sin crear conflictos con otras partes del programa.</p>
<p>Los paquetes tambien proporcionan <em>encapsulacion</em> controlando que nombres son visibles o exportados fuera del paquete. La restriccion de la visibilidad de los miembros del paquete oculta las funciones y tipos de ayuda, de la API del paquete, lo que permite al responsable del paquete cambiar la implementacion con la confianza de que ningun codigo fuera del paquete se vera afectado. Restringir la visibilidad tambien oculta las variables para que los clientes puedan acceder y actualizarlas solo mediante funciones exportadas que preserven las invariantes internas o impongan la exclusion mutua en un programa concurrente.</p>
<p>Cuando cambiamos un archivo, debemos recompilar el paquete del archivo y potencialmente todos los paquetes que dependen de el. La compilacion de Go es notablemente mas rapida que la mayoria de los otros lenguajes compilados, incluso cuando se construye desde cero. Hay tres razones principales para la velocidad del compilador. En primer lugar, todas las importaciones deben estar listadas explicitamente al principio de cada archivo de origen, por lo que el compilador no tiene que leer y procesar un archivo completo para determinar sus dependencias. En segundo lugar, las dependencias de un paquete forman un grafo aciclico dirigido, y debido a que no hay ciclos, los paquetes pueden ser compilados por separado y tal vez en paralelo. Finalmente, el archivo de objeto de un paquete compilado Go registra informacion de exportacion no solo para el propio paquete, sino tambien para sus dependencias. Al compilar un paquete, el compilador debe leer un archivo de objeto para cada importacion pero no necesita mirar mas alla de estos archivos.</p>
</div>
<h3 id="Seccion-10.2" >Rutas de Importacion</h3>
<div class="hBody-3" >
<p>Cada paquete esta identificado por una cadena unica denominada su <em>ruta de importacion</em>. Las rutas de importacion son las cadenas que aparecen en las declaraciones <code>import</code>.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;math/rand&quot;</span>
  <span class="s">&quot;encoding/json&quot;</span>

  <span class="s">&quot;golang.org/x/net/html&quot;</span>

  <span class="s">&quot;github.com/go-sql-driver/mysql&quot;</span>
<span class="p">)</span>
</pre></div>
<p>Como mencionamos en la <a href="#Seccion-2.6.1" >Seccion 2.6.1</a>, la especificacion del lenguaje Go no define el significado de estas cadenas o como determinar ruta de importacion de un paquete, sino que deja estas cuestiones a las herramientas. En este capitulo, analizaremos con detalle como interpreta la herramienta <code class="command" >go</code>, ya que eso es lo que la mayoria de los programadores de Go utilizan para construir, probar, etc. Sin embargo, existen otras herramientas. Por ejemplo, los programadores de Go que utilizan el sistema de compilacion multilenguaje interno de Google siguen reglas diferentes para nombrar y localizar paquetes, especificar pruebas y demas, que se ajusten mas a las convenciones de ese sistema.</p>
<p>Para los paquetes que desea compartir o publicar, las vias de acceso de importacion deben ser unicas a nivel global. Para evitar conflictos, las rutas de importacion de todos los paquetes distintos de los de la biblioteca estandar deben comenzar con el nombre de dominio de Internet de la organizacion que posee o aloja el paquete; Esto tambien hace posible encontrar paquetes. Por ejemplo, la declaracion anterior importa un analizador HTML mantenido por el equipo Go y un popular controlador de base de datos MySQL de terceros.</p>
</div>
<h3 id="Seccion-10.3" >La Declaracion <code>package</code></h3>
<div class="hBody-3" >
<p>En Go se requiere una declaracion <code>package</code> al inicio de cada archivo fuente. Su proposito principal es determinar el identificador por defecto para ese paquete (denominado el <em>nombre del paquete</em>) cuando se importa por otro paquete.</p>
<p>Por ejemplo, todos los archivos del paquete <code>math/rand</code> comienza con <code>package rand</code>, por lo que al importar este paquete, puede acceder a sus miembros como <code>rand.Int</code>, <code>rand.Float64</code>, etc.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;math/rand&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
<p>Convencionalmente, el nombre del paquete es el ultimo segmento de la ruta de importacion y, como resultado, dos paquetes pueden tener el mismo nombre aunque sus rutas de importacion difieran necesariamente. Por ejemplo, los paquetes cuyas rutas de importacion son <code>math/rand</code> y <code>crypto/rand</code> tienen el nombre <code>rand</code>. Veremos como usar ambos en el mismo programa en un momento.</p>
<p>Hay tres excepciones principales a la convencion del <q>ultimo segmento</q>. La primera es que un paquete que define un comando (un programa ejecutable Go) siempre tiene el nombre <code>main</code>, independientemente de la ruta de importacion del paquete. Esta es una señal para <code class="command" >go build</code> (<a href="#Seccion-10.7.3" >§10.7.3</a>) que debe invocar el enlazador para crear un archivo ejecutable.</p>
<p>La segunda excepcion es que algunos archivos en el directorio pueden tener el sufijo <code>_test</code> en su nombre de paquete si el nombre del archivo termina con <code>_test.go</code>. Un directorio de este tipo puede definir dos paquetes: el habitual, ademas de otro denominado <em>paquete de prueba externa</em>. El sufijo <code>_test</code> indica a <code class="command" >go test</code> que debe construir ambos paquetes, e indica que archivos pertenecen a cada paquete. Los paquetes de prueba externos se utilizan para evitar ciclos en el grafico de importacion que surgen de las dependencias de la prueba; se cubren con mas detalle en la <a href="#Seccion-11.2.4" >Seccion 11.2.4</a>.</p>
<p>La tercera excepcion es que algunas herramientas para la gestion de dependencias añaden sufijos del numero de version a rutas de importacion, como <code>&quot;gopkg.in/yaml.v2&quot;</code>. El nombre del paquete excluye el sufijo, por lo que en este caso seria simplemente <code>yaml</code>.</p>
</div>
<h3 id="Seccion-10.4" >Declaraciones Import</h3>
<div class="hBody-3" >
<p>Un archivo de codigo Go puede contener cero o mas declaraciones <code>import</code> inmediatamente despues de la declaracion <code>package</code> y antes de la primera declaracion de no importacion. Cada declaracion de importacion puede especificar la ruta de importacion de un unico paquete o varios paquetes en una lista entre parentesis. Las dos formas a continuacion son equivalentes pero la segunda forma es mas comun.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kn">import</span> <span class="s">&quot;os&quot;</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>
</pre></div>
<p>Los paquetes importados pueden agruparse introduciendo lineas en blanco; Tales grupos suelen indicar diferentes dominios. El orden no es significativo, pero por convencion las lineas de cada grupo se ordenan alfabeticamente. (Tanto <code class="command" >gofmt</code> como <code class="command" >goimports</code> las agruparan y ordenaran por usted.)</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;html/template&quot;</span>
  <span class="s">&quot;os&quot;</span>

  <span class="s">&quot;golang.org/x/net/html&quot;</span>
  <span class="s">&quot;golang.org/x/net/ipv4&quot;</span>
<span class="p">)</span>
</pre></div>
<p>Si tenemos que importar dos paquetes cuyos nombres son los mismos, como <code>math/rand</code> y <code>crypto/rand</code>, en un tercer paquete, la declaracion de importacion debe especificar un nombre alternativo para al menos uno de ellos para evitar un conflicto. Esto se denomina <em>renombrar la importacion</em>.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;crypto/rand&quot;</span>
  <span class="nx">mrand</span> <span class="s">&quot;math/rand&quot;</span> <span class="c1">// alternative name mrand avoids conflict</span>
<span class="p">)</span>
</pre></div>
<p>El nombre alternativo solo afecta al archivo de importacion. Otros archivos, incluso los del mismo paquete, pueden importar el paquete usando su nombre predeterminado o un nombre diferente.</p>
<p>Renombrar una importacion ser util incluso cuando no hay conflicto. Si el nombre del paquete importado es dificil de manejar, como ocurre a veces con el codigo generado automaticamente, es posible que el nombre abreviado sea mas conveniente. El mismo nombre abreviado debe ser usado consistentemente para evitar confusiones. La eleccion de un nombre alternativo puede ayudar a evitar conflictos con nombres de variables locales comunes. Por ejemplo, en un archivo con muchas variables locales llamado <code>path</code>, podriamos importar el paquete estandar <code>&quot;path&quot;</code> como <code>pathpkg</code>.</p>
<p>Cada declaracion de importacion establece una dependencia del paquete actual al paquete importado. La herramienta <code class="command" >go build</code> informara un error si estas dependencias forman un ciclo.</p>
</div>
<h3 id="Seccion-10.5" >Importaciones En Blanco</h3>
<div class="hBody-3" >
<p>Es un error importar un paquete en un archivo pero no hacer referencia al nombre que define, dentro de ese archivo. Sin embargo, en ocasiones hay que importar un paquete solo por los efectos secundarios de hacerlo: evaluacion de las expresiones de inicializador de sus variables y ejecucion de sus funciones <code>init</code> a nivel de paquete (<a href="#Seccion-2.6.2" >§2.6.2</a>). Para suprimir el error de <q>importacion no utilizada</q> que encontrariamos de otra manera, debemos utilizar una importacion de cambio de nombre en la que el nombre alternativo sea <code>_</code>, el identificador en blanco. Como de costumbre, el identificador en blanco nunca puede ser referenciado.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nx">_</span> <span class="s">&quot;image/png&quot;</span> <span class="c1">// registra decodificador PNG</span>
</pre></div>
<p>Esto se conoce como una <em>importacion en blanco</em>. Se utiliza con mayor frecuencia para implementar un mecanismo de tiempo de compilacion mediante el cual el programa principal puede habilitar caracteristicas opcionales mediante la importacion en blanco de paquetes adicionales. Primero veremos como usarlo, luego veremos como funciona.</p>
<p>De la biblioteca estandar el paquete <code>image</code> exporta una funcion <code>Decode</code> que lee bytes desde un <code>io.Reader</code>, se da cuenta de que el formato de imagen se utiliza para codificar los datos, invoca el decodificador apropiado, a continuacion, devuelve la resultante <code>image.Image</code>. Usando <code>image.Decode</code>, es facil construir un convertidor de imagenes simple que lee una imagen en un formato y lo escribe en otro:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch10/jpeg/main.go" >gopl.io/ch10/jpeg</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El comando jpeg lee una imagen PNG de la entrada estandar</span>
<span class="c1">// y lo escribe como una imagen JPEG en la salida estandar.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;image&quot;</span>
  <span class="s">&quot;image/jpeg&quot;</span>
  <span class="nx">_</span> <span class="s">&quot;image/png&quot;</span> <span class="c1">// registra decodificador PNG</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">toJPEG</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;jpeg: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">toJPEG</span><span class="p">(</span><span class="nx">in</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">img</span><span class="p">,</span> <span class="nx">kind</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nx">Decode</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Input format =&quot;</span><span class="p">,</span> <span class="nx">kind</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nx">Encode</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">img</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">jpeg</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span><span class="nx">Quality</span><span class="p">:</span> <span class="mi">95</span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Si alimentamos con la salida de <code>gopl.io/ch3/mandelbrot</code> (<a href="#Seccion-3.3" >§3.3</a>) al programa convertidor, detecta el formato de entrada PNG y escribe una version JPEG de la Figura 3.3.</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch3/mandelbrot
$ go build gopl.io/ch10/jpeg
$ ./mandelbrot <span class="p">|</span> ./jpeg &gt;mandelbrot.jpg
Input <span class="nv">format</span> <span class="o">=</span> png
</pre></div>
<p>Observe la importacion en blanco de <code>image/png</code>. Sin esa linea, el programa compila y vincula como de costumbre, pero ya no puede reconocer o decodificar la entrada en formato PNG:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch10/jpeg
$ ./mandelbrot <span class="p">|</span> ./jpeg &gt;mandelbrot.jpg
jpeg: image: unknown format
</pre></div>
<p>Asi es como funciona. La biblioteca estandar ofrece descodificadores para GIF, PNG y JPEG, y los usuarios pueden proporcionar otros, pero para mantener pequeños ejecutables, los decodificadores no se incluyen en una aplicacion a menos que se solicite explicitamente. la funcion <code>image.Decode</code> consulta una tabla de formatos soportados. Cada entrada en la tabla especifica cuatro cosas: el nombre del formato; Una cadena que es un prefijo de todas las imagenes codificadas de esta manera, utilizadas para detectar la codificacion; una funcion <code>Decode</code> que decodifica una imagen codificada; y otra funcion <code>DecodeConfig</code> que decodifica solo los metadatos de la imagen, como su tamaño y espacio de color. Se añade una entrada a la tabla llamando a <code>image.RegisterFormat</code>, normalmente desde destro del paquete inicializador del paquete de soporte para cada formato, como este en <code>image/png</code> :</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">png</span> <span class="c1">// image/png</span>

<span class="kd">func</span> <span class="nx">Decode</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Image</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="nx">DecodeConfig</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Config</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pngHeader</span> <span class="p">=</span> <span class="s">&quot;\x89PNG\r\n\x1a\n&quot;</span>
  <span class="nx">image</span><span class="p">.</span><span class="nx">RegisterFormat</span><span class="p">(</span><span class="s">&quot;png&quot;</span><span class="p">,</span> <span class="nx">pngHeader</span><span class="p">,</span> <span class="nx">Decode</span><span class="p">,</span> <span class="nx">DecodeConfig</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>El efecto es que una aplicacion solo necesita importar el paquete en blanco para el formato que necesita para hacer a la funcion <code>image.Decode</code> capaz de decodificarlo.</p>
<p>El paquete <code>database/sql</code> utiliza un mecanismo similar para permitir a los usuarios instalar solo los controladores de base de datos que necesita. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;database/mysql&quot;</span>
  <span class="nx">_</span> <span class="s">&quot;github.com/lib/pq&quot;</span>                <span class="c1">// habilitira el soporte para Postgres</span>
  <span class="nx">_</span> <span class="s">&quot;github.com/go-sql-driver/mysql&quot;</span>   <span class="c1">// habilitira el soporte para MySQL</span>
<span class="p">)</span>

<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;postgres&quot;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span> <span class="c1">// OK</span>
<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;mysql&quot;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span>    <span class="c1">// OK</span>
<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">sql</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;sqlite3&quot;</span><span class="p">,</span> <span class="nx">dbname</span><span class="p">)</span>  <span class="c1">// devuelve error: controlador desconocido &quot;sqlite3&quot;</span>
</pre></div>
<p><b>Ejercicio 10.1</b>: Extender el programa <code class="command" >jpeg</code> para que convierte cualquier formato de entrada compatible con cualquier formato de salida, utilizando <code>image.Decode</code> para detectar el formato de entrada y una bandera para seleccionar el formato de salida.</p>
<p><b>Ejercicio 10.2</b>: Definir una funcion generica lectura de archivos capaz de leer archivos ZIP (<code>archive/zip</code>) y archivos tar POSIX (<code>archive/tar</code>). Utilice un mecanismo de registro similar al descrito anteriormente para que el soporte para cada formato de archivo se pueda conectar usando importaciones en blanco.</p>
</div>
<h3 id="Seccion-10.6" >Paquetes y Nombres</h3>
<div class="hBody-3" >
<p>En esta seccion, ofreceremos algunos consejos sobre como seguir las distintivas convenciones de Go para nombrar paquetes y sus miembros.</p>
<p>Al crear un paquete, mantenga su nombre corto, pero no tan corto como para ser criptico. Los paquetes mas utilizados en la biblioteca estandar se nombran <code>bufio</code>, <code>bytes</code>, <code>flag</code>, <code>fmt</code>, <code>http</code>, <code>io</code>, <code>json</code>, <code>os</code>, <code>sort</code>, <code>sync</code> y <code>time</code>.</p>
<p>Sea descriptivo y sin ambigüedades donde sea posible. Por ejemplo, no nombre un paquete de utilidades <code>util</code> cuando un nombre como <code>imageutil</code> o <code>ioutil</code> es especifico y aun asi conciso. No se debe elegir nombres de los paquetes que se utilizan comunmente para las variables locales relacionados, o puede obligar a los clientes del paquete a renombrar las importaciones, al igual que con el paquete <code>path</code>.</p>
<p>Los nombres de los paquetes usualmente toman la forma singular. Los paquetes estandar <code>bytes</code>, <code>errors</code> y <code>strings</code> utilizan el plural para evitar ocultar los tipos predeclarados correspondientes y, en el caso de <code>go/types</code>, para evitar conflictos con una palabra clave.</p>
<p>Evite nombres de paquetes que ya tengan otras connotaciones. Por ejemplo, se utilizamos originalmente el nombre <code>temp</code> para el paquete de conversion de temperatura en la <a href="#Seccion-2.5" >Seccion 2.5</a>, pero eso no duro mucho tiempo. Era una idea terrible, porque <q>temp</q> es un sinonimo casi universal de <q>temporal</q>. Pasamos de un breve periodo con el nombre <code>temperature</code>, pero que era demasiado largo y no decia lo que hace el paquete. Al final, se convirtio en <code>tempconv</code>, que es mas corto y paralelo con <code>strconv</code> .</p>
<p>Ahora pasemos a la nomenclatura de los miembros del paquete. Puesto que cada referencia a un miembro de otro paquete utiliza un identificador calificado como <code>fmt.Println</code>, la carga de describir el elemento del paquete es soportado igualmente por el nombre del paquete y el nombre del miembro. No tenemos que mencionar el concepto de formateo en <code>Println</code> debido a que el nombre del paquete <code>fmt</code> ya hace eso. Al diseñar un paquete, considere como funcionan las dos partes de un identificador cualificado, no solo el nombre del miembro. Estos son algunos ejemplos caracteristicos:</p>
<pre class="pre" >bytes.Equal     flag.Int     http.Get     json.Marshal</pre>
<p>Podemos identificar algunos patrones de denominacion comunes. El paquete <code>strings</code> proporciona una serie de funciones para manipular cadenas independientes:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">strings</span>

<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">needle</span><span class="p">,</span> <span class="nx">haystack</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>

<span class="kd">type</span> <span class="nx">Replacer</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">NewReplacer</span><span class="p">(</span><span class="nx">oldnew</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Replacer</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">NewReader</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Reader</span>
</pre></div>
<p>La palabra <code>string</code> no aparece en ninguno de sus nombres. Los clientes se refieren a ellos como <code>strings.Index</code>, <code>strings.Replacer</code>, y asi sucesivamente.</p>
<p>Otros paquetes que podriamos describir como paquetes de un solo tipo, como <code>html/template</code> y <code>math/rand</code>, exponen un tipo de datos principal mas sus metodos, y con frecuencia una nueva funcion para crear instancias.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">rand</span> <span class="c1">// &quot;math/rand&quot;</span>

<span class="kd">type</span> <span class="nx">Rand</span> <span class="kd">struct</span><span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">source</span> <span class="nx">Source</span><span class="p">)</span> <span class="o">*</span><span class="nx">Rand</span>
</pre></div>
<p>Esto puede conducir a la repeticion, como en <code>template.Template</code> o <code>rand.Rand</code>, por lo que los nombres de estos tipos de paquetes suelen ser especialmente cortos.</p>
<p>En el otro extremo, hay paquetes como <code>net/http</code> que tienen una gran cantidad de nombres sin mucha estructura, ya que desempeñan una tarea complicada. A pesar de tener mas de veinte tipos y muchas mas funciones, los miembros mas importantes del paquete tienen los nombres mas simples: <code>Get</code>, <code>Post</code>, <code>Handle</code>, <code>Error</code>, <code>Client</code>, <code>Server</code>.</p>
</div>
<h3 id="Seccion-10.7" >La Herramienta Go</h3>
<div class="hBody-3" >
<p>El resto de este capitulo se refiere a la herramienta <code class="command" >go</code>, que se utiliza para descargar, consultar, formatear, crear, probar e instalar paquetes de codigo Go.</p>
<p>La herramienta <code class="command" >go</code> combina las caracteristicas de un conjunto diverso de herramientas en un conjunto de comandos. Es un gestor de paquetes (analogo a <code class="command" >apt</code> o <code class="command" >rpm</code>) que responde a consultas sobre su inventario de paquetes, calcula sus dependencias y las descarga desde sistemas de control de versiones remotos. Es un sistema de construccion que calcula las dependencias de archivos e invoca compiladores, ensambladores, enlazadores, aunque es intencionalmente menos completo que el <code class="command" >make</code> estandar de Unix. Y es un operador de pruebas, como veremos en el <a href="#Capitulo-11" >Capitulo 11</a>.</p>
<p>Su interfaz de linea de comandos utiliza el estilo <q>navaja suiza</q>, con mas de una docena de subcomandos, algunos de los cuales ya hemos visto, como <code>get</code>, <code>run</code>, <code>build</code> y <code>fmt</code>. Puede ejecutar <code class="command" >go help</code> a ver el indice de la documentacion incorporada, pero como referencia, hemos realizado una lista de los comandos mas utilizados a continuacion:</p>
<div class="highlight"><pre><span></span>$ go
...
    build       compile packages and dependencies
    clean       remove object files
    doc         show documentation <span class="k">for</span> package or symbol
    env         print Go environment information
    fix         run go tool fix on packages
    fmt         run gofmt on package sources
    generate    generate Go files by processing <span class="nb">source</span>
    get         download and install packages and dependencies
    install     compile and install packages and dependencies
    list        list packages
    run         compile and run Go program
    <span class="nb">test</span>        <span class="nb">test</span> packages
    tool        run specified go tool
    version     print Go version
    vet         run go tool vet on packages

Use <span class="s2">&quot;go help [command]&quot;</span> <span class="k">for</span> more information about a command.
...
</pre></div>
<p>Para mantener la necesidad de configuracion al minimo, la herramienta <code class="command" >go</code> se basa en gran medida en las convenciones. Por ejemplo, dado el nombre de un archivo fuente Go, la herramienta puede encontrar su paquete que lo contiene, ya que cada directorio contiene un unico paquete y la ruta de importacion de un paquete corresponde a la jerarquia de directorios en el espacio de trabajo. Dada la ruta de importacion de un paquete, la herramienta puede encontrar el directorio correspondiente en el que almacena los archivos de objeto. Tambien puede encontrar la direccion URL del servidor que aloja el repositorio de codigo fuente.</p>
</div>
<h4 id="Seccion-10.7.1" >Organizacion del Espacio de Trabajo</h4>
<div class="hBody-4" >
<p>La unica configuracion de la mayoria de los usuarios necesitan es la variable de entorno <code>GOPATH</code>, que especifica la raiz del espacio de trabajo. Cuando se cambia a otro espacio de trabajo, los usuarios actualizan el valor de <code>GOPATH</code>. Por ejemplo, mientras trabajamos en este libro establecemos <code>GOPATH</code> a <code>$HOME/gobook</code>:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">export</span> <span class="nv">GOPATH</span><span class="o">=</span><span class="nv">$HOME</span>/gobook
$ go get gopl.io/...
</pre></div>
<p>Despues de descargar todos los programas de este libro utilizando el comando anterior, su espacio de trabajo contendra una jerarquia como esta:</p>
<pre class="pre" >GOPATH/
      src/
          gopl.io/
                  .git/
                  ch1/
                      helloworld/
                                 main.go
                      dup/
                          main.go
                      ...
          golang.org/x/net/
                          .git/
                          html/
                              parse.go
                              node.go
                              ...
      bin/
          helloworld
          dup
      pkg/
          darwin_amd64/
          ...</pre>
<p><code>GOPATH</code> tiene tres subdirectorios. El subdirectorio <span class="file" >src</span> contiene el codigo fuente. Cada paquete reside en un directorio cuyo nombre en relacion con <code>$GOPATH/src</code> es ruta de importacion del paquete, como <code>gopl.io/ch1/helloworld</code>. Observe que un solo espacio de trabajo <code>GOPATH</code> contiene multiples repositorios de control de version debajo <span class="file" >src</span>, como <code>gopl.io</code> o <code>golang.org</code>. El subdirectorio <span class="file" >pkg</span> es donde las h herramientas de construccion almacenan paquetes compilados, y el subdirectorio <span class="file" >bin</span> contiene los programas ejecutables como <code class="command" >helloworld</code>.</p>
<p>Una segunda variable de entorno, <code class="command" >GOROOT</code>, especifica el directorio raiz de la distribucion Go, que ofrece todos los paquetes de la biblioteca estandar. La estructura de directorios debajo de <code>GOROOT</code> asemeja a la de <code>GOPATH</code>, por lo que, por ejemplo, los archivos de origen del paquete <code>fmt</code> residen en el directorio <code>$GOROOT/src/fmt</code>. Los usuarios no necesitan configurar <code>GOROOT</code> ya que, por defecto, la herramienta de <code class="command" >go</code> utilizara la ubicacion donde se instalo.</p>
<p>El comando <code class="command" >go env</code> imprime los valores efectivos de las variables de entorno correspondientes a la cadena de herramientas, incluidos los valores por defecto para los que faltan. <code>GOOS</code> especifica el sistema operativo de destino (por ejemplo, <code>android</code>, <code>linux</code>, <code>darwin</code>, o <code>windows</code>) y <code>GOARCH</code> especifica la arquitectura de procesador objetivo, como <code>amd64</code>, <code>386</code>, o <code>arm</code>. Aunque <code>GOPATH</code> es la unica variable que debe establecer, los demas de vez en cuando aparecen en nuestras explicaciones.</p>
<div class="highlight"><pre><span></span>$ go env
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&quot;/home/gopher/gobook&quot;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&quot;/usr/local/go&quot;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&quot;amd64&quot;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&quot;darwin&quot;</span>
</pre></div>
</div>
<h4 id="Seccion-10.7.2" >Descargando paquetes</h4>
<div class="hBody-4" >
<p>Cuando se utiliza la herramienta <code class="command" >go</code>, ruta de importacion de un paquete indica no solo donde encontrarlo en el espacio de trabajo local, sino donde encontrarlo en Internet para que <code class="command" >go get</code> pueda recuperarlo y actualizarlo.</p>
<p>El comando <code class="command" >go get</code> puede descargar un solo paquete o todo un subarbol o repositorio usando la notacion <code>...</code>, como en la seccion anterior. La herramienta tambien calcula y descarga todas las dependencias de los paquetes iniciales, como el paquete <code>golang.org/x/net/html</code> que aparecio en el espacio de trabajo en el ejemplo anterior.</p>
<p>Una vez que <code class="command" >go get</code> ha descargado los paquetes, los construye y luego instala las librerias y comandos. Veremos los detalles en la siguiente seccion, pero un ejemplo mostrara lo sencillo que es el proceso. El primer comando a continuacion optiene la herramienta <code class="command" >golint</code>, que comprueba si hay problemas de estilo comunes en codigo fuente Go. El segundo comando ejecuta <code class="command" >golint</code> en <code>gopl.io/ch2/popcount</code> de la <a href="#Seccion-2.6.2" >Seccion 2.6.2</a>. Es util que nos informe que hemos olvidado escribir un comentario de documentacion para el paquete:</p>
<div class="highlight"><pre><span></span>$ go get github.com/golang/lint/golint
$ <span class="nv">$GOPATH</span>/bin/golint gopl.io/ch2/popcount
src/gopl.io/ch2/popcount/main.go:1:1:
  package comment should be of the form <span class="s2">&quot;Package popcount ...&quot;</span>
</pre></div>
<p>El comando <code class="command" >go get</code> tiene soporte para los sitios de alojamiento de codigo populares como GitHub, Bitbucket y Launchpad y puede hacer las solicitudes apropiadas en sus sistemas de control de versiones. Para sitios menos conocidos, es posible que deba indicar que protocolo de control de versiones debe utilizar en la ruta de importacion, como Git o Mercurial. Ejecuta <code class="command" >go help importpath</code> para los detalles.</p>
<p>Los directorios que <code class="command" >go get</code> crea son verdaderos clientes del repositorio remoto, no solo copias de los archivos, por lo que puede utilizar los comandos de control de versiones para ver un diff de ediciones locales que ha realizado o para actualizar a una revision diferente. Por ejemplo, el directorio <span class="file" >golang.org/x/net</span> es un cliente de Git:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/golang.org/x/net
$ git remote -v
origin  https://go.googlesource.com/net <span class="o">(</span>fetch<span class="o">)</span>
origin  https://go.googlesource.com/net <span class="o">(</span>push<span class="o">)</span>
</pre></div>
<p>Observe que el nombre de dominio en ruta de importacion del paquete, <code>golang.org</code>, difiere del nombre de dominio real del servidor Git, <code>go.googlesource.com</code>. Esta es una caracteristica de la herramienta Go que permite que lo paquetes usen un nombre de dominio personalizado en su ruta de importacion al ser alojados por un servicio generico como <a href="https://googlesource.com" >https://googlesource.com</a> o <a href="https://github.com" >https://github.com</a>. Paginas HTML debajo de <a href="https://golang.org/x/net/html" >https://golang.org/x/net/html</a> incluyen los metadatos que se muestran a continuacion, que redirecciona la herramienta <code class="command" >go</code> al repositorio Git en el lugar del alojamiento actual:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch1/fetch
$ ./fetch https://golang.org/x/net/html <span class="p">|</span> grep go-import
&lt;meta <span class="nv">name</span><span class="o">=</span><span class="s2">&quot;go-import&quot;</span>
      <span class="nv">content</span><span class="o">=</span><span class="s2">&quot;golang.org/x/net git https://go.googlesource.com/net&quot;</span>&gt;
</pre></div>
<p>Si especifica la bandera <code>-u</code>, <code class="command" >go get</code> se asegurara de que todos los paquetes que visita, incluidas las dependencias, se actualizan a su ultima version antes de ser construido e instalado. Sin ese indicador, los paquetes que ya existen localmente no se actualizaran.</p>
<p>El comando <code class="command" >go get -u</code> recupera generalmente la ultima version de cada paquete, lo cual es conveniente cuando se inicia, pero puede ser inadecuado para proyectos desplegados, donde el control preciso de dependencias es critico para la higiene de la liberacion. La solucion habitual a este problema es el <em>proveedor</em> del codigo, es decir, hacer una copia local persistente de todas las dependencias necesarias, para actualizar esta copia cuidadosa y deliberadamente. Antes de Go 1.5, esto requiere cambiar las rutas de importacion esos paquetes, por lo que nuestra copia de <code>golang.org/x/net/html</code> se convertiria en <code>gopl.io/vendor/golang.org/x/net/html</code>. Las versiones mas recientes de la herramienta soportan directorios de proveedores directamente, aunque no tenemos espacio para mostrar los detalles aqui. Vea <em>Directorios de Proveedores</em> en la salida del comando <code class="command" >go help gopath</code>.</p>
<p><b>Ejercicio 10.3</b>: Utilizando <code class="command" >fetch http://gopl.io/ch1/helloworld?go-get=1</code>, averigüe que servicio alberga los ejemplos de codigo para este libro.  (Las peticiones HTTP de <code class="command" >go get</code> incluyen el parametro <code>go-get</code> para que los servidores pueden distinguirlos de las solicitudes del navegador comun.)</p>
</div>
<h4 id="Seccion-10.7.3" >Construccion de Paquetes</h4>
<div class="hBody-4" >
<p>El comando <code class="command" >go build</code> compila cada argumento de paquete. Si el paquete es una libreria, el resultado se descarta; Esto simplemente comprueba que el paquete esta libre de errores de compilacion. Si el paquete se llama <code>main</code>, <code class="command" >go build</code> invoca el enlazador para crear un archivo ejecutable en el directorio actual; El nombre del ejecutable se toma del ultimo segmento de la ruta de importacion del paquete.</p>
<p>Dado que cada directorio contiene un solo paquete, cada programa ejecutable, o <em>comando</em> en la terminologia Unix, requiere su propio directorio. Estos directorios son a veces los hijos de un directorio denominado <code>cmd</code>, como el comando <code>golang.org/x/tools/cmd/godoc</code> que sirve la documentacion del paquete Go a traves de una interfaz web (<a href="#Seccion-10.7.4" >§10.7.4</a>).</p>
<p>Los paquetes pueden especificarse por sus rutas de importacion, como hemos visto anteriormente, o por un nombre de directorio relativo, que debe comenzar con un <code>.</code> o <code>..</code> aun si ordinariamente no se requere. Si no se proporciona ningun argumento, se supone el directorio actual. Por lo tanto los siguientes comandos construyen el mismo paquete, aunque cada uno escribe el ejecutable en el directorio en el que <code class="command" >go build</code> se ejecuta:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch1/helloworld
$ go build
</pre></div>
<p>y:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> anywhere
$ go build gopl.io/ch1/helloworld
</pre></div>
<p>y:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>
$ go build ./src/gopl.io/ch1/helloworld
</pre></div>
<p>pero no:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>
$ go build src/gopl.io/ch1/helloworld
Error: cannot find package <span class="s2">&quot;src/gopl.io/ch1/helloworld&quot;</span>.
</pre></div>
<p>Los paquetes tambien se pueden especificar como una lista de nombres de archivo, aunque esto tiende a utilizarse solo para programas pequeños y experimentos puntuales. Si el nombre del paquete es <code>main</code>, el nombre del ejecutable viene del nombre base del primer archivo <span class="file" >.go</span>.</p>
<div class="highlight"><pre><span></span>$ cat quoteargs.go
package main

import <span class="o">(</span>
  <span class="s2">&quot;fmt&quot;</span>
  <span class="s2">&quot;os&quot;</span>
<span class="o">)</span>

func main<span class="o">()</span> <span class="o">{</span>
  fmt.Printf<span class="o">(</span><span class="s2">&quot;%q\n&quot;</span>, os.Args<span class="o">[</span><span class="m">1</span>:<span class="o">])</span>
<span class="o">}</span>
$ go build quoteargs.go
$ ./quoteargs one <span class="s2">&quot;two three&quot;</span> four<span class="se">\ </span>five
<span class="o">[</span><span class="s2">&quot;one&quot;</span> <span class="s2">&quot;two three&quot;</span> <span class="s2">&quot;four five&quot;</span><span class="o">]</span>
</pre></div>
<p>Especialmente para programas descartables como este, queremos ejecutar el archivo ejecutable tan pronto como lo hayamos construido. El comando <code class="command" >go run</code> combina estos dos pasos:</p>
<div class="highlight"><pre><span></span>$ go run quoteargs.go one <span class="s2">&quot;two three&quot;</span> four<span class="se">\ </span>five
<span class="o">[</span><span class="s2">&quot;one&quot;</span> <span class="s2">&quot;two three&quot;</span> <span class="s2">&quot;four five&quot;</span><span class="o">]</span>
</pre></div>
<p>El primer argumento que no termina en <span class="file" >.go</span> se asume como el principio de la lista de argumentos para el ejecutable de Go.</p>
<p>Por defecto, el comando <code class="command" >go build</code> construye el paquete solicitado y todas sus dependencias, y luego tira a la basura todo el codigo compilado, excepto el ejecutable final, si lo hubiera. Tanto el analisis de dependencias como la compilacion son sorprendentemente rapidos, pero a medida que los proyectos crecen hasta decenas de paquetes y cientos de miles de lineas de codigo, el tiempo para recompilar las dependencias puede llegar a ser notable, potencialmente varios segundos, incluso cuando no todas las dependencias han cambiado.</p>
<p>El comando <code class="command" >go install</code> es muy similar a <code class="command" >go build</code>, excepto que guarda el codigo compilado para cada paquete y comando en lugar de tirarlo a la basura. Los paquetes compilados se guardan bajo el directorio <span class="file" >$GOPATH/pkg</span> correspondiente al directorio <span class="file" >src</span> en el que reside el codigo fuente y los ejecutables de comando se guardan en el directorio <span class="file" >$GOPATH/bin</span>. (Muchos usuarios agregar <span class="file" >$GOPATH/bin</span> en su ruta de busqueda ejecutable.) A partir de entonces, <code class="command" >go build</code> y <code class="command" >go install</code> no ejecutan el compilador para esos paquetes y comandos si no han cambiado, haciendo las compilaciones posteriores mucho mas rapido. Por cenveniencia, <code class="command" >go build -i</code> instala los paquetes que son dependencias del objetivo a compilar.</p>
<p>Dado que los paquetes compilados varian segun la plataforma y la arquitectura, <code class="command" >go install</code> los guarda debajo de un subdirectorio cuyo nombre incorpora los valores de las variables de entorno <code>GOOS</code> y <code>GOARCH</code>. Por ejemplo, en un Mac el paquete <code>golang.org/x/net/html</code> se compila e instala en el archivo <span class="file" >golang.org/x/net/html.a</span> bajo <span class="file" >$GOPATH/pkg/darwin_amd64</span>.</p>
<p>Es facil aplicar <em>compilacion cruzada</em> a un programa Go, es decir, construir un ejecutable destinado a un sistema operativo diferente o CPU. Solo hay que establecer las variables <code>GOOS</code> o <code>GOARCH</code> durante la construccion. El programa <code class="command" >cross</code> imprime el sistema operativo y la arquitectura para la que fue construido:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch10/cross/main.go" >gopl.io/ch10/cross</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOARCH</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Los comandos siguientes producen ejecutables de 64 bits y 32 bits, respectivamente:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch10/cross
$ ./cross
darwin amd64
$ <span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> go build gopl.io/ch10/cross
$ ./cross
darwin <span class="m">386</span>
</pre></div>
<p>Algunos paquetes pueden necesitar compilar versiones diferentes del codigo para ciertas plataformas o procesadores, para tratar problemas de portabilidad de bajo nivel o para proporcionar versiones optimizadas de rutinas importantes, por ejemplo. Si un nombre de archivo incluye un sistema operativo o arquitectura de procesador, como <span class="file" >net_linux.go</span> o <span class="file" >asm_amd64.s</span>, la herramienta <code class="command" >go</code> compilara el archivo solo cuando se construye para ese objetivo. Comentarios especiales llamadas <em>etiquetas de compilacion</em> ofrecen un control mas detallado. Por ejemplo, si un archivo contiene este comentario:</p>
<div class="highlight"><pre><span></span><span class="c1">// +build linux darwin</span>
</pre></div>
<p>antes de la declaracion del paquete (y su comentario de documentacion), <code class="command" >go build</code> compilara solo cuando se compile para Linux o Mac OS X, y este comentario indica nunca compilar el archivo:</p>
<div class="highlight"><pre><span></span><span class="c1">// +build ignore</span>
</pre></div>
<p>Para mas detalles, consulte la seccion <em>Build Constraints</em> de la documentacion del paquete <code>go/build</code>:</p>
<div class="highlight"><pre><span></span>$ go doc go/build
</pre></div>
</div>
<h4 id="Seccion-10.7.4" >Documentacion de Paquetes</h4>
<div class="hBody-4" >
<p>El estilo Go anima fuertemente la buena documentacion de las API del paquete. Cada declaracion de un miembro del paquete exportado y la propia declaracion del paquete deben ir precedidas inmediatamente de un comentario que explique su proposito y uso.</p>
<p>Los <em>comentarios de documentacion</em> de Go siempre son oraciones completas, y la primera frase es por lo general un resumen que se inicia con el nombre que se declaro. Los parametros de funcion y otros identificadores se mencionan sin citacion o marcado. Por ejemplo, aqui esta el comentario de documentacion para <code>fmt.Fprintf</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Fprintf formateo de acuerdo con un especificador de formato y escriben w.</span>
<span class="c1">// Devuelve el numero de bytes escritos y cualquier error de escritura encontrado.</span>
<span class="kd">func</span> <span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
<p>Los detalles del formateo de <code>Fprintf</code> se explican en un comentario de documentacion asociado al paquete <code>fmt</code> en si. Un comentario que precede inmediatamente a una declaracion <code>package</code> se considera el comentario de documentacion para el paquete en su conjunto. Solo debe haber uno, aunque pueda aparecer en cualquier archivo. Los comentarios de paquetes mas largos pueden justificar un archivo propio; <code>fmt</code> tiene mas de 300 lineas. Este archivo normalmente se llama <span class="file" >doc.go</span> .</p>
<p>Una buena documentacion no necesita ser extensa, y la documentacion no es un sustituto de la sencillez. De hecho, las convenciones de Go favorecen la brevedad y simplicidad en la documentacion como en todas las cosas, ya que la documentacion, como el codigo, tambien requiere mantenimiento. Muchas declaraciones se pueden explicar en una oracion bien redactada, y si el comportamiento es realmente obvio, no necesita comentarse. A lo largo del libro, a medida que el espacio lo permite, hemos precedido a muchas declaraciones por comentarios de documentacion, pero encontraremos mejores ejemplos buscando en la biblioteca estandar. Dos herramientas pueden ayudarte a hacer eso.</p>
<p>La herramienta <code class="command" >go doc</code> imprime la declaracion y el comentario de documentacion de la entidad especificada en la linea de comandos, que puede ser un paquete:</p>
<div class="highlight"><pre><span></span>$ go doc <span class="nb">time</span>
package <span class="nb">time</span> // import <span class="s2">&quot;time&quot;</span>

Package <span class="nb">time</span> provides functionality <span class="k">for</span> measuring and displaying time.

const Nanosecond <span class="nv">Duration</span> <span class="o">=</span> <span class="m">1</span> ...
func After<span class="o">(</span>d Duration<span class="o">)</span> &lt;-chan Time
func Sleep<span class="o">(</span>d Duration<span class="o">)</span>
func Since<span class="o">(</span>t Time<span class="o">)</span> Duration
func Now<span class="o">()</span> Time
<span class="nb">type</span> Duration int64
<span class="nb">type</span> Time struct <span class="o">{</span> ... <span class="o">}</span>
...many more...
</pre></div>
<p>O un miembro del paquete:</p>
<div class="highlight"><pre><span></span>$ go doc time.Since
func Since<span class="o">(</span>t Time<span class="o">)</span> Duration

    Since returns the <span class="nb">time</span> elapsed since t.
    It is shorthand <span class="k">for</span> time.Now<span class="o">()</span>.Sub<span class="o">(</span>t<span class="o">)</span>.
</pre></div>
<p>O un metodo:</p>
<div class="highlight"><pre><span></span>$ go doc time.Duration.Seconds
func <span class="o">(</span>d Duration<span class="o">)</span> Seconds<span class="o">()</span> float64

    Seconds returns the duration as a floating-point number of seconds.
</pre></div>
<p>La herramienta no necesita rutas de importacion completas o casos de identificador exactos. Este comando imprime la documentacion de <code>(*json.Decoder).Decode</code> del paquete <code>encoding/json</code>:</p>
<div class="highlight"><pre><span></span>$ go doc json.decode
func <span class="o">(</span>dec *Decoder<span class="o">)</span> Decode<span class="o">(</span>v interface<span class="o">{})</span> error

    Decode reads the next JSON-encoded value from its input and stores
    it in the value pointed to by v.
</pre></div>
<p>La segunda herramienta, confusamente nombrada <code class="command" >godoc</code>, sirve paginas HTML a entrecruzadas que proporcionan la misma informacion que <code class="command" >go doc</code> y mucho mas. El servidor <code class="command" >godoc</code> en <a href="https://golang.org/pkg" >https://golang.org/pkg</a> cubre la biblioteca estandar. La Figura 10.1 muestra la documentacion del paquete <code>time</code>, y en la <a href="#Seccion-11.6" >Seccion 11.6</a> veremos la pantalla interactiva de <code class="command" >godoc</code> de programas de ejemplo. El servidor <code class="command" >godoc</code> en <a href="https://godoc.org" >https://godoc.org</a> tiene un indice de busqueda de miles de paquetes de codigo abierto.</p>
<p>Tambien puede ejecutar una instancia de <code class="command" >godoc</code> en su espacio de trabajo si desea navegar por sus propios paquetes. Visite <a href="http://localhost:8000/pkg" >http://localhost:8000/pkg</a> en su navegador mientras se ejecuta este comando:</p>
<div class="highlight"><pre><span></span>$ godoc -http :8000
</pre></div>
<p>Sus banderas <code>-analysis=type</code> y <code>-analysis=pointer</code> aumentan la documentacion y el codigo fuente con resultados del analisis estatico avanzado.</p>
</div>
<h4 id="Seccion-10.7.5" >Paquetes Internos</h4>
<div class="hBody-4" >
<p>El paquete es el mecanismo mas importante para la encapsulacion en programas Go. Los identificadores sin exportacion son visibles solo dentro del mismo paquete, y los identificadores exportados son visibles para el mundo.</p>
<p>A veces, sin embargo, camino medio seria util, una forma de definir identificadores que son visibles para un pequeño conjunto de paquetes de confianza, pero no para todos. Por ejemplo, cuando estamos dividiendo un paquete grande en partes mas manejables, es posible que no deseemos revelar las interfaces entre esas partes a otros paquetes. O quizas queramos compartir funciones de utilidad entre varios paquetes de un proyecto sin exponerlos mas ampliamente. O tal vez solo queremos experimentar con un nuevo paquete sin comprometerse prematuramente con su API, poniendolo <q>a prueba</q> con un conjunto limitado de clientes.</p>
<div class="figure" >
<p class="title">Figura 10.1. El paquete <code>time</code> en <code class="command" >godoc</code>.</p>
<figure>
<img src="img/Figure-10.1.jpg" />
</figure>
</div>
<p>Para hacer frente a estas necesidades, la herramienta <code class="command" >go build</code> maneja de un paquete de forma especial si su ruta de importacion contiene un segmento de ruta denominado <code>interno</code>. Dichos paquetes se denominan <em>paquetes internos</em>. Un paquete interno puede ser importadas por otro paquete que esta dentro del arbol raiz en el paquete del directorio <code>internal</code>. Por ejemplo, los paquetes a continuacion, <code>net/http/internal/chunked</code> pueden ser importados de <code>net/http/httputil</code> o <code>net/http</code>, pero no de <code>net/url</code> . Sin embargo, <code>net/url</code> puede importar <code>net/http/httputil</code>.</p>
<pre class="pre" >net/http
net/http/internal/chunked
net/http/httputil
net/url</pre>
</div>
<h4 id="Seccion-10.7.6" >Consultando Paquetes</h4>
<div class="hBody-4" >
<p>La herramienta <code class="command" >go list</code> reporta informacion sobre los paquetes disponibles. En su forma mas simple, <code class="command" >go list</code> comprueba si un paquete esta presente en el espacio de trabajo e imprime su ruta de importacion si es asi:</p>
<div class="highlight"><pre><span></span>$ go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql
</pre></div>
<p>Un argumento para <code class="command" >go list</code> puede contener el comodin <q><code>...</code></q>, que coincide con cualquier subcadena de ruta de importacion de un paquete. Podemos usarlo para enumerar todos los paquetes dentro de un espacio de trabajo Go:</p>
<div class="highlight"><pre><span></span>$ go list ...
archive/tar
archive/zip
bufio
bytes
cmd/addr2line
cmd/api
...many more...
</pre></div>
<p>O dentro de un subarbol especifico:</p>
<div class="highlight"><pre><span></span>$ go list gopl.io/ch3/...
gopl.io/ch3/basename1
gopl.io/ch3/basename2
gopl.io/ch3/comma
gopl.io/ch3/mandelbrot
gopl.io/ch3/netflag
gopl.io/ch3/printints
gopl.io/ch3/surface
</pre></div>
<p>O relacionados con un tema particular:</p>
<div class="highlight"><pre><span></span>$ go list ...xml...
encoding/xml
gopl.io/ch7/xmlselect
</pre></div>
<p>El comando <code class="command" >go list</code> obtiene los metadatos completos de cada paquete, no solo la ruta de importacion, y pone esta informacion a disposicion de los usuarios u otras herramientas en una variedad de formatos. La bandera <code>-json</code> proboca que <code class="command" >go list</code> imprima el registro completo de cada paquete en formato JSON:</p>
<div class="highlight"><pre><span></span>$ go list -json <span class="nb">hash</span>
<span class="o">{</span>
    <span class="s2">&quot;Dir&quot;</span>: <span class="s2">&quot;/home/gopher/go/src/hash&quot;</span>,
    <span class="s2">&quot;ImportPath&quot;</span>: <span class="s2">&quot;hash&quot;</span>,
    <span class="s2">&quot;Name&quot;</span>: <span class="s2">&quot;hash&quot;</span>,
    <span class="s2">&quot;Doc&quot;</span>: <span class="s2">&quot;Package hash provides interfaces for hash functions.&quot;</span>,
    <span class="s2">&quot;Target&quot;</span>: <span class="s2">&quot;/home/gopher/go/pkg/darwin_amd64/hash.a&quot;</span>,
    <span class="s2">&quot;Goroot&quot;</span>: true,
    <span class="s2">&quot;Standard&quot;</span>: true,
    <span class="s2">&quot;Root&quot;</span>: <span class="s2">&quot;/home/gopher/go&quot;</span>,
    <span class="s2">&quot;GoFiles&quot;</span>: <span class="o">[</span>
           <span class="s2">&quot;hash.go&quot;</span>
    <span class="o">]</span>,
    <span class="s2">&quot;Imports&quot;</span>: <span class="o">[</span>
        <span class="s2">&quot;io&quot;</span>
    <span class="o">]</span>,
    <span class="s2">&quot;Deps&quot;</span>: <span class="o">[</span>
        <span class="s2">&quot;errors&quot;</span>,
        <span class="s2">&quot;io&quot;</span>,
        <span class="s2">&quot;runtime&quot;</span>,
        <span class="s2">&quot;sync&quot;</span>,
        <span class="s2">&quot;sync/atomic&quot;</span>,
        <span class="s2">&quot;unsafe&quot;</span>
    <span class="o">]</span>
<span class="o">}</span>
</pre></div>
<p>La bandera <code>-f</code> permite a los usuarios personalizar el formato de salida utilizando el lenguaje de la plantilla del paquete de <code>text/template</code> (<a href="#Seccion-4.6" >§4.6</a>). Este comando imprime las dependencias transitivas del paquete <code>strconv</code>, separados por espacios:</p>
<div class="highlight"><pre><span></span>$ go list -f <span class="s1">&#39;{{join .Deps &quot; &quot;}}&#39;</span> strconv
errors math runtime unicode/utf8 unsafe
</pre></div>
<p>y el comando muestra las importaciones directas de cada paquete en el subarbol <code>compress</code> de la biblioteca estandar:</p>
<div class="highlight"><pre><span></span>$ go list -f <span class="s1">&#39;{{.ImportPath}} -&gt; {{join .Imports &quot; &quot;}}&#39;</span> compress/...
compress/bzip2 -&gt; bufio io sort
compress/flate -&gt; bufio fmt io math sort strconv
compress/gzip -&gt; bufio compress/flate errors fmt <span class="nb">hash</span> hash/crc32 io <span class="nb">time</span>
compress/lzw -&gt; bufio errors fmt io
compress/zlib -&gt; bufio compress/flate errors fmt <span class="nb">hash</span> hash/adler32 io
</pre></div>
<p>El comando <code class="command" >go list</code> es util tanto para consultas interactivas puntuales y para scripts de construccion y automatizacion de pruebas. Lo volveremos a utilizar en la <a href="#Seccion-11.2.4" >Seccion 11.2.4</a>. Para obtener mas informacion, incluyendo el conjunto de campos disponibles y su significado, ver la salida de la <code class="command" >go help list</code>.</p>
<p>En este capitulo, hemos explicado todos los subcomandos importantes de la herramientas <code class="command" >go</code> excepto uno. En el siguiente capitulo, veremos como se utiliza el comando <code class="command" >go test</code> para probar programas Go.</p>
<p><b>Ejercicio 10.4</b>: Construir una herramienta que reporte el conjunto de todos los paquetes en el espacio de trabajo que dependen de forma transitiva de los paquetes especificados por los argumentos. Sugerencia: tendra que ejecutar <code class="command" >go list</code> dos veces, una para los paquetes iniciales y una vez para todos los paquetes. Es posible que desee analizar su salida JSON utilizando el paquete <code>encoding/json</code> (<a href="#Seccion-4.5" >§4.5</a>).</p>
</div>
<h2 id="Capitulo-11" >Pruebas</h2>
<div class="hBody-2" >
<p>Maurice Wilkes, el desarrollador de EDSAC, el primer computador con programa almacenado, tevo una vision sorprendente mientras subia las escaleras de su laboratorio en 1949. En <em>Memoirs of a Computer Pioneer</em>, recordo, <q>La realizacion se me vino con toda la fuerza que una buena Parte del resto de mi vida iba a ser gastada en encontrar errores en mis propios programas.</q> Seguramente cada programador de una computadora con programas almacenados desde entonces puede simpatizar con Wilkes, aunque tal vez no sin algo de desconcierto en su ingenuidad sobre las dificultades de la construccion de software.</p>
<p>Los programas de hoy son mucho mas grandes y complejos que en el tiempo de Wilkes, por supuesto, y se ha dedicado mucho esfuerzo a tecnicas para hacer que esta complejidad sea manejable. Dos tecnicas en particular destacan por su eficacia. La primera es la revision por pares de los programas antes de que se desplieguen. El segundo, el tema de este capitulo, son las pruebas.</p>
<p>Las pruebas, que implican implicitamente pruebas <em>automatizadas</em>, es la practica de escribir pequeños programas que comprobar que el codigo bajo prueba (el codigo de <em>produccion</em>) se comporta como se esperaba para ciertas entradas, que suelen ser cuidadosamente elegidas para ejercer ciertas funciones o al azar para asegurar amplia cobertura.</p>
<p>El campo de las pruebas de software es enorme. La tarea del testeo ocupa a todos los programadores en parte del tiempo y algunos programadores todo el tiempo. La literatura sobre las pruebas incluye miles de libros impresos y millones de palabras publicadas en el blogs. En todos los lenguajes de programacion, hay docenas de paquetes de software destinados a la construccion de pruebas, algunos con una gran cantidad de teoria, y el campo parece atraer a mas de unos pocos profetas con seguimientos de culto. Es casi suficiente para convencer a los programadores de que para escribir pruebas efectivas deben adquirir un nuevo conjunto de habilidades.</p>
<p>La aproximacion de Go a las pruebas puede parecer de baja tecnologia en comparacion. Se basa en un solo comando, <code class="command" >go test</code>, y un conjunto de convenciones para escribir funciones de prueba que <code class="command" >go test</code> puede ejecutar. El mecanismo relativamente ligero es efectivo para pruebas puras, y se extiende naturalmente a puntos de referencia y ejemplos sistematicos para la documentacion.</p>
<p>En la practica, escribir codigo de prueba no es muy diferente de escribir el programa original en si. Escribimos funciones cortas que se centran en una parte de la tarea. Debemos tener cuidado con las condiciones de los limites, pensar en las estructuras de datos y razonar sobre los resultados que un calculo debe producir a partir de entradas adecuadas. Pero este es el mismo proceso que escribir codigo Go ordinario; No requiere nuevas anotaciones, convenciones o herramientas.</p>
</div>
<h3 id="Seccion-11.1" >La Herramienta <code class="command" >go test</code></h3>
<div class="hBody-3" >
<p>El subcomando <code class="command" >go test</code> es un controlador de pruebas para paquetes Go que se organizan de acuerdo con ciertas convenciones. En un directorio de paquetes, los archivos cuyos nombres terminan con <span class="file" >_test.go</span> no son parte del paquete normalmente construido por <code class="command" >go build</code> sino que son una parte de el cuando se construyen mediante <code class="command" >go test</code>.</p>
<p>Dentro de archivos <span class="file" >*_test.go</span>, tres tipos de funciones se tratan de forma especial: pruebas, benchmarks, y ejemplos. Una <em>funcion de prueba</em>, es una funcion cuyo nombre comienza con <code>Test</code>, ejerce cierta logica del programa para el comportamiento correcto; <code class="command" >go test</code> llama a la funcion de prueba e informa del resultado, que es <code>PASS</code> o <code>FAIL</code>. Una funcion de benchmark tiene un nombre que comienza con <code>Benchmark</code> y mide el rendimiento de una operacion; <code class="command" >go test</code> informes el tiempo de ejecucion medio de la operacion. Y una funcion de ejemplo, cuyo nombre empieza por <code>Example</code>, proporciona documentacion revisada por la maquina. Vamos a cubrir las pruebas en detalle en la <a href="#Seccion-11.2" >Seccion 11.2</a>, los benchmarks en la <a href="#Seccion-11.4" >Seccion 11.4</a>, y los ejemplos en la <a href="#Seccion-11.6" >Seccion 11.6</a>.</p>
<p>La heramienta <code class="command" >go test</code> examina los archivos <span class="file" >*_test.go</span> para estas funciones especiales, genera un paquete <code>main</code> temporal que llama a todas de la manera correcta, compila y ejecuta, informa de los resultados, y luego se limpia.</p>
</div>
<h3 id="Seccion-11.2" >Funciones <code>Test</code></h3>
<div class="hBody-3" >
<p>Cada archivo de prueba debe importar el paquete <code>testing</code>. Las funciones de prueba tienen la siguiente firma:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestNormbre</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Los nombres de las funciones de prueba deben comenzar con <code>Test</code>; el sufijo opcional <em>Nombre</em> debe comenzar con una letra mayuscula:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestSin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestCos</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestLog</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
<p>El parametro <code>t</code> proporciona metodos para informar fallos de las pruebas y registrar informacion adicional. Vamos a definir un paquete de ejemplo <code>gopl.io/ch11/word1</code>, que contiene una sola funcion <code>IsPalindrome</code> que informa de si una cadena se lee igual hacia adelante y hacia atras. (Esta implementacion prueba cada byte dos veces si la cadena es un palindromo, volveremos a esto en breve).</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch11/word1/word.go" >gopl.io/ch11/word1</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete word proporciona utilidades para juegos de palabras.</span>
<span class="kn">package</span> <span class="nx">word</span>

<span class="c1">// IsPalindrome informa si s se lee igual hacia adelante y hacia atras.</span>
<span class="c1">// (Nuestro primer intento.)</span>
<span class="kd">func</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En el mismo directorio, el archive <span class="file" >word_test.go</span> contiene dos funciones de prueba con nombre <code>TestPalindrome</code> y <code>TestNonPalindrome</code>. Cada uno comprueba que <code>IsPalindrome</code> da la respuesta correcta para una entrada unica e informa fallos utilizando <code>t.Error</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">word</span>

<span class="kn">import</span> <span class="s">&quot;testing&quot;</span>

<span class="kd">func</span> <span class="nx">TestPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;detartrated&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&quot;detartrated&quot;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;kayak&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&quot;kayak&quot;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestNonPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;palindrome&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&quot;palindrome&quot;) = true`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Una comando <code class="command" >go test</code> (o <code class="command" >go build</code>) sin argumentos de paquete opera sobre el paquete en el directorio actual. Podemos construir y ejecutar las pruebas con el siguiente comando.</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch11/word1
$ go <span class="nb">test</span>
ok   gopl.io/ch11/word1 <span class="m">0</span>.008s
</pre></div>
<p>Satisfecho, enviamos el programa, pero no antes de que los invitados de la fiesta envien los informes de error iniciales. Un usuario frances llamado Noelle Eva Elleon se queja de que IsPalindrome no reconoce <q>été</q>. Otro, de Centroamerica, se siente decepcionado al rechazar <q>A man, a plan, a canal: Panama</q>. Estos informes de errores especificos y pequeños naturalmente se prestan a nuevos casos de prueba.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestFrenchPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;été&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">`IsPalindrome(&quot;été&quot;) = false`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">TestCanalPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">input</span> <span class="o">:=</span> <span class="s">&quot;A man, a plan, a canal: Panama&quot;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">`IsPalindrome(%q) = false`</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Para evitar la langa cadena de entrada dos veces, utilizamos <code>Errorf</code>, que proporciona formato, como <code>Printf</code>.</p>
<p>Cuando se han añadido las dos nuevas pruebas, el comando <code class="command" >go test</code> falla con mensajes informativos de error.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span>
--- FAIL: TestFrenchPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
    word_test.go:28: IsPalindrome<span class="o">(</span><span class="s2">&quot;été&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
--- FAIL: TestCanalPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
    word_test.go:35: IsPalindrome<span class="o">(</span><span class="s2">&quot;A man, a plan, a canal: Panama&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
FAIL
FAIL    gopl.io/ch11/word1 <span class="m">0</span>.014s
</pre></div>
<p>Es recomendable escribir la prueba primero y observar que desencadena el mismo fallo descrito por el informe de error del usuario. Solo entonces podremos estar seguros de que cualquier solucion que hagamos concierne al problema correcto.</p>
<p>Como beneficio adicional, ejecutar <code class="command" >go test</code> generalmente es mas rapido que manualmente por los pasos descritos en el informe de errores, lo que nos permite iterar mas rapidamente. Si la suite de pruebas contiene muchas pruebas lentas, podemos hacer un progreso aun mas rapido si somos selectivos sobre cuales corremos.</p>
<p>La bandera <code>-v</code> imprime el nombre y el tiempo de ejecucion de cada prueba en el paquete:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -v
<span class="o">===</span> RUN TestPalindrome
--- PASS: TestPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
<span class="o">===</span> RUN TestNonPalindrome
--- PASS: TestNonPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
<span class="o">===</span> RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
word_test.go:28: IsPalindrome<span class="o">(</span><span class="s2">&quot;ete&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
<span class="o">===</span> RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
word_test.go:35: IsPalindrome<span class="o">(</span><span class="s2">&quot;A man, a plan, a canal: Panama&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
FAIL
<span class="nb">exit</span> status <span class="m">1</span>
FAIL    gopl.io/ch11/word1 <span class="m">0</span>.017s
</pre></div>
<p>y la bandera <code>-run</code>, cuyo argumento es una expresion regular, hace que <code class="command" >go test</code> ejecute solo aquellas pruebas cuyo nombre de funcion coincide con el patron:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -v -run<span class="o">=</span><span class="s2">&quot;French|Canal&quot;</span>
<span class="o">===</span> RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
word_test.go:28: IsPalindrome<span class="o">(</span><span class="s2">&quot;ete&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
<span class="o">===</span> RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
word_test.go:35: IsPalindrome<span class="o">(</span><span class="s2">&quot;A man, a plan, a canal: Panama&quot;</span><span class="o">)</span> <span class="o">=</span> <span class="nb">false</span>
FAIL
<span class="nb">exit</span> status <span class="m">1</span>
FAIL    gopl.io/ch11/word1 <span class="m">0</span>.014s
</pre></div>
<p>Por supuesto, una vez que hemos conseguido que las pruebas seleccionadas pasen, debemos invocar a <code class="command" >go test</code> sin banderas para ejecutar el conjunto de pruebas entero una ultima vez antes de que confirme el cambio.</p>
<p>Ahora nuestra tarea es arreglar los errores. Una rapida investigacion revela la causa del primer fallo en <code>IsPalindrome</code> esta en utilizar secuencias de bytes, no secuencias de runas, por lo que los caracteres no ASCII, como la <code>é</code> en <code>&quot;été&quot;</code> lo confunden. El segundo error surge de no ignorar entre mayusculas y minusculas, los espacios y signos de puntuacion.</p>
<p>reescribimos la funcion con mas cuidado:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch11/word2/word.go" >gopl.io/ch11/word2</a></p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete word proporciona utilidades para juegos de palabras.</span>
<span class="kn">package</span> <span class="nx">word</span>

<span class="kn">import</span> <span class="s">&quot;unicode&quot;</span>

<span class="c1">// IsPalindrome informa si s se lee igual hacia adelante y hacia atras.</span>
<span class="c1">// Se ignora entre mayusculas y minusculas, al igual que las no-letras.</span>
<span class="kd">func</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">letters</span> <span class="p">[]</span><span class="kt">rune</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">letters</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">letters</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">letters</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">letters</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">letters</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tambien escribimos un conjunto mas completo de casos de prueba que combina todas las anteriores y una nueva serie en una tabla.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestIsPalindrome</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="kt">string</span>
    <span class="nx">want</span>  <span class="kt">bool</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;ab&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;kayak&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;detartrated&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;A man, a plan, a canal: Panama&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;Evil I did dwell; lewd did I live.&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;Able was I ere I saw Elba&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;ete&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;Et se resservir, ivresse reste.&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;palindrome&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span> <span class="c1">// no-palindromo</span>
    <span class="p">{</span><span class="s">&quot;desserts&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">},</span>   <span class="c1">// semi-palindromo</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">:=</span> <span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;IsPalindrome(%q) = %v&quot;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">got</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Nuestras nuevas pruebas pasan:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> gopl.io/ch11/word2
ok      gopl.io/ch11/word2        <span class="m">0</span>.015s
</pre></div>
<p>Este estilo de la prueba <em>basado en tablas</em> es muy comun en Go. Es facil agregar nuevas entradas de tabla segun sea necesario, y como la logica de asercion no se duplica, podemos invertir mas esfuerzo en producir un buen mensaje de error.</p>
<p>La salida de una prueba erronea <em>no</em> incluye la traza de la pila entera en el momento de la llamada a <code>t.Errorf</code>. <code>t.Errorf</code> tampoco provoca un panico o detiene la ejecucion de la prueba, a diferencia de muchos errores de asercion en frameworks de prueba para otros lenguajes. Las pruebas son independientes entre si. Si una entrada temprana en la tabla hace que la prueba falle, las entradas de tabla posteriores se aun se comprobaran, y asi podemos aprender sobre multiples fallas durante una sola ejecucion.</p>
<p>Cuando realmente debemos detener una funcion de prueba, tal vez porque a algun codigo de inicializacion fallo o para prevenir un fallo ya reportado que proboque una cascada confusa de otros, utilizamos <code>t.Fatal</code> o <code>t.Fatalf</code>. Estos deben ser llamados desde la misma gorutina como la funcion <code>Test</code>, no de la otra creada durante la prueba.</p>
<p>Los mensajes de fallo generalmente de la forma <code>&quot;f(x) = y, want z&quot;</code>, donde <code>f(x)</code> explica el funcionamiento intentado y su entrada, <code>y</code> es el resultado real, y <code>z</code> el resultado esperado. Cuando es conveniente, como en nuestro ejemplo palindromo, se utiliza la sintaxis actual para la parte <code>f(x)</code>. La visualizacion de <code>x</code> es particularmente importante en una prueba basada en tablas, ya que una afirmacion dada se ejecuta muchas veces con diferentes valores. Evite la informacion repetitiva y redundante. Cuando se prueba una funcion booleana como <code>IsPalindrome</code>, omita la parte <code>z</code> puesto que no agrega ninguna informacion. Si <code>x</code>, <code>y</code> o <code>z</code> es largo, en su lugar imprima un resumen relevante de las partes. El autor de una prueba debe esforzarse por ayudar al programador que debe diagnosticar un fallo de la prueba.</p>
<p><b>Ejercicio 11.1</b>: escribir pruebas para el programa <code class="command" >charcount</code> en la <a href="#Seccion-4.3" >Seccion 4.3</a>.</p>
<p><b>Ejercicio 11.2</b>: Escribir una serie de pruebas para <code>IntSet</code> (<a href="#Seccion-6.5" >§6.5</a>) que comprueba que su comportamiento despues de cada operacion es equivalente a un conjunto basado en mapas incorporados. Guarde su implementacion para el benchmarking del Ejercicio 11.7.</p>
</div>
<h4 id="Seccion-11.2.1" >Pruebas Aleatorias</h4>
<div class="hBody-4" >
<p>Las pruebas basadas en tablas son convenientes para comprobar que una funcion funciona en entradas cuidadosamente seleccionadas para ejercer casos interesantes en la logica. Otro enfoque, <em>pruebas al azar</em>, explora una gama mas amplia de entradas mediante la construccion de entradas al azar.</p>
<p>¿Como sabemos que resultado esperar de nuestra funcion, dada una entrada aleatoria? Hay dos estrategias. La primera es escribir una implementacion alternativa de la funcion que utiliza un algoritmo menos eficiente pero mas sencillo y claro, y comprobar que ambas implementaciones dan el mismo resultado. La segunda es crear valores de entrada de acuerdo con un patron para que sepamos que salida esperamos.</p>
<p>El ejemplo siguiente utiliza el segundo enfoque: la funcion <code>randomPalindrome</code> genera palabras que se sabe que son palindromos por construccion.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;math/rand&quot;</span>

<span class="c1">// randomPalindrome devuelve un palindromo cuya longitud y contenido</span>
<span class="c1">// se derivan del generador de numeros pseudo aleatorios rng.</span>
<span class="kd">func</span> <span class="nx">randomPalindrome</span><span class="p">(</span><span class="nx">rng</span> <span class="o">*</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Rand</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="c1">// random length up to 24</span>
  <span class="nx">runes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">rng</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">))</span> <span class="c1">// random rune up to &#39;\u0999&#39;</span>
    <span class="nx">runes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
    <span class="nx">runes</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">runes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestRandomPalindromes</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Initialize a pseudo-random number generator.</span>
  <span class="nx">seed</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">UTC</span><span class="p">().</span><span class="nx">UnixNano</span><span class="p">()</span>
  <span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&quot;Random seed: %d&quot;</span><span class="p">,</span> <span class="nx">seed</span><span class="p">)</span>
  <span class="nx">rng</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="nx">seed</span><span class="p">))</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">randomPalindrome</span><span class="p">(</span><span class="nx">rng</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;IsPalindrome(%q) = false&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Dado que las pruebas aleatorizadas son no deterministas, es fundamental que el registro de la prueba de fallo registre informacion suficiente para reproducir el fallo. En nuestro ejemplo, la entrada <code>p</code> para <code>IsPalindrome</code> nos dice todo lo que necesitamos saber, pero para las funciones que aceptan entradas mas complejas, puede ser mas sencillo registrar la semilla del generador de numeros pseudo-aleatorios (como lo hacemos mas arriba) que volcar toda la estructura de datos de entrada. Armado con ese valor de semilla, podemos modificar facilmente la prueba para reproducir el fracaso de forma determinista.</p>
<p>Utilizando la hora actual como una fuente de aleatoriedad, la prueba explorara nuevas entradas cada vez que se ejecute, durante todo el curso de su vida util. Esto es especialmente valioso si su proyecto utiliza un sistema automatizado para ejecutar todas sus pruebas periodicamente.</p>
<p><b>Ejercicio 11.3</b>: <code>TestRandomPalindromes</code> solo prueba palindromos. Escriba una prueba aleatoria que genere y verifique no-palindromos.</p>
<p><b>Ejercicio 11.4</b>: Modificar <code>randomPalindrome</code> para probar el manejo de puntuacion y espacios de <code>IsPalindrome</code>.</p>
</div>
<h4 id="Seccion-11.2.2" >Probar un Comando</h4>
<div class="hBody-4" >
<p>La heramienta <code class="command" >go test</code> es util para probar paquetes de librerias, pero con un poco de esfuerzo lo podemos usar para probar tambien los comandos. Un paquete llamado <code>main</code> normalmente produce un programa ejecutable, pero tambien puede ser importado como una libreria.</p>
<p>Vamos a escribir una prueba para el programa <code class="command" >echo</code> de la <a href="#Seccion-2.3.2" >Seccion 2.3.2</a>. Hemos dividido el programa en dos funciones: <code>echo</code> hace el trabajo real, mientras que <code>main</code> analiza y lee los valores bandera y los errores devueltos por <code>echo</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch11/echo/echo.go" >gopl.io/ch11/echo</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Echo imprime sus argumentos de linea de comandos.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;flag&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;os&quot;</span>
  <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
  <span class="nx">n</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Bool</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;omit trailing newline&quot;</span><span class="p">)</span>
  <span class="nx">s</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="s">&quot;separator&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span> <span class="c1">// modificado durante las pruebas</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">(!</span><span class="o">*</span><span class="nx">n</span><span class="p">,</span> <span class="o">*</span><span class="nx">s</span><span class="p">,</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Args</span><span class="p">());</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;echo: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">newline</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">sep</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">newline</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A partir de la prueba, llamaremos a <code class="command" >echo</code> con una variedad de argumentos y configuraones de parametros bandera y comprobaremos que imprime la salida correcta en cada caso, por lo que hemos añadido parametros a <code class="command" >echo</code> para reducir su dependencia de las variables globales. Dicho esto, tambien hemos introducido otra variable global, <code>out</code>, un <code>io.Writer</code> al que se escribira el resultado. Al tener <code>echo</code> escritura a traves de esta variable, no directamente a <code>os.Stdout</code>, las pruebas pueden sustituir una implementacion <code>Writer</code> diferente que registra lo que se escrito para una inspeccion posterior. Aqui esta la prueba, en archivo <code>echo_test.go</code>:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;bytes&quot;</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestEcho</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">newline</span> <span class="kt">bool</span>
    <span class="nx">sep</span>     <span class="kt">string</span>
    <span class="nx">args</span>    <span class="p">[]</span><span class="kt">string</span>
    <span class="nx">want</span>    <span class="kt">string</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">&quot;\n&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{},</span> <span class="s">&quot;&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&quot;\t&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">},</span> <span class="s">&quot;one\ttwo\tthree\n&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">},</span> <span class="s">&quot;a,b,c\n&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">},</span> <span class="s">&quot;1:2:3&quot;</span><span class="p">},</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="nx">descr</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;echo(%v, %q, %q)&quot;</span><span class="p">,</span>
      <span class="nx">test</span><span class="p">.</span><span class="nx">newline</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">sep</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span>

    <span class="nx">out</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="c1">// captura la salida</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">newline</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">sep</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s failed: %v&quot;</span><span class="p">,</span> <span class="nx">descr</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">out</span><span class="p">.(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s = %q, want %q&quot;</span><span class="p">,</span> <span class="nx">descr</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Observe que el codigo de prueba esta en el mismo paquete que el codigo de produccion. Aunque el nombre del paquete es <code>main</code> y define una funcion <code>main</code>, durante la prueba, este paquete actua como una libreria que expone la funcion <code>TestEcho</code> al controlador de pruebas; su funcion <code>main</code> es ignorada.</p>
<p>Al organizar la prueba como una tabla, podemos agregar facilmente nuevos casos de prueba. Veamos que sucede cuando la prueba falla, agregando esta linea a la tabla:</p>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">},</span> <span class="s">&quot;a b c\n&quot;</span><span class="p">},</span> <span class="c1">// NOTA: expectativa equivocada!</span>
</pre></div>
<p><code class="command" >go test</code> imprime</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> gopl.io/ch11/echo
--- FAIL: TestEcho <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
    echo_test.go:31: echo<span class="o">(</span>true, <span class="s2">&quot;,&quot;</span>, <span class="o">[</span><span class="s2">&quot;a&quot;</span> <span class="s2">&quot;b&quot;</span> <span class="s2">&quot;c&quot;</span><span class="o">])</span> <span class="o">=</span> <span class="s2">&quot;a,b,c&quot;</span>, want <span class="s2">&quot;a b c\n&quot;</span>
FAIL
FAIL    gopl.io/ch11/echo   <span class="m">0</span>.006s
</pre></div>
<p>El mensaje de error describe el intento de operacion (utilizando la sintaxis similar a Go), el comportamiento real y el comportamiento esperado, en ese orden. Con un mensaje de error informativo como este, es posible que tenga una idea bastante buena sobre la causa raiz antes incluso de haber localizado el codigo fuente de la prueba.</p>
<p>Es importante que el codigo esta probando no llame a <code>log.Fatal</code> o <code>os.Exit</code>, ya que estas detendran el proceso en seco; llamar a estas funciones debe ser considerado como derecho exclusivo de <code>main</code>. Si algo totalmente inesperado ocurre y una funcion entra en panico, el controlador de prueba se recuperara, aunque la prueba, por supuesto, se considerara un fallo. Errores previsibles, como los que resultan de mala entrada del usuario, archivos que faltan, o una configuracion inadecuada deben ser reportados mediante la devolucion de un valor <code>error</code> no-nil. Afortunadamente (aunque desafortunado como una ilustracion), nuestro ejemplo <code class="command" >echo</code> es tan simple que nunca volvera un error no-nil.</p>
</div>
<h4 id="Seccion-11.2.3" >Prueba de Caja Blanca</h4>
<div class="hBody-4" >
<p>Una forma de clasificar las pruebas es por el nivel de conocimiento que requieren del funcionamiento interno del paquete bajo prueba. Una prueba de <em>caja negla</em> no asume nada distinto sobre el paquete de lo expuesto por su API y especificado por su documentacion; Los internos del paquete son opacos. En contraste, una prueba de <em>caja blanca</em> tiene un acceso privilegiado a las funciones internas y estructuras de datos del paquete y puede hacer observaciones y cambios que un cliente comun no puede. Por ejemplo, una prueba de cuadro blanco puede comprobar que las invariantes de los tipos de datos del paquete se mantienen despues de cada operacion. (Er nombre <em>caja blanca</em> es tradicional, pero seria mas exacto <em>caja transparente</em>).</p>
<p>Los dos enfoques son complementarios. Las pruebas de caja negra suelen ser mas robustas, requiriendo menos actualizaciones a medida que el software evoluciona. Tambien ayudan al autor de la prueba a empatizar con el cliente del paquete y pueden revelar defectos en el diseño del API. Por el contrario, las pruebas de caja blanca pueden proporcionar una cobertura mas detallada de las partes mas dificiles de la implementacion.</p>
<p>Ya hemos visto ejemplos de ambos tipos. <code>TestIsPalindrome</code> llama solo a la funcion exportada <code>IsPalindrome</code> y es por lo tanto una prueba de caja negra. <code>TestEcho</code> llama a la funcion <code>echo</code> y actualiza la variable global <code>out</code>, los cuales se dejadan sin exportar, por lo que es una prueba de caja blanca.</p>
<p>Durante el desarrollo de <code>TestEcho</code>, modificamos la funcion <code>echo</code> para utilizar la variable de nivel de paquete <code>out</code> cuando se escribe su salida, por lo que la prueba podria sustituir a la salida estandar con una implementacion alternativa que registra los datos para una inspeccion posterior. Utilizando la misma tecnica, podemos reemplazar otras partes del codigo de produccion con implementaciones <q>falsas</q> faciles de probar. La ventaja de las implementaciones falsas es que pueden ser mas sencillas de configurar, mas predecibles, mas fiables y mas faciles de observar. Tambien pueden evitar efectos secundarios indeseables, como actualizar una base de datos de produccion o cargar una tarjeta de credito.</p>
<p>El siguiente codigo muestra la logica de comprobacion de cuotas en un servicio web que proporciona almacenamiento en red a los usuarios. Cuando los usuarios superan el 90% de su cuota, el sistema les envia un correo electronico de advertencia.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch11/storage1/storage.go" >gopl.io/ch11/storage1</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">storage</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;net/smtp&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">usage</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int64</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">usage</span><span class="p">[</span><span class="nx">username</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// configuracion del remitente del email.</span>
<span class="c1">// NOTA: nunca ponga contraseñas en el codigo fuente!</span>
<span class="kd">const</span> <span class="nx">sender</span> <span class="p">=</span> <span class="s">&quot;notifications@example.com&quot;</span>
<span class="kd">const</span> <span class="nx">password</span> <span class="p">=</span> <span class="s">&quot;correcthorsebatterystaple&quot;</span>
<span class="kd">const</span> <span class="nx">hostname</span> <span class="p">=</span> <span class="s">&quot;smtp.example.com&quot;</span>

<span class="kd">const</span> <span class="nx">template</span> <span class="p">=</span> <span class="s">`Warning: you are using %d bytes of storage,</span>
<span class="s">%d%% of your quota.`</span>

<span class="kd">func</span> <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">used</span> <span class="o">:=</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">quota</span> <span class="p">=</span> <span class="mi">1000000000</span> <span class="c1">// 1GB</span>
  <span class="nx">percent</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">used</span> <span class="o">/</span> <span class="nx">quota</span>
  <span class="k">if</span> <span class="nx">percent</span> <span class="p">&lt;</span> <span class="mi">90</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// OK</span>
  <span class="p">}</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nx">used</span><span class="p">,</span> <span class="nx">percent</span><span class="p">)</span>
  <span class="nx">auth</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">PlainAuth</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">)</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">SendMail</span><span class="p">(</span><span class="nx">hostname</span><span class="o">+</span><span class="s">&quot;:587&quot;</span><span class="p">,</span> <span class="nx">auth</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">username</span><span class="p">},</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">msg</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;smtp.SendMail(%s) failed: %s&quot;</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nos gustaria probarlo, pero no queremos que la prueba envie correo electronico real. Por lo tanto, movemos la logica de correo electronico a su propia funcion y almacenamos esa funcion en una variable de nivel de paquete sin exportar, <code>notifyUser</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch11/storage2/storage.go" >gopl.io/ch11/storage2</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">auth</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">PlainAuth</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">)</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">smtp</span><span class="p">.</span><span class="nx">SendMail</span><span class="p">(</span><span class="nx">hostname</span><span class="o">+</span><span class="s">&quot;:587&quot;</span><span class="p">,</span> <span class="nx">auth</span><span class="p">,</span> <span class="nx">sender</span><span class="p">,</span>
    <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">username</span><span class="p">},</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">msg</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;smtp.SendMail(%s) failed: %s&quot;</span><span class="p">,</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">username</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">used</span> <span class="o">:=</span> <span class="nx">bytesInUse</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">quota</span> <span class="p">=</span> <span class="mi">1000000000</span> <span class="c1">// 1GB</span>
  <span class="nx">percent</span> <span class="o">:=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">used</span> <span class="o">/</span> <span class="nx">quota</span>
  <span class="k">if</span> <span class="nx">percent</span> <span class="p">&lt;</span> <span class="mi">90</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// OK</span>
  <span class="p">}</span>
  <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">template</span><span class="p">,</span> <span class="nx">used</span><span class="p">,</span> <span class="nx">percent</span><span class="p">)</span>
  <span class="nx">notifyUser</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora podemos escribir una prueba que sustituye un simple mecanismo de notificacion falsa en lugar de enviar correo electronico real. Este registra el usuario notificado y el contenido del mensaje.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">storage</span>
<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;strings&quot;</span>
  <span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestCheckQuotaNotifiesUser</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="kt">string</span>
  <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="p">=</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span>
  <span class="p">}</span>

  <span class="c1">// ...simular una condicion que utiliza 980MB...</span>

  <span class="kd">const</span> <span class="nx">user</span> <span class="p">=</span> <span class="s">&quot;joe@example.org&quot;</span>
  <span class="nx">CheckQuota</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">notifiedUser</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="o">&amp;&amp;</span> <span class="nx">notifiedMsg</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;notifyUser not called&quot;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">notifiedUser</span> <span class="o">!=</span> <span class="nx">user</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;wrong user (%s) notified, want %s&quot;</span><span class="p">,</span>
      <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">wantSubstring</span> <span class="p">=</span> <span class="s">&quot;98% of your quota&quot;</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">notifiedMsg</span><span class="p">,</span> <span class="nx">wantSubstring</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, &quot;</span><span class="o">+</span>
      <span class="s">&quot;want substring %q&quot;</span><span class="p">,</span> <span class="nx">notifiedMsg</span><span class="p">,</span> <span class="nx">wantSubstring</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Hay un problema: despues de que esta funcion de prueba ha regresado, <code>CheckQuota</code> ya no funciona como deberia, ya que todavia esta usando la prueba de falsa implementacion de <code>notifyUsers</code>. Debemos modificar la prueba para restaurar el valor anterior para que las pruebas posteriores no observen ningun efecto, y debemos hacerlo en todas las rutas de ejecucion, incluyendo fallas de prueba y panicos. Naturalmente, esto sugiere un <code>defer</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestCheckQuotaNotifiesUser</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Guardar y restaurar notifiUser original</span>
  <span class="nx">saved</span> <span class="o">:=</span> <span class="nx">notifyUser</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">notifyUser</span> <span class="p">=</span> <span class="nx">saved</span> <span class="p">}()</span>

  <span class="c1">// Instala la prueba falsa notifyUser.</span>
  <span class="kd">var</span> <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="kt">string</span>
  <span class="nx">notifyUser</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">notifiedUser</span><span class="p">,</span> <span class="nx">notifiedMsg</span> <span class="p">=</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">msg</span>
  <span class="p">}</span>
  <span class="c1">// ...resto de la prueba...</span>
<span class="p">}</span>
</pre></div>
<p>Este patron se puede utilizar para guardar y restaurar temporalmente todo tipo de variables globales, incluidas banderas de linea de comandos, opciones de depuracion y parametros de rendimiento; para instalar y eliminar los ganchos que hacen que el codigo de produccion llame al codigo de prueba cuando sucede algo interesante; y para codificar el codigo de produccion en estados raros pero importantes, como tiempos muertos, errores e incluso intercalaciones especificas de actividades concurrentes.</p>
<p>El uso de variables globales de esta manera es seguro solo porque <code class="command" >go test</code> normalmente no ejecuta pruebas multiples de forma concurrente.</p>
</div>
<h4 id="Seccion-11.2.4" >Paquetes de Pruebas Externos</h4>
<div class="hBody-4" >
<p>Considere los paquetes de <code>net/url</code>, que proporciona un analizador de URL, y <code>net/http</code>, que proporciona un servidor web y una libreria de cliente HTTP. Como es de esperar, el nivel superior de <code>net/http</code> depende del nivel inferior <code>net/url</code>. Sin embargo, una de las pruebas en <code>net/url</code> es un ejemplo que demuestra la interaccion entre las URL y la libreria cliente HTTP. En otras palabras, una prueba al paquete de nivel inferior importa el paquete de nivel superior.</p>
<div class="figure" >
<p class="title">Figura 11.1. Una prueba de <code>net/url</code> depende de <code>net/http</code>.</p>
<figure>
<img src="img/Figure-11.1.jpg" />
</figure>
</div>
<p>Declarar esta funcion de prueba en el paquete <code>net/url</code> crearia un ciclo en el grafico de importacion paquetes, tal como se representa por las flecha hacia arriba en la Figura 11.1, pero como se explico en la <a href="#Seccion-10.1" >Seccion 10.1</a>, la especificacion Go prohibe los ciclos de importacion.</p>
<p>Resolvemos el problema declarando la funcion de prueba en un <em>paquete de prueba externo</em>, es decir, en un archivo en el directorio <code>net/url</code> cuya declaracion del paquete lee el paquete <code>url_test</code>. El sufijo adicional <code>_test</code> es una señal para <code class="command" >go test</code> que debe construir un paquete adicional que contiene solo estos archivos y ejecutar sus pruebas. Puede ser util pensar en este paquete de prueba externo como si tuviera la ruta de importacion <code>net/url_test</code>, pero no se pueden importar con este nombre ni con ningun otro.</p>
<p>Debido a que las pruebas externas viven en un paquete separado, pueden importar paquetes auxiliares que tambien dependen del paquete que se esta probando; Una prueba en el paquete no puede hacer esto. En terminos de las capas de diseño, el paquete de pruebas externo es logicamente mas alto que los dos paquetes de los que depende, como se muestra en la Figura 11.2.</p>
<div class="figure" >
<p class="title">Figura 11.2. Los paquetes de prueba externos rompen los ciclos de dependencia.</p>
<figure>
<img src="img/Figure-11.2.jpg" />
</figure>
</div>
<p>Al evitar ciclos de importacion, los paquetes de prueba externos permiter que las pruebas, especialmente las <em>pruebas de integracion</em> (que ponen a prueba la interaccion de varios componentes), importen otros paquetes libremente, exactamente como haria una aplicacion.</p>
<p>Podemos utilizar la herramienta <code class="command" >go list</code> para resumir que archivos fuente en un directorio Go son el codigo de produccion, pruebas en el paquete, y pruebas externas. Usaremos el paquete <code>fmt</code> como ejemplo. GoFiles es la lista de los archivos que contienen el codigo de produccion; estos son los archivos que <code class="command" >go build</code> incluira en su aplicacion:</p>
<div class="highlight"><pre><span></span>$ go list -f<span class="o">={{</span>.GoFiles<span class="o">}}</span> fmt
<span class="o">[</span>doc.go format.go print.go scan.go<span class="o">]</span>
</pre></div>
<p><code>TestGoFiles</code> es la lista de archivos que tambien pertenecen al paquete <code>fmt</code>, pero estos archivos, cuyos nombres terminan en <span class="file" >_test.go</span>, se incluye solo en la construccion de las pruebas:</p>
<div class="highlight"><pre><span></span>$ go list -f<span class="o">={{</span>.TestGoFiles<span class="o">}}</span> fmt
<span class="o">[</span>export_test.go<span class="o">]</span>
</pre></div>
<p>Las pruebas del paquete por lo general residen en estos archivos, aunque inusualmente <code>fmt</code> no tiene ninguno; vamos a explicar el proposito de <code>export_test.go</code> en un momento.</p>
<p><code>XTestGoFiles</code> es la lista de los archivos que constituyen el paquete de prueba externo, <code>fmt_test</code>, por lo que estos archivos debe importar el paquete <code>fmt</code> con el fin de usarlo. Una vez mas, se incluyen solo durante las pruebas:</p>
<div class="highlight"><pre><span></span>$ go list -f<span class="o">={{</span>.XTestGoFiles<span class="o">}}</span> fmt
<span class="o">[</span>fmt_test.go scan_test.go stringer_test.go<span class="o">]</span>
</pre></div>
<p>A veces un paquete de prueba externo puede necesitar acceso privilegiado a los internos del paquete bajo prueba, si por ejemplo una prueba de caja blanca debe vivir en un paquete separado para evitar un ciclo de importacion. En estos casos, se utiliza un truco: agregamos declaraciones a un archivo <span class="file" >_test.go</span> del paquete para exponer los componentes internos necesarios para la prueba externa. Este archivo ofrece asi una <q>puerta trasera</q> para la prueba del paquete. Si el archivo origen existe solo para este proposito y no contiene pruebas en si mismo, se le nombra a menudo <span class="file" >export_test.go</span>.</p>
<p>Por ejemplo, la implementacion del paquete <code>fmt</code> necesita la funcionalidad de <code>unicode.IsSpace</code> como parte de <code>fmt.Scanf</code>. Para evitar la creacion de una dependencia indeseable, <code>fmt</code> no importa el paquete <code>unicode</code> y sus grandes tablas de datos; en cambio, contiene una implementacion mas sencilla, a la que llama <code>isSpace</code>.</p>
<p>Para asegurar que los comportamientos de <code>fmt.isSpace</code> y <code>unicode.IsSpace</code> no se separan, <code>fmt</code> prudentemente contiene una prueba. Se trata de una prueba externa, y por lo tanto no puede acceder a <code>isSpace</code> directamente, por lo que <code>fmt</code> abre una puerta trasera declarando una variable exportada que contiene la funcion interna <code>isSpace</code>. Esta es la totalidad del archivo <span class="file" >export_test.go</span> del paquete <code>fmt</code>.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">fmt</span>

<span class="kd">var</span> <span class="nx">IsSpace</span> <span class="p">=</span> <span class="nx">isSpace</span>
</pre></div>
<p>Este archivo de prueba no define pruebas; simplemente declara el simbolo exportado <code>fmt.IsSpace</code> para el uso de la prueba externa. Este truco tambien se puede utilizar cada vez que una prueba externa necesita utilizar algunas de las tecnicas de prueba de caja blanca.</p>
</div>
<h4 id="Seccion-11.2.5" >Escribir Pruebas Efectivas</h4>
<div class="hBody-4" >
<p>Muchos recien llegados a Go se sorprenden por el minimalismo del marco de pruebas de Go. los frameworks otros lenguajes proporcionan mecanismos para la identificacion de las funciones de prueba (a menudo utilizan la reflexion o metadatos), ganchos para realizar operaciones de <q>configuracion</q> y <q>desmontaje</q> antes y despues de ejecucion de pruebas, y l librerias de funciones de utilidad para afirmar predicados comunes, comparar valores, formatear mensajes de error, y abortar una prueba fallida (a menudo utilizando excepciones). Aunque estos mecanismos pueden hacer las pruebas muy concisas, las pruebas resultantes a menudo parecen estar escritas en un lenguaje extranjero. Ademas, aunque pueden reportar <code>PASS</code> o <code>FAIL</code> correctamente, su forma puede ser hostil al infortunado mantenedor, con mensajes de error cripticos como <code>&quot;assert: 0 == 1&quot;</code> o pagina tras pagina de trazas de la pila.</p>
<p>La actitud de Go a la pruebas esta en contraste. Se espera que los autores de las pruebas hagan la mayor parte de este trabajo ellos mismos, definiendo funciones para evitar la repeticion, tal como lo harian para los programas ordinarios. El proceso de prueba no es uno relleno de formatos; una prueba tiene una interfaz de usuario tambien, aunque uno cuyos unicos usuarios son tambien sus mantenedores. Una buena prueba no explota al fracasar, en su lugar imprime una descripcion clara y sucinta del sintoma del problema, y ​​tal vez otros hechos relevantes sobre el contexto. Idealmente, el mantenedor no deberia necesitar leer el codigo fuente para descifrar un fallo de prueba. Una buena prueba no debe abandonar despues de un fallo, debe intentar reportar varios errores en una sola ejecucion, ya que el patron de fallas puede ser revelador.</p>
<p>La funcion de asercion siguiente compara dos valores, genera un mensaje de error generico y detiene el programa. Es facil de usar y es correcta, pero cuando falla, el mensaje de error es casi inutil. No resuelve el dificil problema de proporcionar una buena interfaz de usuario.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;fmt&quot;</span>
  <span class="s">&quot;strings&quot;</span>
  <span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="c1">// Una mala funcion de asercion.</span>
<span class="kd">func</span> <span class="nx">assertEqual</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="nx">y</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d != %d&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="s">&quot;a:b:c&quot;</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">)</span>
  <span class="nx">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>En este sentido, las funciones de asercion sufren de abstraccion prematura: al tratar el fracaso de esta prueba en particular como una mera diferencia de dos numeros enteros, perdemos la oportunidad de proporcionar un contexto significativo. Podemos proporcionar un mejor mensaje a partir de los detalles concretos, como en el ejemplo siguiente. Solo una vez que surgen patrones repetitivos en una suite de pruebas dada es el momento de introducir abstracciones.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="o">:=</span> <span class="s">&quot;a:b:c&quot;</span><span class="p">,</span> <span class="s">&quot;:&quot;</span>
  <span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">want</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">words</span><span class="p">),</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;Split(%q, %q) returned %d words, want %d&quot;</span><span class="p">,</span>
      <span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Ahora la prueba reporta la funcion que se llamo, sus entradas y el significado del resultado; Identifica explicitamente el valor actual y la expectativa; Y continua ejecutandose incluso si esta afirmacion falla. Una vez que hemos escrito una prueba de este tipo, el siguiente paso natural a menudo no es definir una funcion para reemplazar toda le sentencia <code>if</code>, sino ejecutar la prueba en un bucle en el que varien <code>s</code>, <code>sep</code>, y <code>want</code>, como en la prueba basada en tablas de <code>IsPalindrome</code>.</p>
<p>El ejemplo anterior no necesitaba funciones de utilidad, pero por supuesto eso no deberia impedirnos introducir funciones cuando ayudan a simplificar el codigo. (Veremos una funcion de utilidad, <code>reflect.DeepEqual</code>, en la <a href="#Seccion-13.3" >Seccion 13.3</a>.) La clave para una buena prueba es empezar por la aplicacion de la conducta concreta que desea y solo entonces utilizar las funciones para simplificar el codigo y eliminar la repeticion. Los mejores resultados rara vez se obtienen comenzando con una libreria de funciones de pruebas abstractas y genericas.</p>
<p><b>Ejercicio 11.5</b>: Extender <code>TestSplit</code> para utilizar una tabla de entradas y salidas esperadas.</p>
</div>
<h4 id="Seccion-11.2.6" >Evitar Pruebas Fragiles</h4>
<div class="hBody-4" >
<p>Una aplicacion que falla a menudo cuando se encuentra con entradas nuevas pero validas, se denomina <em>buggy</em>; una prueba que falla falsamente cuando se hace un cambio de sonido al programa se denomina <em>fragil</em>. Asi como un programa buggy frustra a sus usuarios, una prueba fragil exaspera a sus mantenedores. Las pruebas mas fragiles, que fallan por casi cualquier cambio en el codigo de produccion, buena o mala, a veces se denominan pruebas de <em>detector de cambio</em> o de <em>status quo</em>, y el tiempo dedicado a tratar con ellos puede consumir rapidamente cualquier beneficio que una vez parecian ofrecer.</p>
<p>Cuando una funcion bajo prueba produce una salida compleja, como una cadena larga, una estructura de datos elaborada, o un archivo, es tentador comprobar que la salida es exactamente igual a algun valor <q>dorado</q> que se esperaba cuando se escribio la prueba. Pero a medida que el programa evoluciona, partes de la produccion probablemente cambian, probablemente de buenas forma, pero cambien sin embargo. Y no es solo la salida; Las funciones con entradas complejas suelen romperse porque la entrada utilizada en una prueba ya no es valida.</p>
<p>La manera mas facil de evitar las pruebas fragiles es comprobar solo las propiedades que le interesan. Pruebe las interfaces mas sencillas y estables de su programa con preferencia a sus funciones internas. Sea selectivo en sus afirmaciones. Por ejemplo, no compruebe si hay coincidencias exactas de cadenas, pero busque subsecciones relevantes que no cambien a medida que el programa evoluciona. A menudo vale la pena escribir una funcion sustancial para destilar una salida compleja hasta su esencia para que las afirmaciones sean confiables. A pesar de que puede parecer una gran cantidad de esfuerzo inicial, puede pagarse por si mismo rapidamente en el tiempo que de otro modo se gastaria reparando falsas pruebas de error.</p>
</div>
<h3 id="Seccion-11.3" >Cobertura</h3>
<div class="hBody-3" >
<p>Por su naturaleza, las pruebas nunca son completas. Como lo dijo el influyente cientifico informatico Edsger Dijkstra: <q>Las pruebas muestran lo presente, no la ausencia de errores.</q> Ninguna cantidad de pruebas puede probar que un paquete esta libre de errores. En el mejor de los casos, aumentan nuestra confianza en que el paquete funciona bien en una amplia gama de escenarios importantes.</p>
<p>El grado en que una suite de pruebas prueba un paquete que se denomina <em>cobertura</em> de la prueba. La cobertura no se puede cuantificar directamente–la dinamica de todos los programas, excepto los mas triviales, esta mas alla de la medicion exacta–pero hay heuristicas que pueden ayudarnos a dirigir nuestros esfuerzos de pruebas a donde es mas probable que sean utiles.</p>
<p>La <em>cobertura de sentencias</em> es la mas simple y mas utilizada de estas heuristicas. La cobertura de sentencias de una suite de pruebas es la fraccion de sentencias de origen que se ejecutan al menos una vez durante la prueba. En esta seccion, vamos a utilizar la herramienta <code class="command" >cover</code> de Go, que esta integrada en <code class="command" >go test</code>, para medir la cobertura de sentencias y ayudar a identificar lagunas evidentes en las pruebas.</p>
<p>El codigo siguiente es una prueba basada en tablas para el evaluador de expresiones que construimos en el <a href="#Capitulo-7" >Capitulo 7</a>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch7/eval/coverage_test.go" >gopl.io/ch7/eval</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestCoverage</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">input</span> <span class="kt">string</span>
    <span class="nx">env</span>   <span class="nx">Env</span>
    <span class="nx">want</span>  <span class="kt">string</span> <span class="c1">// error esperado de Parse/Check o resultado de Eval</span>
  <span class="p">}{</span>
    <span class="p">{</span><span class="s">&quot;x % 2&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&quot;unexpected &#39;%&#39;&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;!true&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&quot;unexpected &#39;!&#39;&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;log(10)&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">`unknown function &quot;log&quot;`</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;sqrt(1, 2)&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&quot;call to sqrt has 2 args, want 1&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;sqrt(A / pi)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;A&quot;</span><span class="p">:</span> <span class="mi">87616</span><span class="p">,</span> <span class="s">&quot;pi&quot;</span><span class="p">:</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pi</span><span class="p">},</span> <span class="s">&quot;167&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;pow(x, 3) + pow(y, 3)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span> <span class="s">&quot;1729&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;5 / 9 * (F - 32)&quot;</span><span class="p">,</span> <span class="nx">Env</span><span class="p">{</span><span class="s">&quot;F&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">40</span><span class="p">},</span> <span class="s">&quot;-40&quot;</span><span class="p">},</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
    <span class="nx">expr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Parse</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Check</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">Var</span><span class="p">]</span><span class="kt">bool</span><span class="p">{})</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s: got %q, want %q&quot;</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">continue</span>
    <span class="p">}</span>

    <span class="nx">got</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.6g&quot;</span><span class="p">,</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Eval</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s: %v =&gt; %s, want %s&quot;</span><span class="p">,</span>
        <span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">env</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En primer lugar, vamos a comprobar que la prueba pasa:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -v -run<span class="o">=</span>Coverage gopl.io/ch7/eval
<span class="o">===</span> RUN TestCoverage
--- PASS: TestCoverage <span class="o">(</span><span class="m">0</span>.00s<span class="o">)</span>
PASS
ok      gopl.io/ch7/eval    <span class="m">0</span>.011s
</pre></div>
<p>Este comando muestra el mensaje de uso de la herramienta de cobertura:</p>
<div class="highlight"><pre><span></span>$ go tool cover
Usage of <span class="s1">&#39;go tool cover&#39;</span>:
Given a coverage profile produced by <span class="s1">&#39;go test&#39;</span>:
    go <span class="nb">test</span> -coverprofile<span class="o">=</span>c.out
Open a web browser displaying annotated <span class="nb">source</span> code:
    go tool cover -html<span class="o">=</span>c.out
</pre></div>
<p>El comando go tool ejecuta uno de los ejecutables de la cadena de herramientas Go. Estos programas viven en el directorio <code>$GOROOT/pkg/tool/${GOOS}_${GOARCH}</code>. Gracias a <code class="command" >go build</code>, rara vez es necesario invocarlo directamente.</p>
<p>Ahora corremos la prueba con la bandera <code>-coverprofile</code>:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -run<span class="o">=</span>Coverage -coverprofile<span class="o">=</span>c.out gopl.io/ch7/eval
ok      gopl.io/ch7/eval    <span class="m">0</span>.032s  coverage: <span class="m">68</span>.5% of statements
</pre></div>
<p>Este indicador permite la recopilacion de datos de cobertura <em>instrumentando</em> el codigo de produccion. Es decir, modifica una copia del codigo fuente para que, antes de ejecutar cada bloque de sentencias, se establezca una variable booleana, con una variable por bloque. Justo antes de salir del programa modificado, se escribe el valor de cada variable en el archivo de registro especificado <span class="file" >c.out</span> e imprime un resumen de la fraccion de declaraciones que fueron ejecutados. (Si todo lo que necesita es el resumen, utilice <code class="command" >go test -cover</code>.)</p>
<p>Si <code class="command" >go test</code> se ejecuta con la bandera <code>-covermode=count</code>, la instrumentacion para cada bloque incrementa un contador en lugar de establecer un valor booleano. El registro resultante del recuento de ejecucion de cada bloque permite comparaciones cuantitativas entre los bloques mas <q>calientes</q>, que se ejecutan con mayor frecuencia, y los mas <q>frios</q>.</p>
<p>Despues de haber reunido los datos, corremos la herramienta <code class="command" >cover</code>, que procesa el registro, genera un informe HTML, y lo abre en una nueva ventana del navegador (Figura 11.3).</p>
<div class="highlight"><pre><span></span>$ go tool cover -html<span class="o">=</span>c.out
</pre></div>
<div class="figure" >
<p class="title">Figura 11.3. Un informe de cobertura.</p>
<figure>
<img src="img/Figure-11.3.jpg" />
</figure>
</div>
<p>Cada declaracion es de color verde si estaba cubierta o rojo si no. Para mayor claridad, hemos sombreado el fondo del texto rojo. Podemos ver inmediatamente que ninguna de nuestras entradas prueba el operador unario del metodo <code>Eval</code>. Si agregamos este nuevo caso de prueba a la tabla y volvemos a ejecutar los dos comandos anteriores, el codigo de expresion unario se convierte en verde:</p>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="s">&quot;-x * -x&quot;</span><span class="p">,</span> <span class="nx">eval</span><span class="p">.</span><span class="nx">Env</span><span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="s">&quot;4&quot;</span><span class="p">}</span>
</pre></div>
<p>Sin embargo, las dos declaraciones <code>panic</code> permanecen de color rojo. Esto no debe ser sorprendente, porque se supone que estas declaraciones son inaccesibles.</p>
<p>Alcanzar una cobertura del 100% de la declaracion suena como un objetivo noble, pero generalmente no es factible en la practica, ni es probable que sea un buen uso del esfuerzo. El hecho de que se ejecute una sentencia no significa que este libre de errores; Las declaraciones que contienen expresiones complejas se deben ejecutar muchas veces con entradas diferentes para cubrir los casos interesantes. Algunos estados, como las declaraciones <code>panic</code> anteriores, no pueden ser alcanzados. Otros, como los que manejan errores esotericos, son dificiles de probar pero raramente alcanzados en la practica. Las pruebas son fundamentalmente un esfuerzo pragmatico, un equilibrio entre el costo de escritura de las pruebas y el costo de los fallos que podrian haber sido evitados por las pruebas. Las herramientas de cobertura pueden ayudar a identificar los puntos mas debiles, pero idear buenos casos de prueba requiere el mismo pensamiento riguroso que la programacion en general.</p>
</div>
<h3 id="Seccion-11.4" >Funciones <code>Benchmark</code></h3>
<div class="hBody-3" >
<p>Benchmarking es la practica de medir el rendimiento de un programa con una carga de trabajo fija. En Go, una funcion de referencia se parece a una funcion de prueba, pero con el prefijo <code>Benchmark</code> y un parametro <code>*testing.B</code> que proporciona la mayor parte de los mismos metodos que un <code>*testing.T</code>, ademas algunos adicionales relacionados con la medicion del desempeño. Tambien expone un campo entero <code>N</code>, que especifica el numero de veces que se realizara la operacion que se esta midiendo.</p>
<p>Aqui tenemos el benchmark para <code>IsPalindrome</code> que llama <code>N</code> veces en un bucle.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;testing&quot;</span>
<span class="kd">func</span> <span class="nx">BenchmarkIsPalindrome</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;A man, a plan, a canal: Panama&quot;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Lo ejecutamos con el siguiente comando. A diferencia de las pruebas, los benchmarks por defecto no se ejecutan. El argumento <code>-bench</code> selecciona que deben ejecutarso los benchmark. Es una expresion regular que coincide con los nombres de las funciones <code>Benchmark</code>, con un valor predeterminado que no coincide con ninguno de ellos. El patron <q><code>.</code></q> hace que coincida con todos los benchmark en el paquete <code>word</code>, pero ya que solo hay una, <code>-bench=IsPalindrome</code> habria sido equivalente.</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> <span class="nv">$GOPATH</span>/src/gopl.io/ch11/word2
$ go <span class="nb">test</span> -bench<span class="o">=</span>.
PASS
BenchmarkIsPalindrome-8 <span class="m">1000000</span>               <span class="m">1035</span> ns/op
ok      gopl.io/ch11/word2      <span class="m">2</span>.179s
</pre></div>
<p>El Sufijo numerico de benchmark, <code>8</code> aqui, indica el valor de <code>GOMAXPROCS</code>, lo cual es importante para los benchmark concurrentes.</p>
<p>El informe nos dice que cada llamada a <code>IsPalindrome</code> tomo cerca de 1.035 microsegundos, un promedio de mas de 1.000.000 ejecuciones. Puesto que el corredor referencia inicialmente no tiene idea de cuanto tiempo dura la operacion, realiza algunas mediciones iniciales utilizando valores pequeños de <code>N</code> y luego extrapola hasta un valor lo suficientemente grande para realizar una medicion de temporizacion estable.</p>
<p>La razon por la que el bucle se implementa por la funcion benchmark, y no por el codigo de llamada en el controlador de prueba, es para que la funcion de referencia tenga la oportunidad de ejecutar cualquier codigo de configuracion de una sola vez fuera del bucle sin que esto se añada al tiempo medido de cada iteracion. Si este codigo de configuracion sigue perturbando los resultados, el parametro <code>testing.B</code> proporciona metodos para detener, reanudar y reiniciar el temporizador, pero estos rara vez son necesarios.</p>
<p>Ahora que tenemos un punto de referencia y pruebas, es facil probar ideas para hacer el programa mas rapido. Quizas la optimizacion mas abvia es hacer el el bucle de <code>IsPalindrome</code> detenga la verificacion en el punto medio, para evitar hacer cada comparacion dos veces:</p>
<div class="highlight"><pre><span></span><span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">letters</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">letters</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">letters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</pre></div>
<p>Pero como suele ser el caso, una optimizacion obvia no siempre da el beneficio esperado. Este proporciono una mera mejora del 4% en un experimento.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -bench<span class="o">=</span>.
PASS
BenchmarkIsPalindrome-8 <span class="m">1000000</span>                <span class="m">992</span> ns/op
ok      gopl.io/ch11/word2      <span class="m">2</span>.093s
</pre></div>
<p>Otra idea es asignar previamente una gama suficientemente amplia para su uso por <code>letters</code>, en lugar de expandirlo mediante llamadas sucesivas a append. Declaramos <code>letters</code> como un arreglo del tamaño adecuado, de esta manera,</p>
<div class="highlight"><pre><span></span><span class="nx">letters</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">IsLetter</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">letters</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">letters</span><span class="p">,</span> <span class="nx">unicode</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Produce una mejora de casi 35%, y el marcador del benchmark ahora informa el promedio de mas de 2.000.000 de iteraciones.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -bench<span class="o">=</span>.
PASS
BenchmarkIsPalindrome-8 <span class="m">2000000</span>                <span class="m">697</span> ns/op
ok      gopl.io/ch11/word2      <span class="m">1</span>.468s
</pre></div>
<p>Como muestra este ejemplo, el programa mas rapido es a menudo el que hace menos asignaciones de memoria. La bandera <code>-benchmem</code> de linea de comandos, incluira estadisticas de asignacion de memoria en su informe. Aqui comparamos el numero de asignaciones antes de la optimizacion:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -bench<span class="o">=</span>. -benchmem
PASS
BenchmarkIsPalindrome    <span class="m">1000000</span>  <span class="m">1026</span> ns/op    <span class="m">304</span> B/op  <span class="m">4</span> allocs/op
</pre></div>
<p>Y despues de ella:</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -bench<span class="o">=</span>. -benchmem
PASS
BenchmarkIsPalindrome    <span class="m">2000000</span>   <span class="m">807</span> ns/op    <span class="m">128</span> B/op  <span class="m">1</span> allocs/op
</pre></div>
<p>La consolidacion de las asignaciones en una sola llamada a make eliminado el 75% de las asignaciones y reduce a la mitad la cantidad de memoria asignada.</p>
<p>Los benchmark de este tipo nos dicen que el tiempo absoluto requerido para una operacion dada, pero en muchas configuraciones las preguntas de desempeño interesantes estan en los tiempos <em>relativos</em> de dos operaciones diferentes. Por ejemplo, si una funcion toma 1ms para procesar 1,000 elementos, ¿cuanto tiempo tardara en procesar 10,000 o un millon? Tales comparaciones revelan el crecimiento asintotico del tiempo de funcionamiento de la funcion. Otro ejemplo: ¿cual es el mejor tamaño para un bufer de E/S? Los benchmarks del rendimiento de la aplicacion en un rango de tamaños pueden ayudarnos a elegir el buffer mas pequeño que ofrece un rendimiento satisfactorio. Un tercer ejemplo: ¿cual algoritmo funciona mejor para un trabajo determinado? Los benchmark que evaluan dos algoritmos diferentes en los mismos datos de entrada a menudo pueden mostrar las fortalezas y debilidades de cada uno en cargas de trabajo importantes o representativas.</p>
<p>Los benchmarks comparativos son solo codigo regular. Por lo general toman la forma de una sola funcion parametrizada, llamada de varias funciones <code>Benchmark</code> con diferentes valores, como esto:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark10</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span>   <span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark100</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>  <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span>  <span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">Benchmark1000</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span> <span class="nx">benchmark</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
<p>El parametro de <code>size</code>, que especifica el tamaño de la entrada, varia a traves de los benchmark, pero es constante dentro de cada punto de referencia. Resista la tentacion de utilizar el parametro <code>b.N</code> como el tamaño de entrada. A menos que lo interprete como un recuento de iteracion para una entrada de tamaño fijo, los resultados de su benchmark no tendran sentido.</p>
<p>Los patrones revelados por los benchmark comparativos son particularmente utiles durante el diseño del programa, pero no arrojamos los benchmark cuando el programa esta funcionando. A medida que el programa evoluciona, o su entrada crece, o se despliega en nuevos sistemas operativos o procesadores con caracteristicas diferentes, podemos reutilizar esos benchmark para revisar las decisiones de diseño.</p>
<p><b>Ejercicio 11.6</b>: Escribir benchmark para comparar la implementacion <code>PopCount</code> en la <a href="#Seccion-2.6.2" >Seccion 2.6.2</a> con sus soluciones al Ejercicio 2.4 y Ejercicio 2.5. ¿En que punto el enfoque basado en tablas se equilibra?</p>
<p><b>Ejercicio 11.7</b>: Escribir benchmark para <code>Add</code>, <code>UnionWith</code>, y otros metodos de <code>*IntSet</code> (<a href="#Seccion-6.5" >Seccion 6.5</a>) utilizando grandes entradas pseudoaleatorias. ¿Que tan rapido puede hacer que estos metodos se ejecuten? ¿Como afecta la eleccion del tamaño de la palabra al rendimiento? ¿Que tan rapido es <code>IntSet</code> en comparacion con una implementacion de conjunto basado en el tipo integrado de mapa?</p>
</div>
<h3 id="Seccion-11.5" >Perfilado</h3>
<div class="hBody-3" >
<p>Los benchmark son utiles para medir el rendimiento de operaciones especificas, pero cuando estamos tratando de hacer un programa lento mas rapido, a menudo no tenemos idea por donde empezar. Todo programador conoce el aforismo de Donald Knuth acerca de la optimizacion prematura, que aparecio en <q>Structured Programming with go to Statements</q> en 1974. Aunque a menudo mal interpretado en el sentido de rendimiento, no importa, en su contexto original, podemos discernir un significado diferente:</p>
<blockquote>
<p>No hay duda de que el grial de la eficiencia conduce al abuso. Los programadores pierden enormes cantidades de tiempo pensando o preocupandose por la velocidad de las partes no criticas de sus programas, y estos intentos de eficiencia realmente tienen un fuerte impacto negativo cuando se consideran la depuracion y el mantenimiento. <em>Debemos</em> olvidarnos de las pequeñas eficiencias, digamos alrededor del 97% del tiempo: la optimizacion prematura es la raiz de todo mal.</p>
<p>Sin embargo, no debemos dejar pasar nuestras oportunidades en ese critico 3%. Un buen programador no se engañara en complacencia por tal razonamiento, el sera sabio mirando cuidadosamente el codigo critico; Pero solo <em>despues</em> de que el codigo se ha identificado. A menudo es un error hacer juicios a priori sobre que partes de un programa son realmente criticos, ya que la experiencia universal de los programadores que han estado utilizando herramientas de medicion ha sido que sus suposiciones intuitivas fallan.</p>
</blockquote>
<p>Cuando deseamos prestar atencion a la velocidad de nuestros programas, la mejor tecnica para identificar el codigo critico es el <em>perfilado</em>. El perfilado es un enfoque automatizado para la medicion del rendimiento basado en el muestreo de un numero de <em>eventos</em> de perfil durante la ejecucion, extrapolando luego de ellos durante una etapa de post-procesamiento; el resumen estadistico resultante se llama un <em>perfil</em>.</p>
<p>Go soporta muchos tipos de perfiles, cada uno de ellos relacionado con un aspecto diferente del rendimiento, pero todos ellos implican grabar una secuencia de eventos de interes, cada uno de los cuales tiene un seguimiento de pila que acompaña–la pila de llamadas de funcion activas en el momento del evento. La herramienta <code class="command" >go test</code> tiene soporte integrado para varios tipos de perfiles.</p>
<p>Un <em>perfil de CPU</em> identifica las funciones cuya ejecucion requiere mas tiempo de CPU. El subproceso actualmente en ejecucion en cada CPU es interrumpido periodicamente por el sistema operativo cada pocos milisegundos, con cada interrupcion registrando un evento de perfil antes de que se reanude la ejecucion normal.</p>
<p>Un <em>perfil de monticulo</em> identifica las declaraciones responsables de la asignacion de la mayoria de la memoria. La libreria de perfiles muestrea las llamadas a las rutinas de asignacion de memoria interna de manera que, en promedio, se registra un evento de perfil por cada 512 KB de memoria asignada.</p>
<p>Un <em>perfil de bloqueo</em> identifica las operaciones responsable del bloqueo de las gorutinas mas largas, como las llamadas al sistema, envio y recepcion de canales, y adquisiciones de bloqueos. La libreria de perfilado registra un evento cada vez que una gorutina es bloqueada por una de estas operaciones.</p>
<p>Recopilar un perfil para el codigo bajo prueba es tan facil como habilitar uno de los indicadores a continuacion. Tenga cuidado al usar mas de una bandera a la vez, sin embargo: la maquinaria para recoger un tipo de perfil puede sesgar los resultados de otros.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -cpuprofile<span class="o">=</span>cpu.out
$ go <span class="nb">test</span> -blockprofile<span class="o">=</span>block.out
$ go <span class="nb">test</span> -memprofile<span class="o">=</span>mem.out
</pre></div>
<p>Es facil agregar soporte de perfilado a programas que no son de prueba, aunque los detalles de como lo hacemos varian entre las herramientas de linea de comandos de corta duracion y las aplicaciones de servidor de larga ejecucion. El perfilado es especialmente util en aplicaciones de larga duracion, por lo que las caracteristicas de generacion de perfiles en tiempo de ejecucion de Go pueden habilitarse bajo el control del programador utilizando la API <code>runtime</code>.</p>
<p>Una vez que hemos reunido un perfil, es necesario analizar usando la herramienta <code class="command" >pprof</code>. Esta es una parte estandar de la distribucion Go, pero ya que no es una herramienta de uso diario, se accede indirectamente usando <code class="command" >go tool pprof</code>. Tiene docenas de caracteristicas y opciones, pero el uso basico requiere solo dos argumentos, el ejecutable que produjo el perfil y el registro del perfil.</p>
<p>Para que el perfil sea eficiente y para ahorrar espacio, el registro no incluye nombres de funciones; En su lugar, las funciones se identifican por sus direcciones. Esto significa que <code class="command" >pprof</code> necesita el ejecutable para que el registro tenga sentido. Aunque <code class="command" >go test</code> generalmente descarta el ejecutable de prueba una vez finalizada la prueba, cuando el perfilado se habilita guarda el archivo ejecutable como <span class="file" >Foo.test</span>, donde <code>foo</code> es el nombre del paquete de prueba.</p>
<p>Los siguientes comandos muestran como recopilar y mostrar un perfil de CPU simple. Hemos seleccionado uno de los benchmark del <code>net/http</code>. Por lo general, es mejor hacer un perfil de benchmark especificos que se han construido para ser representativos de las cargas de trabajo que a uno le preocupan. En los benchmark los casos de prueba casi nunca son representativos, es por ello que las desactivo mediante el filtro <code>-run=NONE</code>.</p>
<div class="highlight"><pre><span></span>$ go <span class="nb">test</span> -run<span class="o">=</span>NONE -bench<span class="o">=</span>ClientServerParallelTLS64 <span class="se">\</span>
    -cpuprofile<span class="o">=</span>cpu.log net/http
PASS
BenchmarkClientServerParallelTLS64-8 <span class="m">1000</span>
   <span class="m">3141325</span> ns/op  <span class="m">143010</span> B/op  <span class="m">1747</span> allocs/op
ok      net/http       <span class="m">3</span>.395s

$ go tool pprof -text -nodecount<span class="o">=</span><span class="m">10</span> ./http.test cpu.log
2570ms of 3590ms total <span class="o">(</span><span class="m">71</span>.59%<span class="o">)</span>
Dropped <span class="m">129</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> <span class="m">17</span>.95ms<span class="o">)</span>
Showing top <span class="m">10</span> nodes out of <span class="m">166</span> <span class="o">(</span>cum &gt;<span class="o">=</span> 60ms<span class="o">)</span>
flat    flat%   sum%     cum   cum%
1730ms <span class="m">48</span>.19% <span class="m">48</span>.19%  1750ms <span class="m">48</span>.75%  crypto/elliptic.p256ReduceDegree
230ms <span class="m">6</span>.41%   <span class="m">54</span>.60%   250ms  <span class="m">6</span>.96%  crypto/elliptic.p256Diff
120ms <span class="m">3</span>.34%   <span class="m">57</span>.94%   120ms  <span class="m">3</span>.34%  math/big.addMulVVW
110ms <span class="m">3</span>.06%   <span class="m">61</span>.00%   110ms  <span class="m">3</span>.06%  syscall.Syscall
 90ms <span class="m">2</span>.51%   <span class="m">63</span>.51%  1130ms <span class="m">31</span>.48%  crypto/elliptic.p256Square
 70ms <span class="m">1</span>.95%   <span class="m">65</span>.46%   120ms  <span class="m">3</span>.34%  runtime.scanobject
 60ms <span class="m">1</span>.67%   <span class="m">67</span>.13%   830ms <span class="m">23</span>.12%  crypto/elliptic.p256Mul
 60ms <span class="m">1</span>.67%   <span class="m">68</span>.80%   190ms  <span class="m">5</span>.29%  math/big.nat.montgomery
 50ms <span class="m">1</span>.39%   <span class="m">70</span>.19%    50ms  <span class="m">1</span>.39%  crypto/elliptic.p256ReduceCarry
 50ms <span class="m">1</span>.39%   <span class="m">71</span>.59%    60ms  <span class="m">1</span>.67%  crypto/elliptic.p256Sum
</pre></div>
<p>La bandera <code>-text</code> especifica el formato de salida, en este caso, una tabla textual con una fila por cada funcion, ordenada para que las funciones <q>mas activas</q>–Las que consumen mas ciclos de CPU–aparecescan primero. La bandera <code>-nodecount=10</code> limita el resultado a 10 filas. Para los problemas de rendimiento bruto, este formato textual puede ser suficiente para identificar la causa.</p>
<p>Este perfil nos dice que la criptografia de curva eliptica es importante para el rendimiento de este benchmark HTTPS en particular. Por el contrario, si un perfil esta dominado por funciones de asignacion de memoria desde el paquete <code>runtime</code>, reducir el consumo de memoria puede ser una optimizacion que vale la pena.</p>
<p>Para problemas mas sutiles, puede ser mejor usar una de las pantallas graficas de <code class="command" >pprof</code>. Estas requieren GraphViz, que se puede descargar desde <a href="www.graphviz.org" >www.graphviz.org</a>. La bandera <code>-web</code> entonces crea un grafico dirigido de las funciones del programa, anotadas por sus numeros de perfil de la CPU y de colores para indicar las funciones mas calientes.</p>
<p>Solo hemos arañado la superficie de las herramientas de perfilado de Go. Para obtener mas informacion, lea el articulo <q>Profiling Go Programs</q> en el Blog de Go.</p>
</div>
<h3 id="Seccion-11.6" >Funciones <code>Example</code></h3>
<div class="hBody-3" >
<p>El tercer tipo de funcion tratada especialmente por <code class="command" >go test</code> es una funcion de ejemplo, uno cuyo nombre empieza con <code>Example</code>. No tiene parametros ni resultados. Aqui un ejemplo para la funcion <code>IsPalindrome</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ExampleIsPalindrome</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;A man, a plan, a canal: Panama&quot;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">IsPalindrome</span><span class="p">(</span><span class="s">&quot;palindrome&quot;</span><span class="p">))</span>
  <span class="c1">// Output:</span>
  <span class="c1">// true</span>
  <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
<p>Las funciones de ejemplo sirven para tres propositos. El principal es la documentacion: un buen ejemplo puede ser una forma mas sucinta o intuitiva de transmitir el comportamiento de una funcion de libreria, que su descripcion en prosa, especialmente cuando se usa como recordatorio o referencia rapida. Un ejemplo tambien puede demostrar la interaccion entre varios tipos y funciones pertenecientes a una API, mientras que la documentacion en prosa siempre debe estar unida a un lugar, como una declaracion de tipo o funcion o el paquete en su conjunto. Y a diferencia de los ejemplos dentro de los comentarios, las funciones de ejemplo son codigo Go real, sujeto a comprobacion en tiempo de compilacion, para que no se vuelvan obsoletos a medida que el codigo evoluciona.</p>
<p>Basado en el sufijo <code>Example</code> de la de funcion, el servidor de documentacion basado en la web <code class="command" >godoc</code> asocia funciones ejemplo con la funcion o el paquete que ejemplifican, por lo que <code>ExampleIsPalindrome</code> se mostrara con la documentacion para la funcion <code>IsPalindrome</code>, y se asociara una funcion de ejemplo llamado simplemente <code>Example</code> asociado con el paquete <code>word</code> en su conjunto.</p>
<p>El segundo proposito es que los ejemplos son pruebas ejecutables dirigidas por <code class="command" >go test</code>. Si la funcion de ejemplo contiene un comentario final <code>// Output</code>: comentar el de arriba, el controlador de pruebas ejecutara la funcion y comprobar que lo que se imprime en la salida estandar coincide con el texto dentro de los comentarios.</p>
<p>El tercer objetivo de un ejemplo es la experimentacion practica. El servidor <code class="command" >godoc</code> en <code>golang.org</code> utiliza la Zona de juegos para permitir al usuario editar y ejecutar cada funcion de ejemplo desde un navegador web, como se muestra en la Figura 11.4. Esta es a menudo la manera mas rapida de conseguir una sensacion para una funcion o caracteristica del lenguaje particular.</p>
<div class="figure" >
<p class="title">Figura 11.4. Un ejemplo interactiva de <code>strings.Join</code> en <code class="command" >godoc</code>.</p>
<figure>
<img src="img/Figure-11.4.jpg" />
</figure>
</div>
<p>Los dos capitulos finales del libro examinan los paquetes <code>reflect</code> y <code>unsafe</code>, que pocon programadores Go utilizan regularmente–e incluso menos <em>necesitan</em> usarlos. Si aun no ha escrito ningun programa de Go sustancial, ahora seria un buen momento para hacerlo.</p>
</div>
<h2 id="Capitulo-12" >Reflexion</h2>
<div class="hBody-2" >
<p>Go proporciona un mecanismo para actualizar variables e inspeccionar sus valores en tiempo de ejecucion, llamar a sus metodos y aplicar las operaciones intrinsecas a su representacion, todo sin conocer sus tipos en tiempo de compilacion. Este mecanismo se denomina <em>reflexion</em>. La reflexion tambien nos permite tratar los propios tipos como valores de primera clase.</p>
<p>En este capitulo, vamos a explorar las caracteristicas de reflexion de Go para ver la forma en que aumentan la expresividad del lenguaje, y en particular la forma en que son cruciales para la implementacion de dos APIs importantes: el formateo de cadenas proporcionado por <code>fmt</code>, y el protocolo de codificacion proporcionados por los paquetes <code>encoding/json</code> y <code>encoding/xml</code>. La reflexion es tambien esencial para el mecanismo de plantilla proporcionada por los paquetes <code>text/template</code> y <code>html/template</code> que vimos en la <a href="#Seccion-4.6" >Seccion 4.6</a>. Sin embargo, es complejo razonar la reflexion y no es para uso casual, por lo que aunque estos paquetes se implementan mediante la reflexion, no exponen la reflexion en sus propias API.</p>
</div>
<h3 id="Seccion-12.1" >¿Por que la Reflexion?</h3>
<div class="hBody-3" >
<p>A veces necesitamos escribir una funcion capaz de tratar uniformemente con valores de tipos que no satisfacen una interfaz comun, no tienen una representacion conocida o no existen en el momento en que diseñamos la funcion–o incluso los tres.</p>
<p>Un ejemplo familiar es la logica de formateo dentro de <code>fmt.Fprintf</code>, que puede imprimir de manera util un valor arbitrario de cualquier tipo, incluso uno definido por el usuario. Tratemos de implementar una funcion como esta usando lo que ya sabemos. Para simplificar, nuestra funcion acepta un argumento y devuelve el resultado como una cadena como hace <code>fmt.Sprint</code>, asi que vamos a llamarlo <code>Sprint</code>.</p>
<p>Empezamos con un <code>switch</code> de tipo que pone a prueba si el argumento define una metodo <code>String</code>, y lo llaman si es asi. A continuacion, agregamos casos que ponen a prueba el tipo dinamico del valor en cada uno de los tipos basicos–<code>string</code>, <code>int</code>, <code>bool</code>, etc–y realice la operacion de formato adecuado en cada caso.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Sprint</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="kd">type</span> <span class="nx">stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
  <span class="p">}</span>
  <span class="k">switch</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">stringer</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
  <span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span>
  <span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="c1">// ...similar cases for int16, uint32, and so on...</span>
  <span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;true&quot;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&quot;false&quot;</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="c1">// array, chan, func, map, pointer, slice, struct</span>
    <span class="k">return</span> <span class="s">&quot;???&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Pero, ¿como podemos hacer frente a otros tipos, como <code>[]float64</code>, <code>map[string][]string</code>, y demas? Podriamos añadir mas casos, pero el numero de tales tipos es infinito. Y que pasa con los tipos con nombre, como <code>url.Values</code>? Incluso si el <code>switch</code> de tipo tenia un caso para su tipo subyacente <code>map[string][]string</code>, no coincidira con con <code>url.Values</code> porque los dos tipos no son identicos, y el interruptor de tipo no puede incluir un caso para cada tipo como <code>url.Values</code> porque eso requeriria que esta libreria dependa de sus clientes.</p>
<p>Sin una manera de inspeccionar la representacion de valores de tipos desconocidos, rapidamente nos quedamos atascados. Lo que necesitamos es reflexion.</p>
</div>
<h3 id="Seccion-12.2" ><code>reflect.Type</code> y <code>reflect.Value</code></h3>
<div class="hBody-3" >
<p>La reflexion es proporcionada por el paquete <code>reflect</code>. Este define dos tipos importantes, <code>Type</code> y <code>Value</code>. <code>Type</code> representa un tipo Go. Es una interfaz con muchos metodos para discriminar entre tipos e inspeccionar sus componentes, como los campos de una estructura o los parametros de una funcion. La unica aplicacion de <code>reflect.Type</code> es el descriptor de tipo (<a href="#Seccion-7.5" >§7.5</a>), la misma entidad que identifica el tipo dinamico de un valor interfaz.</p>
<p>la funcion <code>reflect.TypeOf</code> acepta cualquier <code>interface{}</code> y devuelve su tipo dinamico como <code>reflect.Type</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">// un reflect.Type</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;int&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>          <span class="c1">// &quot;int&quot;</span>
</pre></div>
<p>La llamada <code>TypeOf(3)</code> anterior asigna el valor 3 al parametro <code>interface{}</code>. Recuerdese de la <a href="#Seccion-7.5" >Seccion 7.5</a> que una asignacion de un valor concreto a un tipo de interfaz lleva a cabo una conversion de la interfaz implicita, que crea un valor interfaz que consta de dos componentes: su <em>tipo dinamico</em> es el tipo del operando (<code>int</code>) y su <em>valor dinamico</em> es el valor del operando (3).</p>
<p>Ya que <code>reflect.TypeOf</code> regresa el tipo dinamico de un valor de interfaz, siempre devuelve un tipo concreto. Asi, por ejemplo, el codigo que aparce a continuacion imprime <q><code>*os.File</code></q>, no <q><code>*io.Writer</code></q>. Mas tarde, veremos que <code>reflect.Type</code> es capaz de representar tipos de interfaz tambien.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">TypeOf</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span> <span class="c1">// &quot;*os.File&quot;</span>
</pre></div>
<p>Observe que <code>reflect.Type</code> satisface <code>fmt.Stringer</code>. Como la impresion del tipo dinamico de un valor interfaz es util para depuracion y registro, <code>fmt.Printf</code> proporciona una abreviatura, <code>%T</code>, que internamente utiliza <code>reflect.TypeOf</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// &quot;int&quot;</span>
</pre></div>
<p>El otro tipo importante en el paquete <code>reflect</code> es <code>Value</code>. Un <code>reflect.Value</code> puede contener un valor de cualquier tipo. La funcion <code>reflect.ValueOf</code> acepta cualquier <code>interface{}</code> y devuelve un valor <code>reflect.Value</code> que contiene el valor dinamico de la interfaz. Al igual que con <code>reflect.TypeOf</code>, los resultados de <code>reflect.ValueOf</code> son siempre concretos, pero un <code>reflect.Value</code> pueden contener valores de interfaz tambien.</p>
<div class="highlight"><pre><span></span><span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">// un reflect.Value</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>           <span class="c1">// &quot;3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>    <span class="c1">// &quot;3&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>  <span class="c1">// NOTA: &quot;&lt;int Value&gt;&quot;</span>
</pre></div>
<p>Al igual que <code>reflect.Type</code>, <code>reflect.Value</code> tambien satisface <code>fmt.Stringer</code>, pero a menos que <code>Value</code> contenga un string, el resultado del metodo <code>String</code> solo revela el tipo. En su lugar, utilice el verbo <code>%v</code> del paquete <code>fmt</code>, que maneja <code>reflect.Values</code> especialmente.</p>
<p>Al llamar al metodo <code>Type</code> en un <code>Value</code> devuelve su tipo como <code>reflect.Type</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>           <span class="c1">// un reflect.Type</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// &quot;int&quot;</span>
</pre></div>
<p>La operacion inversa de <code>reflect.ValueOf</code> es el motodo <code>reflect.Value.Interface</code>. Devuelve una <code>interface{}</code> que contiene el mismo valor concreto que <code>reflect.Value</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// un reflect.Value</span>
<span class="nx">x</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Interface</span><span class="p">()</span>      <span class="c1">// un interface{}</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span>            <span class="c1">// un int</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>   <span class="c1">// &quot;3&quot;</span>
</pre></div>
<p>Un <code>reflect.Value</code> y una <code>interface{}</code> pueden ambos contener valores arbitrarios. La diferencia es que una interfaz vacia oculta la representacion y las operaciones intrinsecas del valor que contiene y no expone ninguno de sus metodos, de modo que a menos que conozcamos su tipo dinamico y usemos una asercion de tipo para mirar dentro (como lo hicimos anteriormente), hay Poco que podemos hacer con el valor. Por el contrario, un <code>Value</code> tiene muchos metodos para inspeccionar su contenido, independientemente de su tipo. Vamos a utilizarlos para nuestro segundo intento de una funcion de formateo general, que llamaremos <code>format.Any</code>.</p>
<p>En lugar de un switch de tipo, usaremos <code>reflect.Value</code> y su metodo <code>Kind</code> para discriminar los casos. Aunque hay un numero infinito de tipos, solo hay un numero finito de <code>kinds</code> de tipo: los tipos basicos <code>Bool</code>, <code>String</code>, y todos los numeros; los tipos agregados <code>Array</code> y <code>Struct</code>; los tipos de referencia <code>Chan</code>, <code>Func</code>, <code>Ptr</code>, <code>Slice</code>, y <code>Map</code>; los tipos <code>Interface</code>; y, finalmente, <code>Invalid</code>, es decir, sin valor alguno. (El valor cero de una <code>reflect.Value</code> tiene una tipo <code>Invalid</code>.)</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/format/format.go" >gopl.io/ch12/format</a></p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">format</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;reflect&quot;</span>
  <span class="s">&quot;strconv&quot;</span>
<span class="p">)</span>

<span class="c1">// Any formatea cualquier valor como un string.</span>
<span class="kd">func</span> <span class="nx">Any</span><span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// formatAtom formatea un valor sin inspeccionar su estructura interna.</span>
<span class="kd">func</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">&quot;invalid&quot;</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatInt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Int</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Uint</span><span class="p">(),</span> <span class="mi">10</span><span class="p">)</span>
  <span class="c1">// ...Casos de punto flotante y complejos omitidos por brevedad...</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatBool</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Bool</span><span class="p">())</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Quote</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Chan</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot; 0x&quot;</span> <span class="o">+</span>
      <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()),</span> <span class="mi">16</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span> <span class="c1">// reflect.Array, reflect.Struct, reflect.Interface</span>
    <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot; value&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hasta ahora, nuestra funcion maneja cada valor como una cosa indivisible, sin estructura interna–de ahi <code>formatAtom</code>. Para los tipos de agregados (estructuras y matrices) y las interfaces se imprime unicamente el <em>tipo</em> del valor, y para los tipos de referencia (canales, funciones, punteros, slices, y mapas), se imprime el tipo y la direccion de referencia en hexadecimal. Esto es menos que ideal, pero sigue siendo una importante mejora, y ya que <code>Kind</code> se ocupa solo con la representacion subyacente, <code>format.Any</code> funciona tambien para los timpos con nombre. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Nanosecond</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>                  <span class="c1">// &quot;1&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>                  <span class="c1">// &quot;1&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">([]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">x</span><span class="p">}))</span>         <span class="c1">// &quot;[]int64 0x8202b87b0&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">format</span><span class="p">.</span><span class="nx">Any</span><span class="p">([]</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">{</span><span class="nx">d</span><span class="p">}))</span> <span class="c1">// &quot;[]time.Duration 0x8202b87e0&quot;</span>
</pre></div>
</div>
<h3 id="Seccion-12.3" ><code>Display</code>, una Impresora Recursiva de Valor</h3>
<div class="hBody-3" >
<p>A continuacion veremos como mejorar la visualizacion de tipos compuestos. En lugar de tratar de copiar <code>fmt.Sprint</code> exactamente, vamos a construir una funcion de utilidad de depuracion llamada <code>Display</code> que, dado un valor <code>x</code> arbitrariamente complejo, imprime la estructura completa de ese valor, etiquetando cada elemento con el camino por el cual se encontro. Comencemos con un ejemplo.</p>
<div class="highlight"><pre><span></span><span class="nx">e</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">eval</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="s">&quot;sqrt(A / pi)&quot;</span><span class="p">)</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</pre></div>
<p>En la llamada anterior, el argumento de <code>Display</code> es un arbol sintactico del evaluador de expresiones en la <a href="#Seccion-7.9" >Seccion 7.9</a>. La salida de <code>Display</code> se muestra a continuacion:</p>
<div class="highlight"><pre><span></span>Display e <span class="o">(</span>eval.call<span class="o">)</span>:
e.fn <span class="o">=</span> <span class="s2">&quot;sqrt&quot;</span>
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.type <span class="o">=</span> eval.binary
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.value.op <span class="o">=</span> <span class="m">47</span>
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.value.x.type <span class="o">=</span> eval.Var
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.value.x.value <span class="o">=</span> <span class="s2">&quot;A&quot;</span>
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.value.y.type <span class="o">=</span> eval.Var
e.args<span class="o">[</span><span class="m">0</span><span class="o">]</span>.value.y.value <span class="o">=</span> <span class="s2">&quot;pi&quot;</span>
</pre></div>
<p>Cuando sea posible, debe evitar exponer la reflexion en la API de un paquete. Definiremos un funcion sin exportacion <code>display</code> para hacer el trabajo real de la recursividad, y la exportacion <code>Display</code>, un simple envoltorio alrededor de el que acepta un parametro <code>interface{}</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/display/display.go" >gopl.io/ch12/display</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Display</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Display %s (%T):\n&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
  <span class="nx">display</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En <code>display</code>, usaremos la funcion <code>formatAtom</code> que definimos anteriormente para imprimir valores elementales–tipos basicos, funciones y canales–pero vamos a utilizar los metodos de <code>reflect.Value</code> para mostrar repetidamente cada componente de un tipo mas complejo. A medida que la recursion desciende, la cadena de ruta, que describe inicialmente el valor de partida (por ejemplo, <q><code>e</code></q>), se incrementara para indicar como alcanzamos el valor actual (por ejemplo, <q><code>e.args[0].value</code></q>).</p>
<p>Como ya no pretendemos implementar <code>fmt.Sprint</code>, utilizaremos el paquete <code>fmt</code> para mantener nuestro ejemplo corto.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">display</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = invalid\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s[%d]&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">fieldPath</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s.%s&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">)</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fieldPath</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapKeys</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s[%s]&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span>
        <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">key</span><span class="p">)),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">IsNil</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = nil\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;(*%s)&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">),</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">IsNil</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = nil\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s.type = %s\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">().</span><span class="nx">Type</span><span class="p">())</span>
      <span class="nx">display</span><span class="p">(</span><span class="nx">path</span><span class="o">+</span><span class="s">&quot;.value&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="k">default</span><span class="p">:</span> <span class="c1">// basic types, channels, funcs</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s = %s\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">formatAtom</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Vamos a discutir los casos en orden.</p>
<dl>
<dt>Slices y arreglos</dt>
<dd>
<p>La logica es la misma para ambos. El metodo <code>Len</code> devuelve el numero de elementos de un valor slice o arreglo, y <code>Index(i)</code> recupera el elemento en el indice <code>i</code>, tambien como un <code>reflect.Value</code>; entra en panico si <code>i</code> esta fuera de limites. Esto es analoga al <code>len(a)</code> nativo y a la operacion en secuencias <code>a[i]</code>. La funcion <code>display</code> se invoca a si misma recursivamente en cada elemento de la secuencia, añadiendo la notacion subindice <q><code>[i]</code></q> a la trayectoria.</p>
<p>Aunque <code>reflect.Value</code> tiene muchos metodos, solo unos pocos son seguros para llamar a cualquier valor dado. Por ejemplo, el metodo <code>Index</code> puede ser llamado en valores de tipo <code>Slice</code>, <code>Array</code> o <code>String</code>, pero entra en panico para cualquier otro tipo.</p>
</dd>
<dt>Estructuras</dt>
<dd>
<p>El metodo <code>NumField</code> informa el numero de campos en la estructura, y <code>Field(i)</code> devuelve el valor del campo <code>i</code> como un <code>reflect.Value</code>. La lista de campos incluye los promocionados desde campos anonimos. Para añadir la notacion de seleccion de campo <q><code>.f</code></q> a la ruta, debemos obtener el <code>reflect.Type</code> de la estructura y tener acceso al nombre de su campo <code>i</code>.</p>
</dd>
<dt>Mapas</dt>
<dd>
<p>El metodo <code>MapKeys</code> devuelve un slice de <code>reflect.Values</code>, uno por cada clave del mapa. Como de costumbre cuando se itera sobre un mapa, el orden no esta definido. <code>MapIndex(key)</code> devuelve el valor correspondiente a <code>key</code>. Añadimos la notacion de subindice <q><code>[key]</code></q> a la ruta. (Estamos cortando una esquina aqui el tipo de una clave del mapa no se limita a los tipos que <code>formatAtom</code> maneja mejor; arreglos, estructuras e interfaces tambien pueden ser claves validas de mapa. Extender este caso para imprimir la clave en su totalidad es el Ejercicio. 12.1.)</p>
</dd>
<dt>Punteros</dt>
<dd>
<p>El metodo <code>Elem</code> devuelve la variable a la que apunta un puntero, de nuevo como un <code>reflect.Value</code>. Esta operacion seria segura incluso si el valor del puntero es <code>nil</code>, en cuyo caso el resultado tendria tipo <code>Invalid</code>, pero utilizamos <code>IsNil</code> para detectar punteros nulos de manera explicita por lo que podemos imprimir un mensaje mas apropiado. Prefijamos el camino con un <q><code>*</code></q> y un parentesis para evitar la ambigüedad.</p>
</dd>
</dl>
<ul>
<li>
<p>Interfaces : Una vez mas, utilizamos <code>IsNil</code> para probar si la interfaz es nil, y si no, recuperamos su valor dinamico utilizando <code>v.Elem()) e imprimimos su tipo y valor.</code></p>
</li>
</ul>
<p>Ahora que nuestro funcion <code>Display</code> esta completa, vamos a ponerla a trabajar. El tipo <code>Movie</code> a continuacion es una ligera variacion del presente en la <a href="#Seccion-4.5" >Seccion 4.5</a>:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Movie</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Title</span><span class="p">,</span> <span class="nx">Subtitle</span> <span class="kt">string</span>
  <span class="nx">Year</span>            <span class="kt">int</span>
  <span class="nx">Color</span>           <span class="kt">bool</span>
  <span class="nx">Actor</span>           <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
  <span class="nx">Oscars</span>          <span class="p">[]</span><span class="kt">string</span>
  <span class="nx">Sequel</span>          <span class="o">*</span><span class="kt">string</span>
<span class="p">}</span>
</pre></div>
<p>Vamos a declarar un valor de este tipo y ver lo que hace <code>Display</code> con el:</p>
<div class="highlight"><pre><span></span><span class="nx">strangelove</span> <span class="o">:=</span> <span class="nx">Movie</span><span class="p">{</span>
  <span class="nx">Title</span><span class="p">:</span>    <span class="s">&quot;Dr. Strangelove&quot;</span><span class="p">,</span>
  <span class="nx">Subtitle</span><span class="p">:</span> <span class="s">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span><span class="p">,</span>
  <span class="nx">Year</span><span class="p">:</span>     <span class="mi">1964</span><span class="p">,</span>
  <span class="nx">Color</span><span class="p">:</span>    <span class="kc">false</span><span class="p">,</span>
  <span class="nx">Actor</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&quot;Dr. Strangelove&quot;</span><span class="p">:</span>            <span class="s">&quot;Peter Sellers&quot;</span><span class="p">,</span>
    <span class="s">&quot;Grp. Capt. Lionel Mandrake&quot;</span><span class="p">:</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">,</span>
    <span class="s">&quot;Pres. Merkin Muffley&quot;</span><span class="p">:</span>       <span class="s">&quot;Peter Sellers&quot;</span><span class="p">,</span>
    <span class="s">&quot;Gen. Buck Turgidson&quot;</span><span class="p">:</span>        <span class="s">&quot;George C. Scott&quot;</span><span class="p">,</span>
    <span class="s">&quot;Brig. Gen. Jack D. Ripper&quot;</span><span class="p">:</span>  <span class="s">&quot;Sterling Hayden&quot;</span><span class="p">,</span>
    <span class="s">`Maj. T.J. &quot;King&quot; Kong`</span><span class="p">:</span>      <span class="s">&quot;Slim Pickens&quot;</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="nx">Oscars</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&quot;Best Actor (Nomin.)&quot;</span><span class="p">,</span>
    <span class="s">&quot;Best Adapted Screenplay (Nomin.)&quot;</span><span class="p">,</span>
    <span class="s">&quot;Best Director (Nomin.)&quot;</span><span class="p">,</span>
    <span class="s">&quot;Best Picture (Nomin.)&quot;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">}</span>
</pre></div>
<p>La llamada <code>Display(&quot;strangelove&quot;, strangelove)</code> imprime:</p>
<pre class="pre" >Display strangelove (display.Movie):
strangelove.Title = &quot;Dr. Strangelove&quot;
strangelove.Subtitle = &quot;How I Learned to Stop Worrying and Love the Bomb&quot;
strangelove.Year = 1964
strangelove.Color = false
strangelove.Actor[&quot;Gen. Buck Turgidson&quot;] = &quot;George C. Scott&quot;
strangelove.Actor[&quot;Brig. Gen. Jack D. Ripper&quot;] = &quot;Sterling Hayden&quot;
strangelove.Actor[&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;] = &quot;Slim Pickens&quot;
strangelove.Actor[&quot;Dr. Strangelove&quot;] = &quot;Peter Sellers&quot;
strangelove.Actor[&quot;Grp. Capt. Lionel Mandrake&quot;] = &quot;Peter Sellers&quot;
strangelove.Actor[&quot;Pres. Merkin Muffley&quot;] = &quot;Peter Sellers&quot;
strangelove.Oscars[0] = &quot;Best Actor (Nomin.)&quot;
strangelove.Oscars[1] = &quot;Best Adapted Screenplay (Nomin.)&quot;
strangelove.Oscars[2] = &quot;Best Director (Nomin.)&quot;
strangelove.Oscars[3] = &quot;Best Picture (Nomin.)&quot;
strangelove.Sequel = nil</pre>
<p>Podemos utilizar <code>Display</code> para mostrar el funcionamiento interno de los tipos de librerias, como <code>*os.File</code>:</p>
<pre class="pre" >Display(&quot;os.Stderr&quot;, os.Stderr)
// Output:
// Display os.Stderr (*os.File):
// (*(*os.Stderr).file).fd = 2
// (*(*os.Stderr).file).name = &quot;/dev/stderr&quot;
// (*(*os.Stderr).file).nepipe = 0</pre>
<p>Observe que incluso los campos no exportados son visibles para la reflexion. Tenga en cuenta que la salida particular de este ejemplo puede variar entre plataformas y puede cambiar con el tiempo a medida que las librerias evolucionan. (Esos campos son privados por una razon!) Incluso podemos aplicar <code>Display</code> a un <code>reflect.Value</code> y verlo atravesar la representacion interna del descriptor de tipo de <code>*os.File</code>. La salida de la llamada <code>Display(&quot;rV&quot;, reflect.ValueOf(os.Stderr))</code> se muestra a continuacion, aunque, por supuesto, su experiencia puede variar:</p>
<pre class="pre" >Display rV (reflect.Value):
(*rV.typ).size = 8
(*rV.typ).hash = 871609668
(*rV.typ).align = 8
(*rV.typ).fieldAlign = 8
(*rV.typ).kind = 22
(*(*rV.typ).string) = &quot;*os.File&quot;
(*(*(*rV.typ).uncommonType).methods[0].name) = &quot;Chdir&quot;
(*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string) = &quot;func() error&quot;
(*(*(*(*rV.typ).uncommonType).methods[0].typ).string) = &quot;func(*os.File) error&quot;
...</pre>
<p>Observe la diferencia entre estos dos ejemplos:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="mi">3</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="c1">// Output:</span>
<span class="c1">// Display i (int):</span>
<span class="c1">// i = 3</span>

<span class="nx">Display</span><span class="p">(</span><span class="s">&quot;&amp;i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
<span class="c1">// Output:</span>
<span class="c1">// Display &amp;i (*interface {}):</span>
<span class="c1">// (*&amp;i).type = int</span>
<span class="c1">// (*&amp;i).value = 3</span>
</pre></div>
<p>En el primer ejemplo, <code>Display</code> llama a <code>reflect.ValueOf(i)</code>, que devuelve un valor de tipo <code>Int</code>. Como mencionamos en la <a href="#Seccion-12.2" >Seccion 12.2</a>, <code>reflect.ValueOf</code> siempre devuelve un valor de un tipo concreto ya que extrae el contenido de un valor interfaz.</p>
<p>En el segundo ejemplo, <code>Display</code> llama a <code>reflect.ValueOf(&amp;i)</code>, que devuelve un puntero a <code>i</code>, de tipo <code>Ptr</code>. El caso del switch para <code>Ptr</code> llama a <code>Elem</code> en este valor, que devuelve un valor que representa la <em>variable</em> <code>i</code> en si, del tipo <code>Interface</code>. Un <code>Value</code> obtenido indirectamente, como este, puede representar cualquier valor en absoluto, incluyendo interfaces. La funcion <code>display</code> se llama a si misma de forma recursiva y esta vez, imprime componentes separados para el tipo y valor dinamico de la interfaz.</p>
<p>Tal como se aplica actualmente, <code>Display</code> nunca terminara si encuentra un ciclo en el grafico del objeto, como esta lista enlazada que se come su propia cola:</p>
<div class="highlight"><pre><span></span><span class="c1">// une estructura que apunta a si misma</span>
<span class="kd">type</span> <span class="nx">Cycle</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">Value</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">Tail</span> <span class="o">*</span><span class="nx">Cycle</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Cycle</span>
<span class="nx">c</span> <span class="p">=</span> <span class="nx">Cycle</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">}</span>
<span class="nx">Display</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</pre></div>
<p><code>Display</code> imprime esta expansion cada vez mayor:</p>
<div class="highlight"><pre><span></span><span class="nx">Display</span> <span class="nx">c</span> <span class="p">(</span><span class="nx">display</span><span class="p">.</span><span class="nx">Cycle</span><span class="p">):</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">.</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Tail</span><span class="p">).</span><span class="nx">Value</span> <span class="p">=</span> <span class="mi">42</span>
<span class="o">...</span><span class="nx">ad</span> <span class="nx">infinitum</span><span class="o">...</span>
</pre></div>
<p>Muchos programas Go contienen al menos algunos datos ciclicos. Hacer <code>Display</code> robusto frente a estos ciclos es complicado, requiriendo contabilidad adicional para registrar el conjunto de referencias que se han seguido hasta ahora; Es costoso tambien. Una solucion general requiere la caracteristicas <code>unsafe</code> del lenguaje, como veremos en la <a href="#Seccion-13.3" >Seccion 13.3</a>.</p>
<p>Los ciclos plantean un problema menor para <code>fmt.Sprint</code>, ya que rara vez se intenta imprimir la estructura completa. Por ejemplo, cuando encuentra un puntero, rompe la recursion imprimiendo el valor numerico del puntero. Puede quedar atrapado tratando de imprimir un slice o un mapa que se contiene como un elemento, pero estos casos raros no garantizan el considerable problema adicional de la manipulacion de ciclos.</p>
<p><b>Ejercicio 12.1</b>: Ampliar <code>Display</code> para que pueda mostrar mapas cuyas claves son estructuras o matrices.</p>
<p><b>Ejercicio 12.2</b>: Hacer <code>display</code> seguro de usar en estructuras de datos ciclicas limitando el numero de pasos necesarios antes de abandonar la recursividad. (En la <a href="#Seccion-13.3" >Seccion 13.3</a>, veremos otra forma de detectar ciclos).</p>
</div>
<h3 id="Seccion-12.4" >Ejemplo: Codificacion de Expressions-S</h3>
<div class="hBody-3" >
<p><code>Display</code> es una rutina de depuracion para la visualizacion de datos estructurados, pero no esta muy lejos de ser capaz de codificar u <em>ordenar</em> objetos Go arbitrarios como mensajes en una notacion portatil adecuada para la comunicacion entre procesos.</p>
<p>Como vimos en la <a href="#Seccion-4.5" >Seccion 4.5</a>, la libreria estandar de Go es compatible con una variedad de formatos, incluyendo JSON, XML y ASN.1. Otra indicacion de que todavia es ampliamente utilizado <em>expresiones-S</em>, la sintaxis de Lisp. A diferencia de las otras notaciones, las expresiones-S no son compatibles con la libreria estandar de Go, no menos porque no tienen una definicion universalmente aceptada, a pesar de varios intentos de estandarizacion y la existencia de muchas implementaciones.</p>
<p>En esta seccion, definiremos un paquete que codifica objetos Go arbitrarios usando una notacion de expresiones-S que admita las siguientes construcciones:</p>
<table>
<tbody>
<tr><td><code>42</code></td><td>entero</td></tr>
<tr><td><code>&quot;hello&quot;</code></td><td>cadena (con notacion en estilo Go)</td></tr>
<tr><td><code>foo</code></td><td>symbolo (un nombre sin cita)</td></tr>
<tr><td><code>(1 2 3)</code></td><td>lista (zero o mas elementos entre parentesis)</td></tr>
</tbody>
</table>
<p>Los booleanos tradicionalmente se codifican utilizando el simbolo <code>t</code> para la verdadero, y la lista vacia <code>()</code> o el simbolo <code>nil</code> para falso, pero por simplicidad, nuestra implementacion los ignora. Tambien ignora canales y funciones, ya que su estado es opaco a la reflexion. Y no hace caso de numeros reales y complejos de punto flotante e interfaces. Agregar soporte para ellos es el <a href="#Ejercicio-12.3" >Ejercicio 12.3</a>.</p>
<p>Vamos a codificar los tipos de Go usando expresiones-S como sigue. Los enteros y las cadenas se codifican de la manera obvia. Los valores Nil se codifican como el simbolo <code>nil</code>. Los arrays y slices se codifican utilizando la notacion de lista.</p>
<p>Las estructuras se codifican como una lista de campos enlazados, siendo cada enlace de campo una lista de dos elementos cuyo primer elemento (un simbolo) es el nombre del campo y cuyo segundo elemento es el valor del campo. Los mapas tambien se codifican como una lista de pares, siendo cada par la clave y el valor de una entrada de mapa. Tradicionalmente, las expresiones-S representan listas de pares clave/valor utilizando una sola celula <em>cons</em> <code>(key . value)</code> para cada par, en lugar de una lista de dos elementos, pero para simplificar la decodificacion ignoraremos la notacion de lista punteada.</p>
<p>La codificacion se realiza por una sola funcion recursiva, <code>encode</code>, que se muestra a continuacion. Su estructura es esencialmente la misma que la de <code>Display</code> en la seccion anterior:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/sexpr/encode.go" >gopl.io/ch12/sexpr</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Invalid</span><span class="p">:</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;nil&quot;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Uint</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;%q&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Elem</span><span class="p">())</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span> <span class="c1">// (value ...)</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span> <span class="c1">// ((name value) ...)</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="s">&quot;(%s &quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span> <span class="c1">// ((key value) ...)</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapKeys</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">MapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
      <span class="p">}</span>
      <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteByte</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>

  <span class="k">default</span><span class="p">:</span> <span class="c1">// float, complex, bool, chan, func, interface</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unsupported type: %s&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>Marshal</code> envuelve el codificador en una API similar a los de otros paquetes <code>encoding/...</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Marshal codifica un valor Go en forma de expresion-S.</span>
<span class="kd">func</span> <span class="nx">Marshal</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Aqui esta la salida que <code>Marshal</code> aplica a la variable <code>strangelove</code> de la <a href="#Seccion-12.3" >Seccion 12.3</a>:</p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="nv">Title</span> <span class="s">&quot;Dr. Strangelove&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nv">Subtitle</span> <span class="s">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nv">Year</span> <span class="mi">1964</span><span class="p">)</span> <span class="p">(</span><span class="nv">Actor</span> <span class="p">((</span><span class="s">&quot;Grp. Capt. Lionel Mandrake&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;Pres. Merkin Muffley&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;Gen. Buck Turgidson&quot;</span> <span class="s">&quot;George C. Scott&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;Brig. Gen. Jack D. Ripper&quot;</span> <span class="s">&quot;Sterling Hayden&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;</span> <span class="s">&quot;Slim Pickens&quot;</span><span class="p">)</span> <span class="p">(</span><span class="s">&quot;Dr. Strangelove&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)))</span> <span class="p">(</span><span class="nv">Oscars</span> <span class="p">(</span><span class="s">&quot;Best Actor (Nomin.)&quot;</span> <span class="s">&quot;Best Adapted Screenplay (Nomin.)&quot;</span> <span class="s">&quot;Best Director (Nomin.)&quot;</span> <span class="s">&quot;Best Picture (Nomin.)&quot;</span><span class="p">))</span> <span class="p">(</span><span class="nv">Sequel</span> <span class="no">nil</span><span class="p">))</span>
</pre></div>
<p>Toda la salida aparece en una linea larga con espacios minimos, por lo que es dificil de leer. Esta es la misma salida formateada manualmente de acuerdo con las convenciones de expresion-S. Escribir una bonita impresora para las expresiones-S se deja como un ejercicio (desafiante); la descarga de <code>gopl.io</code> incluye una version simple.</p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="nv">Title</span> <span class="s">&quot;Dr. Strangelove&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Subtitle</span> <span class="s">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Year</span> <span class="mi">1964</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">Actor</span> <span class="p">((</span><span class="s">&quot;Grp. Capt. Lionel Mandrake&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&quot;Pres. Merkin Muffley&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&quot;Gen. Buck Turgidson&quot;</span> <span class="s">&quot;George C. Scott&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&quot;Brig. Gen. Jack D. Ripper&quot;</span> <span class="s">&quot;Sterling Hayden&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;</span> <span class="s">&quot;Slim Pickens&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="s">&quot;Dr. Strangelove&quot;</span> <span class="s">&quot;Peter Sellers&quot;</span><span class="p">)))</span>
 <span class="p">(</span><span class="nv">Oscars</span> <span class="p">(</span><span class="s">&quot;Best Actor (Nomin.)&quot;</span>
          <span class="s">&quot;Best Adapted Screenplay (Nomin.)&quot;</span>
          <span class="s">&quot;Best Director (Nomin.)&quot;</span>
          <span class="s">&quot;Best Picture (Nomin.)&quot;</span><span class="p">))</span>
 <span class="p">(</span><span class="nv">Sequel</span> <span class="no">nil</span><span class="p">))</span>
</pre></div>
<p>Al igual las funciones <code>fmt.Print</code>, <code>json.Marshal</code> y <code>Display</code>, <code>sexpr.Marshal</code> entrara en un bucle infinito si es llamado con los datos ciclicos.</p>
<p>En la <a href="#Seccion-12.6" >Seccion 12.6</a>, esbozaremos la implementacion de la funcion de decodificacion de expreciones-S correspondiente, pero antes de llegar alli, primero debemos entender como se puede usar la reflexion para actualizar las variables del programa.</p>
<p><b>Ejercicio 12.3</b>: Implementar los casos faltantes de la funcion <code>encode</code>. Codifique booleanos como <code>t</code> y <code>nil</code>, numeros de punto flotante utilizando la notacion de Go, y los numeros complejos como <span class="math" >1+2i</span> como <code>#C(1.0 2.0)</code>. Las interfaces se pueden codificar como un par de nombre de tipo y un valor, por ejemplo <code>(&quot;[</code>int&quot; (1 2 3))], pero cuidado que esta notacion es ambigua: el metodo <code>reflect.Type.String</code> puede devolver la misma cadena para diferentes tipos.</p>
<p><b>Ejercicio 12.4</b>: Modifique <code>encode</code> para imprimir expresiones-S con el estilo mostrado anteriormente.</p>
<p><b>Ejercicio 12.5</b>: Adapte <code>encode</code> para producir JSON en lugar de expresiones-S. Pruebe su codificador utilizando el descodificador estandar, <code>json.Unmarshal</code>.</p>
<p><b>Ejercicio 12.6</b>: Adapte <code>encode</code> para que a manera de optimizacion, no codifique un campo cuyo valor es el valor cero de su tipo.</p>
<p><b>Ejercicio 12.7</b>: Crear un API de streaming para el decodificador de expresiones-S, siguiendo el estilo de <code>json.Decoder</code> (<a href="#Seccion-4.5" >§4.5</a>).</p>
</div>
<h3 id="Seccion-12.5" >Configurar Variables con <code>reflect.Value</code></h3>
<div class="hBody-3" >
<p>Hasta el momento, la reflexion solo ha <em>interpretado</em> los valores en nuestro programa de diversas maneras. El punto de esta seccion, es <code>cambiarlos</code>.</p>
<p>Recordemos que algunas expresiones van como <code>x</code>, <code>x.f[1]</code>, y <code>*p</code> denotan variables, pero otras como <code>x + 1</code> y <code>f(2)</code> no. Una variable es una ubicacion de almacenamiento <em>direccionable</em> que contiene un valor, y su valor puede ser actualizado a traves de esa direccion.</p>
<p>Una distincion similar se aplica a <code>reflect.Values</code>. Algunos son direccionables; Otros no lo son. Considere las siguientes declaraciones:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>                     <span class="c1">// valor   tipo   variable?</span>
<span class="nx">a</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>    <span class="c1">// 2       int    no</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>    <span class="c1">// 2       int    no</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>   <span class="c1">// &amp;x      *int   no</span>
<span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Elem</span><span class="p">()</span>              <span class="c1">// 2       int    si (x)</span>
</pre></div>
<p>El valor dentro de <code>a</code> no es direccionable. Se trata simplemente de una copia del entero 2. Lo mismo es cierto para <code>b</code>. El valor dentro de <code>c</code> tambien es no direccionable, siendo una copia del valor de puntero <code>&amp;x</code>. De hecho, <code>reflect.Value</code> devuelto por <code>reflect.ValueOf(x)</code> no es direccionable. Pero <code>d</code>, derivado de <code>c</code> mediante la desreferenciacion del puntero un su interior, se refiere a una variable y es, por tanto direccionable. Podemos utilizar este enfoque, llamando a <code>reflect.ValueOf(&amp;x).Elem()</code>, para obtener un <code>Value</code> direccionable de cualquier variable <code>x</code>.</p>
<p>Podemos pregruntar a <code>reflect.Value</code> si es direccionable a traves de su metodo <code>CanAddr</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">())</span> <span class="c1">// &quot;true&quot;</span>
</pre></div>
<p>Obtenemos un <code>reflect.Value</code> direccionable siempre indirectamente atravez de un puntero, incluso si partimos de un <code>Value</code> no-direccionable . Todas las reglas habituales de direccionabilidad tienen analogos para la reflexion. Por ejemplo, ya que la expresion de indexacion de un slice <code>e[i]</code> sigue implicitamente un puntero, es direccionable incluso si la expresion <code>e</code> no lo es. Por analogia, <code>reflect.ValueOf(e).Index(i)</code> se refiere a una variable, y por tanto es direccionable incluso si <code>reflect.ValueOf(e)</code> no lo es.</p>
<p>Para recuperar la variable de un <code>reflect.Value</code> direccionable requiere tres pasos. En primer lugar, llamamos a <code>Addr()</code>, que devuelve un valor que contiene un puntero a la variable. Despues, llamamos a <code>Interface()</code> en este <code>Value</code>, que devuelve un valor <code>interface{}</code> que contiene el puntero. Finalmente, si sabemos el tipo de la variable, podemos usar una asercion de tipo para recuperar el contenido de la interfaz como un puntero comun. A continuacion, podemos actualizar la variable a traves del puntero:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>    <span class="c1">// d referencia a la variable x</span>
<span class="nx">px</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Addr</span><span class="p">().</span><span class="nx">Interface</span><span class="p">().(</span><span class="o">*</span><span class="kt">int</span><span class="p">)</span>  <span class="c1">// px := &amp;x</span>
<span class="o">*</span><span class="nx">px</span> <span class="p">=</span> <span class="mi">3</span>                            <span class="c1">// x = 3</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>                     <span class="c1">// &quot;3&quot;</span>
</pre></div>
<p>O bien, podemos actualizar la variable a la que hace referencia <code>reflect.Value</code> directamente, sin necesidad de utilizar un puntero, llamando al metodo <code>reflect.Value.Set</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">d</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;4&quot;</span>
</pre></div>
<p>Las mismas comprobaciones de asignabilidad que normalmente se realizan por el compilador se realizan en tiempo de ejecucion por los metodos <code>Set</code>. Arriba, la variable y el valor tienen el tipo <code>int</code>, pero si la variable habia sido un <code>int64</code>, el programa entrara en panico, por lo que es crucial asegurarse de que el valor sea asignable al tipo de la variable:</p>
<div class="highlight"><pre><span></span><span class="nx">d</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span> <span class="c1">// panico: int64 no es asignable a int</span>
</pre></div>
<p>Y, por supuesto, llamando a <code>Set</code> sobre un <code>reflect.Value</code> no direccionable tambien entra en panico:</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">2</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// panico: se utiliza Set con un valor no direccionable</span>
</pre></div>
<p>Hay variantes de <code>Set</code> especializadas para ciertos grupos de tipos basicos: <code>SetInt</code>, <code>SetUint</code>, <code>SetString</code>, <code>SetFloat</code>, y demas:</p>
<div class="highlight"><pre><span></span><span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">d</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// &quot;3&quot;</span>
</pre></div>
<p>En algunos aspectos, estos metodos son mas tolerantes. <code>SetInt</code>, por ejemplo, tendra exito siempre y cuando el tipo de la variable sea algun tipo de entero con signo, o incluso un tipo con nombre cuyo tipo subyacente es un entero con signo, y si el valor es demasiado grande sera truncado en silencio para ajustarse. Pero pise con cuidado: llamar a <code>SetInt</code> en un <code>reflect.Value</code> que se refiere a una variable <code>interface{}</code> entrara en panico, aunque <code>Set</code> tendria exito.</p>
<div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="nx">rx</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                     <span class="c1">// OK, x = 2</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>       <span class="c1">// OK, x = 3</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>            <span class="c1">// panic: string no es asignable a int</span>
<span class="nx">rx</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// panic: string no es asignable a int</span>

<span class="kd">var</span> <span class="nx">y</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">ry</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">y</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span>
<span class="nx">ry</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>                     <span class="c1">// panico: SetInt llamada con un Valoe interface</span>
<span class="nx">ry</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>       <span class="c1">// OK, y = int(3)</span>
<span class="nx">ry</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>            <span class="c1">// panico: SetString llamada en un Value interface</span>
<span class="nx">ry</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span> <span class="c1">// OK, y = &quot;hello&quot;</span>
</pre></div>
<p>Cuando aplicamos <code>Display</code> a <code>os.Stdout</code>, encontramos que la reflexion puede leer los valores de los campos no exportados de estructuras que son inaccesibles segun las reglas usuales del lenguaje, como el campo <code>fd int</code> de una estructura <code>os.File</code> en una plataforma Unix. Sin embargo, la reflexion no puede actualizar estos valores:</p>
<div class="highlight"><pre><span></span><span class="nx">stdout</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span> <span class="c1">// *os.Stdout, una variable os.File</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>                  <span class="c1">// &quot;os.File&quot;</span>
<span class="nx">fd</span> <span class="o">:=</span> <span class="nx">stdout</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="s">&quot;fd&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Int</span><span class="p">())</span> <span class="c1">// &quot;1&quot;</span>
<span class="nx">fd</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>          <span class="c1">// panico: capo sin exportar</span>
</pre></div>
<p>Un <code>reflect.Value</code> direccionable registra si se obtuvo al atravesar el campo sin exportar de una estructura y, si es asi, no permite la modificacion. En consecuencia, <code>CanAddr</code> no suele ser la comprobacion correcta a utilizar antes de establecer una variable. El metodo relacionado <code>CanSet</code> informa si un <code>reflect.Value</code> es direccionable <em>y</em> asignable:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">(),</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">CanSet</span><span class="p">())</span> <span class="c1">// &quot;true false&quot;</span>
</pre></div>
</div>
<h3 id="Seccion-12.6" >Ejemplo: Descodificar Expressions-S</h3>
<div class="hBody-3" >
<p>Por cada funcion <code>Marshal</code> proporcionada por los paquetes <code>encoding/...</code> de la libreria estandar, hay una funcion correspondiente <code>Unmarshal</code> que realiza la decodificacion. Por ejemplo, como vimos en la <a href="#Seccion-4.5" >Seccion 4.5</a>, dada un slice de bytes que contiene datos codificados JSON para nuestro tipo <code>Movie</code> (<a href="#Seccion-12.3" >§12.3</a>), podemos decodificarla asi:</p>
<div class="highlight"><pre><span></span><span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">movie</span> <span class="nx">Movie</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">movie</span><span class="p">)</span>
</pre></div>
<p>la funcion <code>Unmarshal</code> utiliza la reflexion para modificar los campos de la variable <code>movie</code> actual, creando nuevos mapas, estructuras, y las slices segun lo determinado por el tipo <code>Movie</code> y el contenido de los datos entrantes.</p>
<p>Ahora vamos a poner en practica una simple funcion <code>Unmarshal</code> para expresiones-S, analoga a la funcion estandar <code>json.Unmarshal</code> utilizada anteriormente, y la inversa de nuestra anterior <code>sexpr.Marshal</code>. Debemos advertirle que una implementacion robusta y general requiere mucho mas codigo del que encajaria comodamente en este ejemplo, que ya es largo, asi que hemos tomado muchos atajos. Soportamos solo un subconjunto limitado de expresiones-S y no manejamos errores con gracia. El codigo pretende ilustrar la reflexion, no el analisis.</p>
<p>El lexer utiliza el tipo <code>Scanner</code> del paquete <code>text/scanner</code> para romper una corriente de entrada en una secuencia de tokens como comentarios, identificadores, literales de cadena, y literales numericos. El metodo del <code>Scan</code> del escaner avanza el escaner y devuelve el tipo del siguiente token, que tiene el tipo <code>rune</code>. La mayoria de los tokens, como <code>'('</code>, consisten en una sola runa, pero el paquete <code>text/scanner</code> representa el tipo de tokens de caracteres multiples <code>Ident</code>, <code>String</code>, e <code>Int</code> usando pequeños valores negativos del tipo <code>rune</code>. Despues de una llamada a <code>Scan</code> que devuelve uno de estos tipos de token, el metodo <code>TokenText</code> de escaner devuelve el texto del token.</p>
<p>Ya que un analizador tipico puede tener que inspeccionar el token actual varias veces, pero el metodo <code>Scan</code> avanza el escaner, envolvemos el escaner en un tipo auxiliar llamado <code>lexer</code> que realiza un seguimiento del token recientemente devuelto por <code>Scan</code>.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/sexpr/decode.go" >gopl.io/ch12/sexpr</a></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">lexer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">scan</span>  <span class="nx">scanner</span><span class="p">.</span><span class="nx">Scanner</span>
  <span class="nx">token</span> <span class="kt">rune</span> <span class="c1">// the current token</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">next</span><span class="p">()</span>        <span class="p">{</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">=</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Scan</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">text</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">TokenText</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="nx">consume</span><span class="p">(</span><span class="nx">want</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span> <span class="c1">// NOTA: No es un ejemplo de buen manejo de errores.</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;got %q, want %q&quot;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">(),</span> <span class="nx">want</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora pasemos al analizador sintactico. Consiste en dos funciones principales. La primera, <code>read</code>, lee la expresion-S que comienza con el token actual y actualiza la variable referida por el <code>reflect.Value v</code> direccionable.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Ident</span><span class="p">:</span>
    <span class="c1">// Los unicos identificadores validos son</span>
    <span class="c1">// &quot;nil&quot; y campos con nombre en estructuras.</span>
    <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;nil&quot;</span> <span class="p">{</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Zero</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Unquote</span><span class="p">(</span><span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">())</span> <span class="c1">// NOTA: ignorando errores</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">())</span> <span class="c1">// NOTA: ignorando errores</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">:</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
    <span class="nx">readList</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// consume &#39;)&#39;</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected token %q&quot;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()))</span>
<span class="p">}</span>
</pre></div>
<p>Nuestras expresiones-S utilizan identificadores para dos propositos distintos, nombres de campo en estructuras y el valor de un puntero <code>nil</code>. La funcion <code>read</code> solo se ocupa de este ultimo caso. Cuando <code>scanner.Ident</code> se encuentra con <q><code>nil</code></q>, establece <code>v</code> a el valor cero de su tipo usando la funcion <code>reflect.Zero</code>. Para cualquier otro identificador, informa de un error. la funcion <code>readList</code>, que veremos en un momento, maneja identificadores utilizados como nombres de campo estructura.</p>
<p>Un token <code>'('</code> indica el comienzo de una lista. La segunda funcion, <code>readList</code>, decodifica una lista en una variable de tipo compuesto–un mapa, estructura, slice, o arreglo–dependiendo el tipo de variable Go que estamos rellenando actualmente. En cada caso, el bucle mantiene el analisis de elementos hasta encontrar el parentesis de cierre correspondiente, <code>')'</code>, detectado por la funcion <code>endList</code>.</p>
<p>La parte interesante es la recursion. El caso mas sencillo es un arreglo. Hasta que se ve el cierre <code>')'</code>, utilizamos <code>Index</code> para obtener la variable para cada elemento del arreglo y hacer una llamada recursiva a <code>read</code> para rellenarla. Como en muchos otros casos de error, si los datos de entrada hacen que el decodificador se indexe mas alla del final del arreglo, el descodificador entrara en panico. Un metodo similar se utiliza para los slices, excepto que debemos crear una nueva variable para cada elemento, rellenarlo y, a continuacion, añadirlo a la porcion.</p>
<p>Los bucles de estructuras y mapas deben analizar una sublista <code>(key value)</code> en cada iteracion. Para las estructuras, la clave es un simbolo que identifica el campo. Analogo al caso de los arreglos, obtenemos la variable existente para el campo struct usando <code>FieldByName</code> y realizamos una llamada recursiva para llenarla. Para los mapas, la clave puede ser de cualquier tipo, y de forma analoga al caso de los slices, creamos una nueva variable, rellenandola de forma recursiva y finalmente insertamos el nuevo par clave/valor en el mapa.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">readList</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">:</span> <span class="c1">// (item ...)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span> <span class="c1">// (item ...)</span>
    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">item</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Append</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">item</span><span class="p">))</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span> <span class="c1">// ((name value) ...)</span>
    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="o">!=</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Ident</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;got token %q, want field name&quot;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()))</span>
      <span class="p">}</span>
      <span class="nx">name</span> <span class="o">:=</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">text</span><span class="p">()</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">FieldByName</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span> <span class="c1">// ((key value) ...)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">MakeMap</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
    <span class="k">for</span> <span class="p">!</span><span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
      <span class="nx">key</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Key</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
      <span class="nx">value</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
      <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
      <span class="nx">v</span><span class="p">.</span><span class="nx">SetMapIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
      <span class="nx">lex</span><span class="p">.</span><span class="nx">consume</span><span class="p">(</span><span class="sc">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="k">default</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;cannot decode list into %v&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">endList</span><span class="p">(</span><span class="nx">lex</span> <span class="o">*</span><span class="nx">lexer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">EOF</span><span class="p">:</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;end of file&quot;</span><span class="p">)</span>
  <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
<p>Finalmente, terminamos el analizador en una funcion exportada <code>Unmarshal</code>, que se muestra a continuacion, que esconde algunas de las asperezas de la aplicacion. Los errores encontrados durante el analisis dan lugar a un panico, por lo que <code>Unmarshal</code> utiliza una llamada diferida para recuperarse del panico (<a href="#Seccion-5.10" >§5.10</a>) y devolvera un mensaje de error.</p>
<div class="highlight"><pre><span></span><span class="c1">// Unmarshal analiza datos de expresiones-S y rellena la variable</span>
<span class="c1">// cuya direccion esta en el puntero out no-nil.</span>
<span class="kd">func</span> <span class="nx">Unmarshal</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">lex</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">lexer</span><span class="p">{</span><span class="nx">scan</span><span class="p">:</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">Scanner</span><span class="p">{</span><span class="nx">Mode</span><span class="p">:</span> <span class="nx">scanner</span><span class="p">.</span><span class="nx">GoTokens</span><span class="p">}}</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Init</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
  <span class="nx">lex</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// obtiene el primer token</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// NOTE: this is not an example of ideal error handling.</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;error at %s: %v&quot;</span><span class="p">,</span> <span class="nx">lex</span><span class="p">.</span><span class="nx">scan</span><span class="p">.</span><span class="nx">Position</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}()</span>
  <span class="nx">read</span><span class="p">(</span><span class="nx">lex</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">out</span><span class="p">).</span><span class="nx">Elem</span><span class="p">())</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Una implementacion de calidad de produccion nunca debe entrar en panico para cualquier entrada y debe informar un error informativo para cada contratiempo, tal vez con un numero de linea o desplazamiento. No obstante, esperamos que este ejemplo transmita una idea de lo que esta sucediendo bajo el capo de paquetes como <code>encoding/json</code>, y como se puede utilizar la reflexion para poblar las estructuras de datos.</p>
<p><b>Ejercicio 12.8</b>: La funcion <code>sexpr.Unmarshal</code>, como <code>json.Marshal</code>, requiere la entrada completa en un slice de bytes antes de que pueda comenzar la decodificacion. Defina un tipo <code>sexpr.Decoder</code> que como <code>json.Decoder</code>, permite que una secuencia de valores sea decodificada desde un <code>io.Reader</code>. Cambiar <code>sexpr.Unmarshal</code> para utilizar este nuevo tipo.</p>
<p><b>Ejercicio 12.9</b>: Escriba una API basada en tokens para decodificar expresiones-S, siguiendo el estilo de <code>xml.Decoder</code> (<a href="#Seccion-7.14" >§7.14</a>). Necesitara cinco tipos de tokens: <code>Symbol</code>, <code>String</code>, <code>Int</code>, <code>StartList</code> y <code>EndList</code>.</p>
<p><b>Ejercicio 12.10</b>: Extienda <code>sexpr.Unmarshal</code> para manejar booleanos, numeros de punto flotante, e interfaces codificadas con su solucion al Ejercicio 12.3. (Sugerencia: para decodificar interfaces, se necesitara una asignacion del nombre de cada tipo soportado a su <code>reflect.Type</code>).</p>
</div>
<h3 id="Seccion-12.7" >Accediendo a Etiquetas de Campo en Estructuras</h3>
<div class="hBody-3" >
<p>En la <a href="#Seccion-4.5" >Seccion 4.5</a> utilizamos <em>etiquetas de campo</em> de estructura para modificar la codificacion de valores JSON de estructuras Go. La etiqueta de campo <code>json</code> nos permite escoger nombres de campos alternativos y suprimir la salida de los campos vacios. En esta seccion, veremos como acceder a las etiquetas de campo mediante la reflexion.</p>
<p>En un servidor web, lo primero que hace la mayoria de las funciones del controlador HTTP es extraer los parametros de la peticion en variables locales. Vamos a definir una funcion de utilidad, <code>params.Unpack</code>, que utiliza etiquetas de campos de estructura para que los manipuladores de la escritura HTTP (<a href="#Seccion-7.7" >§7.7</a>) sean mas convenientes.</p>
<p>En primer lugar, vamos a mostrar como se utiliza. La funcion <code>search</code> a continuacion, es un controlador HTTP. Se define una variable llamada <code>data</code> de un tipo de estructura anonima cuyos campos corresponden a los parametros de la peticion HTTP. Las etiquetas de campo de la estructura especifican los nombres de los parametros, que a menudo son cortos y cripticos, ya que el espacio es precioso en una URL. la funcion <code>Unpack</code> llena la estructura del la solicitud, por lo que los parametros se puede acceder convenientemente y con un tipo apropiado.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/search/main.go" >gopl.io/ch12/search</a></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;gopl.io/ch12/params&quot;</span>

<span class="c1">// search implementa la busqueda del /punto-final de la URL.</span>
<span class="kd">func</span> <span class="nx">search</span><span class="p">(</span><span class="nx">resp</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Labels</span>     <span class="p">[]</span><span class="kt">string</span> <span class="s">`http:&quot;l&quot;`</span>
    <span class="nx">MaxResults</span> <span class="kt">int</span>      <span class="s">`http:&quot;max&quot;`</span>
    <span class="nx">Exact</span>      <span class="kt">bool</span>     <span class="s">`http:&quot;x&quot;`</span>
  <span class="p">}</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">MaxResults</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// establece por defecto</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">Unpack</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">data</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span> <span class="c1">// 400</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// ...resto del manejador...</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">resp</span><span class="p">,</span> <span class="s">&quot;Search: %+v\n&quot;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funcion <code>Unpack</code> de abajo hace tres cosas. En primer lugar, llama <code>req.ParseForm()</code> para analizar la solicitud. Posteriormente, <code>req.Form</code> contiene todos los parametros, independientemente de si el cliente HTTP utiliza el metodo de solicitud GET o POST.</p>
<p>A continuacion, <code>Unpack</code> construye una correlacion del nombre <em>efectivo</em> de cada campo a la variable para ese campo. El nombre efectivo puede diferir del nombre real si el campo tiene una etiqueta. El metodo <code>Field</code> de <code>reflect.Type</code> devuelve un <code>reflect.StructField</code> que proporciona informacion sobre el tipo de cada campo, como su nombre, tipo, y la etiqueta opcional. El campo <code>Tag</code> es un <code>reflect.StructTag</code>, que es un tipo de cadena que proporciona un metodo <code>Get</code> para analizar y extraer la subcadena de una clave particular, como <code>http:&quot;...&quot;</code> en este caso.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/params/params.go" >gopl.io/ch12/params</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Unpack rellena los campos de la estructura apuntada por ptr</span>
<span class="c1">// con los parametros de la solicitud HTTP en req.</span>
<span class="kd">func</span> <span class="nx">Unpack</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">ptr</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ParseForm</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>

  <span class="c1">// Construye un mapa de los campos marcados con un nombre efectivo.</span>
  <span class="nx">fields</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">ptr</span><span class="p">).</span><span class="nx">Elem</span><span class="p">()</span> <span class="c1">// the struct variable</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">fieldInfo</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// un reflect.StructField</span>
    <span class="nx">tag</span> <span class="o">:=</span> <span class="nx">fieldInfo</span><span class="p">.</span><span class="nx">Tag</span>           <span class="c1">// un reflect.StructTag</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="s">&quot;http&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">name</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
      <span class="nx">name</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">fieldInfo</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fields</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Actualiza el campo de estructura para cada parametro en la solicitud</span>
  <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">values</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Form</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">fields</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">f</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">continue</span> <span class="c1">// ingorar los parametros HTTP no reconocidos</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
        <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Type</span><span class="p">().</span><span class="nx">Elem</span><span class="p">()).</span><span class="nx">Elem</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s: %v&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">f</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Append</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">elem</span><span class="p">))</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;%s: %v&quot;</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finalmente, <code>Unpack</code> itera sobre los pares nombre/valor de los parametros HTTP y actualiza los campos de estructura correspondientes. Recuerde que el mismo nombre de parametro puede aparecer mas de una vez. Si esto sucede, y el campo es un slice, entonces todos los valores de ese parametro se acumulan en el slice. De lo contrario, el campo se sobrescribe repetidamente para que solo el ultimo valor tenga algun efecto.</p>
<p>la funcion <code>populate</code> se encarga de establecer un unico campo <code>v</code> (o un unico elemento de un campo de slice) a partir de un valor de parametro. Por ahora, solo admite cadenas, enteros con signo y booleanos. Soportar otros tipos se deja como un ejercicio.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">populate</span><span class="p">(</span><span class="nx">v</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetString</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseInt</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetInt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseBool</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">SetBool</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;unsupported kind %s&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Si añadimos el controlador <code>server</code> a un servidor web, esto podria ser una tipica sesion:</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch12/search
$ ./search <span class="p">&amp;</span>
$ ./fetch <span class="s1">&#39;http://localhost:12345/search&#39;</span>
Search: <span class="o">{</span>Labels:<span class="o">[]</span> MaxResults:10 Exact:false<span class="o">}</span>
$ ./fetch <span class="s1">&#39;http://localhost:12345/search?l=golang&amp;l=programming&#39;</span>
Search: <span class="o">{</span>Labels:<span class="o">[</span>golang programming<span class="o">]</span> MaxResults:10 Exact:false<span class="o">}</span>
$ ./fetch <span class="s1">&#39;http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100&#39;</span>
Search: <span class="o">{</span>Labels:<span class="o">[</span>golang programming<span class="o">]</span> MaxResults:100 Exact:false<span class="o">}</span>
$ ./fetch <span class="s1">&#39;http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming&#39;</span>
Search: <span class="o">{</span>Labels:<span class="o">[</span>golang programming<span class="o">]</span> MaxResults:10 Exact:true<span class="o">}</span>
$ ./fetch <span class="s1">&#39;http://localhost:12345/search?q=hello&amp;x=123&#39;</span>
x: strconv.ParseBool: parsing <span class="s2">&quot;123&quot;</span>: invalid syntax
$ ./fetch <span class="s1">&#39;http://localhost:12345/search?q=hello&amp;max=lots&#39;</span>
max: strconv.ParseInt: parsing <span class="s2">&quot;lots&quot;</span>: invalid syntax
</pre></div>
<p><b>Ejercicio 12.11</b>: Escribir la funcion correspondiente <code>Pack</code>. Dado un valor de estructura, <code>Pack</code> debe devolver una direccion URL que incorpora los valores de los parametros de la estructura.</p>
<p><b>Ejercicio 12.12</b>: Extender la notacion de etiqueta de campo para expresar requisitos de validez de parametros. Por ejemplo, es posible que una cadena tenga que ser una direccion de correo electronico valida o un numero de tarjeta de credito, y un numero entero puede tener que ser un codigo postal valido de los Estados Unidos. Modifique <code>Unpack</code> para comprobar estos requisitos.</p>
<p><b>Ejercicio 12.13</b>: Modificar el codificador (<a href="#Seccion-12.4" >§12.4</a>) y decodificador (<a href="#Seccion-12.6" >§12.6</a>) de expresiones-S para que cumplan la etiqueta de campo <code>sexpr:&quot;...&quot;</code> de una manera similar a <code>encoding/json</code> (<a href="#Seccion-4.5" >§4.5</a>).</p>
</div>
<h3 id="Seccion-12.8" >Visualizando los Motodos de Type</h3>
<div class="hBody-3" >
<p>Nuestro ultimo ejemplo de reflexion utiliza <code>reflect.Type</code> para imprimir el tipo de un valor arbitrario y enumerar sus metodos:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch12/methods/methods.go" >gopl.io/ch12/methods</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Print imprime el conjunto de metodos del valor x.</span>
<span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
  <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="nx">t</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;type %s\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">NumMethod</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">methType</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Type</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;func (%s) %s%s\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">,</span>
      <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimPrefix</span><span class="p">(</span><span class="nx">methType</span><span class="p">.</span><span class="nx">String</span><span class="p">(),</span> <span class="s">&quot;func&quot;</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ambos <code>reflect.Type</code> y <code>reflect.Value</code> tienen un metodo llamado <code>Method</code>. Cada llamada <code>t.Method(i)</code> devuelve una instancia de <code>reflect.Method</code>, un tipo struct que describe el nombre y tipo de un unico metodo. Cada llamada <code>v.Method(i)</code> devuelve un <code>reflect.Value</code> que representa un valor metodo (<a href="#Seccion-6.4" >§6.4</a>), es decir, un metodo vinculado a su receptor. Utilizando el metodo <code>reflect.Value.Call</code> (que no tenemos espacio para mostrar aqui), es posible llamar a <code>Values</code> de tipo <code>Func</code> como este, pero este programa solo necesita su <code>Type</code>.</p>
<p>Estos son los metodos que pertenecen a dos tipos, <code>time.Duration</code> y <code>*strings.Replacer</code>:</p>
<div class="highlight"><pre><span></span><span class="nx">methods</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>
<span class="c1">// Output:</span>
<span class="c1">// type time.Duration</span>
<span class="c1">// func (time.Duration) Hours() float64</span>
<span class="c1">// func (time.Duration) Minutes() float64</span>
<span class="c1">// func (time.Duration) Nanoseconds() int64</span>
<span class="c1">// func (time.Duration) Seconds() float64</span>
<span class="c1">// func (time.Duration) String() string</span>

<span class="nx">methods</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Replacer</span><span class="p">))</span>
<span class="c1">// Output:</span>
<span class="c1">// type *strings.Replacer</span>
<span class="c1">// func (*strings.Replacer) Replace(string) string</span>
<span class="c1">// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)</span>
</pre></div>
</div>
<h3 id="Seccion-12.9" >Una Palabra de Precaucion</h3>
<div class="hBody-3" >
<p>Hay mucho mas sobre la API de reflexion que el espacio que tenemos para mostror, pero los ejemplos anteriores dan una idea de lo que es posible. La reflexion es una herramienta poderosa y expresiva, pero debe ser usada con cuidado, por tres razones.</p>
<p>La primera razon es que el codigo basado en reflexion puede ser fragil. Para cada error que podria hacer que un compilador informe un error de tipo, hay una forma correspondiente de usar incorrectamente la reflexion, pero mientras que el compilador informa del error en el tiempo de construccion, un error de reflexion se informa durante la ejecucion como un panico, posiblemente mucho despues heber escrito el programa o incluso mucho despues de que ha comenzado su ejecucion.</p>
<p>Si la funcion <code>readList</code> (<a href="#Seccion-12.6" >§12.6</a>), por ejemplo, debe leer una cadena de la entrada al rellenar una variable de tipo <code>int</code>, la llamada a <code>reflect.Value.SetString</code> entrara en panico. La mayoria de los programas que utilizan la reflexion tienen riesgos similares, y se requiere mucho cuidado para realizar un seguimiento del tipo, capacidad de direccionamiento, y asignabilidad de cada <code>reflect.Value</code>.</p>
<p>La mejor manera de evitar esta fragilidad es asegurar que el uso de la reflexion esta totalmente encapsulado dentro de su paquete y, si es posible, evitar <code>reflect.Value</code> en favor de tipos especificos en la API de su paquete, para restringir las entradas a valores legales. Si esto no es posible, realice comprobaciones dinamicas adicionales antes de cada operacion riesgosa. A modo de ejemplo en la libreria estandar, cuando <code>fmt.Printf</code> aplica un verbo a un operando inadecuado, no entra misteriosamente en panico, por que imprime un mensaje de error informativo. El programa aun tiene un error, pero es mas facil de diagnosticar.</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %s\n&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span> <span class="c1">// &quot;%!d(string=hello) %!s(int=42)&quot;</span>
</pre></div>
<p>La reflexion tambien reduce la seguridad y la precision de las herramientas automatizadas de refactorizacion y analisis, ya que no pueden determinar o confiar en la informacion de tipo.</p>
<p>La segunda razon para evitar la reflexion es que como los tipos sirven como una forma de documentacion y las operaciones de reflexion no pueden estar sujetas a la verificacion de tipo estatico, el codigo altamente reflexivo es a menudo dificil de entender. Siempre documente cuidadosamente los tipos esperados y otros invariantes de las funciones que aceptan una <code>interface{}</code> o <code>reflect.Value</code>.</p>
<p>La tercera razon es que las funciones basadas en la reflexion pueden ser de uno o dos ordenes de magnitud mas lentas que el codigo especializado para un tipo particular. En un programa tipico, la mayoria de las funciones no son relevantes para el rendimiento general, por lo que es bueno usar la reflexion cuando haga mas claro el programa. Las pruebas son particularmente adecuadas para la reflexion ya que la mayoria de las pruebas utilizan conjuntos de datos pequeños. Pero para las funciones en rutas criticas, es mejor evitar la reflexion.</p>
</div>
<h2 id="Capitulo-13" >Programacion de Bajo Nivel</h2>
<div class="hBody-2" >
<p>El diseño de Go garantiza una serie de propiedades de seguridad que limitan las formas en que un programa Go puede <q>ir mal</q>. Durante la compilacion, la comprobacion de tipo detecta la mayoria de los intentos de aplicar una operacion a un valor inadecuado para su tipo, por ejemplo, restando una cadena de otra. Las estrictas reglas para las conversiones de tipos impiden el acceso directo a los tipos nativos como cadenas, mapas, slices y canales.</p>
<p>Para errores que no se pueden detectar de forma estatica, como accesos a un arreglo fuera de limites o desreferencias de puntero nulo, las comprobaciones dinamicas aseguran que el programa termina inmediatamente con un error informativo siempre que se produce una operacion prohibida. La gestion automatica de memoria (recoleccion de basura) elimina errores de <q>uso posterior</q>, asi como la mayoria de las perdidas de memoria.</p>
<p>Muchos detalles de la implementacion son inaccesibles para los programas de Go. No hay manera de descubrir el diseño de memoria de un tipo agregado como una estructura, o el codigo maquina para una funcion, o la identidad del hilo del sistema operativo en el que se esta ejecutando la actual gorutina. De hecho, el planificador de Go mueve libremente las gorutas de un hilo a otro. Un puntero identifica una variable sin revelar la direccion numerica de la variable. Las direcciones pueden cambiar a medida que el recolector de basura mueve las variables; Los punteros se actualizan de forma transparente.</p>
<p>Juntas, estas caracteristicas hacen que los programas de Go, especialmente los que fallan, sean mas predecibles y menos misteriosos que los programas en C, la quienta escencia de los lenguajes de bajo nivel. Al ocultar los detalles subyacentes, tambien hace que los programas Go sean altamente portatiles, ya que la semantica del lenguaje es en gran medida independiente de cualquier compilador, sistema operativo o arquitectura de la CPU en particular. (No es totalmente independiente: algunos detalles se filtran, como el tamaño de la palabra del procesador, el orden de evaluacion de ciertas expresiones y el conjunto de restricciones de implementacion impuestas por el compilador).</p>
<p>Ocasionalmente, podemos optar por renunciar a algunas de estas garantias utiles para lograr el maximo rendimiento posible, para interoperar con librerias escritas en otros lenguajes o para implementar una funcion que no puede expresarse en Go puro.</p>
<p>En este capitulo, vamos a ver como el paquete <code>unsafe</code> nos permite saltar las reglas habituales, y como utilizar la herramienta <code class="command" >cgo</code> para crear enlaces Go para librerias de C y llamadas al sistema operativo.</p>
<p>Los enfoques descritos en este capitulo no deben utilizarse frivolamente. Sin la atencion cuidadosa a los detalles, pueden causar el tipo de fracasos impredecibles, inescrutables, no locales con los cuales los programadores de C son infelizmente familiarizados. El uso de <code>unsafe</code> tambien anula la garantia de la compatibilidad de Go con versiones futuras, ya que, ya sea intencional o no, es facil depender de detalles de implementacion no especificados que pueden cambiar de forma inesperada.</p>
<p>El paquete <code>unsafe</code> es bastante magico. Aunque parece ser un paquete regular y se importa de la manera habitual, es realmente implementado por el compilador. Proporciona acceso a una serie de caracteristicas nativas de lenguaje que normalmente no estan disponibles porque exponen detalles del diseño de memoria de Go. La presentacion de estas caracteristicas como un paquete por separado hace que las raras ocasiones en que se necesita mas conspicuo. Ademas, algunos entornos pueden restringir el uso del paquete <code>unsafe</code> por razones de seguridad.</p>
<p>El paquete <code>unsafe</code> se utiliza ampliamente en paquetes de bajo nivel como <code>runtime</code>, <code>os</code>, <code>syscall</code>, y <code>net</code> que interactuan con el sistema operativo, pero casi nunca es necesario en programas ordinarios.</p>
</div>
<h3 id="Seccion-13.1" ><code>unsafe.Sizeof</code>, <code>Alignof</code>, y <code>Offsetof</code></h3>
<div class="hBody-3" >
<p>la funcion <code>unsafe.Sizeof</code> informa el tamaño en bytes de la representacion de su operando, que puede ser una expresion de cualquier tipo; La expresion no se evalua. Una llamada a <code>Sizeof</code> es una expresion constante de tipo <code>uintptr</code>, por lo que el resultado puede ser utilizado como la dimension de un tipo de matriz, o para calcular otras constantes.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;unsafe&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Sizeof</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="c1">// &quot;8&quot;</span>
</pre></div>
<p><code>Sizeof</code> informa solo el tamaño de la parte fija de cada estructura de datos, como el puntero y longitud de una cadena, pero no partes indirectas como el contenido de la cadena. Los tamaños tipicos para todos los tipos Go no agregados se muestran a continuacion, aunque los tamaños exactos pueden variar segun la cadena de herramientas. Para la portabilidad, hemos dado los tamaños de los tipos de referencia (o tipos que contienen referencias) en terminos de palabras, donde una palabra es 4 bytes en una plataforma de 32 bits y 8 bytes en una plataforma de 64 bits.</p>
<p>Las computadoras cargan y almacenan los valores de memoria mas efecientemente cuando esos valores estan correctamente <em>alineados</em>. Por ejemplo, la direccion de un valor de un tipo de dos bytes como <code>int16</code> debe ser un numero par, la direccion de un valor de cuatro bytes como una runa debe ser un multiplo de cuatro, y la direccion de un valor de ocho bytes como un <code>float64</code>, <code>uint64</code>, o un puntero de 64 bits debe ser un multiplo de ocho. Los requisitos de alineacion de multiplos mayores son inusuales, incluso para los tipos de datos mas grandes como <code>complex128</code>.</p>
<p>Por esta razon, el tamaño de un valor de un tipo agregado (una estructura o arreglo) es al menos la suma de los tamaños de sus campos o elementos, pero puede ser mayor debido a la presencia de <q>agujeros</q>. Los agujeros son espacios no utilizados añadidos por el compilador para asegurar que el siguiente campo o elemento este correctamente alineado con respecto al inicio de la estructura o arreglo.</p>
<table>
<thead>
<tr><th>Type</th><th>Size</th></tr>
</thead>
<tbody>
<tr><td><code>bool</code></td><td>1 byte</td></tr>
<tr><td><code>int</code><span class="math" >N</span>, <code>uint</code><span class="math" >N</span>, <code>float</code><span class="math" >N</span>, <code>complex</code><span class="math" >N</span></td><td><span class="math" >N</span> / 8 bytes (por ejemplo, f<code>loat64</code> es 8 bytes)</td></tr>
<tr><td><code>int</code>, <code>uint</code>, <code>uintptr</code></td><td>1 palabra</td></tr>
<tr><td><code>*T</code></td><td>1 palabra</td></tr>
<tr><td><code>string</code></td><td>2 palabras (data, len)</td></tr>
<tr><td><code>[]T</code></td><td>3 palabras (data, len, cap)</td></tr>
<tr><td><code>map</code></td><td>1 palabra</td></tr>
<tr><td><code>func</code></td><td>1 palabra</td></tr>
<tr><td><code>chan</code></td><td>1 palabra</td></tr>
<tr><td><code>interface</code></td><td>2 palabras (type, value)</td></tr>
</tbody>
</table>
<p>La especificacion del lenguaje no garantiza que el orden en que se declaran los campos es el orden en el que se exponen en la memoria, por lo que en teoria un compilador es libre de reordenarlos, aunque al escribir esto, ninguno lo hace. Si los tipos de campos de una estructura son de diferentes tamaños, puede ser mas eficiente en el espacio declarar los campos en un orden que los empaqueta tan firmemente como sea posible. Las tres estructuras abajo tienen los mismos campos, pero la primera requiere hasta un 50% mas de memoria que las otras dos:</p>
<div class="highlight"><pre><span></span>                                  <span class="c1">// 64-bit       32-bit</span>
<span class="kd">struct</span><span class="p">{</span> <span class="kt">bool</span><span class="p">;</span> <span class="kt">float64</span><span class="p">;</span> <span class="kt">int16</span> <span class="p">}</span>    <span class="c1">// 3 palabras   4 palabras</span>
<span class="kd">struct</span><span class="p">{</span> <span class="kt">float64</span><span class="p">;</span> <span class="kt">int16</span><span class="p">;</span> <span class="kt">bool</span> <span class="p">}</span>    <span class="c1">// 2 palabras   3 palabras</span>
<span class="kd">struct</span><span class="p">{</span> <span class="kt">bool</span><span class="p">;</span> <span class="kt">int16</span><span class="p">;</span> <span class="kt">float64</span> <span class="p">}</span>    <span class="c1">// 2 palabras   3 palabras</span>
</pre></div>
<p>Los detalles del algoritmo de alineacion estan mas alla del alcance de este libro, y ciertamente no vale la pena preocuparse por cada estructura, pero un enpaque eficiente puede hacer que las estructuras de datos asignadas frecuentemente sean mas compactas y por lo tanto mas rapidas.</p>
<p>La funcion <code>unsafe.Alignof</code> informa la alineacion requerida del tipo de su argumento. Al igual que <code>Sizeof</code>, se puede aplicar a una expresion de cualquier tipo, y produce una constante. Normalmente, los tipos booleanos y numericos estan alineados con su tamaño (hasta un maximo de 8 bytes) y todos los demas tipos estan alineados con palabras.</p>
<p>La funcion <code>unsafe.Offsetof</code>, cuyo operando debe ser un selector de campo <code>x.f</code>, calcula el desplazamiento del campo de <code>f</code> con respecto al comienzo de su estructura contenedora <code>x</code>, representando los agujeros, si los hay.</p>
<p>La Figura 13.1 muestra una variable de estructura <code>x</code> y su disposicion de memoria tipica en de 32 y 64 bits en implementaciones Go. Las regiones grises son agujeros.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="kt">bool</span>
  <span class="nx">b</span> <span class="kt">int16</span>
  <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>
</pre></div>
<div class="figure" >
<p class="title">Figura 13.1. Agujeros en una estructura.</p>
<figure>
<img src="img/Figure-13.1.jpg" />
</figure>
</div>
<p>La siguiente tabla muestra los resultados de aplicar las tres funcion <code>unsafe</code> al mismo <code>x</code> y a cada uno de sus tres campos:</p>
<dl>
<dt>Plataforma tipica de 32 bits</dt>
<dd>
<pre class="pre" >Sizeof(x)   = 16  Alignof(x)   = 4
Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
Sizeof(x.c) = 12  Alignof(x.c) = 4  Offsetof(x.c) = 4

</pre>
</dd>
<dt>Plataforma tipica de 64 bits</dt>
<dd>
<pre class="pre" >Sizeof(x)   = 32  Alignof(x)   = 8
Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
Sizeof(x.c) = 24  Alignof(x.c) = 8  Offsetof(x.c) = 8

</pre>
</dd>
</dl>
<p>A pesar de sus nombres, estas funciones en realidad no son inseguras, y pueden ser utiles para entender el diseño de la memoria en bruto en un programa al optimizar el espacio.</p>
</div>
<h3 id="Seccion-13.2" ><code>unsafe.Pointer</code></h3>
<div class="hBody-3" >
<p>La mayoria de los tipos de puntero se escriben <code>*T</code>, es decir, <q>un puntero a una variable de tipo <code>T</code></q>. El tipo <code>unsafe.Pointer</code> es un tipo especial de puntero que puede contener la direccion de cualquier variable. Por supuesto, no podemos aplicar indireccion a traves de un <code>unsafe.Pointer</code> usando <code>*p</code>, porque no sabemos que tipo de expresion que debe tener. Como los punteros ordinarios, <code>unsafe.Pointers</code> es comparable y pueden compararse con <code>nil</code>, que es el valor cero del tipo.</p>
<p>Un puentor <code>*T</code> ordinario puede convertirse en un <code>unsafe.Pointer</code>, y un <code>unsafe.Pointer</code> convertirse de nuevo a un puntero ordinario, no necesariamente del mismo tipo <code>*T</code>. Por ejemplo, al convertir un puntero <code>*float64</code> en un <code>*uint64</code>, podemos inspeccionar el patron de bits de una variable de punto flotante:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">math</span>

<span class="kd">func</span> <span class="nx">Float64bits</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span> <span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#016x\n&quot;</span><span class="p">,</span> <span class="nx">Float64bits</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span> <span class="c1">// &quot;0x3ff0000000000000&quot;</span>
</pre></div>
<p>A traves del puntero resultante, podemos actualizar el patron de bits tambien. Esto es inofensivo para una variable de punto flotante, ya que cualquier patron de bits es legal, pero en general, las conversiones <code>unsafe.Pointer</code> nos permiter escribir valores arbitrarios en memoria y asi subvertir el sistema de tipos.</p>
<p>Un <code>unsafe.Pointer</code> tambien se puede convertir en un <code>uintptr</code> que mantiene el valor numerico del puntero, dejandonos realizar aritmetica de direcciones. (Recuerde del <a href="#Capitulo-3" >Capitulo 3</a> que un <code>uintptr</code> es un entero sin signo lo suficientemente ancho como para representar una direccion.) Esta conversion tambien se puede aplicar a la inversa, pero de nuevo, la conversion de un <code>uintptr</code> a un <code>unsafe.Pointer</code> puede subvertir el sistema de tipos ya que no todos los numeros son direcciones validas.</p>
<p>Muchos valores <code>unsafe.Pointer</code> son, por tanto, intermediarios para convertir punteros ordinarios en direcciones numericas brutas y viceversa. El ejemplo a continuacion toma la direccion de la variable <code>x</code>, añade el desplazamiento de su campo <code>b</code>, convierte la direccion resultante en <code>*int16</code>, y por medio este puntero actualiza <code>x.b</code>:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch13/unsafeptr/main.go" >gopl.io/ch13/unsafeptr</a></p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="kt">bool</span>
  <span class="nx">b</span> <span class="kt">int16</span>
  <span class="nx">c</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// equivalente a pb := &amp;x.b</span>
<span class="nx">pb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span>
  <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Offsetof</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)))</span>
<span class="o">*</span><span class="nx">pb</span> <span class="p">=</span> <span class="mi">42</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// &quot;42&quot;</span>
</pre></div>
</div>
<p>Aunque la sintaxis es engorrosa–quiza no es malo, ya que estas caracteristicas deben utilizarse con moderacion–no se sienta tentado a introducir variables temporales de tipo <code>uintptr</code> para romper las lineas. Este codigo es incorrecto:</p>
<div class="highlight"><pre><span></span><span class="c1">// NOTA: sutilmente incorreto!</span>
<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Offsetof</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="nx">pb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">tmp</span><span class="p">))</span>
<span class="o">*</span><span class="nx">pb</span> <span class="p">=</span> <span class="mi">42</span>
</pre></div>
<p>La razon es muy sutil. Algunos recolectores de basura mueven las variables en la memoria para reducir la fragmentacion o la contabilidad. Los recolectores de basura de este tipo lo conocen como <em>mover GCs</em>. Cuando se mueve una variable, todos los punteros que contienen la direccion de la antigua ubicacion deben actualizarse para apuntar a la nueva. Desde la perspectiva del colector de basura, un <code>unsafe.Pointer</code> es un puntero y por lo tanto su valor debe cambiar a medida que se mueve la variable, pero un <code>uintptr</code> es solo un numero por lo que su valor no debe cambiar. El codigo anterior es incorrecta por que <em>oculta un puentero</em> del recolector de basura en la variable no puntero <code>tmp</code>. En el momento que la segunda instruccion se ejecuta, la variable <code>x</code> podria haberse movido y el numero de <code>tmp</code> ya no seria la direccion <code>&amp;x.b</code>. La tercera declaracion ataca una ubicacion de memoria arbitraria con el valor 42.</p>
<p>Hay un sin sinnumero de variaciones patologicas sobre este tema. Despues de que esta declaracion se ha ejecutado:</p>
<div class="highlight"><pre><span></span><span class="nx">pT</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)))</span> <span class="c1">// NOTA: incorrecto!</span>
</pre></div>
<p>no hay punteros que referencien la variable creado por <code>new</code>, por lo que el recolector de basura tiene derecho a reciclar su almacenamiento cuando esta declaracion se complete, despues de lo cual <code>pT</code> contiene la direccion donde estaba la variable, pero ya no.</p>
<p>Ninguna implementacion actual de Go utiliza un recolector de basura en movimiento (aunque futuras implementaciones podrian), pero esto no es motivo de complacencia: las versiones actuales de Go hacer mover <em>algunas</em> variables en la memoria. Recuerde de la <a href="#Seccion-5.2" >Seccion 5.2</a> que las pilas de gorutina crecen segun sea necesario. Cuando esto sucede, todas las variables de la pila antigua pueden ser reubicadas en una nueva pila mas grande, por lo que no podemos confiar en que el valor numerico de la direccion de una variable permanezca invariable durante toda su vida util.</p>
<p>En el momento de escribir esto, hay poco clara orientacion sobre lo que los programadores Go pueden esperar despues de una convercion <code>unsafe.Pointer</code> a <code>uintptr</code> (en el repositorio vea el asunto 7192), por lo que recomendamos encarecidamente que asuma el minimo necesario. Trate todos los valores <code>uintptr</code> como si almacenaran la <em>antigua</em> direccion de una variable, y minimice el numero de operaciones entre la conversion de un <code>unsafe.Pointer</code> a un <code>uintptr</code> y el uso de ese <code>uintptr</code>. En nuestro primer ejemplo anterior, las tres operaciones–la conversion a un <code>uintptr</code>, la suma la compensacion de campo, y la conversion de nuevo–aparecieron dentro de una sola expresion.</p>
<p>Cuando se llama a una funcion de libreria que devuelve un <code>uintptr</code>, como las que se muestran a continuacion del paquete <code>reflect</code>, el resultado debe ser convertido inmediatamente a un <code>unsafe.Pointer</code> para asegurarse de que sigue apuntando a la misma variable.</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">reflect</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">Pointer</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">UnsafeAddr</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">Value</span><span class="p">)</span> <span class="nx">InterfaceData</span><span class="p">()</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// (index 1)</span>
</pre></div>
</div>
<h3 id="Seccion-13.3" >Ejemplo: Equivalencia profunda</h3>
<div class="hBody-3" >
<p>La funcion <code>DeepEqual</code> del paquete <code>reflect</code> informa si dos valores son <q>profundamente</q> iguales. <code>DeepEqual</code> compara los valores basicos como si fuera el operador <code>==</code>; para los valores compuestos, los recorre recursivamente, comparando los elementos correspondientes. Debido a que funciona para cualquier par de valores, incluso los que no son comparables con <code>==</code>, este encuentra un uso amplio en pruebas. La siguiente prueba utiliza <code>DeepEqual</code> para comparar dos valores <code>[]string</code>:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestSplit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">got</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="s">&quot;a:b:c&quot;</span><span class="p">,</span> <span class="s">&quot;:&quot;</span><span class="p">)</span>
  <span class="nx">want</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">got</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Aunque <code>DeepEqual</code> es conveniente, sus distinciones pueden parecer arbitrarias. Por ejemplo, no considera un mapa nil igual a un mapa vacio no-nil, ni un slice nil igual a uno vacio no-nil:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>

<span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">DeepEqual</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p>En esta seccion vamos a definir una funcion <code>Equal</code> que compara valores arbitrarios. Al igual que <code>DeepEqual</code>, compara slices y mapas en base a sus elementos, pero a diferencia de <code>DeepEqual</code>, considera una slice nil (o mapa) igual a uno no-nil vacio. La recursion basica sobre los argumentos se puede hacer con reflexion, usando un enfoque similar a <code>Display</code> del programa que vimos en la <a href="#Seccion-12.3" >Seccion 12.3</a>. Como de costumbre, definimos una funcion no exportada, <code>equal</code>, para la recursion.  Por el momento no se preocupe por el parametro <code>seen</code>. Para cada par de valores <code>x</code> y <code>y</code> a comparar, <code>equal</code> verifica que ambos (o ninguno) son validos y comprueba que tienen el mismo tipo. El resultado de la funcion se define como un conjunto de casos de conmutacion que comparan dos valores del mismo tipo. Por motivos de espacio, hemos omitido varios casos, ya que el patron debe ser familiar por ahora.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch13/equal/equal.go" >gopl.io/ch13/equal</a></p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">seen</span> <span class="kd">map</span><span class="p">[</span><span class="nx">comparison</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">y</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">IsValid</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="c1">// ...ciclo de verificacion omitido (mostrado mas adelante)...</span>

  <span class="k">switch</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Kind</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Bool</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Bool</span><span class="p">()</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>

  <span class="c1">// ...casos numericos omitidos por brevedad...</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Chan</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">UnsafePointer</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Func</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()</span> <span class="o">==</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">()</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Elem</span><span class="p">(),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Elem</span><span class="p">(),</span> <span class="nx">seen</span><span class="p">)</span>

  <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">equal</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nx">seen</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>

  <span class="c1">// ...struct and map cases omitted for brevity...</span>
  <span class="p">}</span>
  <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;unreachable&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como de costumbre, no exponemos el uso de la reflexion en la API, por lo que la funcion exportada <code>Equal</code> debe llamarla con <code>reflect.ValueOf</code> en sus argumentos:</p>
<div class="highlight"><pre><span></span><span class="c1">// Equal informa si x e y son profundamente iguales.</span>
<span class="kd">func</span> <span class="nx">Equal</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="nx">seen</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">comparison</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">ValueOf</span><span class="p">(</span><span class="nx">y</span><span class="p">),</span> <span class="nx">seen</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">comparison</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
  <span class="nx">t</span>
  <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span>
<span class="p">}</span>
</pre></div>
<p>Para asegurar que el algoritmo termina incluso para estructuras de datos ciclicas, debe registrar que pares de variables ya ha comparado y evitar compararlas una segunda vez. <code>Equal</code> asigna un conjunto de comparison estructuras, cada uno con la direccion de dos variables (representado como valores <code>unsafe.Pointer</code>) y el tipo de comparacion. Necesitamos registrar el tipo ademas de las direcciones porque las diferentes variables pueden tener la misma direccion. Por ejemplo, si <code>x</code> y <code>y</code> son ambos arreglos, <code>x</code> y <code>x[0]</code> tienen la misma direccion, como lo hacen <code>y</code> e <code>y[0]</code>, y es importante distinguir si hemos comparado <code>x</code> y <code>y</code> o <code>x[0]</code> y <code>y[0]</code>.</p>
<p>Una vez equal ha establecido que sus argumentos tienen el mismo tipo, y antes de que ejecute el switch, se comprueba si se esta comparando dos variables que ya ha visto y, si es asi, termina la recursion.</p>
<div class="highlight"><pre><span></span><span class="c1">// verificacion de ciclo</span>
<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">CanAddr</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">xptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">UnsafeAddr</span><span class="p">())</span>
  <span class="nx">yptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">UnsafeAddr</span><span class="p">())</span>
  <span class="k">if</span> <span class="nx">xptr</span> <span class="o">==</span> <span class="nx">yptr</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span> <span class="c1">// referencias identicas</span>
  <span class="p">}</span>
  <span class="nx">c</span> <span class="o">:=</span> <span class="nx">comparison</span><span class="p">{</span><span class="nx">xptr</span><span class="p">,</span> <span class="nx">yptr</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Type</span><span class="p">()}</span>
  <span class="k">if</span> <span class="nx">seen</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span> <span class="c1">// ya visto</span>
  <span class="p">}</span>
  <span class="nx">seen</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
<p>Aqui esta nuestra funcion <code>Equal</code> en accion:</p>
<div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}))</span>        <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;bar&quot;</span><span class="p">}))</span>      <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">([]</span><span class="nb">string</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}))</span>             <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}))</span> <span class="c1">// &quot;true&quot;</span>
</pre></div>
<p>Incluso funciona en entradas ciclicas similares a la que hizo que la funcion <code>Display</code> de la <a href="#Seccion-12.3" >Seccion 12.3</a> quedara atascada en un bucle:</p>
<div class="highlight"><pre><span></span><span class="c1">// Lista circular enlazada a -&gt; b -&gt; a and c -&gt; c.</span>
<span class="kd">type</span> <span class="nx">link</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">value</span> <span class="kt">string</span>
  <span class="nx">tail</span> <span class="o">*</span><span class="nx">link</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&quot;a&quot;</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&quot;b&quot;</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">link</span><span class="p">{</span><span class="nx">value</span><span class="p">:</span> <span class="s">&quot;c&quot;</span><span class="p">}</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">c</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="c1">// &quot;true&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">))</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>
<p><b>Ejercicio 13.1</b>: Definir una funcion de comparacion de profundidad que tome en cuenta los numeros (de cualquier tipo) igual si difieren en menos de una parte en mil millones.</p>
<p><b>Ejercicio 13.2</b>: Escribir una funcion que informa si su argumento es una estructura de datos ciclica.</p>
</div>
<h3 id="Seccion-13.4" >Llamar Codigo C con <code class="command" >cgo</code></h3>
<div class="hBody-3" >
<p>Un programa Go puede necesitar utilizar un controlador de hardware implementado en C, consultar una base de datos enbebida implementada en C++ o utilizar algunas rutinas de algebra lineal implementadas en Fortran. C ha sido durante mucho tiempo la lingua franca de la programacion, por lo que muchos paquetes destinados a un uso generalizado exportan una API compatible con C, independientemente del lenguaje de su implementacion.</p>
<p>En esta seccion, vamos a construir un simple programa de compresion de datos que utiliza <code class="command" >cgo</code>, una herramienta que crea enlaces de Go para funciones C. Estas herramientas se llaman <em>interfaces de funcion externa</em> (FFIs), y <code class="command" >cgo</code> no es el unico para los programas Go. SWIG (<a href="http://swig.org/" >swig.org</a>) es otro; Proporciona caracteristicas mas complejas para integrarse con las clases de C++, pero no lo mostraremos aqui.</p>
<p>El subarbol <code>compress/...</code> de la libreria estandar proporciona compresores y descompresores de los algoritmos de compresion mas populares, incluyendo LZW (usado por el comando Unix <code class="command" >compress</code>) y DEFLATE (usado por el comando GNU <code class="command" >gzip</code>). Las APIs de estos paquetes varian ligeramente en detalles, pero todos ellos proporcionan un envoltorio para un io.Writer que comprime los datos escritos en ellos, y un envoltorio para un io.Reader que descomprime los datos leidos de estos. Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">gzip</span> <span class="c1">// compress/gzip</span>

<span class="kd">func</span> <span class="nx">NewWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span>
<span class="kd">func</span> <span class="nx">NewReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
<p>El algoritmo bzip2, que se basa en la elegante transformacion de Burrows-Wheeler, corre mas lento que gzip pero produce una compresion significativamente mejor. El paquete <code>compress/bzip2</code> proporciona un descompresor para bzip2, pero en este momento el paquete no proporciona ningun compresor. La construccion de uno desde cero es una tarea sustancial, pero hay una implementacion en C de codigo abierto bien documentada con alto rendimiento, el paquete <code>libbzip2</code> desde <a href="http://bzip.org/" >bzip.org</a>.</p>
<p>Si la libreria de C fuera pequeña, simplemente la portariamos a Go puro, y si su rendimiento no fuera critico para nuestros propositos, estariamos mejor invocando un programa en C como un subproceso de ayuda utilizando el paquete <code>os/exec</code>. Es cuando se necesita utilizar una libreria compleja, de rendimiento critico con un API C compacto que puede tener sentido envolverla usando <code class="command" >cgo</code>. El resto de este capitulo, trabajaremos con un ejemplo.</p>
<p>Desde el paquete C <code>libbzip2</code>, necesitamos el tipo de estructura <code>bz_stream</code>, que contiene los buferes de entrada y salida, y tres funciones de C: <code>BZ2_bzCompressInit</code>, que asigna buffers del flujo; <code>BZ2_bzCompress</code>, que comprime los datos de bufer d entrada al bufer de salida; y <code>BZ2_bzCompressEnd</code>, que libera los bufferes. (No se preocupe por la mecanica del paquete <code>libbzip2</code>, el proposito de este ejemplo es mostrar como las piezas encajan entre si.)</p>
<p>Vamos a llamar a las funciones <code>BZ2_bzCompressInit</code> y <code>BZ2_bzCompressEnd</code> C directamente desde Go, pero para <code>BZ2_bzCompress</code>, vamos a definir una funcion de envoltorio en C, para mostrar como se hace. El archivo de codigo fuente C vive al lado del codigo Go en nuestro paquete:</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch13/bzip/bzip2.c" >gopl.io/ch13/bzip</a></p>
<div class="highlight"><pre><span></span><span class="cm">/* Este archivo es gopl.io/ch13/bzip/bzip2.c,            */</span>
<span class="cm">/* un simple envoltorio para libbzip2 adecuado para cgo. */</span>
<span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">bzlib</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>

<span class="kt">int</span> <span class="nx">bz2compress</span><span class="p">(</span><span class="nx">bz_stream</span> <span class="o">*</span><span class="nx">s</span><span class="p">,</span> <span class="kt">int</span> <span class="nx">action</span><span class="p">,</span>
                <span class="nx">char</span> <span class="o">*</span><span class="nx">in</span><span class="p">,</span> <span class="nx">unsigned</span> <span class="o">*</span><span class="nx">inlen</span><span class="p">,</span> <span class="nx">char</span> <span class="o">*</span><span class="nx">out</span><span class="p">,</span> <span class="nx">unsigned</span> <span class="o">*</span><span class="nx">outlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next_in</span> <span class="p">=</span> <span class="nx">in</span><span class="p">;</span>
  <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">avail_in</span> <span class="p">=</span> <span class="o">*</span><span class="nx">inlen</span><span class="p">;</span>
  <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next_out</span> <span class="p">=</span> <span class="nx">out</span><span class="p">;</span>
  <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">avail_out</span> <span class="p">=</span> <span class="o">*</span><span class="nx">outlen</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nx">r</span> <span class="p">=</span> <span class="nx">BZ2_bzCompress</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
  <span class="o">*</span><span class="nx">inlen</span> <span class="o">-=</span> <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">avail_in</span><span class="p">;</span>
  <span class="o">*</span><span class="nx">outlen</span> <span class="o">-=</span> <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">avail_out</span><span class="p">;</span>
  <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next_in</span> <span class="p">=</span> <span class="nx">s</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next_out</span> <span class="p">=</span> <span class="nx">NULL</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ahora veamos el codigo Go, cuya primera parte se muestra a continuacion. La declaracion <code>import &quot;C&quot;</code> es especial. No hay ningun paquete C, pero esta importacion hace que <code class="command" >go build</code> preprocese el archivo con la herramienta <code class="command" >cgo</code> antes de que el compilador Go lo vea.</p>
<div class="highlight"><pre><span></span><span class="c1">// El paquete bzip proporciona un escritor que utiliza compresion bzip2 (bzip.org).</span>
<span class="kn">package</span> <span class="nx">bzip</span>

<span class="cm">/*</span>
<span class="cm">#cgo CFLAGS: -I/usr/include</span>
<span class="cm">#cgo LDFLAGS: -L/usr/lib -lbz2</span>
<span class="cm">#include &lt;bzlib.h&gt;</span>
<span class="cm">int bz2compress(bz_stream *s, int action,</span>
<span class="cm">                char *in, unsigned *inlen, char *out, unsigned *outlen);</span>
<span class="cm">*/</span>
<span class="kn">import</span> <span class="s">&quot;C&quot;</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;unsafe&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">writer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">w</span>      <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="c1">// underlying output stream</span>
  <span class="nx">stream</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">bz_stream</span>
  <span class="nx">outbuf</span> <span class="p">[</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">// NewWriter devuelve un escritor para flujos bzip2 comprimidos.</span>
<span class="kd">func</span> <span class="nx">NewWriter</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">(</span>
    <span class="nx">blockSize</span> <span class="p">=</span> <span class="mi">9</span>
    <span class="nx">verbosity</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">workFactor</span> <span class="p">=</span> <span class="mi">30</span>
  <span class="p">)</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">writer</span><span class="p">{</span><span class="nx">w</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">stream</span><span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nx">bz_stream</span><span class="p">)}</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">BZ2_bzCompressInit</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">blockSize</span><span class="p">,</span> <span class="nx">verbosity</span><span class="p">,</span> <span class="nx">workFactor</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">w</span>
<span class="p">}</span>
</pre></div>
<p>Durante el preprocesamiento, <code class="command" >cgo</code> genera un paquete temporal que contiene declaraciones Go correspondientes a todas las funciones de C y los tipos utilizados por el archivo, como <code>C.bz_stream</code> y <code>C.BZ2_bzCompressInit</code>. La herramienta <code class="command" >cgo</code> descubre este tipo invocando el compilador de C de una manera especial sobre el contenido del comentario que precede a la declaracion de importacion.</p>
<p>El comentario tambien puede contener directivas <code>#cgo</code> que especifican opciones adicionales a la cadena de herramientas C. Los valores <code>CFLAGS</code> y <code>LDFLAGS</code> aportan argumentos adicionales a los comandos de compilacion y enlace para que puedan localizar el archivo de cabecera <code>bzlib.h</code> y la libreria de archivo <code>libbz2.a</code>. El ejemplo supone que estos se instalan debajo de <code>/usr</code> en su sistema. Es posible que necesite modificar o eliminar estos indicadores para su instalacion. <code>NewWriter</code> realiza una llamada a la funcion C <code>BZ2_bzCompressInit</code> para inicializar los buferes de la secuencia. El tipo de escritor incluye otro bufer que se utilizara para drenar el bufer de salida del descompresor.</p>
<p>El metodo <code>Write</code>, se muestra a continuacion, alimenta el compresor con <code>data</code>, llamando a la funcion <code>bz2compress</code> en un bucle hasta que todos los datos se ha consumido. Observe que el programa Go puede acceder tipos C como <code>bz_stream</code>, <code>char</code>, y <code>uint</code>, funciones de C como <code>bz2compress</code>, e incluso macros del preprocesador C como a objetos como <code>BZ_RUN</code>, todo a traves de la notacion <code>C.x</code>. El tipo <code>C.uint</code> es distinto del tipo <code>uint</code> de Go, incluso si ambos tienen el mismo tamaño.</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">writer</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;closed&quot;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int</span> <span class="c1">// bytes escritos sin comprimir</span>

  <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">inlen</span><span class="p">,</span> <span class="nx">outlen</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">))</span>
    <span class="nx">C</span><span class="p">.</span><span class="nx">bz2compress</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_RUN</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">inlen</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">outlen</span><span class="p">)</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">inlen</span><span class="p">)</span>
    <span class="nx">data</span> <span class="p">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">inlen</span><span class="p">:]</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">[:</span><span class="nx">outlen</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
<p>Cada iteracion del bucle <code>bz2compress</code> pasa la direccion y longitud de la porcion restante de la variable <code>data</code>, y la direccion y capacidad de <code>w.outbuf</code>. Las dos variables de longitud son pasadas por sus direcciones, no por sus valores, por lo que la funcion C puede actualizarlas para indicar la cantidad de datos sin comprimir que se consumio y la cantidad de datos comprimidos producidos. Cada trozo de datos comprimido se escribe en el <code>io.Writer</code> subyacente.</p>
<p>El metodo <code>Close</code> tiene una estructura similar a <code>Write</code>, utilizando un bucle para eliminar cualquier resto de datos comprimidos del bufer de salida del flujo.</p>
<div class="highlight"><pre><span></span><span class="c1">// Cierra los datos comprimidos y cierra el flujo.</span>
<span class="c1">// No cierra el io.Writer subyacente.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">writer</span><span class="p">)</span> <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;closed&quot;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">C</span><span class="p">.</span><span class="nx">BZ2_bzCompressEnd</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">)</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">stream</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="p">}()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">inlen</span><span class="p">,</span> <span class="nx">outlen</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">))</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nx">bz2compress</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">stream</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_FINISH</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inlen</span><span class="p">,</span>
      <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">outlen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nx">Write</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">outbuf</span><span class="p">[:</span><span class="nx">outlen</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="nx">C</span><span class="p">.</span><span class="nx">BZ_STREAM_END</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Al finalizar, <code>Close</code> llama a <code>C.BZ2_bzCompressEnd</code> para liberar los buferes de flujo, utilizando <code>defer</code> para asegurar que esto sucede en todas las rutas de retorno. En este punto el puntero <code>w.stream</code> ya no es seguro de deferenciar. Para estar a la defensiva, lo ponemos a <code>nil</code>, y agregamos chequeos explicitos de nil en cada metodo, por lo que el programa entra en panico si el usuario llama por error un metodo despues de <code>Close</code>.</p>
<p>No solo <code>writer</code> no es concurrentemente seguro, sino que las concurrentes a <code>Close</code> y <code>Write</code> podria hacer que el programa se bloquee en el codigo C. Correjir esto es el Ejercicio 13.3.</p>
<p>El siguiente programa, <code>bzipper</code>, es un comando <code>bzip2</code> compresor que utiliza nuestro nuevo paquete. Se comporta como el comando <code class="command" >bzip2</code> presente en muchos sistemas Unix.</p>
<div class="figure" >
<p class="title"><a href="gopl.io/ch13/bzipper/main.go" >gopl.io/ch13/bzipper</a></p>
<div class="highlight"><pre><span></span><span class="c1">// Bzipper lee la entrada, lo comprime como bzip2, y lo escribe en la salida.</span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&quot;io&quot;</span>
  <span class="s">&quot;log&quot;</span>
  <span class="s">&quot;os&quot;</span>

  <span class="s">&quot;gopl.io/ch13/bzip&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">w</span> <span class="o">:=</span> <span class="nx">bzip</span><span class="p">.</span><span class="nx">NewWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;bzipper: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">Close</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;bzipper: close: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En la sesion a continuacion, utilizamos <code class="command" >bzipper</code> para comprimir <code>/usr/share/dict/words</code> el diccionario del sistema, de 938,848 bytes a 335,405 bytes–aproximadamente de un tercio de su tamaño original–luego lo descomprimimos con el comando del sistema <code class="command" >bunzip2</code>. El hash SHA256 es el mismo antes y despues, dandonos confianza de que el compresor esta funcionando correctamente. (Si usted no tiene <code class="command" >sha256sum</code> en su sistema, utilice su solucion al Ejercicio 4.2.)</p>
<div class="highlight"><pre><span></span>$ go build gopl.io/ch13/bzipper
$ wc -c &lt; /usr/share/dict/words
<span class="m">938848</span>
$ sha256sum &lt; /usr/share/dict/words
126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed $ ./bzipper &lt; /usr/share/dict/words <span class="p">|</span> wc -c
<span class="m">335405</span>
$ ./bzipper &lt; /usr/share/dict/words <span class="p">|</span> bunzip2 <span class="p">|</span> sha256sum
126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -
</pre></div>
<p>Hemos demostrado la vinculacion de una libreria C con un programa Go. Yendo en la otra direccion, tambien es posible compilar un programa Go como un archivo estatico que se puede vincular en un programa C o como una libreria compartida que puede cargarse dinamicamente por un programa C. Solo hemos arañado la superficie de <code class="command" >cgo</code>, y hay mucho mas que decir acerca de la gestion de memoria, punteros, devoluciones de llamada, el manejo de señales, cadenas, <code>errno</code>, finalizadores, y la relacion entre gorutinas y los hilos del sistema operativo, gran parte de ello muy sutil. En particular, las reglas para pasar correctamente punteros de Go a C o viceversa son complejas, por razones similares a las que discutimos en la <a href="#Seccion-13.2" >Seccion 13.2</a>, y aun no autoritariamente especificadas. Para mas informacion, comience con <a href="https://golang.org/cmd/cgo" >https://golang.org/cmd/cgo</a>.</p>
<p><b>Ejercicio 13.3</b>: Utilice <code>sync.Mutex</code> para hacer <code>bzip2.writer</code> seguro para el uso concurrente por multiples gorutinas.</p>
<p><b>Ejercicio 13.4</b>: Depender de librerias C tiene sus inconvenientes. Proporcione una implementacion alternativa en puro Go de <code>bzip.NewWriter</code> que utilice el paquete <code>os/exec</code> para ejecutar <code>/bin/bzip2</code> como un subproceso.</p>
</div>
<h3 id="Seccion-13.5" >Otra Palabra de Precaucion</h3>
<div class="hBody-3" >
<p>Terminamos el capitulo anterior con una advertencia sobre las desventajas de la interfaz de reflexion. Esa advertencia se aplica incluso con mas fuerza al paquete <code>unsafe</code> descrito en este capitulo.</p>
<p>Los lenguajes de alto nivel aislan a los programas y programadores no solo de los detalles arcanos de los conjuntos de instrucciones individuales de computadora, sino de la dependencia de las irrelevancias, como en la memoria en la que vive una variable, el tamaño del tipo de datos, y otros detalles de implementacion del anfitrion. Debido a esa capa aislante, es posible escribir programas que son seguros y robustos y que se ejecutaran en cualquier sistema operativo sin cambios.</p>
<p>El paquete <code>unsafe</code> permite a los programadores cruzar a traves del aislamiento para utilizar alguna caracteristica crucial, pero de otro modo inaccesibles, o tal vez para lograr un mayor rendimiento. El costo suele ser la portabilidad y la seguridad. Nuestro consejo sobre como y cuando usar <code>unsafe</code> son paralelos a los comentarios de Knuth para la optimizacion prematura, que hemos citado en la <a href="#Seccion-11.5" >Seccion 11.5</a>. La mayoria de los programadores nunca necesitaran utilizar <code>unsafe</code> en absoluto. Sin embargo, ocasionalmente habra situaciones en las que algun fragmento critica de codigo puede ser escrito mejor usando <code>unsafe</code>. Si el estudio y la medicion cuidadosa indican que <code>unsafe</code> realmente es el mejor enfoque, restrinja el fragmento lo mayor posible, para que la mayor parte del programa ignore su uso.</p>
<p>Por ahora, ponga los dos ultimos capitulos en la parte de atras de su mente. Escriba algunos programas importantes en Go. Evite <code>reflect</code> y <code>unsafe</code>; Vuelva a estos capitulos solamente si usted debe.</p>
<p>Mientras tanto, Feliz programacion con Go. Esperamos que disfrutes escribiendo en Go tanto como nosotros.</p>
</div>


  </body>
</html>
