@ -*- mode: org; -*-
..title   > El lenguaje de programacion Go
..author  > Alan A. A. Donovan
..author  > Brian W. Kernighan
..date    > 29/09/2015
..id      > isbn-13 978-0-13-419044-0
..id      > isbn-10 0-13-419044-0
..style   > worg-data/worg.css
..options > toc pygments

@ revision 3b600c, date 29 Sep 2015

# ..center >
#   For Leila and Meg
# < center..
..center >
  Para Leila y Meg
< center..

# * Preface
* Prefacio

#   ..quote >
#     @"(Go is an open source programming language that makes it easy to build
#     simple, reliable, and efficient software.)
#
#     --(From the Go web site at @l(https://golang.org/<>golang.org))
#   < quote..
  ..quote >
    @"(Go es un lenguaje de programacion de codigo abierto, que facilita la
    creacion de software simple, confiable y eficiente.)

    --(Desde el sitio web de Go en  @l(https://golang.org/<>golang.org))
  < quote..

#   Go was conceived in September 2007 by Robert Griesemer, Rob Pike, and Ken
#   Thompson, all at Google, and was announced in November 2009. The goals of the
#   language and its accompanying tools were to be expressive, efficient in both
#   compilation and execution, and effective in writing reliable and robust
#   programs.
  Go fue concebido en septiembre de 2007 por Robert Griesemer, Rob Pike y Ken
  Thompson, todos de Google, y fue anunciado en noviembre de 2009. La meta del
  lenguaje y sus herramientas acompañantes es ser expresivos, eficientes en la
  compilacion y ejecucion, y eficaz en la escritura de programas fiables y
  robustos.

#   Go bears a surface similarity to C and, like C, is a tool for professional
#   programmers, achieving maximum effect with minimum means. But it is much more
#   than an updated version of C. It borrows and adapts good ideas from many other
#   languages, while avoiding features that have led to complexity and unreliable
#   code. Its facilities for concurrency are new and efficient, and its approach
#   to data abstraction and object-oriented programming is unusually flexible. It
#   has automatic memory management or @e(garbage collection).
  Go tiene una similitud superficial con C y, como C, es una herramienta para
  programadores profesionales, logrando el maximo efecto con un minimo de
  medios. Pero es mucho mas que una version actualizada de C. Obtiene y adapta
  buenas ideas de muchos otros idiomas, evitando caracteristicas que han llevado
  a la complejidad y a un codigo poco confiable. Sus comodidades para la
  concurrencia son nuevas y eficientes, y su enfoque hacia la abstraccion de
  datos y la programacion orientada a objetos es inusualmente flexible. Tambien
  cuenta con gestion automatica de memoria o @e(recoleccion de basura).

#   Go is especially well suited for building infrastructure like networked
#   servers, and tools and systems for programmers, but it is truly a
#   general-purpose language and finds use in domains as diverse as graphics,
#   mobile applications, and machine learning. It has become popular as a
#   replacement for untyped scripting languages because it balances expressiveness
#   with safety : Go programs typically run faster than programs written in
#   dynamic languages and suffer far fewer crashes due to unexpected type errors.
  Go es especialmente adecuado para la construccion de infraestructura como
  servidores en red, y herramientas y sistemas para programadores, pero es
  realmente un lenguaje de uso general y se utiliza en dominios tan diversos
  como graficos, aplicaciones moviles y aprendizaje automatico. Se ha vuelto
  popular como un reemplazo para los lenguajes de scripting no tipados porque
  equilibra la expresividad con la seguridad: Los programas Go suelen funcionar
  mas rapido que los programas escritos en lenguajes dinamicos y sufren muchos
  menos accidentes debido a errores de tipado.

#   Go is an open-source project, so source code for its compiler, libraries, and
#   tools is freely available to anyone. Contributions to the project come from an
#   active worldwide community. Go runs on Unix-like systems—Linux, FreeBSD,
#   OpenBSD, Mac OS X—and on Plan 9 and Microsoft Windows. Programs written in one
#   of these environments generally work without modification on the others.
  Go es un proyecto de codigo abierto, por lo que el codigo fuente de su
  compilador, librerias y herramientas esta disponible gratuitamente para
  cualquiera. Las contribuciones al proyecto provienen de una activa comunidad
  mundial. Go se ejecuta en sistemas tipo Unix –GNU/Linux, FreeBSD, OpenBSD,
  Mac OS X– y en Plan 9 y Microsoft Windows. Los programas escritos en uno de
  estos entornos generalmente funcionan sin modificacion en los otros.

#   This book is meant to help you start using Go effectively right away and to
#   use it well, taking full advantage of Go’s language features and standard
#   libraries to write clear, idiomatic, and efficient programs.
  Este libro esta diseñado para ayudarle a comenzar a usar Go efectivamente, de
  inmediato y utilizarlo bien, aprovechando al maximo las caracteristicas
  lingüisticas de Go y las librerias estandar para escribir programas claros,
  idiomaticos y eficientes.

# ** The Origins of Go
** Los origenes de Go

#    Like biological species, successful languages beget offspring that
#    incorporate the advantages of their ancestors; interbreeding sometimes leads
#    to surprising strengths; and, very occasionally, a radical new feature arises
#    without precedent. We can learn a lot about why a language is the way it is
#    and what environment it has been adapted for by looking at these influences.
   Como las especies biologicas, las lenguas exitosas engendran hijos que
   incorporan las ventajas de sus antepasados; El entrecruzamiento a veces
   conduce a fortalezas sorprendentes; Y, muy ocasionalmente, surge un nuevo
   rasgo radical sin precedentes. Podemos aprender mucho sobre por que un
   lenguaje es como es y a que entorno se ha adaptado para ver estas
   influencias.

#    The figure below shows the most important influences of earlier
#    programming languages on the design of Go.
   La siguiente figura muestra las influencias mas importantes de los lenguajes
   de programacion anteriores en el diseño de Go.

#    ..img > img/go-influences.jpg
   ..img > img/go-influences.jpg


#    Go is sometimes described as a @"(C-like language,) or as @"(C for the 21st
#    century.) From C, Go inherited its expression syntax, control-flow
#    statements, basic data types, call-by-value parameter passing, pointers, and
#    above all, C’s emphasis on programs that compile to efficient machine code
#    and cooperate naturally with the abstractions of current operating systems.
   En ocaciones Go se describe como un @"(lenguaje de tipo C,) o como @"(C para
   el siglo 21.) De C, Go heredo su sintaxis de expresiones, instrucciones de
   flujo de control, tipos de datos basicos, paso parametros por valor, punteros
   y, sobre todo, el enfasis de C en programas que compilan codigo maquina
   eficiente y cooperan naturalmente con las abstracciones de los sistemas
   operativos actuales.

#    But there are other ancestors in Go’s family tree. One major stream of
#    influence comes from languages by Niklaus Wirth, beginning with
#    Pascal. Modula-2 inspired the package concept.  Oberon eliminated the
#    distinction between module interface files and module implementation
#    files. Oberon-2 influenced the syntax for packages, imports, and
#    declarations, and Object Oberon provided the syntax for method declarations.
   Pero hay otros antepasados ​​en el arbol genealogico de Go. Una importante
   corriente de influencia proviene de lenguajes de Niklaus Wirth, comenzando
   con Pascal. Modula-2 inspiro el concepto de paquete. Oberon elimino la
   distincion entre los archivos de interfaz del modulo y los archivos de
   implementacion del modulo. Oberon-2 influyo en la sintaxis de paquetes,
   importaciones y declaraciones, y Object Oberon proporciono la sintaxis para
   la declararcion de metodos.

#    Another lineage among Go’s ancestors, and one that makes Go distinctive among
#    recent programming languages, is a sequence of little-known research
#    languages developed at Bell Labs, all inspired by the concept of
#    @e(communicating sequential processes) (CSP) from Tony Hoare’s seminal 1978
#    paper on the foundations of concurrency. In CSP, a program is a parallel
#    composition of processes that have no shared state; the processes communicate
#    and synchronize using channels. But Hoare’s CSP was a formal language for
#    describing the fundamental concepts of concurrency, not a programming
#    language for writing executable programs.
   Otro linaje entre los antepasados de Go, y uno que hace a Go distinto entre
   los lenguajes de programacion mas recientes, es una secuencia de lenguajes de
   investigacion poco conocidos desarrollados en los Laboratorios Bell, todos
   ellos inspiradas en el concepto de comunicacion de procesos secuenciales
   (CSP) del seminal articulo de 1978 de Tony Hoare en los cimientos de la
   concurrencia. En CSP, un programa es una composicion paralela de procesos que
   no tienen estado compartido; Los procesos se comunican y sincronizan
   utilizando canales. Pero el CSP de Hoare era un lenguaje formal para
   describir los conceptos fundamentales de la concurrencia, no un lenguaje de
   programacion para escribir programas ejecutables.

#    Rob Pike and others began to experiment with CSP implementations as actual
#    languages. The first was called Squeak (@"(A language for communicating with
#    mice)), which provided a language for handling mouse and keyboard events,
#    with statically created channels. This was followed by Newsqueak, which
#    offered C-like statement and expression syntax and Pascal-like type
#    notation. It was a purely functional language with garbage collection, again
#    aimed at managing keyboard, mouse, and window events. Channels became
#    first-class values, dynamically created and storable in variables.
   Rob Pike y otros comenzaron a experimentar con implementaciones CSP como
   lenguajes reales. El primero fue llamado Squeak (@"(Un Lenguaje para
   comunicarce con ratones)), que proporcionaron un lenguaje para el manejo de
   eventos de raton y teclado, con canales estaticamente creados. Esto fue
   seguido por Newsqueak, que ofrecia declaraciones y sintaxis de expresion como
   C y la notacion de tipo Pascal. Se trataba de un lenguaje puramente funcional
   con recoleccion de basura, dirigido nuevamente a administrar eventos de
   teclado, raton y ventanas. Los canales se convirtieron en valores de primera
   clase, creados dinamicamente y almacenados en variables.

#    The Plan 9 operating system carried these ideas forward in a language called
#    Alef. Alef tried to make Newsqueak a viable system programming language, but
#    its omission of garbage collection made concurrency too painful.
   El sistema operativo Plan 9 llevo adelante estas ideas en un lenguaje llamado
   Alef. Alef trato de hacer de Newsqueak un lenguaje viable para la
   programacion de sistemas, pero su omision de un recoleccion de basura hizo
   que la concurrencia fuera demasiado dolorosa.

#    Other constructions in Go show the influence of non-ancestral genes here and
#    there; for example @c(iota) is loosely from APL, and lexical scope with nested
#    functions is from Scheme (and most languages since). Here too we find novel
#    mutations. Go’s innovative slices provide dynamic arrays with efficient
#    random access but also permit sophisticated sharing arrangements reminiscent
#    of linked lists. And the defer statement is new with Go.
   Otras construcciones en Go muestran la influencia de genes no ancestrales
   aqui y alla; Por ejemplo @c(iota) es tomado libremente de APL, y el ambito
   lexico con funciones anidadas es de Scheme (y la mayoria de lenguajes desde
   entonces). Aqui tambien encontramos mutaciones novedosas. Go innova
   proporcionando slices (arreglos dinamicos) con acceso aleatorio eficiente,
   pero tambien permite sofisticados arreglos compartidos que recuerdan a las
   listas enlazadas. Y la declaracion @c(defer) es con Go.

# ** The Go Project
** El proyecto Go

#    All programming languages reflect the programming philosophy of their
#    creators, which often includes a significant component of reaction to the
#    perceived shortcomings of earlier languages. The Go project was borne of
#    frustration with several software systems at Google that were suffering from
#    an explosion of complexity. (This problem is by no means unique to Google.)
   Todos los lenguajes de programacion reflejan la filosofia de programacion de
   sus creadores, que a menudo incluye un componente significativo de la
   reaccion a las deficiencias percibidas de los idiomas anteriores. El proyecto
   Go fue frustrado con varios sistemas de software de Google que estaban
   sufriendo una explosion de complejidad. (Este problema no es exclusivo de
   Google.)

#    As Rob Pike put it, @"(complexity is multiplicative): fixing a problem by
#    making one part of the system more complex slowly but surely adds complexity
#    to other parts. With constant pressure to add features and options and
#    configurations, and to ship code quickly, it’s easy to neglect simplicity,
#    even though in the long run simplicity is the key to good software.
   Como Rob Pike dijo, @"(la complejidad es multiplicativa): solucionar un
   problema al hacer una parte del sistema mas compleja, lenta pero seguramente
   añade complejidad a otras partes. Con la presion constante para agregar
   caracteristicas y opciones y configuraciones, y para enviar codigo
   rapidamente, es facil olvidar la sencillez, aunque a la larga la simplicidad
   es la clave para un buen software.

#    Simplicity requires more work at the beginning of a project to reduce an idea
#    to its essence and more discipline over the lifetime of a project to
#    distinguish good changes from bad or pernicious ones. With sufficient effort,
#    a good change can be accommodated without compromising what Fred Brooks
#    called the @"(conceptual integrity) of the design but a bad change cannot,
#    and a pernicious change trades simplicity for its shallow cousin,
#    convenience. Only through simplicity of design can a system remain stable,
#    secure, and coherent as it grows.
   La simplicidad requiere mas trabajo al comienzo de un proyecto para reducir
   una idea a su esencia y mas disciplina durante la vida de un proyecto para
   distinguir los buenos cambios, de los malos o perniciosos. Con un esfuerzo
   suficiente, un buen cambio se puede acomodar sin comprometer lo que Fred
   Brooks llamo la @"(integridad conceptual) del diseño, pero un mal cambio no
   puede, un cambio pernicioso negocia la sencillez por uno conveniencia
   superficial. Solo a traves de la simplicidad del diseño un sistema puede
   permanecer estable, seguro y coherente a medida que crece.

#    The Go project includes the language itself, its tools and standard
#    libraries, and last but not least, a cultural agenda of radical
#    simplicity. As a recent high-level language, Go has the benefit of hindsight,
#    and the basics are done well: it has garbage collection, a package system,
#    firstclass functions, lexical scope, a system call interface, and immutable
#    strings in which text is generally encoded in UTF-8. But it has comparatively
#    few features and is unlikely to add more. For instance, it has no implicit
#    numeric conversions, no constructors or destructors, no operator overloading,
#    no default parameter values, no inheritance, no generics, no exceptions, no
#    macros, no function annotations, and no thread-local storage. The language is
#    mature and stable, and guarantees backwards compatibility: older Go programs
#    can be compiled and run with newer versions of compilers and standard
#    libraries.
   El proyecto Go incluye el lenguaje mismo, sus herramientas y librerias
   estandar, y por ultimo, pero no menos importante, una agenda cultural de
   simplicidad radical. Como un lenguaje reciente de alto nivel, Go tiene el
   beneficio de la retrospectiva, y los fundamentos se hacen bien: tiene
   recoleccion de basura, un sistema de paquetes, funciones de primera clase,
   alcance lexico, una interfaz de llamadas de sistema y cadenas inmutables en
   las que el texto es generalmente codificado en UTF-8. Pero tiene
   comparativamente pocas caracteristicas y es poco probable que agregue
   mas. Por ejemplo, no tiene conversiones numericas implicitas, no hay
   constructores o destructores, no hay sobrecarga de operadores, no hay valores
   de parametros predeterminados, no hay herencia, no hay genericos, no hay
   excepciones, no hay macros, no hay anotaciones de funcion y no hay
   almacenamiento local de subprocesos. El lenguaje es maduro y estable y
   garantiza la compatibilidad con versiones anteriores: los programas Go mas
   antiguos se pueden compilar y ejecutar con versiones mas recientes de
   compiladores y librerias estandar.

#    Go has enough of a type system to avoid most of the careless mistakes that
#    plague programmers in dynamic languages, but it has a simpler type system
#    than comparable typed languages.  This approach can sometimes lead to
#    isolated pockets of @"(untyped) programming within a broader framework of
#    types, and Go programmers do not go to the lengths that C++ or Haskell
#    programmers do to express safety properties as type-based proofs. But in
#    practice Go gives programmers much of the safety and run-time performance
#    benefits of a relatively strong type system without the burden of a complex
#    one.
   Go tiene un sistema de tipado para evitar la mayoria de los errores
   descuidados que afectan a los programadores en lenguajes dinamicos, pero
   tiene un sistema de tipado mas simple que los lenguajes tipados
   comparables. Este enfoque puede conducir en ocaciones a baches de
   programacion @"(sin tipo) dentro de un marco mas amplio de tipos, y los
   programadores Go no van a las longitudes que hacen a los programadores C++ o
   Haskell expresar propiedades de seguridad como pruebas basadas en tipo. Pero
   en la practica, Go da a los programadores gran parte de los beneficios de
   seguridad y rendimiento en tiempo de ejecucion de un sistema de tipado
   relativamente fuerte sin la carga de complejidad.

#    Go encourages an awareness of contemporary computer system design,
#    particularly the importance of locality. Its built-in data types and most
#    library data structures are crafted to work naturally without explicit
#    initialization or implicit constructors, so relatively few memory allocations
#    and memory writes are hidden in the code. Go’s aggregate types (structs and
#    arrays) hold their elements directly, requiring less storage and fewer
#    allocations and pointer indirections than languages that use indirect
#    fields. And since the modern computer is a parallel machine, Go has
#    concurrency features based on CSP, as mentioned earlier. The variablesize
#    stacks of Go’s lightweight threads or goroutines are initially small enough
#    that creating one goroutine is cheap and creating a million is practical.
   Go fomenta una conciencia del diseño de sistemas informaticos contemporaneos,
   particularmente la importancia de la localidad. Sus tipos de datos
   incorporados y la mayoria de las estructuras de datos de la libreria estan
   diseñados para funcionar naturalmente sin inicializacion explicita o
   constructores implicitos, por lo que relativamente pocas asignaciones de
   memoria y escrituras de memoria estan ocultas en el codigo. Los tipos
   agregados de Go (estructuras y matrices) mantienen sus elementos
   directamente, requiriendo menos almacenamiento y menos asignaciones e
   indireccion de punteros, que los idiomas que utilizan campos indirectos. Y
   como la computadora moderna es una maquina paralela, Go tiene caracteristicas
   de concurrencia basadas en CSP, como se menciono anteriormente. Los stacs de
   tamaño variable de los hilos ligeros de Go o @e(goroutines) son inicialmente
   lo suficientemente pequeñas como para que crear una goroutine sea barato y
   crear un millon sea practico.

#    Go’s standard library, often described as coming with @"(batteries included,)
#    provides clean building blocks and APIs for I/O, text processing, graphics,
#    cryptography, networking, and distributed applications, with support for many
#    standard file formats and protocols. The libraries and tools make extensive
#    use of convention to reduce the need for configuration and explanation, thus
#    simplifying program logic and making diverse Go programs more similar to each
#    other and thus easier to learn. Projects built using the go tool use only
#    file and identifier names and an occasional special comment to determine all
#    the libraries, executables, tests, benchmarks, examples, platform-specific
#    variants, and documentation for a project; the Go source itself contains the
#    build specification.
   La libreria estandar de Go, a menudo descrita como con @"(baterias
   incluidas,) proporciona bloques de construccion limpios y APIs de E/S,
   procesamiento de texto, graficos, criptografia, redes y aplicaciones
   distribuidas, con soporte para muchos formatos de archivos y protocolos
   estandar. Las librerias y las herramientas hacen uso extensivo de la
   convencion para reducir la necesidad de configuracion y explicaciones,
   simplificando asi la logica del programa y haciendo que diversos programas Go
   sean mas similares entre si y, por lo tanto, mas faciles de aprender. Los
   proyectos creados con la herramienta @$(go) solo utilizan nombres de archivos
   e identificadores y un comentario especial ocasional para determinar todas
   las librerias, ejecutables, pruebas, referencias, ejemplos, variantes
   especificas de la plataforma y documentacion para un proyecto; El codigo
   fuente de Go en si contiene la especificacion de compilacion.

# ** Organization of the Book
** Organizacion del Libro

#    We assume that you have programmed in one or more other languages, whether
#    compiled like C, C++, and Java, or interpreted like Python, Ruby, and
#    JavaScript, so we won’t spell out everything as if for a total
#    beginner. Surface syntax will be familiar, as will variables and constants,
#    expressions, control flow, and functions.
   Asumimos que usted ha programado en uno o mas lenguajes, compilados como C,
   C++ y Java, o interpretados como Python, Ruby y JavaScript, por lo que no
   solemos explicar todo como si fuera un completo principiante. La sintaxis
   superficial sera familiar, al igual que variables y constantes, expresiones,
   flujo de control y funciones.

#    Chapter 1 is a tutorial on the basic constructs of Go, introduced through a
#    dozen programs for everyday tasks like reading and writing files, formatting
#    text, creating images, and communicating with Internet clients and servers.
   El capitulo 1 es un tutorial sobre las construcciones basicas de Go,
   introducido a traves de una docena de programas para tareas cotidianas como
   leer y escribir archivos, formatear texto, crear imagenes y comunicarse con
   clientes y servidores de Internet.

#    Chapter 2 describes the structural elements of a Go program—declarations,
#    variables, new types, packages and files, and scope. Chapter 3 discusses
#    numbers, booleans, strings, and constants, and explains how to process
#    Unicode. Chapter 4 describes composite types, that is, types built up from
#    simpler ones using arrays, maps, structs, and slices, Go’s approach to
#    dynamic lists. Chapter 5 covers functions and discusses error handling,
#    @c(panic) and @c(recover), and the @c(defer) statement.
   El capitulo 2 describe los elementos estructurales de un programa
   Go–declaraciones, variables, nuevos tipos, paquetes y archivos, y alcance. El
   capitulo 3 analiza numeros, booleanos, cadenas y constantes, y explica como
   procesar Unicode. El capitulo 4 describe los tipos compuestos, es decir, los
   tipos construidos a partir de los mas sencillos utilizando arreglos, mapas,
   estructuras y slices, la aproximacion de Go para listas dinamicas. El
   capitulo 5 cubre las funciones y discute el manejo de errores,
   @c(panic) y @c(recover), y la sentencia @c(defer).

#    Chapters 1 through 5 are thus the basics, things that are part of any
#    mainstream imperative language. Go’s syntax and style sometimes differ from
#    other languages, but most programmers will pick them up quickly. The
#    remaining chapters focus on topics where Go’s approach is less conventional:
#    methods, interfaces, concurrency, packages, testing, and reflection.
   Los capitulos 1 a 5 son, son por lo tanto, lo basico, las cosas que forman
   parte de cualquier lenguaje imperativo popular. La sintaxis y el estilo de Go
   a veces difieren de otros lenguajes, pero la mayoria de los programadores los
   recogeran rapidamente. Los capitulos restantes se centran en temas en los que
   el enfoque de Go es menos convencional: metodos, interfaces, concurrencia,
   paquetes, pruebas y reflexion.

#    Go has an unusual approach to object-oriented programming. There are no class
#    hierarchies, or indeed any classes; complex object behaviors are created from
#    simpler ones by composition, not inheritance. Methods may be associated with
#    any user-defined type, not just structures, and the relationship between
#    concrete types and abstract types (@e(interfaces)) is implicit, so a concrete
#    type may satisfy an interface that the type’s designer was unaware
#    of. Methods are covered in Chapter 6 and interfaces in Chapter 7.
   Go tiene un acercamiento inusual a la programacion orientada a objetos. No
   hay jerarquias de clase, o de hecho ninguna clase; Los comportamientos de
   objetos complejos se crean a partir de los mas simples por composicion, no
   por herencia. Los metodos pueden ser asociados con cualquier tipo definido
   por el usuario, no solo las estructuras, y la relacion entre tipos concretos
   y tipos abstractos (@e(interfaces)) es implicita, por lo que un tipo concreto
   puede satisfacer una interfaz que el diseñador del tipo desconocia. Los
   metodos estan cubiertos en el capitulo 6, las interfaces en el capitulo 7.

#    Chapter 8 presents Go’s approach to concurrency, which is based on the idea
#    of communicating sequential processes (CSP), embodied by goroutines and
#    channels. Chapter 9 explains the more traditional aspects of concurrency
#    based on shared variables.
   El capitulo 8 presenta el enfoque de Go a la concurrencia, que se basa en la
   idea de comunicar procesos secuenciales (CSP), incorporados por goroutines y
   canales. El Capitulo 9 explica los aspectos mas tradicionales de la
   concurrencia basados ​​en variables compartidas.

#    Chapter 10 describes packages, the mechanism for organizing libraries. This
#    chapter also shows how to make effective use of the @$(go) tool, which
#    provides for compilation, testing, benchmarking, program formatting,
#    documentation, and many other tasks, all within a single command.
   El capitulo 10 describe los paquetes, el mecanismo para organizar las
   librerias. Este capitulo tambien muestra como hacer un uso efectivo de la
   herramienta @$(go), provista para la compilacion, pruebas, benchmarking,
   formateo del programa, documentacion y muchas otras tareas, todo dentro de un
   solo comando.

#    Chapter 11 deals with testing, where Go takes a notably lightweight approach,
#    avoiding abstraction-laden frameworks in favor of simple libraries and
#    tools. The testing libraries provide a foundation atop which more complex
#    abstractions can be built if necessary.
   El capitulo 11 trata de las pruebas, donde Go adopta un enfoque notablemente
   ligero, evitando framewoks cargados de abstraccion en favor de librerias y
   herramientas simples. Las librerias de pruebas proporcionan una base sobre
   la que se pueden construir abstracciones mas complejas si es necesario.

#    Chapter 12 discusses reflection, the ability of a program to examine its own
#    representation during execution. Reflection is a powerful tool, though one to
#    be used carefully; this chapter explains finding the right balance by showing
#    how it is used to implement some important Go libraries. Chapter 13 explains
#    the gory details of low-level programming that uses the @c(unsafe) package to
#    step around Go’s type system, and when that is appropriate.
   El capitulo 12 discute la reflexion, la capacidad de un programa para
   examinar su propia representacion durante la ejecucion. La reflexion es una
   herramienta poderosa, aunque debe ser usada con cuidado; Este capitulo
   explica como encontrar el equilibrio correcto, mostrando como se utiliza para
   implementar algunas librerias importantes en Go. El capitulo 13 explica los
   detalles morbosos de programacion a bajo nivel que utiliza el paquete
   @c(unsafe) para dar un paso alrededor del sistema de tipado de Go, y cuando
   es apropiada eso.

#    Each chapter has a number of exercises that you can use to test your
#    understanding of Go, and to explore extensions and alternatives to the
#    examples from the book.
   Cada capitulo tiene una serie de ejercicios que puedes usar para probar tu
   comprension de Go, y para explorar extensiones y alternativas a los ejemplos
   del libro.

#    All but the most trivial code examples in the book are available for download
#    from the public Git repository at @l(http://www.gopl.io/<>gopl.io). Each
#    example is identified by its package import path and may be conveniently
#    fetched, built, and installed using the @$(go get) command. You’ll need to
#    choose a directory to be your Go workspace and set the @c(GOPATH) environment
#    variable to point to it.  The go tool will create the directory if
#    necessary. For example:
   Todos menos los ejemplos de codigo mas triviales en el libro estan
   disponibles para su descarga desde un repositorio Git publico en
   @l(http://www.gopl.io/<>gopl.io). Cada ejemplo se identifica por su ruta de
   importacion paquete y puede ser convenientemente localizado, construido e
   instalado utilizando el comando @$(go get). tendra que elegir un directorio
   para ser su espacio de trabajo y establecer la variable de entorno @c(GOPATH)
   apuntando a este. La herramienta @$(go) creara el directorio si es necesario.
   Por ejemplo:

#    ..src > sh
#      $ export GOPATH=$HOME/gobook        # choose workspace directory
#      $ go get gopl.io/ch1/helloworld     # fetch, build, install
#      $ $GOPATH/bin/helloworld            # run
#      Hello, 世界
#    < src..
   ..src > sh
     $ export GOPATH=$HOME/gobook        # Elegir el directorio de trabajo
     $ go get gopl.io/ch1/helloworld     # buscar, construir, instalar
     $ $GOPATH/bin/helloworld            # ejecutar
     Hello, 世界
   < src..

#    To run the examples, you will need at least version 1.5 of Go.
   Para ejecutar los ejemplos, necesitara al menos la version 1.5 de Go.

#    ..src > sh
#      $ go version
#      go version go1.5 linux/amd64
#    < src..
   ..src > sh
     $ go version
     go version go1.5 linux/amd64
   < src..

#    Follow the instructions at @l(https://golang.org/doc/install) if the go tool
#    on your computer is older or missing.
   Siga las instrucciones en @l(https://golang.org/doc/install) si en su equipo
   la herramienta @$(go) esta ausente o es anterior.

# ** Where to Find More Information
** Donde encontrar mas informacion

#    The best source for more information about Go is the official web site,
#    @l(https://golang.org), which provides access to the documentation, including
#    the @e(Go Programming Language Specification), standard packages, and the
#    like. There are also tutorials on how to write Go and how to write it well,
#    and a wide variety of online text and video resources that will be valuable
#    complements to this book. The Go Blog at @l(https://blog.golang.org<>blog.golang.org)
#    publishes some of the best writing on Go, with articles on the state of the
#    language, plans for the future, reports on conferences, and in-depth
#    explanations of a wide variety of Go-related topics.
   La mejor fuente para obtener mas informacion sobre Go es el sitio web
   oficial, @l(https://golang.org) , que proporciona acceso a la documentacion,
   incluyendo la @e(Especificacion del Lenguaje de Programacion Go), los
   paquetes estandar, y similares. Tambien hay tutoriales sobre como escribir Go
   y como escribirlo bien, y una amplia variedad de recursos de texto y video en
   linea que seran complementos valiosos para este libro. El Blog de Go se
   encuentra en @l(https://blog.golang.org<>blog.golang.org) donde se publican
   algunos de los mejores escritos en Go, con articulos sobre el estado del
   lenguaje, los planes a futuro, los informes sobre conferencias y
   explicaciones en profundidad de una amplia variedad de temas relacionados.

#    One of the most useful aspects of online access to Go (and a regrettable
#    limitation of a paper book) is the ability to run Go programs from the web
#    pages that describe them. This functionality is provided by the Go Playground
#    at @l(https://play.golang.org<>play.golang.org), and may be embedded within
#    other pages, such as the home page at @l(https://golang.org<>golang.org) or
#    the documentation pages served by the godoc tool.
   Uno de los aspectos mas utiles del acceso en linea a Go (y una limitacion
   lamentable de un libro de papel) es la capacidad de ejecutar programas de Go
   desde las paginas web que los describen. Esta funcionalidad es proporcionada
   por Go Playground en @l(https://play.golang.org<>play.golang.org), y puede
   ser embebido dentro de otras paginas, como la pagina de inicio en
   @l(https://golang.org<>golang.org) o las paginas de documentacion provistas
   por la herramienta @$(godoc).

#    The Playground makes it convenient to perform simple experiments to check
#    one’s understanding of syntax, semantics, or library packages with short
#    programs, and in many ways takes the place of a @e(read-eval-print loop)
#    (REPL) in other languages. Its persistent URLs are great for sharing snippets
#    of Go code with others, for reporting bugs or making suggestions.
   Playground hace que sea conveniente llevar a cabo experimentos sencillos para
   comprobar la propia comprension de la sintaxis, la semantica, o paquetes de
   librerias con programas cortos, y en muchos sentidos toma el lugar de un
   @e(bucle leer-evaluar-imprimir) (@e(read-eval-print loop) o REPL) en otros
   lenguajes. Sus URLs persistentes son ideales para compartir fragmentos de
   codigo con otros, para informar sobre errores o hacer sugerencias.

#    Built atop the Playground, the Go Tour at @l(https://tour.golang.org<>tour.golang.org)
#    is a sequence of short interactive lessons on the basic ideas and
#    constructions of Go, an orderly walk through the language.
   Construido sobre Playground, el Tour Go en @l(https://tour.golang.org<>tour.golang.org)
   es una secuencia de breves lecciones interactivas sobre las ideas basicas y
   construcciones de Go, un paseo ordenado por atraves del lenguaje.

#    The primary shortcoming of the Playground and the Tour is that they allow
#    only standard libraries to be imported, and many library features—networking,
#    for example—are restricted for practical or security reasons. They also
#    require access to the Internet to compile and run each program. So for more
#    elaborate experiments, you will have to run Go programs on your own
#    computer. Fortunately the download process is straightforward, so it should
#    not take more than a few minutes to fetch the Go distribution from @l(https://golang.org<>golang.org)
#    and start writing and running Go programs of your own.
   El principal inconveniente del Playground y del Tour es que permiten que solo
   se importen librerias estandar, y muchas funciones de la libreria–por
   ejemplo, redes–estan restringidas por razones practicas o de
   seguridad. Tambien requiere de acceso a Internet para compilar y ejecutar
   cada programa. Asi que para experimentos mas elaborados, tendra que ejecutar
   programas Go en su propia computadora. Afortunadamente, el proceso de
   descarga es sencillo, por lo que no debe tomar mas de unos minutos para
   buscar la Go distribucion desde @l(https://golang.org<>golang.org) y empezar
   a escribir y ejecutar programas por su cuenta.

#    Since Go is an open-source project, you can read the code for any type or
#    function in the standard library online at @l(https://golang.org/pkg); the
#    same code is part of the downloaded distribution. Use this to figure out how
#    something works, or to answer questions about details, or merely to see how
#    experts write really good Go.
   Ya que Go es un proyecto de codigo abierto, se puede leer el codigo fuente de
   cualquier tipo o funcion en la libreria estandar en
   @l(https://golang.org/pkg); el mismo codigo forma parte de la distribucion
   descargada. Utilice esto para averiguar como funciona algo, o para responder
   a preguntas sobre los detalles, o simplemente para ver como los expertos
   escriben bueno Go.

# ** Acknowledgments
** Agradecimientos

#    Rob Pike and Russ Cox, core members of the Go team, read the manuscript
#    several times with great care; their comments on everything from word choice
#    to overall structure and organization have been invaluable. While preparing
#    the Japanese translation, Yoshiki Shibata went far beyond the call of duty;
#    his meticulous eye spotted numerous inconsistencies in the English text and
#    errors in the code. We greatly appreciate thorough reviews and critical
#    comments on the entire manuscript from Brian Goetz, Corey Kosak, Arnold
#    Robbins, Josh Bleecher Snyder, and Peter Weinberger.
   Rob Pike y Russ Cox, miembros centrales del equipo de Go, leyeron el
   manuscrito varias veces con mucho cuidado; Sus comentarios sobre todo, desde
   la eleccion de palabras hasta la estructura general y la organizacion han
   sido invaluables. Mientras preparaba la traduccion japonesa, Yoshiki Shibata
   iba mucho mas alla del llamado del deber; Su ojo meticuloso observo numerosas
   inconsistencias en el texto ingles y errores en el codigo. Apreciamos
   grandemente revisiones completas y comentarios criticos en el manuscrito
   entero de Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, y
   Peter Weinberger.

#    We are indebted to Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy
#    Donohue, Jonathan Feinberg, Andrew Gerrand, Robert Griesemer, John Linderman,
#    Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth,
#    Nigel Tao, and Howard Trickey for many helpful suggestions. We also thank
#    David Brailsford and Raph Levien for typesetting advice.
   Agradecemos a Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue,
   Jonathan Feinberg, Andrew Gerrand, Roberto Griesemer, John Linderman, Minux
   Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao,
   y a Howard Trickey para muchas sugerencias utiles. Tambien damos las gracias
   a David Brailsford y Raph Levien por los consejos sobre composicion
   tipografica.

#    Our editor Greg Doench at Addison-Wesley got the ball rolling originally and
#    has been continuously helpful ever since. The AW production team—John Fuller,
#    Dayna Isley, Julie Nahil, Chuti Prasertsith, and Barbara Wood—has been
#    outstanding; authors could not hope for better support.
   Nuestro redactor Greg Doench de Addison-Wesley consiguio hacer rodar la bola
   originalmente y ha estado ayunando continuamente desde entonces. El equipo de
   produccion de AW–John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith y
   Barbara Wood–ha sido excepcional; Los autores no podrian esperar un mejor
   apoyo.

#    Alan Donovan wishes to thank: Sameer Ajmani, Chris Demetriou, Walt Drummond,
#    and Reid Tatge at Google for allowing him time to write; Stephen Donovan, for
#    his advice and timely encouragement; and above all, his wife Leila Kazemi,
#    for her unhesitating enthusiasm and unwavering support for this project,
#    despite the long hours of distraction and absenteeism from family life that
#    it entailed.
   Alan Donovan desea agradecer a: Sameer Ajmani, Chris Demetriou, Walt
   Drummond, y Reid Tatge en Google por permitirle tiempo para escribir; Stephen
   Donovan, por su consejo y oportuno estimulo; Y sobre todo a su esposa Leila
   Kazemi, por su entusiasmo y apoyo inquebrantable a este proyecto, a pesar de
   las largas horas de distraccion y ausentismo de la vida familiar que ello
   conllevaba.

#    Brian Kernighan is deeply grateful to friends and colleagues for their
#    patience and forbearance as he moved slowly along the path to understanding,
#    and especially to his wife Meg, who has been unfailingly supportive of
#    book-writing and so much else.
   Brian Kernighan esta profundamente agradecido a sus amigos y colegas por su
   paciencia y autodominio mientras avanzaba lentamente por el camino hacia la
   comprension, y especialmente a su esposa Meg, que ha sido infaliblemente
   favorable a la escritura de libros y mucho mas.

#    ..quote >
#      -- New York
#      -- October 2015
#    < quote..
   ..quote >
     --Nueva York
     --Octubre 2015
   < quote..

# * Chapter 1 <> Tutorial
* Capitulo 1 <> Tutorial

#   This chapter is a tour of the basic components of Go. We hope to provide
#   enough information and examples to get you off the ground and doing useful
#   things as quickly as possible. The examples here, and indeed in the whole
#   book, are aimed at tasks that you might have to do in the real world. In this
#   chapter we’ll try to give you a taste of the diversity of programs that one
#   might write in Go, ranging from simple file processing and a bit of graphics
#   to concurrent Internet clients and servers. We certainly won’t explain
#   everything in the first chapter, but studying such programs in a new language
#   can be an effective way to get started.
  Este capitulo es un recorrido por los componentes basicos de Go. Esperamos
  proporcionar suficiente informacion y ejemplos para sacarle del barro y hacer
  cosas utiles lo mas rapido posible. Los ejemplos aqui, y de hecho en todo el
  libro, estan dirigidos a tareas que usted podria tener que hacer en el mundo
  real. En este capitulo intentaremos darle una muestra de la diversidad de
  programas que uno podria escribir en Go, que van desde el simple procesamiento
  de archivos y un poco de graficos, a clientes y servidores de Internet
  concurrentes. Ciertamente no vamos a explicar todo en el primer capitulo, pero
  el estudio de estos programas en un nuevo lenguaje puede ser una manera eficaz
  de empezar.

#   When you’re learning a new language, there’s a natural tendency to write code
#   as you would have written it in a language you already know. Be aware of this
#   bias as you learn Go and try to avoid it. We’ve tried to illustrate and
#   explain how to write good Go, so use the code here as a guide when you’re
#   writing your own.
  Cuando estas aprendiendo un nuevo lenguaje, hay una tendencia natural a
  escribir codigo como lo habrias escrito en un idioma que ya conoces. Este
  consciente de este sesgo a medida que aprende Go y trate de evitarlo. Hemos
  tratado de ilustrar y explicar como escribir buen Go, asi que utilice el
  codigo aqui como guia cuando este escribiendo el suyo propio.

# ** Section 1.1 <> Hello, World
** Seccion 1.1 <> Hola, Mundo

#    We’ll start with the now-traditional @"(hello, world) example, which appears
#    at the beginning of @e(The C Programming Language), published in 1978. C is
#    one of the most direct influences on Go, and @"(hello, world) illustrates a
#    number of central ideas.
   Vamos a empezar con la ya tradicional ejemplo del @"(hola, mundo), que
   aparece al comienzo de @e(El lenguaje de programacion C), publicado
   en 1978. C es una de las influencias mas directas sobre el Go, y @"(hola,
   mundo) ilustra una serie de ideas centrales.

#    ..figure > @l(gopl.io/ch1/helloworld/main.go<>gopl.io/ch1/helloworld)
   ..figure > @l(gopl.io/ch1/helloworld/main.go<>gopl.io/ch1/helloworld)

#      ..src > go
#        package main
#
#        import "fmt"
#
#        func main() {
#          fmt.Println("Hello, 世界")
#        }
#      < src..
     ..src > go
       package main

       import "fmt"

       func main() {
         fmt.Println("Hello, 世界")
       }
     < src..

#    Go is a compiled language. The Go toolchain converts a source program and the
#    things it depends on into instructions in the native machine language of a
#    computer. These tools are accessed through a single command called @$(go)
#    that has a number of subcommands. The simplest of these subcommands is
#    @$(run), which compiles the source code from one or more source files whose
#    names end in @f(.go), links it with libraries, then runs the resulting
#    executable file.  (We will use @$($) as the command prompt throughout the
#    book.)
   Go es un lenguaje compilado. El conjunto de herramienta de Go convierte un el
   codigo fuente de un programa y las cosas de las que depende, en instrucciones
   en el lenguaje maquina nativo de una computadora. Se puede acceder a estas
   herramientas a traves de un unico comando llamado @$(go) que tiene una serie
   de subcomandos. El mas simple de estos subcomandos es @$(run) , que compila
   el codigo fuente de uno o mas archivos de origen cuyos nombres terminan en
   @f(.go), lo vincula con las librerias, y a continuacion, ejecuta el archivo
   ejecutable resultante. (Utilizaremos @$($) como el simbolo del sistema en
   todo el libro.)

#    ..src > sh
#      $ go run helloworld.go
#    < src..
   ..src > sh
     $ go run helloworld.go
   < src..

#    Not surprisingly, this prints
   No es sorprendente que esto imprima

#    ..src > sh
#      Hello, 世界
#    < src..
   ..src > sh
     Hello, 世界
   < src..


#    Go natively handles Unicode, so it can process text in all the world’s languages.
   Go maneja Unicode de forma nativa, por lo que puede procesar texto en todos
   los idiomas del mundo.

#    If the program is more than a one-shot experiment, it’s likely that you would
#    want to compile it once and save the compiled result for later use. That is
#    done with @$(go build):
   Si el programa es mas que un experimento de un solo disparo, es probable que
   quiera compilarlo una vez y guardar el resultado compilado para su uso
   posterior. Esto se hace con @$(go build):

#    ..src > sh
#      $ go build helloworld.go
#    < src..
   ..src > sh
     $ go build helloworld.go
   < src..

#    This creates an executable binary file called @$(helloworld) that can be run
#    any time without further processing:
   Esto crea un archivo binario ejecutable llamado @$(helloworld) que se pueden
   ejecutar en cualquier momento sin procesamiento adicional:

#    ..src > sh
#      $ ./helloworld
#      Hello, 世界
#    < src..
   ..src > sh
     $ ./helloworld
     Hello, 世界
   < src..

#    We have labeled each significant example as a reminder that you can obtain
#    the code from the book’s source code repository at
#    @l(http://www.gopl.io/<>(gopl.io): @l(http://www.gopl.io/ch1/helloworld<>gopl.io/ch1/helloworld)
   Hemos etiquetado cada ejemplo significativo como un recordatorio de que
   puede obtener el codigo fuente del libro desde el repositorio en
   @l(http://www.gopl.io/<>(gopl.io): @l(http://www.gopl.io/ch1/helloworld<>gopl.io/ch1/helloworld)

#    If you run @$(go get gopl.io/ch1/helloworld), it will fetch the source code
#    and place it in the corresponding directory. There’s more about this topic in
#    @l(#Section 2.6) and @l(#Section 10.7).
   Si ejecuta @$(go get gopl.io/ch1/helloworld), se obtendra el codigo fuente y
   lo coloca en el directorio correspondiente. Hay mas informacion sobre este
   tema en la @l(#Seccion 2.6) y la @l(#Seccion 10.7).

#    Let’s now talk about the program itself. Go code is organized into packages,
#    which are similar to libraries or modules in other languages. A package
#    consists of one or more @f(.go) source files in a single directory that
#    define what the package does. Each source file begins with a package
#    declaration, here @c(package main), that states which package the file
#    belongs to, followed by a list of other packages that it imports, and then
#    the declarations of the program that are stored in that file.
   Hablemos ahora del programa en si. El codigo Go esta organizado en paquetes,
   que son similares a librerias o modulos en otros lenguajes. Un paquete se
   compone de uno o mas archivos de codigo @f(.go) en un unico directorio que
   definen lo que hace el paquete. Cada archivo de codigo inicia con una
   declaracion del paquete, aqui es @c(package main), que declara a que paquete
   pertenece el archivo, seguido de una lista de otros paquetes que importa, y
   luego las declaraciones del programa que se almacena en el archivo.

#    The Go standard library has over 100 packages for common tasks like input and
#    output, sorting, and text manipulation. For instance, the @c(fmt) package
#    contains functions for printing formatted output and scanning input.
#    @c(Println) is one of the basic output functions in @c(fmt); it prints one or
#    more values, separated by spaces, with a newline character at the end so that
#    the values appear as a single line of output.
   La libreria estandar de Go tiene mas de 100 paquetes para tareas comunes como
   entrada y salida, clasificacion y manipulacion de texto. Por ejemplo, el
   paquete @c(fmt) contiene funciones para la impresion y entrada de datos con
   formato. @c(Println) es una de las funciones de basicas de salida en @c(fmt);
   esta imprime uno o mas valores, separados por espacios, con un caracter de
   nueva linea al final para que los valores aparezcan como una sola linea de
   salida.

#    Package @c(main) is special. It defines a standalone executable program, not
#    a library. Within package @c(main) the @e(function) @c(main) is also
#    special—it’s where execution of the program begins.  Whatever @c(main) does
#    is what the program does. Of course, @c(main) will normally call upon
#    functions in other packages to do much of the work, such as the function
#    @c(fmt.Println).
   El paquete @c(main) es especial. Define un programa ejecutable independiente,
   no una libreria. Dentro del paquete @c(main) la @e(funcion) @c(main) tambien
   es especial–es donde comienza la ejecucion del programa. Cualquier cosa que
   haga @c(main) es lo que hara el programa. Por supuesto, @c(main) sera
   normalmente un llamado a las funciones de otros paquetes que hacen gran parte
   del trabajo, tales como la funcion @c(fmt.Println).

#    We must tell the compiler what packages are needed by this source file;
#    that’s the role of the @c(import) declaration that follows the @c(package)
#    declaration. The @"(hello, world) program uses only one function from one
#    other package, but most programs will import more packages.
   Debemos decirle al compilador que paquetes son necesarios por este archivo de
   codigo fuente; ese es el papel de la declaracion @c(import) seguida por la
   declaracion del @c(paquete). El programa @"(hola, mundial) utiliza solo una
   funcion de otro paquete, pero en la mayoria de los programas se importaran
   mas paquetes.

#    You must import exactly the packages you need. A program will not compile if
#    there are missing imports or if there are unnecessary ones. This strict
#    requirement prevents references to unused packages from accumulating as
#    programs evolve.
   Debe importar exactamente los paquetes que necesita. Un programa no compilara
   si hay importaciones que faltan o si son innecesarias. Este estricto
   requisito impide que las referencias a paquetes no utilizados se acumulen a
   medida que los programas evolucionan.

#    The @c(import) declarations must follow the @c(package) declaration. After
#    that, a program consists of the declarations of functions, variables,
#    constants, and types (introduced by the keywords @c(func), @c(var),
#    @c(const), and @c(type)); for the most part, the order of declarations does
#    not matter. This program is about as short as possible since it declares only
#    one function, which in turn calls only one other function. To save space, we
#    will sometimes not show the @c(package) and @c(import) declarations when
#    presenting examples, but they are in the source file and must be there to
#    compile the code.
   Las declaraciones @c(import) deben ir luego de la declaracion
   @c(package). Despues de eso, un programa consiste en la declaracion de
   funciones, variables, constantes y tipos (introducidos por las palabras clave
   @c(func), @c(var), @c(const), y @c(type)); En su mayor parte, el orden de las
   declaraciones no importa. Este programa es lo mas corto posible, ya que
   declara solo una funcion, que a su vez solo llama a otra funcion. Para
   ahorrar espacio en la presentacion de ejemplos, a veces no mostramos las
   declaraciones @c(package) e @c(import), pero estaran en el codigo del archivo
   y debemos estar alli para compilar el codigo.

#    A function declaration consists of the keyword @c(func), the name of the
#    function, a parameter list (empty for @c(main)), a result list (also empty
#    here), and the body of the function—the statements that define what it
#    does—enclosed in braces. We’ll take a closer look at functions in @l(#Chapter
#    5).
   Una declaracion de funcion consiste en la palabra clave @c(func), el nombre
   de la funcion, una lista de parametros (vacia para @c(main)), una lista de
   resultados (aqui tambien vacia), y el cuerpo de la funcion–las declaraciones
   que definen lo que hace–encerradas entre llaves. Vamos a echar un vistazo mas
   de cerca a las funciones en el @l(#Capitulo 5).

#    Go does not require semicolons at the ends of statements or declarations,
#    except where two or more appear on the same line. In effect, newlines
#    following certain tokens are converted into semicolons, so where newlines are
#    placed matters to proper parsing of Go code. For instance, the opening brace
#    @c({) of the function must be on the same line as the end of the @c(func)
#    declaration, not on a line by itself, and in the expression @c(x + y), a newline
#    is permitted after but not before the @c(+) operator.
   Go no requiere punto y coma al final de las sentencias o declaraciones,
   excepto donde aparecen dos o mas en la misma linea. En efecto, las nuevas
   lineas que siguen ciertas palabras se convierten en punto y coma, por lo que
   cuando se colocan nuevas lineas se colocan en funcion del correcto analisis
   del codigo Go. Por ejemplo, la llave de apertura @c({) de la funcion, debe
   estar en la misma linea, que el final de la declaracion @c(func), no en una
   linea distinta, y en la expresion @c(x + y), se permite un salto de linea
   despues, pero no antes del operador @c(+).

#    Go takes a strong stance on code formatting. The @$(gofmt) tool rewrites code
#    into the standard format, and the @$(go) tool’s @$(fmt) subcommand applies
#    @$(gofmt) to all the files in the specified package, or the ones in the
#    current directory by default. All Go source files in the book have been run
#    through @$(gofmt), and you should get into the habit of doing the same for
#    your own code.  Declaring a standard format by fiat eliminates a lot of
#    pointless debate about trivia and, more importantly, enables a variety of
#    automated source code transformations that would be infeasible if arbitrary
#    formatting were allowed.
   Go toma una fuerte postura en el formato del codigo. La herramienta @$(gofmt)
   reescribe el codigo en el formato estandar, y el subcomando @$(fmt) de la
   herramienta @$(go) aplica @$(gofmt) a todos los archivos en el paquete
   especificado, o por defecto, a los que estan en el directorio actual.  Se ha
   ejecutado @$(gofmt) sobre todos los archivos de codigo fuente en el libro, y
   usted debe optener el habito de hacer lo mismo con su propio codigo. Declarar
   un formato estandar por mandato elimina un monton de debate inutil sobre
   trivialidades y, lo que es mas importante, permite una variedad de
   transformaciones automatizadas de codigo fuente que serian imposibles si se
   permitiera el formato arbitrario.

#    Many text editors can be configured to run @$(gofmt) each time you save a
#    file, so that your source code is always properly formatted. A related tool,
#    @$(goimports), additionally manages the insertion and removal of import
#    declarations as needed. It is not part of the standard distribution but you
#    can obtain it with this command:
   Muchos editores de texto pueden ser configurados para ejecutar @$(gofmt) cada
   vez que se guarda un archivo, por lo que su codigo fuente siempre tendra el
   formato apropiado. Una herramienta relacionada, @$(goimports) , ademas,
   gestiona la insercion y extraccion de las declaraciones de importacion, segun
   sea necesario. No es parte de la distribucion estandar pero se puede obtener
   con este comando:

#    ..src > sh
#      $ go get golang.org/x/tools/cmd/goimports
#    < src..
   ..src > sh
     $ go get golang.org/x/tools/cmd/goimports
   < src..

#    For most users, the usual way to download and build packages, run their
#    tests, show their documentation, and so on, is with the @$(go) tool, which
#    we’ll look at in @l(#Section 10.7).
   Para la mayoria de los usuarios, la forma habitual de descargar y construir
   paquetes, ejecutar pruebas, mostrar su documentacion, y asi sucesivamente, es
   con la herramienta @$(go), que vamos a ver en la @l(#Seccion 10.7).

# ** Section 1.2 <> Command-Line Arguments
** Seccion 1.2 <> Argumentos de la linea de comandos

#    Most programs process some input to produce some output; that’s pretty much
#    the definition of computing. But how does a program get input data on which
#    to operate? Some programs generate their own data, but more often, input
#    comes from an external source: a file, a network connection, the output of
#    another program, a user at a keyboard, command-line arguments, or the like.
#    The next few examples will discuss some of these alternatives, starting with
#    command-line arguments.
   La mayoria de los programas procesan alguna entrada para producir alguna
   salida; Que es mas o menos la definicion de la computacion. Pero, ¿como un
   programa obtiene datos de entrada para operar? Algunos programas generan sus
   propios datos, pero mas a menudo, la entrada proviene de una fuente externa:
   un archivo, una conexion de red, la salida de otro programa, un usuario en un
   teclado, argumentos de linea de comandos o similares. Los siguientes ejemplos
   discutiran algunas de estas alternativas, comenzando con argumentos de linea
   de comandos.

#    The @c(os) package provides functions and other values for dealing with the
#    operating system in a platform-independent fashion. Command-line arguments
#    are available to a program in a variable named @c(Args) that is part of the
#    @c(os) package; thus its name anywhere outside the @c(os) package is
#    @c(os.Args).
   El paquete @c(os) proporciona funciones y otros valores para relacionarse con
   el sistema operativo de una manera independiente de la plataforma. Los
   argumentos de linea de comandos estan disponibles para un programa en una
   variable denominada @c(Args) que forma parte del paquete @c(os); por lo tanto
   su nombre en cualquier lugar fuera del paquete @c(os) es @c(os.Args).

#    The variable @c(os.Args) is a @e(slice) of strings. Slices are a fundamental
#    notion in Go, and we’ll talk a lot more about them soon. For now, think of a
#    slice as a dynamically sized sequence @c(s) of array elements where
#    individual elements can be accessed as @c(s[i]) and a contiguous subsequence
#    as @c(s[m:n]). The number of elements is given by @c[len(s)]. As in most
#    other programming languages, all indexing in Go uses @e(half-open) intervals
#    that include the first index but exclude the last, because it simplifies
#    logic. For example, the slice @c(s[m:n]), where @c[0 ≤ m ≤ n ≤ len(s)],
#    contains @c(n-m) elements.
   Las variables @c(os.Args) es una @e(slice) de strings. Los slices son una
   nocion fundamental en Go, y hablaremos mucho mas sobre ellos pronto. Por
   ahora, piensa en un slice como una secuencia @c(s) de elementos de un arreglo
   de tamaño dinamico, donde los elementos individuales pueden accederse como
   @c(s[i]) y una subsecuencia contigua como @c(s[m:n]). El numero de elementos esta
   dado por @c[len(s)]. Como en la la mayoria de los otros lenguajes de
   programacion, toda  indexacion en Go utiliza intervalos @e(semiabiertos)
   que incluyen el primer indice, pero no incluyen el ultimo, ya que simplifica
   la logica. Por ejemplo, el slice  @c(s[m:n]), donde @c[0 ≤ m ≤ n ≤ len(s)],
   contiene @c(n-m) elementos.

#    The first element of @c(os.Args), @c(os.Args[0]), is the name of the command
#    itself; the other elements are the arguments that were presented to the
#    program when it started execution. A slice expression of the form @c(s[m:n])
#    yields a slice that refers to elements @c(m) through @c(n-1), so the elements
#    we need for our next example are those in the slice
#    @c{os.Args[1:len(os.Args)]}. If @c(m) or @c(n) is omitted, it defaults to 0
#    or @c[len(s)] respectively, so we can abbreviate the desired slice as
#    @c(os.Args[1:]).
   El primer elemento de @c(os.Args), @c(os.Args[0]), es el nombre del comando
   en si; Los otros elementos son los argumentos que se ofresieron al programa
   cuando se inicio la ejecucion. Una expresion de la forma @c(s[m:n]) produce
   un slice que hace referencia a los elementos entre @c(m) y @c(n-1), por lo
   que los elementos que necesitamos para nuestro siguiente ejemplo corresponden
   al slice @c{os.Args[1:len(os.Args)]}. Si @c(m) o @c(n) se omite, el valor
   predeterminado es 0 o @c[len(s)], respectivamente, por lo que se puede
   abreviar el slice deseado como @c(os.Args[1:]).

#    Here’s an implementation of the Unix @$(echo) command, which prints its
#    command-line arguments on a single line. It imports two packages, which are
#    given as a parenthesized list rather than as individual import declarations.
#    Either form is legal, but conventionally the list form is used. The order of
#    imports doesn’t matter; the @$(gofmt) tool sorts the package names into
#    alphabetical order. (When there are several versions of an example, we will
#    often number them so you can be sure of which one we’re talking about.)
   Aqui esta una implementacion del comando @$(echo) de Unix, que imprime sus
   argumentos de linea de comandos en una sola linea. Importa dos paquetes, que
   se dan como una lista entre parentesis en lugar de como declaraciones de
   importacion individuales. Cualquiera de las formas es legal, pero
   convencionalmente se utiliza el formato de lista. El orden de las
   importaciones no importa; la herramienta @$(gofmt) ordena los nombres de los
   paquetes en orden alfabetico. (Cuando hay varias versiones de un ejemplo, a
   menudo las numeraremos para que pueda estar seguro de cual estamos hablando.)

#    ..figure > @l(gopl.io/ch1/echo1/main.go<>gopl.io/ch1/echo1)
   ..figure > @l(gopl.io/ch1/echo1/main.go<>gopl.io/ch1/echo1)

#      ..src > go
#        // Echo1 prints its command-line arguments.
#        package main
#
#        import (
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          var s, sep string
#          for i := 1; i < len(os.Args); i++ {
#            s += sep + os.Args[i]
#            sep = " "
#          }
#          fmt.Println(s)
#        }
#      < src..
     ..src > go
       // Echo1 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         var s, sep string
         for i := 1; i < len(os.Args); i++ {
           s += sep + os.Args[i]
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


#    Comments begin with @c(//). All text from a @c(//) to the end of the line is
#    commentary for programmers and is ignored by the compiler. By convention, we
#    describe each package in a comment immediately preceding its package
#    declaration; for a @c(main) package, this comment is one or more complete
#    sentences that describe the program as a whole.
   Los comentarios comienzan con @c(//). Todo el texto desde @c(//) hasta el
   final de la linea es el comentario para los programadores y es ignorado por
   el compilador. Por convencion, describimos cada paquete en un comentario
   inmediatamente anterior a su declaracion del paquete; para un paquete
   @c(main), este comentario es una o varias frases completas que describen el
   programa en su conjunto.

#    The @c(var) declaration declares two variables @c(s) and @c(sep), of type
#    @c(string). A variable can be initialized as part of its declaration. If it
#    is not explicitly initialized, it is implicitly initialized to the @e(zero
#    value) for its type, which is @c(0) for numeric types and the empty string
#    @c("") for strings.  Thus in this example, the declaration implicitly
#    initializes @c(s) and @c(sep) to empty strings. We’ll have more to say about
#    variables and declarations in @l(#Chapter 2).
   La declaracion @c(var) declara dos variables @c(s) y @c(sep), de tipo
   @c(string). Una variable se puede inicializar como parte de su
   declaracion. Si no se inicia de forma explicita, se inicializa de forma
   implicita al @e(valor cero) para su tipo, que es 0 para los tipos numericos y
   la cadena vacia "" para strings. Asi, en este ejemplo, la declaracion
   implicita inicializa @c(s) y @c(sep) como cadenas vacias. Tendremos mas que
   decir acerca de las variables y las declaraciones en el @l(#Capitulo 2).

#    For numbers, Go provides the usual arithmetic and logical operators. When
#    applied to strings, however, the @c(+) operator @e(concatenates) the values,
#    so the expression
   Para los numeros, Go proporciona los operadores aritmeticos y logicos
   habituales. Cuando se aplica a las cadenas, sin embargo, el operador @c(+)
   @e(concatena) los valores, por lo que la expresion

#    ..src > go
#      sep + os.Args[i]
#    < src..
   ..src > go
     sep + os.Args[i]
   < src..

#    represents the concatenation of the strings @c(sep) and @c(os.Args[i]). The
#    statement we used in the program,
   representa la concatenacion de las cadenas @c(sep) y @c(os.Args[i]) . La
   declaracion que usamos en el programa,

#    ..src > go
#      s += sep + os.Args[i]
#    < src..
   ..src > go
     s += sep + os.Args[i]
   < src..

#    is an @e(assignment statement) that concatenates the old value of @c(s) with
#    @c(sep) and @c(os.Args[i]) and assigns it back to @c(s); it is equivalent to
   es una @e(sencencia de asignacion) que concatena el antiguo valor de @c(s) con @c(sep)
   y @c(os.Args[i]) y lo asigna de nuevo a @c(s); Es equivalente a

#    ..src > go
#      s = s + sep + os.Args[i]
#    < src..
   ..src > go
     s = s + sep + os.Args[i]
   < src..

#    The operator @c(+=) is an @e(assignment operator). Each arithmetic and logical
#    operator like @c(+) or @c(*) has a corresponding assignment operator.
   El operador @c(+=) es un operador de asignacion. Cada operador aritmetico y
   logico como @c(+) o @c(*) tiene un operador de asignacion correspondiente.

#    The @$(echo) program could have printed its output in a loop one piece at a
#    time, but this version instead builds up a string by repeatedly appending new
#    text to the end. The string @c(s) starts life empty, that is, with value
#    @c(""), and each trip through the loop adds some text to it; after the first
#    iteration, a space is also inserted so that when the loop is finished, there
#    is one space between each argument. This is a quadratic process that could be
#    costly if the number of arguments is large, but for @$(echo), that’s
#    unlikely. We’ll show a number of improved versions of @$(echo) in this
#    chapter and the next that will deal with any real inefficiency.
   El programa @$(echo) podria haber impreso su salida en un bucle de una sola
   pieza a la vez, pero en esta version, en su lugar se acumula una cadena
   añadiendo repetidamente nuevo texto hasta el final. La cadena de @c(s)
   comienza su vida vacia, es decir, con el valor "", y cada ciclo a traves del
   bucle añade un poco de texto a ella; Despues de la primera iteracion, tambien
   se inserta un espacio para que cuando el bucle este terminado, haya un
   espacio entre cada argumento. Este es un proceso cuadratico que podria ser
   costoso si el numero de argumentos es grande, pero para @$(echo), eso es poco
   probable. Vamos a mostrar una serie de versiones mejoradas de @$(echo) en
   este capitulo y el siguiente para hacer frente a cualquier ineficiencia real.

#    The loop index variable @c(i) is declared in the first part of the @c(for)
#    loop. The @c(:=) symbol is part of a @e(short variable declaration), a
#    statement that declares one or more variables and gives them appropriate
#    types based on the initializer values; there’s more about this in the next
#    chapter.
   El indice variable @c(i) de bucle se declara en la primera parte del bucle
   @c(for). El @c(:=) simbolo es parte de una @e(declaracion de variables
   compacta), una sentencia que declara una o mas variables y les da los tipos
   apropiados basados en los valores del inicializador; Hay mas informacion al
   respecto en el proximo capitulo.

#    The increment statement @c(i++) adds 1 to @c(i); it’s equivalent to @c(i
#    += 1) which is in turn equivalent to @c(i = i + 1). There’s a corresponding
#    decrement statement @c(i--) that subtracts 1. These are statements, not
#    expressions as they are in most languages in the C family, so @c(j = i++) is
#    illegal, and they are postfix only, so @c(--i) is not legal either.
   La declaracion de incremento @c(i++) añade 1 a @c(i); que es equivalente a
   @c(i += 1), que es a su vez equivalente a @c(i = i + 1). Hay una declaracion
   de decremento correspondiente @c(i--) que resta 1. Estas son declaraciones,
   no expresiones como lo son en la mayoria de los lenguajes en la familia C,
   por lo que @c(j = i++) es ilegal, y solamente son de sufijo, asi @c(--i)
   tampoco es legal.

#    The @c(for) loop is the only loop statement in Go. It has a number of forms,
#    one of which is illustrated here:
   El bucle @c(for) es la unica sentencia de bucle en Go. Tiene una serie de formas,
   una de las cuales se ilustra aqui:

#    ..src > go
#      for initialization; condition; post {
#          // zero or more statements
#      }
#    < src..
   ..src > go
     for inicializacion; condicion; incremento {
         // zero or more statements
     }
   < src..

#    Parentheses are never used around the three components of a @c(for) loop. The
#    braces are mandatory, however, and the opening brace must be on the same line
#    as the @c(post) statement.
   Los parentesis no se utilizan nunca alrededor de los tres componentes de un
   bucle @c(for). Las llaves son obligatorios, sin embargo, y la llave de apertura
   deben estar en la misma linea que la declaracion @c(incremento).

#    The optional @c(initialization) statement is executed before the loop
#    starts. If it is present, it must be a @e(simple statement), that is, a short
#    variable declaration, an increment or assignment statement, or a function
#    call. The @c(condition) is a boolean expression that is evaluated at the
#    beginning of each iteration of the loop; if it evaluates to @c(true), the
#    statements controlled by the loop are executed. The @c(post) statement is
#    executed after the body of the loop, then the condition is evaluated
#    again. The loop ends when the condition becomes false.
   La declaracion opcional @c(inicializacion) se ejecuta antes de que comience
   el bucle. Si esta presente, debe ser una simple declaracion, es decir, una
   declaracion de variables compacta, una declaracion de incremento o asignacion, o
   una llamada a funcion. La @c(condition) es una expresion booleana que se
   evalua en al inicio de cada iteracion del bucle; si se evalua como @c(true),
   las declaraciones controladas por el bucle se ejecutan. La declaracion
   @c(incremento) se ejecuta despues del cuerpo del bucle, luego la
   @c(condicion) se evalua de nuevo. El bucle termina cuando la condicion se
   convierte en falsa.

#    Any of these parts may be omitted. If there is no @c(initialization) and no @c(post),
#    the semicolons may also be omitted:
   Cualquiera de estas partes puede omitirse. Si no hay @c(inicializacion) y
   ningun @c(incremento), el punto y coma tambien pueden omitirse:

#    ..src > go
#      // a traditional "while" loop
#      for condition {
#          // ...
#      }
#    < src..
   ..src > go
     // un tradicional bucle "while"
     for condicion {
         // ...
     }
   < src..

#    If the condition is omitted entirely in any of these forms, for example in
   Si la condicion se omite totalmente en cualquiera de estas formas, por
   ejemplo en

#    ..src > go
#      // a traditional infinite loop
#      for {
#          // ...
#      }
#    < src..
   ..src > go
     // un tradicional bucle infinito
     for {
         // ...
     }
   < src..

#    the loop is infinite, though loops of this form may be terminated in some
#    other way, like a @c(break) or @c(return) statement.
   el bucle es infinito, aunque los bucles de esta forma se pueden terminar de
   alguna otra forma, como una declaracion @c(break) o @c(return).

#    Another form of the @c(for) loop iterates over a @e(range) of values from a
#    data type like a string or a slice. To illustrate, here’s a second version of
#    @$(echo):
   Otra forma en que el bucle @c(for) itera, es sobre un @e(rango) de valores de
   un tipo de datos como un string o un slice. Para ilustrar esto, he aqui una
   segunda version de @$(echo):

#    ..figure > @l(gopl.io/ch1/echo2/main.go<>gopl.io/ch1/echo2)
   ..figure > @l(gopl.io/ch1/echo2/main.go<>gopl.io/ch1/echo2)

#      ..src > go
#        // Echo2 prints its command-line arguments.
#        package main
#
#        import (
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          s, sep := "", ""
#          for _, arg := range os.Args[1:] {
#            s += sep + arg
#            sep = " "
#          }
#          fmt.Println(s)
#        }
#      < src..
     ..src > go
       // Echo2 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         s, sep := "", ""
         for _, arg := range os.Args[1:] {
           s += sep + arg
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


#    In each iteration of the loop, @c(range) produces a pair of values: the index and
#    the value of the element at that index. In this example, we don’t need the
#    index, but the syntax of a @c(range) loop requires that if we deal with the
#    element, we must deal with the index too. One idea would be to assign the
#    index to an obviously temporary variable like @c(temp) and ignore its value, but
#    Go does not permit unused local variables, so this would result in a
#    compilation error.
   En cada iteracion del bucle, @c(range) produce un par de valores: el indice y
   el valor del elemento en ese indice. En este ejemplo, no necesitamos el
   indice, pero la sintaxis de un bucle @c(range) requiere que si tratamos con
   el elemento, debemos tratar tambien con el indice. Una idea seria asignar el
   indice a una variable temporal, como @c(temp) y pasar por alto su valor, pero
   Go no permite tener variables locales sin utilizar, por lo que esto daria
   lugar a un error de compilacion.

#    The solution is to use the @e(blank identifier), whose name is @c(_) (that
#    is, an underscore). The blank identifier may be used whenever syntax requires
#    a variable name but program logic does not, for instance to discard an
#    unwanted loop index when we require only the element value. Most Go
#    programmers would likely use @c(range) and @c(_) to write the @$(echo)
#    program as above, since the indexing over @c(os.Args) is implicit, not
#    explicit, and thus easier to get right.
   La solucion es utilizar el @e(identificador en blanco), cuyo nombre es @c(_)
   (esto es, un guion bajo). El identificador en blanco puede utilizarse siempre
   que la sintaxis requiera un nombre de variable, pero la logica del programa
   no lo haga, por ejemplo para descartar un indice no deseado del bucle cuando
   solo necesitamos el valor del elemento. La mayoria de los programadores Go
   probablemente usarian @c(range) y @c(_) para escribir el programa @$(echo)
   anterior, ya que la indexacion sobre @c(os.Args) es implicita, no explicita,
   y por lo tanto mas facil de hacerlo bien.

#    This version of the program uses a short variable declaration to declare and
#    initialize @c(s) and @c(sep), but we could equally well have declared the
#    variables separately. There are several ways to declare a string variable;
#    these are all equivalent:
   Esta version del programa utiliza una breve declaracion de variables para
   declarar e inicializar @c(s) y @c(sep), pero podria igualmente haber declarado las
   variables por separado. Hay varias maneras de declarar una variable de
   cadena; Todas estas son equivalentes:

#    ..src > go
#      s := ""
#      var s string
#      var s = ""
#      var s string = ""
#    < src..
   ..src > go
     s := ""
     var s string
     var s = ""
     var s string = ""
   < src..

#    Why should you prefer one form to another? The first form, a short variable
#    declaration, is the most compact, but it may be used only within a function,
#    not for package-level variables.  The second form relies on default
#    initialization to the zero value for strings, which is @c(""). The third form is
#    rarely used except when declaring multiple variables. The fourth form is
#    explicit about the variable’s type, which is redundant when it is the same as
#    that of the initial value but necessary in other cases where they are not of
#    the same type. In practice, you should generally use one of the first two
#    forms, with explicit initialization to say that the initial value is
#    important and implicit initialization to say that the initial value doesn’t
#    matter.
   Por que usted deberia preferir una forma sobre otra? El primer formato, una
   declaracion de variable compacta, es el mas compacto, pero puede ser utilizado
   solo dentro de una funcion, no para variables de nivel de paquete. La segunda
   forma se basa en la inicializacion por defecto al valor cero para strings,
   que es @c("") . La tercera forma se utiliza raramente excepto cuando se
   declaran multiples variables. La cuarta forma es explicita sobre el tipo de
   la variable, que es redundante cuando es el mismo que el del valor inicial
   pero necesario en otros casos donde no son del mismo tipo. En la practica,
   generalmente debe utilizar una de las dos primeras formas, con inicializacion
   explicita para decir que el valor inicial es importante e implicita para
   decir que el valor inicial no importa.

#    As noted above, each time around the loop, the string @c(s) gets completely
#    new contents. The @c(+=) statement makes a new string by concatenating the
#    old string, a space character, and the next argument, then assigns the new
#    string to @c(s). The old contents of @c(s) are no longer in use, so they will
#    be garbage-collected in due course.
   Como se señalo anteriormente, cada iteracion alrededor del bucle, la cadena
   @c(s) obtiene contenidos completamente nuevos. La declaracion @c(+=) crea una
   nueva cadena mediante la concatenacion de la cadena antigua, un caracter de
   espacio, y el siguiente argumento, a continuacion, asigna la nueva cadena a
   @c(s). El contenido antiguo del @c(s) ya no estan en uso, por lo que sera
   recolectado por el recolector de basura en su debido momento.

#    If the amount of data involved is large, this could be costly. A simpler and
#    more efficient solution would be to use the @c(Join) function from the @c(strings)
#    package:
   Si la cantidad de datos involucrados es grande, esto podria ser costoso. Una
   solucion mas simple y mas eficiente seria utilizar la funcion @c(Join) del
   paquete @c(strings):

#    ..figure > @l(gopl.io/ch1/echo3/main.go<>gopl.io/ch1/echo3)
   ..figure > @l(gopl.io/ch1/echo3/main.go<>gopl.io/ch1/echo3)

#      ..src > go
#        func main() {
#          fmt.Println(strings.Join(os.Args[1:], " "))
#        }
#      < src..
     ..src > go
       func main() {
         fmt.Println(strings.Join(os.Args[1:], " "))
       }
     < src..


#    Finally, if we don’t care about format but just want to see the values,
#    perhaps for debugging, we can let @c(Println) format the results for us:
   Por ultimo, si no nos interesa el formato, pero solo queremos ver los
   valores, tal vez para depurar, podemos dejar que @c(Println) formatee el
   resultado por nosotros:

#    ..src > go
#      fmt.Println(os.Args[1:])
#    < src..
   ..src > go
     fmt.Println(os.Args[1:])
   < src..

#    The output of this statement is like what we would get from @c(strings.Join),
#    but with surrounding brackets. Any slice may be printed this way.
   El resultado de esta sentencia es como la que se pueden conseguir mediante
   @c(strings.Join), pero con corchetes al rededor. Cualquier slice se puede
   imprimir de esta manera.

#    @b(Exercise 1.1): Modify the @$(echo) program to also print @c(os.Args[0]),
#    the name of the command that invoked it.
   @b(Ejercicio 1.1): Modificar el programa @$(echo) para imprimir tambien
   @c(os.Args[0]), el nombre del comando que lo invoco.

#    @b(Exercise 1.2): Modify the @$(echo) program to print the index and value of
#    each of its arguments, one per line.
   @b(Ejercicio 1.2): Modificar el programa @$(echo) para imprimir el indice y el
   valor de cada uno de sus argumentos, uno por linea.

#    @b(Exercise 1.3): Experiment to measure the difference in running time
#    between our potentially inefficient versions and the one that uses
#    @c(strings.Join). (@l(#Section 1.6) illustrates part of the @c(time) package,
#    and @l(#Section 11.4) shows how to write benchmark tests for systematic
#    performance evaluation.)
   @b(Ejercicio 1.3): Experimento para medir la diferencia en el tiempo de
   funcionamiento entre nuestras versiones potencialmente ineficientes y el que
   utiliza @c(strings.Join). ( La @l(#Seccion 1.6) ilustra parte del paquete
   @c(time), y la @l(#Seccion 11.4) muestra como escribir pruebas de referencia
   para la evaluacion sistematica del rendimiento.)

# ** Section 1.3 <> Finding Duplicate Lines
** Seccion 1.3 <> Encontrar lineas duplicadas

#    Programs for file copying, printing, searching, sorting, counting, and the
#    like all have a similar structure: a loop over the input, some computation on
#    each element, and generation of output on the fly or at the end. We’ll show
#    three variants of a program called @$(dup); it is partly inspired by the Unix
#    @$(uniq) command, which looks for adjacent duplicate lines. The structures
#    and packages used are models that can be easily adapted.
   Los programas para copiar archivos, imprimir, buscar, clasificar, contar y
   similares tienen una estructura similar: un bucle sobre la entrada, algun
   calculo sobre cada elemento y generacion de salida al vuelo o al
   final. Mostraremos tres variantes de un programa llamado @$(dup); se inspira
   en parte por el comando Unix @$(uniq), que mira las lineas duplicadas
   adyacentes. Las estructuras y paquetes utilizados son modelos que se pueden
   adaptar facilmente.

#    The first version of @$(dup) prints each line that appears more than once in the
#    standard input, preceded by its count. This program introduces the @c(if)
#    statement, the @$(map) data type, and the @c(bufio) package.
   La primer version del @$(dup) imprime cada linea que aparece mas de una vez en
   la entrada estandar, precedido por su recuento. Este programa presenta la declaracion
   @c(if), el  tipo de datos @c(map) y el paquete @c(bufio).

#    ..figure > @l(gopl.io/ch1/dup1/main.go<>gopl.io/ch1/dup1)
   ..figure > @l(gopl.io/ch1/dup1/main.go<>gopl.io/ch1/dup1)

#      ..src > go
#        // Dup1 prints the text of each line that appears more than
#        // once in the standard input, preceded by its count.
#        package main
#
#        import (
#          "bufio"
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          input := bufio.NewScanner(os.Stdin)
#          for input.Scan() {
#            counts[input.Text()]++
#          }
#          // NOTE: ignoring potential errors from input.Err()
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#      < src..
     ..src > go
       // Dup1 imprime el texto de cada linea que aparece mas de
       // una vez en la entrada estandar, precedida por su recuento.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         input := bufio.NewScanner(os.Stdin)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTA: ignorando posibles errores de input.Err ()
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


#    As with @c(for), parentheses are never used around the condition in an @c(if)
#    statement, but braces are required for the body. There can be an optional
#    @c(else) part that is executed if the condition is false.
   Al igual que con @c(for), nunca se usan parentesis alrededor de la
   declaracion de la condicion @c(if), pero se requieren llaves para el
   cuerpo. Puede haber una parte @c(else) opcional que se ejecute si la
   condicion es falsa.

#    A @e(map) holds a set of key/value pairs and provides constant-time
#    operations to store, retrieve, or test for an item in the set. The key may be
#    of any type whose values can compared with @c(==), strings being the most
#    common example; the value may be of any type at all. In this example, the
#    keys are @c(string)s and the values are @c(int)s. The built-in function
#    @c(make) creates a new empty map; it has other uses too. Maps are discussed
#    at length in @l(#Section 4.3).
   Un @e(mapa) contiene un conjunto de pares clave/valor y proporciona
   operaciones de tiempo constante para almacenar, recuperar, o comprobar un
   elemento en el conjunto. La clave puede ser de cualquier tipo cuyos valores
   puedan compararse con @c(==), siendo strings el ejemplo mas comun; El valor
   puede ser de cualquier tipo en absoluto. En este ejemplo, las claves son
   @c(string)s, y los valores son @c(int)s. La funcion incorporada @c(make) crea
   un nuevo mapa vacio; Tiene otros usos tambien. Los mapas se discuten
   extensamente en la @l(#Seccion 4.3).

#    Each time @$(dup) reads a line of input, the line is used as a key into the
#    map and the corresponding value is incremented. The statement
#    @c{counts[input.Text()]++} is equivalent to these two statements:
   Cada vez @$(dup) lee una linea de entrada, la linea se utiliza como una clave
   en el mapa y se incrementa el valor correspondiente. La declaracion
   @c{counts[input.Text()]++} es equivalente a estas dos afirmaciones:

#    ..src > go
#      line := input.Text()
#      counts[line] = counts[line] + 1
#    < src..
   ..src > go
     line := input.Text()
     counts[line] = counts[line] + 1
   < src..

#    It’s not a problem if the map doesn’t yet contain that key. The first time a
#    new line is seen, the expression @c(counts[line]) on the right-hand side
#    evaluates to the zero value for its type, which is 0 for @c(int).
   No es un problema, si el mapa aun no contiene esa clave. La primera vez que
   se ve una nueva linea, la expresion @c(counts[line]) en el lado derecho se
   evalua al valor cero para su tipo, que es 0 para @c(int).

#    To print the results, we use another @c(range)-based @c(for) loop, this time
#    over the @c(counts) map. As before, each iteration produces two results, a
#    key and the value of the map element for that key. The order of map iteration
#    is not specified, but in practice it is random, varying from one run to
#    another. This design is intentional, since it prevents programs from relying
#    on any particular ordering where none is guaranteed.
   Para imprimir los resultados, utilizamos otro bucle de repeticion @c(for)
   basado en @c(range), esta vez sobre el mapa @c(counts). Como antes, cada
   iteracion produce dos resultados, una clave y el valor del elemento del mapa
   para esa clave. El orden de la iteracion del mapa no es especifico, en la
   practica es aleatorio, variando de una ejecucion a otra. Este diseño es
   intencional, ya que impide que los programas se basen en cualquier orden
   particular donde no se garantiza ninguno.

#    Onward to the @c(bufio) package, which helps make input and output efficient and
#    convenient.  One of its most useful features is a type called @c(Scanner) that
#    reads input and breaks it into lines or words; it’s often the easiest way to
#    process input that comes naturally in lines.
   El paquete @c(bufio), ayuda a que la entrada y salida sea eficiente y
   conveniente. Una de sus caracteristicas mas utiles es un tipo llamado
   @c(Scanner) que lee la entrada y la rompe en lineas o palabras; A menudo es
   la manera mas facil de procesar la entrada que llega naturalmente en lineas.

#    The program uses a short variable declaration to create a new variable input
#    that refers to a @c(bufio.Scanner):
   El programa utiliza una breve declaracion de variables para crear una nueva
   variable de entrada que hace referencia a @c(bufio.Scanner):

#    ..src > go
#      input := bufio.NewScanner(os.Stdin)
#    < src..
   ..src > go
     input := bufio.NewScanner(os.Stdin)
   < src..

#    The scanner reads from the program’s standard input. Each call to
#    @c[input.Scan()] reads the next line and removes the newline character from
#    the end; the result can be retrieved by calling @c[input.Text()]. The
#    @c(Scan) function returns @c(true) if there is a line and @c(false) when
#    there is no more input.
   El escaner lee de la entrada estandar del programa. Cada llamada a
   @c[input.Scan()] lee la siguiente linea y elimina el caracter de nueva linea
   al final; el resultado puede ser recuperado llamando a @c[input.Text()]. La
   funcion @c(Scan) devuelve @c(true) si hay una linea y @c(false) cuando no hay
   mas entrada.

#    The function @c(fmt.Printf), like @c(printf) in C and other languages,
#    produces formatted output from a list of expressions. Its first argument is a
#    format string that specifies how subsequent arguments should be
#    formatted. The format of each argument is determined by a conversion
#    character, a letter following a percent sign. For example, @c(%d) formats an
#    integer operand using decimal notation, and @c(%s) expands to the value of a
#    string operand.
   La funcion @c(fmt.Printf), como @c(printf) en C y otros lenguajes, produce
   una salida con formato de una lista de expresiones. Su primer argumento es
   una cadena de formato que especifica como deben formatearse los argumentos
   posteriores. El formato de cada argumento esta determinado por un caracter de
   conversion, una letra siguiendo un signo de porcentaje. Por ejemplo, @c(%d)
   formatea un operando entero usando la notacion decimal, y @c(%s) se expande
   para el valor de un operando de cadena.

#    @c(Printf) has over a dozen such conversions, which Go programmers call
#    @e(verbs). This table is far from a complete specification but illustrates
#    many of the features that are available:
   @c(Printf) tiene mas de una docena de estas conversiones, que los
   programadores de Go llaman @e(verbos). Esta tabla esta lejos de ser una
   especificacion completa, pero ilustra muchas de las caracteristicas que estan
   disponibles:

#    | @c(%d)                 | decimal integer                                                |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%x), @c(%o), @c(%b) | integer in hexadecimal, octal, binary                          |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%f), @c(%g), @c(%e) | floating-point number: 3.141593 3.141592653589793 3.141593e+00 |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%t)                 | boolean: @c(true) or @c(false)                                 |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%c)                 | rune (Unicode code point)                                      |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%s)                 | string                                                         |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%q)                 | quoted string @c("abc") or rune @c('c')                        |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%v)                 | any value in a natural format                                  |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%T)                 | type of any value                                              |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%%)                 | literal percent sign (no operand)                              |
   | @c(%d)                 | entero decimal                                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%x), @c(%o), @c(%b) | entero en hexadecimal, octal, binario                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%f), @c(%g), @c(%e) | numero de coma flotante: 3.141593 3.141592653589793 3.141593e + 00 |
   |------------------------|--------------------------------------------------------------------|
   | @c(%t)                 | booleano: @c(true) o @c(false)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%c)                 | runa (punto de codigo Unicode)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%s)                 | string                                                             |
   |------------------------|--------------------------------------------------------------------|
   | @c(%q)                 | citar string @c("abc") o runa @c('c')                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%v)                 | cualquier valor en un formato natural                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%T)                 | cualquier tipo de valor                                            |
   |------------------------|--------------------------------------------------------------------|
   | @c(%%)                 | signo literal de porcentaje (sin operando)                         |

#    The format string in @c(dup1) also contains a tab @c(\t) and a newline
#    @c(\n). String literals may contain such @e(escape sequences) for
#    representing otherwise invisible characters. @c(Printf) does not write a
#    newline by default. By convention, formatting functions whose names end in
#    @c(f), such as @c(log.Printf) and @c(fmt.Errorf), use the formatting rules of
#    @c(fmt.Printf), whereas those whose names end in @c(ln) follow @c(Println),
#    formatting their arguments as if by @c(%v), followed by a newline.
   El formato de cadena en @c(dup1) tambien contiene una tabulacion @c(\t) y un
   salto de linea @c(\n). Los literales de cadena pueden contener tales
   @e(secuencias de escape) para la representacion de caracteres de otra manera
   invisibles. @c(Printf) no escribe una nueva linea por defecto. Por
   convencion, las funciones de formato cuyos nombres terminan en f, tales como
   @c(log.Printf) y @c(fmt.Errorf), utilizan las reglas de formato de
   @c(fmt.Printf), mientras que aquellas cuyos nombres terminan en @c(ln) como
   @c(Println), formatean sus argumentos con %v, seguido por una nueva linea.

#    Many programs read either from their standard input, as above, or from a
#    sequence of named files. The next version of @c(dup) can read from the
#    standard input or handle a list of file names, using @c(os.Open) to open each
#    one:
   Muchos programas leen ya sea a partir de su entrada estandar, como
   anteriormente, o de una secuencia de archivos con nombre. La proxima version
   de @$(dup) puede leer desde la entrada estandar o manejar una lista de
   nombres de archivos, utilizando @c(os.Open) para abrir cada uno de ellos:

#    ..figure > @l(gopl.io/ch1/dup2/main.go<>gopl.io/ch1/dup2)
   ..figure > @l(gopl.io/ch1/dup2/main.go<>gopl.io/ch1/dup2)

#      ..src > go
#        // Dup2 prints the count and text of lines that appear more than once
#        // in the input.  It reads from stdin or from a list of named files.
#        package main
#
#        import (
#          "bufio"
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          files := os.Args[1:]
#          if len(files) == 0 {
#            countLines(os.Stdin, counts)
#          } else {
#            for _, arg := range files {
#              f, err := os.Open(arg)
#              if err != nil {
#                fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
#                continue
#              }
#              countLines(f, counts)
#              f.Close()
#            }
#          }
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#
#        func countLines(f *os.File, counts map[string]int) {
#          input := bufio.NewScanner(f)
#          for input.Scan() {
#            counts[input.Text()]++
#          }
#          // NOTE: ignoring potential errors from input.Err()
#        }
#      < src..
     ..src > go
       // Dup2 imprime el recuento y el texto de las lineas que aparecen mas de una vez
       // en la entrada.  Se lee desde stdin o desde una lista de archivos con nombre.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         files := os.Args[1:]
         if len(files) == 0 {
           countLines(os.Stdin, counts)
         } else {
           for _, arg := range files {
             f, err := os.Open(arg)
             if err != nil {
               fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
               continue
             }
             countLines(f, counts)
             f.Close()
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }

       func countLines(f *os.File, counts map[string]int) {
         input := bufio.NewScanner(f)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTE: Ignora errores potenciales de input.Err()
       }
     < src..


#    The function @c(os.Open) returns two values. The first is an open file
#    (@c(*os.File)) that is used in subsequent reads by the @c(Scanner).
   La funcion @c(os.Open) devuelve dos valores. El primero es un archivo abierto
   (@c(*os.File)) que se utiliza en lecturas posteriores por @c(Scanner).

#    The second result of @c(os.Open) is a value of the built-in @c(error)
#    type. If @c(err) equals the special built-in value @c(nil), the file was
#    opened successfully. The file is read, and when the end of the input is
#    reached, @c(Close) closes the file and releases any resources. On the other
#    hand, if @c(err) is not @c(nil), something went wrong. In that case, the
#    error value describes the problem. Our simple-minded error handling prints a
#    message on the standard error stream using @c(Fprintf) and the verb @c(%v),
#    which displays a value of any type in a default format, and @$(dup) then
#    carries on with the next file; the @c(continue) statement goes to the next
#    iteration of the enclosing @c(for) loop.
   El segundo resultado de @c(os.Open) es un valor nativo de tipo @c(error). Si
   @c(err) es igual al valor especial nativo @c(nil), el archivo fue abierto
   correctamente. El archivo se lee, y cuando se llega al final de la entrada,
   @c(Close) cierra el archivo y libera cualquier recurso. Por otro lado, si
   @c(err) no es @c(nil), algo salio mal. En ese caso, el valor de error
   describe el problema. Nuestra sencillo manejo de errores imprime un mensaje
   en el flujo de error estandar utilizando @c(Fprintf) y el verbo @c(%v), que
   muestra un valor de cualquier tipo en un formato predeterminado, y luego
   @c(dup) continua con el siguiente archivo; la instruccion @c(continue) va a
   la siguiente iteracion del bucle @c(for).

#    In the interests of keeping code samples to a reasonable size, our early
#    examples are intentionally somewhat cavalier about error handling. Clearly we
#    must check for an error from @c(os.Open); however, we are ignoring the less
#    likely possibility that an error could occur while reading the file with
#    @c(input.Scan). We will note places where we’ve skipped error checking, and
#    we will go into the details of error handling in @l(#Section 5.4).
   Con el fin de mantener los ejemplos de codigo de un tamaño razonable,
   nuestros primeros ejemplos son intencionalmente un tanto descuidados en el
   manejo de errores. Es evidente que hay que comprobar si hay un error de parte
   de @c(os.Open); Sin embargo, estamos ignorando la menos probable posibilidad
   de que pueda producirse un error al leer el archivo con @c(input.Scan).
   Anotaremos los lugares donde hemos omitido la comprobacion de errores,
   entraremos en detalles sobre el manejo de errores en la @l(#Seccion 5.4).

#    Notice that the call to @c(countLines) precedes its declaration. Functions
#    and other package-level entities may be declared in any order.
   Observe que la llamada a @c(countLines) precede a su declaracion. Las
   funciones y otras entidades a nivel de paquete se pueden declarar en
   cualquier orden.

#    A map is a @e(reference) to the data structure created by @c(make). When a map is
#    passed to a function, the function receives a copy of the reference, so any
#    changes the called function makes to the underlying data structure will be
#    visible through the caller’s map reference too. In our example, the values
#    inserted into the counts map by @c(countLines) are seen by @c(main).
   Un mapa es una referencia a la estructura de datos creada por @c(make).
   Cuando un mapa se pasa a una funcion, la funcion recibe una copia de la
   referencia, De modo que cualquier cambio que haga la funcion llamada en la
   estructura de datos subyacente, sera tambien visible a traves de la
   referencia del mapa del llamador. En nuestro ejemplo, los valores insertados
   en el mapa @c(counts) por @c(countLines) son vistos por @c(main).

#    The versions of @$(dup) above operate in a @"(streaming) mode in which input
#    is read and broken into lines as needed, so in principle these programs can
#    handle an arbitrary amount of input. An alternative approach is to read the
#    entire input into memory in one big gulp, split it into lines all at once,
#    then process the lines. The following version, @$(dup3), operates in that
#    fashion. It introduces the function @c(ReadFile) (from the @c(io/ioutil)
#    package), which reads the entire contents of a named file, and
#    @c(strings.Split), which splits a string into a slice of substrings.
#    (@c(Split) is the opposite of @c(strings.Join), which we saw earlier.)
   Las versiones anteriores de @$(dup) operan en un modo @"(streaming) en el que
   la entrada se lee y divide en lineas segun sea necesario, por lo que, en
   principio, estos programas pueden manejar una cantidad arbitraria de
   entrada. Un enfoque alternativo es leer la entrada entera en la memoria de un
   solo trago, dividirlo en lineas a la vez, y luego procesar las lineas. La
   siguiente version, @$(dup3), funciona de esa manera. Se introduce la funcion
   @c(ReadFile) (del paquete @c(io/ioutil)), que lee todo el contenido de un
   archivo, y @c(strings.Split), que divide una cadena en una slice de
   subcadenas. ( @c(Split) es lo contrario de @c(strings.Join), que vimos
   anteriormente.)

#    We’ve simplified @$(dup3) somewhat. First, it only reads named files, not the
#    standard input, since @c(ReadFile) requires a file name argument. Second, we
#    moved the counting of the lines back into @c(main), since it is now needed in
#    only one place.
   Hemos simplificado un poco @$(dup3). En primer lugar, solo lee archivos por
   su nombre, no la entrada estandar, ya que @c(ReadFile) requiere como
   argumento un nombre de archivo. En segundo lugar, se paso el conteo de las
   lineas de nuevo a @c(main), ya que ahora solo es necesario un solo lugar.

#    ..figure > @l(gopl.io/ch1/dup3/main.go<>gopl.io/ch1/dup3)
   ..figure > @l(gopl.io/ch1/dup3/main.go<>gopl.io/ch1/dup3)

#      ..src > go
#        package main
#
#        import (
#          "fmt"
#          "io/ioutil"
#          "os"
#          "strings"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          for _, filename := range os.Args[1:] {
#            data, err := ioutil.ReadFile(filename)
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
#              continue
#            }
#            for _, line := range strings.Split(string(data), "\n") {
#              counts[line]++
#            }
#          }
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#      < src..
     ..src > go
       package main

       import (
         "fmt"
         "io/ioutil"
         "os"
         "strings"
       )

       func main() {
         counts := make(map[string]int)
         for _, filename := range os.Args[1:] {
           data, err := ioutil.ReadFile(filename)
           if err != nil {
             fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
             continue
           }
           for _, line := range strings.Split(string(data), "\n") {
             counts[line]++
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


#    @c(ReadFile) returns a byte slice that must be converted into a @c(string) so
#    it can be split by @c(strings.Split). We will discuss strings and byte slices
#    at length in @l(#Section 3.5.4).
   @c(ReadFile) devuelve un slice de @c(byte)s que se debe convertirse en un
   @c(string) para que pueda ser dividido por @c(strings.Split). Vamos a
   discutir los strings y slices de bytes en detalle en la @l(#Seccion 3.5.4).

#    Under the covers, @c(bufio.Scanner), @c(ioutil.ReadFile), and
#    @c(ioutil.WriteFile) use the Read and Write methods of @c(*os.File), but it’s
#    rare that most programmers need to access those lower-level routines
#    directly. The higher-level functions like those from @c(bufio) and @c(io/ioutil)
#    are easier to use.
   Bajo la cubierta, @c(bufio.Scanner), @c(ioutil.ReadFile) y
   @c(ioutil.WriteFile) utilizan los metodos @c(Read) y @c(Write) de
   @c(*os.File), pero es raro que la mayoria de los programadores necesiten
   acceder directamente a las rutinas de bajo nivel. Las funciones de nivel
   superior como @c(bufio) y @c(io/ioutil) son mas faciles de usar.

#    @b(Exercise 1.4): Modify @$(dup2) to print the names of all files in which
#    each duplicated line occurs.
   @b(Ejercicio 1.4): Modificar @$(dup2) para imprimir los nombres de todos los
   archivos en los que se produce cada linea duplicada.

# ** Section 1.4 <> Animated GIFs
** Seccion 1.4 <> GIF animados

#    The next program demonstrates basic usage of Go’s standard image packages,
#    which we’ll use to create a sequence of bit-mapped images and then encode the
#    sequence as a GIF animation. The images, called @e(Lissajous figures), were a
#    staple visual effect in sci-fi films of the 1960s. They are the parametric
#    curves produced by harmonic oscillation in two dimensions, such as two sine
#    waves fed into the @m(x) and @m(y) inputs of an oscilloscope. Figure 1.1
#    shows some examples.
   El siguiente programa demuestra el uso basico de los paquetes de imagenes
   estandar en Go, que usaremos para crear una secuencia de imagenes de mapa de
   bits y luego codificar la secuencia como una animacion GIF. Las imagenes,
   llamadas @e(figuras de Lissajous), eran un efecto visual basico en peliculas
   de ciencia ficcion de la decada de 1960. Son las curvas parametricas
   producidas por oscilacion armonica en dos dimensiones, tales como dos ondas
   sinusoidales alimentados en el entradas @m(x) e @m(y) de un osciloscopio. La
   Figura 1.1 muestra algunos ejemplos.

#    ..figure > Figure 1.1. Four Lissajous figures.
   ..figure > Figura 1.1. Cuatro figuras de Lissajous.

#      ..img > img/Figure-1.1.jpg
     ..img > img/Figure-1.1.jpg


#    There are several new constructs in this code, including @c(const) declarations,
#    struct types, and composite literals. Unlike most of our examples, this one
#    also involves floating-point computations. We’ll discuss these topics only
#    briefly here, pushing most details off to later chapters, since the primary
#    goal right now is to give you an idea of what Go looks like and the kinds of
#    things that can be done easily with the language and its libraries.
     Hay varias nuevas construcciones en este codigo, incluyendo declaraciones
     const, tipos de estructura, y literales compuestos. A diferencia de la
     mayoria de nuestros ejemplos, este tambien implica calculos de punto
     flotante.  Aqui vamos a discutir estos temas solo brevemente, desplazando
     la mayoria de los detalles a los capitulos posteriores, ya que el objetivo
     principal en este momento es darle una idea de como se ve Go y el tipo de
     cosas que se pueden hacer facilmente con el lenguaje y sus librerias.

#    ..figure > @l(gopl.io/ch1/lissajous/main.go<>gopl.io/ch1/lissajous)
   ..figure > @l(gopl.io/ch1/lissajous/main.go<>gopl.io/ch1/lissajous)

#      ..src > go
#        // Lissajous generates GIF animations of random Lissajous figures.
#        package main
#
#        import (
#          "image"
#          "image/color"
#          "image/gif"
#          "io"
#          "math"
#          "math/rand"
#          "os"
#        )
#
#        var palette = []color.Color{color.White, color.Black}
#
#        const (
#          whiteIndex = 0 // first color in palette
#          blackIndex = 1 // next color in palette
#        )
#
#        func main() {
#          lissajous(os.Stdout)
#        }
#
#        func lissajous(out io.Writer) {
#          const (
#            cycles  = 5     // number of complete x oscillator revolutions
#            res     = 0.001 // angular resolution
#            size    = 100   // image canvas covers [-size..+size]
#            nframes = 64    // number of animation frames
#            delay   = 8     // delay between frames in 10ms units
#          )
#          freq := rand.Float64() * 3.0 // relative frequency of y oscillator
#          anim := gif.GIF{LoopCount: nframes}
#          phase := 0.0 // phase difference
#          for i := 0; i < nframes; i++ {
#            rect := image.Rect(0, 0, 2*size+1, 2*size+1)
#            img := image.NewPaletted(rect, palette)
#            for t := 0.0; t < cycles*2*math.Pi; t += res {
#              x := math.Sin(t)
#              y := math.Sin(t*freq + phase)
#              img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
#                blackIndex)
#            }
#            phase += 0.1
#            anim.Delay = append(anim.Delay, delay)
#            anim.Image = append(anim.Image, img)
#          }
#          gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
#        }
#      < src..
     ..src > go
       // Lissajous genera GIF animados de figuras Lissajous aleatorias.
       package main

       import (
         "image"
         "image/color"
         "image/gif"
         "io"
         "math"
         "math/rand"
         "os"
       )

       var palette = []color.Color{color.White, color.Black}

       const (
         whiteIndex = 0 // primer color en la paleta
         blackIndex = 1 // siguiente color en la paleta
       )

       func main() {
         lissajous(os.Stdout)
       }

       func lissajous(out io.Writer) {
         const (
           cycles  = 5     // numero de revoluciones completas del oscilador x
           res     = 0.001 // resolucion angular
           size    = 100   // dimencion de la imagen [-size..+size]
           nframes = 64    // numero de cuadros de animacion
           delay   = 8     // retardo entre fotogramas en unidades de 10ms
         )
         freq := rand.Float64() * 3.0 // frecuencia relativa del oscilador y
         anim := gif.GIF{LoopCount: nframes}
         phase := 0.0 // diferencia de fase
         for i := 0; i < nframes; i++ {
           rect := image.Rect(0, 0, 2*size+1, 2*size+1)
           img := image.NewPaletted(rect, palette)
           for t := 0.0; t < cycles*2*math.Pi; t += res {
             x := math.Sin(t)
             y := math.Sin(t*freq + phase)
             img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
               blackIndex)
           }
           phase += 0.1
           anim.Delay = append(anim.Delay, delay)
           anim.Image = append(anim.Image, img)
         }
         gif.EncodeAll(out, &anim) // NOTA: Ignorados errores de codificacion
       }
     < src..


#    After importing a package whose path has multiple components, like
#    @c(image/color), we refer to the package with a name that comes from the last
#    component. Thus the variable @c(color.White) belongs to the @c(image/color)
#    package and @c(gif.GIF) belongs to @c(image/gif).
   Despues de importar un paquete cuya ruta tiene multiples componentes, como
   @c(image/color), nos referimos al paquete con el nombre que procede del
   ultimo componente. Por lo tanto la variable @c(color.White) pertenece al
   paquete @c(image/color) y @c(gif.GIF) pertenece a @c(image/gif).

#    A @c(const) declaration (@l(#Section 3.6<>§3.6)) gives names to constants,
#    that is, values that are fixed at compile time, such as the numerical
#    parameters for cycles, frames, and delay. Like @c(var) declarations,
#    @c(const) declarations may appear at package level (so the names are visible
#    throughout the package) or within a function (so the names are visible only
#    within that function). The value of a constant must be a number, string, or
#    boolean.
   Una declaracion @c(const) (@l(#Seccion 3.6<>§3.6)) da nombres a las
   constantes, es decir, valores que se establecen en tiempo de compilacion,
   tales como los parametros numericos para ciclos, cuadros, y el retardo. Igual
   a las declaraciones @c(var), las declaraciones @c(const) pueden aparecer a
   nivel de paquete (por lo que los nombres son visibles en todo el paquete) o
   dentro de una funcion (por lo que los nombres son visibles solo dentro de esa
   funcion). El valor de una constante debe ser un numero, una cadena o un
   booleano.

#    The expressions @c([]color.Color{...}) and @c(gif.GIF{...}) are @e(composite
#    literals) (@l(#Section 4.2<>§4.2), @l(#Section 4.4.1<>§4.4.1)), a compact
#    notation for instantiating any of Go’s composite types from a sequence of
#    element values. Here, the first one is a slice and the second one is a
#    @e(struct).
   Las expresiones @c([]color.Color{...}) y @c(gif.GIF{...}) son @e(literales
   compuestos) (@l(#Seccion 4.2<>§4.2), @l(#Seccion 4.4.1<>§4.4.1)), una
   notacion compacta de Go para instanciar cualquiera de los tipos compuestos de
   una secuencia de valores de los elementos. Aqui, la primera es un slice y
   la segunda es una @e(estructura).

#    The type @c(gif.GIF) is a struct type (@l(#Section 4.4<>§4.4)). A struct is a
#    group of values called @e(fields), often of different types, that are
#    collected together in a single object that can be treated as a unit. The
#    variable @c(anim) is a struct of type @c(gif.GIF). The struct literal creates
#    a struct value whose @c(LoopCount) field is set to @c(nframes); all other
#    fields have the zero value for their type. The individual fields of a struct
#    can be accessed using dot notation, as in the final two assignments which
#    explicitly update the @c(Delay) and @c(Image) fields of @c(anim).
   El tipo @c(gif.GIF) es de tipo struct (@l(#Seccion 4.4<>§4.4)). Una
   estructura es un grupo de valores denominados @e(campos), a menudo de
   diferentes tipos, que se recogen juntos en un unico objeto que puede tratarse
   como una unidad. La variable @c(anim) es una estructura de tipo
   @c(gif.GIF). La estructura literal crea un valor estructura cuyo campo
   @c(LoopCount) se establece en @c(nframes); Todos los demas campos tienen el
   valor cero para su tipo. Los campos individuales de una estructura se puede
   acceder usando la notacion punto, al igual que en las dos ultimas
   asignaciones que actualizan de forma explicita los campos @c(Delay) e
   @c(Image) de @c(anim).

#    The @c(lissajous) function has two nested loops. The outer loop runs for 64
#    iterations, each producing a single frame of the animation. It creates a new
#    201x201 image with a palette of two colors, white and black. All pixels are
#    initially set to the palette’s zero value (the zeroth color in the palette),
#    which we set to white. Each pass through the inner loop generates a new image
#    by setting some pixels to black. The result is appended, using the built-in
#    @c(append) function (@l(#Section 4.2.1<>§4.2.1)), to a list of frames in
#    @c(anim), along with a specified delay of 80ms. Finally the sequence of
#    frames and delays is encoded into GIF format and written to the output stream
#    @c(out). The type of @c(out) is @c(io.Writer), which lets us write to a wide
#    range of possible destinations, as we’ll show soon.
   La funcion @c(lissajous) tiene dos bucles anidados. El bucle exterior se
   ejecuta 64 iteraciones, cada una produciendo un solo fotograma de la
   animacion. Crea una nueva imagen de 201x201 con una paleta de dos colores,
   blanco y negro. Todos los pixeles se ajustan inicialmente al valor cero de la
   paleta (el color cero de la paleta), que se establece en blanco. Cada paso a
   traves del bucle interno genera una nueva imagen estableciendo algunos
   pixeles en negro. El resultado se añade a una lista de cuadros en @c(anim)
   utilizando la funcion incorporada @c(append) (@l(#Seccion 4.2.1<>§4.2.1)),
   junto con un retardo especificado de 80 ms. Por ultimo, la secuencia de
   cuadros y los retrasos se codifica en formato GIF y se escribe en la salida
   de fluje @c(out). El tipo de @c(out) es @c(io.Writer), lo que nos permite
   escribir a una amplia gama de posibles destinos, como vamos a mostrar pronto.

#    The inner loop runs the two oscillators. The @c(x) oscillator is just the
#    sine function. The @c(y) oscillator is also a sinusoid, but its frequency
#    relative to the @c(x) oscillator is a random number between 0 and 3, and its
#    phase relative to the @c(x) oscillator is initially zero but increases with
#    each frame of the animation. The loop runs until the @c(x) oscillator has
#    completed five full cycles. At each step, it calls @c(SetColorIndex) to color
#    the pixel corresponding to (@c(x), @c(y)) black, which is at position 1 in
#    the palette.
   El bucle interior ejecuta los dos osciladores. El oscilador @c(x) es
   simplemente la funcion sinusoidal. El oscilador @c(y) es tambien una
   sinusoide, pero su frecuencia es relativa a la del oscilador @c(x) un numero
   aleatorio entre 0 y 3, y su fase relativa al oscilador @c(x) es inicialmente
   cero, pero aumenta con cada fotograma de la animacion. El bucle se ejecuta
   hasta que el oscilador @c(x) ha completado cinco ciclos completos. En cada
   paso, que llaman a @c(SetColorIndex) para colorear el pixel correspondiente
   en (@c(x), @c(y)) negro, que es en la posicion 1 de la paleta.

#    The @c(main) function calls the @c(lissajous) function, directing it to write
#    to the standard output, so this command produces an animated GIF with frames
#    like those in Figure 1.1:
   La funcion @c(main) llama a la funcion @c(lissajous), dirigiendola a escribir en la
   salida estandar, por lo que este comando produce un GIF animado con marcos
   como los de la Figura 1.1:

#    ..src > sh
#      $ go build gopl.io/ch1/lissajous
#      $ ./lissajous >out.gif
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/lissajous
     $ ./lissajous >out.gif
   < src..

#    @b(Exercise 1.5): Change the Lissajous program’s color palette to green on
#    black, for added authenticity. To create the web color @c(#RRGGBB), use
#    @c(color.RGBA{0xRR, 0xGG, 0xBB, 0xff}), where each pair of hexadecimal digits
#    represents the intensity of the red, green, or blue component of the pixel.
   @b(Ejercicio 1.5): Cambiar la paleta de colores del programa Lissajous a
   verde sobre negro, para mayor autenticidad. Para crear el color web
   @c(#RRGGBB), utilice @c(color.RGBA{0xRR, 0xGG, 0xBB, 0xff}), donde cada par
   de digitos hexadecimales representa la intensidad del componente de color
   rojo, verde o azul del pixel.

#    @b(Exercise 1.6): Modify the Lissajous program to produce images in multiple
#    colors by adding more values to palette and then displaying them by changing
#    the third argument of @c(SetColorIndex) in some interesting way.
   @b(Ejercicio 1.6): Modificar el programa Lissajous para producir imagenes de
   multiples colores mediante la adicion de mas valores a la paleta y luego
   mostrarlos cambiando el tercer argumento de @c(SetColorIndex) de alguna
   manera interesante.

# ** Section 1.5 <> Fetching a URL
** Seccion 1.5 <>  Obtener una URL

#    For many applications, access to information from the Internet is as
#    important as access to the local file system. Go provides a collection of
#    packages, grouped under net, that make it easy to send and receive
#    information through the Internet, make low-level network connections, and set
#    up servers, for which Go’s concurrency features (introduced in @l(#Chapter
#    8)) are particularly useful.
   Para muchas aplicaciones, el acceso a la informacion de Internet es tan
   importante como el acceso al sistema de archivos local. Go ofrece una
   coleccion de paquetes, agrupados bajo @c(net), que hacen que sea facil de
   enviar y recibir informacion a traves de Internet, realizar conexiones de red
   de bajo nivel, y configurar servidores, por lo que las caracteristicas de
   concurrencia de Go (introducidas en el @l(#Capitulo 8)) son particularmente
   utiles.

#    To illustrate the minimum necessary to retrieve information over HTTP, here’s
#    a simple program called @$(fetch) that fetches the content of each specified URL
#    and prints it as uninterpreted text; it’s inspired by the invaluable utility
#    @$(curl). Obviously one would usually do more with such data, but this shows the
#    basic idea. We will use this program frequently in the book.
   Para ilustrar el minimo necesario para recuperar la informacion a traves de
   HTTP, aqui esta un programa simple llamado @$(fetch) que recupera el
   contenido de cada URL y lo imprime como texto sin interpretar; esta inspirado
   en la invaluable utilidad @$(curl) . Obviamente uno normalmente haria mas con
   tales datos, pero esto muestra la idea basica. Usaremos este programa con
   frecuencia en el libro.

#    ..figure > @l(gopl.io/ch1/fetch/main.go<>gopl.io/ch1/fetch)
   ..figure > @l(gopl.io/ch1/fetch/main.go<>gopl.io/ch1/fetch)

#      ..src > go
#        // Fetch prints the content found at each specified URL.
#        package main
#
#        import (
#          "fmt"
#          "io/ioutil"
#          "net/http"
#          "os"
#        )
#
#        func main() {
#          for _, url := range os.Args[1:] {
#            resp, err := http.Get(url)
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
#              os.Exit(1)
#            }
#            b, err := ioutil.ReadAll(resp.Body)
#            resp.Body.Close()
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
#              os.Exit(1)
#            }
#            fmt.Printf("%s", b)
#          }
#        }
#      < src..
     ..src > go
       // Fetch imprime el contenido encontrado en cada URL especificada.
       package main

       import (
         "fmt"
         "io/ioutil"
         "net/http"
         "os"
       )

       func main() {
         for _, url := range os.Args[1:] {
           resp, err := http.Get(url)
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
             os.Exit(1)
           }
           b, err := ioutil.ReadAll(resp.Body)
           resp.Body.Close()
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
             os.Exit(1)
           }
           fmt.Printf("%s", b)
         }
       }
     < src..


#    This program introduces functions from two packages, @c(net/http) and
#    @c(io/ioutil). The @c(http.Get) function makes an HTTP request and, if there
#    is no error, returns the result in the response struct @c(resp). The @c(Body)
#    field of @c(resp) contains the server response as a readable stream. Next,
#    @c(ioutil.ReadAll) reads the entire response; the result is stored in
#    @c(b). The @c(Body) stream is closed to avoid leaking resources, and
#    @c(Printf) writes the response to the standard output.
   Este programa introduce funciones a partir de dos paquetes, @c(net/http) y
   @c(io/ioutil). La funcion @c(http.Get) realiza una peticion HTTP y, si no hay
   error, devuelve el resultado en la estructura @c(resp) . El campo @c(Body) de
   @c(resp) contiene la respuesta del servidor como un flujo legible. A
   continuacion, @c(ioutil.ReadAll) lee toda la respuesta; el resultado se
   almacena en @c(b). El flujo @c(Body) es cerrado para evitar fuga de recursos
   y @c(Printf) escribe la respuesta a la salida estandar.

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://gopl.io
#      <html>
#      <head>
#      <title>The Go Programming Language</title>
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://gopl.io
     <html>
     <head>
     <title>The Go Programming Language</title>
     ...
   < src..

#    If the HTTP request fails, fetch reports the failure instead:
   Si la solicitud HTTP falla, en su lugar, @$(fetch) reportara el error:

#    ..src > sh
#      $ ./fetch http://bad.gopl.io
#      fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
#    < src..
   ..src > sh
     $ ./fetch http://bad.gopl.io
     fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
   < src..

#    In either error case, @c[os.Exit(1)] causes the process to exit with a status
#    code of 1.
   En cualquiera de los casos de error, @c[os.Exit(1)] hace que el proceso
   termine con un codigo de estado de valor 1.

#    @b(Exercise 1.7): The function call @c[io.Copy(dst, src)] reads from @c(src)
#    and writes to @c(dst). Use it instead of @c(ioutil.ReadAll) to copy the
#    response body to @c(os.Stdout) without requiring a buffer large enough to
#    hold the entire stream. Be sure to check the error result of @c(io.Copy).
   @b(Ejercicio 1.7): La funcion @c[io.Copy(dst, src)] lee desde @c(src) y
   escribe en @c(dst). Utilicelo en lugar de @c(ioutil.ReadAll) para copiar el
   cuerpo de la respuesta a @c(os.Stdout) sin requerir un buffer lo
   suficientemente grande como para contener todo el fluje de datos. Asegurese
   de comprobar el resultado del error de @c(io.Copy).

#    @b(Exercise 1.8): Modify @$(fetch) to add the prefix @c(http://) to each
#    argument URL if it is missing. You might want to use @c(strings.HasPrefix).
   @b(Ejercicio 1.8): Modificar @$(fetch) para agregar el prefijo @c(http://) a
   cada argumento URL si este so se proporciona. Es posible que desee utilizar
   @c(strings.HasPrefix).

#    @b(Exercise 1.9): Modify @$(fetch) to also print the HTTP status code, found
#    in @c(resp.Status).
   @b(Ejercicio 1.9): Modificar @$(fetch) para imprimir tambien el codigo de
   estado HTTP, que se encuentra en @c(resp.Status).

# ** Section 1.6 <> Fetching URLs Concurrently
** Seccion 1.6 <> Obteniendo URL Concurrentemente

#    One of the most interesting and novel aspects of Go is its support for
#    concurrent programming. This is a large topic, to which @l(#Chapter 8) and
#    Chapter 9 are devoted, so for now we’ll give you just a taste of Go’s main
#    concurrency mechanisms, goroutines and channels.
   Uno de los aspectos mas interesantes y novedosos de Go es su soporte para la
   programacion concurrente. Este es un tema muy amplio, al que se dedican el
   @l(#Capitulo 8) y el @l(#Capitulo 9), asi que por ahora le daremos solo una
   muestra de los principales mecanismos de la concurrencia en Go, @e(gorutinas)
   y @e(canales).

#    The next program, @$(fetchall), does the same fetch of a URL’s contents as
#    the previous example, but it fetches many URLs, all concurrently, so that the
#    process will take no longer than the longest fetch rather than the sum of all
#    the fetch times. This version of @$(fetchall) discards the responses but
#    reports the size and elapsed time for each one:
   El siguiente programa, @$(fetchall), realiza la misma busqueda del contenido
   de una URL como en el ejemplo anterior, pero obtiene muchas URL, todas al
   mismo tiempo, de modo que el proceso no tardara mas que la busqueda mas
   prolongada en lugar de la suma de todos los tiempos de busqueda. Esta version
   de @$(fetchall) descarta las respuestas, pero indica el tamaño y el tiempo
   transcurrido de cada una:

#    ..figure > @l(gopl.io/ch1/fetchall/main.go<>gopl.io/ch1/fetchall)
   ..figure > @l(gopl.io/ch1/fetchall/main.go<>gopl.io/ch1/fetchall)

#      ..src > go
#        // Fetchall fetches URLs in parallel and reports their times and sizes.
#        package main
#
#        import (
#          "fmt"
#          "io"
#          "io/ioutil"
#          "net/http"
#          "os"
#          "time"
#        )
#
#        func main() {
#          start := time.Now()
#          ch := make(chan string)
#          for _, url := range os.Args[1:] {
#            go fetch(url, ch) // start a goroutine
#          }
#          for range os.Args[1:] {
#            fmt.Println(<-ch) // receive from channel ch
#          }
#          fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
#        }
#
#        func fetch(url string, ch chan<- string) {
#          start := time.Now()
#          resp, err := http.Get(url)
#          if err != nil {
#            ch <- fmt.Sprint(err) // send to channel ch
#            return
#          }
#
#          nbytes, err := io.Copy(ioutil.Discard, resp.Body)
#          resp.Body.Close() // don't leak resources
#          if err != nil {
#            ch <- fmt.Sprintf("while reading %s: %v", url, err)
#            return
#          }
#          secs := time.Since(start).Seconds()
#          ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
#        }
#      < src..
     ..src > go
       // Fetchall busca URLs en paralelo e informa de sus tiempos y tamaños.
       package main

       import (
         "fmt"
         "io"
         "io/ioutil"
         "net/http"
         "os"
         "time"
       )

       func main() {
         start := time.Now()
         ch := make(chan string)
         for _, url := range os.Args[1:] {
           go fetch(url, ch) // inicia una gorutina
         }
         for range os.Args[1:] {
           fmt.Println(<-ch) // recibir desde el canal ch
         }
         fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
       }

       func fetch(url string, ch chan<- string) {
         start := time.Now()
         resp, err := http.Get(url)
         if err != nil {
           ch <- fmt.Sprint(err) // enviar al canal ch
           return
         }

         nbytes, err := io.Copy(ioutil.Discard, resp.Body)
         resp.Body.Close() // no pierdas recursos
         if err != nil {
           ch <- fmt.Sprintf("while reading %s: %v", url, err)
           return
         }
         secs := time.Since(start).Seconds()
         ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
       }
     < src..


#    Here’s an example:
   He aqui un ejemplo:

#    ..src > sh
#      $ go build gopl.io/ch1/fetchall
#      $ ./fetchall https://golang.org http://gopl.io https://godoc.org
#      0.14s     6852 https://godoc.org
#      0.16s     7261 https://golang.org
#      0.48s     2475 http://gopl.io
#      0.48s elapsed
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetchall
     $ ./fetchall https://golang.org http://gopl.io https://godoc.org
     0.14s     6852 https://godoc.org
     0.16s     7261 https://golang.org
     0.48s     2475 http://gopl.io
     0.48s elapsed
   < src..

#    A @e(goroutine) is a concurrent function execution. A @e(channel) is a
#    communication mechanism that allows one goroutine to pass values of a
#    specified type to another goroutine. The function @c(main) runs in a
#    goroutine and the @c(go) statement creates additional goroutines.
   Una @e(gorutina) es una funcion de ejecucion concurrente. Un @e(canal) es un
   mecanismo de comunicacion que permite a una @e(gorutina) para pasar valores
   de un tipo especificado a otra @e(gorutina). La funcion @e(main) se ejecuta
   en una gorutina y la sentencia @c(go) crea gorutinas adicionales.

#    The @c(main) function creates a channel of strings using @c(make). For each
#    command-line argument, the @c(go) statement in the first range loop starts a
#    new goroutine that calls @c(fetch) asynchronously to fetch the URL using
#    @c(http.Get). The @c(io.Copy) function reads the body of the response and
#    discards it by writing to the @c(ioutil.Discard) output stream. @c(Copy)
#    returns the byte count, along with any error that occurred. As each result
#    arrives, @c(fetch) sends a summary line on the channel @c(ch). The second
#    range loop in @c(main) receives and prints those lines.
   La funcion @c(main) crea un canal de strings utilizando @c(make) . Para cada
   argumento de linea de comandos, la sentencia @c(go) en el primer bucle inicia
   una nueva gorutina que llama a @c(fetch) asincronamente para buscar la URL
   usando @c(http.Get). La funcion @c(io.Copy) lee el cuerpo de la respuesta y
   la descarta escribiendo en el flujo de salida @c(ioutil.Discard). @c(Copy)
   devuelve el numero de bytes, junto con cualquier error que prodicido. A
   medida que llega cada resultado, @c(fetch) envia una linea de resumen en el
   canal @c(ch). El segundo bucle en @c(main) recibe e imprime esas lineas.

#    When one goroutine attempts a send or receive on a channel, it blocks until
#    another goroutine attempts the corresponding receive or send operation, at
#    which point the value is transferred and both goroutines proceed. In this
#    example, each @c(fetch) sends a value (@c(ch <-) @e(expression)) on the
#    channel @c(ch), and @c(main) receives all of them (@c(<-ch)). Having @c(main)
#    do all the printing ensures that output from each goroutine is processed as a
#    unit, with no danger of interleaving if two goroutines finish at the same
#    time.
   Cuando una gorutina intenta enviar o recibir en un canal, se bloquea hasta
   que otra gorutina intente la operacion correspondiente de recepcion o envio,
   momento en el cual se transfiere el valor y ambas gorutinas continuan. En
   este ejemplo, cada @c(fetch) envia un valor (@e(expresion) @c(ch <-)) en el
   canal @c(ch), y @c(main) recibe todos ellos (@c(<-ch)). Tener a @c(main)
   haciendo toda la impresion, asegura que la salida de cada gorutina se procesa
   como una unidad, sin el peligro de entrelazado si dos gorutinas terminan al
   mismo tiempo.

#    @b(Exercise 1.10): Find a web site that produces a large amount of
#    data. Investigate caching by running @c(fetchall) twice in succession to see
#    whether the reported time changes much. Do you get the same content each
#    time? Modify @c(fetchall) to print its output to a file so it can be
#    examined.
   @b(Ejercicio 1.10): Encontrar un sitio web que produce una gran cantidad de
   datos. Investiga el almacenamiento en cache mediante la ejecucion de
   @$(fetchall) dos veces consecutivas para ver si el tiempo reportado cambia
   mucho. ¿Obtienes el mismo contenido cada vez? Modificar @$(fetchall) para
   imprimir su salida a un archivo para que pueda ser examinado.

#    @b(Exercise 1.11): Try @c(fetchall) with longer argument lists, such as
#    samples from the top million web sites available at @l(http://www.alexa.com/<>alexa.com). How does
#    the program behave if a web site just doesn’t respond? (@l(#Section 8.9)
#    describes mechanisms for coping in such cases.)
   @b(Ejercicio 1.11): Pruebe @$(fetchall) con listas de argumentos mas
   extensas, como muestras de los mejores sitios web disponibles en
   @l(http://www.alexa.com/<>alexa.com). ¿Como se comporta el programa si un
   sitio web simplemente no responde? (La @l(#Seccion 8.9) describe los
   mecanismos para hacer frente en estos casos.)

# ** Section 1.7 <> A Web Server
** Seccion 1.7 <> Un servidor Web

#    Go’s libraries makes it easy to write a web server that responds to client
#    requests like those made by @$(fetch). In this section, we’ll show a minimal
#    server that returns the path component of the URL used to access the
#    server. That is, if the request is for @c(http://localhost:8000/hello), the
#    response will be @c(URL.Path = "/hello").
   Las Librerias de Go hacen que sea facil escribir un servidor web que responde
   a las solicitudes de los clientes, como las realizadas por @$(fetch). En esta
   seccion, mostraremos un servidor minimo que devuelve el componente de ruta de
   la URL utilizada para acceder al servidor. Es decir, si la solicitud es
   @c(http://localhost:8000/hello), la respuesta sera @c(URL.Path = "/hello").

#    ..figure > @l(gopl.io/ch1/server1/main.go<>gopl.io/ch1/server1)
   ..figure > @l(gopl.io/ch1/server1/main.go<>gopl.io/ch1/server1)

#      ..src > go
#        // Server1 is a minimal "echo" server.
#        package main
#
#        import (
#          "fmt"
#          "log"
#          "net/http"
#        )
#
#        func main() {
#          http.HandleFunc("/", handler) // each request calls handler
#          log.Fatal(http.ListenAndServe("localhost:8000", nil))
#        }
#
#        // handler echoes the Path component of the requested URL.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
#        }
#      < src..
     ..src > go
       // Server1 es un servidor de "eco" minimo.
       package main

       import (
         "fmt"
         "log"
         "net/http"
       )

       func main() {
         http.HandleFunc("/", handler) // cada solicitud llama a handler
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }
     < src..


#    The program is only a handful of lines long because library functions do most
#    of the work. The @c(main) function connects a handler function to incoming
#    URLs that begin with @c(/), which is all URLs, and starts a server listening
#    for incoming requests on port 8000. A request is represented as a struct of
#    type @c(http.Request), which contains a number of related fields, one of
#    which is the URL of the incoming request. When a request arrives, it is given
#    to the handler function, which extracts the path component (@c(/hello)) from
#    the request URL and sends it back as the response, using @c(fmt.Fprintf). Web
#    servers will be explained in detail in @l(#Section 7.7).
   El programa esta formado por solo un puñado de lineas, porque las funciones
   de la libreria hacen la mayor parte del trabajo. La funcion @c(main) conecta
   una funcion de manejo a las direcciones URL entrantes que comienzan con
   @c(/), que son todas las direcciones URL, e inicia un servidor que escucha
   las peticiones entrantes en el puerto 8000. La solicitud se representa como
   una estructura de tipo @c(http.Request), que contiene una serie de campos
   relacionados, uno de los cuales es la URL de la solicitud entrante. Cuando
   llega una peticion, se le da a la funcion de manejo, que extrae el componente
   de ruta (@c(/hello)) a partir de la URL de solicitud y la envia de vuelta
   como la respuesta, utilizando @c(fmt.Fprintf). Los servidores web se
   explicaran en detalle en la @l(#Seccion 7.7).

#    Let’s start the server in the background. On Mac OS X or Linux, add an
#    ampersand (@c(&)) to the command; on Microsoft Windows, you will need to run
#    the command without the ampersand in a separate command window.
   Iniciemos el servidor en segundo plano. En Mac OS X o GNU/Linux, añadir un
   simbolo ampersand (@c(&)) al comando; En Microsoft Windows, necesitara
   ejecutar el comando sin el signo ampersand en una ventana de comandos
   distinta.

#    ..src > sh
#      $ go run src/gopl.io/ch1/server1/main.go &
#    < src..
   ..src > sh
     $ go run src/gopl.io/ch1/server1/main.go &
   < src..

#    We can then make client requests from the command line:
   A continuacion, podemos hacer solicitudes desde la linea de comandos:

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://localhost:8000
#      URL.Path = "/"
#      $ ./fetch http://localhost:8000/help
#      URL.Path = "/help"
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://localhost:8000
     URL.Path = "/"
     $ ./fetch http://localhost:8000/help
     URL.Path = "/help"
   < src..

#    Alternatively, we can access the server from a web browser, as shown in
#    Figure 1.2.
   Como alternativa, podemos acceder al servidor desde un navegador web, como se
   muestra en la Figura 1.2.

#    ..figure > Figure 1.2. A response from the echo server.
   ..figure > Figura 1.2. Una respuesta del servidor de eco.

#      ..img > img/Figure-1.2.jpg
     ..img > img/Figure-1.2.jpg


#    It’s easy to add features to the server. One useful addition is a specific
#    URL that returns a status of some sort. For example, this version does the
#    same echo but also counts the number of requests; a request to the URL
#    @c(/count) returns the count so far, excluding @c(/count) requests
#    themselves:
   Es facil agregar funciones al servidor. Una adicion util es una URL
   especifica que devuelve un estado de algun tipo. Por ejemplo, esta version
   hace eco, pero tambien cuenta el numero de peticiones; una peticion a la URL
   @c(/count) devuelve el recuento hasta el momento, excluyendo la solicitud
   @c(/count) a si misma:

#    ..figure > @l(gopl.io/ch1/server2/main.go<>gopl.io/ch1/server2)
   ..figure > @l(gopl.io/ch1/server2/main.go<>gopl.io/ch1/server2)

#      ..src > go
#        // Server2 is a minimal "echo" and counter server.
#        package main
#
#        import (
#          "fmt"
#          "log"
#          "net/http"
#          "sync"
#        )
#
#        var mu sync.Mutex
#        var count int
#
#        func main() {
#          http.HandleFunc("/", handler)
#          http.HandleFunc("/count", counter)
#          log.Fatal(http.ListenAndServe("localhost:8000", nil))
#        }
#
#        // handler echoes the Path component of the requested URL.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          mu.Lock()
#          count++
#          mu.Unlock()
#          fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
#        }
#
#        // counter echoes the number of calls so far.
#        func counter(w http.ResponseWriter, r *http.Request) {
#          mu.Lock()
#          fmt.Fprintf(w, "Count %d\n", count)
#          mu.Unlock()
#        }
#      < src..
     ..src > go
       // Server2 es un servidor de eco y conteo minimo
       package main

       import (
         "fmt"
         "log"
         "net/http"
         "sync"
       )

       var mu sync.Mutex
       var count int

       func main() {
         http.HandleFunc("/", handler)
         http.HandleFunc("/count", counter)
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         count++
         mu.Unlock()
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }

       // counter hace eco del numero de lamadas hasta ahora.
       func counter(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         fmt.Fprintf(w, "Count %d\n", count)
         mu.Unlock()
       }
     < src..


#    The server has two handlers, and the request URL determines which one is
#    called: a request for @c(/count) invokes @c(counter) and all others invoke
#    @c(handler). A handler pattern that ends with a slash matches any URL that
#    has the pattern as a prefix. Behind the scenes, the server runs the handler
#    for each incoming request in a separate goroutine so that it can serve
#    multiple requests simultaneously. However, if two concurrent requests try to
#    update count at the same time, it might not be incremented consistently; the
#    program would have a serious bug called a @e(race condition) (@l(#Section
#    9.1<>§9.1)). To avoid this problem, we must ensure that at most one goroutine
#    accesses the variable at a time, which is the purpose of the @c[mu.Lock()]
#    and @c[mu.Unlock()] calls that bracket each access of @c(count). We’ll look
#    more closely at concurrency with shared variables in @l(#Chapter 9).
   El servidor tiene dos manejadores, y la URL de la solicitud determina cual se
   llama: una solicitud por @c(/count) invoca a @c(counter) y todas los demas
   invocan a @c(handler). Un patron de manejo que termina con una barra diagonal
   coincide con cualquier URL que tenga el patron como prefijo. Detras de
   escena, el servidor ejecuta el controlador para cada solicitud entrante en
   una gorutina separada para que pueda servir multiples solicitudes
   simultaneamente. Sin embargo, si dos solicitudes simultaneas intentan
   actualizar @c(count) al mismo tiempo, es posible que no se incremente
   consistentemente; El programa tendria un error grave llamado @e(condicion de
   carrera) (@l(#Seccion 9.1<>§9.1)). Para evitar este problema, debemos
   asegurarnos de que a lo sumo solo una gorutina accede a la variable a la vez,
   que es el proposito de las llamadas a @c[mu.Lock()] y @c[mu.Unlock()] que
   rodean el acceso a @c(count). Examinaremos mas de cerca a la concurrencia con
   variables compartidas en el @l(#Capitulo 9).

#    As a richer example, the handler function can report on the headers and form
#    data that it receives, making the server useful for inspecting and debugging
#    requests:
   Como un ejemplo mas rico, la funcion de manejo puede informar sobre los
   encabezados y datos de formulario que recibe, haciendo que el servidor sea
   util para inspeccionar y depurar peticiones:

#    ..figure > @l(gopl.io/ch1/server3/main.go<>gopl.io/ch1/server3)
   ..figure > @l(gopl.io/ch1/server3/main.go<>gopl.io/ch1/server3)

#      ..src > go
#        // handler echoes the HTTP request.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
#          for k, v := range r.Header {
#            fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
#          }
#          fmt.Fprintf(w, "Host = %q\n", r.Host)
#          fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
#          if err := r.ParseForm(); err != nil {
#            log.Print(err)
#          }
#          for k, v := range r.Form {
#            fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
#          }
#        }
#      < src..
     ..src > go
       // handler responde a la peticion HTTP.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
         for k, v := range r.Header {
           fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
         }
         fmt.Fprintf(w, "Host = %q\n", r.Host)
         fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
         if err := r.ParseForm(); err != nil {
           log.Print(err)
         }
         for k, v := range r.Form {
           fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
         }
       }
     < src..


#    This uses the fields of the @c(http.Request) struct to produce output like
#    this:
   Este utiliza los campos de la estructura @c(http.Request) para producir una
   salida como esta:

#    ..pre >
#      GET /?q=query HTTP/1.1
#      Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
#      Header["Accept-Language"] = ["en-US,en;q=0.8"]
#      Header["Connection"] = ["keep-alive"]
#      Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
#      Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
#      Host = "localhost:8000"
#      RemoteAddr = "127.0.0.1:59911"
#      Form["q"] = ["query"]
#    < pre..
   ..pre >
     GET /?q=query HTTP/1.1
     Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
     Header["Accept-Language"] = ["en-US,en;q=0.8"]
     Header["Connection"] = ["keep-alive"]
     Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
     Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
     Host = "localhost:8000"
     RemoteAddr = "127.0.0.1:59911"
     Form["q"] = ["query"]
   < pre..

#    Notice how the call to @c(ParseForm) is nested within an @c(if) statement. Go
#    allows a simple statement such as a local variable declaration to precede the
#    @c(if) condition, which is particularly useful for error handling as in this
#    example. We could have written it as
   Observe como la llamada a @c(ParseForm) esta anidada dentro de una sentencia
   @c(if). Go permite una declaracion simple, como una declaracion de variable
   local para preceder la sentencia @c(if), lo que es particularmente util para
   el tratamiento de errores como en este ejemplo. Podriamos haberlo escrito
   como

#    ..src > go
#      err := r.ParseForm()
#      if err != nil {
#        log.Print(err)
#      }
#    < src..
   ..src > go
     err := r.ParseForm()
     if err != nil {
       log.Print(err)
     }
   < src..

#    but combining the statements is shorter and reduces the scope of the variable
#    @c(err), which is good practice. We’ll define scope in @l(#Section 2.7).
   la combinacion de las sentencias es mas corta y reduce el alcance de la
   variable @c(err), que es una buena practica. Vamos a definir el alcance en la
   @l(#Seccion 2.7).

#    In these programs, we’ve seen three very different types used as output
#    streams. The @$(fetch) program copied HTTP response data to @c(os.Stdout), a
#    file, as did the @$(lissajous) program. The @$(fetchall) program threw the
#    response away (while counting its length) by copying it to the trivial sink
#    @c(ioutil.Discard). And the web server above used @c(fmt.Fprintf) to write to
#    an @c(http.ResponseWriter) representing the web browser.
   En estos programas, hemos visto tres tipos muy diferentes utilizados como
   flujos de salida. El programa @$(fetch) copia datos de la respuesta HTTP a
   @c(os.Stdout), a un archivo, al igual que el programa @$(lissajous). El
   programa @$(fetchall) arroja la respuesta copiando el flujo (mientras cuenta
   su longitud) de forma trivial en @c(ioutil.Discard). Y el anterior servidor
   web utiliza @c(fmt.Fprintf) para escribir una representacion del navegador
   @c(http.ResponseWriter).

#    Although these three types differ in the details of what they do, they all
#    satisfy a common @e(interface), allowing any of them to be used wherever an
#    output stream is needed. That interface, called @c(io.Writer), is discussed
#    in @l(#Section 7.1).
   Aunque estos tres tipos difieren en los detalles de lo que hacen, todos ellos
   satisfacen una interfaz comun, permitiendo que cualquiera pueda ser utilizado
   cuando sea necesario crear un flujo de salida. Esa interfaz, llamada
   @c(io.Writer), se discute en la @l(#Seccion 7.1).

#    Go’s interface mechanism is the topic of @l(#Chapter 7), but to give an idea
#    of what it’s capable of, let’s see how easy it is to combine the web server
#    with the @c(lissajous) function so that animated GIFs are written not to the
#    standard output, but to the HTTP client. Just add these lines to the web
#    server:
   El mecanismo de interfaz de Go es el tema del @l(#Capitulo 7), pero para dar
   una idea de lo que es capaz de hacer, vamos a ver lo facil que es combinar el
   servidor web con la funcion @c(lissajous) para que los archivos GIF animados
   se escriben no en la salida estandar, en su lugar en el cliente
   HTTP. Simplemente agregue estas lineas al servidor web:

#    ..src > go
#      handler := func(w http.ResponseWriter, r *http.Request) {
#        lissajous(w)
#      }
#      http.HandleFunc("/", handler)
#    < src..
   ..src > go
     handler := func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     }
     http.HandleFunc("/", handler)
   < src..

#    or equivalently:
   o su equivalente:

#    ..src > go
#      http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
#        lissajous(w)
#      })
#    < src..
   ..src > go
     http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     })
   < src..

#    The second argument to the @c(HandleFunc) function call immediately above is
#    a @e(function literal), that is, an anonymous function defined at its point
#    of use. We will explain it further in @l(#Section 5.6).
   El segundo argumento de la funcion @c(HandleFunc) se conoce como una
   e(funcion literal), es decir, una funcion anonima definida en su punto de
   uso. Vamos a explicar mas a fondo en la @l(#Seccion 5.6).

#    Once you’ve made this change, visit @l(http://localhost:8000) in your
#    browser. Each time you load the page, you’ll see a new animation like the one
#    in Figure 1.3.
   Una vez que haya realizado este cambio, visite @l(http://localhost:8000) en su
   navegador. Cada vez que cargue la pagina, vera una nueva animacion como la de
   la Figura 1.3.

#    @b(Exercise 1.12): Modify the Lissajous server to read parameter values from
#    the URL. For example, you might arrange it so that a URL like
#    @c(http://localhost:8000/?cycles=20) sets the number of cycles to 20 instead
#    of the default 5. Use the @c(strconv.Atoi) function to convert the string
#    parameter into an integer. You can see its documentation with @$(go doc
#    strconv.Atoi).
   @b(Ejercicio 1.12): Modificar el servidor de Lissajous para leer valores de
   los parametros de la URL. Por ejemplo, es posible disponer de forma que una
   URL como @c(http://localhost:8000/?cycles=20) establece el numero de ciclos a
   20 en lugar del predeterminado 5. Utilice la funcion @c(strconv.Atoi) para
   convertir el parametro de string a un entero. Puede ver su mediante con @$(go
   doc strconv.Atoi).

#    ..figure > Figure 1.3. Animated Lissajous figures in a browser.
   ..figure > Figura 1.3. Figuras animadas de Lissajous en un navegador.

#      ..img > img/Figure-1.3.jpg
     ..img > img/Figure-1.3.jpg

# ** Section 1.8 <> Loose Ends
** Seccion 1.8 <> Cabos sueltos

#    There is a lot more to Go than we’ve covered in this quick introduction. Here
#    are some topics we’ve barely touched upon or omitted entirely, with just
#    enough discussion that they will be familiar when they make brief appearances
#    before the full treatment.
   Hay mucho mas de Go de lo que hemos cubierto en esta introduccion rapida.
   Aqui hay algunos temas que apenas hemos tocado o omitido por completo, con
   tratamiento suficiente para empezar a familiarizarse con ellos antes de un
   tratamiento completo.

#    - Control flow :: We covered the two fundamental control-flow statements,
#      @c(if) # and @c(for), but not the @c(switch) statement, which is a
#      multi-way branch. Here’s a # small example:
   - Control flow :: Cubrimos los dos estados de flujos de control fundamentales,
     @c(if) y @c(for), pero no la sentencia @c(switch), que es una via de
     multiples ramas. Aqui hay un pequeño ejemplo:

#      ..src > go
#        switch coinflip() {
#        case "heads":
#          heads++
#        case "tails":
#          tails++
#        default:
#          fmt.Println("landed on edge!")
#        }
#      < src..
     ..src > go
       switch coinflip() {
       case "heads":
         heads++
       case "tails":
         tails++
       default:
         fmt.Println("landed on edge!")
       }
     < src..

#      The result of calling @c(coinflip) is compared to the value of each
#      case. Cases are evaluated from top to bottom, so the first matching one
#      is executed. The optional default case matches if none of the other cases
#      does; it may be placed anywhere. Cases do not fall through from one to
#      the next as in C-like languages (though there is a rarely used
#      @c(fallthrough) statement that overrides this behavior).
     El resultado de llamar a @c(coinflip) se compara con el valor de cada
     caso. Los casos se evaluan de arriba a abajo, por lo que se ejecuta la
     primera coincidencia. El caso opcional @c(default) coincide si ninguno de
     los otros casos lo hace; Puede colocarse en cualquier lugar. Los casos no
     caigan uno sobre otro, como en lenguajes tipo C (aunque hay una poco
     utilizada declaracion @c(fallthrough) que anula este comportamiento).

#      A @c(switch) does not need an operand; it can just list the cases, each of which
#      is a boolean expression:
     Un @c(switch) no necesita un operando; Solo puede enumerar los casos, cada
     uno de los cuales es una expresion booleana:

#      ..src > go
#        func Signum(x int) int {
#          switch {
#          case x > 0:
#            return +1
#          default:
#            return 0
#          case x < 0:
#            return -1
#          }
#        }
#      < src..
     ..src > go
       func Signum(x int) int {
         switch {
         case x > 0:
           return +1
         default:
           return 0
         case x < 0:
           return -1
         }
       }
     < src..

#      This form is called a @e(tagless switch); it’s equivalent to @c(switch true).
     Esta forma se llama @e(switch sin etiquetas); que es equivalente a
     @c(switch true).

#      Like the @c(for) and @c(if) statements, a @c(switch) may include an
#      optional simple statement—a short variable declaration, an increment or
#      assignment statement, or a function call—that can be used to set a value
#      before it is tested.
     Al igual que las sentencias @c(for) e @c(if), un @c(switch) puede incluir
     una declaracion, una unica declaracion de variables compacta opcional, una
     declaracion de incremento o asignacion, o una funcion de llamada que se
     puede utilizar para establecer un valor antes de ser puesto a prueba.

#      The @c(break) and @c(continue) statements modify the flow of control. A
#      @c(break) causes control to resume at the next statement after the
#      innermost @c(for), @c(switch), or @c(select) statement (which we’ll see
#      later), and as we saw in @l(#Section 1.3), a @c(continue) causes the
#      innermost @c(for) loop to start its next iteration. Statements may be
#      labeled so that @c(break) and @c(continue) can refer to them, for
#      instance to break out of several nested loops at once or to start the
#      next iteration of the outermost loop. There is even a @c(goto) statement,
#      though it’s intended for machine-generated code, not regular use by
#      programmers.
     Las declaraciones @c(break) y @c(continue) modifican el flujo de
     control. Un @c(break) proboca control se reanude la siguiente sentencia
     despues de la secuenca @c(for), @c(switch), o @c(select) (que veremos mas
     adelante) mas anidada, y como hemos visto en la @l(#Seccion 1.3), un
     @c(continue) proboca que el bucle @c(for) mas interno inicie su proxima
     iteracion. Las declaraciones pueden etiquetarse de forma que un @c(break) y
     @c(continue) pueden referirse a ellos, por ejemplo, para salir de varios
     bucles anidados a la vez o para iniciar la siguiente iteracion del bucle
     mas externo. Hay incluso una sentencia @c(goto), aunque esta destinada para
     el codigo generado por la maquina, sin el uso regular por los
     programadores.

#    - Named types :: A @c(type) declaration makes it possible to give a name to an
#      existing type. Since struct types are often long, they are nearly always
#      named. A familiar example is the definition of a @c(Point) type for a 2-D
#      graphics system:
   - Tipos con nombre :: Una declaracion @c(type) hace que sea posible dar un
     nombre a un tipo existente. Puesto que los tipos de la estructura son a
     menudo largos, se nombran casi siempre. Un ejemplo conocido es la
     definicion de un tipo para un sistema de graficos 2-D @c(Point):

#      ..src > go
#        type Point struct {
#          X, Y int
#        }
#        var p Point
#      < src..
     ..src > go
       type Point struct {
         X, Y int
       }
       var p Point
     < src..

#      Type declarations and named types are covered in @l(#Chapter 2).
     Las declaracion de tipos y tipos con nombre se trata en el @l(#Capitulo 2).

#    - Pointers :: Go provides pointers, that is, values that contain the address
#      of a variable. In some languages, notably C, pointers are relatively
#      unconstrained. In other languages, pointers are disguised as
#      @"(references,) and there’s not much that can be done with them except pass
#      them around. Go takes a position somewhere in the middle. Pointers are
#      explicitly visible. The @c(&) operator yields the address of a variable,
#      and the @c(*) operator retrieves the variable that the pointer refers to,
#      but there is no pointer arithmetic. We’ll explain pointers in @l(#Section
#      2.3.2).
   - Punteros :: Go proporciona punteros, es decir, los valores que contienen
     la direccion de una variable. En algunos lenguajes, notablemente C, los
     punteros son relativamente sin restricciones. En otros lenguajes, los
     punteros son disfrazados como @"(referencias), y no hay mucho que se
     pueda hacer con ellos, excepto pasar a su alrededor. Go toma una posicion
     en algun lugar en el medio. Los punteros son explicitamente
     visibles. operador @c(&) obtiene la direccion de una variable, y el
     operador @c(*) recupera la variable a la que se refiere el puntero, pero
     no hay aritmetica de punteros. Vamos a explicar los punteros en la
     @l(#Seccion 2.3.2).

#    - Methods and interfaces :: A method is a function associated with a named
#      type; Go is unusual in that methods may be attached to almost any named
#      type. Methods are covered in @l(#Chapter 6). Interfaces are abstract types
#      that let us treat different concrete types in the same way based on what
#      methods they have, not how they are represented or implemented. Interfaces
#      are the subject of @l(#Chapter 7).
   - Metodos e interfaces :: Un metodo es una funcion asociada con un tipo de
     dato; Go es inusual en el echo que los metodos se pueden vincular a casi
     cualquier tipo nombrado. Los Metodos son cubiertos en el @l(#Capitulo
     6). Las interfaces son tipos abstractos que nos permiten manejar tipos
     concretos diferentes de la misma manera basados ​​en que metodos tienen, no
     como se representan o implementan. Las interfaces son el tema del
     @l(#Capitulo 7).

#    - Packages :: Go comes with an extensive standard library of useful packages,
#      and the Go community has created and shared many more. Programming is often
#      more about using existing packages than about writing original code of
#      one’s own. Throughout the book, we will point out a couple of dozen of the
#      most important standard packages, but there are many more we don’t have
#      space to mention, and we cannot provide anything remotely like a complete
#      reference for any package.
   - Paquetes :: Go llega con una extensa libreria de paquetes utiles estandar,
     y la comunidad Go ha creado y compartido muchas mas. La programacion es a
     menudo mas sobre el uso de paquetes existentes que sobre la escritura de
     codigo propio original. A lo largo del libro, vamos a señalar un par de
     docenas de los paquetes estandar mas importantes, pero hay muchos mas que
     no tenemos espacio para mencionar, y no podemos proporcionar nada
     remotamente cercana a una referencia completa para cualquier paquete.

#      Before you embark on any new program, it’s a good idea to see if packages
#      already exist that might help you get your job done more easily. You can find
#      an index of the standard library packages at @l(https://golang.org/pkg) and
#      the packages contributed by the community at @l(https://godoc.org). The @$(go
#      doc) tool makes these documents easily accessible from the command line:
     Antes de embarcarse en cualquier programa nuevo, es una buena idea ver si
     ya existen paquetes que podrian ayudarle a hacer su trabajo mas
     facilmente. Puede encontrar un indice de los paquetes de librerias estandar
     en @l(https://golang.org/pkg) y los paquetes aportados por la comunidad en
     @l(https://godoc.org). La herramienta @$(go doc) hace que estos documentos
     sean facilmente accesibles desde la linea de comandos:

#      ..src > sh
#        $ go doc http.ListenAndServe
#        package http // import "net/http"
#
#        func ListenAndServe(addr string, handler Handler) error
#            ListenAndServe listens on the TCP network address addr and then
#            calls Serve with handler to handle requests on incoming connections.
#        ...
#      < src..
     ..src > sh
       $ go doc http.ListenAndServe
       package http // import "net/http"

       func ListenAndServe(addr string, handler Handler) error
           ListenAndServe listens on the TCP network address addr and then
           calls Serve with handler to handle requests on incoming connections.
       ...
     < src..

#    - Comments :: We have already mentioned documentation comments at the
#      beginning of a program or package. It’s also good style to write a comment
#      before the declaration of each function to specify its behavior. These
#      conventions are important, because they are used by tools like @$(go doc)
#      and @$(godoc) to locate and display documentation (@l(#Section
#      10.7.4<>§10.7.4)).
   - Comentarios :: Ya hemos mencionado los comentarios de documentacion al
     inicio de un programa o paquete. Tambien es un buen estilo escribir un
     comentario antes de la declaracion de cada funcion para especificar su
     comportamiento. Estas convenciones son importantes, ya que se utilizan por
     herramientas como @$(go doc) y @$(godoc) para localizar y monstrar la
     documentacion en pantalla (@l(#Seccion 10.7.4<>§10.7.4)).

#      For comments that span multiple lines or appear within an expression or
#      statement, there is also the @c(/* ... */) notation familiar from other
#      languages. Such comments are sometimes used at the beginning of a file for
#      a large block of explanatory text to avoid a @c(//) on every line. Within a
#      comment, @c(//) and @c(/*) have no special meaning, so comments do not
#      nest.
     Para los comentarios que abarcan varias lineas o aparecen dentro de una
     expresion o declaracion, tambien existe la conocida notacion @c(/* ... */)
     de otros lenguajes. Este tipo de comentarios se utilizan a veces al
     principio de un archivo en un gran bloque de texto explicativo para evitar
     un @c(//) en cada linea. Dentro de un comentario, @c(//) y @c(/*) no tienen
     ningun significado especial, por que los comentarios no se anidan.

# * Chapter 2 <> Program Structure
* Capitulo 2 <> Estructura del programa

#   In Go, as in any other programming language, one builds large programs from a
#   small set of basic constructs. Variables store values. Simple expressions are
#   combined into larger ones with operations like addition and subtraction. Basic
#   types are collected into aggregates like arrays and structs. Expressions are
#   used in statements whose execution order is determined by control-flow
#   statements like @c(if) and @c(for). Statements are grouped into functions for
#   isolation and reuse. Functions are gathered into source files and packages.
  En Go, como en cualquier otro lenguaje de programacion, se construyen grandes
  programas a partir de un pequeño conjunto de construcciones basicas. Las
  variables almacenan los valores. Las expresiones simples se combinan en las
  mas grandes con operaciones como suma y resta. Los tipos basicos se reunen en
  agregados como matrices y estructuras. Las expresiones se utilizan en
  declaraciones cuyo orden de ejecucion es determinado por instrucciones de
  control de flujo como @c(if) y @c(for). Las declaraciones se agrupan en
  funciones por aislamiento y reutilizacion. Las funciones se agrupan en
  archivos de codigo fuente y paquetes.

#   We saw examples of most of these in the previous chapter. In this chapter,
#   we’ll go into more detail about the basic structural elements of a Go
#   program. The example programs are intentionally simple, so we can focus on the
#   language without getting sidetracked by complicated algorithms or data
#   structures.
  Vimos ejemplos de la mayoria de estos en el capitulo anterior. En este
  capitulo, vamos a entrar en mas detalles sobre los elementos estructurales
  basicos de un programa Go. Los programas de ejemplo son intencionalmente
  simples, por lo que podemos centrarnos en el lenguaje sin desviarnos de
  complicados algoritmos o estructuras de datos.

# ** Section 2.1 <> Names
** Seccion 2.1 <> Nombres

#    The names of Go functions, variables, constants, types, statement labels, and
#    packages follow a simple rule: a name begins with a letter (that is, anything
#    that Unicode deems a letter) or an underscore and may have any number of
#    additional letters, digits, and underscores. Case matters: @c(heapSort) and
#    @c(Heapsort) are different names.
   Los nombres de las funciones Go, variables, constantes, tipos, etiquetas de
   instrucciones y paquetes siguen una regla simple: un nombre comienza con una
   letra (es decir, cualquier cosa que Unicode considera una letra) o un guion
   bajo y puede tener cualquier numero de letras adicionales, Digitos y giones
   bajos. Las mayusculas importan: @c(heapSort) y @c(Heapsort) son nombres
   diferentes.

#    Go has 25 @e(keywords) like @c(if) and @c(switch) that may be used only where the
#    syntax permits; they can’t be used as names.
   Go tiene 25 @e(palabras claves) como @c(if) y @c(switch) que solo puede
   utilizarse cuando la sintaxis lo permita; No pueden usarse como nombres.

#    ..pre >
#      break      default       func     interface   select
#      case       defer         go       map         struct
#      chan       else          goto     package     switch
#      const      fallthrough   if       range       type
#      continue   for           import   return      var
#    < pre..
   ..pre >
     break      default       func     interface   select
     case       defer         go       map         struct
     chan       else          goto     package     switch
     const      fallthrough   if       range       type
     continue   for           import   return      var
   < pre..

#    In addition, there are about three dozen @e(predeclared) names like @c(int)
#    and @c(true) for built-in constants, types, and functions:
   Ademas, hay cerca de tres docenas de nombres @e(predeclarados) como @c(int) y
   @c(true) para las constantes, tipos y funciones incorporadas:

#    - Constants ::
   - Constantes ::

#      ..pre >
#        true false iota nil
     ..pre >
       true false iota nil

#    - Types     ::
   - Tipos      ::

#      ..pre >
#        int int8 int16 int32 int64
#        uint uint8 uint16 uint32 uint64 uintptr
#        float32 float64 complex128 complex64
#        bool byte rune string error
     ..pre >
       int int8 int16 int32 int64
       uint uint8 uint16 uint32 uint64 uintptr
       float32 float64 complex128 complex64
       bool byte rune string error

#    - Functions ::
   - Functions  ::

#      ..pre >
#        make len cap new append copy close delete
#        complex real imag
#        panic recover
     ..pre >
       make len cap new append copy close delete
       complex real imag
       panic recover


#    These names are not reserved, so you may use them in declarations. We’ll see
#    a handful of places where redeclaring one of them makes sense, but beware of
#    the potential for confusion.
   Estos nombres no estan reservados, por lo que puede utilizarlos en
   declaraciones. Vamos a ver un puñado de lugares donde redeclarar uno de
   ellos tiene sentido, pero tenga cuidado con la potencial confusion.

#    If an entity is declared within a function, it is @e(local) to that
#    function. If declared outside of a function, however, it is visible in all
#    files of the package to which it belongs. The case of the first letter of a
#    name determines its visibility across package boundaries. If the name begins
#    with an upper-case letter, it is @e(exported), which means that it is visible
#    and accessible outside of its own package and may be referred to by other
#    parts of the program, as with @c(Printf) in the @c(fmt) package. Package
#    names themselves are always in lower case.
   Si una entidad se declara dentro de una funcion, esta es @e(local) a esa
   funcion. Si se declara fuera de una funcion, sin embargo, es visible en todos
   los archivos del paquete al que pertenece. La primer letra de un nombre
   determina su visibilidad a traves de los limites del paquete. Si el nombre
   comienza con una letra mayuscula, se exporta, lo que significa que es visible
   y accesible fuera de su propio paquete y puede hacer referencia a otras
   partes del programa, al igual que con @c(Printf) en el paquete @c(fmt). Los
   nombres de los paquetes estan siempre en minusculas.

#    There is no limit on name length, but convention and style in Go programs
#    lean toward short names, especially for local variables with small scopes;
#    you are much more likely to see variables named @c(i) than @c(theLoopIndex).
#    Generally, the larger the scope of a name, the longer and more meaningful it
#    should be.
   No hay limite en la longitud del nombre, pero la convencion y el estilo en
   los programas de Go se inclinan hacia nombres cortos, especialmente para
   variables locales con ambitos pequeños; es mucho mas probable ver variables
   con nombre @c(i) que @c(indiceDelBucle). Generalmente, cuanto mayor es el
   alcance de un nombre, mas largo y mas significativo debe ser.

#    Stylistically, Go programmers use @"(camel case) when forming names by
#    combining words; that is, interior capital letters are preferred over
#    interior underscores. Thus the standard libraries have functions with names
#    like @c(QuoteRuneToASCII) and @c(parseRequestLine) but never
#    @c(quote_rune_to_ASCII) or @c(parse_request_line). The letters of acronyms
#    and initialisms like @A(ASCII) and @A(HTML) are always rendered in the same
#    case, so a function might be called @c(htmlEscape), @c(HTMLEscape), or @c(escapeHTML),
#    but not @c(escapeHtml).
   Estilisticamente, los programadores Go utilizan la @"(notacion camello)
   cuando se forma nombres mediante la combinacion de palabras; Es decir, las
   letras mayusculas internas se prefieren sobre los subrayados interiores. Por
   lo tanto las librerias estandar tienen funciones con nombres como
   @c(QuoteRuneToASCII) y @c(parseRequestLine) pero nunca @c(quote_rune_to_ASCII)
   o @c(parse_request_line). Las letras de acronimos y siglas como @A(ASCII) y
   @A(HTML) siempre se prestan en el mismo tipo, por lo que una funcion sera
   llamada @c(htmlEscape), @c(HTMLEscape) o @c(escapeHTML), pero no
   @c(escapeHtml).

# ** Section 2.2 <> Declarations
** Seccion 2.2 <> Declaraciones

#    A @e(declaration) names a program entity and specifies some or all of its
#    properties. There are four major kinds of declarations: @c(var), @c(const),
#    @c(type), and @c(func). We’ll talk about variables and types in this chapter,
#    constants in @l(#Chapter 3), and functions in @l(#Chapter 5).
   Una @e(declaracion) nombra una entidad del programa y especifica todas o
   algunas de sus propiedades. Hay cuatro tipos principales de declaraciones:
   @c(var), @c(const), @c(type) y @c(func). Hablaremos sobre variables y tipos
   en este capitulo, constantes en el @l(#Capitulo 3), y funciones en el
   @l(#Capitulo 5).

#    A Go program is stored in one or more files whose names end in @f(.go). Each
#    file begins with a @c(package) declaration that says what package the file is
#    part of. The @c(package) declaration is followed by any @c(import)
#    declarations, and then a sequence of @e(package-level) declarations of types,
#    variables, constants, and functions, in any order. For example, this program
#    declares a constant, a function, and a couple of variables:
   Un programa Go se almacena en uno o mas archivos cuyos nombres terminan en
   @f(.go). Cada archivo comienza con una declaracion @c(package) que indica de
   que paquete forma parte el archivo. La declaracion @c(package) es seguido por
   cualquier declaraciones @c(import), y luego una secuencia de declaraciones a
   nivel de paquete de tipos, variables, constantes y funciones, en cualquier
   orden. Por ejemplo, este programa declara una constante, una funcion y un par
   de variables:

#    ..figure > @l(gopl.io/ch2/boiling/main.go<>gopl.io/ch2/boiling)
   ..figure > @l(gopl.io/ch2/boiling/main.go<>gopl.io/ch2/boiling)

#      ..src > go
#        // Boiling prints the boiling point of water.
#        package main
#
#        import "fmt"
#
#        const boilingF = 212.0
#
#        func main() {
#          var f = boilingF
#          var c = (f - 32) * 5 / 9
#          fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
#          // Output:
#          // boiling point = 212°F or 100°C
#        }
#      < src..
     ..src > go
       // Boiling imprime el punto de ebullicion del agua.
       package main

       import "fmt"

       const boilingF = 212.0

       func main() {
         var f = boilingF
         var c = (f - 32) * 5 / 9
         fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
         // Salida:
         // boiling point = 212°F or 100°C
       }
     < src..


#    The constant @c(boilingF) is a package-level declaration (as is @c(main)),
#    whereas the variables @c(f) and @c(c) are local to the function @c(main). The
#    name of each package-level entity is visible not only throughout the source
#    file that contains its declaration, but throughout all the files of the
#    package. By contrast, local declarations are visible only within the function
#    in which they are declared and perhaps only within a small part of it.
   La constante @c(boilingF) es una declaracion de nivel de paquete (como es
   @c(main)), mientras que las variables @c(f) y @c(c) son locales a la funcion
   @c(main). El nombre de cada entidad de nivel de paquete es visible no solo en
   todo el archivo de origen que contiene su declaracion, sino en todos los
   archivos del paquete. Por el contrario, las declaraciones locales son
   visibles solo dentro de la funcion en la que se declaran y tal vez solo
   dentro de una pequeña parte de ella.

#    A function declaration has a name, a list of parameters (the variables whose
#    values are provided by the function’s callers), an optional list of results,
#    and the function body, which contains the statements that define what the
#    function does. The result list is omitted if the function does not return
#    anything. Execution of the function begins with the first statement and
#    continues until it encounters a return statement or reaches the end of a
#    function that has no results. Control and any results are then returned to
#    the caller.
   Una declaracion de funcion tiene un nombre, una lista de parametros (las
   variables cuyos valores se proporcionan por quien llama a la funcion), una
   lista opcional de resultados y el cuerpo de la funcion, que contiene las
   sentencias que definen lo que hace la funcion. La lista de resultados se
   omite si la funcion no devuelve nada. La ejecucion de la funcion comienza con
   la primer instruccion y continua hasta que encuentra una instruccion de
   retorno o llega al final de una funcion que no tiene resultados. El control y
   los resultados se devuelven a quien hiso la llamada.

#    We’ve seen a fair number of functions already and there are lots more to
#    come, including an extensive discussion in @l(#Chapter 5), so this is only a
#    sketch. The function @c(fToC) below encapsulates the temperature conversion
#    logic so that it is defined only once but may be used from multiple
#    places. Here @c(main) calls it twice, using the values of two different local
#    constants:
   Hemos visto un buen numero de funciones ya y hay muchas mas por venir,
   incluyendo una extenso tratamiento en el @l(#Capitulo 5), asi que esto es
   solo un esbozo. La funcion @c(fToC) a continuacion, encapsula la logica de
   conversion de temperatura de manera que se define solo una vez, pero puede
   utilizarse desde multiples lugares. Aqui @c(main) llama dos veces, utilizando
   los valores de las constantes de dos locales diferentes:

#    ..figure > @l(gopl.io/ch2/ftoc/main.go<>gopl.io/ch2/ftoc)
   ..figure > @l(gopl.io/ch2/ftoc/main.go<>gopl.io/ch2/ftoc)

#      ..src > go
#        // Ftoc prints two Fahrenheit-to-Celsius conversions.
#        package main
#
#        import "fmt"
#
#        func main() {
#          const freezingF, boilingF = 32.0, 212.0
#          fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
#          fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
#        }
#
#        func fToC(f float64) float64 {
#          return (f - 32) * 5 / 9
#        }
#      < src..
     ..src > go
       // Ftoc imprime dos conversiones de Fahrenheit a Celsius.
       package main

       import "fmt"

       func main() {
         const freezingF, boilingF = 32.0, 212.0
         fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
         fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
       }

       func fToC(f float64) float64 {
         return (f - 32) * 5 / 9
       }
     < src..

# ** Section 2.3 <> Variables
** Seccion 2.3 <> Variables

#    A @c(var) declaration creates a variable of a particular type, attaches a
#    name to it, and sets its initial value. Each declaration has the general form
   Un declaracion @c(var) crea una variable de un tipo particular, vinculando un
   nombre a la misma, y se define su valor inicial. Cada declaracion tiene la
   forma general

#    ..src > go
#      var name type = expression
#    < src..
   ..src > go
     var nombre tipo = expresion
   < src..

#    Either the type or the @c(= expression) part may be omitted, but not both. If
#    the type is omitted, it is determined by the initializer expression. If the
#    expression is omitted, the initial value is the @e(zero value) for the type,
#    which is @c(0) for numbers, @c(false) for booleans, @c("") for strings, and
#    @c(nil) for interfaces and reference types (slice, pointer, map, channel,
#    function). The zero value of an aggregate type like an array or a struct has
#    the zero value of all of its elements or fields.
   O bien el tipo o la parte @c(= expresion) pueden omitirse, pero no ambos. Si
   se omite el tipo, se determina mediante la expresion del inicializador. Si se
   omite la expresion, el valor inicial es el @e(valor cero) para el tipo, que
   es 0 para los numeros, @c(false) para booleanos, @c("") para string, y
   @c(nil) para interfaces y tipos de referencia (slices, punteros, mapa, canal,
   funcion). El valor cero de un tipo agregado como una matriz o una estructura
   tiene el valor cero de todos sus elementos o campos.

#    The zero-value mechanism ensures that a variable always holds a well-defined
#    value of its type; in Go there is no such thing as an uninitialized
#    variable. This simplifies code and often ensures sensible behavior of
#    boundary conditions without extra work. For example,
   El mecanismo de valor cero asegura que una variable siempre tenga un valor
   bien definido de su tipo; En Go no hay tal cosa como una variable no
   inicializada. Esto simplifica el codigo y, a menudo, asegura un
   comportamiento sensible de las condiciones limite sin trabajo adicional. Por
   ejemplo,

#    ..src > go
#      var s string
#      fmt.Println(s) // ""
#    < src..
   ..src > go
     var s string
     fmt.Println(s) // ""
   < src..

#    prints an empty string, rather than causing some kind of error or
#    unpredictable behavior. Go programmers often go to some effort to make the
#    zero value of a more complicated type meaningful, so that variables begin
#    life in a useful state.
   Imprime una cadena vacia, en lugar de causar algun tipo de error o
   comportamiento impredecible. Los programadores Go, suelen hacer algun
   esfuerzo por hacer el valor cero de un tipo mas complicado significativo, por
   lo que las variables comienzan su vida en un estado util.

#    It is possible to declare and optionally initialize a set of variables in a
#    single declaration, with a matching list of expressions. Omitting the type
#    allows declaration of multiple variables of different types:
   Es posible declarar y opcionalmente inicializar un conjunto de variables en
   una sola declaracion, con una lista de expresiones correspondiente. Omitir el
   tipo permite la declaracion de multiples variables de diferentes tipos:

#    ..src > go
#      var i, j, k int                 // int, int, int
#      var b, f, s = true, 2.3, "four" // bool, float64, string
#    < src..
   ..src > go
     var i, j, k int                 // int, int, int
     var b, f, s = true, 2.3, "four" // bool, float64, string
   < src..

#    Initializers may be literal values or arbitrary expressions. Package-level
#    variables are initialized before @c(main) begins (@l(#Section
#    2.6.2<>§2.6.2)), and local variables are initialized as their declarations
#    are encountered during function execution.
   Los inicializadores pueden ser valores literales o expresiones
   arbitrarias. Las variables a nivel de paquete se inicializan antes del inicio
   de @c(main) (@l(#Section 2.6.2<>§2.6.2)), y las variables locales se
   inicializan a medida que se encuentran sus declaraciones durante la ejecucion
   de la funcion.

#    A set of variables can also be initialized by calling a function that returns
#    multiple values:
   Tambien se puede inicializar un conjunto de variables llamando a una funcion
   que devuelve valores multiples:

#    ..src > go
#      var f, err = os.Open(name) // os.Open returns a file and an error
#    < src..
   ..src > go
     var f, err = os.Open(name) // os.Open returns a file and an error
   < src..

# *** Section 2.3.1 <> Short Variable Declarations
*** Seccion 2.3.1 <> Declaraciones de Variables Compacta

#     Within a function, an alternate form called a @e(short variable declaration)
#     may be used to declare and initialize local variables. It takes the form
#     @c(name := expression), and the type of @c(name) is determined by the type
#     of @c(expression). Here are three of the many short variable declarations in
#     the @c(lissajous) function (@l(#Section 1.4<>§1.4)):
    Dentro de una funcion, una forma alternativa llamada @e(declaracion de
    variables compacta) se puede usar para declarar e inicializar las variables
    locales. Toma la forma @c(nombre := expresion), y el tipo de @c(nombre) esta
    determinada por el tipo de @c(expresion). Aqui estan tres de las muchas
    declaraciones de variables compacta en la funcion @c(lissajous) (@l(#Seccion
    1.4<>§1.4)):

#     ..src > go
#       anim := gif.GIF{LoopCount: nframes}
#       freq := rand.Float64() * 3.0
#       t := 0.0
#     < src..
    ..src > go
      anim := gif.GIF{LoopCount: nframes}
      freq := rand.Float64() * 3.0
      t := 0.0
    < src..

#     Because of their brevity and flexibility, short variable declarations are
#     used to declare and initialize the majority of local variables. A @c(var)
#     declaration tends to be reserved for local variables that need an explicit
#     type that differs from that of the initializer expression, or for when the
#     variable will be assigned a value later and its initial value is
#     unimportant.
    Debido a su brevedad y flexibilidad, la declaracion compacta de variables se
    utilizan para declarar e inicializar la mayoria de las variables
    locales. Una sentencia @c(var) tiende a ser reservado para las variables
    locales que necesitan un tipo explicito que difiere de la de la expresion de
    inicializacion, o para cuando se le asignara un valor mas adelante la
    variable y su valor inicial no es importante.

#     ..src > go
#       i := 100                  // an int
#       var boiling float64 = 100 // a float64
#
#       var names []string
#       var err error
#       var p Point
#     < src..
    ..src > go
      i := 100                  // an int
      var boiling float64 = 100 // a float64

      var names []string
      var err error
      var p Point
    < src..

#     As with @c(var) declarations, multiple variables may be declared and initialized
#     in the same short variable declaration,
    Como con las sentencias @c(var), multiples variables pueden ser declaradas e
    inicializadas en la misma declaracion compacta de variables,

#     ..src > go
#       i, j := 0, 1
#     < src..
    ..src > go
      i, j := 0, 1
    < src..

#     but declarations with multiple initializer expressions should be used only
#     when they help readability, such as for short and natural groupings like the
#     initialization part of a @c(for) loop.
    pero las declaraciones con multiples expresiones de inicializador deben
    utilizarse solo cuando ayudan a la legibilidad, como en agrupaciones cortas
    y naturales, como la parte de inicializacion de un bucle @c(for).

#     Keep in mind that @c(:=) is a declaration, whereas @c(=) is an assignment. A
#     multi-variable declaration should not be confused with a @e(tuple
#     assignment) (@l(#Section 2.4.1<>§2.4.1)), in which each variable on the
#     left-hand side is assigned the corresponding value from the right-hand side:
    Tenga en cuenta que @c(:=) es una declaracion, mientras que @c(=) es una
    asignacion. Una declaracion de multiples variables no debe confundirse con
    una asignacion de tuplas (@l(#Seccion 2.4.1<>§2.4.1)), en la que se asigna a
    cada variable en el lado de la izquierda el valor correspondiente de la
    parte derecha:

#     ..src > go
#       i, j = j, i // swap values of i and j
#     < src..
    ..src > go
      i, j = j, i // swap values of i and j
    < src..

#     Like ordinary @c(var) declarations, short variable declarations may be used
#     for calls to functions like @c(os.Open) that return two or more values:
    Al igual que en declaraciones @c(var) ordinarias, la declaraciones de
    variables compacta se puede utilizar para las llamadas a funciones como
    @c(os.Open) que devuelve dos o mas valores:

#     ..src > go
#       f, err := os.Open(name)
#       if err != nil {
#         return err
#       }
#       // ...use f...
#       f.Close()
#     < src..
    ..src > go
      f, err := os.Open(name)
      if err != nil {
        return err
      }
      // ...use f...
      f.Close()
    < src..

#     One subtle but important point: a short variable declaration does not
#     necessarily @e(declare) all the variables on its left-hand side. If some of
#     them were already declared in the @e(same) lexical block (@l(#Section
#     2.7<>§2.7)), then the short variable declaration acts like an @e(assignment)
#     to those variables.
    Un punto sutil pero importante: una declaracion de variables compacta no
    declara necesariamente todas las variables en su lado izquierdo. Si algunos
    de ellos ya fueron declarados en el @e(mismo) bloque lexico (@l(#Seccion
    2.7<>§2.7)), entonces la declaracion de variables compacta se comporta como
    una asignacion a esas variables.

#     In the code below, the first statement declares both @c(in) and @c(err). The second
#     declares @c(out) but only assigns a value to the existing @c(err) variable.
    En el codigo siguiente, la primera sentencia declara tanto @c(in) como
    @c(err). El segundo declara @c(out) pero solo asigna un valor a la variable
    @c(err) existente.

#     ..src > go
#       in, err := os.Open(infile)
#       // ...
#       out, err := os.Create(outfile)
#     < src..
    ..src > go
      in, err := os.Open(infile)
      // ...
      out, err := os.Create(outfile)
    < src..

#     A short variable declaration must declare at least one new variable,
#     however, so this code will not compile:
    Sin embargo, una declaracion de variable corta debe declarar al menos una
    variable nueva, por lo que este codigo no compilara:

#     ..src > go
#       f, err := os.Open(infile)
#       // ...
#       f, err := os.Create(outfile) // compile error: no new variables
#     < src..
    ..src > go
      f, err := os.Open(infile)
      // ...
      f, err := os.Create(outfile) // error de compilacion: no hay nuevas variables
    < src..


#     The fix is to use an ordinary assignment for the second statement.
    La correccion consiste en utilizar una asignacion ordinaria para la segunda
    instruccion.

#     A short variable declaration acts like an assignment only to variables that
#     were already declared in the same lexical block; declarations in an outer
#     block are ignored. We’ll see examples of this at the end of the chapter.
    Una declaracion de variable compacta actua como una asignacion solo a
    variables que ya estaban declaradas en el mismo bloque lexico; Las
    declaraciones en un bloque externo se ignoran. Veremos ejemplos de esto al
    final del capitulo.

# *** Section 2.3.2 <> Pointers
*** Seccion 2.3.2 <> Punteros

#     A @e(variable) is a piece of storage containing a value. Variables created
#     by declarations are identified by a name, such as @c(x), but many variables
#     are identified only by expressions like @c(x[i]) or @c(x.f). All these
#     expressions read the value of a variable, except when they appear on the
#     lefthand side of an assignment, in which case a new value is assigned to the
#     variable.
    Una variable es una pieza de almacenamiento que contiene un valor. Las
    variables creadas por las declaraciones se identifican por un nombre, como
    @c(x), pero muchas variables se idientifican solo por expresion como
    @c(x[i]) o @c(x.f). Todas estas expresiones leen el valor de una variable,
    excepto cuando aparecen en el lado izquierdo de una asignacion, en cuyo caso
    se asigna un nuevo valor a la variable.

#     A @e(pointer) value is the @e(address) of a variable. A pointer is thus the
#     location at which a value is stored. Not every value has an address, but
#     every variable does. With a pointer, we can read or update the value of a
#     variable @e(indirectly), without using or even knowing the name of the
#     variable, if indeed it has a name.
    El valor de un @e(puntero) es la @e(direccion) de una variable. Un puntero
    es, por tanto, la ubicacion en la que se almacena un valor. No todos los
    valores tienen una direccion, pero todas las variables si. Con un puntero,
    podemos leer o actualizar el valor de una variable @e(indirectamente), sin
    utilizar o incluso saber el nombre de la variable, si es que tiene un
    nombre.

#     If a variable is declared @c(var x int), the expression @c(&x) (@"(address of
#     @c(x))) yields a pointer to an integer variable, that is, a value of type
#     @c(*int), which is pronounced @"(pointer to int.) If this value is called
#     @c(p), we say @"(@c(p) points to @c(x),) or equivalently @"(@c(p) contains
#     the address of @c(x).) The variable to which @c(p) points is written
#     @c(*p). The expression @c(*p) yields the value of that variable, an @c(int),
#     but since @c(*p) denotes a variable, it may also appear on the left-hand
#     side of an assignment, in which case the assignment updates the variable.
    Si se declara una variable @c(var x int), la expresion @c(&x) (@"(direccion
    de @c(x))) produce un puntero a una variable de de tipo entero, es decir, un
    valor de tipo @c(*int), que se pronuncia @"(puntero a int.) Si este valor se
    llama @c(p), decimos @"(@c(p) apunta a @c(x),)" o equivalentemente @"(@c(p)
    contiene la direccion de @c(x).) La variable a la que @c(p) apunta se
    escribe @c(*p). La expresion @c(*p) produce el valor de dicha variable, un
    @c(int), pero desde @c(*p) indica una variable, tambien puede aparecer en la
    parte izquierda de una asignacion, en cuyo caso la asignacion actualiza la
    variable.

#     ..src > go
#       x := 1
#       p := &x         // p, of type *int, points to x
#       fmt.Println(*p) // "1"
#       *p = 2          // equivalent to x = 2
#       fmt.Println(x)  // "2"
#     < src..
    ..src > go
      x := 1
      p := &x         // p, of type *int, points to x
      fmt.Println(*p) // "1"
      *p = 2          // equivalent to x = 2
      fmt.Println(x)  // "2"
    < src..

#     Each component of a variable of aggregate type—a field of a struct or an
#     element of an array— is also a variable and thus has an address too.
    Cada componente de una variable de tipo agregado–un campo de una estructura
    o un elemento de una matriz– es tambien una variable y por lo tanto tiene
    una direccion tambien.

#     Variables are sometimes described as @e(addressable) values. Expressions
#     that denote variables are the only expressions to which the @e(address-of)
#     operator @c(&) may be applied.
    Las variables se describen a veces como valores @e(direccionables).
    Expresiones que denotan variables son las unicas expresiones a las que el
    operador de direccion @c(&) se puede aplicar.

#     The zero value for a pointer of any type is @c(nil). The test @c(p != nil) is true
#     if @c(p) points to a variable. Pointers are comparable; two pointers are equal
#     if and only if they point to the same variable or both are nil.
    El valor cero de un puntero de cualquier tipo es @c(nil). La prueba de @c(p
    != nil) es verdadera si @c(p) apunta a una variable. Los punteros son
    comparables; Dos punteros son iguales si y solo si apuntan a la misma
    variable o ambos son @c(nil).

#     ..src > go
#       var x, y int
#       fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
#     < src..
    ..src > go
      var x, y int
      fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
    < src..

#     It is perfectly safe for a function to return the address of a local
#     variable. For instance, in the code below, the local variable @c(v) created by
#     this particular call to @c(f) will remain in existence even after the call has
#     returned, and the pointer @c(p) will still refer to it:
    Es perfectamente seguro para una funcion devolver la direccion de una
    variable local. Por ejemplo, en el codigo siguiente, la variable local @c(v)
    creada por la llamada a @c(f) seguira existiendo incluso despues de devolver
    la llamada, y el puntero @c(p) todavia se referira a ella:

#     ..src > go
#       var p = f()
#
#       func f() *int {
#         v := 1
#         return &v
#       }
#     < src..
    ..src > go
      var p = f()

      func f() *int {
        v := 1
        return &v
      }
    < src..

#     Each call of @c(f) returns a distinct value:
    Cada llamada a @c(f) devuelve un valor distinto:

#     ..src > go
#       fmt.Println(f() == f()) // "false"
#     < src..
    ..src > go
      fmt.Println(f() == f()) // "false"
    < src..

#     Because a pointer contains the address of a variable, passing a pointer
#     argument to a function makes it possible for the function to update the
#     variable that was indirectly passed. For example, this function increments
#     the variable that its argument points to and returns the new value of the
#     variable so it may be used in an expression:
    Debido a que un puntero contiene la direccion de una variable, pasar un
    argumento de puntero a una funcion hace posible que la funcion actualice la
    variable que se paso indirectamente. Por ejemplo, esta funcion incrementa la
    variable a la que apunta su argumento y devuelve el nuevo valor de la
    variable para que pueda ser utilizada en una expresion:

#     ..src > go
#       func incr(p *int) int {
#         *p++ // increments what p points to; does not change p
#         return *p
#       }
#
#       v := 1
#       incr(&v)              // side effect: v is now 2
#       fmt.Println(incr(&v)) // "3" (and v is 3)
#     < src..
    ..src > go
      func incr(p *int) int {
        *p++ // incrementa a lo que apunta p; no cambia p
        return *p
      }

      v := 1
      incr(&v)              // efecto secundario: ahora v es 2
      fmt.Println(incr(&v)) // "3" (y v es 3)
    < src..

#     Each time we take the address of a variable or copy a pointer, we create new
#     @e(aliases) or ways to identify the same variable. For example, @c(*p) is an
#     alias for @c(v). Pointer aliasing is useful because it allows us to access a
#     variable without using its name, but this is a double-edged sword: to find
#     all the statements that access a variable, we have to know all its
#     aliases. It’s not just pointers that create aliases; aliasing also occurs
#     when we copy values of other reference types like slices, maps, and
#     channels, and even structs, arrays, and interfaces that contain these types.
    Cada vez que se toma la direccion de una variable o se copia un puntero,
    creamos nuevos @e(alias) o maneras de identificar a la misma variable. Por
    ejemplo, @c(*p) es un alias para @c(v). Los punteros como alias son utiles
    porque nos permite acceder a una variable sin usar su nombre, pero esto es
    una espada de doble filo: para encontrar todas las sentencias que acceden a
    una variable, tenemos que conocer todos sus alias. No son solo los punteros
    que crean alias; los alias tambien se crean cuando copiamos valores de otros
    tipos de referencia como slices, mapas y canales, e incluso estructuras,
    matrices e interfaces que contienen estos tipos.

#     Pointers are key to the @c(flag) package, which uses a program’s
#     command-line arguments to set the values of certain variables distributed
#     throughout the program. To illustrate, this variation on the earlier
#     @$(echo) command takes two optional flags: @c(-n) causes @$(echo) to omit
#     the trailing newline that would normally be printed, and @c(-s sep) causes
#     it to separate the output arguments by the contents of the string @c(sep)
#     instead of the default single space. Since this is our fourth version, the
#     package is called @f(gopl.io/ch2/echo4).
    Los punteros son clave para el paquete @c(flag), que utiliza los argumentos
    de linea de comandos de un programa, para establecer los valores de ciertas
    variables distribuidas a lo largo del programa. Para ilustrar, esta
    variacion en el anterior comando @$(echo) tiene dos indicadores opcionales:
    @c(-n) provaca que @$(echo) omita el salto de linea final que normalmente se
    imprime, y @c(-s sep) hace que se separe los argumentos de salida por el
    contenido de la cadena @c(sep) en lugar de El espacio unico
    predeterminado. Como esta es nuestra cuarta version, el paquete se llama
    @f(gopl.io/ch2/echo4).

#     ..figure > @l(gopl.io/ch2/echo4/main.go<>gopl.io/ch2/echo4)
    ..figure > @l(gopl.io/ch2/echo4/main.go<>gopl.io/ch2/echo4)

#       ..src > go
#         // Echo4 prints its command-line arguments.
#         package main
#
#         import (
#           "flag"
#           "fmt"
#           "strings"
#         )
#
#         var n = flag.Bool("n", false, "omit trailing newline")
#         var sep = flag.String("s", " ", "separator")
#
#         func main() {
#           flag.Parse()
#           fmt.Print(strings.Join(flag.Args(), *sep))
#           if !*n {
#             fmt.Println()
#           }
#         }
#       < src..
      ..src > go
        // Echo4 imprime sus argumentos de linea de comandos.
        package main

        import (
          "flag"
          "fmt"
          "strings"
        )

        var n = flag.Bool("n", false, "omit trailing newline")
        var sep = flag.String("s", " ", "separator")

        func main() {
          flag.Parse()
          fmt.Print(strings.Join(flag.Args(), *sep))
          if !*n {
            fmt.Println()
          }
        }
      < src..


#     The function @c(flag.Bool) creates a new flag variable of type @c(bool). It
#     takes three arguments: the name of the flag (@c("n")), the variable’s
#     default value (@c(false)), and a message that will be printed if the user
#     provides an invalid argument, an invalid flag, or @c(-h) or
#     @c(-help). Similarly, @c(flag.String) takes a name, a default value, and a
#     message, and creates a @c(string) variable. The variables @c(sep) and @c(n)
#     are pointers to the flag variables, which must be accessed indirectly as
#     @c(*sep) and @c(*n).
    La funcion @c(flag.Bool) crea una nueva variable bandera de tipo @c(bool).
    Toma tres argumentos: el nombre de la bandera (@c("n")), el valor por
    defecto de la variable (@c(false)), y un mensaje que se imprimira si el
    usuario proporciona un argumento invalido, una bandera invalida, o @c(-h) o
    @c(-help). Del mismo modo, @c(flag.String) toma un nombre, un valor por
    defecto, y un mensaje, y crea una variable @c(string). Las variables @c(sep)
    y @c(n) son punteros a las variables de la bandera, que deben accederse
    indirectamente como @c(*sep) y @c(*n).

#     When the program is run, it must call @c(flag.Parse) before the flags are
#     used, to update the flag variables from their default values. The non-flag
#     arguments are available from @c[flag.Args()] as a slice of strings. If
#     @c(flag.Parse) encounters an error, it prints a usage message and calls
#     @c[os.Exit(2)] to terminate the program.
    Cuando se ejecuta el programa, debe llamar a @c(flag.Parse) antes de
    utilizar las banderas, para actualizar las variables bandera de sus valores
    por defecto. Los argumentos que no sean banderas estan disponibles mediante
    @c[flag.Args()] como un slice de strings. Si @c(flag.Parse) encuentra un
    error, se imprime un mensaje sobre el uso y llama a @c[os.Exit(2)] para terminar
    el programa.

#     Let’s run some test cases on @$(echo):
    Vamos a ejecutar algunos casos de prueba a @$(echo):

#     ..src > sh
#       $ go build gopl.io/ch2/echo4
#       $ ./echo4 a bc def
#       a bc def
#       $ ./echo4 -s / a bc def
#       a/bc/def
#       $ ./echo4 -n a bc def
#       a bc def$
#       $ ./echo4 -help
#       Usage of ./echo4:
#         -n    omit trailing newline
#         -s string
#               separator (default " ")
#     < src..
    ..src > sh
      $ go build gopl.io/ch2/echo4
      $ ./echo4 a bc def
      a bc def
      $ ./echo4 -s / a bc def
      a/bc/def
      $ ./echo4 -n a bc def
      a bc def$
      $ ./echo4 -help
      Usage of ./echo4:
        -n    omit trailing newline
        -s string
              separator (default " ")
    < src..

# *** Section 2.3.3 <> The @c(new) Function
*** Seccion 2.3.3 <> La Funcion @c(new)

#     Another way to create a variable is to use the built-in function @c(new).
#     The expression @c[new(T)] creates an @e(unnamed variable) of type @c(T),
#     initializes it to the zero value of @c(T), and returns its address, which is
#     a value of type @c(*T).
    Otra forma de crear una variable es utilizar la funcion nativa de @c(new).
    La expresion @c[new(T)] crea una @e(variable sin nombre) del tipo @c(T), la
    inicializa al valor cero de @c(T), y devuelve su direccion, que es un valor
    de tipo @c(*T).

#     ..src > go
#       p := new(int)   //  p, of type *int, points to an unnamed int variable
#       fmt.Println(*p) //  "0"
#       *p = 2          //  sets the unnamed int to 2
#       fmt.Println(*p) //  "2"
#     < src..
    ..src > go
      p := new(int)   //  p, de tipo *int, apunta a una varible int sin nombre
      fmt.Println(*p) //  "0"
      *p = 2          //  establece el int sin nombre a 2
      fmt.Println(*p) //  "2"
    < src..

#     A variable created with @c(new) is no different from an ordinary local
#     variable whose address is taken, except that there’s no need to invent (and
#     declare) a dummy name, and we can use @c[new(T)] in an expression. Thus
#     @c(new) is only a syntactic convenience, not a fundamental notion:
    Una variable creada con @c(new) no es diferente de una variable local
    ordinaria cuya direccion es tomada, excepto que no hay necesidad de inventar
    (y declarar) un nombre ficticio, y podemos usar @c[new(T)] en una expresion.
    De este modo @c(new) es solo una conveniencia sintactica, no es una idea
    fundamental:

#     the two @c(newInt) functions below have identical behaviors.
    las dos funciones @c(newInt) a continuacion tienen comportamientos
    identicos.

#     ..cols >
    ..cols >

#       ..src > go
#         func newInt() *int {
#           return new(int)
#         }
#       < src..
      ..src > go
        func newInt() *int {
          return new(int)
        }
      < src..

#       ::
      ::

#       ..src > go
#         func newInt() *int {
#           var dummy int
#           return &dummy
#         }
#       < src..
      ..src > go
        func newInt() *int {
          var dummy int
          return &dummy
        }
      < src..

#     Each call to @c(new) returns a distinct variable with a unique address:
    Cada llamada a @c(new) devuelve una variable distinta con una direccion
    unica:

#     ..src > go
#       p := new(int)
#       q := new(int)
#       fmt.Println(p == q) // "false"
#     < src..
    ..src > go
      p := new(int)
      q := new(int)
      fmt.Println(p == q) // "false"
    < src..

#     There is one exception to this rule: two variables whose type carries no
#     information and is therefore of size zero, such as @c(struct{}) or
#     @c([0]int), may, depending on the implementation, have the same address.
    Hay una excepcion a esta regla: dos variables cuyo tipo no lleva ninguna
    informacion y por lo tanto es de tamaño cero, como @c(struct{}) o
    @c([0]int), puede, dependiendo de la aplicacion, tener la misma direccion.

#     The @c(new) function is relatively rarely used because the most common
#     unnamed variables are of struct types, for which the struct literal syntax
#     (@l(#Section 4.4.1<>§4.4.1)) is more flexible.
    La funcion @c(new) se utiliza relativamente rara vez porque las variables
    sin nombre mas comunes son de tipo estructura, para el que la sintaxis
    literal @c(struct) (@l(#Seccion 4.4.1<>§4.4.1)) es mas flexible.

#     Since @c(new) is a predeclared function, not a keyword, it’s possible to redefine the name for
#     something else within a function, for example:
    Dado que @c(new) es una funcion nativa, no una palabra clave, es posible
    redefinir el nombre para algo distinto dentro de una funcion, por ejemplo:

#     ..src > go
#       func delta(old, new int) int { return new - old }
#     < src..
    ..src > go
      func delta(old, new int) int { return new - old }
    < src..

#     Of course, within @c(delta), the built-in @c(new) function is unavailable.
    Por supuesto, dentro de @c(delta), la funcion nativa @c(new) no esta
    disponible.

# *** Section 2.3.4 <> Lifetime of Variables
*** Seccion 2.3.4 <> Tiempo de Vida de las Variables

#     The @e(lifetime) of a variable is the interval of time during which it
#     exists as the program executes.  The lifetime of a package-level variable is
#     the entire execution of the program. By contrast, local variables have
#     dynamic lifetimes: a new instance is created each time the declaration
#     statement is executed, and the variable lives on until it becomes
#     @e(unreachable), at which point its storage may be recycled. Function
#     parameters and results are local variables too; they are created each time
#     their enclosing function is called.
    La @e(vida util) de una variable es el intervalo de tiempo durante el cual
    existe a medida que el programa se ejecuta. La duracion de una variable a
    nivel de paquete, es la ejecucion completa del programa. Por el contrario,
    las variables locales tienen una vida util dinamica: una nueva instancia se
    crea cada vez que se ejecuta la instruccion de declaracion, y la variable
    vive hasta que se vuelve @e(inaccesible), momento en el que su
    almacenamiento se puede reciclar. Los parametros de funcion y los resultados
    tambien son variables locales; Se crean cada vez que se llama a la funcion
    que las encierra.

#     For example, in this excerpt from the Lissajous program of @l(#Section 1.4),
    Por ejemplo, en este extracto del programa de Lissajous de la @l(#Seccion 1.4),

#     ..src > go
#       for t := 0.0; t < cycles*2*math.Pi; t += res {
#         x := math.Sin(t)
#         y := math.Sin(t*freq + phase)
#         img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
#           blackIndex)
#       }
#     < src..
    ..src > go
      for t := 0.0; t < cycles*2*math.Pi; t += res {
        x := math.Sin(t)
        y := math.Sin(t*freq + phase)
        img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
          blackIndex)
      }
    < src..

#     the variable @c(t) is created each time the @c(for) loop begins, and new
#     variables @c(x) and @c(y) are created on each iteration of the loop.
    la variable @c(t) se crea cada vez que el bucle @c(for) comienza, y nuevas
    variables @c(x) y @c(y) se crean en cada iteracion del bucle.

#     How does the garbage collector know that a variable’s storage can be
#     reclaimed? The full story is much more detailed than we need here, but the
#     basic idea is that every package-level variable, and every local variable of
#     each currently active function, can potentially be the start or root of a
#     path to the variable in question, following pointers and other kinds of
#     references that ultimately lead to the variable. If no such path exists, the
#     variable has become unreachable, so it can no longer affect the rest of the
#     computation.
    ¿Como sabe el recolector de basura que el almacenamiento de una variable
    puede ser recuperado? La historia completa es mucho mas detallada de lo que
    necesitamos aqui, pero la idea basica es que cada variable a nivel de
    paquete, y cada variable local de cada funcion actualmente activa, puede ser
    el inicio o la raiz de una ruta a la variable en cuestion, sugiendo punteros
    y otros tipos de referencias que finalmente conducen a la variable. Si no
    existe tal ruta, la variable se ha vuelto inaccesible, por lo que ya no
    puede afectar el resto del calculo.

#     Because the lifetime of a variable is determined only by whether or not it
#     is reachable, a local variable may outlive a single iteration of the
#     enclosing loop. It may continue to exist even after its enclosing function
#     has returned.
    Debido a que el tiempo de vida de una variable se determina por ser o no
    accesible, una variable local puede sobrevivir a una sola iteracion del
    bucle que lo rodea. Puede seguir existiendo incluso despues de que su
    funcion de inclusion ha regresado.

#     A compiler may choose to allocate local variables on the heap or on the
#     stack but, perhaps surprisingly, this choice is not determined by whether
#     var or @c(new) was used to declare the variable.
    Un compilador puede elegir por asignar las variables locales en el monticulo
    o en la pila, pero, tal vez sorprendentemente, esta eleccion no depende de
    si se utiliza @c(var) o @c(new) para declarar la variable.

#     ..cols >
    ..cols >

#       ..src > go
#         var global *int
#
#         func f() {
#           var x int
#           x = 1
#           global = &x
#         }
#       < src..
      ..src > go
        var global *int

        func f() {
          var x int
          x = 1
          global = &x
        }
      < src..

#       ::
      ::

#       ..src > go
#         func g() {
#           y := new(int)
#           *y = 1
#         }
#       < src..
      ..src > go
        func g() {
          y := new(int)
          *y = 1
        }
      < src..

#     Here, @c(x) must be heap-allocated because it is still reachable from the
#     variable @c(global) after @c(f) has returned, despite being declared as a
#     local variable; we say @c(x) @e(escapes from) @c(f). Conversely, when @c(g)
#     returns, the variable @c(*y) becomes unreachable and can be recycled. Since
#     @c(*y) does not escape from @c(g), it’s safe for the compiler to allocate
#     @c(*y) on the stack, even though it was allocated with @c(new). In any case,
#     the notion of escaping is not something that you need to worry about in
#     order to write correct code, though it’s good to keep in mind during
#     performance optimization, since each variable that escapes requires an extra
#     memory allocation.
    Aqui, @c(x) debe ser asignado al monticulo porque todavia es accesible desde
    la variable @c(global) despues de haber devuelto @c(f), a pesar de ser
    declarado como una variable local; decimos que @c(x) escapa de @c(f). Por el
    contrario, cuando @c(g) regresa la variable @c(*y) se vuelve inaccesible y
    se pueden reciclar. Dado que @c(*y) no escapa de @c(g), es seguro para el
    compilador asignar @c(*y) en la pila, a pesar de que se asigno con @c(new).
    En cualquier caso, la nocion de escapar no es algo de lo que tengas que
    preocuparte para escribir codigo correcto, aunque es bueno tenerlo en cuenta
    durante la optimizacion de rendimiento, ya que cada variable que escapa
    requiere una asignacion de memoria adicional.

#     Garbage collection is a tremendous help in writing correct programs, but it
#     does not relieve you of the burden of thinking about memory. You don’t need
#     to explicitly allocate and free memory, but to write efficient programs you
#     still need to be aware of the lifetime of variables. For example, keeping
#     unnecessary pointers to short-lived objects within long-lived objects,
#     especially global variables, will prevent the garbage collector from
#     reclaiming the short-lived objects.
    La recoleccion de basura es una tremenda ayuda para escribir programas
    correctos, pero no elimina la carga de pensar en la memoria. No es necesario
    asignar y liberar memoria de forma explicita, pero para escribir programas
    eficientes es necesario tener en cuenta la duracion de las variables. Por
    ejemplo, mantener punteros innecesarios a objetos de corta duracion dentro
    de objetos de larga vida, especialmente variables globales, evitara que el
    recolector de basura recupere los objetos de corta duracion.

# ** Section 2.4 <> Assignments
** Seccion 2.4 <> Asignaciones

#    The value held by a variable is updated by an assignment statement, which in
#    its simplest form has a variable on the left of the @c(=) sign and an expression
#    on the right.
   El valor contenido en una variable es actualizado por una instruccion de
   asignacion, que en su forma mas simple tiene una variable a la izquierda del
   signo @c(=) y una expresion a la derecha.

#    ..src > go
#      x = 1                       // named variable
#      *p = true                   // indirect variable
#      person.name = "bob"         // struct field
#      count[x] = count[x] * scale // array or slice or map element
#    < src..
   ..src > go
     x = 1                       // variable con nombre
     *p = true                   // variable indirecta
     person.name = "bob"         // campo de ustructura
     count[x] = count[x] * scale // elemento de arreglo, slice o mapa
   < src..

#    Each of the arithmetic and bitwise binary operators has a corresponding
#    @e(assignment operator) allowing, for example, the last statement to be
#    rewritten as
   Cada uno de los operadores aritmeticos y operadores binarios a nivel de bits
   tiene su correspondiente @e(operador de asignacion) permitiendo, por ejemplo,
   reescribir la ultima instruccion como

#    ..src > go
#      count[x] *= scale
#    < src..
   ..src > go
     count[x] *= scale
   < src..

#    which saves us from having to repeat (and re-evaluate) the expression for the
#    variable.
   Lo que nos ahorra tener que repetir (y reevaluar) la expresion de la
   variable.

#    Numeric variables can also be incremented and decremented by @c(++) and
#    @c(--) statements:
   Las variables numericas tambien se pueden incrementar y disminuir con las
   declaraciones @c(++) y @c(--):

#    ..src > go
#      v := 1
#      v++    // same as v = v + 1; v becomes 2
#      v--    // same as v = v - 1; v becomes 1 again
#    < src..
   ..src > go
     v := 1
     v++    // igual a v = v + 1; v es 2
     v--    // igual a v = v - 1; v es 1 de nuevo
   < src..

# *** section 2.4.1 <> tuple assignment
*** seccion 2.4.1 <> Asignacion de Tuplas

#     another form of assignment, known as @e(tuple assignment), allows several
#     variables to be assigned at once. all of the right-hand side expressions are
#     evaluated before any of the variables are updated, making this form most
#     useful when some of the variables appear on both sides of the assignment, as
#     happens, for example, when swapping the values of two variables:
    Otra forma de asignacion, conocida como @e(asignacion de tuplas), permite
    asignar varias variables a la vez. Todas las expresiones del lado derecho se
    evaluan antes de actualizar cualquiera de las variables, haciendo que este
    formato sea mas util cuando algunas de las variables aparecen en ambos lados
    de la asignacion, como sucede, por ejemplo, al intercambiar los valores de
    dos variables:

#     ..src > go
#       x, y = y, x
#       a[i], a[j] = a[j], a[i]
#     < src..
    ..src > go
      x, y = y, x
      a[i], a[j] = a[j], a[i]
    < src..

#     or when computing the greatest common divisor (GCD) of two integers:
    O cuando se calcula el mayor comun divisor de dos enteros:

#     ..src > go
#       func gcd(x, y int) int {
#         for y != 0 {
#           x, y = y, x%y
#         }
#         return x
#       }
#     < src..
    ..src > go
      func gcd(x, y int) int {
        for y != 0 {
          x, y = y, x%y
        }
        return x
      }
    < src..

#     or when computing the n-th Fibonacci number iteratively:
    O al calcular el n-esimo numero de Fibonacci iterativamente:

#     ..src > go
#       func fib(n int) int {
#         x, y := 0, 1
#         for i := 0; i < n; i++ {
#           x, y = y, x+y
#         }
#         return x
#       }
#     < src..
    ..src > go
      func fib(n int) int {
        x, y := 0, 1
        for i := 0; i < n; i++ {
          x, y = y, x+y
        }
        return x
      }
    < src..

#     Tuple assignment can also make a sequence of trivial assignments more compact,
    La asignacion de tuplas tambien puede hacer una secuencia de tareas
    triviales mas compacta,

#     ..src > go
#       i, j, k = 2, 3, 5
#     < src..
    ..src > go
      i, j, k = 2, 3, 5
    < src..

#     though as a matter of style, avoid the tuple form if the expressions are
#     complex; a sequence of separate statements is easier to read.
    Aunque por una cuestion de estilo, evite la forma de tupla si las
    expresiones son complejas; una secuencia de declaraciones separadas es mas
    facil de leer.

#     Certain expressions, such as a call to a function with multiple results,
#     produce several values. When such a call is used in an assignment statement,
#     the left-hand side must have as many variables as the function has results.
    Ciertas expresiones, como una llamada a una funcion con resultados
    multiples, producen varios valores. Cuando se utiliza una llamada de este
    tipo en una instruccion de asignacion, el lado izquierdo debe tener tantas
    variables como la funcion tenga resultados.

#     ..src > go
#       f, err = os.Open("foo.txt") // function call returns two values
#     < src..
    ..src > go
      f, err = os.Open("foo.txt") // Llamada de funcion devuelve dos valores
    < src..

#     Often, functions use these additional results to indicate some kind of
#     error, either by returning an @c(error) as in the call to @c(os.Open), or a
#     @c(bool), usually called @c(ok). As we’ll see in later chapters, there are
#     three operators that sometimes behave this way too. If a map lookup
#     (@l(#Section 4.3<>§4.3)), type assertion (@l(#Section 7.10<>§7.10)), or
#     channel receive (@l(#Section 8.4.2<>§8.4.2)) appears in an assignment in
#     which two results are expected, each produces an additional boolean result:
    A menudo, las funciones utilizan estos resultados adicionales para indicar
    algun tipo de error, ya sea devolviendo un @c(error) como en la llamada a
    @c(os.Open), o un @c(bool), generalmente llamado @c(ok). Como veremos en
    capitulos posteriores, hay tres operadores que a veces se comportan de esta
    manera tambien. Si la busqueda en un mapa (@l(#Seccion 4.3<>§4.3)), un tipo
    de asercion (@l(#Seccion 7.10<>§7.10)), o la recepcion de un canal
    (@l(#Seccion 8.4.2<>§8.4.2)) aparece en una asignacion en la que se esperan
    dos resultados, cada una produce un resultado booleano adicional:

#     ..src > go
#       v, ok = m[key]         // map lookup
#       v, ok = x.(T)          // type assertion
#       v, ok = <-ch           // channel receive
#     < src..
    ..src > go
      v, ok = m[key]         // map lookup
      v, ok = x.(T)          // type assertion
      v, ok = <-ch           // channel receive
    < src..

#     As with variable declarations, we can assign unwanted values to the blank
#     identifier:
    Al igual que con la declaracion de variables, podemos asignar valores no
    deseados al identificador en blanco:

#     ..src > go
#       _, err = io.Copy(dst, src) // discard byte count
#       _, ok = x.(T)              // check type but discard result
#     < src..
    ..src > go
      _, err = io.Copy(dst, src) // discard byte count
      _, ok = x.(T)              // check type but discard result
    < src..

# *** Section 2.4.2 <> Assignability
*** Seccion 2.4.2 <> Asignacion

#     Assignment statements are an explicit form of assignment, but there are many
#     places in a program where an assignment occurs @e(implicitly): a function
#     call implicitly assigns the argument values to the corresponding parameter
#     variables; a @c(return) statement implicitly assigns the @c(return) operands
#     to the corresponding result variables; and a literal expression for a
#     composite type (@l(#Section 4.2<>§4.2)) such as this slice:
    Las sentencias de asignacion son una forma explicita de asignacion, pero hay
    muchos lugares en un programa donde se produce una asignacion @e(implicita):
    una llamada de funcion asigna implicitamente los valores de los argumentos a
    las variables de parametros correspondientes; una instruccion @c(return)
    asigna implicitamente los operandos de retorno a las variables de resultado
    correspondientes; y una expresion literal para un tipo compuesto
    (@l(#Seccion 4.2<>§4.2)), tal como esta slice:

#     ..src > go
#       medals := []string{"gold", "silver", "bronze"}
#     < src..
    ..src > go
      medallas := []string{"oro", "plata", "bronce"}
    < src..

#     implicitly assigns each element, as if it had been written like this:
    Implicitamente asigna cada elemento, como si se hubiera escrito asi:

#     ..src > go
#       medals[0] = "gold"
#       medals[1] = "silver"
#       medals[2] = "bronze"
#     < src..
    ..src > go
      medallas[0] = "oro"
      medallas[1] = "plata"
      medallas[2] = "bronce"
    < src..

#     The elements of maps and channels, though not ordinary variables, are also
#     subject to similar implicit assignments.
    Los elementos de mapas y canales, aunque no son variables ordinarias,
    tambien estan sujetos a asignaciones implicitas similares.

#     An assignment, explicit or implicit, is always legal if the left-hand side
#     (the variable) and the right-hand side (the value) have the same type. More
#     generally, the assignment is legal only if the value is @e(assignable) to
#     the type of the variable.
    Una asignacion, explicita o implicita, siempre es legal si el lado izquierdo
    (la variable) y el lado derecho (el valor) tienen el mismo tipo. En terminos
    mas generales, la asignacion es legal solo si el valor es @e(asignable) al
    tipo de la variable.

#     The rule for @e(assignability) has cases for various types, so we’ll explain
#     the relevant case as we introduce each new type. For the types we’ve
#     discussed so far, the rules are simple: the types must exactly match, and
#     @c(nil) may be assigned to any variable of interface or reference type.
#     Constants (@l(#Section 3.6<>§3.6)) have more flexible rules for
#     assignability that avoid the need for most explicit conversions.
    La regla para la @e(asignabilidad) tiene casos para varios tipos, por lo que
    vamos a explicar el caso relevante a medida que introducimos cada nuevo
    tipo. Para los tipos que hemos discutido hasta ahora, las reglas son
    simples: los tipos deben coincidir exactamente, y @c(nil) puede ser asignado
    a cualquier variable de interfaz o tipo de referencia. Las constantes
    (@l(#Seccion 3.6<>§3.6)) tienen reglas mas flexibles para la asignacion que
    evitan la necesidad de conversiones mas explicitos.

#     Whether two values may be compared with @c(==) and @c(!=) is related to
#     assignability: in any comparison, the first operand must be assignable to
#     the type of the second operand, or vice versa.  As with assignability, we’ll
#     explain the relevant cases for @e(comparability) when we present each new
#     type.
    Si dos valores pueden compararse con @c(==) y @c(!=) se relaciona con la
    asignacion: en cualquier comparacion, el primer operando debe ser asignable
    al tipo del segundo operando, o viceversa. Al igual que con la
    asignabilidad, vamos a explicar los casos relevantes para la comparabilidad
    cuando presentamos cada nuevo tipo.

# ** Section 2.5 <> Type Declarations
** Seccion 2.5 <> Declaraciones de tipo

#    The type of a variable or expression defines the characteristics of the
#    values it may take on, such as their size (number of bits or number of
#    elements, perhaps), how they are represented internally, the intrinsic
#    operations that can be performed on them, and the methods associated with
#    them.
   El tipo de una variable o expresion define las caracteristicas de los valores
   que puede tomar, como su tamaño (numero de bits o numero de elementos, tal
   vez), como se representan internamente, las operaciones intrinsecas que se
   pueden realizar en ellos, Y los metodos asociados con ellos.

#    In any program there are variables that share the same representation but
#    signify very different concepts. For instance, an @c(int) could be used to
#    represent a loop index, a timestamp, a file descriptor, or a month; a @c(float64)
#    could represent a velocity in meters per second or a temperature in one of
#    several scales; and a @c(string) could represent a password or the name of a
#    color.
   En cualquier programa hay variables que comparten la misma representacion
   pero que significan conceptos muy diferentes. Por ejemplo, un @c(int) podria
   ser usado para representar un indice de bucle, una marca de tiempo, un
   descriptor de archivo, o un mes; un @c(float64) podria representar una
   velocidad en metros por segundo o una temperatura en una de varias escalas; y
   un @c(string) podria representar una contraseña o el nombre de un color.

#    A @c(type) declaration defines a new @e(named type) that has the same
#    @e(underlying type) as an existing type. The named type provides a way to
#    separate different and perhaps incompatible uses of the underlying type so
#    that they can’t be mixed unintentionally.
   Una declaracion @c(type) define un nuevo @e(tipo con nombre) que tiene el
   mismo @e(tipo subyacente) como un tipo existente. El tipo nombrado
   proporciona una manera de separar los diferentes usos y quizas incompatibles
   del tipo subyacente para que no puedan ser mezclados involuntariamente.

#    ..src > go
#      type name underlying-type
#    < src..
   ..src > go
     type name underlying-type
   < src..

#    Type declarations most often appear at package level, where the named type is
#    visible throughout the package, and if the name is exported (it starts with
#    an upper-case letter), it’s accessible from other packages as well.
   Las declaraciones de tipo aparecen mas a menudo en el nivel de paquete, donde
   el tipo nombrado es visible en todo el paquete, y si el nombre se exporta
   (inicia con una letra mayuscula), es accesible desde otros paquetes tambien.

#    To illustrate type declarations, let’s turn the different temperature scales
#    into different types:
   Para ilustrar la declaracion de tipos, vamos a convertir las diferentes
   escalas de temperatura en tipos distintos:

#    ..figure > @l(gopl.io/ch2/tempconv0/celsius.go<>gopl.io/ch2/tempconv0)
   ..figure > @l(gopl.io/ch2/tempconv0/celsius.go<>gopl.io/ch2/tempconv0)

#      ..src > go
#        // Package tempconv performs Celsius and Fahrenheit temperature computations.
#        package tempconv
#
#        import "fmt"
#
#        type Celsius float64
#        type Fahrenheit float64
#
#        const (
#          AbsoluteZeroC Celsius = -273.15
#          FreezingC     Celsius = 0
#          BoilingC      Celsius = 100
#        )
#
#        func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
#        func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
#      < src..
     ..src > go
       // Paquete tempconv realiza calculos de temperatura Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
         AbsoluteZeroC Celsius = -273.15
         FreezingC     Celsius = 0
         BoilingC      Celsius = 100
       )

       func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
       func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
     < src..


#    This package defines two types, @c(Celsius) and @c(Fahrenheit), for the two
#    units of temperature. Even though both have the same underlying type,
#    @c(float64), they are not the same type, so they cannot be compared or
#    combined in arithmetic expressions. Distinguishing the types makes it
#    possible to avoid errors like inadvertently combining temperatures in the two
#    different scales; an explicit type @e(conversion) like @c[Celsius(t)] or
#    @c[Fahrenheit(t)] is required to convert from a @c[float64]. @c[Celsius(t)]
#    and @c[Fahrenheit(t)] are conversions, not function calls. They don’t change
#    the value or representation in any way, but they make the change of meaning
#    explicit.  On the other hand, the functions @c(CToF) and @c(FToC) convert
#    between the two scales; they do return different values.
   Este paquete define dos tipos, @c(Celsius) y @c(Fahrenheit), para las dos
   unidades de temperatura. A pesar de que ambos tienen el mismo tipo
   subyacente, @c(float64), no son del mismo tipo, por lo que no pueden
   compararse o ser combinados en expresiones aritmeticas. Distinguir los tipos
   hace posible evitar errores como combinar inadvertidamente temperaturas en
   las dos escalas diferentes; una conversion de tipo explicita como
   @c[Celsius(t)] o @c[Fahrenheit(t)] es necesario para convertir desde un
   @c(float64). @c[Celsius(t)] y @c[Fahrenheit(t)] son conversiones, no llamadas
   a funcion. No cambian el valor o la representacion de ninguna manera, pero
   hacen que el cambio de significado sea explicito. Por otro lado, las
   funciones @c(CToF) y @c(FToC) convertir entre las dos escalas; Estas
   devuelven valores diferentes.

#    For every type @c(T), there is a corresponding conversion operation @c[T(x)]
#    that converts the value @c(x) to type @c(T). A conversion from one type to
#    another is allowed if both have the same underlying type, or if both are
#    unnamed pointer types that point to variables of the same underlying type;
#    these conversions change the type but not the representation of the value. If
#    @c(x) is assignable to @c(T), a conversion is permitted but is usually
#    redundant,
   Para cada tipo @c(T), hay una operacion de conversion correspondiente
   @c[T(x)] que convierte el valor @c(x) al tipo @c(T). Se permite una
   conversion de un tipo a otro si ambos tienen el mismo tipo subyacente, o si
   ambos son tipos apuntador sin nombre que apuntan a variables del mismo tipo
   subyacente; Estas conversiones cambian el tipo pero no la representacion del
   valor. Si @c(x) es asignable a @c(T), se permite una conversion, pero suele
   ser redundante,

#    Conversions are also allowed between numeric types, and between string and
#    some slice types, as we will see in the next chapter. These conversions may
#    change the representation of the value. For instance, converting a
#    floating-point number to an integer discards any fractional part, and
#    converting a string to a @c([]byte) slice allocates a copy of the string
#    data. In any case, a conversion never fails at run time.
   Las conversiones tambien se permiten entre tipos numericos, y entre la cadena
   y algunos tipos de slices, como veremos en el siguiente capitulo. Estas
   conversiones pueden cambiar la representacion del valor. Por ejemplo, la
   conversion de un numero de coma flotante a un entero descarta cualquier parte
   fraccionaria, y la conversion de una cadena a un slice @c([]byte) asigna una
   copia de los datos de cadena. En cualquier caso, una conversion nunca falla
   en tiempo de ejecucion.

#    The underlying type of a named type determines its structure and
#    representation, and also the set of intrinsic operations it supports, which
#    are the same as if the underlying type had been used directly. That means
#    that arithmetic operators work the same for @c(Celsius) and @c(Fahrenheit) as
#    they do for @c(float64), as you might expect.
   El tipo subyacente de un tipo con nombre determina su estructura y
   representacion, asi como el conjunto de operaciones intrinsecas que admite,
   que son iguales que si el tipo subyacente se hubiera utilizado
   directamente. Eso significa que los operadores aritmeticos funcionan igual
   para @c(Celsius) y @c(Fahrenheit) como lo hacen para @c(float64), como se
   podria esperar.

#    ..src > go
#      fmt.Printf("%g\n", BoilingC-FreezingC)       // "100" °C
#      boilingF := CToF(BoilingC)
#      fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
#      fmt.Printf("%g\n", boilingF-FreezingC)       // compile error: type mismatch
#    < src..
   ..src > go
     fmt.Printf("%g\n", BoilingC-FreezingC)       // "100" °C
     boilingF := CToF(BoilingC)
     fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
     fmt.Printf("%g\n", boilingF-FreezingC)       // error de compilacion: tipo incorrecto
   < src..

#    Comparison operators like @c(==) and @c(<) can also be used to compare a
#    value of a named type to another of the same type, or to a value of the
#    underlying type. But two values of different named types cannot be compared
#    directly :
   Los operadores de comparacion como @c(==) y @c(<) tambien se puede utilizar
   para comparar un valor de un tipo con nombre a otro del mismo tipo, o a un
   valor del tipo subyacente. Pero dos valores de diferentes tipos con nombre no
   pueden compararse directamente:

#    ..src > go
#      var c Celsius
#      var f Fahrenheit
#      fmt.Println(c == 0)          // "true"
#      fmt.Println(f >= 0)          // "true"
#      fmt.Println(c == f)          // compile error: type mismatch
#      fmt.Println(c == Celsius(f)) // "true"!
#    < src..
   ..src > go
     var c Celsius
     var f Fahrenheit
     fmt.Println(c == 0)          // "true"
     fmt.Println(f >= 0)          // "true"
     fmt.Println(c == f)          // error de compilacion: tipo incorrecto
     fmt.Println(c == Celsius(f)) // "true"!
   < src..

#    Note the last case carefully. In spite of its name, the type conversion
#    @c[Celsius(f)] does not change the value of its argument, just its type. The
#    test is true because @c(c) and @c(f) are both zero.
   Anote cuidadosamente el ultimo caso. A pesar de su nombre, la conversion de
   tipo @c[Celsius(f)] no cambia el valor de su argumento, a su tipo. La prueba
   es cierto porque @c(c) y @c(f) son ambos cero.

#    A named type may provide notational convenience if it helps avoid writing out
#    complex types over and over again. The advantage is small when the underlying
#    type is simple like @c(float64), but big for complicated types, as we will see
#    when we discuss structs.
   Un tipo con nombre puede proporcionar conveniencia de notacion si ayuda a
   evitar escribir tipos complejos una y otra vez. La ventaja es pequeña cuando
   el tipo subyacente es tan simple como @c(float64), pero grande para los tipos
   complicados, como veremos cuando hablemos de estructuras.

#    Named types also make it possible to define new behaviors for values of the
#    type. These behaviors are expressed as a set of functions associated with the
#    type, called the type’s @e(methods).  We’ll look at methods in detail in Chapter
#    6 but will give a taste of the mechanism here.
   Los tipos nombrados tambien permiten definir nuevos comportamientos para los
   valores del tipo. Estos comportamientos se expresan como un conjunto de
   funciones asociadas con el tipo, llamado @e(metodos) del tipo. Veremos los
   metodos en detalle en el capitulo 6, pero daremos una idea del mecanismo
   aqui.

#    The declaration below, in which the @c(Celsius) parameter @c(c) appears before the
#    function name, associates with the @c(Celsius) type a method named @c(String) that
#    returns @c(c)’s numeric value followed by @c(°C):
   La siguiente declaracion, en la que el parametro @c(Celsius) @c(c) aparece
   antes del nombre de la funcion, se asocia con el tipo @c(Celsius) un metodo
   llamado @c(String) que devuelve @c(c) como un valor numerico seguido por
   @c(°C):

#    ..src > go
#      func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
#    < src..
   ..src > go
     func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
   < src..


#    Many types declare a @c(String) method of this form because it controls how
#    values of the type appear when printed as a string by the @c(fmt) package, as
#    we will see in @l(#Section 7.1).
   Muchos tipos declarar un metodo @c(String) de esta forma debido a que controla
   como aparecen los valores del tipo cuando se imprimen en una cadena con el
   paquete @c(fmt), como veremos en la @l(#Seccion 7.1).

#    ..src > go
#      c := FToC(212.0)
#      fmt.Println(c.String()) // "100°C"
#      fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
#      fmt.Printf("%s\n", c)   // "100°C"
#      fmt.Println(c)          // "100°C"
#      fmt.Printf("%g\n", c)   // "100"; does not call String
#      fmt.Println(float64(c)) // "100"; does not call String
#    < src..
   ..src > go
     c := FToC(212.0)
     fmt.Println(c.String()) // "100°C"
     fmt.Printf("%v\n", c)   // "100°C"; no es necesario llamar a String explicitamente
     fmt.Printf("%s\n", c)   // "100°C"
     fmt.Println(c)          // "100°C"
     fmt.Printf("%g\n", c)   // "100"; no llama a String
     fmt.Println(float64(c)) // "100"; no llama a String
   < src..

# ** Section 2.6 <> Packages and Files
** Seccion 2.6 <> Paquetes y Ficheros

#    Packages in Go serve the same purposes as libraries or modules in other
#    languages, supporting modularity, encapsulation, separate compilation, and
#    reuse. The source code for a package resides in one or more @f(.go) files,
#    usually in a directory whose name ends with the import path; for instance,
#    the files of the @c(gopl.io/ch1/helloworld) package are stored in directory
#    @c($GOPATH/src/gopl.io/ch1/helloworld).
   Los paquetes en Go sirven a los mismos propositos que las librerias o modulos
   en otros lenguajes, soportando modularidad, encapsulacion, compilacion
   separada y reutilizacion. El codigo fuente de un paquete reside en uno o mas
   archivos @f(.go), por lo general en un directorio cuyo nombre termina con la
   ruta de importacion; por ejemplo, los archivos del paquete
   @c(gopl.io/ch1/helloworld) se almacenan en el directorio
   @c($GOPATH/src/gopl.io/ch1/helloworld).

#    Each package serves as a separate @e(name space) for its declarations. Within
#    the @e(image) package, for example, the identifier @c(Decode) refers to a
#    different function than does the same identifier in the @c(unicode/utf16)
#    package. To refer to a function from outside its package, we must @e(qualify)
#    the identifier to make explicit whether we mean @c(image.Decode) or
#    @c(utf16.Decode).
   Cada paquete sirve como un @e(espacio de nombres) separado para sus
   declaraciones. Dentro del paquete @c(image), por ejemplo, el identificador
   @c(Decode) se refiere a una funcion diferente de la que el mismo
   identificador en el paquete @c(unicode/utf16). Para hacer referencia a una
   funcion desde fuera de su paquete, debemos @e(calificar) el identificador
   para hacer explicito si nos referimos a @c(image.Decode) o @c(utf16.Decode).

#    Packages also let us hide information by controlling which names are visible
#    outside the package, or @e(exported). In Go, a simple rule governs which
#    identifiers are exported and which are not: exported identifiers start with
#    an upper-case letter.
   Los paquetes tambien nos permiten ocultar informacion controlando que nombres
   son visibles fuera del paquete, o @e(exportados). En Go, una regla simple
   regula que identificadores se exportan y cuales no: los identificadores
   exportados comienzan con una letra mayuscula.

#    To illustrate the basics, suppose that our temperature conversion software
#    has become popular and we want to make it available to the Go community as a
#    new package. How do we do that?
   Para ilustrar los fundamentos, supongamos que nuestro software de conversion
   de temperatura se ha vuelto popular y queremos ponerlo a disposicion de la
   comunidad Go como un nuevo paquete. ¿Como hacemos eso?

#    Let’s create a package called @c(gopl.io/ch2/tempconv), a variation on the
#    previous example.  (Here we’ve made an exception to our usual rule of
#    numbering examples in sequence, so that the package path can be more
#    realistic.) The package itself is stored in two files to show how
#    declarations in separate files of a package are accessed; in real life, a
#    tiny package like this would need only one file.
   Vamos a crear un paquete llamado @c(gopl.io/ch2/tempconv), una variacion del
   ejemplo anterior. (Aqui hemos hecho una excepcion a nuestra regla habitual de
   ejemplos de numeracion en secuencia, de modo que la ruta del paquete puede
   ser mas realista.) El propio paquete se almacena en dos archivos para mostrar
   como se accede a las declaraciones en archivos separados de un paquete; En la
   vida real, un pequeño paquete como este solo necesitaria un archivo.

#    We have put the declarations of the types, their constants, and their methods
#    in @f(tempconv.go):
   Hemos puesto las declaraciones de los tipos, sus constantes y sus metodos en
   @f(tempconv.go):

#    ..figure > @l(gopl.io/ch2/tempconv/tempconv.go<>gopl.io/ch2/tempconv)
   ..figure > @l(gopl.io/ch2/tempconv/tempconv.go<>gopl.io/ch2/tempconv)

#      ..src > go
#        // Package tempconv performs Celsius and Fahrenheit conversions.
#        package tempconv
#
#        import "fmt"
#
#        type Celsius float64
#        type Fahrenheit float64
#
#        const (
#        	AbsoluteZeroC Celsius = -273.15
#        	FreezingC     Celsius = 0
#        	BoilingC      Celsius = 100
#        )
#
#        func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
#        func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
#      < src..
     ..src > go
       // El paquete tempconv realiza conversiones Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
       	AbsoluteZeroC Celsius = -273.15
       	FreezingC     Celsius = 0
       	BoilingC      Celsius = 100
       )

       func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
       func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
     < src..


#    and the conversion functions in @f(conv.go):
   y las funciones de conversion en @f(conv.go):

#    ..src > go
#      package tempconv
#
#      // CToF converts a Celsius temperature to Fahrenheit.
#      func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
#
#      // FToC converts a Fahrenheit temperature to Celsius.
#      func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
#    < src..
   ..src > go
     package tempconv

     // CToF convierte una temperatura Celsius a Fahrenheit.
     func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

     // FToC convierte una temperatura Fahrenheit a Celsius.
     func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
   < src..

#    Each file starts with a @c(package) declaration that defines the package
#    name. When the package is imported, its members are referred to as
#    @c(tempconv.CToF) and so on. Package-level names like the types and constants
#    declared in one file of a package are visible to all the other files of the
#    package, as if the source code were all in a single file. Note that
#    @f(tempconv.go) imports @c(fmt), but @f(conv.go) does not, because it does not use
#    anything from @c(fmt).
   Cada archivo comienza con una declaracion @c(package) que define el nombre
   del paquete. Cuando se importa el paquete, sus miembros se conocen como
   @c(tempconv.CToF) y asi. Los nombres a nivel de paquete como los tipos y las
   constantes declaradas en un archivo de un paquete son visibles para todos los
   otros archivos del paquete, como si el codigo fuente estuviera todo en un
   solo archivo. Observe que @f(tempconv.go) importa @c(fmt), pero @f(conv.go)
   no lo hace, ya que no utiliza nada de @c(fmt).

#    Because the package-level @c(const) names begin with upper-case letters, they too
#    are accessible with qualified names like @c(tempconv.AbsoluteZeroC):
   Debido a que los nombres @c(const) de nivel de paquete comienzan con letras
   mayusculas, tambien son accesibles con nombres calificados, por ejemplo,
   @c(tempconv.AbsoluteZeroC):

#    ..src > go
#      fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
#    < src..
   ..src > go
     fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
   < src..

#    To convert a Celsius temperature to Fahrenheit in a package that imports
#    @c(gopl.io/ch2/tempconv), we can write the following code:
   Para convertir una temperatura Celsius a Fahrenheit en un paquete que importa
   @c(gopl.io/ch2/tempconv), podemos escribir el siguiente codigo:

#    ..src > go
#      fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
#    < src..
   ..src > go
     fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
   < src..

#    The @e(doc comment) (@l(#Section 10.7.4<>§10.7.4)) immediately preceding the
#    package declaration documents the package as a whole. Conventionally, it
#    should start with a summary sentence in the style illustrated. Only one file
#    in each package should have a package doc comment. Extensive doc comments are
#    often placed in a file of their own, conventionally called @f(doc.go).
   El @c(comentario de documentacion) (@l(#Seccion 10.7.4<>§10.7.4))
   inmediatamente anterior a la declaracion del paquete, documenta el paquete en
   su conjunto. Convencionalmente, debe comenzar con una oracion de resumen en
   el estilo ilustrado. Solo un archivo en cada paquete debe tener un comentario
   de documentacion del paquete. Los comentarios de documentacion extensos, a
   menudo se colocan en su propio fichero, convencionalmente llamado @f(doc.go).

#    @b(Exercise 2.1): Add types, constants, and functions to @c(tempconv) for
#    processing temperatures in the Kelvin scale, where zero Kelvin is -273.15°C
#    and a difference of 1K has the same magnitude as 1°C.
   @b(Ejercicio 2.1): Añadir tipos, constantes y funciones a @c(tempconv) para
   el procesamiento de temperaturas en la escala Kelvin, donde cero Kelvin es
   -273,15°C y una diferencia de 1K tiene la misma magnitud de 1°C.

# *** Section 2.6.1 <> Imports
*** Seccion 2.6.1 <> Importaciones

#     Within a Go program, every package is identified by a unique string called
#     its @e(import path).  These are the strings that appear in an @c(import)
#     declaration like @c("gopl.io/ch2/tempconv"). The language specification
#     doesn’t define where these strings come from or what they mean; it’s up to
#     the tools to interpret them. When using the @$(go) tool (@l(#Chapter 10)),
#     an import path denotes a directory containing one or more Go source files
#     that together make up the package.
    Dentro de un programa Go, cada paquete se identifica por una cadena unica
    llamada la @e(ruta de importacion). Estas son las cadenas que aparecen en
    una declaracion @c(import) como @c("gopl.io/ch2/tempconv"). La
    especificacion del lenguaje no define de donde provienen estas cadenas o lo
    que significan; Depende de las herramientas para interpretarlas. Cuando se
    utiliza la herramienta @$(go) de (@l(#Capitulo 10)), una ruta de importacion
    denota un directorio que contiene uno o mas archivos de codigo fuento Go que
    juntos componen el paquete.

#     In addition to its import path, each package has a @e(package name), which
#     is the short (and not necessarily unique) name that appears in its
#     @c(package) declaration. By convention, a package’s name matches the last
#     segment of its import path, making it easy to predict that the package name
#     of @c(gopl.io/ch2/tempconv) is @c(tempconv).
    Ademas de su ruta de importacion, cada paquete tiene un nombre de paquete,
    que es corto (y no necesariamente unico) nombre que aparece en su
    declaracion @c(package). Por convencion, el nombre de un paquete coincide
    con el ultimo segmento de la ruta de importacion, por lo que es facil
    predecir que el nombre del paquete de @c(gopl.io/ch2/tempconv) es
    @c(tempconv).

#     To use @c(gopl.io/ch2/tempconv), we must import it:
    Para utilizar @c(gopl.io/ch2/tempconv), hay que importarlo:

#     ..figure > @l(gopl.io/ch2/cf/main.go<>gopl.io/ch2/cf)
    ..figure > @l(gopl.io/ch2/cf/main.go<>gopl.io/ch2/cf)

#       ..src > go
#         // Cf converts its numeric argument to Celsius and Fahrenheit.
#         package main
#
#         import (
#           "fmt"
#           "os"
#           "strconv"
#
#           "gopl.io/ch2/tempconv"
#         )
#
#         func main() {
#           for _, arg := range os.Args[1:] {
#             t, err := strconv.ParseFloat(arg, 64)
#             if err != nil {
#               fmt.Fprintf(os.Stderr, "cf: %v\n", err)
#               os.Exit(1)
#             }
#             f := tempconv.Fahrenheit(t)
#             c := tempconv.Celsius(t)
#             fmt.Printf("%s = %s, %s = %s\n",
#               f, tempconv.FToC(f), c, tempconv.CToF(c))
#           }
#         }
#       < src..
      ..src > go
        // Cf conviente su argumento numerico en Celsius y Fahrenheit.
        package main

        import (
          "fmt"
          "os"
          "strconv"

          "gopl.io/ch2/tempconv"
        )

        func main() {
          for _, arg := range os.Args[1:] {
            t, err := strconv.ParseFloat(arg, 64)
            if err != nil {
              fmt.Fprintf(os.Stderr, "cf: %v\n", err)
              os.Exit(1)
            }
            f := tempconv.Fahrenheit(t)
            c := tempconv.Celsius(t)
            fmt.Printf("%s = %s, %s = %s\n",
              f, tempconv.FToC(f), c, tempconv.CToF(c))
          }
        }
      < src..

#     The import declaration binds a short name to the imported package that may
#     be used to refer to its contents throughout the file. The @c(import) above
#     lets us refer to names within @c(gopl.io/ch2/tempconv) by using a
#     @e(qualified identifier) like @c(tempconv.CToF). By default, the short name
#     is the package name—@c(tempconv) in this case—but an import declaration may
#     specify an alternative name to avoid a conflict (@l(#Section 10.3<>§10.3)).
    La declaracion de importacion vincula un nombre corto al paquete importado
    que se puede utilizar para referirse a su contenido en todo el archivo. El
    @c(import) anterior nos permite referimos a nombres dentro de
    @c(gopl.io/ch2/tempconv) mediante el uso de un identificador calificado como
    @c(tempconv.CToF). Por defecto, el nombre corto es el nombre del paquete–en
    este caso @c(tempconv), pero una declaracion de importacion puede
    especificar un nombre alternativo para evitar un conflicto (@l(#Seccion
    10.3<>§10.3)).

#     The @$(cf) program converts a single numeric command-line argument to its value
#     in both Celsius and Fahrenheit:
    El programa @$(cf) convierte un unico argumento numerico de la linea de
    comando a su valor en grados Celsius y Fahrenheit:

#     ..src > sh
#       $ go build gopl.io/ch2/cf
#       $ ./cf 32
#       32°F = 0°C, 32°C = 89.6°F
#       $ ./cf 212
#       212°F = 100°C, 212°C = 413.6°F
#       $ ./cf -40
#       -40°F = -40°C, -40°C = -40°F
#     < src..
    ..src > sh
      $ go build gopl.io/ch2/cf
      $ ./cf 32
      32°F = 0°C, 32°C = 89.6°F
      $ ./cf 212
      212°F = 100°C, 212°C = 413.6°F
      $ ./cf -40
      -40°F = -40°C, -40°C = -40°F
    < src..

#     It is an error to import a package and then not refer to it. This check
#     helps eliminate dependencies that become unnecessary as the code evolves,
#     although it can be a nuisance during debugging, since commenting out a line
#     of code like @c[log.Print("got here!")] may remove the sole reference to the
#     package name @c(log), causing the compiler to emit an error. In this situation,
#     you need to comment out or delete the unnecessary @c(import).
    Es un error importar un paquete y luego no hacer referencia a el. Esta
    verificacion ayuda a eliminar las dependencias que se hacen innecesarias,
    cuando el codigo evoluciona, aunque puede ser una molestia durante la
    depuracion, ya que al comentar una linea de codigo como @c[log.Print("got
    here!")] puede eliminar la unica referencia al de nombre de paquete @c(log),
    probocando que el compilador emita un error. En esta situacion, es necesario
    comentar o eliminar el @c(import) innecesario.

#     Better still, use the @c(golang.org/x/tools/cmd/goimports) tool, which
#     automatically inserts and removes packages from the import declaration as
#     necessary ; most editors can be configured to run @$(goimports) each time
#     you save a file. Like the @$(gofmt) tool, it also pretty-prints Go source
#     files in the canonical format.
    Mejor aun, utilice la herramienta @c(golang.org/x/tools/cmd/goimports), que
    inserta y elimina paquetes de la declaracion de importacion, segun sea
    necesario de forma automatica; la mayoria de los editores pueden
    configurarse para ejecutar @$(goimports) cada vez que se guarda un fichero.
    Al igual que la herramienta @$(gofmt), tambien imprime bonitos ficheros de
    codigo fuene en el formato canonico.

#     @b(Exercise 2.2): Write a general-purpose unit-conversion program analogous
#     to @c(cf) that reads numbers from its command-line arguments or from the
#     standard input if there are no arguments, and converts each number into
#     units like temperature in Celsius and Fahrenheit, length in feet and meters,
#     weight in pounds and kilograms, and the like.
   @b(Ejercicio 2.2): Escribir un programa de proposito general para conversion
   de unidades analogo a @$(cf) que leea los numeros de sus argumentos de linea
   de comando o de la entrada estandar si no hay argumentos, y convierta cada
   numero en unidades como la temperatura en grados Celsius y Fahrenheit,
   longitud en Pies y metros, peso en libras y kilogramos y similares.

# *** Section 2.6.2 <> Package Initialization
*** Seccion 2.6.2 <> Inicializacion del paquete

#     Package initialization begins by initializing package-level variables in the
#     order in which they are declared, except that dependencies are resolved
#     first:
    La inicializacion del paquete comienza inicializando las variables a nivel
    de paquete en el orden en que se declaran, excepto que las dependencias se
    resuelven primero:

#     ..src > go
#       var a = b + c      // a initialized third, to 3
#       var b = f()        // b initialized second, to 2, by calling f
#       var c = 1          // c initialized first, to 1
#
#       func f() int { return c + 1 }
#     < src..
    ..src > go
      var a = b + c      // a inicializado tercero, a 3
      var b = f()        // b inicializado segundo, a 2, llamando a f
      var c = 1          // c inicializado primero, a 1

      func f() int { return c + 1 }
    < src..

#     If the package has multiple @f(.go) files, they are initialized in the order in
#     which the files are given to the compiler; the @$(go) tool sorts @f(.go) files by
#     name before invoking the compiler.
    Si el paquete tiene multiples ficheros @f(.go), se inicializan en el orden
    en que se dan los archivos al compilador; La herramienta @$(go) ordena los
    ficheros @f(.go) archivos por nombre antes de invocar el compilador.

#     Each variable declared at package level starts life with the value of its
#     initializer expression, if any, but for some variables, like tables of data,
#     an initializer expression may not be the simplest way to set its initial
#     value. In that case, the @c(init) function mechanism may be simpler. Any file
#     may contain any number of functions whose declaration is just
    Cada variable declarada en el nivel del paquete comienza su vida con el
    valor de su expresion de inicializador, pero para algunas variables, como
    tablas de datos, una expresion del inicializador no puede ser la manera mas
    simple de establecer su valor inicial. En ese caso, el mecanismo de la
    funcion @c(init) puede ser mas simple. Cualquier archivo puede contener
    cualquier numero de funciones cuya declaracion sea

#     ..src > go
#       func init() { /* ... */ }
#     < src..
    ..src > go
      func init() { /* ... */ }
    < src..

#     Such @c(init) functions can’t be called or referenced, but otherwise they
#     are normal functions.  Within each file, @c(init) functions are automatically
#     executed when the program starts, in the order in which they are declared.
    No se puede llamar o hacer referencia a estas funciones @c(init), pero por
    lo demas son funciones normales. Dentro de cada archivo, las funciones
    @c(init) se ejecutan automaticamente cuando se inicia el programa, en el
    orden en que se declaran.

#     One package is initialized at a time, in the order of imports in the
#     program, dependencies first, so a package @c(p) importing @c(q) can be sure
#     that @c(q) is fully initialized before @c(p)’s initialization begins.
#     Initialization proceeds from the bottom up; the @c(main) package is the last
#     to be initialized. In this manner, all packages are fully initialized before
#     the application’s @c(main) function begins.
    Los paquetes se inician uno a la vez, en el orden de las importaciones en el
    programa, las dependencias en primer lugar, por lo que un paquete @c(p) que
    importa a @c(q) puede estar seguro de que @c(q) se inicializa completamente
    antes de la inicialiacion de @c(p). La inicializacion procede de abajo hacia
    arriba; el paquete @c(main) es el ultimo en ser inicializado. De esta
    manera, todos los paquetes se inicializan completamente antes de que inicie
    la funcion @c(main).

#     The package below defines a function @c(PopCount) that returns the number of
#     set bits, that is, bits whose value is 1, in a @c(uint64) value, which is
#     called its @e(population count). It uses an @c(init) function to precompute
#     a table of results, @c(pc), for each possible 8-bit value so that the
#     @c(PopCount) function needn’t take 64 steps but can just return the sum of
#     eight table lookups. (This is definitely @e(not) the fastest algorithm for
#     counting bits, but it’s convenient for illustrating @c(init) functions, and
#     for showing how to precompute a table of values, which is often a useful
#     programming technique.)
    El paquete a continuacion define una funcion @c(PopCount) que devuelve el
    numero de bits establecidos, es decir, los bits cuyo valor es 1, en un valor
    @c(uint64), que se llama @e(conteo de poblacion). Utiliza una funcion
    @c(init) para calcular previamente una tabla de resultados, @c(pc), para
    cada posible valor de 8 bits de modo que la funcion @c(PopCount) no necesite
    tomar 64 pasos, pero solo puede devolver la suma de ocho consultas de
    tabla. (Esto definitivamente no es el algoritmo mas rapido para el recuento
    de bits, pero es conveniente para ilustrar las funciones @c(init), y para
    mostrar como calcular previamente una tabla de valores, que a menudo es una
    tecnica de programacion util).

#     ..figure > @l(gopl.io/ch2/popcount/main.go<>gopl.io/ch2/popcount)
    ..figure > @l(gopl.io/ch2/popcount/main.go<>gopl.io/ch2/popcount)

#       ..src > go
#         package popcount
#
#         // pc[i] is the population count of i.
#         var pc [256]byte
#
#         func init() {
#           for i := range pc {
#             pc[i] = pc[i/2] + byte(i&1)
#           }
#         }
#
#         // PopCount returns the population count (number of set bits) of x.
#         func PopCount(x uint64) int {
#           return int(pc[byte(x>>(0*8))] +
#             pc[byte(x>>(1*8))] +
#             pc[byte(x>>(2*8))] +
#             pc[byte(x>>(3*8))] +
#             pc[byte(x>>(4*8))] +
#             pc[byte(x>>(5*8))] +
#             pc[byte(x>>(6*8))] +
#             pc[byte(x>>(7*8))])
#         }
#       < src..
      ..src > go
        package popcount

        // pc[i] es el recuento de poblacion de i.
        var pc [256]byte

        func init() {
          for i := range pc {
            pc[i] = pc[i/2] + byte(i&1)
          }
        }

        // PopCount regresa el conteo de la poblacion (numero de bist establecidos) de x.
        func PopCount(x uint64) int {
          return int(pc[byte(x>>(0*8))] +
            pc[byte(x>>(1*8))] +
            pc[byte(x>>(2*8))] +
            pc[byte(x>>(3*8))] +
            pc[byte(x>>(4*8))] +
            pc[byte(x>>(5*8))] +
            pc[byte(x>>(6*8))] +
            pc[byte(x>>(7*8))])
        }
      < src..


#     Note that the range loop in @c(init) uses only the index; the value is
#     unnecessary and thus need not be included. The loop could also have been
#     written as for
    Observe que el rango del bucle en @c(init) utiliza solo el indice; El valor
    es innecesario y por lo tanto no necesita ser incluido. El bucle tambien
    podria haber sido escrito como

#     ..src > go
#       i, _ := range pc {
#     < src..
    ..src > go
      i, _ := range pc {
    < src..

#     We’ll see other uses of @c(init) functions in the next section and in
#     @l(#Section 10.5).
    Veremos otros usos de funciones @c(init) en la siguiente seccion y en la seccion
    @l(#Seccion 10.5).

#     @b(Exercise 2.3): Rewrite @c(PopCount) to use a loop instead of a single
#     expression. Compare the performance of the two versions. (@l(#Section 11.4)
#     shows how to compare the performance of different implementations
#     systematically.)
    @b(Ejercicio 2.3): Vuelve a escribir @c(PopCount) para utilizar un bucle en
    lugar de una sola expresion. Compare el rendimiento de las dos versiones. La
    (@l(#Section 11.4) muestra como comparar el rendimiento de diferentes
    implementaciones de forma sistematica.)

#     @b(Exercise 2.4): Write a version of @c(PopCount) that counts bits by shifting
#     its argument through 64 bit positions, testing the rightmost bit each
#     time. Compare its performance to the tablelookup version.
    @b(Ejercicio 2.4): Escribe una version de @c(PopCount) que cuenta los bits
    desplazando su argumento a traves de posiciones de 64 bits, poniendo a
    prueba el bit mas a la derecha cada vez. Compare su rendimiento con la
    version de buesqueda por la tabla.

#     @b(Exercise 2.5): The expression @c[x&(x-1)] clears the rightmost non-zero
#     bit of @c(x). Write a version of PopCount that counts bits by using this
#     fact, and assess its performance.
    @b(Ejercicio 2.5): La expresion @c&x&(x-1)] despeja el bit mas a la derecha
    no-cero de @c(x). Escribe una version de @c(PopCount) que cuente bits
    mediante este hecho, y evalua su rendimiento.

# ** Section 2.7 <> Scope
** Seccion 2.7 <> Alcance

#    A declaration associates a name with a program entity, such as a function or
#    a variable. The @e(scope) of a declaration is the part of the source code
#    where a use of the declared name refers to that declaration.
   Una declaracion asocia un nombre a una entidad de programa, como una funcion
   o una variable. El @e(alcance) de una declaracion es la parte del codigo
   fuente, donde el uso de un nombre declarado hace referencia a esa
   declaracion.

#    Don’t confuse scope with lifetime. The scope of a declaration is a region of
#    the program text; it is a compile-time property. The lifetime of a variable
#    is the range of time during execution when the variable can be referred to by
#    other parts of the program; it is a run-time property.
   No confunda el alcance con el tiempo de vida. El alcance de una declaracion
   es una region del texto del programa; Es una propiedad de tiempo de
   compilacion. La vida util de una variable es el intervalo de tiempo durante
   la ejecucion cuando la variable puede ser referida por otras partes del
   programa; Es una propiedad en tiempo de ejecucion.

#    A syntactic @e(block) is a sequence of statements enclosed in braces like
#    those that surround the body of a function or loop. A name declared inside a
#    syntactic block is not visible outside that block. The block encloses its
#    declarations and determines their scope. We can generalize this notion of
#    blocks to include other groupings of declarations that are not explicitly
#    surrounded by braces in the source code; we’ll call them all @e(lexical
#    blocks). There is a lexical block for the entire source code, called the
#    @e(universe block); for each package; for each file; for each @c(for),
#    @c(if), and @c(switch) statement; for each case in a @c(switch) or @c(select)
#    statement; and, of course, for each explicit syntactic block.
   Un @e(bloque) sintactico es una secuencia de sentencias encerradas entre
   llaves como las que rodean el cuerpo de una funcion o bucle. Un nombre
   declarado dentro de un bloque sintactico no es visible fuera de ese
   bloque. El bloque incluye sus declaraciones y determina su alcance. Podemos
   generalizar esta nocion de bloques para incluir otras agrupaciones de
   declaraciones que no estan explicitamente rodeadas por llaves en el codigo
   fuente; los llamaremos a todos @e(bloques lexicos). Hay un bloque lexico para
   todo el codigo fuente, llamado @e(bloque del universo); para cada paquete;
   para cada archivo; para cada sentencia @c(for), @c(if), y @c(switch); para
   cada caso en una sentencia @c(switch) o @c(select); Y, por supuesto, para
   cada bloque sintactico explicito.

#    A declaration’s lexical block determines its scope, which may be large or
#    small. The declarations of built-in types, functions, and constants like
#    @c(int), @c(len), and @c(true) are in the universe block and can be referred
#    to throughout the entire program. Declarations outside any function, that is,
#    at @e(package level), can be referred to from any file in the same
#    package. Imported packages, such as @c(fmt) in the @c(tempconv) example, are
#    declared at the @e(file level), so they can be referred to from the same
#    file, but not from another file in the same package without another
#    @c(import). Many declarations, like that of the variable @c(c) in the
#    @c(tempconv.CToF) function, are @e(local), so they can be referred to only
#    from within the same function or perhaps just a part of it.
   El bloque lexico de una declaracion determina su alcance, que puede ser
   grande o pequeño. Las declaracion de tipos nativos, funciones y constantes,
   por ejemplo @c(int), @c(len), y @c(true) estan en el bloque universo y pueden
   ser referidos a lo largo de todo el programa. Declaraciones fuera de
   cualquier funcion, es decir, a @e(nivel de paquete), puede ser refenciadas en
   cualquier archivo en el mismo paquete. Paquetes importados, como @c(fmt) en
   el ejemplo @c(tempconv), se declaran a @e(nivel de archivo), por lo que se
   puede hacer referencia a partir del mismo archivo, pero no desde otro archivo
   en el mismo paquete sin otro @c(import). Muchas declaraciones, como la de la
   variable @c(c) en la funcion @c(tempconv.CToF), son @e(locales), por lo que
   puden ser referidos solo desde dentro de la misma funcion o tal vez solo en
   una parte de ella.

#    The scope of a control-flow label, as used by @c(break), @c(continue), and
#    @c(goto) statements, is the entire enclosing function.
   El alcance de una etiqueta de flujo de control, tal como se utiliza por las
   sentencias @c(break), @c(continue), y @c(goto), es toda la funcion que la
   rodea.

#    A program may contain multiple declarations of the same name so long as each
#    declaration is in a different lexical block. For example, you can declare a
#    local variable with the same name as a package-level variable. Or, as shown
#    in @l(#Section 2.3.3), you can declare a function parameter called @c(new),
#    even though a function of this name is predeclared in the universe
#    block. Don’t overdo it, though; the larger the scope of the redeclaration,
#    the more likely you are to surprise the reader.
   Un programa puede contener varias declaraciones del mismo nombre, siempre y
   cuando cada declaracion este en un bloque lexico diferente. Por ejemplo,
   puede declarar una variable local con el mismo nombre que una variable a
   nivel de paquete. O, como se muestra en la @l(#Seccion 2.3.3), se puede
   declarar un parametro de funcion llamado @c(new), a pesar de tener una
   funcion con este nombre declarada con anterioridad en el bloque universo. No
   exagere, cuanto mayor sea el alcance de la redeclaracion, mas probable es que
   sorprenda al lector.

#    When the compiler encounters a reference to a name, it looks for a
#    declaration, starting with the innermost enclosing lexical block and working
#    up to the universe block. If the compiler finds no declaration, it reports an
#    @"(undeclared name) error. If a name is declared in both an outer block and
#    an inner block, the inner declaration will be found first. In that case, the
#    inner declaration is said to @e(shadow) or @e(hide) the outer one, making it
#    inaccessible:
   Cuando el compilador encuentra una referencia a un nombre, busca una
   declaracion, comenzando con el bloque lexico interno mas cercano y explorando
   hasta el bloque universo. Si el compilador no encuentra ninguna declaracion,
   se informa de un error de @"(nombre no declarado.) Si se declara un nombre
   tanto en un bloque externo como en un bloque interno, se encontrara primero
   la declaracion interna. En ese caso, se dice que la declaracion interna
   @e(obscurese) u @e(ocultar) la exterior, por lo que es inaccesible:

#    ..src > go
#      func f() {}
#      var g = "g"
#      func main() {
#        f := "f"
#        fmt.Println(f) // "f"; local var f shadows package-level func f
#        fmt.Println(g) // "g"; package-level var
#        fmt.Println(h) // compile error: undefined: h
#      }
#    < src..
   ..src > go
     func f() {}
     var g = "g"
     func main() {
       f := "f"
       fmt.Println(f) // "f"; la variable f local oculta la funcion f a nivel de paquete
       fmt.Println(g) // "g"; variable a nivel de paquete
       fmt.Println(h) // error de compilacion: sin definir: h
     }
   < src..

#    Within a function, lexical blocks may be nested to arbitrary depth, so one
#    local declaration can shadow another. Most blocks are created by control-flow
#    constructs like @c(if) statements and @c(for) loops. The program below has
#    three different variables called @c(x) because each declaration appears in a
#    different lexical block. (This example illustrates scope rules, not good
#    style!)
   Dentro de una funcion, los bloques lexicos pueden anidarse en una profundidad
   arbitraria, por lo que una declaracion local puede sombrear a otra. La
   mayoria de los bloques son creados por construcciones de flujo de control,
   como las declaraciones @c(if) y los bucles @c(for). El programa siguiente
   tiene tres variables distintas llamadas @c(x), ya que cada declaracion
   aparece en un bloque lexico diferente. (Este ejemplo ilustra las reglas de
   alcance, no es un buen estilo de programacion!)

#    ..src > go
#      func main() {
#        x := "hello!"
#        for i := 0; i < len(x); i++ {
#          x := x[i]
#          if x != '!' {
#            x := x + 'A' - 'a'
#            fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
#          }
#        }
#      }
#    < src..
   ..src > go
     func main() {
       x := "hello!"
       for i := 0; i < len(x); i++ {
         x := x[i]
         if x != '!' {
           x := x + 'A' - 'a'
           fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
         }
       }
     }
   < src..

#    The expressions @c(x[i]) and @c(x + 'A' - 'a') each refer to a declaration of
#    @c(x) from an outer block; we’ll explain that in a moment. (Note that the
#    latter expression is @e(not) equivalent to @c(unicode.ToUpper).)
   Las expresiones @c(x[i]) y @c(x + 'A' - 'a') se refieren cada una a una
   declaracion de @c(x) a partir de un bloque exterior; Lo explicaremos en un
   momento. (Tenga en cuenta que esta ultima expresion @e(no) es equivalente a
   @c(unicode.ToUpper)).

#    As mentioned above, not all lexical blocks correspond to explicit
#    brace-delimited sequences of statements; some are merely implied. The @c(for)
#    loop above creates two lexical blocks: the explicit block for the loop body,
#    and an implicit block that additionally encloses the variables declared by
#    the initialization clause, such as @c(i). The scope of a variable declared in
#    the implicit block is the condition, post-statement (@c(i++)), and body of
#    the @c(for) statement.
   Como se menciono anteriormente, no todos los bloques lexicos corresponden con
   secuencias delimitadas explicitamente por llaves; Algunos simplemente son
   implicitos. El bucle @c(for) anterior crea dos bloques lexicos: el bloque
   explicito para el cuerpo del bucle, y un bloque implicito que adicionalmente
   encierra las variables declaradas por la clausula de inicializacion, como
   @c(i). El alcance de una variable declarada en el bloque implicito es la
   condicion, post-declaracion (@c(i++)), y el cuerpo del comunicado @c(for).

#    The example below also has three variables named @c(x), each declared in a
#    different block—one in the function body, one in the @c(for) statement’s block,
#    and one in the loop body—but only two of the blocks are explicit:
   El siguiente ejemplo tambien tiene tres variables denominadas @c(x), cada una
   declarada en un bloque distinto–una en el cuerpo de la funcion, una en un
   bloque de sentencia @c(for) y uno en el cuerpo del bucle–pero solo dos de los
   bloques son explicitos:

#    ..src > go
#      func main() {
#        x := "hello"
#        for _, x := range x {
#          x := x + 'A' - 'a'
#          fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
#        }
#      }
#    < src..
   ..src > go
     func main() {
       x := "hello"
       for _, x := range x {
         x := x + 'A' - 'a'
         fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
       }
     }
   < src..

#    Like @c(for) loops, @c(if) statements and @c(switch) statements also create
#    implicit blocks in addition to their body blocks. The code in the following
#    @c(if)-@c(else) chain shows the scope of @c(x) and @c(y):
   Al igual que bucle @c(for), las declaraciones @c(if) y @c(switch) tambien
   crean un bloque implicito que, ademas del cuerpo de sus bloques. El codigo en
   la siguiente cadena @c(if)-@c(else) muestra el alcance de @c(x) y @c(y):

#    ..src > go
#      if x := f(); x == 0 {
#        fmt.Println(x)
#      } else if y := g(x); x == y {
#        fmt.Println(x, y)
#      } else {
#        fmt.Println(x, y)
#      }
#      fmt.Println(x, y) // compile error: x and y are not visible here
#    < src..
   ..src > go
     if x := f(); x == 0 {
       fmt.Println(x)
     } else if y := g(x); x == y {
       fmt.Println(x, y)
     } else {
       fmt.Println(x, y)
     }
     fmt.Println(x, y) // error de compilacion: x y y no son visibles aqui
   < src..

#    The second @c(if) statement is nested within the first, so variables declared
#    within the first statement’s initializer are visible within the
#    second. Similar rules apply to each case of a switch statement: there is a
#    block for the condition and a block for each case body.
   La segunda declaracion @c(if) esta anidada dentro de la primera, por lo que
   las variables declaradas dentro de la inicializacion de la primer declaracion
   son visibles dentro de la segunda. Reglas similares se aplican a cada caso de
   una sentencia @c(switch): hay un bloque para la condicion y un bloque para
   cada cuerpo de caso.

#    At the package level, the order in which declarations appear has no effect on
#    their scope, so a declaration may refer to itself or to another that follows
#    it, letting us declare recursive or mutually recursive types and
#    functions. The compiler will report an error if a constant or variable
#    declaration refers to itself, however.
   En el nivel de paquete, el orden en el que aparecen las declaraciones no
   tiene ningun efecto en su alcance, por lo que una declaracion puede referirse
   a si misma, o a otra que le sigue, permitiendonos declarar tipos y funciones
   recursivos o recursivos mutuamente. Sin embargo, el compilador reportara un
   error si una declaracion constante o variable se refiere a si misma.

#    In this program:
   En este programa:

#    ..src > go
#      if f, err := os.Open(fname); err != nil { // compile error: unused: f
#        return err
#      }
#      f.ReadByte() // compile error: undefined f
#      f.Close()    // compile error: undefined f
#    < src..
   ..src > go
     if f, err := os.Open(fname); err != nil { // error de compilacion: sin usar: f
       return err
     }
     f.ReadByte() // error de compilacion: f sin definir
     f.Close()    // error de compilacion: f sin definir
   < src..

#    the scope of @c(f) is just the @c(if) statement, so @c(f) is not accessible to the
#    statements that follow, resulting in compiler errors. Depending on the
#    compiler, you may get an additional error reporting that the local variable @c(f)
#    was never used.
   el alcance de @c(f) es solo la sentencia @c(if), por lo que @c(f) no es
   accesible a los estados que despues de enta, lo que resulta en errores de
   compilacion. Dependiendo del compilador, puede obtener un informe de errores
   adicional de que la variable local @c(f) nunca fue utilizada.

#    Thus it is often necessary to declare @c(f) before the condition so that it
#    is accessible after:
   Por lo tanto, a menudo es necesario declarar @c(f) antes de la condicion de modo
   que sea accesible mas tarde:

#    ..src > go
#      f, err := os.Open(fname)
#      if err != nil {
#        return err
#      }
#      f.ReadByte()
#      f.Close()
#    < src..
   ..src > go
     f, err := os.Open(fname)
     if err != nil {
       return err
     }
     f.ReadByte()
     f.Close()
   < src..

#    You may be tempted to avoid declaring @c(f) and @c(err) in the outer block by
#    moving the calls to @c(ReadByte) and @c(Close) inside an @c(else) block:
   Es posible que se sienta tentado a evitar declarar @c(f) y @c(err) en el
   bloque externo moviendo las llamadas a @c(ReadByte) y @c(Close) dentro del
   bloque @c(else):

#    ..src > go
#      if f, err := os.Open(fname); err != nil {
#        return err
#      } else {
#        // f and err are visible here too
#        f.ReadByte()
#        f.Close()
#      }
#    < src..
   ..src > go
     if f, err := os.Open(fname); err != nil {
       return err
     } else {
       // f and err are visible here too
       f.ReadByte()
       f.Close()
     }
   < src..

#    but normal practice in Go is to deal with the error in the @c(if) block and
#    then return, so that the successful execution path is not indented.
   pero una practica normal en Go es tratar con el error en el bloque @c(if) y
   luego regresar, de modo que la ruta de ejecucion exitosa no este indentada.

#    Short variable declarations demand an awareness of scope. Consider the
#    program below, which starts by obtaining its current working directory and
#    saving it in a package-level variable. This could be done by calling
#    @c(os.Getwd) in function @c(main), but it might be better to separate this
#    concern from the primary logic, especially if failing to get the directory is
#    a fatal error. The function @c(log.Fatalf) prints a message and calls
#    @c[os.Exit(1)].
   Las declaracion de variables compacta exige un conocimiento del
   alcance. Considere el siguiente programa, que comienza obteniendo su
   directorio de trabajo actual y guardandolo en una variable a nivel de
   paquete. Esto podria hacerse llamando a @c(os.Getwd) en la funcion @c(main),
   pero podria ser mejor separar esta preocupacion de la logica primaria, sobre
   todo si no podemos conseguir el directorio, es un error fatal. La funcion
   @c(log.Fatalf) imprime un mensaje y llama @c[os.Exit(1)].

#    ..src > go
#      var cwd string
#
#      func init() {
#        cwd, err := os.Getwd() // compile error: unused: cwd
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // error de compilacion: sin usar: cwd
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..
  var cadena cwd

#    Since neither @c(cwd) nor @c(err) is already declared in the init function’s block,
#    the @c(:=) statement declares both of them as local variables. The inner
#    declaration of @c(cwd) makes the outer one inaccessible, so the statement does
#    not update the package-level @c(cwd) variable as intended.
  Dado que ni @c(cwd) ni @c(err) se declaran en el bloque de la funcion
  @c(init), la sentencia @c(:=) declara ambas como variables locales. La
  declaracion interna de @c(cwd) hace que la externa sea inaccesible, por lo que
  la sentencia no actualiza la variable @c(cdw) de nivel de paquete como se
  pretende.

#    Current Go compilers detect that the local @c(cwd) variable is never used and
#    report this as an error, but they are not strictly required to perform this
#    check. Furthermore, a minor change, such as the addition of a logging
#    statement that refers to the local @c(cwd) would defeat the check.
  Los compiladores de Go actuales detectan que la variable local @c(cwd) nunca
  se utilza e informar de esto como un error, pero no son estrictamente
  necesarias para llevar a cabo esta comprobacion. Por otra parte, un cambio
  menor, como la adicion de una declaracion de registro que se hace referencia a
  la @c(cwd) local, anularia la comprobacion.

#    ..src > go
#      var cwd string
#
#      func init() {
#        cwd, err := os.Getwd() // NOTE: wrong!
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#        log.Printf("Working directory = %s", cwd)
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // NOTA: incorrecto!
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
       log.Printf("Working directory = %s", cwd)
     }
   < src..

#    The global @c(cwd) variable remains uninitialized, and the apparently normal
#    log output obfuscates the bug.
   La variable global @c(cwd) permanece sin inicializar, y la salida del
   registro aparentemente normal ofusca el fallo.

#    There are a number of ways to deal with this potential problem. The most
#    direct is to avoid @c(:=) by declaring @c(err) in a separate @c(var)
#    declaration:
   Hay un numero de maneras de lidiar con este problema potencial. La mas
   directa es evitar @c(:=) declarando @c(err) en una declaracion @c(var)
   separada:

#    ..src > go
#      var cwd string
#
#      func init() {
#        var err error
#        cwd, err = os.Getwd()
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       var err error
       cwd, err = os.Getwd()
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..

#    We’ve now seen how packages, files, declarations, and statements express the
#    structure of programs. In the next two chapters, we’ll look at the structure
#    of data.
   Hemos visto como los paquetes, archivos, declaraciones y declaraciones
   expresan la estructura de los programas. En los proximos dos capitulos,
   veremos la estructura de los datos.

# * Chapter 3 <> Basic Data Types
* Capitulo 3 <> Tipos de datos basicos

#   It’s all bits at the bottom, of course, but computers operate fundamentally on
#   fixed-size numbers called @e(words), which are interpreted as integers,
#   floating-point numbers, bit sets, or memory addresses, then combined into
#   larger aggregates that represent packets, pixels, portfolios, poetry, and
#   everything else. Go offers a variety of ways to organize data, with a spectrum
#   of data types that at one end match the features of the hardware and at the
#   other end provide what programmers need to conveniently represent complicated
#   data structures.
  En el fondo todo son solo bits, por supuesto, pero las computadoras operan
  fundamentalmente en numeros de tamaño fijo llamados palabras, que se
  interpretan como numeros enteros, numeros de punto flotante, conjuntos de
  bits, o direcciones de memoria, que luego se combinana en agregados mas
  grandes que representan paquetes, pixeles, carteras, poesia y todo lo
  demas. Go ofrece una variedad de formas de organizar los datos, con un
  espectro de tipos de datos que en un extremo coinciden con las caracteristicas
  del hardware y en el otro extremo proporcionan lo que los programadores
  necesitan para representar convenientemente estructuras de datos complicadas.

#   Go’s types fall into four categories: @e(basic types), @e(aggregate types),
#   @e(reference types), and @e(interface types). Basic types, the topic of this
#   chapter, include numbers, strings, and booleans. Aggregate types—arrays
#   (@l(#Section 4.1<>§4.1)) and structs (@l(#Section 4.4<>§4.4))—form more
#   complicated data types by combining values of several simpler ones. Reference
#   types are a diverse group that includes pointers (@l(#Section 2.3.2<>§2.3.2)),
#   slices (@l(#Section 4.2<>§4.2)), maps (@l(#Section 4.3<>§4.3)), functions
#   (@l(#Chapter 5)), and channels (@l(#Chapter 8)), but what they have in common
#   is that they all refer to program variables or state @e(indirectly), so that
#   the effect of an operation applied to one reference is observed by all copies
#   of that reference. Finally, we’ll talk about interface types in @l(#Chapter
#   7).
  Los tipos de datos de Go se dividen en cuatro categorias: @e(tipos basicos),
  @e(tipos de agregados), @e(tipos de referencia), y @e(tipos de interfaz). Los
  tipos basicos, el tema de este capitulo, incluyen numeros, cadenas y
  booleanos. Los tipos agregados–arreglos (@l(#Seccion 4.1<>§4.1)) y estructuras
  (@l(#Section 4.4<>§4.4))–forma tipos de datos mas complejos mediante la
  combinacion de otros valores mas simples. Los tipos de referencia son un grupo
  diverso, que incluye punteros (@l(#Seccion 2.3.2<>§2.3.2)), slices
  (@l(#Section 4.2<>§4.2)), mapas (@l(#Section 4.3<>§4.3)), funciones
  (@l(#Capitulo 5)), y canales (@l(#Capitulo 8)), pero lo que tienen en comun es
  que se todos ellos se refieren a variables del programa o estados
  indirectamente, por lo que el efecto de una operacion que se aplica a una
  referencia es observado por todas las copias de esa referencia. Por ultimo,
  hablaremos de los tipos de interfaz en el @l(#Capitulo 7).

# ** Section 3.1 <> Integers
** Seccion 3.1 <> Enteros

#    Go’s numeric data types include several sizes of integers, floating-point
#    numbers, and complex numbers. Each numeric type determines the size and
#    signedness of its values. Let’s begin with integers.
   Los tipos de datos numericos de Go incluyen varios tamaños de enteros,
   numeros de coma flotante y numeros complejos. Cada tipo numerico determina el
   tamaño y la firma de sus valores. Comencemos con numeros enteros.

#    Go provides both signed and unsigned integer arithmetic. There are four
#    distinct sizes of signed integers—8, 16, 32, and 64 bits—represented by the
#    types @c(int8), @c(int16), @c(int32), and @c(int64), and corresponding
#    unsigned versions @c(uint8), @c(uint16), @c(uint32), and @c(uint64).
   Go proporciona tanto aritmetica con y sin signo. Hay cuatro tamaños distintos
   de numeros enteros–8, 16, 32 y 64 bits–representados por los tipos @c(int8),
   @c(int16), @c(int32), y @c(int64), y las correspondientes versiones sin signo
   @c(uint8), @c(uint16), @c(uint32), y @c(uint64).

#    There are also two types called just @c(int) and @c(uint) that are the
#    natural or most efficient size for signed and unsigned integers on a
#    particular platform; @c(int) is by far the most widely used numeric
#    type. Both these types have the same size, either 32 or 64 bits, but one must
#    not make assumptions about which; different compilers may make different
#    choices even on identical hardware.
   Tambien hay dos tipos llamados simplemente @c(int) y @c(uint) que son del
   tamaño natural o mas eficiente para los numeros enteros con y sin signo en
   una plataforma en particular; @c(int) es de lejos el tipo numerico mas
   utilizado. Ambos tipos tienen el mismo tamaño, 32 o 64 bits, pero uno no debe
   hacer suposiciones sobre cual es; Diferentes compiladores pueden tomar
   diferentes opciones incluso en hardware identico.

#    The type @c(rune) is an synonym for @c(int32) and conventionally indicates
#    that a value is a Unicode code point. The two names may be used
#    interchangeably. Similarly, the type @c(byte) is an synonym for @c(uint8),
#    and emphasizes that the value is a piece of raw data rather than a small
#    numeric quantity.
   El tipo @c(rune) es un sinonimo de @c(int32) y convencionalmente indica que
   un valor es un punto de codigo Unicode. Los dos nombres pueden utilizarse
   indistintamente. Del mismo modo, el tipo de @c(byte) es un sinonimo de
   @c(uint8), y hace hincapie en que el valor es una pieza de datos en bruto mas
   que una pequeña cantidad numerica.

#    Finally, there is an unsigned integer type @c(uintptr), whose width is not
#    specified but is sufficient to hold all the bits of a pointer value. The
#    @c(uintptr) type is used only for low-level programming, such as at the
#    boundary of a Go program with a C library or an operating system. We’ll see
#    examples of this when we deal with the @c(unsafe) package in @l(#Chapter 13).
   Por ultimo, existe un tipo entero sin signo @c(uintptr), cuya anchura no se
   especifica, pero es suficiente para contener todos los bits de un valor de
   puntero. El tipo @c(uintptr) solo se utiliza para la programacion a bajo
   nivel, por ejemplo, en el limite de un programa Go con una libreria C o un
   sistema operativo. Veremos ejemplos de esto cuando nos ocupemos del paquete
   @c(unsafe) en el @l(#Capitulo 13).

#    Regardless of their size, @c(int), @c(uint), and @c(uintptr) are different types
#    from their explicitly sized siblings. Thus @c(int) is not the same type as
#    @c(int32), even if the natural size of integers is 32 bits, and an explicit
#    conversion is required to use an @c(int) value where an @c(int32) is needed,
#    and vice versa.
   Independientemente de su tamaño, @c(int), @c(uint) y @c(uintptr) son
   diferentes tipos de sus hermanos de tamaño de forma explicita. Por lo tanto
   @c(int) no es el mismo tipo que @c(int32), incluso si el tamaño natural de
   enteros es de 32 bits, y requiere una conversion explicita utilizar un valor
   @c(int) donde se necesita un @c(int32), y viceversa.

#    Signed numbers are represented in 2’s-complement form, in which the
#    high-order bit is reserved for the sign of the number and the range of values
#    of an @m(n)-bit number is from -2ⁿ⁻¹ to 2ⁿ⁻¹-1. Unsigned integers use the
#    full range of bits for non-negative values and thus have the range 0 to
#    2ⁿ-1. For instance, the range of @c(int8) is -128 to 127, whereas the range
#    of @c(uint8) is 0 to 255.
   Numeros con signo se representan en forma de complemento a 2, en el que el
   bit de orden superior esta reservado para el signo del numero y la gama de
   valores de un numero de @m(n) bits es de -2ⁿ⁻¹ a 2ⁿ⁻¹-1. Los numeros enteros
   sin signo usan el rango completo de bits para valores no negativos y por lo
   tanto tienen el rango de 0 a 2ⁿ-1. Por ejemplo, la gama de @c(int8) entre
   -128 y 127, mientras que la gama de @c(uint8) es de 0 a 255.

#    Go’s binary operators for arithmetic, logic, and comparison are listed here
#    in order of decreasing precedence:
   En Go Los operadores binarios de aritmetica, logica y comparacion se enumeran
   aqui en orden decreciente de precedencia:

#    ..pre >
#      *   /   %  <<  >>  &   &^
#      +   -   |  ^
#      ==  !=  <  <=  >   >=
#      &&
#      ||
#    < pre..
   ..pre >
     *   /   %  <<  >>  &   &^
     +   -   |  ^
     ==  !=  <  <=  >   >=
     &&
     ||
   < pre..

#    There are only five levels of precedence for binary operators. Operators at
#    the same level associate to the left, so parentheses may be required for
#    clarity, or to make the operators evaluate in the intended order in an
#    expression like @c[mask & (1 << 28)].
   Solo hay cinco niveles de precedencia para los operadores binarios. Los
   operadores en el mismo nivel se asocian a la izquierda, por lo que pueden ser
   necesarios parentesis, para mayor claridad, o para hacer que los operadores
   evaluan en el orden deseado en una expresion como @c[mask & (1 << 28)].

#    Each operator in the first two lines of the table above, for instance @c(+),
#    has a corresponding @c(assignment operator) like @c(+=) that may be used to
#    abbreviate an assignment statement.
   Cada operador en las dos primeras lineas de la tabla anterior, por ejemplo
   @c(+), tiene un operador de asignacion correspondiente como @c(+=) que pueden
   utilizarse para abreviar una instruccion de asignacion.

#    The integer arithmetic operators @c(+), @c(-), @c(*), and @c(/) may be
#    applied to integer, floating-point, and complex numbers, but the remainder
#    operator @c(%) applies only to integers. The behavior of @c(%) for negative
#    numbers varies across programming languages. In Go, the sign of the remainder
#    is always the same as the sign of the dividend, so @c(-5%3) and @c(-5%-3) are
#    both @c(-2). The behavior of @c(/) depends on whether its operands are
#    integers, so @c(5.0/4.0) is @c(1.25), but @c(5/4) is @c(1) because integer
#    division truncates the result toward zero.
   Los operadores aritmetica enteros @c(+), @c(-), @c(*), y @c(/) pueden
   aplicarse a numeros enteros, de coma flotante, y numeros complejos, pero el
   operador @c(%) solo se aplica a numeros enteros. El comportamiento de @c(%)
   para los numeros negativos varia a traves de los lenguajes de
   programacion. En Go, el signo del resto es siempre el mismo que el signo del
   dividendo, por lo @c(-5%3) y @c(-5%-3) son ambos @c(-2). El comportamiento de
   @c(/) depende de si sus operandos son numeros enteros, por lo que @c(5.0/4.0)
   es @c(1.25), pero @c(5/4) es @c(1) porque la division entera trunca el
   resultado hacia cero.

#    If the result of an arithmetic operation, whether signed or unsigned, has
#    more bits than can be represented in the result type, it is said to
#    @e(overflow). The high-order bits that do not fit are silently discarded. If
#    the original number is a signed type, the result could be negative if the
#    leftmost bit is a 1, as in the @c(int8) example here:
   Si el resultado de una operacion aritmetica, ya sea con o sin signo, tiene
   mas bits de los que pueden ser representados en el tipo del resultado, se
   dice que se @e(desborda). Los bits de orden superior que no encajan se
   descartan silenciosamente. Si el numero original es un tipo con signo, el
   resultado podria ser negativo si el bit mas a la izquierda es un 1, como en
   el @c(int8) ejemplo aqui:

#    ..src > go
#      var u uint8 = 255
#      fmt.Println(u, u+1, u*u) // "255 0 1"
#
#      var i int8 = 127
#      fmt.Println(i, i+1, i*i) // "127 -128 1"
#    < src..
   ..src > go
     var u uint8 = 255
     fmt.Println(u, u+1, u*u) // "255 0 1"

     var i int8 = 127
     fmt.Println(i, i+1, i*i) // "127 -128 1"
   < src..

#    Two integers of the same type may be compared using the binary comparison
#    operators below; the type of a comparison expression is a boolean.
   Dos numeros enteros del mismo tipo pueden compararse usando los operadores de
   comparacion binarios siguientes; El tipo de una expresion de comparacion es
   un booleano.

#    | @c(==) | equal to                 |
#    |--------|--------------------------|
#    | @c(!=) | not equal to             |
#    |--------|--------------------------|
#    | @c(<)  | less than                |
#    |--------|--------------------------|
#    | @c(<=) | less than or equal to    |
#    |--------|--------------------------|
#    | @c(>)  | greater than             |
#    |--------|--------------------------|
#    | @c(>=) | greater than or equal to |
   | @c(==) | igual a             |
   |--------|---------------------|
   | @c(!=) | no igual a          |
   |--------|---------------------|
   | @c(<)  | menor que           |
   |--------|---------------------|
   | @c(<=) | Menor que o igual a |
   |--------|---------------------|
   | @c(>)  | mayor que           |
   |--------|---------------------|
   | @c(>=) | Mayor que o igual a |

#    In fact, all values of basic type—booleans, numbers, and strings—are
#    @e(comparable), meaning that two values of the same type may be compared
#    using the @c(==) and @c(!=) operators. Furthermore, integers, floating-point
#    numbers, and strings are @e(ordered) by the comparison operators. The values
#    of many other types are not comparable, and no other types are ordered. As we
#    encounter each type, we’ll present the rules governing the @e(comparability)
#    of its values.
   De hecho, todos los valores de tipo basico–booleanos, numeros y cadenas–son
   comparables, lo que significa que dos valores del mismo tipo pueden ser
   comparados con los operadores @c(==) y @c(!=). Por otra parte, los numeros
   enteros, numeros de punto flotante y cadenas son @e(ordenados) por los
   operadores de comparacion. Los valores de muchos otros tipos no son
   comparables y no se ordenan otros tipos. A medida que nos encontramos cada
   tipo, vamos a presentar las normas que rigen la comparacion de sus valores.

#    There are also unary addition and subtraction operators:
   Tambien hay operadores unarios de suma y resta:

#    | @c(+) | unary positive (no effect) |
#    |-------|----------------------------|
#    | @c(-) | unary negation             |
   | @c(+) | Unario positivo (sin efecto) |
   |-------|------------------------------|
   | @c(-) | Negacion unaria              |

#    For integers, @c(+x) is a shorthand for @c(0+x) and @c(-x) is a shorthand for
#    @c(0-x); for floating-point and complex numbers, @c(+x) is just @c(x) and
#    @c(-x) is the negation of @c(x).
   Para enteros, @c(+x) es una abreviatura de @c(0+x) y @c(-x) es una
   abreviatura de @c(0-x); para los numeros de punto flotante y complejos,
   @c(+x) es @c(x) y @c(-x) es la negacion de @c(x).

#    Go also provides the following bitwise binary operators, the first four of
#    which treat their operands as bit patterns with no concept of arithmetic
#    carry or sign:
   Go tambien proporciona los siguientes operadores binarios a nivel de bits,
   cuyos cuatro primeros tratan a sus operandos como patrones de bits sin ningun
   concepto aritmetico o signo:

#    | @c(&)  | bitwise AND         |
#    |--------|---------------------|
#    | @c(|)  | bitwise OR          |
#    |--------|---------------------|
#    | @c(^)  | bitwise XOR         |
#    |--------|---------------------|
#    | @c(&^) | bit clear (AND NOT) |
#    |--------|---------------------|
#    | @c(<<) | left shift          |
#    |--------|---------------------|
#    | @c(>>) | right shift         |
   | @c(&)  | AND bit a bit                 |
   |--------|-------------------------------|
   | @c(|)  | OR bit a bit                  |
   |--------|-------------------------------|
   | @c(^)  | XOR bit a bit                 |
   |--------|-------------------------------|
   | @c(&^) | AND NOT                       |
   |--------|-------------------------------|
   | @c(<<) | desplazamiento a la izquierdo |
   |--------|-------------------------------|
   | @c(>>) | desplazamiento a la derecha   |

#    The operator @c(^) is bitwise exclusive OR (XOR) when used as a binary
#    operator, but when used as a unary prefix operator it is bitwise negation or
#    complement; that is, it returns a value with each bit in its operand
#    inverted. The @c(&^) operator is bit clear (AND NOT): in the expression @c(z
#    = x &^ y), each bit of @c(z) is 0 if the corresponding bit of @c(y) is 1;
#    other wise it equals the corresponding bit of @c(x).
   El operador bit a bit @c(^) es un OR exclusivo (XOR) cuando se utiliza como
   un operador binario (coloca un uno en cada posicion en donde sus operandos
   tienen bits distintos, y un cero en donde son iguales), pero cuando se
   utiliza como un operador de prefijo unario es el complemento a uno; es decir,
   devuelve un valor con cada bit en su operando invertido. El operador @c(&^)
   es para lipiar bits (AND NOT): en la expresion @c(z = x &^ y), cada bit de
   @c(z) es 0 si el bit correspondiente de @c(y) es 1; de lo contrario es igual
   al bit correspondiente de @c(x).

#    The code below shows how bitwise operations can be used to interpret a
#    @c(uint8) value as a compact and efficient set of 8 independent bits. It uses
#    @c(Printf)’s @c(%b) verb to print a number’s binary digits; @c(08) modifies
#    @c(%b) (an adverb!) to pad the result with zeros to exactly 8 digits.
   El siguiente codigo muestra como se pueden utilizar las operaciones a nivel
   de bit para interpretar un valor @c(uint8) como un conjunto compacto y
   eficiente de 8 bits independientes. Se utiliza el verbo @c(%b) de @c(Printf)
   para imprimir los digitos binarios de un numero; @c(08) modifica @c(%b) (un
   adverbio!)  para rellenar el resultado con ceros a exactamente 8 digitos.

#    ..src > go
#      package main
#
#      import "fmt"
#
#      func main(){
#        var x uint8 = 1<<1 | 1<<5
#        var y uint8 = 1<<1 | 1<<2
#
#        fmt.Printf("%08b\n", x)    // "00100010", the set {1, 5}
#        fmt.Printf("%08b\n", y)    // "00000110", the set {1, 2}
#        fmt.Printf("%08b\n", x&y)  // "00000010", the intersection {1}
#        fmt.Printf("%08b\n", x|y)  // "00100110", the union {1, 2, 5}
#        fmt.Printf("%08b\n", x^y)  // "00100100", the symmetric difference {2, 5}
#        fmt.Printf("%08b\n", x&^y) // "00100000", the difference {5}
#
#        for i := uint(0); i < 8; i++ {
#          if x&(1<<i) != 0 { // membership test
#            fmt.Println(i)   // "1", "5"
#          }
#        }
#
#        fmt.Printf("%08b\n", x<<1) // "01000100", the set {2, 6}
#        fmt.Printf("%08b\n", x>>1) // "00010001", the set {0, 4}
#      }
#    < src..
   ..src > go
     package main

     import "fmt"

     func main(){
       var x uint8 = 1<<1 | 1<<5
       var y uint8 = 1<<1 | 1<<2

       fmt.Printf("%08b\n", x)    // "00100010", el conjunto {1, 5}
       fmt.Printf("%08b\n", y)    // "00000110", el conjunto {1, 2}
       fmt.Printf("%08b\n", x&y)  // "00000010", la interseccion {1}
       fmt.Printf("%08b\n", x|y)  // "00100110", la union {1, 2, 5}
       fmt.Printf("%08b\n", x^y)  // "00100100", la diferencia simetrica {2, 5}
       fmt.Printf("%08b\n", x&^y) // "00100000", la diferencia {5}

       for i := uint(0); i < 8; i++ {
         if x&(1<<i) != 0 { // prueba de pertenencia
           fmt.Println(i)   // "1", "5"
         }
       }

       fmt.Printf("%08b\n", x<<1) // "01000100", el conjunto {2, 6}
       fmt.Printf("%08b\n", x>>1) // "00010001", el conjunto {0, 4}
     }
   < src..

#    (@l(#Section 6.5) shows an implementation of integer sets that can be much
#    bigger than a byte.)
   (La @l(#Seccion 6.5) muestra una implementacion de conjuntos de numeros
   enteros que pueden ser mucho mas grande que un byte).

#    In the shift operations @c(x<<n) and @c(x>>n), the @c(n) operand determines
#    the number of bit positions to shift and must be unsigned; the @c(x) operand
#    may be unsigned or signed. Arithmetically, a left shift @c(x<<n) is
#    equivalent to multiplication by 2ⁿ and a right shift @c(x>>n) is equivalent
#    to the floor of division by 2ⁿ.
   En las operaciones de desplazamiento @c(x<<n) y @c(x>>n), el operando @c(n)
   determina el numero de posiciones de bits a cambiar y debe ser sin signo; el
   operando @c(x) puede tener o no signo. Aritmeticamente, el desplazamiento a
   la izquierda @c(x<<n) es equivalente a la multiplicacion por 2ⁿ y un
   desplazamiento a la derecha @c(x>>n) es equivalente a dividir por 2ⁿ.

#    Left shifts fill the vacated bits with zeros, as do right shifts of unsigned
#    numbers, but right shifts of signed numbers fill the vacated bits with copies
#    of the sign bit. For this reason, it is important to use unsigned arithmetic
#    when you’re treating an integer as a bit pattern.
   Los desplazamientos a la izquierda o derecha en enteros sin singno llenan los
   bits desocupados con ceros, pero los desplazamientos a la derecha de numeros
   con signo llenan los bits desocupados con copias del bit de signo. Por esta
   razon, es importante utilizar aritmetica sin signo cuando se esta tratando un
   entero como un patron de bits.

#    Although Go provides unsigned numbers and arithmetic, we tend to use the
#    signed @c(int) form even for quantities that can’t be negative, such as the
#    length of an array, though @c(uint) might seem a more obvious choice. Indeed,
#    the built-in @c(len) function returns a signed @c(int), as in this loop which
#    announces prize medals in reverse order:
   Aunque Go proporciona aritmetica y numeros sin signo, se tiende a utilizar un
   int con signo incluso para cantidades que no pueden ser negativas, tales como
   la longitud de un arreglo, aunque @c(uint) puede parecer una eleccion mas
   obvia. De hecho, la funcion nativa @c(len) devuelve un @c(int) con signo,
   como en este bucle que anuncia medallas de premio en el orden inverso:

#    ..src > go
#      medals := []string{"gold", "silver", "bronze"}
#      for i := len(medals) - 1; i >= 0; i-- {
#        fmt.Println(medals[i]) // "bronze", "silver", "gold"
#      }
#    < src..
   ..src > go
     medallas := []string{"oro", "plata", "bronce"}
     for i := len(medallas) - 1; i >= 0; i-- {
       fmt.Println(medallas[i]) // "bornce", "plata", "oro"
     }
   < src..

#    The alternative would be calamitous. If @c(len) returned an unsigned number,
#    then @c(i) too would be a @c(uint), and the condition @c(i >= 0) would always
#    be true by definition. After the third iteration, in which @c(i == 0), the
#    @c(i--) statement would cause @c(i) to become not -1, but the maximum
#    @c(uint) value (for example, 2⁶⁴-1), and the evaluation of @c(medals[i])
#    would fail at run time, or @e(panic) (@l(#Section 5.9<>§5.9)), by attempting
#    to access an element outside the bounds of the slice.
   La alternativa seria calamitosa. Si @c(len) devuelve un numero sin signo,
   entonces @c(i) tambien seria un @c(uint), y la condicion @c(i >= 0) siempre
   seria verdadera por definicion. Despues de la tercera iteracion, en la cual
   @c(i == 0), la instruccion @c(i--) no haria que @c(i) se volviera -1, en
   cambion seria el valor maximo de @c(uint) (es decir, 2⁶⁴-1), y la evaluacion
   de @c(medallas[i]) fallaria en tiempo de ejecucion, o de @e(panico)
   (@l(#Seccion 5.9<>§5.9)), al tratar de acceder a un elemento fuera de los
   limites del slice.

#    For this reason, unsigned numbers tend to be used only when their bitwise
#    operators or peculiar arithmetic operators are required, as when implementing
#    bit sets, parsing binary file formats, or for hashing and cryptography. They
#    are typically not used for merely non-negative quantities.
   Por esta razon, los numeros sin signo tienden a utilizarse solo cuando se
   requieren sus operadores bit a bit u operadores aritmeticos peculiares, como
   cuando se implementan conjuntos de bits, se analizan formatos binarios de
   archivos o se usan hash y criptografia. Normalmente no se usan para
   cantidades meramente no negativas.

#    In general, an explicit conversion is required to convert a value from one
#    type to another, and binary operators for arithmetic and logic (except
#    shifts) must have operands of the same type. Although this occasionally
#    results in longer expressions, it also eliminates a whole class of problems
#    and makes programs easier to understand.
   En general, se requiere una conversion explicita para convertir un valor de
   un tipo a otro, y los operadores binarios para aritmetica y logica (excepto
   los desplazamientos) deben tener operandos del mismo tipo. Aunque esto
   resulta ocasionalmente en expresiones mas largas, tambien elimina toda una
   clase de problemas y hace que los programas sean mas faciles de entender.

#    As an example familiar from other contexts, consider this sequence:
   Como ejemplo familiar de otros contextos, considere esta secuencia:

#    ..src > go
#      var apples int32 = 1
#      var oranges int16 = 2
#      var compote int = apples + oranges // compile error
#    < src..
   ..src > go
     var manzanas int32 = 1
     var naranjas int16 = 2
     var compota int = manzanas + naranjas // Error de compiacion
   < src..

#    Attempting to compile these three declarations produces an error message:
   Al intentar compilar estas tres declaraciones se genera un mensaje de error:

#    ..pre >
#      invalid operation: apples + oranges (mismatched types int32 and int16)
#    < pre..
   ..pre >
     invalid operation: manzanas + naranjas (mismatched types int32 and int16)
   < pre..

#    This type mismatch can be fixed in several ways, most directly by converting
#    everything to a common type:
   Este tipo de incompatibilidad se puede corregir de varias maneras, mas
   directamente convirtiendo todo a un tipo comun:

#    ..src > go
#      var compote = int(apples) + int(oranges)
#    < src..
   ..src > go
     var compota = int(manzanas) + int(naranjas)
   < src..

#    As described in @l(#Section 2.5), for every type @c(T), the conversion
#    operation @c[T(x)] converts the value @c(x) to type @c(T) if the conversion
#    is allowed. Many integer-to-integer conversions do not entail any change in
#    value; they just tell the compiler how to interpret a value. But a conversion
#    that narrows a big integer into a smaller one, or a conversion from integer
#    to floating-point or vice versa, may change the value or lose precision:
   Como se describe en la @l(#Seccion 2.5), para cada tipo @c(T), la operacion
   de conversion @c[T(x)] convierte el valor @c(x) a tipo @c(T) si se permite la
   conversion. Muchas conversiones de entero a entero no implican ningun cambio
   en el valor; Solo le dicen al compilador como interpretar un valor. Pero una
   conversion que reduce un entero grande a uno mas pequeño o una conversion de
   entero a punto flotante o viceversa, puede cambiar el valor o perder
   precision:

#    ..src > go
#      f := 3.141          // a float64
#      i := int(f)
#      fmt.Println(f, i)   // "3.141 3"
#      f = 1.99
#      fmt.Println(int(f)) // "1"
#    < src..
   ..src > go
     f := 3.141          // un float64
     i := int(f)
     fmt.Println(f, i)   // "3.141 3"
     f = 1.99
     fmt.Println(int(f)) // "1"
   < src..

#    Float to integer conversion discards any fractional part, truncating toward
#    zero. You should avoid conversions in which the operand is out of range for
#    the target type, because the behavior depends on the implementation:
   La conversion de float a entero descarta cualquier parte fraccional,
   truncando hacia cero. Debe evitar las conversiones en las que el operando
   este fuera del rango del tipo destino, ya que el comportamiento depende de la
   implementacion:

#    ..src > go
#      f := 1e100  // a float64
#      i := int(f) // result is implementation-dependent
#    < src..
   ..src > go
     f := 1e100  // un float64
     i := int(f) // el resultado depende de la implementacion
   < src..

#    Integer literals of any size and type can be written as ordinary decimal
#    numbers, or as octal numbers if they begin with @c(0), as in @c(0666), or as
#    hexadecimal if they begin with @c(0x) or @c(0X), as in @c(0xdeadbeef). Hex
#    digits may be upper or lower case. Nowadays octal numbers seem to be used for
#    exactly one purpose—file permissions on POSIX systems—but hexadecimal numbers
#    are widely used to emphasize the bit pattern of a number over its numeric
#    value.
   Los literales enteros de cualquier tamaño y tipo se pueden escribir como
   numeros decimales ordinarios, o bien con numeros octales si comienzan con
   @c(0), como en @c(0666), o como hexadecimal si comienzan con @c(0x) o @c(0X),
   como en @c(0xdeadbeef). Los digitos hexadecimales pueden ser mayusculas o
   minusculas. Hoy en dia los numeros octales parecen ser utilizados para
   exactamente un proposito–permisos de archivo en sistemas POSIX–pero los
   numeros hexadecimales se utilizan ampliamente para enfatizar el patron de
   bits de un numero sobre su valor numerico.

#    When printing numbers using the fmt package, we can control the radix and
#    format with the @c(%d), @c(%o), and @c(%x) verbs, as shown in this example:
   Al imprimir numeros usando el paquete @c(fmt), podemos controlar la base y el
   formato con los verbos @c(%d), @c(%o), y @c(%x), como se muestra en este
   ejemplo:

#    ..src > go
#      o := 0666
#      fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
#      x := int64(0xdeadbeef)
#      fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
#      // Output:
#      // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
#    < src..
   ..src > go
     o := 0666
     fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
     x := int64(0xdeadbeef)
     fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
     // Salida:
     // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
   < src..

#    Note the use of two @c(fmt) tricks. Usually a @c(Printf) format string
#    containing multiple @c(%) verbs would require the same number of extra
#    operands, but the @c([1]) @"(adverbs) after @c(%) tell @c(Printf) to use the
#    first operand over and over again. Second, the @c(#) adverb for @c(%o) or
#    @c(%x) or @c(%X) tells @c(Printf) to emit a @c(0) or @c(0x) or @c(0X) prefix
#    respectively.
   Observe el uso de dos trucos de @c(fmt). Por lo general, una cadena de
   formato @c(Printf) que contiene multiples verbos @c(%) requeriria el mismo
   numero de operandos adicionales, pero los @"(adverbios) @c([1]) despues de
   @c(%) le indican a @c(Printf) utilizar el primer operando una y otra vez. En
   segundo lugar, el adverbio @c(#) enr @c(%o) o @c(%x) o @c(%X) indica a
   @c(Printf) emitir un prefijo @c(0) o @c(0x) o @c(0X) respectivamente.

#    Rune literals are written as a character within single quotes. The simplest
#    example is an ASCII character like @c('a'), but it’s possible to write any
#    Unicode code point either directly or with numeric escapes, as we will see
#    shortly.
   Las literales de runa se escriben como un caracter entre comillas
   simples. El ejemplo mas simple es un caracter ASCII como @c('a'), pero es
   posible escribir cualquier punto de codigo Unicode directamente o con escapes
   numericos, como veremos en breve.

#    Runes are printed with @c(%c), or with @c(%q) if quoting is desired:
   Las runas se imprimen con @c(%c), o con @c(%q) si se desea citar:

#    ..src > go
#      ascii := 'a'
#      unicode := '𢉩'
#      newline := '\n'
#      fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
#      fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 𢉩 '𢉩'"
#      fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
#    < src..
   ..src > go
     ascii := 'a'
     unicode := '𢉩'
     newline := '\n'
     fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 un 'a'"
     fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 𢉩 '𢉩'"
     fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
   < src..

# ** Section 3.2 <> Floating-Point Numbers
** Seccion 3.2 <> Numeros de punto flotante

#    Go provides two sizes of floating-point numbers, @c(float32) and
#    @c(float64). Their arithmetic properties are governed by the IEEE 754
#    standard implemented by all modern CPUs.
   Go ofrece dos tamaños de numeros de punto flotante, @c(float32) y
   @c(float64). Sus propiedades aritmeticas se rigen por el estandar IEEE 754
   implementado por todas las CPUs modernas.

#    Values of these numeric types range from tiny to huge. The limits of
#    floating-point values can be found in the @c(math) package. The constant
#    @c(math.MaxFloat32), the largest @c(float32), is about @c(3.4e38), and
#    @c(math.MaxFloat64) is about @c(1.8e308). The smallest positive values are
#    near @c(1.4e-45) and @c(4.9e-324), respectively.
   Los valores de estos tipos numericos varian de pequeño a enorme. Los limites
   de valores de coma flotante se pueden encontrar en el paquete @c(math). La
   constante @c(math.MaxFloat32), el mayor valor de @c(float32), es cerca de
   @c(3.4e38) y @c(math.MaxFloat64) es @c(1.8e308). Los valores positivos mas
   pequeños son @c(1.4e-45) y @c(4.9e-324), respectivamente.

#    A @c(float32) provides approximately six decimal digits of precision, whereas
#    a @c(float64) provides about 15 digits; @c(float64) should be preferred for
#    most purposes because @c(float32) computations accumulate error rapidly
#    unless one is quite careful, and the smallest positive integer that cannot be
#    exactly represented as a @c(float32) is not large:
   Un @c(float32) proporciona aproximadamente seis digitos decimales de
   precision, mientras que un @c(float64) proporciona alrededor de 15 digitos;
   @c(float64) debe ser preferido para la mayoria de los propositos porque los
   calculos sobre @c(float32) acumulan errores rapidamente a menos que sea
   bastante cuidadoso, y el numero entero positivo mas pequeño que no se puede
   representar exactamente como @c(float32) no es grande:

#    ..src > go
#      var f float32 = 16777216 // 1 << 24
#      fmt.Println(f == f+1)    // "true"!
#    < src..
   ..src > go
     var f float32 = 16777216 // 1 << 24
     fmt.Println(f == f+1)    // "true"!
   < src..

#    Floating-point numbers can be written literally using decimals, like this:
   Los numeros de punto flotante se pueden escribir literalmente usando
   decimales, asi:

#    ..src > go
#      const e = 2.71828 // (approximately)
#    < src..
   ..src > go
     const e = 2.71828 // (aproximadamente)
   < src..

#    Digits may be omitted before the decimal point (@c(.707)) or after it
#    (@c(1.)). Very small or very large numbers are better written in scientific
#    notation, with the letter @c(e) or @c(E) preceding the decimal exponent:
   Pueden omitirse los digitos antes del punto decimal (@c(.707)) o despues de
   el (@c(1.)). Es mejor escribir numeros muy pequeños o muy grandes en notacion
   cientifica, con la letra @c(e) o @c(E) precediendo el exponente decimal:

#    ..src > go
#      const Avogadro = 6.02214129e23
#      const Planck   = 6.62606957e-34
#    < src..
   ..src > go
     const Avogadro = 6.02214129e23
     const Planck   = 6.62606957e-34
   < src..

#    Floating-point values are conveniently printed with @c(Printf)’s @c(%g) verb,
#    which chooses the most compact representation that has adequate precision,
#    but for tables of data, the @c(%e) (exponent) or @c(%f) (no exponent) forms
#    may be more appropriate. All three verbs allow field width and numeric
#    precision to be controlled.
   Los Valores de coma flotante se imprimen convenientemente con el verbo @c(%g)
   de @c(Printf), que elige la representacion mas compacta con la precision
   adecuada, pero para las tablas de datos, es mas adecuado el formato @c(%e)
   (exponente) o %f (sin exponente). Los tres verbos permiten controlar el ancho
   del campo y la precision numerica.

#    ..src > go
#      for x := 0; x < 8; x++ {
#        fmt.Printf("x = %d eˣ = %8.3f\n", x, math.Exp(float64(x)))
#      }
#    < src..
   ..src > go
     for x := 0; x < 8; x++ {
       fmt.Printf("x = %d eˣ = %8.3f\n", x, math.Exp(float64(x)))
     }
   < src..

#    The code above prints the powers of @e(e) with three decimal digits of
#    precision, aligned in an eight-character field:
   El codigo anterior imprime las potencias de @e(e) con tres digitos decimales
   de precision, alineados en un campo de ocho caracteres:

#    ..pre >
#      x = 0 eˣ =    1.000
#      x = 1 eˣ =    2.718
#      x = 2 eˣ =    7.389
#      x = 3 eˣ =   20.086
#      x = 4 eˣ =   54.598
#      x = 5 eˣ =  148.413
#      x = 6 eˣ =  403.429
#      x = 7 eˣ = 1096.633
   ..pre >
     x = 0 eˣ =    1.000
     x = 1 eˣ =    2.718
     x = 2 eˣ =    7.389
     x = 3 eˣ =   20.086
     x = 4 eˣ =   54.598
     x = 5 eˣ =  148.413
     x = 6 eˣ =  403.429
     x = 7 eˣ = 1096.633

#    In addition to a large collection of the usual mathematical functions, the
#    @c(math) package has functions for creating and detecting the special values
#    defined by IEEE 754: the positive and negative infinities, which represent
#    numbers of excessive magnitude and the result of division by zero; and NaN
#    (@"(not a number)), the result of such mathematically dubious operations as
#    @c(0/0) or @c[Sqrt(-1)].
   Ademas de una gran coleccion de las funciones matematicas comunes, el paquete
   @c(math) tiene funciones para crear y detectar los valores especiales
   definidas por IEEE 754: los infinitos positivo y negativo, que representan
   los numeros de magnitud excesiva y el resultado de la division por cero; y
   NaN (@"(not a number)), el resultado de operaciones matematicamente dudosas
   como @c(0/0) o @[Sqrt(-1)].

#    ..src > go
#      var z float64
#      fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
#    < src..
   ..src > go
     var z float64
     fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
   < src..

#    The function @c(math.IsNaN) tests whether its argument is a not-a-number
#    value, and @c(math.NaN) returns such a value. It’s tempting to use NaN as a
#    sentinel value in a numeric computation, but testing whether a specific
#    computational result is equal to NaN is fraught with peril because any
#    comparison with NaN @e(always) yields @c(false):
   La funcion @c(math.IsNaN) prueba si su argumento es un valor no-numerico, y
   @c(math.NaN) devuelve ese valor. Es tentador utilizar NaN como un valor
   centinela en un calculo numerico, pero probar si el resultado de un calculo
   especifico es igual NaN esta lleno de peligros, ya que cualquier comparacion
   con NaN @e(siempre) produce @c(false):

#    ..src > go
#      nan := math.NaN()
#      fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
#    < src..
   ..src > go
     nan := math.NaN()
     fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
   < src..

#    If a function that returns a floating-point result might fail, it’s better to
#    report the failure separately, like this:
   Si una funcion que devuelve un resultado de coma flotante puede fallar, es
   mejor informar el error por separado, como aqui:

#    ..src > go
#      func compute() (value float64, ok bool) {
#        // ...
#        if failed {
#          return 0, false
#        }
#        return result, true
#      }
#    < src..
   ..src > go
     func compute() (value float64, ok bool) {
       // ...
       if failed {
         return 0, false
       }
       return result, true
     }
   < src..

#    The next program illustrates floating-point graphics computation. It plots a
#    function of two variables @c[z = f(x, y)] as a wire mesh 3-D surface, using
#    Scalable Vector Graphics (@A(SVG)), a standard @A(XML) notation for line
#    drawings. Figure 3.1 shows an example of its output for the function
#    @c[sin(r)/r], where @c(r) is @c[sqrt(x*x+y*y)].
   El siguiente programa ilustra el calculo de graficos en coma flotante. Se
   traza una funcion de dos variables @c[z = f(x, y)] como una superficie de
   malla de alambre 3-D, utilizando graficos vectoriales escalables (SVG), en
   notacion XML estandar para dibujos lineales. La Figura 3.1 muestra un ejemplo
   de salida de la funcion @c[sin(r)/r], donde @c(r) es @c[sqrt(x*x+y*y)].

#    ..figure > Figure 3.1. A surface plot of the function @c[sin(r)/r].
   ..figure > Figura 3.1. Un grafico superficial de la funcion @c[sin(r)/r].

#      ..img > img/Figure-3.1.jpg
     ..img > img/Figure-3.1.jpg


#    ..figure > @l(gopl.io/ch3/surface/main.go<>gopl.io/ch3/surface)
   ..figure > @l(gopl.io/ch3/surface/main.go<>gopl.io/ch3/surface)

#      ..src > go
#        // Surface computes an SVG rendering of a 3-D surface function.
#        package main
#
#        import (
#          "fmt"
#          "math"
#        )
#
#        const (
#          width, height = 600, 320            // canvas size in pixels
#          cells         = 100                 // number of grid cells
#          xyrange       = 30.0                // axis ranges (-xyrange..+xyrange)
#          xyscale       = width / 2 / xyrange // pixels per x or y unit
#          zscale        = height * 0.4        // pixels per z unit
#          angle         = math.Pi / 6         // angle of x, y axes (=30°)
#        )
#
#        var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)
#
#        func main() {
#          fmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+
#            "style='stroke: grey; fill: white; stroke-width: 0.7' "+
#            "width='%d' height='%d'>", width, height)
#          for i := 0; i < cells; i++ {
#            for j := 0; j < cells; j++ {
#              ax, ay := corner(i+1, j)
#              bx, by := corner(i, j)
#              cx, cy := corner(i, j+1)
#              dx, dy := corner(i+1, j+1)
#              fmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
#                ax, ay, bx, by, cx, cy, dx, dy)
#            }
#          }
#          fmt.Println("</svg>")
#        }
#
#        func corner(i, j int) (float64, float64) {
#          // Find point (x,y) at corner of cell (i,j).
#          x := xyrange * (float64(i)/cells - 0.5)
#          y := xyrange * (float64(j)/cells - 0.5)
#
#          // Compute surface height z.
#          z := f(x, y)
#
#          // Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).
#          sx := width/2 + (x-y)*cos30*xyscale
#          sy := height/2 + (x+y)*sin30*xyscale - z*zscale
#          return sx, sy
#        }
#
#        func f(x, y float64) float64 {
#          r := math.Hypot(x, y) // distance from (0,0)
#          return math.Sin(r) / r
#        }
#      < src..
     ..src > go
       // Surface calcula una representacion SVG de una funcion de superficie 3D
       package main

       import (
         "fmt"
         "math"
       )

       const (
         width, height = 600, 320            // tamaño de la superficie en pixeles
         cells         = 100                 // numero de celdas de la cuadricula
         xyrange       = 30.0                // ejes (-xyrange..+xyrange)
         xyscale       = width / 2 / xyrange // pixeles por unidad x o y
         zscale        = height * 0.4        // pixeles por unidad z
         angle         = math.Pi / 6         // angulo de ejes x, y (=30°)
       )

       var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)

       func main() {
         fmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+
           "style='stroke: grey; fill: white; stroke-width: 0.7' "+
           "width='%d' height='%d'>", width, height)
         for i := 0; i < cells; i++ {
           for j := 0; j < cells; j++ {
             ax, ay := corner(i+1, j)
             bx, by := corner(i, j)
             cx, cy := corner(i, j+1)
             dx, dy := corner(i+1, j+1)
             fmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
               ax, ay, bx, by, cx, cy, dx, dy)
           }
         }
         fmt.Println("</svg>")
       }

       func corner(i, j int) (float64, float64) {
         // Hallar el punto (x,y) en la esquina de la celda (i,j).
         x := xyrange * (float64(i)/cells - 0.5)
         y := xyrange * (float64(j)/cells - 0.5)

         // Calcular la altura de la superficie z.
         z := f(x, y)

         // Proyeccion isometrica (x,y,z) sobre superficie SVG 2-D (sx,sy).
         sx := width/2 + (x-y)*cos30*xyscale
         sy := height/2 + (x+y)*sin30*xyscale - z*zscale
         return sx, sy
       }

       func f(x, y float64) float64 {
         r := math.Hypot(x, y) // distancia de (0,0)
         return math.Sin(r) / r
       }
     < src..


#    Notice that the function corner returns two values, the coordinates of the
#    corner of the cell.
   Observe que la esquina de funcion devuelve dos valores, las coordenadas de la
   esquina de la celda.

#    The explanation of how the program works requires only basic geometry, but
#    it’s fine to skip over it, since the point is to illustrate floating-point
#    computation. The essence of the program is mapping between three different
#    coordinate systems, shown in Figure 3.2. The first is a 2-D grid of 100&100
#    cells identified by integer coordinates @m[(i, j)], starting at @m[(0, 0)] in
#    the far back corner. We plot from the back to the front so that background
#    polygons may be obscured by foreground ones.
   La explicacion de como funciona el programa requiere solo geometria basica,
   pero esta bien pasarla por alto, ya que el punto es ilustrar la computacion
   de punto flotante. La esencia del programa es el mapeo entre tres sistemas de
   coordenadas diferentes, como se muestra en la Figura 3.2. La primera es una
   red de 2D de 100 y 100 celdas identificadas por coordenadas enteras @m[(i,
   j)], a partir de @m[(0, 0)] en la esquina mas lejanas. Trazamos desde la
   parte posterior al frente de modo que los poligonos del fondo puedan ser
   oscurecidos por los primeros.

#    The second coordinate system is a mesh of 3-D floating-point coordinates
#    @m[(x, y, z)], where @m(x) and @m(y) are linear functions of @m(i) and @m(j),
#    translated so that the origin is in the center, and scaled by the constant
#    @c(xyrange). The height @m(z) is the value of the surface function @m[ƒ(x,
#    y)].
   El segundo sistema de coordenadas es una malla de coordenadas 3-D de punto
   flotante @m[(x, y, z)], donde @m(x) e @m(y) son funciones lineales de @m(i) y
   @m(j), traducido de manera que el origen esta en el centro, y escalado por la
   constante @c(xyrange). La altura @m(z) es el valor de la funcion de
   superficie @m[ƒ(x, y)].

#    The third coordinate system is the 2-D image canvas, with @m[(0, 0)] in the
#    top left corner. Points in this plane are denoted @m[(sx, sy)]. We use an
#    isometric projection to map each 3-D point
   El tercer sistema de coordenadas es la superficie 2-D de la imagen, con
   @m[(0, 0)] en la esquina superior izquierda. Los puntos en este plano se
   denotan @m[(sx, sy)]. Utilizamos una proyeccion isometrica para correlacionar
   cada punto 3D

#    ..figure > Figure 3.2. Three different coordinate systems.
   ..figure > Figura 3.2. Tres sistemas de coordenadas diferentes.

#      ..img > img/Figure-3.2.jpg
     ..img > img/Figure-3.2.jpg


#    @m[(x, y, z)] onto the 2-D canvas. A point appears farther to the right on
#    the canvas the greater its @m(x) value or the @e(smaller) its @m(y)
#    value. And a point appears farther down the canvas the greater its @m(x)
#    value or @m(y) value, and the smaller its @m(z) value. The vertical and
#    horizontal scale factors for @m(x) and @m(y) are derived from the sine and
#    cosine of a 30° angle. The scale factor for @m(z), 0.4, is an arbitrary
#    parameter.
   @m[(x, y, z)] sobre la superficie 2-D. Un punto aparece mas a la derecha en
   la superficie cuanto mayor sera su valor @m(x) o menor sea su valor @m(y). Y
   un punto aparece mas abajo en la superficie cuanto mayor sera su valor @m(x)
   o el valor @m(y), y cuanto menor sea su valor @m(z). Los factores de escala
   horizontal o vertical para @m(x) e @m(y) se derivan del seno y coseno de un
   angulo de 30°. El factor de escala para @m(z), 0.4, es un parametro
   arbitrario.

#    For each cell in the 2-D grid, the main function computes the coordinates on
#    the image canvas of the four corners of the polygon ABCD, where B corresponds
#    to @m[(i, j)] and A, C, and D are its neighbors, then prints an SVG
#    instruction to draw it.
   Para cada celda de la cuadricula 2-D, la funcion principal calcula las
   coordenadas en la superficie de imagen de las cuatro esquinas del poligono
   ABCD, donde B corresponde a @m[(i, j)] y A, C, y D son sus vecinos, entonces
   imprime una instruccion SVG para dibujarla.

#    @b(Exercise 3.1): If the function @c(f) returns a non-finite @c(float64)
#    value, the SVG file will contain invalid @c(<polygon>) elements (although
#    many SVG renderers handle this gracefully). Modify the program to skip
#    invalid polygons.
   @b(Ejercicio 3.1): Si la funcion @c(f) devuelve un valor @c(float64)
   no-finito, el archivo SVG contendra elementos @c(<polygon>) no validos
   (aunque muchos procesadores SVG manejan esto con gracia). Modifique el
   programa para omitir poligonos no validos.

#    @b(Exercise 3.2): Experiment with visualizations of other functions from the
#    @c(math) package. Can you produce an egg box, moguls, or a saddle?
   @b(Ejercicio 3.2): Experimente con visualizaciones de otras funciones del
   paquete @c(math). ¿Puede usted producir una caja de huevos, moguls, o una
   montura?

#    @b(Exercise 3.3): Color each polygon based on its height, so that the peaks
#    are colored red (@c(#ff0000)) and the valleys blue (@c(#0000ff)).
   @b(Ejercicio 3.3): El color de cada poligono en funcion de su altura, por lo
   que los picos son de color rojo (@c(#ff0000)) y los valles azul
   (@c(#0000ff)).

#    @b(Exercise 3.4): Following the approach of the Lissajous example in
#    @l(#Section 1.7), construct a web server that computes surfaces and writes
#    SVG data to the client. The server must set the @c(Content-Type) header like
#    this:
   @b(Ejercicio 3.4): Siguiendo el enfoque del ejemplo Lissajous en la
   @l(#Seccion 1.7), construya un servidor web que calcule superficies y escriba
   los datos SVG al cliente. El servidor debe establecer el manejador
   @c(Content-Type) asi:

#    ..src > go
#      w.Header().Set("Content-Type", "image/svg+xml")
#    < src..
   ..src > go
     w.Header().Set("Content-Type", "image/svg+xml")
   < src..

#    (This step was not required in the Lissajous example because the server uses
#    standard heuristics to recognize common formats like PNG from the first 512
#    bytes of the response and generates the proper header.) Allow the client to
#    specify values like height, width, and color as HTTP request parameters.
   (Este paso no era necesario en el ejemplo de Lissajous porque el servidor
   utiliza la heuristica estandar para reconocer formatos comunes como PNG de
   los primeros 512 bytes de la respuesta y generar el encabezado
   adecuado). Permitir al cliente especificar valores como altura, ancho y color
   como parametros de peticion HTTP.

# ** Section 3.3 <> Complex Numbers
** Seccion 3.3 <> Numeros complejos

#    Go provides two sizes of complex numbers, @c(complex64) and @c(complex128),
#    whose components are @c(float32) and @c(float64) respectively. The built-in
#    function @c(complex) creates a complex number from its real and imaginary
#    components, and the built-in @c(real) and @c(imag) functions extract those
#    components:
   Go proporciona dos tamaños de numeros complejos, @c(complex64) y
   @c(complex128), cuyos componentes son @c(float32) y @c(float64)
   respectivamente. La funcion nativa @c(complex) crea un numero complejo a
   partir de sus componentes real e imaginario, e incorpora funciones @c(real) y
   @c(imag) para extraer estos componentes:

#    ..src > go
#      var x complex128 = complex(1, 2) // 1+2i
#      var y complex128 = complex(3, 4) // 3+4i
#      fmt.Println(x*y)                 // "(-5+10i)"
#      fmt.Println(real(x*y))           // "-5"
#      fmt.Println(imag(x*y))           // "10"
#    < src..
   ..src > go
     var x complex128 = complex(1, 2) // 1+2i
     var y complex128 = complex(3, 4) // 3+4i
     fmt.Println(x*y)                 // "(-5+10i)"
     fmt.Println(real(x*y))           // "-5"
     fmt.Println(imag(x*y))           // "10"
   < src..

#    If a floating-point literal or decimal integer literal is immediately
#    followed by @c(i), such as @c(3.141592i) or @c(2i), it becomes an
#    @e(imaginary literal), denoting a complex number with a zero real
#    component:
   Si un punto flotante literal entero o decimal literal es seguido
   inmediatamente por @c(i), como @c(3.141592i) o @c(2i), se convierte en un
   literal imaginario, que denota un numero complejo con un componente real
   cero:

#    ..src > go
#      fmt.Println(1i * 1i) // "(-1+0i)", i² = -1
#    < src..
   ..src > go
     fmt.Println(1i * 1i) // "(-1+0i)", i² = -1
   < src..

#    Under the rules for constant arithmetic, complex constants can be added to
#    other constants (integer or floating point, real or imaginary), allowing us
#    to write complex numbers naturally, like @c(1+2i), or equivalently,
#    @c(2i+1). The declarations of @c(x) and @c(y) above can be simplified:
   Bajo las reglas de la aritmetica constante, constantes complejas se pueden
   añadir a otras constantes (enteras o de coma flotante, real o imaginarias),
   lo que nos permite escribir numeros complejos de forma natural, como
   @c(1+2i), o equivalentemente, @c(2i+1) . Las anteriores declaraciones @c(x) y
   @c(y) se pueden simplificar:

#    ..src > go
#      x := 1 + 2i
#      y := 3 + 4i
#    < src..
   ..src > go
     x := 1 + 2i
     y := 3 + 4i
   < src..

#    Complex numbers may be compared for equality with @c(==) and @c(!=). Two
#    complex numbers are equal if their real parts are equal and their imaginary
#    parts are equal.
   Los numeros complejos se pueden comparar por igualdad con @c(==) y
   @c(!=). Dos numeros complejos son iguales si sus partes reales son iguales y
   sus partes imaginarias son iguales.

#    The @c(math/cmplx) package provides library functions for working with
#    complex numbers, such as the complex square root and exponentiation
#    functions.
   El paquete @c(math/cmplx) proporciona funciones de libreria para trabajar con
   numeros complejos, tales como las raiz cuadrada compleja y las funciones de
   exponenciacion.

#    ..src > go
#      fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"
#    < src..
   ..src > go
     fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"
   < src..

#    The following program uses @c(complex128) arithmetic to generate a Mandelbrot
#    set.
   El siguiente programa utiliza aritmetica @c(complex128) para generar un
   conjunto de Mandelbrot.

#    ..figure > @l(gopl.io/ch3/mandelbrot/main.go<>gopl.io/ch3/mandelbrot)
   ..figure > @l(gopl.io/ch3/mandelbrot/main.go<>gopl.io/ch3/mandelbrot)

#      ..src > go
#        // Mandelbrot emits a PNG image of the Mandelbrot fractal.
#        package main
#
#        import (
#          "image"
#          "image/color"
#          "image/png"
#          "math/cmplx"
#          "os"
#        )
#
#        func main() {
#          const (
#            xmin, ymin, xmax, ymax = -2, -2, +2, +2
#            width, height          = 1024, 1024
#          )
#
#          img := image.NewRGBA(image.Rect(0, 0, width, height))
#          for py := 0; py < height; py++ {
#            y := float64(py)/height*(ymax-ymin) + ymin
#            for px := 0; px < width; px++ {
#              x := float64(px)/width*(xmax-xmin) + xmin
#              z := complex(x, y)
#              // Image point (px, py) represents complex value z.
#              img.Set(px, py, mandelbrot(z))
#            }
#          }
#          png.Encode(os.Stdout, img) // NOTE: ignoring errors
#        }
#
#        func mandelbrot(z complex128) color.Color {
#          const iterations = 200
#          const contrast = 15
#
#          var v complex128
#          for n := uint8(0); n < iterations; n++ {
#            v = v*v + z
#            if cmplx.Abs(v) > 2 {
#              return color.Gray{255 - contrast*n}
#            }
#          }
#          return color.Black
#        }
#      < src..
     ..src > go
       // Mandelbrot emite una imagen PNG del fractal de Mandelbrot.
       package main

       import (
         "image"
         "image/color"
         "image/png"
         "math/cmplx"
         "os"
       )

       func main() {
         const (
           xmin, ymin, xmax, ymax = -2, -2, +2, +2
           width, height          = 1024, 1024
         )

         img := image.NewRGBA(image.Rect(0, 0, width, height))
         for py := 0; py < height; py++ {
           y := float64(py)/height*(ymax-ymin) + ymin
           for px := 0; px < width; px++ {
             x := float64(px)/width*(xmax-xmin) + xmin
             z := complex(x, y)
             // El punto de imagen (px, py) representa el valor complejo z.
             img.Set(px, py, mandelbrot(z))
           }
         }
         png.Encode(os.Stdout, img) // NOTA: ignorando errores
       }

       func mandelbrot(z complex128) color.Color {
         const iterations = 200
         const contrast = 15

         var v complex128
         for n := uint8(0); n < iterations; n++ {
           v = v*v + z
           if cmplx.Abs(v) > 2 {
             return color.Gray{255 - contrast*n}
           }
         }
         return color.Black
       }
     < src..


#    The two nested loops iterate over each point in a 1024x1024 grayscale raster
#    image representing the -2 to +2 portion of the complex plane. The program
#    tests whether repeatedly squaring and adding the number that point represents
#    eventually @"(escapes) the circle of radius 2. If so, the point is shaded by
#    the number of iterations it took to escape. If not, the value belongs to the
#    Mandelbrot set, and the point remains black. Finally, the program writes to
#    its standard output the PNG-encoded image of the iconic fractal, shown in
#    Figure 3.3.
   Los dos bucles anidados iteran sobre cada punto en una imagen en cuadricula
   de escala de grises de 1024x1024 que representa la porcion de -2 a +2 del
   plano complejo. El programa prueba si repetidamente cuadrando y añadiendo el
   numero del punto representado eventualmente @"(escapa) el circulo de
   radio 2. Si es asi, el punto es sombreado por el numero de iteraciones que se
   tardo en escapar. Si no, el valor pertenece al conjunto de Mandelbrot, y el
   punto permanece negro. Finalmente, el programa escribe en su salida estandar
   la imagen codificada en PNG del iconico fractal, que se muestra en la Figura
   3.3.

#    ..figure > Figure 3.3. The Mandelbrot set.
   ..figure > Figura 3.3. El conjunto de Mandelbrot.

#      ..img > img/Figure-3.3.jpg
     ..img > img/Figure-3.3.jpg


#    @b(Exercise 3.5): Implement a full-color Mandelbrot set using the function
#    @c(image.NewRGBA) and the type @c(color.RGBA) or @c(color.YCbCr).
   @b(Ejercicio 3.5): Implementar a todo color el cojunto de Mandelbrot usando
   la funcion @c(image.NewRGBA) y el tipo @c(color.RGBA) o @c(color.YCbCr).

#    @b(Exercise 3.6): Supersampling is a technique to reduce the effect of
#    pixelation by computing the color value at several points within each pixel
#    and taking the average. The simplest method is to divide each pixel into four
#    @"(subpixels.) Implement it.
   @b(Ejercicio 3.6): Supermuestreo es una tecnica para reducir el efecto de
   pixelacion calculando el valor del color en varios puntos dentro de cada
   pixel y tomando el promedio. El metodo mas simple consiste en dividir cada
   pixel en cuatro @"(subpixeles.) Implementalo.

#    @b(Exercise 3.7): Another simple fractal uses Newton’s method to find complex
#    solutions to a function such as @m(z⁴-1 = 0). Shade each starting point by
#    the number of iterations required to get close to one of the four
#    roots. Color each point by the root it approaches.
   @b(Ejercicio 3.7): Otro fractal sencillo utiliza el metodo Newton para
   encontrar soluciones complejas a una funcion como @m(z⁴-1 = 0). Sombrea cada
   punto de partida por el numero de iteraciones necesarias para acercarse a una
   de las cuatro raices. Colorea cada punto por la raiz que se aproxima.

#    @b(Exercise 3.8): Rendering fractals at high zoom levels demands great
#    arithmetic precision. Implement the same fractal using four different
#    representations of numbers: @c(complex64), @c(complex128), @c(big.Float), and
#    @c(big.Rat). (The latter two types are found in the @c(math/big) package.
#    @c(Float) uses arbitrary but bounded-precision floating-point; @c(Rat) uses
#    unbounded-precision rational numbers.) How do they compare in performance and
#    memory usage? At what zoom levels do rendering artifacts become visible?
   @b(Ejercicio 3.8): La Representacion de fractales con altos niveles de zoom
   exige una gran precision aritmetica. Implementa el mismo fractal utilizando
   cuatro representaciones diferentes de numeros: @c(complex64), @c(complex128),
   @c(big.Float), y @c(big.Rat). (Los ultimos dos tipos se encuentran en el
   paquete @c(math/big). @c(Float) utiliza arbitraria, pero delimitada precision
   de punto flotante; @c(Rat) utiliza numeros racionales sin limites de
   precision.)  ¿Como se comparan en el rendimiento y uso de memoria? ¿A que
   niveles de zoom se hacen visibles los artefactos de renderizacion?

#    @b(Exercise 3.9): Write a web server that renders fractals and writes the
#    image data to the client.  Allow the client to specify the @m(x), @m(y), and
#    zoom values as parameters to the HTTP request.
   @b(Ejercicio 3.9): Escriba un servidor web que procese fractales y escribe
   los datos de imagen al cliente. Permita que el cliente especifique las
   coordenadas @c(x), @c(y), y los valores de zoom como parametros en la
   peticion HTTP.

# ** Section 3.4 <> Booleans
** Seccion 3.4 <> Booleanos

#    A value of type @c(bool), or @e(boolean), has only two possible values,
#    @c(true) and @c(false). The conditions in @c(if) and @c(for) statements are
#    booleans, and comparison operators like @c(==) and @c(<) produce a boolean
#    result. The unary operator @c(!) is logical negation, so @c(!true) is
#    @c(false), or, one might say, @c[(!true==false)==true], although as a matter
#    of style, we always simplify redundant boolean expressions like @c(x==true)
#    to @c(x).
   Un valor de tipo @c(bool), o @e(booleano), tiene solo dos valores posibles,
   @c(true) y @c(false). Las condiciones en @c(if) y @c(for) son declaraciones
   booleanas, y los operadores de comparacion como @c(==) y @c(<) producen un
   resultado booleano. El operador unario @c(!) es la negacion logica, de modo
   que @c(!true) es @c(false), o, por decirlo asi, @c[(!true==false)==true],
   aunque por cuestion de estilo, siempre simplificamos las expresiones
   booleanas redundantes como @c(x==true) a @c(x).

#    Boolean values can be combined with the @c(&&) (AND) and @c(||) (OR)
#    operators, which have @e(shortcircuit) behavior: if the answer is already
#    determined by the value of the left operand, the right operand is not
#    evaluated, making it safe to write expressions like this:
   Los valores booleanos pueden ser combinados con los operadores @c(&&) (AND) y
   @c(||) (OR), que tienen un comportamiento de @e(cortocircuito): si la
   respuesta ya esta determinada por el valor del operando de la izquierda, el
   operando de la derecha no se evalua, por lo que es seguro para escribir
   expresiones como esta:

#    ..src > go
#      s != "" && s[0] == 'x'
#    < src..
   ..src > go
     s != "" && s[0] == 'x'
   < src..

#    where @c(s[0]) would panic if applied to an empty string.
   donde @c(s[0]) produciria un panico si se aplica a una cadena vacia.

#    Since @c(&&) has higher precedence than @c(||) (mnemonic: @c(&&) is boolean
#    multiplication, @c(||) is boolean addition), no parentheses are required for
#    conditions of this form:
   Ya que @c(&&) tiene mayor precedencia que @c(||) (mnemonico: @c(&&) es la
   multiplicacion booleana, @c(||) es la adicion boolean), no se requieren
   parentesis para las condiciones de esta forma:

#    ..src > go
#      if 'a' <= c && c <= 'z' ||
#        'A' <= c && c <= 'Z' ||
#        '0' <= c && c <= '9' {
#        // ...ASCII letter or digit...
#      }
#    < src..
   ..src > go
     if 'a' <= c && c <= 'z' ||
       'A' <= c && c <= 'Z' ||
       '0' <= c && c <= '9' {
       // ...letra o digito ASCII...
     }
   < src..

#    There is no implicit conversion from a boolean value to a numeric value like
#    0 or 1, or vice versa. It’s necessary to use an explicit @c(if), as in
   No hay una conversion implicita de un valor booleano a un valor numerico como
   0 o 1, o viceversa. Es necesario utilizar un @c(if) explicito, como en

#    ..src > go
#      i := 0
#      if b {
#        i = 1
#      }
#    < src..
   ..src > go
     i := 0
     if b {
       i = 1
     }
   < src..

#    It might be worth writing a conversion function if this operation were needed often:
   Podria valer la pena escribir una funcion de conversion si esta operacion se
   necesita a menudo:

#    ..src > go
#      // btoi returns 1 if b is true and 0 if false.
#      func btoi(b bool) int {
#        if b {
#          return 1
#        }
#        return 0
#      }
#    < src..
   ..src > go
     // btoi regresa 1 si b es verdadero y 0 sy es falso.
     func btoi(b bool) int {
       if b {
         return 1
       }
       return 0
     }
   < src..

#    The inverse operation is so simple that it doesn’t warrant a function, but
#    for symmetry here it is:
   La operacion inversa es tan simple que no necesita una funcion, pero por
   simetria aqui esta:

#    ..src > go
#      // itob reports whether i is non-zero.
#      func itob(i int) bool { return i != 0 }
#    < src..
   ..src > go
     // itob reporta cuando i no es cero.
     func itob(i int) bool { return i != 0 }
   < src..

# ** Section 3.5 <> Strings
** Seccion 3.5 <> Cadenas

#    A string is an immutable sequence of bytes. Strings may contain arbitrary
#    data, including bytes with value 0, but usually they contain human-readable
#    text. Text strings are conventionally interpreted as UTF-8-encoded sequences
#    of Unicode code points (runes), which we’ll explore in detail very soon.
   Una cadena es una secuencia inmutable de bytes. Las cadenas pueden contener
   datos arbitrarios, incluyendo bytes con valor 0, pero normalmente contienen
   texto legible por humanos. Las cadenas de texto se interpretan de forma
   convencional como secuencias codificadas en UTF-8 de puntos de codigo Unicode
   (runas), que exploraremos en detalle muy pronto.

#    The built-in @c(len) function returns the number of bytes (not runes) in a
#    string, and the @e(index) operation @c(s[i]) retrieves the @m(i)-th byte of
#    string @c(s), where @c(0) ≤ @c(i) < @c[len(s)].
   La funcion nativa @c(len) devuelve el numero de bytes (no runas) en una
   cadena, y la operacion de indice @c(s[i]) recupera el @m(n)-esimo byte de la
   cadena @c(s), donde @c(0) ≤ @c(i) < @c[len(s)].

#    ..src > go
#      s := "hello, world"
#      fmt.Println(len(s))     // "12"
#      fmt.Println(s[0], s[7]) // "104 119"  ('h' and 'w')
#    < src..
   ..src > go
     s := "hello, world"
     fmt.Println(len(s))     // "12"
     fmt.Println(s[0], s[7]) // "104 119"  ('h' and 'w')
   < src..

#    Attempting to access a byte outside this range results in a panic:
   Intentar acceder a un byte fuera de este rango produce un panico:

#    ..src > go
#      c := s[len(s)] // panic: index out of range
#    < src..
   ..src > go
     c := s[len(s)] // panico: indice fuera de rango
   < src..

#    The @m(i)-th byte of a string is not necessarily the @m(i)-th @e(character)
#    of a string, because the UTF-8 encoding of a non-ASCII code point requires
#    two or more bytes. Working with characters is discussed shortly.
   El @m(n)-esimo byte de una cadena no es necesariamente el @m(n)-esimo
   caracter de una cadena, porque la codificacion UTF-8 de un punto de codigo no
   ASCII requiere dos o mas bytes. Como Trabajar con caracteres se discutira en
   breve.

#    The @e(substring) operation @c(s[i:j]) yields a new string consisting of the
#    bytes of the original string starting at index @c(i) and continuing up to,
#    but not including, the byte at index @c(j). The result contains @c(j-i)
#    bytes.
   La operacion de subcadena @c(s[i:j]) produce una nueva cadena que consta de
   los bytes de la cadena original a partir del indice @c(i) y continua hasta,
   pero no incluyendo, el byte en el indice @c(j). El resultado contiene @c(j-i)
   bytes.

#    ..src > go
#      fmt.Println(s[0:5]) // "hello"
#    < src..
   ..src > go
     fmt.Println(s[0:5]) // "hello"
   < src..

#    Again, a panic results if either index is out of bounds or if @c(j) is less
#    than @c(i).
   De nuevo, se produce un panico si cualquiera de los indices esta fuera de
   limite o si @c(j) es menor que @c(i).

#    Either or both of the @c(i) and @c(j) operands may be omitted, in which case the
#    default values of 0 (the start of the string) and @c[len(s)] (its end) are
#    assumed, respectively.
   Cualquiera o ambos operandos @c(i) y @c(j) pueden omitirse, en cuyo caso los
   valores por defecto son 0 (el inicio de la cadena) y @c[len(s)] (su final),
   respectivamente.

#    ..src > go
#      fmt.Println(s[:5]) // "hello"
#      fmt.Println(s[7:]) // "world"
#      fmt.Println(s[:])  // "hello, world"
#    < src..
   ..src > go
     fmt.Println(s[:5]) // "hello"
     fmt.Println(s[7:]) // "world"
     fmt.Println(s[:])  // "hello, world"
   < src..

#    The @c(+) operator makes a new string by concatenating two strings:
   El operador c(+) crea una nueva cadena mediante la concatenacion de dos
   cadenas:

#    ..src > go
#      fmt.Println("goodbye" + s[5:]) // "goodbye, world"
#    < src..
   ..src > go
     fmt.Println("goodbye" + s[5:]) // "goodbye, world"
   < src..

#    Strings may be compared with comparison operators like @c(==) and @c(<); the
#    comparison is done byte by byte, so the result is the natural lexicographic
#    ordering.
   Las cadenas pueden compararse con los operadores de comparacion como @c(==) y
   @c(<); La comparacion se realiza byte a byte, por lo que el resultado es el
   orden lexicografico natural.

#    String values are immutable: the byte sequence contained in a string value
#    can never be changed, though of course we can assign a new value to a string
#    @e(variable). To append one string to another, for instance, we can write
   Los valores de cadena son inmutables: la secuencia de bytes contenidos en un
   valor de cadena no se puede cambiar, aunque, por supuesto, podemos asignar un
   nuevo valor a una variable de cadena. Para añadir una cadena a otra, por
   ejemplo, podemos escribir

#    ..src > go
#      s := "left foot"
#      t := s
#      s += ", right foot"
#    < src..
   ..src > go
     s := "left foot"
     t := s
     s += ", right foot"
   < src..

#    This does not modify the string that @c(s) originally held but causes @c(s)
#    to hold the new string formed by the @c(+=) statement; meanwhile, @c(t) still
#    contains the old string.
   Esto no modifica la cadena que retenia @c(s) originalmente, pero hace que
   @c(s) contenga la nueva cadena formada por la sentencia @c(+=); Mientras
   tanto, @c(t) aun contiene la cadena antigua.

#    ..src > go
#      fmt.Println(s) // "left foot, right foot"
#      fmt.Println(t) // "left foot"
#    < src..
   ..src > go
     fmt.Println(s) // "left foot, right foot"
     fmt.Println(t) // "left foot"
   < src..

#    Since strings are immutable, constructions that try to modify a string’s data
#    in place are not allowed:
   Dado que las cadenas son inmutables, no se permiten las construcciones que
   intentan modificar los datos de una cadena en su lugar:

#    ..src > go
#      s[0] = 'L' // compile error: cannot assign to s[0]
#    < src..
   ..src > go
     s[0] = 'L' // error de compilacion: no se puede asignar a s[0]
   < src..

#    Immutability means that it is safe for two copies of a string to share the
#    same underlying memory, making it cheap to copy strings of any length.
#    Similarly, a string @c(s) and a substring like @c(s[7:]) may safely share the
#    same data, so the substring operation is also cheap. No new memory is
#    allocated in either case. Figure 3.4 illustrates the arrangement of a string
#    and two of its substrings sharing the same underlying byte array.
   Inmutabilidad significa que es seguro que dos copias de una cadena compartan
   la misma memoria subyacente, por lo que es barato copiar cadenas de cualquier
   longitud. Del mismo modo, una cadena @c(s) y una subcadena como @c(s[7:])
   pueden compartir de forma segura los mismos datos, por lo que la operacion
   subcadena tambien es barata. No se asigna ninguna memoria nueva en ningun
   caso. La Figura 3.4 ilustra la disposicion de una cadena y dos de sus
   subcadenas que comparten el mismo arreglo de bytes subyacente.

#    ..figure > Figure 3.4. The string @c("hello, world") and two substrings.
   ..figure > Figura 3.4. La cadena @c("hello, world") y dos subcadenas.

#      ..img > img/Figure-3.4.jpg
     ..img > img/Figure-3.4.jpg

# *** Section 3.5.1 <> String Literals
*** Seccion 3.5.1 <> Cadenas Literales

#     A string value can be written as a @e(string literal), a sequence of bytes
#     enclosed in double quotes:
    Un valor de cadena se puede escribir como una @e(cadena literal), una
    secuencia de bytes entre comillas dobles:

#     ..src > go
#       "Hello, 世界"
#     < src..
    ..src > go
      "Hello, 世界"
    < src..

#     Because Go source files are always encoded in UTF-8 and Go text strings are
#     conventionally interpreted as UTF-8, we can include Unicode code points in
#     string literals.
    Debido a que los archivos fuente de Go siempre estan codificados en UTF-8 y
    las cadenas de texto Go son interpretadas convencionalmente como UTF-8,
    podemos incluir puntos de codigo Unicode en literales de cadena.

#     Within a double-quoted string literal, @e(escape sequences) that begin with
#     a backslash @c(\) can be used to insert arbitrary byte values into the
#     string. One set of escapes handles ASCII control codes like newline,
#     carriage return, and tab:
    Dentro de una literal de cadena entre comillas dobles, las secuencias de
    escape que comienzan con una barra invertida @c(\) se pueden utilizar para
    insertar valores arbitrarios de bytes en la cadena. Un conjunto de escape
    maneja codigos de control ASCII como newline, retorno de carro y tabulacion:

#     | @c(\a) | @"(alert) or bell                            |
#     |--------|----------------------------------------------|
#     | @c(\b) | backspace                                    |
#     |--------|----------------------------------------------|
#     | @c(\f) | form feed                                    |
#     |--------|----------------------------------------------|
#     | @c(\n) | newline                                      |
#     |--------|----------------------------------------------|
#     | @c(\r) | carriage return                              |
#     |--------|----------------------------------------------|
#     | @c(\t) | tab                                          |
#     |--------|----------------------------------------------|
#     | @c(\v) | vertical tab                                 |
#     |--------|----------------------------------------------|
#     | @c(\') | single quote (only in the rune literal '\'') |
#     |--------|----------------------------------------------|
#     | @c(\") | double quote (only within "..." literals)    |
#     |--------|----------------------------------------------|
#     | @c(\\) | backslash                                    |
    | @c(\a) | @"(alerta) o  campana                            |
    |--------|--------------------------------------------------|
    | @c(\b) | retroceso                                        |
    |--------|--------------------------------------------------|
    | @c(\f) | form feed                                        |
    |--------|--------------------------------------------------|
    | @c(\n) | linea nueva                                      |
    |--------|--------------------------------------------------|
    | @c(\r) | retorno de carro                                 |
    |--------|--------------------------------------------------|
    | @c(\t) | tabulador                                        |
    |--------|--------------------------------------------------|
    | @c(\v) | tabulador vertical                               |
    |--------|--------------------------------------------------|
    | @c(\') | comilla simple (solo en la runa literal '\'')    |
    |--------|--------------------------------------------------|
    | @c(\") | comillas dobles (solo dentro de "..." literales) |
    |--------|--------------------------------------------------|
    | @c(\\) | barra invertida                                  |

#     Arbitrary bytes can also be included in literal strings using hexadecimal or
#     octal escapes. A @e(hexadecimal) escape is written @c(\x)@e(hh), with exactly
#     two hexadecimal digits @e(h) (in upper or lower case). An octal escape is
#     written @e(\ooo) with exactly three octal digits @e(o) (0 through 7) not
#     exceeding @e(\377). Both denote a single byte with the specified
#     value. Later, we’ll see how to encode Unicode code points numerically in
#     string literals.
    Los bytes arbitrarios tambien se pueden incluir en cadenas literales usando
    escapes hexadecimales u octales. Un escape hexadecimal se escribe
    @c(\x)@e(hh), con exactamente dos digitos hexadecimales @e(h) (en mayusculas
    o minusculas). Un escape octal se escribe @e(\ooo) con exactamente tres
    digitos octales @e(o) (0 a 7) no superior a @c(\377). Ambos denotan un solo
    byte con el valor especificado. Mas adelante, veremos como codificar
    numericamente los puntos de codigo Unicode en literales de cadena.

#     A @e(raw string literal) is written @c(`...`), using backquotes instead of
#     double quotes. Within a raw string literal, no escape sequences are
#     processed; the contents are taken literally, including backslashes and
#     newlines, so a raw string literal may spread over several lines in the
#     program source. The only processing is that carriage returns are deleted so
#     that the value of the string is the same on all platforms, including those
#     that conventionally put carriage returns in text files.
    Una @e(literal de cadena sin formato) se escribe @c(`...`), utilizando
    comillas inversas en lugar de comillas dobles. Dentro de una literal de
    cadena sin formato, no se procesan secuencias de escape; Los contenidos se
    toman literalmente, incluyendo barras invertidas y lineas nuevas, por lo que
    un literal de cadena sin formato puede extenderse por varias lineas en el
    codigo del programa. El unico procesamiento es que los retornos de carro se
    eliminan para que el valor de la cadena sea el mismo en todas las
    plataformas, incluidas aquellas que convencionalmente ponen retornos de
    carro en archivos de texto.

#     Raw string literals are a convenient way to write regular expressions, which
#     tend to have lots of backslashes. They are also useful for HTML templates,
#     JSON literals, command usage messages, and the like, which often extend over
#     multiple lines.
    Las literales de cadenas sin formato son una manera conveniente de escribir
    expresiones regulares, que tienden a tener un monton de barras
    inversas. Tambien son utiles para plantillas HTML, literales JSON, mensajes
    de uso de comandos y similares, que a menudo se extienden sobre varias
    lineas.

#     ..src > go
#       const GoUsage = `Go is a tool for managing Go source code.
#
#       Usage:
#           go command [arguments]
#       ...`
#     < src..
    ..src > go
      const GoUsage = `Go is a tool for managing Go source code.

      Usage:
          go command [arguments]
      ...`
    < src..

# *** Section 3.5.2 <> Unicode
*** Seccion 3.5.2 <> Unicode

#     Long ago, life was simple and there was, at least in a parochial view, only
#     one character set to deal with: ASCII, the American Standard Code for
#     Information Interchange. ASCII, or more precisely US-ASCII, uses 7 bits to
#     represent 128 @"(characters): the upper- and lower-case letters of English,
#     digits, and a variety of punctuation and device-control characters. For much
#     of the early days of computing, this was adequate, but it left a very large
#     fraction of the world’s population unable to use their own writing systems
#     in computers. With the growth of the Internet, data in myriad languages has
#     become much more common. How can this rich variety be dealt with at all and,
#     if possible, efficiently?
    Hace mucho tiempo, la vida era simple y habia, por lo menos un punto de
    vista parroquial, solo un conjunto de caracteres a manejar: ASCII, el codigo
    estandar americano para el intercambio de la informacion (@e(American
    Standard Code for Information Interchange)). ASCII, o mas precisamente
    US-ASCII, utiliza 7 bits para representar 128 @"(caracteres): las letras
    mayusculas y minusculas del ingles, digitos y una variedad de caracteres de
    puntuacion y control de dispositivo. Durante gran parte de los primeros dias
    de la informatica, esto fue adecuado, pero dejo a una gran parte de la
    poblacion mundial incapaz de utilizar sus propios sistemas de escritura en
    las computadoras. Con el crecimiento de Internet, los datos en innumerables
    idiomas se han vuelto mucho mas comunes. ¿Como puede manejarse esta rica
    variedad y, si es posible, de forma eficiente?

#     The answer is Unicode (@l(http://unicode.org/<>unicode.org)), which collects
#     all of the characters in all of the world’s writing systems, plus accents
#     and other diacritical marks, control codes like tab and carriage return, and
#     plenty of esoterica, and assigns each one a standard number called a
#     @e(Unicode code point) or, in Go terminology, a @c(rune).
    La respuesta es Unicode (@l(http://unicode.org/<>unicode.org)), que recoge
    todos los caracteres de todos los sistemas de escritura del mundo, ademas de
    acentos y otros signos diacriticos, codigos de control como tabulador y
    retorno de carro, y plenty of esoterica, y asigna a cada uno un numero
    estandar denominado @e(punto de codigo Unicode) o, en la terminologia Go,
    una runa.

#     Unicode version 8 defines code points for over 120,000 characters in well
#     over 100 languages and scripts. How are these represented in computer
#     programs and data? The natural data type to hold a single rune is @c(int32),
#     and that’s what Go uses; it has the synonym @c(rune) for precisely this
#     purpose.
    Unicode version 8 define puntos de codigo para mas de 120.000 caracteres en
    mas de 100 idiomas y scripts. ¿Como se representan esto en los datos y
    programas de computadora? El tipo de datos naturales para almacenar una sola
    runa es @c(int32), y eso es lo utiliza Go; tiene el sinonimo @c(rune)
    precisamente para este proposito.

#     We could represent a sequence of runes as a sequence of @c(int32) values. In
#     this representation, which is called UTF-32 or UCS-4, the encoding of each
#     Unicode code point has the same size, 32 bits. This is simple and uniform,
#     but it uses much more space than necessary since most computer-readable text
#     is in ASCII, which requires only 8 bits or 1 byte per character. All the
#     characters in widespread use still number fewer than 65,536, which would fit
#     in 16 bits. Can we do better?
    Podriamos representar una secuencia de runas como una secuencia de valores
    @c(int32). Esta representacion, se llama UTF-32 o UCS-4, la codificacion de
    cada punto de codigo Unicode tiene el mismo tamaño, 32 bits. Esto es simple
    y uniforme, pero utiliza mucho mas espacio de lo necesario, ya que la
    mayoria de texto legible por computadora esta en ASCII, que requiere solo 8
    bits o 1 byte por caracter. Todos los caracteres en uso generalizado todavia
    aun son menos de 65.536, que cabrian en 16 bits. ¿Podemos hacerlo mejor?

# *** Section 3.5.3 <> UTF-8
*** Seccion 3.5.3 <> UTF-8

#     UTF-8 is a variable-length encoding of Unicode code points as bytes. UTF-8
#     was invented by Ken Thompson and Rob Pike, two of the creators of Go, and is
#     now a Unicode standard. It uses between 1 and 4 bytes to represent each
#     rune, but only 1 byte for ASCII characters, and only 2 or 3 bytes for most
#     runes in common use. The high-order bits of the first byte of the encoding
#     for a rune indicate how many bytes follow. A high-order @c(0) indicates
#     7-bit ASCII, where each rune takes only 1 byte, so it is identical to
#     conventional ASCII. A high-order @c(110) indicates that the rune takes 2
#     bytes; the second byte begins with @c(10). Larger runes have analogous
#     encodings.
    UTF-8 es una codificacion de longitud variable de puntos de codigo Unicode
    como bytes. UTF-8 fue inventado por Ken Thompson y Rob Pike, dos de los
    creadores de Go, y ahora es un estandar Unicode. Utiliza entre 1 y 4 bytes
    para representar cada runa, pero solo 1 byte para caracteres ASCII y solo 2
    o 3 bytes para la mayoria de runas en uso comun. Los bits de orden alto del
    primer byte de la codificacion de una runa indican cuantos bytes siguen. Un
    alto orden 0 indica ASCII de 7 bits, donde cada runa toma solo 1 byte, por
    lo que es identica a ASCII convencional. Un alto orden @c(110) indica que la
    runa toma 2 bytes; el segundo byte comienza con @c(10). Las runas mas
    grandes tienen codificaciones analogas.

#     | @c(0xxxxxx)                            | runes 0−127    | (ASCII)               |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(11xxxxx 10xxxxxx)                   | 128−2047       | (values <128 unused)  |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(110xxxx 10xxxxxx 10xxxxxx)          | 2048−65535     | (values <2048 unused) |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(1110xxx 10xxxxxx 10xxxxxx 10xxxxxx) | 65536−0x10ffff | (other values unused) |
    | @c(0xxxxxx)                            | runas 0−127    | (ASCII)                       |
    |----------------------------------------|----------------|-------------------------------|
    | @c(11xxxxx 10xxxxxx)                   | 128−2047       | (valores <128 no utilizados)  |
    |----------------------------------------|----------------|-------------------------------|
    | @c(110xxxx 10xxxxxx 10xxxxxx)          | 2048−65535     | (valores <2048 no utilizados) |
    |----------------------------------------|----------------|-------------------------------|
    | @c(1110xxx 10xxxxxx 10xxxxxx 10xxxxxx) | 65536−0x10ffff | (otros valores no utiliados)  |

#     A variable-length encoding precludes direct indexing to access the @m(n)-th
#     character of a string, but UTF-8 has many desirable properties to compensate.
#     The encoding is compact, compatible with ASCII, and self-synchronizing: it’s
#     possible to find the beginning of a character by backing up no more than
#     three bytes. It’s also a prefix code, so it can be decoded from left to
#     right without any ambiguity or lookahead. No rune’s encoding is a substring
#     of any other, or even of a sequence of others, so you can search for a rune
#     by just searching for its bytes, without worrying about the preceding
#     context. The lexicographic byte order equals the Unicode code point order,
#     so sorting UTF-8 works naturally. There are no embedded NUL (zero) bytes,
#     which is convenient for programming languages that use NUL to terminate
#     strings.
    Una codificacion de longitud variable impide la indexacion directa para
    acceder al @m(n)-esimo caracter de una cadena, pero UTF-8 tiene muchas
    propiedades deseables para compensar. La codificacion es compacta,
    compatible con ASCII y auto-sincronizada: es posible encontrar el inicio de
    un caracter al realizar una copia de seguridad de no mas de tres
    bytes. Tambien es un prefijo de codigo, por lo que se puede decodificar de
    izquierda a derecha sin ninguna ambigüedad o lookahead. La codificacion de
    ninguna runa es una subcadena de cualquier otra, o incluso de una secuencia
    de otras, por lo que puedes buscar una runa simplemente buscando sus bytes,
    sin preocuparte por el contexto anterior. El orden de bytes lexicografico es
    igual al orden de los puntos de codigo Unicode, por lo que la ordenacion de
    UTF-8 funciona de forma natural. No hay ningun NUL incrustado (cero) bytes,
    que es conveniente para los lenguajes de programacion que utilizan NUL para
    terminar cadenas.

#     Go source files are always encoded in UTF-8, and UTF-8 is the preferred
#     encoding for text strings manipulated by Go programs. The @c(unicode)
#     package provides functions for working with individual runes (such as
#     distinguishing letters from numbers, or converting an uppercase letter to a
#     lower-case one), and the @c(unicode/utf8) package provides functions for
#     encoding and decoding runes as bytes using UTF-8.
    Los archivos de codigo fuente de Go siempre estan codificados en UTF-8 y
    UTF-8 es la codificacion preferida para las cadenas de texto manipuladas por
    los programas Go. El paquete @c(unicode) proporciona funciones para trabajar
    con runas individuales (como distinguir letras de numeros, o la conversion
    de una letra mayuscula a una minuscula), y el paquete @c(unicode/utf8)
    proporciona funciones para codificar y decodificar runas como bytes usando
    UTF-8.

#     Many Unicode characters are hard to type on a keyboard or to distinguish
#     visually from similar-looking ones; some are even invisible. Unicode escapes
#     in Go string literals allow us to specify them by their numeric code point
#     value. There are two forms, @c(\u)@e(hhhh) for a 16-bit value and @c(\U)@e(hhhhhhhh)
#     for a 32-bit value, where each @e(h) is a hexadecimal digit; the need for the
#     32-bit form arises very infrequently. Each denotes the UTF-8 encoding of the
#     specified code point. Thus, for example, the following string literals all
#     represent the same six-byte string:
    Muchos caracteres Unicode son dificiles de escribir en un teclado o
    distinguir visualmente de otros de similar aspecto; Algunos son incluso
    invisibles. Go nos permite el escape de literales Unicode en una cadena Go
    al especificarlos por su valor numerico. Hay dos formas, @c(\u)@e(hhhh) para
    un valor de 16 bits y @c(\U)@e(hhhhhhhh) para un valor de 32 bits, donde
    cada @e(h) es un digito hexadecimal; La necesidad de la forma de 32 bits se
    presenta con poca frecuencia. Cada uno denota la codificacion UTF-8 del
    punto de codigo especificado. Asi, por ejemplo, los siguientes literales de
    cadena representan la misma cadena de seis bytes:

#     ..src > go
#       "世界"
#       "\xe4\xb8\x96\xe7\x95\x8c"
#       "\u4e16\u754c"
#       "\U00004e16\U0000754c"
#     < src..
    ..src > go
      "世界"
      "\xe4\xb8\x96\xe7\x95\x8c"
      "\u4e16\u754c"
      "\U00004e16\U0000754c"
    < src..

#     The three escape sequences above provide alternative notations for the first
#     string, but the values they denote are identical.  Unicode escapes may also
#     be used in rune literals. These three literals are equivalent:
    Las tres secuencias de escape anteriores proporcionan notaciones
    alternativas para la primera cadena, pero los valores que denotan son
    identicos. Los escapes Unicode tambien se puede utilizar en runas
    literales. Estos tres literales son equivalentes:

#     ..pre >
#       '世' '\u4e16' '\U00004e16'
    ..pre >
      '世' '\u4e16' '\U00004e16'

#     A rune whose value is less than 256 may be written with a single hexadecimal
#     escape, such as @c('\x41') for @c('A'), but for higher values, a @c(\u) or
#     @c(\U) escape must be used. Consequently, @c('\xe4\xb8\x96') is not a legal
#     rune literal, even though those three bytes are a valid UTF-8 encoding of a
#     single code point.
    Una runa cuyo valor es menor que 256 se puede escribir con una sola de
    escape hexadecimal, por ejemplo @c('\x41') para @c('A'), pero para los
    valores mas altos, debe utilizar un @c(\u) o @c(\U) de escape. En
    consecuencia, @c('\xe4\xb8\x96') no es una runa literal legal, a pesar de
    que esos tres bytes son un UTF-8 valido de un unico punto de codigo.

#     Thanks to the nice properties of UTF-8, many string operations don’t require
#     decoding. We can test whether one string contains another as a prefix:
    Gracias a las buenas propiedades de UTF-8, muchas operaciones de cadena no
    requieren decodificacion. Podemos probar si una cadena contiene otra como
    prefijo:

#     ..src > go
#       func HasPrefix(s, prefix string) bool {
#         return len(s) >= len(prefix) && s[:len(prefix)] == prefix
#       }
#     < src..
    ..src > go
      func HasPrefix(s, prefix string) bool {
        return len(s) >= len(prefix) && s[:len(prefix)] == prefix
      }
    < src..

#     or as a suffix:
    O como sufijo:

#     ..src > go
#       func HasSuffix(s, suffix string) bool {
#         return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
#       }
#     < src..
    ..src > go
      func HasSuffix(s, suffix string) bool {
        return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
      }
    < src..

#     or as a substring:
    O como una subcadena:

#     ..src > go
#       func Contains(s, substr string) bool {
#         for i := 0; i < len(s); i++ {
#           if HasPrefix(s[i:], substr) {
#             return true
#           }
#         }
#         return false
#       }
#     < src..
    ..src > go
      func Contains(s, substr string) bool {
        for i := 0; i < len(s); i++ {
          if HasPrefix(s[i:], substr) {
            return true
          }
        }
        return false
      }
    < src..

#     using the same logic for UTF-8-encoded text as for raw bytes. This is not
#     true for other encodings. (The functions above are drawn from the @c(strings)
#     package, though its implementation of @c(Contains) uses a hashing technique to
#     search more efficiently.)
    Utilizando la misma logica para un texto codificado en UTF-8 como para bytes
    sin procesar. Esto no es cierto para otras codificaciones. (Las funciones
    anteriores se han extraido del paquete @c(strings), aunque su implementacion
    de @c(Contains) utiliza una tecnica de hash para buscar de manera mas
    eficiente.)

#     On the other hand, if we really care about the individual Unicode
#     characters, we have to use other mechanisms. Consider the string from our
#     very first example, which includes two East Asian characters. Figure 3.5
#     illustrates its representation in memory. The string contains 13 bytes,
#     but interpreted as UTF-8, it encodes only nine code points or runes:
    Por otro lado, si realmente nos preocupamos por los caracteres Unicode
    individuales, tenemos que usar otros mecanismos. Consideremos la cadena de
    nuestro primer ejemplo, la cual incluye dos caracteres asiaticos. La Figura
    3.5 ilustra su representacion en la memoria. La cadena contiene 13 bytes,
    pero interpretada como UTF-8, codifica solo nueve puntos de codigo o runas:

#     ..src > go
#       import "unicode/utf8"
#
#       s := "Hello, 世界"
#       fmt.Println(len(s))                    // "13"
#       fmt.Println(utf8.RuneCountInString(s)) // "9"
#     < src..
    ..src > go
      import "unicode/utf8"

      s := "Hello, 世界"
      fmt.Println(len(s))                    // "13"
      fmt.Println(utf8.RuneCountInString(s)) // "9"
    < src..

#     To process those characters, we need a UTF-8 decoder. The @c(unicode/utf8)
#     package provides one that we can use like this:
    Para procesar esos caracteres, necesitamos un decodificador UTF-8. El
    paquete @c(unicode/utf8) proporciona uno que podemos utilizar de la
    siguiente manera:

#     ..src > go
#       for i := 0; i < len(s); {
#         r, size := utf8.DecodeRuneInString(s[i:])
#         fmt.Printf("%d\t%c\n", i, r)
#         i += size
#       }
#     < src..
    ..src > go
      for i := 0; i < len(s); {
        r, size := utf8.DecodeRuneInString(s[i:])
        fmt.Printf("%d\t%c\n", i, r)
        i += size
      }
    < src..

#     Each call to @c(DecodeRuneInString) returns @c(r), the rune itself, and
#     @c(size), the number of bytes occupied by the UTF-8 encoding of @c(r). The
#     size is used to update the byte index @c(i) of the next rune in the
#     string. But this is clumsy, and we need loops of this kind all the
#     time. Fortunately, Go’s @c(range) loop, when applied to a string, performs
#     UTF-8 decoding implicitly. The output of the loop below is also shown in
#     Figure 3.5; notice how the index jumps by more than 1 for each non-ASCII
#     rune.
    Cada llamada a @c(DecodeRuneInString) regresa @c(r), la runa en si, y
    @c(size), el numero de bytes ocupados por la codificacion UTF-8 de @c(r). El
    tamaño se utiliza para actualizar el indice del byte @c(i) de la siguiente
    runa en la cadena. Pero esto es torpe, y necesitamos bucles de este tipo
    todo el tiempo. Afortunadamente, Go tiene los bucles @c(range), cuando se
    aplica a una cadena, realiza decodificacion UTF-8 de forma implicita. La
    salida del bucle de siguiente se muestra en la Figura 3.5; Observe como el
    indice salta en mas de 1 para cada runa no ASCII.

#     ..src > go
#       for i, r := range "Hello, 世界" {
#         fmt.Printf("%d\t%q\t%d\n", i, r, r)
#       }
#     < src..
    ..src > go
      for i, r := range "Hello, 世界" {
        fmt.Printf("%d\t%q\t%d\n", i, r, r)
      }
    < src..

#     ..figure > Figure 3.5. A @c(range) loop decodes a UTF-8-encoded string.
    ..figure > Figura 3.5. Un bucle @c(range) descodifica una cadena UTF-8-codificado.

#       ..img  > img/Figure-3.5.jpg
      ..img  > img/Figure-3.5.jpg


#     We could use a simple @c(range) loop to count the number of runes in a string,
#     like this:
    Podriamos usar un simple bucle @c(range) para contar el numero de runas en
    una cadena, como aqui:

#     ..src > go
#       n := 0
#       for _, _ = range s {
#         n++
#       }
#     < src..
    ..src > go
      n := 0
      for _, _ = range s {
        n++
      }
    < src..

#     As with the other forms of @c(range) loop, we can omit the variables we
#     don’t need:
    Al igual que con las otras formas de bucle @c(range), podemos omitir las
    variables que no necesitamos:

#     ..src > go
#       n := 0
#       for range s {
#         n++
#       }
#     < src..
    ..src > go
      n := 0
      for range s {
        n++
      }
    < src..

#     Or we can just call @c[utf8.RuneCountInString(s)].
    O podemos simplemente llamar a @c[utf8.RuneCountInString(s)].

#     We mentioned earlier that it is mostly a matter of convention in Go that
#     text strings are interpreted as UTF-8-encoded sequences of Unicode code
#     points, but for correct use of @c(range) loops on strings, it’s more than a
#     convention, it’s a necessity. What happens if we range over a string
#     containing arbitrary binary data or, for that matter, UTF-8 data containing
#     errors?
    Ya hemos mencionado que es sobre todo una cuestion de convencion en Go que
    las cadenas de texto se interpretan como secuencias codificadas en UTF-8 de
    puntos de codigo Unicode, pero para el uso correcto de bucles @c(range) de
    cadenas, es mas que una convencion, es una necesidad. ¿Que sucede si
    aplicamos @c(range) en cadena que contiene datos binarios arbitrarios o, de
    hecho, datos UTF-8 que contienen errores?

#     Each time a UTF-8 decoder, whether explicit in a call to
#     @c(utf8.DecodeRuneInString) or implicit in a @c(range) loop, consumes an
#     unexpected input byte, it generates a special Unicode @e(replacement
#     character), @c('\uFFFD'), which is usually printed as a white question mark
#     inside a black hexagonal or diamond-like shape �. When a program encounters
#     this rune value, it’s often a sign that some upstream part of the system
#     that generated the string data has been careless in its treatment of text
#     encodings.
    Cada vez que un decodificador UTF-8, ya sea explicito en una llamada a
    @c(utf8.DecodeRuneInString) o implicito en un bucle @c(range), consume un
    byte de entrada inesperado, se genera un caracter Unicode de reemplazo
    especial, @c('\uFFFD'), que generalmente se impreme como un signo de
    interrogacion dentro de una forma hexagonal o un diamante negro �. Cuando un
    programa encuentra este valor de runa, a menudo es un signo de que parte del
    sistema que genero los datos de cadena ha sido descuidado en su tratamiento
    de las codificaciones de texto.

#     UTF-8 is exceptionally convenient as an interchange format but within a
#     program runes may be more convenient because they are of uniform size and
#     are thus easily indexed in arrays and slices.
    UTF-8 es excepcionalmente conveniente como un formato de intercambio, pero
    dentro de un programa las runas puede ser mas conveniente porque son de
    tamaño uniforme y por lo tanto, de facil indexado en arreglos y slices.

#     A @c([]rune) conversion applied to a UTF-8-encoded string returns the
#     sequence of Unicode code points that the string encodes:
    Una conversion @c([]rune) aplicada a una cadena codificada en UTF-8 devuelve la
    secuencia de codigos Unicode:

#     ..src > go
#       // "program" in Japanese katakana
#       s := "プログラム"
#       fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
#       r := []rune(s)
#       fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
#     < src..
    ..src > go
      // "programa" en katakana
      s := "プログラム"
      fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
      r := []rune(s)
      fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
    < src..

#     (The verb @c(% x) in the first @c(Printf) inserts a space between each pair
#     of hex digits.)
    (El verbo @c(% x) en el primer @c(Printf) inserta un espacio entre cada par
    de digitos hexadecimales.)

#     If a slice of runes is converted to a string, it produces the concatenation
#     of the UTF-8 encodings of each rune:
    Si un slice de runas se convierte en una cadena, produce la concatenacion de
    las codificaciones UTF-8 de cada runa:

#     ..src > go
#       fmt.Println(string(r)) // "プログラム"
#     < src..
    ..src > go
      fmt.Println(string(r)) // "プログラム"
    < src..

#     Converting an integer value to a string interprets the integer as a rune
#     value, and yields the UTF-8 representation of that rune:
    Convertir un valor entero en una cadena interpre el entero como un valor
    de runa, y produce la representacion UTF-8 de esa runa:

#     ..src > go
#       UTF-8 representation of that rune:
#       fmt.Println(string(65))     // "A", not "65"
#       fmt.Println(string(0x4eac)) // "京"
#     < src..
    ..src > go
      fmt.Println(string(65))     // "A", not "65"
      fmt.Println(string(0x4eac)) // "京"
    < src..

#     If the rune is invalid, the replacement character is substituted:
    Si la runa no es valida, se reemplasa por el caracter de sustitucion:

#     ..src > go
#       fmt.Println(string(1234567)) // "�"
#     < src..
    ..src > go
      fmt.Println(string(1234567)) // "�"
    < src..

# *** Section 3.5.4 <> Strings and Byte Slices
*** Seccion 3.5.4 <> Cadenas y Slices de Bytes

#     Four standard packages are particularly important for manipulating strings:
#     @c(bytes), @c(strings), @c(strconv), and @c(unicode). The @c(string) spackage
#     provides many functions for searching, replacing, comparing, trimming,
#     splitting, and joining strings.
    cuatro paquetes estandar son particularmente importantes para la
    manipulacion de cadenas: @c(bytes), @c(strings), @c(strconv) y
    @c(unicode). El paquete @c(strings) ofrece muchas funciones para busqueda,
    reemplazo, comparacion, recorte, division, y union en cadenas.

#     The @c(bytes) package has similar functions for manipulating slices of
#     bytes, of type @c([]byte), which share some properties with strings. Because
#     strings are immutable, building up strings incrementally can involve a lot
#     of allocation and copying. In such cases, it’s more efficient to use the
#     @c(bytes.Buffer) type, which we’ll show in a moment.
    El paquete @c(bytes) tiene funciones similares para manipular slices de
    bytes, de tipo @c([]byte), que comparten algunas propiedades con
    @c(strings). Debido a que las cadenas son inmutables, la construccion de
    cadenas de forma incremental puede implicar una gran cantidad de asignacion
    y copiado. En tales casos, es mas eficaz utilizar el tipo @c(bytes.Buffer),
    que vamos a mostrar en un momento.

#     The @c(strconv) package provides functions for converting boolean, integer,
#     and floating-point values to and from their string representations, and
#     functions for quoting and unquoting strings.
    El paquete @c(strconv) proporciona funciones para convertir booleanos,
    enteros, y valores de coma flotante hacia y desde sus representaciones en
    cadenas, y funciones para citar y des-citar cadenas.

#     The @c(unicode) package provides functions like @c(IsDigit), @c(IsLetter),
#     @c(IsUpper), and @c(IsLower) for classifying runes. Each function takes a
#     single rune argument and returns a boolean. Conversion functions like
#     @c(ToUpper) and @c(ToLower) convert a rune into the given case if it is a
#     letter. All these functions use the Unicode standard categories for letters,
#     digits, and so on. The @c(strings) package has similar functions, also
#     called @c(ToUpper) and @c(ToLower), that return a new string with the
#     specified transformation applied to each character of the original string.
    El paquete @c(unicode) proporciona funciones como @c(IsDigit), @c(IsLetter),
    @c(IsUpper) y @c(IsLower) para la clasificacion de runas. Cada funcion toma
    un unico argumento de tipo runa y devuelve un booleano. Las funciones de
    conversion como @c(ToUpper) y @c(ToLower) convierten una runa en el caso
    concreto si se trata de una letra. Todas estas funciones utilizan las
    categorias estandar de Unicode para las letras, los digitos, etc. El paquete
    @c(strings) tiene funciones similares, tambien llamadas @c(ToUpper) y
    @c(ToLower), que devuelven una nueva cadena con la transformacion
    especificada aplicada a cada caracter de la cadena original.

#     The @c(basename) function below was inspired by the Unix shell utility of
#     the same name. In our version, @c(basename)(s) removes any prefix of s that
#     looks like a file system path with components separated by slashes, and it
#     removes any suffix that looks like a file type:
    La siguiente funcion @c(basename) se inspiro en la utilidad de shell Unix
    del mismo nombre. En nuestra version, @c[basename(s)] elimina cualquier
    prefijo de @c(s) que paresca una ruta de sistema con componentes separados
    por barras, y elimina cualquier sufijo que se parece a un tipo de archivo:

#     ..src > go
#       fmt.Println(basename("a/b/c.go")) // "c"
#       fmt.Println(basename("c.d.go"))   // "c.d"
#       fmt.Println(basename("abc"))      // "abc"
#     < src..
    ..src > go
      fmt.Println(basename("a/b/c.go")) // "c"
      fmt.Println(basename("c.d.go"))   // "c.d"
      fmt.Println(basename("abc"))      // "abc"
    < src..

#     The first version of @c(basename) does all the work without the help of
#     libraries:
    La primer version de basename hace todo el trabajo sin la ayuda de
    librerias:

#     ..figure > @l(gopl.io/ch3/basename1/main.go<>gopl.io/ch3/basename1)
    ..figure > @l(gopl.io/ch3/basename1/main.go<>gopl.io/ch3/basename1)

#       ..src > go
#         // basename removes directory components and a .suffix.
#         // e.g., a => a, a.go => a, a/b/c.go => c, a/b.c.go => b.c
#         func basename(s string) string {
#           // Discard last '/' and everything before.
#           for i := len(s) - 1; i >= 0; i-- {
#             if s[i] == '/' {
#               s = s[i+1:]
#               break
#             }
#           }
#           // Preserve everything before last '.'.
#           for i := len(s) - 1; i >= 0; i-- {
#             if s[i] == '.' {
#               s = s[:i]
#               break
#             }
#           }
#           return s
#         }
#       < src..
      ..src > go
        // basename elimina los .subfijos y componentes de directorios.
        // e.g., a => a, a.go => a, a/b/c.go => c, a/b.c.go => b.c
        func basename(s string) string {
          // Descarta el ultimo '/' y todo lo anterior.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '/' {
              s = s[i+1:]
              break
            }
          }
          // Conserva todo antes del ultimo '.'.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '.' {
              s = s[:i]
              break
            }
          }
          return s
        }
      < src..


#     A simpler version uses the @c(strings.LastIndex) library function:
    Una version mas simple utiliza la funcion de libreria @c(strings.LastIndex):

#     ..figure > @l(gopl.io/ch3/basename2/main.go<>gopl.io/ch3/basename2)
    ..figure > @l(gopl.io/ch3/basename2/main.go<>gopl.io/ch3/basename2)

#       ..src > go
#         func basename(s string) string {
#           slash := strings.LastIndex(s, "/") // -1 if "/" not found
#           s = s[slash+1:]
#           if dot := strings.LastIndex(s, "."); dot >= 0 {
#             s = s[:dot]
#           }
#           return s
#         }
#       < src..
      ..src > go
        func basename(s string) string {
          slash := strings.LastIndex(s, "/") // -1 si no se encuentra "/"
          s = s[slash+1:]
          if dot := strings.LastIndex(s, "."); dot >= 0 {
            s = s[:dot]
          }
          return s
        }
      < src..


#     The @c(path) and @c(path/filepath) packages provide a more general set of
#     functions for manipulating hierarchical names. The @c(path) package works
#     with slash-delimited paths on any platform. It shouldn’t be used for file
#     names, but it is appropriate for other domains, like the path component of a
#     URL. By contrast, @c(path/filepath) manipulates file names using the rules
#     for the host platform, such as @c(/foo/bar) for POSIX or @c(c:\foo\bar) on
#     Microsoft Windows.
    Los paquetes @c(path) y @c(path/filepath) proporcionan un conjunto general
    de funciones para manipular nombres jerarquicos. El paquete @c(path)
    funciona con rutas delimitada por barras en cualquier plataforma. No se debe
    utilizar para nombres de archivo, pero es apropiado para otros dominios,
    como los componente de ruta de una URL. Por el contrario, @c(path/filepath)
    manipula los nombres de archivos usando las reglas para la plataforma
    huesped, tales como @c(/foo/bar) para POSIX o @c(c:\foo\bar) en Microsoft
    Windows.

#     Let’s continue with another substring example. The task is to take a string
#     representation of an integer, such as @c("12345"), and insert commas every
#     three places, as in @c("12,345"). This version only works for integers;
#     handling floating-point numbers is left as a exercise.
    Vamos a continuar con otro ejemplo de subcadena. La tarea es tomar una
    representacion de cadena de un entero, como @c("12345"), e insertar comas
    cada tres posiciones, como en @c("12,345") . Esta version solo funciona para
    enteros; El manejo de numeros de coma flotante se deja como un ejercicio.

#     ..figure > @l(gopl.io/ch3/comma/main.go<>gopl.io/ch3/comma)
    ..figure > @l(gopl.io/ch3/comma/main.go<>gopl.io/ch3/comma)

#       ..src > go
#         // comma inserts commas in a non-negative decimal integer string.
#         func comma(s string) string {
#           n := len(s)
#           if n <= 3 {
#             return s
#           }
#           return comma(s[:n-3]) + "," + s[n-3:]
#         }
#       < src..
      ..src > go
        // comma inserta comas en una cadena de numeros enteros decimales negativos.
        func comma(s string) string {
          n := len(s)
          if n <= 3 {
            return s
          }
          return comma(s[:n-3]) + "," + s[n-3:]
        }
      < src..


#     The argument to @c(comma) is a string. If its length is less than or equal
#     to 3, no comma is necessary. Otherwise, @c(comma) calls itself recursively
#     with a substring consisting of all but the last three characters, and
#     appends a comma and the last three characters to the result of the recursive
#     call.
    El argumento de @c(comma) es una cadena. Si su longitud es menor o igual a
    3, no es necesaria una coma. De lo contrario, comma se llama a si misma de
    forma recursiva con una subcadena formada por todos menos los tres ultimos
    caracteres, y añåde una coma y los tres ultimos caracteres en el resultado
    de la llamada recursiva.

#     A string contains an array of bytes that, once created, is immutable. By
#     contrast, the elements of a byte slice can be freely modified.
    Una cadena contiene un arreglo de bytes que, una vez creado, es
    inmutable. Por el contrario, los elementos de una slice de bytes se pueden
    modificar libremente.

#     Strings can be converted to byte slices and back again:
    Las cadenas se pueden convertir en slices de bytes y viceversa:

#     ..src > go
#       s := "abc"
#       b := []byte(s)
#       s2 := string(b)
#     < src..
    ..src > go
      s := "abc"
      b := []byte(s)
      s2 := string(b)
    < src..

#     Conceptually, the @c{[]byte(s)} conversion allocates a new byte array
#     holding a copy of the bytes of @c(s), and yields a slice that references the
#     entirety of that array. An optimizing compiler may be able to avoid the
#     allocation and copying in some cases, but in general copying is required to
#     ensure that the bytes of @c(s) remain unchanged even if those of @c(b) are
#     subsequently modified. The conversion from byte slice back to string with
#     @c[string(b)] also makes a copy, to ensure immutability of the resulting
#     string @c(s2).
    Conceptualmente, la conversion @c{[]byte(s)} asigna un nuevo arreglo de
    bytes que guarda una copia de bytes de @c(s), y produce un slice que hace
    referencia a la totalidad del arreglo. Un compilador optimizado puede ser
    capaz de evitar la asignacion y la copia en algunos casos, pero en general,
    la copia es necesaria para asegurar que los bytes de @c(s) se mantienen sin
    cambios incluso si los de @c(b) son modificados posteriormente. La
    conversion de slice de byte de nuevo a cadena con @c[string(b)] tambien
    genera una copia, para asegurar inmutabilidad de la cadena resultante
    @c(s2).

#     To avoid conversions and unnecessary memory allocation, many of the utility
#     functions in the @c(bytes) package directly parallel their counterparts in
#     the @c(strings) package. For example, here are half a dozen functions from
#     @c(strings):
    Para evitar conversiones y asignacion de memoria innecesaria, muchas
    de las funciones de utilidad en el paquete @c(bytes) directamente paralelos a
    sus contrapartes en el paquete @c(strings). Por ejemplo, aqui hay una media
    docena de funciones en @c(strings):

#     ..src > go
#       func Contains(s, substr string) bool
#       func Count(s, sep string) int
#       func Fields(s string) []string
#       func HasPrefix(s, prefix string) bool
#       func Index(s, sep string) int
#       func Join(a []string, sep string) string
#     < src..
    ..src > go
      func Contains(s, substr string) bool
      func Count(s, sep string) int
      func Fields(s string) []string
      func HasPrefix(s, prefix string) bool
      func Index(s, sep string) int
      func Join(a []string, sep string) string
    < src..

#     and the corresponding ones from @c(bytes):
    y las correspondientes en bytes :

#     ..src > go
#       func Contains(b, subslice []byte) bool
#       func Count(s, sep []byte) int
#       func Fields(s []byte) [][]byte
#       func HasPrefix(s, prefix []byte) bool
#       func Index(s, sep []byte) int
#       func Join(s [][]byte, sep []byte) []byte
#     < src..
    ..src > go
      func Contains(b, subslice []byte) bool
      func Count(s, sep []byte) int
      func Fields(s []byte) [][]byte
      func HasPrefix(s, prefix []byte) bool
      func Index(s, sep []byte) int
      func Join(s [][]byte, sep []byte) []byte
    < src..

#     The only difference is that strings have been replaced by byte slices.
    La unica diferencia es que las cadenas han sido reemplazadas por slices de
    bytes.

#     The @c(bytes) package provides the @c(Buffer) type for efficient
#     manipulation of byte slices. A @c(Buffer) starts out empty but grows as data
#     of types like @c(string), @c(byte), and @c([]byte) are written to it. As the
#     example below shows, a @c(bytes.Buffer) variable requires no initialization
#     because its zero value is usable:
    El paquete @c(bytes) proporciona el tipo @c(Buffer) para la manipulacion
    eficiente de slices de @c(byte). Un @c(Buffer) comienza vacio, pero crece a
    medida que los datos de tipos como @c(string), @c(byte), y @c([]byte) se
    escriben en el. Como muestra el siguiente ejemplo, una variable
    @c(bytes.Buffer) no requiere inicializacion porque su valor cero es
    utilizable:

#     ..figure > @l(gopl.io/ch3/printints/main.go<>gopl.io/ch3/printints)
    ..figure > @l(gopl.io/ch3/printints/main.go<>gopl.io/ch3/printints)

#       ..src > go
#         // intsToString is like fmt.Sprint(values) but adds commas.
#         func intsToString(values []int) string {
#           var buf bytes.Buffer
#           buf.WriteByte('[')
#           for i, v := range values {
#             if i > 0 {
#               buf.WriteString(", ")
#             }
#             fmt.Fprintf(&buf, "%d", v)
#           }
#           buf.WriteByte(']')
#           return buf.String()
#         }
#
#         func main() {
#           fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
#         }
#       < src..
      ..src > go
        // intsToString es como fmt.Sprint(values) pero agrega comas.
        func intsToString(values []int) string {
          var buf bytes.Buffer
          buf.WriteByte('[')
          for i, v := range values {
            if i > 0 {
              buf.WriteString(", ")
            }
            fmt.Fprintf(&buf, "%d", v)
          }
          buf.WriteByte(']')
          return buf.String()
        }

        func main() {
          fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
        }
      < src..


#     When appending the UTF-8 encoding of an arbitrary rune to a
#     @c(bytes.Buffer), it’s best to use @c(bytes.Buffer)’s @c(WriteRune) method,
#     but @c(WriteByte) is fine for ASCII characters such as @c('[') and @c(']').
    Cuando se agrega la codificacion UTF-8 de un runa arbitraria a un
    @c(bytes.Buffer), lo mejor es utilizar el metodo @c(WriteRune) de
    @c(bytes.Buffer), pero @c(WriteByte) esta bien para caracteres ASCII como
    @c('[') y @c(']').

#     The @c(bytes.Buffer) type is extremely versatile, and when we discuss
#     interfaces in @l(#Chapter 7), we’ll see how it may be used as a replacement
#     for a file whenever an I/O function requires a sink for bytes
#     (@c(io.Writer)) as @c(Fprintf) does above, or a source of bytes
#     (@c(io.Reader)).
    El tipo @c(bytes.Buffer) es extremadamente versatil, y cuando hablemos de
    interfaces en el @l(#Capitulo 7), vamos a ver como se puede utilizar como un
    sustituto de un archivo cada vez que una funcion de E/S requiere un poso de
    bytes (@c(io.Writer)) como @c(Fprintf), o una fuente de bytes
    (@c(io.Reader)).

#     @b(Exercise 3.10): Write a non-recursive version of @c(comma), using
#     @c(bytes.Buffer) instead of string concatenation.
   @b(Ejercicio 3.10): Escribir una version no recursiva de @c(comma),
   utilizando @c(bytes.Buffer) en lugar de la concatenacion de cadenas.

#     @b(Exercise 3.11): Enhance @c(comma) so that it deals correctly with
#     floating-point numbers and an optional sign.
   @b(Ejercicio 3.11): Mejorar @c(comma) para que se maneje correctamente los
   numeros de punto flotante y un opcionalmente con signo.

#     @b(Exercise 3.12): Write a function that reports whether two strings are
#     anagrams of each other, that is, they contain the same letters in a
#     different order.
   @b(Ejercicio 3.12): Escribir una funcion que informa de si dos cadenas son
   anagramas entre si, es decir, que contienen las mismas letras en un orden
   diferente.

# *** Section 3.5.5 <> Conversions between Strings and Numbers
*** Seccion 3.5.5 <> Conversiones entre cadenas y numeros

#     In addition to conversions between strings, runes, and bytes, it’s often
#     necessary to convert between numeric values and their string
#     representations. This is done with functions from the @c(strconv) package.
    Ademas de las conversiones entre cadenas, runas y bytes, a menudo es
    necesario convertir entre valores numericos y sus representaciones de
    cadena. Esto se realiza con las funciones del paquete @c(strconv).

#     To convert an integer to a string, one option is to use @c(fmt.Sprintf);
#     another is to use the function @c(strconv.Itoa) (@"(integer to ASCII)):
    Para convertir un entero a una cadena, una opcion es utilizar @c(fmt.Sprintf);
    otra es utilizar la funcion @c(strconv.Itoa) (@"(entero a ASCII)):

#     ..src > go
#       x := 123
#       y := fmt.Sprintf("%d", x)
#       fmt.Println(y, strconv.Itoa(x)) // "123 123"
#     < src..
    ..src > go
      x := 123
      y := fmt.Sprintf("%d", x)
      fmt.Println(y, strconv.Itoa(x)) // "123 123"
    < src..

#     @c(FormatInt) and @c(FormatUint) can be used to format numbers in a
#     different base:
    @c(FormatInt) y @c(FormatUint) se pueden utilizar para dar formato a numeros
    en una base diferente:

#     ..src > go
#       fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
#     < src..
    ..src > go
      fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
    < src..

#     The @c(fmt.Printf) verbs @c(%b), @c(%d), @c(%u), and @c(%x) are often more
#     convenient than @c(Format) functions, especially if we want to include
#     additional information besides the number:
    Los verbos @c(%b), @c(%d), @c(%u) y @c(%x) de @c(fmt.Printf) a menudo son
    mas conveniente que las funciones @c(Format), sobre todo si queremos incluir
    informacion adicional ademas del numero:

#     ..src > go
#       s := fmt.Sprintf("x=%b", x) // "x=1111011"
#     < src..
    ..src > go
      s := fmt.Sprintf("x=%b", x) // "x=1111011"
    < src..

#     To parse a string representing an integer, use the @c(strconv) functions
#     @c(Atoi) or @c(ParseInt), or ParseUint for unsigned integers:
    Para analizar una cadena que representa un numero entero, utilice las
    funciones de @c(strconv) como @c(Atoi) o @c(ParseInt), o @c(ParseUint) para
    enteros sin signo:

#     ..src > go
#       x, err := strconv.Atoi("123")             // x is an int
#       y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
#     < src..
    ..src > go
      x, err := strconv.Atoi("123")             // x es un entero
      y, err := strconv.ParseInt("123", 10, 64) // base 10, hasta 64 bits
    < src..

#     The third argument of @c(ParseInt) gives the size of the integer type that
#     the result must fit into; for example, 16 implies @c(int16), and the special
#     value of 0 implies @c(int). In any case, the type of the result y is always
#     @c(int64), which you can then convert to a smaller type.
    El tercer argumento de @c(ParseInt) da el tamaño del tipo de entero que debe
    ser el resultado; por ejemplo, 16 implica @c(int16), y el valor especial 0
    implica @c(int) . En cualquier caso, el tipo del resultado @c(y) es siempre
    @c(int64), que luego se puede convertir a un tipo mas pequeño.

#     Sometimes @c(fmt.Scanf) is useful for parsing input that consists of orderly
#     mixtures of strings and numbers all on a single line, but it can be
#     inflexible, especially when handling incomplete or irregular input.
    A veces es util @c(fmt.Scanf) para el analisis de entrada que consta de
    mezclas ordenadas de cadenas y numeros todo en una sola linea, pero puede
    ser inflexible, especialmente cuando se maneja una entrada incompleta o
    irregular.

# ** Section 3.6 <> Constants
** Seccion 3.6 <> Constantes

#    Constants are expressions whose value is known to the compiler and whose
#    evaluation is guaranteed to occur at compile time, not at run time. The
#    underlying type of every constant is a basic type: boolean, string, or
#    number.
   Las constantes son expresiones cuyo valor es conocido por el compilador y
   cuya evaluacion se garantiza que se produzca en tiempo de compilacion, no en
   tiempo de ejecucion. El tipo subyacente de cada constante es un tipo basico:
   booleano, cadena o numero.

#    A @c(const) declaration defines named values that look syntactically like
#    variables but whose value is constant, which prevents accidental (or
#    nefarious) changes during program execution.  For instance, a constant is
#    more appropriate than a variable for a mathematical constant like @c(pi),
#    since its value won’t change:
   Una declaracion @c(const) define los valores que se ven sintacticamente como
   variables con nombre pero cuyo valor es constante, lo que evita cambios
   accidentales (o nefastos) durante la ejecucion del programa. Por ejemplo, una
   constante es mas apropiada que una variable para una constante matematica
   como @c(pi), ya que su valor no cambiara:

#    ..src > go
#      const pi = 3.14159 // approximately; math.Pi is a better approximation
#    < src..
   ..src > go
     const pi = 3.14159 // aproximadamente; math.Pi un una mejor aproximacion
   < src..

#    As with variables, a sequence of constants can appear in one declaration;
#    this would be appropriate for a group of related values:
   Al igual que con las variables, una secuencia de constantes puede aparecer en
   una declaracion; Esto seria apropiado para un grupo de valores relacionados:

#    ..src > go
#      const (
#        e  = 2.71828182845904523536028747135266249775724709369995957496696763
#        pi = 3.14159265358979323846264338327950288419716939937510582097494459
#      )
#    < src..
   ..src > go
     const (
       e  = 2.71828182845904523536028747135266249775724709369995957496696763
       pi = 3.14159265358979323846264338327950288419716939937510582097494459
     )
   < src..

#    Many computations on constants can be completely evaluated at compile time,
#    reducing the work necessary at run time and enabling other compiler
#    optimizations. Errors ordinarily detected at run time can be reported at
#    compile time when their operands are constants, such as integer division by
#    zero, string indexing out of bounds, and any floating-point operation that
#    would result in a non-finite value.
   Muchos calculos de constantes pueden evaluarse completamente en tiempo de
   compilacion, reduciendo el trabajo necesario en tiempo de ejecucion y
   habilitando otras optimizaciones de compilador. Los errores ordinariamente
   detectados en tiempo de ejecucion pueden ser reportados en tiempo de
   compilacion cuando sus operandos son constantes, como la division entera por
   cero, una cadena de indexacion fuera de limites y cualquier operacion de
   punto flotante que daria lugar a un valor no finito.

#    The results of all arithmetic, logical, and comparison operations applied to
#    constant operands are themselves constants, as are the results of conversions
#    and calls to certain built-in functions such as @c(len), @c(cap), @c(real),
#    @c(imag), @c(complex), and @c(unsafe.Sizeof) (@l(#Section 13.1<>§13.1)).
   Los resultados de toda la aritmetica, y operaciones de comparacion logicos
   aplicados a operandos constantes son en si mismas constantes, como son los
   resultados de las conversiones y las llamadas a ciertas funciones nativas
   como @c(len), @c(cap), @c(real), @c(imag), @c(complex), y @c(unsafe.Sizeof)
   (@l(#Seccion 13.1<>§13.1)).

#    Since their values are known to the compiler, constant expressions may appear
#    in types, specifically as the length of an array type:
   Ya que sus valores son conocidos por el compilador, las expresiones
   constantes pueden aparecer en los tipos, especificamente como la longitud de
   un tipo de arreglo:

#    ..src > go
#      const IPv4Len = 4
#
#      // parseIPv4 parses an IPv4 address (d.d.d.d).
#      func parseIPv4(s string) IP {
#        var p [IPv4Len]byte
#        // ...
#      }
#    < src..
   ..src > go
     const IPv4Len = 4

     // parseIPv4 analiza una direccion IPv4 (d.d.d.d).
     func parseIPv4(s string) IP {
       var p [IPv4Len]byte
       // ...
     }
   < src..

#    A constant declaration may specify a type as well as a value, but in the
#    absence of an explicit type, the type is inferred from the expression on the
#    right-hand side. In the following, @c(time.Duration) is a named type whose
#    underlying type is @c(int64), and @c(time.Minute) is a constant of that
#    type. Both of the constants declared below thus have the type
#    @c(time.Duration) as well, as revealed by @c(%T):
   Una declaracion constante puede especificar un tipo como un valor, pero en
   ausencia de un tipo explicito, el tipo se infiere de la expresion en el lado
   derecho. En el siguiente ejemplo, @c(time.Duration) es un tipo con nombre
   cuyo tipo subyacente es @c(int64), y @c(time.Minute) es una constante de ese
   tipo. Por lo tanto las dos constantes declaradas a continuacion tienen el
   tipo @c(time.Duration), como lo revela @c(%T):

#    ..src > go
#      const noDelay time.Duration = 0
#      const timeout = 5 * time.Minute
#
#      fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
#      fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s
#      fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
#    < src..
   ..src > go
     const noDelay time.Duration = 0
     const timeout = 5 * time.Minute

     fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
     fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s
     fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
   < src..

#    When a sequence of constants is declared as a group, the right-hand side
#    expression may be omitted for all but the first of the group, implying that
#    the previous expression and its type should be used again. For example:
   Cuando una secuencia de constantes se declara como un grupo, la expresion del
   lado derecho se puede omitir para todas excepto para la primera del grupo, lo
   que implica que la expresion anterior y su tipo deben ser utilizados de
   nuevo. Por ejemplo:

#    ..src > go
#      const (
#        a = 1
#        b
#        c = 2
#        d
#      )
#
#      fmt.Println(a, b, c, d) // "1 1 2 2"
#    < src..
   ..src > go
     const (
       a = 1
       b
       c = 2
       d
     )

     fmt.Println(a, b, c, d) // "1 1 2 2"
   < src..

#    This is not very useful if the implicitly copied right-hand side expression
#    always evaluates to the same thing. But what if it could vary? This brings us
#    to @c(iota).
   Esto no es muy util si la expresion del lado derecho implicitamente copiada
   se evalua siempre con el mismo valor. Pero, ¿y si pudiera variar? Esto nos
   lleva a @c(iota).

# *** Section 3.6.1 <> The Constant Generator @c(iota)
*** Seccion 3.6.1 <> El Generador Constante @c(iota)

#     A @c(const) declaration may use the @e(constant generator) @c(iota), which
#     is used to create a sequence of related values without spelling out each one
#     explicitly. In a @c(const) declaration, the value of @c(iota) begins at zero
#     and increments by one for each item in the sequence.
    Una declaracion @c(const) puede utilizar el generador de constante @c(iota),
    que se utiliza para crear una secuencia de valores relacionados sin escribir
    cada uno de forma explicita. En una declaracion @c(const), el valor de
    @c(iota) comienza en cero y se incrementa en uno en cada elemento de la
    secuencia.

#     Here’s an example from the @c(time) package, which defines named constants
#     of type @c(Weekday) for the days of the week, starting with zero for
#     @c(Sunday). Types of this kind are often called @e(enumerations), or
#     @e(enums) for short.
    He aqui un ejemplo del paquete @c(time), que define constantes de tipo
    @c(Weekday) de los dias de la semana, a partir de cero para @c(Sunday).
    Tipos de esta clase a menudo se conocen como @e(enumeraciones), o @e(enums),
    para abreviar.

#     ..src > go
#       type Weekday int
#
#       const (
#         Sunday Weekday = iota
#         Monday
#         Tuesday
#         Wednesday
#         Thursday
#         Friday
#         Saturday
#       )
#     < src..
    ..src > go
      type Weekday int

      const (
        Sunday Weekday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
      )
    < src..

#     This declares @c(Sunday) to be 0, @c(Monday) to be 1, and so on.
    Esto declara que @c(Sunday) debe ser 0, @c(Monday) debe ser 1, y asi
    sucesivamente.

#     We can use @c(iota) in more complex expressions too, as in this example from
#     the @c(net) package where each of the lowest 5 bits of an unsigned integer
#     is given a distinct name and boolean interpretation:
    Podemos utilizar @c(iota) en expresiones mas complejas, como en este ejemplo
    del paquete @c(net) en el que se le da a cada uno de los 5 bits mas bajos de
    un entero sin signo un nombre distinto e interpretacion booleana:

#     ..src > go
#       type Flags uint
#
#       const (
#         FlagUp Flags = 1 << iota // is up
#         FlagBroadcast            // supports broadcast access capability
#         FlagLoopback             // is a loopback interface
#         FlagPointToPoint         // belongs to a point-to-point link
#         FlagMulticast            // supports multicast access capability
#       )
#     < src..
    ..src > go
      type Flags uint

      const (
        FlagUp Flags = 1 << iota // esta arriba
        FlagBroadcast            // soporta acceso broadcast
        FlagLoopback             // es una interface loopback
        FlagPointToPoint         // pertenece a un enlace punto-a-punto
        FlagMulticast            // soporta acceso multicast
      )
    < src..

#     As @c(iota) increments, each constant is assigned the value of @c(1 <<
#     iota), which evaluates to successive powers of two, each corresponding to a
#     single bit. We can use these constants within functions that test, set, or
#     clear one or more of these bits:
    Como @c(iota) incrementa, a cada constante se le asigna el valor de @c(1 <<
    iota), que evalua a potencias consecutivas de dos, cada un corresponde a un
    solo bit. Podemos utilizar estas constantes dentro de funciones que prueban,
    establecen o borran uno o mas de estos bits:

#     ..figure > @l(gopl.io/ch3/netflag/netflag.go<>gopl.io/ch3/netflag)
    ..figure > @l(gopl.io/ch3/netflag/netflag.go<>gopl.io/ch3/netflag)

#       ..src > go
#         func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
#         func TurnDown(v *Flags)     { *v &^= FlagUp }
#         func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
#         func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }
#
#         func main() {
#           var v Flags = FlagMulticast | FlagUp
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10001 true"
#           TurnDown(&v)
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10000 false"
#           SetBroadcast(&v)
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
#           fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
#         }
#       < src..
      ..src > go
        func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
        func TurnDown(v *Flags)     { *v &^= FlagUp }
        func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
        func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }

        func main() {
          var v Flags = FlagMulticast | FlagUp
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10001 true"
          TurnDown(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10000 false"
          SetBroadcast(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
          fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
        }
      < src..


#     As a more complex example of @c(iota), this declaration names the powers of
#     1024:
    Como un ejemplo mas complejo de @c(iota), esta declaracion nombra las
    potencias de 1024:

#     ..src > go
#       const (
#         _ = 1 << (10 * iota)
#         KiB // 1024
#         MiB // 1048576
#         GiB // 1073741824
#         TiB // 1099511627776              (exceeds 1 << 32)
#         PiB // 1125899906842624
#         EiB // 1152921504606846976
#         ZiB // 1180591620717411303424     (exceeds 1 << 64)
#         YiB // 1208925819614629174706176
#       )
#     < src..
    ..src > go
      const (
        _ = 1 << (10 * iota)
        KiB // 1024
        MiB // 1048576
        GiB // 1073741824
        TiB // 1099511627776              (exede 1 << 32)
        PiB // 1125899906842624
        EiB // 1152921504606846976
        ZiB // 1180591620717411303424     (exede 1 << 64)
        YiB // 1208925819614629174706176
      )
    < src..

#     The @c(iota) mechanism has its limits. For example, it’s not possible to
#     generate the more familiar powers of 1000 (KB, MB, and so on) because there
#     is no exponentiation operator.
    El mecanismo @c(iota) tiene sus limites. Por ejemplo, no es posible generar
    las potencias mas familiares de 1000 (KB, MB, etc.) porque no hay un
    operador de exponenciacion.

#     @b(Exercise 3.13): Write @c(const) declarations for KB, MB, up through YB as
#     compactly as you can.
   @b(Ejercicio 3.13): Escribir declaraciones @c(const) para KB, MB, hasta YB lo
   mas compacto como sea posible.

# *** Section 3.6.2 <> Untyped Constants
*** Seccion 3.6.2 <> Constantes Sin Tipo

#     Constants in Go are a bit unusual. Although a constant can have any of the
#     basic data types like @c(int) or @c(float64), including named basic types
#     like @c(time.Duration), many constants are not committed to a particular
#     type. The compiler represents these uncommitted constants with much greater
#     numeric precision than values of basic types, and arithmetic on them is more
#     precise than machine arithmetic; you may assume at least 256 bits of
#     precision. There are six flavors of these uncommitted constants, called
#     @e(untyped) boolean, untyped integer, untyped rune, untyped floating-point,
#     untyped complex, and untyped string.
    Las constantes en Go son un poco inusuales. Aunque una constante puede tener
    cualquiera de los tipos de datos basicos como @c(int) o @c(float64),
    incluyendo tipos basicos con nombre como @c(time.Duration), muchas
    constantes no estan comprometidas con un tipo particular. El compilador
    representa estas constantes no comprometidas con una precision numerica
    mucho mayor que los valores de tipos basicos, y la aritmetica en ellas es
    mas precisa que la aritmetica de la maquina; Puede suponer al menos 256 bits
    de precision. Hay seis sabores de estas constantes no comprometidos, llamado
    booleanos @e(sin tipo), enteros sin tipo, runas sin tipo, punto flotante sin
    tipo, complejos sin tipo y cadenas sin tipo.

#     By deferring this commitment, untyped constants not only retain their higher
#     precision until later, but they can participate in many more expressions
#     than committed constants without requiring conversions. For example, the
#     values @c(ZiB) and @c(YiB) in the example above are too big to store in any
#     integer variable, but they are legitimate constants that may be used in
#     expressions like this one:
    Al aplazar este compromiso, las constantes no tipificadas no solo conservan
    su mayor precision hasta mas tarde, sino que pueden participar en muchas mas
    expresiones que las constantes comprometidas sin requerir conversiones. Por
    ejemplo, los valores @c(ZiB) y @c(YiB) en el ejemplo anterior son demasiado
    grandes para almacenase en cualquier variable entera, pero son legitimas
    constantes que pueden utilizarse en las expresiones como esta:

#     ..src > go
#       fmt.Println(YiB/ZiB) // "1024"
#     < src..
    ..src > go
      fmt.Println(YiB/ZiB) // "1024"
    < src..

#     As another example, the floating-point constant @c(math.Pi) may be used
#     wherever any floatingpoint or complex value is needed:
    Como otro ejemplo, la constante de coma flotante @c(math.Pi) puede
    utilizarse alli donde se necesite cualquier valor de coma flotante o
    complejo:

#     ..src > go
#       var x float32 = math.Pi
#       var y float64 = math.Pi
#       var z complex128 = math.Pi
#     < src..
    ..src > go
      var x float32 = math.Pi
      var y float64 = math.Pi
      var z complex128 = math.Pi
    < src..

#     If @c(math.Pi) had been committed to a specific type such as @c(float64),
#     the result would not be as precise, and type conversions would be required
#     to use it when a @c(float32) or @c(complex128) value is wanted:
    Si @c(math.Pi) entubiera comprometido con un tipo especifico, como
    @c(float64), el resultado no seria tan preciso, y se requerira de conversion
    de tipos para usarlo con valores @c(float32) o @c(complex128):

#     ..src > go
#       const Pi64 float64 = math.Pi
#
#       var x float32 = float32(Pi64)
#       var y float64 = Pi64
#       var z complex128 = complex128(Pi64)
#     < src..
    ..src > go
      const Pi64 float64 = math.Pi

      var x float32 = float32(Pi64)
      var y float64 = Pi64
      var z complex128 = complex128(Pi64)
    < src..

#     For literals, syntax determines flavor. The literals @c(0), @c(0.0), @c(0i),
#     and @c('\u0000') all denote constants of the same value but different
#     flavors: untyped integer, untyped floating-point, untyped complex, and
#     untyped rune, respectively. Similarly, @c(true) and @c(false) are untyped
#     booleans and string literals are untyped strings.
    Para literales, la sintaxis determina el sabor. Los literales de @c(0),
    @c(0.0), @c(0i), y @c('\u0000') representan constantes del mismo valor pero
    diferentes sabores: entero sin tipo, sin tipo de punto flotante, complejo
    sin tipo, y runa sin tipo, respectivamente. Del mismo modo, @c(true) y
    @c(false) son booleanos sin tipo y literales de cadena son cadenas sin tipo.

#     Recall that @c(/) may represent integer or floating-point division depending on
#     its operands.  Consequently, the choice of literal may affect the result of
#     a constant division expression:
    Recordemos que @c(/) puede representar un numero entero o division de punto
    flotante dependiendo de sus operandos. En consecuencia, la eleccion de
    literal puede afectar el resultado de una expresion de division constante:

#     ..src > go
#       var f float64 = 212
#       fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
#       fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
#       fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
#     < src..
    ..src > go
      var f float64 = 212
      fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 es un float64
      fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 es un entero sin tipo, 0
      fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 es un float sin tipo
    < src..

#     Only constants can be untyped. When an untyped constant is assigned to a
#     variable, as in the first statement below, or appears on the right-hand side
#     of a variable declaration with an explicit type, as in the other three
#     statements, the constant is implicitly converted to the type of that
#     variable if possible.
    Solo las constantes pueden no tener tipo. Cuando una constante no tipificada
    se asigna a una variable, como en la primer instruccion a continuacion, o
    aparece en el lado derecho de una declaracion de variable con un tipo
    explicito, como en las otras tres sentencias, la constante se convierte
    implicitamente en el tipo de esa variable si es posible.

#     ..src > go
#       var f float64 = 3 + 0i // untyped complex -> float64
#       f = 2                  // untyped integer -> float64
#       f = 1e123              // untyped floating-point -> float64
#       f = 'a'                // untyped rune -> float64
#     < src..
    ..src > go
      var f float64 = 3 + 0i // complejo sin tipo -> float64
      f = 2                  // entero sin tipo -> float64
      f = 1e123              // punto flotante sin tipo -> float64
      f = 'a'                // runa sin tipo -> float64
    < src..

#     The statements above are thus equivalent to these:
    Las afirmaciones anteriores son, pues, equivalentes a estas:

#     ..src > go
#       var f float64 = float64(3 + 0i)
#       f = float64(2)
#       f = float64(1e123)
#       f = float64('a')
#     < src..
    ..src > go
      var f float64 = float64(3 + 0i)
      f = float64(2)
      f = float64(1e123)
      f = float64('a')
    < src..

#     Whether implicit or explicit, converting a constant from one type to another
#     requires that the target type can represent the original value. Rounding is
#     allowed for real and complex floating-point numbers:
    Ya sea implicita o explicitamente, la conversion de una constante de un tipo
    a otro requiere que el tipo de destino pueda representar el valor
    original. Se permite el redondeo para numeros reales y complejos de coma
    flotante:

#     ..src > go
#       const (
#         deadbeef = 0xdeadbeef // untyped int with value 3735928559
#         a = uint32(deadbeef)  // uint32 with value 3735928559
#         b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
#         c = float64(deadbeef) // float64 with value 3735928559 (exact)
#         d = int32(deadbeef)   // compile error: constant overflows int32
#         e = float64(1e309)    // compile error: constant overflows float64
#         f = uint(-1)          // compile error: constant underflows uint
#       )
#     < src..
    ..src > go
      const (
        deadbeef = 0xdeadbeef // int sin tipo con valor 3735928559
        a = uint32(deadbeef)  // uint32 con valor 3735928559
        b = float32(deadbeef) // float32 con valor 3735928576 (rounded up)
        c = float64(deadbeef) // float64 con valor 3735928559 (exact)
        d = int32(deadbeef)   // error de compilacion: desbordamiento constante int32
        e = float64(1e309)    // error de compilacion: desbordamiento constante float64
        f = uint(-1)          // error de compilacion: subdesbordamiento constante uint
      )
    < src..

#     In a variable declaration without an explicit type (including short variable
#     declarations), the flavor of the untyped constant implicitly determines the
#     default type of the variable, as in these examples:
    En una declaracion de variable sin un tipo explicito (incluyendo declaracion
    de variables compacto), el sabor de la constante no tipificada determina
    implicitamente el tipo predeterminado de la variable, como en estos
    ejemplos:

#     ..src > go
#       i := 0      // untyped integer;        implicit int(0)
#       r := '\000' // untyped rune;           implicit rune('\000')
#       f := 0.0    // untyped floating-point; implicit float64(0.0)
#       c := 0i     // untyped complex;        implicit complex128(0i)
#     < src..
    ..src > go
      i := 0      // entero sin tipo;         int(0) implicitio
      r := '\000' // runa sin tipo;           rune('\000') implicitio
      f := 0.0    // punto flotante sin tipo; float64(0.0) implicitio
      c := 0i     // complejo sin tipo;       complex128(0i) implicitio
    < src..

#     Note the asymmetry: untyped integers are converted to @c(int), whose size is
#     not guaranteed, but untyped floating-point and complex numbers are converted
#     to the explicitly sized types @c(float64) and @c(complex128). The language
#     has no unsized @c(float) and @c(complex) types analogous to unsized @c(int),
#     because it is very difficult to write correct numerical algorithms without
#     knowing the size of one’s floating-point data types.
    Observese la asimetria: los enteros sin tipo se convierten en @c(int), cuyo
    tamaño no esta garantizado, pero los numeros de punto flotante y numeros
    complejos se convierten a los tipos de tamaño @c(float64) y @c(complex128)
    de forma explicita. El lenguaje no cuenta con tipos @c(float) y @c(complex)
    sin tamaño, analogos a @c(int) sin tamaño, porque es muy dificil escribir
    algoritmos numericos correctos sin conocer el tamaño de uno de los tipos de
    datos de punto flotante.

#     To give the variable a different type, we must explicitly convert the
#     untyped constant to the desired type or state the desired type in the
#     variable declaration, as in these examples:
    Para dar un tipo diferente a la variable, debemos convertir explicitamente
    la constante no tipificada en el tipo deseado o indicar el tipo deseado en
    la declaracion de variables, como en estos ejemplos:

#     ..src > go
#       var i = int8(0)
#       var i int8 = 0
#     < src..
    ..src > go
      var i = int8(0)
      var i int8 = 0
    < src..

#     These defaults are particularly important when converting an untyped
#     constant to an interface value (see @l(#Chapter 7)) since they determine its
#     dynamic type.
    Estos valores predeterminados son particularmente importantes cuando se
    convierte una constante sin tipo a un valor de interfaz (ver @l(#Capitulo
    7)) ya que determinan su tipo dinamico.

#     ..src > go
#       fmt.Printf("%T\n", 0)      // "int"
#       fmt.Printf("%T\n", 0.0)    // "float64"
#       fmt.Printf("%T\n", 0i)     // "complex128"
#       fmt.Printf("%T\n", '\000') // "int32" (rune)
#     < src..
    ..src > go
      fmt.Printf("%T\n", 0)      // "int"
      fmt.Printf("%T\n", 0.0)    // "float64"
      fmt.Printf("%T\n", 0i)     // "complex128"
      fmt.Printf("%T\n", '\000') // "int32" (rune)
    < src..

#     We’ve now covered the basic data types of Go. The next step is to show how
#     they can be combined into larger groupings like arrays and structs, and then
#     into data structures for solving real programming problems; that is the
#     topic of @l(#Chapter 4).
    Ahora hemos cubierto los tipos de datos basicos de Go. El siguiente paso es
    mostrar como se pueden combinar en agrupaciones mas grandes como arreglos y
    estructuras, y luego en estructuras de datos para resolver problemas de
    programacion real; ese es el tema del @l(#Capitulo 4).

# * Chapter 4 <> Composite Types
* Capitulo 4 <> Tipos Compuestos
