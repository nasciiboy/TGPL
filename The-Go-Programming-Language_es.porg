@ -*- mode: org; -*-
..title   > El lenguaje de programacion Go
..author  > Alan A. A. Donovan
..author  > Brian W. Kernighan
..date    > 29/09/2015
..id      > isbn-13 978-0-13-419044-0
..id      > isbn-10 0-13-419044-0
..style   > worg-data/worg.css
..options > toc pygments

@ revision 3b600c, date 29 Sep 2015

# ..center >
#   For Leila and Meg
# < center..
..center >
  Para Leila y Meg
< center..

# * Preface
* Prefacio

#   ..quote >
#     @"(Go is an open source programming language that makes it easy to build
#     simple, reliable, and efficient software.)
#
#     --(From the Go web site at @l(https://golang.org/<>golang.org))
#   < quote..
  ..quote >
    @"(Go es un lenguaje de programacion de codigo abierto, que facilita la
    creacion de software simple, confiable y eficiente.)

    --(Desde el sitio web de Go en @l(https://golang.org/<>golang.org))
  < quote..

#   Go was conceived in September 2007 by Robert Griesemer, Rob Pike, and Ken
#   Thompson, all at Google, and was announced in November 2009. The goals of the
#   language and its accompanying tools were to be expressive, efficient in both
#   compilation and execution, and effective in writing reliable and robust
#   programs.
  Go fue concebido en septiembre de 2007 por Robert Griesemer, Rob Pike y Ken
  Thompson, todos de Google, y fue anunciado en noviembre de 2009. La meta del
  lenguaje y sus herramientas acompañantes es ser expresivos, eficientes en la
  compilacion y ejecucion, y eficaz en la escritura de programas fiables y
  robustos.

#   Go bears a surface similarity to C and, like C, is a tool for professional
#   programmers, achieving maximum effect with minimum means. But it is much more
#   than an updated version of C. It borrows and adapts good ideas from many other
#   languages, while avoiding features that have led to complexity and unreliable
#   code. Its facilities for concurrency are new and efficient, and its approach
#   to data abstraction and object-oriented programming is unusually flexible. It
#   has automatic memory management or @e(garbage collection).
  Go tiene una similitud superficial con C y, como C, es una herramienta para
  programadores profesionales, logrando el maximo efecto con un minimo de
  medios. Pero es mucho mas que una version actualizada de C. Obtiene y adapta
  buenas ideas de muchos otros lenguajes, evitando caracteristicas que han
  llevado a la complejidad y a un codigo poco confiable. Sus comodidades para la
  concurrencia son nuevas y eficientes, y su enfoque hacia la abstraccion de
  datos y la programacion orientada a objetos es inusualmente flexible. Tambien
  cuenta con gestion automatica de memoria o @e(recoleccion de basura).

#   Go is especially well suited for building infrastructure like networked
#   servers, and tools and systems for programmers, but it is truly a
#   general-purpose language and finds use in domains as diverse as graphics,
#   mobile applications, and machine learning. It has become popular as a
#   replacement for untyped scripting languages because it balances expressiveness
#   with safety: Go programs typically run faster than programs written in
#   dynamic languages and suffer far fewer crashes due to unexpected type errors.
  Go es especialmente adecuado para la construccion de infraestructura como
  servidores en red, y herramientas y sistemas para programadores, pero es
  realmente un lenguaje de uso general y se utiliza en dominios tan diversos
  como graficos, aplicaciones moviles y aprendizaje automatico. Se ha vuelto
  popular como un reemplazo para los lenguajes de scripting no tipados porque
  equilibra la expresividad con la seguridad: Los programas Go suelen funcionar
  mas rapido que los programas escritos en lenguajes dinamicos y sufren muchos
  menos accidentes debido a errores de tipado.

#   Go is an open-source project, so source code for its compiler, libraries, and
#   tools is freely available to anyone. Contributions to the project come from an
#   active worldwide community. Go runs on Unix-like systems—GNU/Linux, FreeBSD,
#   OpenBSD, Mac OS X—and on Plan 9 and Microsoft Windows. Programs written in one
#   of these environments generally work without modification on the others.
  Go es un proyecto de codigo abierto, por lo que el codigo fuente de su
  compilador, librerias y herramientas esta disponible gratuitamente para
  cualquiera. Las contribuciones al proyecto provienen de una activa comunidad
  mundial. Go se ejecuta en sistemas tipo Unix–GNU/Linux, FreeBSD, OpenBSD,
  Mac OS X–y en Plan 9 y Microsoft Windows. Los programas escritos en uno de
  estos entornos generalmente funcionan sin modificacion en los otros.

#   This book is meant to help you start using Go effectively right away and to
#   use it well, taking full advantage of Go’s language features and standard
#   libraries to write clear, idiomatic, and efficient programs.
  Este libro esta diseñado para ayudarle a comenzar a usar Go efectivamente, de
  inmediato y utilizarlo bien, aprovechando al maximo las caracteristicas
  lingüisticas de Go y las librerias estandar para escribir programas claros,
  idiomaticos y eficientes.

# ** The Origins of Go
** Los Origenes de Go

#    Like biological species, successful languages beget offspring that
#    incorporate the advantages of their ancestors; interbreeding sometimes leads
#    to surprising strengths; and, very occasionally, a radical new feature arises
#    without precedent. We can learn a lot about why a language is the way it is
#    and what environment it has been adapted for by looking at these influences.
   Como las especies biologicas, los lenguajes exitosos engendran hijos que
   incorporan las ventajas de sus antepasados; El entrecruzamiento a veces
   conduce a fortalezas sorprendentes; Y, muy ocasionalmente, surge un nuevo
   rasgo radical sin precedentes. Podemos aprender mucho sobre por que un
   lenguaje es como es y a que entorno se ha adaptado para ver estas
   influencias.

#    The figure below shows the most important influences of earlier
#    programming languages on the design of Go.
   La siguiente figura muestra las influencias mas importantes de los lenguajes
   de programacion anteriores en el diseño de Go.

#    ..img > img/go-influences.jpg
   ..img > img/go-influences.jpg


#    Go is sometimes described as a @"(C-like language,) or as @"(C for the 21st
#    century.) From C, Go inherited its expression syntax, control-flow
#    statements, basic data types, call-by-value parameter passing, pointers, and
#    above all, C’s emphasis on programs that compile to efficient machine code
#    and cooperate naturally with the abstractions of current operating systems.
   En ocaciones Go se describe como un @"(lenguaje de tipo C), o como @"(C para
   el siglo 21). De C, Go heredo su sintaxis de expresiones, instrucciones de
   flujo de control, tipos de datos basicos, paso de parametros por valor, punteros
   y, sobre todo, el enfasis de C en programas que compilan codigo maquina
   eficiente y cooperan naturalmente con las abstracciones de los sistemas
   operativos actuales.

#    But there are other ancestors in Go’s family tree. One major stream of
#    influence comes from languages by Niklaus Wirth, beginning with
#    Pascal. Modula-2 inspired the package concept.  Oberon eliminated the
#    distinction between module interface files and module implementation
#    files. Oberon-2 influenced the syntax for packages, imports, and
#    declarations, and Object Oberon provided the syntax for method declarations.
   Pero hay otros antepasados ​​en el arbol genealogico de Go. Una importante
   corriente de influencia proviene de lenguajes de Niklaus Wirth, comenzando
   con Pascal. Modula-2 inspiro el concepto de paquete. Oberon elimino la
   distincion entre los archivos de interfaz del modulo y los archivos de
   implementacion del modulo. Oberon-2 influyo en la sintaxis de importacion y
   declaracion de paquetes, y Object Oberon proporciono la sintaxis para la
   declararcion de metodos.

#    Another lineage among Go’s ancestors, and one that makes Go distinctive among
#    recent programming languages, is a sequence of little-known research
#    languages developed at Bell Labs, all inspired by the concept of
#    @e(communicating sequential processes) (CSP) from Tony Hoare’s seminal 1978
#    paper on the foundations of concurrency. In CSP, a program is a parallel
#    composition of processes that have no shared state; the processes communicate
#    and synchronize using channels. But Hoare’s CSP was a formal language for
#    describing the fundamental concepts of concurrency, not a programming
#    language for writing executable programs.
   Otro linaje entre los antepasados de Go, y uno que hace a Go distinto entre
   los lenguajes de programacion mas recientes, es una secuencia de lenguajes de
   investigacion poco conocidos desarrollados en los Laboratorios Bell, todos
   ellos inspiradas en el concepto de comunicacion de procesos secuenciales
   (CSP) del seminal articulo de 1978 de Tony Hoare en los cimientos de la
   concurrencia. En CSP, un programa es una composicion paralela de procesos que
   no tienen estado compartido; Los procesos se comunican y sincronizan
   utilizando canales. Pero el CSP de Hoare era un lenguaje formal para
   describir los conceptos fundamentales de la concurrencia, no un lenguaje de
   programacion para escribir programas ejecutables.

#    Rob Pike and others began to experiment with CSP implementations as actual
#    languages. The first was called Squeak (@"(A language for communicating with
#    mice)), which provided a language for handling mouse and keyboard events,
#    with statically created channels. This was followed by Newsqueak, which
#    offered C-like statement and expression syntax and Pascal-like type
#    notation. It was a purely functional language with garbage collection, again
#    aimed at managing keyboard, mouse, and window events. Channels became
#    first-class values, dynamically created and storable in variables.
   Rob Pike y otros comenzaron a experimentar con implementaciones CSP como
   lenguajes reales. El primero fue llamado Squeak (@"(Un Lenguaje para
   comunicarce con ratones)), que proporcionaron un lenguaje para el manejo de
   eventos de raton y teclado, con canales estaticamente creados. Esto fue
   seguido por Newsqueak, que ofrecia declaraciones y sintaxis de expresion como
   C y la notacion de tipo Pascal. Se trataba de un lenguaje puramente funcional
   con recoleccion de basura, dirigido nuevamente a administrar eventos de
   teclado, raton y ventanas. Los canales se convirtieron en valores de primera
   clase, creados dinamicamente y almacenados en variables.

#    The Plan 9 operating system carried these ideas forward in a language called
#    Alef. Alef tried to make Newsqueak a viable system programming language, but
#    its omission of garbage collection made concurrency too painful.
   El sistema operativo Plan 9 llevo adelante estas ideas en un lenguaje llamado
   Alef. Alef trato de hacer de Newsqueak un lenguaje viable para la
   programacion de sistemas, pero su omision de un recoleccion de basura hizo
   que la concurrencia fuera demasiado dolorosa.

#    Other constructions in Go show the influence of non-ancestral genes here and
#    there; for example @c(iota) is loosely from APL, and lexical scope with nested
#    functions is from Scheme (and most languages since). Here too we find novel
#    mutations. Go’s innovative slices provide dynamic arrays with efficient
#    random access but also permit sophisticated sharing arrangements reminiscent
#    of linked lists. And the defer statement is new with Go.
   Otras construcciones en Go muestran la influencia de genes no ancestrales
   aqui y alla; Por ejemplo @c(iota) es tomado libremente de APL, y el ambito
   lexico con funciones anidadas es de Scheme (y la mayoria de lenguajes desde
   entonces). Aqui tambien encontramos mutaciones novedosas. Go innova
   proporcionando slices (arreglos dinamicos) con acceso aleatorio eficiente,
   pero tambien permite sofisticados arreglos compartidos que recuerdan a las
   listas enlazadas. Y la declaracion @c(defer) es nueva con Go.

# ** The Go Project
** El Proyecto Go

#    All programming languages reflect the programming philosophy of their
#    creators, which often includes a significant component of reaction to the
#    perceived shortcomings of earlier languages. The Go project was borne of
#    frustration with several software systems at Google that were suffering from
#    an explosion of complexity. (This problem is by no means unique to Google.)
   Todos los lenguajes de programacion reflejan la filosofia de programacion de
   sus creadores, que a menudo incluye un componente significativo de la
   reaccion a las deficiencias percibidas de los lenguajes anteriores. El proyecto
   Go fue frustrado con varios sistemas de software de Google que estaban
   sufriendo una explosion de complejidad. (Este problema no es exclusivo de
   Google.)

#    As Rob Pike put it, @"(complexity is multiplicative): fixing a problem by
#    making one part of the system more complex slowly but surely adds complexity
#    to other parts. With constant pressure to add features and options and
#    configurations, and to ship code quickly, it’s easy to neglect simplicity,
#    even though in the long run simplicity is the key to good software.
   Como Rob Pike dijo, @"(la complejidad es multiplicativa): solucionar un
   problema al hacer una parte del sistema mas compleja, lenta pero seguramente
   añade complejidad a otras partes. Con la presion constante para agregar
   caracteristicas y opciones y configuraciones, y para enviar codigo
   rapidamente, es facil olvidar la sencillez, aunque a la larga la simplicidad
   es la clave para un buen software.

#    Simplicity requires more work at the beginning of a project to reduce an idea
#    to its essence and more discipline over the lifetime of a project to
#    distinguish good changes from bad or pernicious ones. With sufficient effort,
#    a good change can be accommodated without compromising what Fred Brooks
#    called the @"(conceptual integrity) of the design but a bad change cannot,
#    and a pernicious change trades simplicity for its shallow cousin,
#    convenience. Only through simplicity of design can a system remain stable,
#    secure, and coherent as it grows.
   La simplicidad requiere mas trabajo al comienzo de un proyecto para reducir
   una idea a su esencia y mas disciplina durante la vida de un proyecto para
   distinguir los buenos cambios, de los malos o perniciosos. Con un esfuerzo
   suficiente, un buen cambio se puede acomodar sin comprometer lo que Fred
   Brooks llamo la @"(integridad conceptual) del diseño, pero un mal cambio no
   puede, un cambio pernicioso negocia la sencillez por una conveniencia
   superficial. Solo a traves de la simplicidad del diseño un sistema puede
   permanecer estable, seguro y coherente a medida que crece.

#    The Go project includes the language itself, its tools and standard
#    libraries, and last but not least, a cultural agenda of radical
#    simplicity. As a recent high-level language, Go has the benefit of hindsight,
#    and the basics are done well: it has garbage collection, a package system,
#    firstclass functions, lexical scope, a system call interface, and immutable
#    strings in which text is generally encoded in UTF-8. But it has comparatively
#    few features and is unlikely to add more. For instance, it has no implicit
#    numeric conversions, no constructors or destructors, no operator overloading,
#    no default parameter values, no inheritance, no generics, no exceptions, no
#    macros, no function annotations, and no thread-local storage. The language is
#    mature and stable, and guarantees backwards compatibility: older Go programs
#    can be compiled and run with newer versions of compilers and standard
#    libraries.
   El proyecto Go incluye el lenguaje mismo, sus herramientas y librerias
   estandar, y por ultimo, pero no menos importante, una agenda cultural de
   simplicidad radical. Como un lenguaje reciente de alto nivel, Go tiene el
   beneficio de la retrospectiva, y los fundamentos se hacen bien: tiene
   recoleccion de basura, un sistema de paquetes, funciones de primera clase,
   alcance lexico, una interfaz de llamadas de sistema y cadenas inmutables en
   las que el texto es generalmente codificado en UTF-8. Pero tiene
   comparativamente pocas caracteristicas y es poco probable que agregue
   mas. Por ejemplo, no tiene conversiones numericas implicitas, no hay
   constructores o destructores, no hay sobrecarga de operadores, no hay valores
   de parametros predeterminados, no hay herencia, no hay genericos, no hay
   excepciones, no hay macros, no hay anotaciones de funcion y no hay
   almacenamiento local de subprocesos. El lenguaje es maduro y estable y
   garantiza la compatibilidad con versiones anteriores: los programas Go mas
   antiguos se pueden compilar y ejecutar con versiones mas recientes de
   compiladores y librerias estandar.

#    Go has enough of a type system to avoid most of the careless mistakes that
#    plague programmers in dynamic languages, but it has a simpler type system
#    than comparable typed languages.  This approach can sometimes lead to
#    isolated pockets of @"(untyped) programming within a broader framework of
#    types, and Go programmers do not go to the lengths that C++ or Haskell
#    programmers do to express safety properties as type-based proofs. But in
#    practice Go gives programmers much of the safety and run-time performance
#    benefits of a relatively strong type system without the burden of a complex
#    one.
   Go tiene un sistema de tipado para evitar la mayoria de los errores
   descuidados que afectan a los programadores en lenguajes dinamicos, pero
   tiene un sistema de tipado mas simple que los lenguajes tipados
   comparables. Este enfoque puede conducir en ocaciones a baches de
   programacion @"(sin tipo) dentro de un marco mas amplio de tipos, y los
   programadores Go no van a las longitudes que hacen a los programadores C++ o
   Haskell expresar propiedades de seguridad como pruebas basadas en tipo. Pero
   en la practica, Go da a los programadores gran parte de los beneficios de
   seguridad y rendimiento en tiempo de ejecucion de un sistema de tipado
   relativamente fuerte sin la carga de complejidad.

#    Go encourages an awareness of contemporary computer system design,
#    particularly the importance of locality. Its built-in data types and most
#    library data structures are crafted to work naturally without explicit
#    initialization or implicit constructors, so relatively few memory allocations
#    and memory writes are hidden in the code. Go’s aggregate types (structs and
#    arrays) hold their elements directly, requiring less storage and fewer
#    allocations and pointer indirections than languages that use indirect
#    fields. And since the modern computer is a parallel machine, Go has
#    concurrency features based on CSP, as mentioned earlier. The variablesize
#    stacks of Go’s lightweight threads or goroutines are initially small enough
#    that creating one goroutine is cheap and creating a million is practical.
   Go fomenta una conciencia del diseño de sistemas informaticos contemporaneos,
   particularmente la importancia de la localidad. Sus tipos de datos
   incorporados y la mayoria de las estructuras de datos de la libreria estan
   diseñados para funcionar naturalmente sin inicializacion explicita o
   constructores implicitos, por lo que relativamente pocas asignaciones de
   memoria y escrituras de memoria estan ocultas en el codigo. Los tipos
   agregados de Go (estructuras y matrices) mantienen sus elementos
   directamente, requiriendo menos almacenamiento y menos asignaciones e
   indireccion de punteros, que los lenguajes que utilizan campos indirectos. Y
   como la computadora moderna es una maquina paralela, Go tiene caracteristicas
   de concurrencia basadas en CSP, como se menciono anteriormente. Los stacs de
   tamaño variable de los hilos ligeros de Go o @e(gorutinas) son inicialmente
   lo suficientemente pequeñas como para que crear una gorutina sea barato y
   crear un millon sea practico.

#    Go’s standard library, often described as coming with @"(batteries included,)
#    provides clean building blocks and APIs for I/O, text processing, graphics,
#    cryptography, networking, and distributed applications, with support for many
#    standard file formats and protocols. The libraries and tools make extensive
#    use of convention to reduce the need for configuration and explanation, thus
#    simplifying program logic and making diverse Go programs more similar to each
#    other and thus easier to learn. Projects built using the go tool use only
#    file and identifier names and an occasional special comment to determine all
#    the libraries, executables, tests, benchmarks, examples, platform-specific
#    variants, and documentation for a project; the Go source itself contains the
#    build specification.
   La libreria estandar de Go, a menudo descrita como con @"(baterias
   incluidas,) proporciona bloques de construccion limpios y APIs de E/S,
   procesamiento de texto, graficos, criptografia, redes y aplicaciones
   distribuidas, con soporte para muchos formatos de archivos y protocolos
   estandar. Las librerias y las herramientas hacen uso extensivo de la
   convencion para reducir la necesidad de configuracion y explicaciones,
   simplificando asi la logica del programa y haciendo que diversos programas Go
   sean mas similares entre si y, por lo tanto, mas faciles de aprender. Los
   proyectos creados con la herramienta @$(go) solo utilizan nombres de archivos
   e identificadores y un comentario especial ocasional para determinar todas
   las librerias, ejecutables, pruebas, referencias, ejemplos, variantes
   especificas de la plataforma y documentacion para un proyecto; El codigo
   fuente de Go en si contiene la especificacion de compilacion.

# ** Organization of the Book
** Organizacion del Libro

#    We assume that you have programmed in one or more other languages, whether
#    compiled like C, C++, and Java, or interpreted like Python, Ruby, and
#    JavaScript, so we won’t spell out everything as if for a total
#    beginner. Surface syntax will be familiar, as will variables and constants,
#    expressions, control flow, and functions.
   Asumimos que usted ha programado en uno o mas lenguajes, compilados como C,
   C++ y Java, o interpretados como Python, Ruby y JavaScript, por lo que no
   solemos explicar todo como si fuera un completo principiante. La sintaxis
   superficial sera familiar, al igual que variables y constantes, expresiones,
   flujo de control y funciones.

#    Chapter 1 is a tutorial on the basic constructs of Go, introduced through a
#    dozen programs for everyday tasks like reading and writing files, formatting
#    text, creating images, and communicating with Internet clients and servers.
   El Capitulo 1 es un tutorial sobre las construcciones basicas de Go,
   introducido a traves de una docena de programas para tareas cotidianas como
   leer y escribir archivos, formatear texto, crear imagenes y comunicarse con
   clientes y servidores de Internet.

#    Chapter 2 describes the structural elements of a Go program—declarations,
#    variables, new types, packages and files, and scope. Chapter 3 discusses
#    numbers, booleans, strings, and constants, and explains how to process
#    Unicode. Chapter 4 describes composite types, that is, types built up from
#    simpler ones using arrays, maps, structs, and slices, Go’s approach to
#    dynamic lists. Chapter 5 covers functions and discusses error handling,
#    @c(panic) and @c(recover), and the @c(defer) statement.
   El Capitulo 2 describe los elementos estructurales de un programa
   Go–declaraciones, variables, nuevos tipos, paquetes y archivos, y alcance. El
   Capitulo 3 analiza numeros, booleanos, cadenas y constantes, y explica como
   procesar Unicode. El Capitulo 4 describe los tipos compuestos, es decir, los
   tipos construidos a partir de los mas sencillos utilizando arreglos, mapas,
   estructuras y slices, la aproximacion de Go para listas dinamicas. El
   Capitulo 5 cubre las funciones y discute el manejo de errores,
   @c(panic) y @c(recover), y la sentencia @c(defer).

#    Chapters 1 through 5 are thus the basics, things that are part of any
#    mainstream imperative language. Go’s syntax and style sometimes differ from
#    other languages, but most programmers will pick them up quickly. The
#    remaining chapters focus on topics where Go’s approach is less conventional:
#    methods, interfaces, concurrency, packages, testing, and reflection.
   Los Capitulos 1 a 5 son, son por lo tanto, lo basico, las cosas que forman
   parte de cualquier lenguaje imperativo popular. La sintaxis y el estilo de Go
   a veces difieren de otros lenguajes, pero la mayoria de los programadores los
   recogeran rapidamente. Los capitulos restantes se centran en temas en los que
   el enfoque de Go es menos convencional: metodos, interfaces, concurrencia,
   paquetes, pruebas y reflexion.

#    Go has an unusual approach to object-oriented programming. There are no class
#    hierarchies, or indeed any classes; complex object behaviors are created from
#    simpler ones by composition, not inheritance. Methods may be associated with
#    any user-defined type, not just structures, and the relationship between
#    concrete types and abstract types (@e(interfaces)) is implicit, so a concrete
#    type may satisfy an interface that the type’s designer was unaware
#    of. Methods are covered in Chapter 6 and interfaces in Chapter 7.
   Go tiene un acercamiento inusual a la programacion orientada a objetos. No
   hay jerarquias de clase, o de hecho ninguna clase; Los comportamientos de
   objetos complejos se crean a partir de los mas simples por composicion, no
   por herencia. Los metodos pueden ser asociados con cualquier tipo definido
   por el usuario, no solo las estructuras, y la relacion entre tipos concretos
   y tipos abstractos (las @e(interfaces)) son implicitas, por lo que un tipo
   concreto puede satisfacer una interfaz que el diseñador del tipo desconocia.
   Los metodos estan cubiertos en el Capitulo 6, las interfaces en el Capitulo 7.

#    Chapter 8 presents Go’s approach to concurrency, which is based on the idea
#    of communicating sequential processes (CSP), embodied by goroutines and
#    channels. Chapter 9 explains the more traditional aspects of concurrency
#    based on shared variables.
   El Capitulo 8 presenta el enfoque de Go a la concurrencia, que se basa en la
   idea de comunicar procesos secuenciales (CSP), incorporados por goroutines y
   canales. El Capitulo 9 explica los aspectos mas tradicionales de la
   concurrencia basados ​​en variables compartidas.

#    Chapter 10 describes packages, the mechanism for organizing libraries. This
#    chapter also shows how to make effective use of the @$(go) tool, which
#    provides for compilation, testing, benchmarking, program formatting,
#    documentation, and many other tasks, all within a single command.
   El Capitulo 10 describe los paquetes, el mecanismo para organizar las
   librerias. Este capitulo tambien muestra como hacer un uso efectivo de la
   herramienta @$(go), provista para la compilacion, pruebas, benchmarking,
   formateo del programa, documentacion y muchas otras tareas, todo dentro de un
   solo comando.

#    Chapter 11 deals with testing, where Go takes a notably lightweight approach,
#    avoiding abstraction-laden frameworks in favor of simple libraries and
#    tools. The testing libraries provide a foundation atop which more complex
#    abstractions can be built if necessary.
   El Capitulo 11 trata de las pruebas, donde Go adopta un enfoque notablemente
   ligero, evitando framewoks cargados de abstraccion en favor de librerias y
   herramientas simples. Las librerias de pruebas proporcionan una base sobre
   la que se pueden construir abstracciones mas complejas si es necesario.

#    Chapter 12 discusses reflection, the ability of a program to examine its own
#    representation during execution. Reflection is a powerful tool, though one to
#    be used carefully; this chapter explains finding the right balance by showing
#    how it is used to implement some important Go libraries. Chapter 13 explains
#    the gory details of low-level programming that uses the @c(unsafe) package to
#    step around Go’s type system, and when that is appropriate.
   El Capitulo 12 discute la reflexion, la capacidad de un programa para
   examinar su propia representacion durante la ejecucion. La reflexion es una
   herramienta poderosa, aunque debe ser usada con cuidado; Este capitulo
   explica como encontrar el equilibrio correcto, mostrando como se utiliza para
   implementar algunas librerias importantes en Go. El Capitulo 13 explica los
   detalles morbosos de programacion a bajo nivel que utiliza el paquete
   @c(unsafe) para dar un paso alrededor del sistema de tipado de Go, y cuando
   eso es apropiada.

#    Each chapter has a number of exercises that you can use to test your
#    understanding of Go, and to explore extensions and alternatives to the
#    examples from the book.
   Cada capitulo tiene una serie de ejercicios que puedes usar para probar tu
   comprension de Go, y para explorar extensiones y alternativas a los ejemplos
   del libro.

#    All but the most trivial code examples in the book are available for download
#    from the public Git repository at @l(http://www.gopl.io/<>gopl.io). Each
#    example is identified by its package import path and may be conveniently
#    fetched, built, and installed using the @$(go get) command. You’ll need to
#    choose a directory to be your Go workspace and set the @c(GOPATH) environment
#    variable to point to it.  The go tool will create the directory if
#    necessary. For example:
   Todos menos los ejemplos de codigo mas triviales en el libro estan
   disponibles para su descarga desde un repositorio Git publico en
   @l(http://www.gopl.io/<>gopl.io). Cada ejemplo se identifica por su ruta de
   importacion de paquete y puede ser convenientemente localizado, construido e
   instalado utilizando el comando @$(go get). tendra que elegir un directorio
   para que sea su espacio de trabajo y establecer la variable de entorno
   @c(GOPATH) apuntando a este. La herramienta @$(go) creara el directorio si es
   necesario. Por ejemplo:

#    ..src > sh
#      $ export GOPATH=$HOME/gobook        # choose workspace directory
#      $ go get gopl.io/ch1/helloworld     # fetch, build, install
#      $ $GOPATH/bin/helloworld            # run
#      Hello, 世界
#    < src..
   ..src > sh
     $ export GOPATH=$HOME/gobook        # Elegir el directorio de trabajo
     $ go get gopl.io/ch1/helloworld     # buscar, construir, instalar
     $ $GOPATH/bin/helloworld            # ejecutar
     Hello, 世界
   < src..

#    To run the examples, you will need at least version 1.5 of Go.
   Para ejecutar los ejemplos, necesitara al menos la version 1.5 de Go.

#    ..src > sh
#      $ go version
#      go version go1.5 linux/amd64
#    < src..
   ..src > sh
     $ go version
     go version go1.5 linux/amd64
   < src..

#    Follow the instructions at @l(https://golang.org/doc/install) if the go tool
#    on your computer is older or missing.
   Siga las instrucciones en @l(https://golang.org/doc/install) si en su equipo
   la herramienta @$(go) esta ausente o es anterior.

# ** Where to Find More Information
** Donde Encontrar Mas Informacion

#    The best source for more information about Go is the official web site,
#    @l(https://golang.org), which provides access to the documentation, including
#    the @e(Go Programming Language Specification), standard packages, and the
#    like. There are also tutorials on how to write Go and how to write it well,
#    and a wide variety of online text and video resources that will be valuable
#    complements to this book. The Go Blog at @l(https://blog.golang.org<>blog.golang.org)
#    publishes some of the best writing on Go, with articles on the state of the
#    language, plans for the future, reports on conferences, and in-depth
#    explanations of a wide variety of Go-related topics.
   La mejor fuente para obtener mas informacion sobre Go es el sitio web
   oficial, @l(https://golang.org), que proporciona acceso a la documentacion,
   incluyendo la @e(Especificacion del Lenguaje de Programacion Go), los
   paquetes estandar, y similares. Tambien hay tutoriales sobre como escribir Go
   y como escribirlo bien, y una amplia variedad de recursos de texto y video en
   linea que seran complementos valiosos para este libro. El Blog de Go se
   encuentra en @l(https://blog.golang.org<>blog.golang.org) donde se publican
   algunos de los mejores escritos en Go, con articulos sobre el estado del
   lenguaje, los planes a futuro, los informes sobre conferencias y
   explicaciones en profundidad de una amplia variedad de temas relacionados.

#    One of the most useful aspects of online access to Go (and a regrettable
#    limitation of a paper book) is the ability to run Go programs from the web
#    pages that describe them. This functionality is provided by the Go Playground
#    at @l(https://play.golang.org<>play.golang.org), and may be embedded within
#    other pages, such as the home page at @l(https://golang.org<>golang.org) or
#    the documentation pages served by the godoc tool.
   Uno de los aspectos mas utiles del acceso en linea a Go (y una limitacion
   lamentable de un libro de papel) es la capacidad de ejecutar programas de Go
   desde las paginas web que los describen. Esta funcionalidad es proporcionada
   por Go Playground en @l(https://play.golang.org<>play.golang.org), y puede
   ser embebido dentro de otras paginas, como la pagina de inicio en
   @l(https://golang.org<>golang.org) o las paginas de documentacion provistas
   por la herramienta @$(godoc).

#    The Playground makes it convenient to perform simple experiments to check
#    one’s understanding of syntax, semantics, or library packages with short
#    programs, and in many ways takes the place of a @e(read-eval-print loop)
#    (REPL) in other languages. Its persistent URLs are great for sharing snippets
#    of Go code with others, for reporting bugs or making suggestions.
   Playground hace que sea conveniente llevar a cabo experimentos sencillos para
   comprobar la propia comprension de la sintaxis, la semantica, o paquetes de
   librerias con programas cortos, y en muchos sentidos toma el lugar de un
   @e(bucle leer-evaluar-imprimir) (@e(read-eval-print loop) o REPL) de otros
   lenguajes. Sus URLs persistentes son ideales para compartir fragmentos de
   codigo con otros, para informar sobre errores o hacer sugerencias.

#    Built atop the Playground, the Go Tour at @l(https://tour.golang.org<>tour.golang.org)
#    is a sequence of short interactive lessons on the basic ideas and
#    constructions of Go, an orderly walk through the language.
   Construido sobre Playground, el Tour Go en @l(https://tour.golang.org<>tour.golang.org)
   es una secuencia de breves lecciones interactivas sobre las ideas basicas y
   construcciones de Go, un paseo ordenado atraves del lenguaje.

#    The primary shortcoming of the Playground and the Tour is that they allow
#    only standard libraries to be imported, and many library features—networking,
#    for example—are restricted for practical or security reasons. They also
#    require access to the Internet to compile and run each program. So for more
#    elaborate experiments, you will have to run Go programs on your own
#    computer. Fortunately the download process is straightforward, so it should
#    not take more than a few minutes to fetch the Go distribution from @l(https://golang.org<>golang.org)
#    and start writing and running Go programs of your own.
   El principal inconveniente del Playground y del Tour es que permiten que solo
   se importen librerias estandar, y muchas funciones de la libreria–por
   ejemplo, redes–estan restringidas por razones practicas o de seguridad.
   Tambien requiere de acceso a Internet para compilar y ejecutar cada programa.
   Asi que para experimentos mas elaborados, tendra que ejecutar programas Go en
   su propia computadora. Afortunadamente, el proceso de descarga es sencillo,
   por lo que no debe tomar mas de unos minutos para buscar su distribucion Go
   desde @l(https://golang.org<>golang.org) y empezar a escribir y ejecutar
   programas por su cuenta.

#    Since Go is an open-source project, you can read the code for any type or
#    function in the standard library online at @l(https://golang.org/pkg); the
#    same code is part of the downloaded distribution. Use this to figure out how
#    something works, or to answer questions about details, or merely to see how
#    experts write really good Go.
   Ya que Go es un proyecto de codigo abierto, se puede leer el codigo fuente de
   cualquier tipo o funcion en la libreria estandar en @l(https://golang.org/pkg);
   el mismo codigo forma parte de la distribucion descargada. Utilice esto para
   averiguar como funciona algo, o para responder a preguntas sobre los
   detalles, o simplemente para ver como los expertos escriben buen Go.

# ** Acknowledgments
** Agradecimientos

#    Rob Pike and Russ Cox, core members of the Go team, read the manuscript
#    several times with great care; their comments on everything from word choice
#    to overall structure and organization have been invaluable. While preparing
#    the Japanese translation, Yoshiki Shibata went far beyond the call of duty;
#    his meticulous eye spotted numerous inconsistencies in the English text and
#    errors in the code. We greatly appreciate thorough reviews and critical
#    comments on the entire manuscript from Brian Goetz, Corey Kosak, Arnold
#    Robbins, Josh Bleecher Snyder, and Peter Weinberger.
   Rob Pike y Russ Cox, miembros centrales del equipo de Go, leyeron el
   manuscrito varias veces con mucho cuidado; Sus comentarios sobre todo, desde
   la eleccion de palabras hasta la estructura general y la organizacion han
   sido invaluables. Mientras preparaba la traduccion japonesa, Yoshiki Shibata
   iba mucho mas alla del llamado del deber; Su ojo meticuloso observo numerosas
   inconsistencias en el texto ingles y errores en el codigo. Apreciamos
   grandemente revisiones completas y comentarios criticos en el manuscrito
   entero de Brian Goetz, Corey Kosak, Arnold Robbins, Josh Bleecher Snyder, y
   Peter Weinberger.

#    We are indebted to Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy
#    Donohue, Jonathan Feinberg, Andrew Gerrand, Robert Griesemer, John Linderman,
#    Minux Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth,
#    Nigel Tao, and Howard Trickey for many helpful suggestions. We also thank
#    David Brailsford and Raph Levien for typesetting advice.
   Agradecemos a Sameer Ajmani, Ittai Balaban, David Crawshaw, Billy Donohue,
   Jonathan Feinberg, Andrew Gerrand, Roberto Griesemer, John Linderman, Minux
   Ma, Bryan Mills, Bala Natarajan, Cosmos Nicolaou, Paul Staniforth, Nigel Tao,
   y a Howard Trickey para muchas sugerencias utiles. Tambien damos las gracias
   a David Brailsford y Raph Levien por los consejos sobre composicion
   tipografica.

#    Our editor Greg Doench at Addison-Wesley got the ball rolling originally and
#    has been continuously helpful ever since. The AW production team—John Fuller,
#    Dayna Isley, Julie Nahil, Chuti Prasertsith, and Barbara Wood—has been
#    outstanding; authors could not hope for better support.
   Nuestro redactor Greg Doench de Addison-Wesley consiguio hacer rodar la bola
   originalmente y ha estado ayunando continuamente desde entonces. El equipo de
   produccion de AW–John Fuller, Dayna Isley, Julie Nahil, Chuti Prasertsith y
   Barbara Wood–ha sido excepcional; Los autores no podrian esperar un mejor
   apoyo.

#    Alan Donovan wishes to thank: Sameer Ajmani, Chris Demetriou, Walt Drummond,
#    and Reid Tatge at Google for allowing him time to write; Stephen Donovan, for
#    his advice and timely encouragement; and above all, his wife Leila Kazemi,
#    for her unhesitating enthusiasm and unwavering support for this project,
#    despite the long hours of distraction and absenteeism from family life that
#    it entailed.
   Alan Donovan desea agradecer a: Sameer Ajmani, Chris Demetriou, Walt
   Drummond, y Reid Tatge en Google por permitirle tiempo para escribir; Stephen
   Donovan, por su consejo y oportuno estimulo; Y sobre todo a su esposa Leila
   Kazemi, por su entusiasmo y apoyo inquebrantable a este proyecto, a pesar de
   las largas horas de distraccion y ausentismo de la vida familiar que ello
   conllevaba.

#    Brian Kernighan is deeply grateful to friends and colleagues for their
#    patience and forbearance as he moved slowly along the path to understanding,
#    and especially to his wife Meg, who has been unfailingly supportive of
#    book-writing and so much else.
   Brian Kernighan esta profundamente agradecido a sus amigos y colegas por su
   paciencia y autodominio mientras avanzaba lentamente por el camino hacia la
   comprension, y especialmente a su esposa Meg, que ha sido infaliblemente
   favorable a la escritura de libros y mucho mas.

#    ..quote >
#      -- New York
#      -- October 2015
#    < quote..
   ..quote >
     --Nueva York
     --Octubre 2015
   < quote..

# * Chapter 1 <> Tutorial
* Capitulo 1 <> Tutorial

#   This chapter is a tour of the basic components of Go. We hope to provide
#   enough information and examples to get you off the ground and doing useful
#   things as quickly as possible. The examples here, and indeed in the whole
#   book, are aimed at tasks that you might have to do in the real world. In this
#   chapter we’ll try to give you a taste of the diversity of programs that one
#   might write in Go, ranging from simple file processing and a bit of graphics
#   to concurrent Internet clients and servers. We certainly won’t explain
#   everything in the first chapter, but studying such programs in a new language
#   can be an effective way to get started.
  Este capitulo es un recorrido por los componentes basicos de Go. Esperamos
  proporcionar suficiente informacion y ejemplos para sacarle del barro y hacer
  cosas utiles lo mas rapido posible. Los ejemplos aqui, y de hecho en todo el
  libro, estan dirigidos a tareas que usted podria tener que hacer en el mundo
  real. En este capitulo intentaremos darle una muestra de la diversidad de
  programas que uno podria escribir en Go, que van desde el simple procesamiento
  de archivos y un poco de graficos, a clientes y servidores de Internet
  concurrentes. Ciertamente no vamos a explicar todo en el primer capitulo, pero
  el estudio de estos programas en un nuevo lenguaje puede ser una manera eficaz
  de empezar.

#   When you’re learning a new language, there’s a natural tendency to write code
#   as you would have written it in a language you already know. Be aware of this
#   bias as you learn Go and try to avoid it. We’ve tried to illustrate and
#   explain how to write good Go, so use the code here as a guide when you’re
#   writing your own.
  Cuando estas aprendiendo un nuevo lenguaje, hay una tendencia natural a
  escribir codigo como lo habrias escrito en un languaje que ya conoces. Este
  consciente de este sesgo a medida que aprende Go y trate de evitarlo. Hemos
  tratado de ilustrar y explicar como escribir buen Go, asi que utilice el
  codigo aqui como guia cuando este escribiendo el suyo propio.

# ** Section 1.1 <> Hello, World
** Seccion 1.1 <> Hola, Mundo

#    We’ll start with the now-traditional @"(hello, world) example, which appears
#    at the beginning of @e(The C Programming Language), published in 1978. C is
#    one of the most direct influences on Go, and @"(hello, world) illustrates a
#    number of central ideas.
   Vamos a empezar con el ya tradicional ejemplo del @"(hola, mundo), que
   aparece al comienzo de @e(El lenguaje de programacion C), publicado
   en 1978. C es una de las influencias mas directas sobre Go, y @"(hola, mundo)
   ilustra una serie de ideas centrales.

#    ..figure > @l(gopl.io/ch1/helloworld/main.go<>gopl.io/ch1/helloworld)
   ..figure > @l(gopl.io/ch1/helloworld/main.go<>gopl.io/ch1/helloworld)

#      ..src > go
#        package main
#
#        import "fmt"
#
#        func main() {
#          fmt.Println("Hello, 世界")
#        }
#      < src..
     ..src > go
       package main

       import "fmt"

       func main() {
         fmt.Println("Hello, 世界")
       }
     < src..

#    Go is a compiled language. The Go toolchain converts a source program and the
#    things it depends on into instructions in the native machine language of a
#    computer. These tools are accessed through a single command called @$(go)
#    that has a number of subcommands. The simplest of these subcommands is
#    @$(run), which compiles the source code from one or more source files whose
#    names end in @f(.go), links it with libraries, then runs the resulting
#    executable file.  (We will use @$($) as the command prompt throughout the
#    book.)
   Go es un lenguaje compilado. El conjunto de herramienta de Go convierte el
   codigo fuente de un programa y las cosas de las que depende, en instrucciones
   en el lenguaje maquina nativo de una computadora. Se puede acceder a estas
   herramientas a traves de un unico comando llamado @$(go) que tiene una serie
   de subcomandos. El mas simple de estos subcomandos es @$(run), que compila
   el codigo fuente de uno o mas archivos de origen cuyos nombres terminan en
   @f(.go), lo vincula con las librerias, y a continuacion, ejecuta el archivo
   ejecutable resultante. (Utilizaremos @$($) como el simbolo del sistema en
   todo el libro.)

#    ..src > sh
#      $ go run helloworld.go
#    < src..
   ..src > sh
     $ go run helloworld.go
   < src..

#    Not surprisingly, this prints
   No es sorprendente que esto imprima

#    ..src > sh
#      Hello, 世界
#    < src..
   ..src > sh
     Hello, 世界
   < src..


#    Go natively handles Unicode, so it can process text in all the world’s languages.
   Go maneja Unicode de forma nativa, por lo que puede procesar texto en todos
   los idiomas del mundo.

#    If the program is more than a one-shot experiment, it’s likely that you would
#    want to compile it once and save the compiled result for later use. That is
#    done with @$(go build):
   Si el programa es mas que un experimento de un solo disparo, es probable que
   quiera compilarlo una vez y guardar el resultado compilado para su uso
   posterior. Esto se hace con @$(go build):

#    ..src > sh
#      $ go build helloworld.go
#    < src..
   ..src > sh
     $ go build helloworld.go
   < src..

#    This creates an executable binary file called @$(helloworld) that can be run
#    any time without further processing:
   Esto crea un archivo binario ejecutable llamado @$(helloworld) que se pueden
   ejecutar en cualquier momento sin procesamiento adicional:

#    ..src > sh
#      $ ./helloworld
#      Hello, 世界
#    < src..
   ..src > sh
     $ ./helloworld
     Hello, 世界
   < src..

#    We have labeled each significant example as a reminder that you can obtain
#    the code from the book’s source code repository at
#    @l(http://www.gopl.io/<>(gopl.io): @l(http://www.gopl.io/ch1/helloworld<>gopl.io/ch1/helloworld)
   Hemos etiquetado cada ejemplo significativo como un recordatorio de que
   puede obtener el codigo fuente del libro desde el repositorio en
   @l(http://www.gopl.io/<>(gopl.io): @l(http://www.gopl.io/ch1/helloworld<>gopl.io/ch1/helloworld)

#    If you run @$(go get gopl.io/ch1/helloworld), it will fetch the source code
#    and place it in the corresponding directory. There’s more about this topic in
#    @l(#Section 2.6) and @l(#Section 10.7).
   Si ejecuta @$(go get gopl.io/ch1/helloworld), obtendra el codigo fuente y
   lo colocara en el directorio correspondiente. Hay mas informacion sobre este
   tema en la @l(#Seccion 2.6) y la @l(#Seccion 10.7).

#    Let’s now talk about the program itself. Go code is organized into packages,
#    which are similar to libraries or modules in other languages. A package
#    consists of one or more @f(.go) source files in a single directory that
#    define what the package does. Each source file begins with a package
#    declaration, here @c(package main), that states which package the file
#    belongs to, followed by a list of other packages that it imports, and then
#    the declarations of the program that are stored in that file.
   Hablemos ahora del programa en si. El codigo Go esta organizado en paquetes,
   que son similares a librerias o modulos en otros lenguajes. Un paquete se
   compone de uno o mas archivos de codigo @f(.go) en un unico directorio que
   definen lo que hace el paquete. Cada archivo de codigo inicia con una
   declaracion del paquete, aqui es @c(package main), que declara a que paquete
   pertenece el archivo, seguido de una lista de otros paquetes que importa, y
   luego las declaraciones del programa que se almacena en el archivo.

#    The Go standard library has over 100 packages for common tasks like input and
#    output, sorting, and text manipulation. For instance, the @c(fmt) package
#    contains functions for printing formatted output and scanning input.
#    @c(Println) is one of the basic output functions in @c(fmt); it prints one or
#    more values, separated by spaces, with a newline character at the end so that
#    the values appear as a single line of output.
   La libreria estandar de Go tiene mas de 100 paquetes para tareas comunes como
   entrada y salida, clasificacion y manipulacion de texto. Por ejemplo, el
   paquete @c(fmt) contiene funciones para la impresion y entrada de datos con
   formato. @c(Println) es una de las funciones basicas de salida en @c(fmt);
   esta imprime uno o mas valores, separados por espacios, con un caracter de
   nueva linea al final para que los valores aparezcan como una sola linea de
   salida.

#    Package @c(main) is special. It defines a standalone executable program, not
#    a library. Within package @c(main) the @e(function) @c(main) is also
#    special—it’s where execution of the program begins.  Whatever @c(main) does
#    is what the program does. Of course, @c(main) will normally call upon
#    functions in other packages to do much of the work, such as the function
#    @c(fmt.Println).
   El paquete @c(main) es especial. Define un programa ejecutable independiente,
   no una libreria. Dentro del paquete @c(main) la @e(funcion) @c(main) tambien
   es especial–es donde comienza la ejecucion del programa. Cualquier cosa que
   haga @c(main) es lo que hara el programa. Por supuesto, @c(main) sera
   normalmente un llamado a las funciones de otros paquetes que hacen gran parte
   del trabajo, como la funcion @c(fmt.Println).

#    We must tell the compiler what packages are needed by this source file;
#    that’s the role of the @c(import) declaration that follows the @c(package)
#    declaration. The @"(hello, world) program uses only one function from one
#    other package, but most programs will import more packages.
   Debemos decirle al compilador que paquetes son necesarios para este archivo
   de codigo fuente; ese es el papel de la declaracion @c(import) seguida por la
   declaracion del @c(paquete). El programa @"(hola, mundo) utiliza solo una
   funcion de otro paquete, pero en la mayoria de los programas importaran mas
   paquetes.

#    You must import exactly the packages you need. A program will not compile if
#    there are missing imports or if there are unnecessary ones. This strict
#    requirement prevents references to unused packages from accumulating as
#    programs evolve.
   Debe importar exactamente los paquetes que necesita. Un programa no compilara
   si hay importaciones que faltan o si son innecesarias. Este estricto
   requisito impide que las referencias a paquetes no utilizados se acumulen a
   medida que los programas evolucionan.

#    The @c(import) declarations must follow the @c(package) declaration. After
#    that, a program consists of the declarations of functions, variables,
#    constants, and types (introduced by the keywords @c(func), @c(var),
#    @c(const), and @c(type)); for the most part, the order of declarations does
#    not matter. This program is about as short as possible since it declares only
#    one function, which in turn calls only one other function. To save space, we
#    will sometimes not show the @c(package) and @c(import) declarations when
#    presenting examples, but they are in the source file and must be there to
#    compile the code.
   Las declaraciones @c(import) deben ir luego de la declaracion @c(package).
   Despues de eso, un programa consiste en la declaracion de funciones,
   variables, constantes y tipos (introducidos por las palabras clave @c(func),
   @c(var), @c(const), y @c(type)); En su mayor parte, el orden de las
   declaraciones no importa. Este programa es lo mas corto posible, ya que
   declara solo una funcion, que a su vez solo llama a otra funcion. Para
   ahorrar espacio en la presentacion de ejemplos, a veces no mostramos las
   declaraciones @c(package) e @c(import), pero estaran en el codigo del archivo
   y debemos estar alli para compilar el codigo.

#    A function declaration consists of the keyword @c(func), the name of the
#    function, a parameter list (empty for @c(main)), a result list (also empty
#    here), and the body of the function—the statements that define what it
#    does—enclosed in braces. We’ll take a closer look at functions in @l(#Chapter
#    5).
   Una declaracion de funcion consiste en la palabra clave @c(func), el nombre
   de la funcion, una lista de parametros (vacia para @c(main)), una lista de
   resultados (aqui tambien vacia), y el cuerpo de la funcion–las declaraciones
   que definen lo que hace–encerradas entre llaves. Vamos a echar un vistazo mas
   de cerca a las funciones en el @l(#Capitulo 5).

#    Go does not require semicolons at the ends of statements or declarations,
#    except where two or more appear on the same line. In effect, newlines
#    following certain tokens are converted into semicolons, so where newlines are
#    placed matters to proper parsing of Go code. For instance, the opening brace
#    @c({) of the function must be on the same line as the end of the @c(func)
#    declaration, not on a line by itself, and in the expression @c(x + y), a newline
#    is permitted after but not before the @c(+) operator.
   Go no requiere punto y coma al final de las sentencias o declaraciones,
   excepto donde aparecen dos o mas en la misma linea. En efecto, las nuevas
   lineas que siguen ciertas palabras se convierten en punto y coma, por lo que
   cuando se colocan nuevas lineas se colocan en funcion del correcto analisis
   del codigo Go. Por ejemplo, la llave de apertura @c({) de la funcion, debe
   estar en la misma linea, que el final de la declaracion @c(func), no en una
   linea distinta, y en la expresion @c(x + y), se permite un salto de linea
   despues, pero no antes del operador @c(+).

#    Go takes a strong stance on code formatting. The @$(gofmt) tool rewrites code
#    into the standard format, and the @$(go) tool’s @$(fmt) subcommand applies
#    @$(gofmt) to all the files in the specified package, or the ones in the
#    current directory by default. All Go source files in the book have been run
#    through @$(gofmt), and you should get into the habit of doing the same for
#    your own code.  Declaring a standard format by fiat eliminates a lot of
#    pointless debate about trivia and, more importantly, enables a variety of
#    automated source code transformations that would be infeasible if arbitrary
#    formatting were allowed.
   Go toma una fuerte postura en el formato del codigo. La herramienta @$(gofmt)
   reescribe el codigo en el formato estandar, y el subcomando @$(fmt) de la
   herramienta @$(go) aplica @$(gofmt) a todos los archivos en el paquete
   especificado, o por defecto, a los que estan en el directorio actual.  Se ha
   ejecutado @$(gofmt) sobre todos los archivos de codigo fuente en el libro, y
   usted debe optener el habito de hacer lo mismo con su propio codigo. Declarar
   un formato estandar por mandato elimina un monton de debate inutil sobre
   trivialidades y, lo que es mas importante, permite una variedad de
   transformaciones automatizadas de codigo fuente que serian imposibles si se
   permitiera el formato arbitrario.

#    Many text editors can be configured to run @$(gofmt) each time you save a
#    file, so that your source code is always properly formatted. A related tool,
#    @$(goimports), additionally manages the insertion and removal of import
#    declarations as needed. It is not part of the standard distribution but you
#    can obtain it with this command:
   Muchos editores de texto pueden ser configurados para ejecutar @$(gofmt) cada
   vez que se guarda un archivo, por lo que su codigo fuente siempre tendra el
   formato apropiado. Una herramienta relacionada, @$(goimports), ademas,
   gestiona la insercion y extraccion de las declaraciones de importacion, segun
   sea necesario. No es parte de la distribucion estandar pero se puede obtener
   con este comando:

#    ..src > sh
#      $ go get golang.org/x/tools/cmd/goimports
#    < src..
   ..src > sh
     $ go get golang.org/x/tools/cmd/goimports
   < src..

#    For most users, the usual way to download and build packages, run their
#    tests, show their documentation, and so on, is with the @$(go) tool, which
#    we’ll look at in @l(#Section 10.7).
   Para la mayoria de los usuarios, la forma habitual de descargar y construir
   paquetes, ejecutar pruebas, mostrar su documentacion, y asi sucesivamente, es
   con la herramienta @$(go), que vamos a ver en la @l(#Seccion 10.7).

# ** Section 1.2 <> Command-Line Arguments
** Seccion 1.2 <> Argumentos de Linea de Comandos

#    Most programs process some input to produce some output; that’s pretty much
#    the definition of computing. But how does a program get input data on which
#    to operate? Some programs generate their own data, but more often, input
#    comes from an external source: a file, a network connection, the output of
#    another program, a user at a keyboard, command-line arguments, or the like.
#    The next few examples will discuss some of these alternatives, starting with
#    command-line arguments.
   La mayoria de los programas procesan alguna entrada para producir alguna
   salida; Que es mas o menos la definicion de la computacion. Pero, ¿como un
   programa obtiene datos de entrada para operar? Algunos programas generan sus
   propios datos, pero mas a menudo, la entrada proviene de una fuente externa:
   un archivo, una conexion de red, la salida de otro programa, un usuario en un
   teclado, argumentos de linea de comandos o similares. Los siguientes ejemplos
   discutiran algunas de estas alternativas, comenzando con argumentos de linea
   de comandos.

#    The @c(os) package provides functions and other values for dealing with the
#    operating system in a platform-independent fashion. Command-line arguments
#    are available to a program in a variable named @c(Args) that is part of the
#    @c(os) package; thus its name anywhere outside the @c(os) package is
#    @c(os.Args).
   El paquete @c(os) proporciona funciones y otros valores para relacionarse con
   el sistema operativo de una manera independiente de la plataforma. Los
   argumentos de linea de comandos estan disponibles para un programa en una
   variable denominada @c(Args) que forma parte del paquete @c(os); por lo tanto
   su nombre en cualquier lugar fuera del paquete @c(os) es @c(os.Args).

#    The variable @c(os.Args) is a @e(slice) of strings. Slices are a fundamental
#    notion in Go, and we’ll talk a lot more about them soon. For now, think of a
#    slice as a dynamically sized sequence @c(s) of array elements where
#    individual elements can be accessed as @c(s[i]) and a contiguous subsequence
#    as @c(s[m:n]). The number of elements is given by @c[len(s)]. As in most
#    other programming languages, all indexing in Go uses @e(half-open) intervals
#    that include the first index but exclude the last, because it simplifies
#    logic. For example, the slice @c(s[m:n]), where @c[0 ≤ m ≤ n ≤ len(s)],
#    contains @c(n-m) elements.
   La variable @c(os.Args) es un @e(slice) de @c(strings). Los slices son una
   nocion fundamental en Go, y hablaremos mucho mas sobre ellos pronto. Por
   ahora, piensa en un slice como una secuencia @c(s) de elementos de un arreglo
   de tamaño dinamico, donde los elementos individuales pueden accederse como
   @c(s[i]) y una subsecuencia contigua como @c(s[m:n]). El numero de elementos esta
   dado por @c[len(s)]. Como en la la mayoria de los otros lenguajes de
   programacion, toda  indexacion en Go utiliza intervalos @e(semiabiertos)
   que incluyen el primer indice, pero no incluyen el ultimo, ya que simplifica
   la logica. Por ejemplo, el slice  @c(s[m:n]), donde @c[0 ≤ m ≤ n ≤ len(s)],
   contiene @c(n-m) elementos.

#    The first element of @c(os.Args), @c(os.Args[0]), is the name of the command
#    itself; the other elements are the arguments that were presented to the
#    program when it started execution. A slice expression of the form @c(s[m:n])
#    yields a slice that refers to elements @c(m) through @c(n-1), so the elements
#    we need for our next example are those in the slice
#    @c{os.Args[1:len(os.Args)]}. If @c(m) or @c(n) is omitted, it defaults to 0
#    or @c[len(s)] respectively, so we can abbreviate the desired slice as
#    @c(os.Args[1:]).
   El primer elemento de @c(os.Args), @c(os.Args[0]), es el nombre del comando
   en si; Los otros elementos son los argumentos que se ofresieron al programa
   cuando se inicio la ejecucion. Una expresion de la forma @c(s[m:n]) produce
   un slice que hace referencia a los elementos entre @c(m) y @c(n-1), por lo
   que los elementos que necesitamos para nuestro siguiente ejemplo corresponden
   al slice @c{os.Args[1:len(os.Args)]}. Si @c(m) o @c(n) se omite, el valor
   predeterminado es 0 o @c[len(s)], respectivamente, por lo que se puede
   abreviar el slice deseado como @c(os.Args[1:]).

#    Here’s an implementation of the Unix @$(echo) command, which prints its
#    command-line arguments on a single line. It imports two packages, which are
#    given as a parenthesized list rather than as individual import declarations.
#    Either form is legal, but conventionally the list form is used. The order of
#    imports doesn’t matter; the @$(gofmt) tool sorts the package names into
#    alphabetical order. (When there are several versions of an example, we will
#    often number them so you can be sure of which one we’re talking about.)
   Aqui esta una implementacion del comando @$(echo) de Unix, que imprime sus
   argumentos de linea de comandos en una sola linea. Importa dos paquetes, que
   se dan como una lista entre parentesis en lugar de como declaraciones de
   importacion individuales. Cualquiera de las formas es legal, pero
   convencionalmente se utiliza el formato de lista. El orden de las
   importaciones no importa; la herramienta @$(gofmt) ordena los nombres de los
   paquetes en orden alfabetico. (Cuando hay varias versiones de un ejemplo, a
   menudo las numeraremos para que pueda estar seguro de cual estamos hablando.)

#    ..figure > @l(gopl.io/ch1/echo1/main.go<>gopl.io/ch1/echo1)
   ..figure > @l(gopl.io/ch1/echo1/main.go<>gopl.io/ch1/echo1)

#      ..src > go
#        // Echo1 prints its command-line arguments.
#        package main
#
#        import (
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          var s, sep string
#          for i := 1; i < len(os.Args); i++ {
#            s += sep + os.Args[i]
#            sep = " "
#          }
#          fmt.Println(s)
#        }
#      < src..
     ..src > go
       // Echo1 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         var s, sep string
         for i := 1; i < len(os.Args); i++ {
           s += sep + os.Args[i]
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


#    Comments begin with @c(//). All text from a @c(//) to the end of the line is
#    commentary for programmers and is ignored by the compiler. By convention, we
#    describe each package in a comment immediately preceding its package
#    declaration; for a @c(main) package, this comment is one or more complete
#    sentences that describe the program as a whole.
   Los comentarios comienzan con @c(//). Todo el texto desde @c(//) hasta el
   final de la linea es el comentario para los programadores y es ignorado por
   el compilador. Por convencion, describimos cada paquete en un comentario
   inmediatamente anterior a su declaracion del paquete; para un paquete
   @c(main), este comentario es una o varias frases completas que describen el
   programa en su conjunto.

#    The @c(var) declaration declares two variables @c(s) and @c(sep), of type
#    @c(string). A variable can be initialized as part of its declaration. If it
#    is not explicitly initialized, it is implicitly initialized to the @e(zero
#    value) for its type, which is @c(0) for numeric types and the empty string
#    @c("") for strings.  Thus in this example, the declaration implicitly
#    initializes @c(s) and @c(sep) to empty strings. We’ll have more to say about
#    variables and declarations in @l(#Chapter 2).
   La declaracion @c(var) declara dos variables @c(s) y @c(sep), de tipo
   @c(string). Una variable se puede inicializar como parte de su declaracion.
   Si no se inicia de forma explicita, se inicializa de forma implicita al
   @e(valor cero) para su tipo, que es 0 para los tipos numericos y la cadena
   vacia @c("") para strings. Asi, en este ejemplo, la declaracion implicita
   inicializa @c(s) y @c(sep) como cadenas vacias. Tendremos mas que decir
   acerca de las variables y las declaraciones en el @l(#Capitulo 2).

#    For numbers, Go provides the usual arithmetic and logical operators. When
#    applied to strings, however, the @c(+) operator @e(concatenates) the values,
#    so the expression
   Para los numeros, Go proporciona los operadores aritmeticos y logicos
   habituales. Cuando se aplica a las cadenas, sin embargo, el operador @c(+)
   @e(concatena) los valores, por lo que la expresion

#    ..src > go
#      sep + os.Args[i]
#    < src..
   ..src > go
     sep + os.Args[i]
   < src..

#    represents the concatenation of the strings @c(sep) and @c(os.Args[i]). The
#    statement we used in the program,
   representa la concatenacion de las cadenas @c(sep) y @c(os.Args[i]). La
   declaracion que usamos en el programa,

#    ..src > go
#      s += sep + os.Args[i]
#    < src..
   ..src > go
     s += sep + os.Args[i]
   < src..

#    is an @e(assignment statement) that concatenates the old value of @c(s) with
#    @c(sep) and @c(os.Args[i]) and assigns it back to @c(s); it is equivalent to
   es una @e(sencencia de asignacion) que concatena el antiguo valor de @c(s) con @c(sep)
   y @c(os.Args[i]) y lo asigna de nuevo a @c(s); Es equivalente a

#    ..src > go
#      s = s + sep + os.Args[i]
#    < src..
   ..src > go
     s = s + sep + os.Args[i]
   < src..

#    The operator @c(+=) is an @e(assignment operator). Each arithmetic and logical
#    operator like @c(+) or @c(*) has a corresponding assignment operator.
   El operador @c(+=) es un operador de asignacion. Cada operador aritmetico y
   logico como @c(+) o @c(*) tiene un operador de asignacion correspondiente.

#    The @$(echo) program could have printed its output in a loop one piece at a
#    time, but this version instead builds up a string by repeatedly appending new
#    text to the end. The string @c(s) starts life empty, that is, with value
#    @c(""), and each trip through the loop adds some text to it; after the first
#    iteration, a space is also inserted so that when the loop is finished, there
#    is one space between each argument. This is a quadratic process that could be
#    costly if the number of arguments is large, but for @$(echo), that’s
#    unlikely. We’ll show a number of improved versions of @$(echo) in this
#    chapter and the next that will deal with any real inefficiency.
   El programa @$(echo) podria haber impreso su salida en un bucle de una sola
   pieza a la vez, pero en esta version, en su lugar se acumula una cadena
   añadiendo repetidamente nuevo texto hasta el final. La cadena de @c(s)
   comienza su vida vacia, es decir, con el valor @c(""), y cada ciclo a traves
   del bucle añade un poco de texto a ella; Despues de la primer iteracion,
   tambien se inserta un espacio para que cuando el bucle este terminado, haya
   un espacio entre cada argumento. Este es un proceso cuadratico que podria ser
   costoso si el numero de argumentos es grande, pero para @$(echo), eso es poco
   probable. Vamos a mostrar una serie de versiones mejoradas de @$(echo) en
   este capitulo y el siguiente para hacer frente a cualquier ineficiencia real.

#    The loop index variable @c(i) is declared in the first part of the @c(for)
#    loop. The @c(:=) symbol is part of a @e(short variable declaration), a
#    statement that declares one or more variables and gives them appropriate
#    types based on the initializer values; there’s more about this in the next
#    chapter.
   El indice variable @c(i) del bucle se declara en la primer parte del bucle
   @c(for). El simbolo @c(:=) es parte de una @e(declaracion de variables
   compacta), una sentencia que declara una o mas variables y les da los tipos
   apropiados basados en los valores del inicializador; Hay mas informacion al
   respecto en el proximo capitulo.

#    The increment statement @c(i++) adds 1 to @c(i); it’s equivalent to @c(i
#    += 1) which is in turn equivalent to @c(i = i + 1). There’s a corresponding
#    decrement statement @c(i--) that subtracts 1. These are statements, not
#    expressions as they are in most languages in the C family, so @c(j = i++) is
#    illegal, and they are postfix only, so @c(--i) is not legal either.
   La declaracion de incremento @c(i++) añade 1 a @c(i); que es equivalente a
   @c(i += 1), que es a su vez equivalente a @c(i = i + 1). Hay una declaracion
   de decremento correspondiente @c(i--) que resta 1. Estas son declaraciones,
   no expresiones como lo son en la mayoria de los lenguajes en la familia C,
   por lo que @c(j = i++) es ilegal, y solamente son de sufijo, asi @c(--i)
   tampoco es legal.

#    The @c(for) loop is the only loop statement in Go. It has a number of forms,
#    one of which is illustrated here:
   El bucle @c(for) es la unica sentencia de bucle en Go. Tiene una serie de formas,
   una de las cuales se ilustra aqui:

#    ..src > go
#      for initialization; condition; post {
#          // zero or more statements
#      }
#    < src..
   ..src > go
     for inicializacion; condicion; incremento {
         // cero o mas declaraciones
     }
   < src..

#    Parentheses are never used around the three components of a @c(for) loop. The
#    braces are mandatory, however, and the opening brace must be on the same line
#    as the @c(post) statement.
   Los parentesis no se utilizan nunca alrededor de los tres componentes de un
   bucle @c(for). Las llaves son obligatorias, sin embargo, y la llave de apertura
   deben estar en la misma linea que la declaracion @c(incremento).

#    The optional @c(initialization) statement is executed before the loop
#    starts. If it is present, it must be a @e(simple statement), that is, a short
#    variable declaration, an increment or assignment statement, or a function
#    call. The @c(condition) is a boolean expression that is evaluated at the
#    beginning of each iteration of the loop; if it evaluates to @c(true), the
#    statements controlled by the loop are executed. The @c(post) statement is
#    executed after the body of the loop, then the condition is evaluated
#    again. The loop ends when the condition becomes false.
   La declaracion opcional @c(inicializacion) se ejecuta antes de que comience
   el bucle. Si esta presente, debe ser una simple declaracion, es decir, una
   declaracion de variables compacta, una declaracion de incremento o asignacion, o
   una llamada a funcion. La @c(condition) es una expresion booleana que se
   evalua en al inicio de cada iteracion del bucle; si se evalua como @c(true),
   las declaraciones controladas por el bucle se ejecutan. La declaracion
   @c(incremento) se ejecuta despues del cuerpo del bucle, luego la
   @c(condicion) se evalua de nuevo. El bucle termina cuando la condicion se
   convierte en falsa.

#    Any of these parts may be omitted. If there is no @c(initialization) and no @c(post),
#    the semicolons may also be omitted:
   Cualquiera de estas partes puede omitirse. Si no hay @c(inicializacion) y
   ningun @c(incremento), el punto y coma tambien pueden omitirse:

#    ..src > go
#      // a traditional "while" loop
#      for condition {
#          // ...
#      }
#    < src..
   ..src > go
     // un tradicional bucle "while"
     for condicion {
         // ...
     }
   < src..

#    If the condition is omitted entirely in any of these forms, for example in
   Si la condicion se omite totalmente en cualquiera de estas formas, por
   ejemplo en

#    ..src > go
#      // a traditional infinite loop
#      for {
#          // ...
#      }
#    < src..
   ..src > go
     // un tradicional bucle infinito
     for {
         // ...
     }
   < src..

#    the loop is infinite, though loops of this form may be terminated in some
#    other way, like a @c(break) or @c(return) statement.
   el bucle es infinito, aunque los bucles de esta forma se pueden terminar de
   alguna otra forma, como una declaracion @c(break) o @c(return).

#    Another form of the @c(for) loop iterates over a @e(range) of values from a
#    data type like a string or a slice. To illustrate, here’s a second version of
#    @$(echo):
   Otra forma en que el bucle @c(for) itera, es sobre un @e(rango) de valores de
   un tipo de datos como un string o un slice. Para ilustrar esto, he aqui una
   segunda version de @$(echo):

#    ..figure > @l(gopl.io/ch1/echo2/main.go<>gopl.io/ch1/echo2)
   ..figure > @l(gopl.io/ch1/echo2/main.go<>gopl.io/ch1/echo2)

#      ..src > go
#        // Echo2 prints its command-line arguments.
#        package main
#
#        import (
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          s, sep := "", ""
#          for _, arg := range os.Args[1:] {
#            s += sep + arg
#            sep = " "
#          }
#          fmt.Println(s)
#        }
#      < src..
     ..src > go
       // Echo2 imprime sus argumentos de linea de comandos
       package main

       import (
         "fmt"
         "os"
       )

       func main() {
         s, sep := "", ""
         for _, arg := range os.Args[1:] {
           s += sep + arg
           sep = " "
         }
         fmt.Println(s)
       }
     < src..


#    In each iteration of the loop, @c(range) produces a pair of values: the index and
#    the value of the element at that index. In this example, we don’t need the
#    index, but the syntax of a @c(range) loop requires that if we deal with the
#    element, we must deal with the index too. One idea would be to assign the
#    index to an obviously temporary variable like @c(temp) and ignore its value, but
#    Go does not permit unused local variables, so this would result in a
#    compilation error.
   En cada iteracion del bucle, @c(range) produce un par de valores: el indice y
   el valor del elemento en ese indice. En este ejemplo, no necesitamos el
   indice, pero la sintaxis de un bucle @c(range) requiere que si tratamos con
   el elemento, debemos tratar tambien con el indice. Una idea seria asignar el
   indice a una variable temporal, como @c(temp) y pasar por alto su valor, pero
   Go no permite tener variables locales sin utilizar, por lo que esto daria
   lugar a un error de compilacion.

#    The solution is to use the @e(blank identifier), whose name is @c(_) (that
#    is, an underscore). The blank identifier may be used whenever syntax requires
#    a variable name but program logic does not, for instance to discard an
#    unwanted loop index when we require only the element value. Most Go
#    programmers would likely use @c(range) and @c(_) to write the @$(echo)
#    program as above, since the indexing over @c(os.Args) is implicit, not
#    explicit, and thus easier to get right.
   La solucion es utilizar el @e(identificador en blanco), cuyo nombre es @c(_)
   (esto es, un guion bajo). El identificador en blanco puede utilizarse siempre
   que la sintaxis requiera un nombre de variable, pero la logica del programa
   no lo haga, por ejemplo para descartar un indice no deseado del bucle cuando
   solo necesitamos el valor del elemento. La mayoria de los programadores Go
   probablemente usarian @c(range) y @c(_) para escribir el programa @$(echo)
   anterior, ya que la indexacion sobre @c(os.Args) es implicita, no explicita,
   y por lo tanto mas facil de hacerlo bien.

#    This version of the program uses a short variable declaration to declare and
#    initialize @c(s) and @c(sep), but we could equally well have declared the
#    variables separately. There are several ways to declare a string variable;
#    these are all equivalent:
   Esta version del programa utiliza una breve declaracion de variables para
   declarar e inicializar @c(s) y @c(sep), pero podria igualmente haber declarado las
   variables por separado. Hay varias maneras de declarar una variable de
   cadena; Todas estas son equivalentes:

#    ..src > go
#      s := ""
#      var s string
#      var s = ""
#      var s string = ""
#    < src..
   ..src > go
     s := ""
     var s string
     var s = ""
     var s string = ""
   < src..

#    Why should you prefer one form to another? The first form, a short variable
#    declaration, is the most compact, but it may be used only within a function,
#    not for package-level variables.  The second form relies on default
#    initialization to the zero value for strings, which is @c(""). The third form is
#    rarely used except when declaring multiple variables. The fourth form is
#    explicit about the variable’s type, which is redundant when it is the same as
#    that of the initial value but necessary in other cases where they are not of
#    the same type. In practice, you should generally use one of the first two
#    forms, with explicit initialization to say that the initial value is
#    important and implicit initialization to say that the initial value doesn’t
#    matter.
   Por que usted deberia preferir una forma sobre otra? El primer formato, una
   declaracion de variable compacta, es el mas compacto, pero puede ser utilizado
   solo dentro de una funcion, no para variables de nivel de paquete. La segunda
   forma se basa en la inicializacion por defecto al valor cero para strings,
   que es @c(""). La tercera forma se utiliza raramente excepto cuando se
   declaran multiples variables. La cuarta forma es explicita sobre el tipo de
   la variable, que es redundante cuando es el mismo que el del valor inicial
   pero necesario en otros casos donde no son del mismo tipo. En la practica,
   generalmente debe utilizar una de las dos primeras formas, con inicializacion
   explicita para decir que el valor inicial es importante e implicita para
   decir que el valor inicial no importa.

#    As noted above, each time around the loop, the string @c(s) gets completely
#    new contents. The @c(+=) statement makes a new string by concatenating the
#    old string, a space character, and the next argument, then assigns the new
#    string to @c(s). The old contents of @c(s) are no longer in use, so they will
#    be garbage-collected in due course.
   Como se señalo anteriormente, cada iteracion alrededor del bucle, la cadena
   @c(s) obtiene contenidos completamente nuevos. La declaracion @c(+=) crea una
   nueva cadena mediante la concatenacion de la cadena antigua, un caracter de
   espacio, y el siguiente argumento, a continuacion, asigna la nueva cadena a
   @c(s). El contenido antiguo del @c(s) ya no estan en uso, por lo que sera
   recolectado por el recolector de basura en su debido momento.

#    If the amount of data involved is large, this could be costly. A simpler and
#    more efficient solution would be to use the @c(Join) function from the @c(strings)
#    package:
   Si la cantidad de datos involucrados es grande, esto podria ser costoso. Una
   solucion mas simple y mas eficiente seria utilizar la funcion @c(Join) del
   paquete @c(strings):

#    ..figure > @l(gopl.io/ch1/echo3/main.go<>gopl.io/ch1/echo3)
   ..figure > @l(gopl.io/ch1/echo3/main.go<>gopl.io/ch1/echo3)

#      ..src > go
#        func main() {
#          fmt.Println(strings.Join(os.Args[1:], " "))
#        }
#      < src..
     ..src > go
       func main() {
         fmt.Println(strings.Join(os.Args[1:], " "))
       }
     < src..


#    Finally, if we don’t care about format but just want to see the values,
#    perhaps for debugging, we can let @c(Println) format the results for us:
   Por ultimo, si no nos interesa el formato, y solo queremos ver los valores,
   tal vez para depuracion, podemos dejar que @c(Println) formatee el resultado por
   nosotros:

#    ..src > go
#      fmt.Println(os.Args[1:])
#    < src..
   ..src > go
     fmt.Println(os.Args[1:])
   < src..

#    The output of this statement is like what we would get from @c(strings.Join),
#    but with surrounding brackets. Any slice may be printed this way.
   El resultado de esta sentencia es como la que se puede conseguir mediante
   @c(strings.Join), pero con corchetes al rededor. Cualquier slice se puede
   imprimir de esta manera.

#    @b(Exercise 1.1): Modify the @$(echo) program to also print @c(os.Args[0]),
#    the name of the command that invoked it.
   @b(Ejercicio 1.1): Modificar el programa @$(echo) para imprimir tambien
   @c(os.Args[0]), el nombre del comando que lo invoco.

#    @b(Exercise 1.2): Modify the @$(echo) program to print the index and value of
#    each of its arguments, one per line.
   @b(Ejercicio 1.2): Modificar el programa @$(echo) para imprimir el indice y el
   valor de cada uno de sus argumentos, uno por linea.

#    @b(Exercise 1.3): Experiment to measure the difference in running time
#    between our potentially inefficient versions and the one that uses
#    @c(strings.Join). (@l(#Section 1.6) illustrates part of the @c(time) package,
#    and @l(#Section 11.4) shows how to write benchmark tests for systematic
#    performance evaluation.)
   @b(Ejercicio 1.3): Experimente para medir la diferencia en el tiempo de
   funcionamiento entre nuestras versiones potencialmente ineficientes y el que
   utiliza @c(strings.Join). ( La @l(#Seccion 1.6) ilustra parte del paquete
   @c(time), y la @l(#Seccion 11.4) muestra como escribir pruebas de referencia
   para la evaluacion sistematica del rendimiento.)

# ** Section 1.3 <> Finding Duplicate Lines
** Seccion 1.3 <> Encontrar lineas duplicadas

#    Programs for file copying, printing, searching, sorting, counting, and the
#    like all have a similar structure: a loop over the input, some computation on
#    each element, and generation of output on the fly or at the end. We’ll show
#    three variants of a program called @$(dup); it is partly inspired by the Unix
#    @$(uniq) command, which looks for adjacent duplicate lines. The structures
#    and packages used are models that can be easily adapted.
   Los programas para copiar archivos, imprimir, buscar, clasificar, contar y
   similares tienen una estructura similar: un bucle sobre la entrada, algun
   calculo sobre cada elemento y generacion de salida al vuelo o al final.
   Mostraremos tres variantes de un programa llamado @$(dup); se inspira en
   parte por el comando Unix @$(uniq), que mira las lineas duplicadas
   adyacentes. Las estructuras y paquetes utilizados son modelos que se pueden
   adaptar facilmente.

#    The first version of @$(dup) prints each line that appears more than once in the
#    standard input, preceded by its count. This program introduces the @c(if)
#    statement, the @$(map) data type, and the @c(bufio) package.
   La primer version de @$(dup) imprime cada linea que aparece mas de una vez en
   la entrada estandar, precedido por su recuento. Este programa presenta la
   declaracion @c(if), el tipo de datos @c(map) y el paquete @c(bufio).

#    ..figure > @l(gopl.io/ch1/dup1/main.go<>gopl.io/ch1/dup1)
   ..figure > @l(gopl.io/ch1/dup1/main.go<>gopl.io/ch1/dup1)

#      ..src > go
#        // Dup1 prints the text of each line that appears more than
#        // once in the standard input, preceded by its count.
#        package main
#
#        import (
#          "bufio"
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          input := bufio.NewScanner(os.Stdin)
#          for input.Scan() {
#            counts[input.Text()]++
#          }
#          // NOTE: ignoring potential errors from input.Err()
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#      < src..
     ..src > go
       // Dup1 imprime el texto de cada linea que aparece mas de
       // una vez en la entrada estandar, precedida por su recuento.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         input := bufio.NewScanner(os.Stdin)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTA: ignorando posibles errores de input.Err ()
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


#    As with @c(for), parentheses are never used around the condition in an @c(if)
#    statement, but braces are required for the body. There can be an optional
#    @c(else) part that is executed if the condition is false.
   Al igual que con @c(for), nunca se usan parentesis alrededor de la
   declaracion de la condicion @c(if), pero se requieren llaves para el
   cuerpo. Puede haber una parte @c(else) opcional que se ejecute si la
   condicion es falsa.

#    A @e(map) holds a set of key/value pairs and provides constant-time
#    operations to store, retrieve, or test for an item in the set. The key may be
#    of any type whose values can compared with @c(==), strings being the most
#    common example; the value may be of any type at all. In this example, the
#    keys are @c(string)s and the values are @c(int)s. The built-in function
#    @c(make) creates a new empty map; it has other uses too. Maps are discussed
#    at length in @l(#Section 4.3).
   Un @e(mapa) contiene un conjunto de pares clave/valor y proporciona
   operaciones de tiempo constante para almacenar, recuperar, o comprobar un
   elemento en el conjunto. La clave puede ser de cualquier tipo cuyos valores
   puedan compararse con @c(==), siendo strings el ejemplo mas comun; El valor
   puede ser de cualquier tipo en absoluto. En este ejemplo, las claves son
   @c(string)s, y los valores son @c(int)s. La funcion incorporada @c(make) crea
   un nuevo mapa vacio; Tiene otros usos tambien. Los mapas se discuten
   extensamente en la @l(#Seccion 4.3).

#    Each time @$(dup) reads a line of input, the line is used as a key into the
#    map and the corresponding value is incremented. The statement
#    @c{counts[input.Text()]++} is equivalent to these two statements:
   Cada vez que @$(dup) lee una linea de entrada, la linea se utiliza como una
   clave en el mapa y se incrementa el valor correspondiente. La declaracion
   @c{counts[input.Text()]++} es equivalente a estas dos afirmaciones:

#    ..src > go
#      line := input.Text()
#      counts[line] = counts[line] + 1
#    < src..
   ..src > go
     line := input.Text()
     counts[line] = counts[line] + 1
   < src..

#    It’s not a problem if the map doesn’t yet contain that key. The first time a
#    new line is seen, the expression @c(counts[line]) on the right-hand side
#    evaluates to the zero value for its type, which is 0 for @c(int).
   No es un problema, si el mapa aun no contiene esa clave. La primera vez que
   se ve una nueva linea, la expresion @c(counts[line]) en el lado derecho se
   evalua al valor cero para su tipo, que es 0 para @c(int).

#    To print the results, we use another @c(range)-based @c(for) loop, this time
#    over the @c(counts) map. As before, each iteration produces two results, a
#    key and the value of the map element for that key. The order of map iteration
#    is not specified, but in practice it is random, varying from one run to
#    another. This design is intentional, since it prevents programs from relying
#    on any particular ordering where none is guaranteed.
   Para imprimir los resultados, utilizamos otro bucle de repeticion @c(for)
   basado en @c(range), esta vez sobre el mapa @c(counts). Como antes, cada
   iteracion produce dos resultados, una clave y el valor del elemento del mapa
   para esa clave. El orden de la iteracion del mapa no es especifico, en la
   practica es aleatorio, variando de una ejecucion a otra. Este diseño es
   intencional, ya que impide que los programas se basen en cualquier orden
   particular donde no se garantiza ninguno.

#    Onward to the @c(bufio) package, which helps make input and output efficient and
#    convenient.  One of its most useful features is a type called @c(Scanner) that
#    reads input and breaks it into lines or words; it’s often the easiest way to
#    process input that comes naturally in lines.
   El paquete @c(bufio), ayuda a que la entrada y salida sea eficiente y
   conveniente. Una de sus caracteristicas mas utiles es un tipo llamado
   @c(Scanner) que lee la entrada y la rompe en lineas o palabras; A menudo es
   la manera mas facil de procesar la entrada que llega naturalmente en lineas.

#    The program uses a short variable declaration to create a new variable input
#    that refers to a @c(bufio.Scanner):
   El programa utiliza una breve declaracion de variables para crear una nueva
   variable de entrada que hace referencia a @c(bufio.Scanner):

#    ..src > go
#      input := bufio.NewScanner(os.Stdin)
#    < src..
   ..src > go
     input := bufio.NewScanner(os.Stdin)
   < src..

#    The scanner reads from the program’s standard input. Each call to
#    @c[input.Scan()] reads the next line and removes the newline character from
#    the end; the result can be retrieved by calling @c[input.Text()]. The
#    @c(Scan) function returns @c(true) if there is a line and @c(false) when
#    there is no more input.
   El escaner lee de la entrada estandar del programa. Cada llamada a
   @c[input.Scan()] lee la siguiente linea y elimina el caracter de nueva linea
   al final; el resultado puede ser recuperado llamando a @c[input.Text()]. La
   funcion @c(Scan) devuelve @c(true) si hay una linea y @c(false) cuando no hay
   mas entrada.

#    The function @c(fmt.Printf), like @c(printf) in C and other languages,
#    produces formatted output from a list of expressions. Its first argument is a
#    format string that specifies how subsequent arguments should be
#    formatted. The format of each argument is determined by a conversion
#    character, a letter following a percent sign. For example, @c(%d) formats an
#    integer operand using decimal notation, and @c(%s) expands to the value of a
#    string operand.
   La funcion @c(fmt.Printf), como @c(printf) en C y otros lenguajes, produce
   una salida con formato de una lista de expresiones. Su primer argumento es
   una cadena de formato que especifica como deben formatearse los argumentos
   posteriores. El formato de cada argumento esta determinado por un caracter de
   conversion, una letra siguiendo un signo de porcentaje. Por ejemplo, @c(%d)
   formatea un operando entero usando la notacion decimal, y @c(%s) se expande
   para el valor de un operando de cadena.

#    @c(Printf) has over a dozen such conversions, which Go programmers call
#    @e(verbs). This table is far from a complete specification but illustrates
#    many of the features that are available:
   @c(Printf) tiene mas de una docena de estas conversiones, que los
   programadores de Go llaman @e(verbos). Esta tabla esta lejos de ser una
   especificacion completa, pero ilustra muchas de las caracteristicas que estan
   disponibles:

#    | @c(%d)                 | decimal integer                                                |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%x), @c(%o), @c(%b) | integer in hexadecimal, octal, binary                          |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%f), @c(%g), @c(%e) | floating-point number: 3.141593 3.141592653589793 3.141593e+00 |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%t)                 | boolean: @c(true) or @c(false)                                 |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%c)                 | rune (Unicode code point)                                      |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%s)                 | string                                                         |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%q)                 | quoted string @c("abc") or rune @c('c')                        |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%v)                 | any value in a natural format                                  |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%T)                 | type of any value                                              |
#    |------------------------|----------------------------------------------------------------|
#    | @c(%%)                 | literal percent sign (no operand)                              |
   | @c(%d)                 | entero decimal                                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%x), @c(%o), @c(%b) | entero en hexadecimal, octal, binario                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%f), @c(%g), @c(%e) | numero de coma flotante: 3.141593 3.141592653589793 3.141593e + 00 |
   |------------------------|--------------------------------------------------------------------|
   | @c(%t)                 | booleano: @c(true) o @c(false)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%c)                 | runa (punto de codigo Unicode)                                     |
   |------------------------|--------------------------------------------------------------------|
   | @c(%s)                 | string                                                             |
   |------------------------|--------------------------------------------------------------------|
   | @c(%q)                 | citar string @c("abc") o runa @c('c')                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%v)                 | cualquier valor en un formato natural                              |
   |------------------------|--------------------------------------------------------------------|
   | @c(%T)                 | cualquier tipo de valor                                            |
   |------------------------|--------------------------------------------------------------------|
   | @c(%%)                 | signo literal de porcentaje (sin operando)                         |

#    The format string in @c(dup1) also contains a tab @c(\t) and a newline
#    @c(\n). String literals may contain such @e(escape sequences) for
#    representing otherwise invisible characters. @c(Printf) does not write a
#    newline by default. By convention, formatting functions whose names end in
#    @c(f), such as @c(log.Printf) and @c(fmt.Errorf), use the formatting rules of
#    @c(fmt.Printf), whereas those whose names end in @c(ln) follow @c(Println),
#    formatting their arguments as if by @c(%v), followed by a newline.
   El formato de cadena en @c(dup1) tambien contiene una tabulacion @c(\t) y un
   salto de linea @c(\n). Los literales de cadena pueden contener tales
   @e(secuencias de escape) para la representacion de caracteres de otra manera
   invisibles. @c(Printf) no escribe una nueva linea por defecto. Por
   convencion, las funciones de formato cuyos nombres terminan en @c(f), tales
   como @c(log.Printf) y @c(fmt.Errorf), utilizan las reglas de formato de
   @c(fmt.Printf), mientras que aquellas cuyos nombres terminan en @c(ln) como
   @c(Println), formatean sus argumentos con @c(%v), seguido por una nueva
   linea.

#    Many programs read either from their standard input, as above, or from a
#    sequence of named files. The next version of @c(dup) can read from the
#    standard input or handle a list of file names, using @c(os.Open) to open each
#    one:
   Muchos programas leen ya sea a partir de su entrada estandar, como
   anteriormente, o de una secuencia de archivos con nombre. La proxima version
   de @$(dup) puede leer desde la entrada estandar o manejar una lista de
   nombres de archivos, utilizando @c(os.Open) para abrir cada uno de ellos:

#    ..figure > @l(gopl.io/ch1/dup2/main.go<>gopl.io/ch1/dup2)
   ..figure > @l(gopl.io/ch1/dup2/main.go<>gopl.io/ch1/dup2)

#      ..src > go
#        // Dup2 prints the count and text of lines that appear more than once
#        // in the input.  It reads from stdin or from a list of named files.
#        package main
#
#        import (
#          "bufio"
#          "fmt"
#          "os"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          files := os.Args[1:]
#          if len(files) == 0 {
#            countLines(os.Stdin, counts)
#          } else {
#            for _, arg := range files {
#              f, err := os.Open(arg)
#              if err != nil {
#                fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
#                continue
#              }
#              countLines(f, counts)
#              f.Close()
#            }
#          }
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#
#        func countLines(f *os.File, counts map[string]int) {
#          input := bufio.NewScanner(f)
#          for input.Scan() {
#            counts[input.Text()]++
#          }
#          // NOTE: ignoring potential errors from input.Err()
#        }
#      < src..
     ..src > go
       // Dup2 imprime el recuento y el texto de las lineas que aparecen mas de una vez
       // en la entrada.  Se lee desde stdin o desde una lista de archivos con nombre.
       package main

       import (
         "bufio"
         "fmt"
         "os"
       )

       func main() {
         counts := make(map[string]int)
         files := os.Args[1:]
         if len(files) == 0 {
           countLines(os.Stdin, counts)
         } else {
           for _, arg := range files {
             f, err := os.Open(arg)
             if err != nil {
               fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
               continue
             }
             countLines(f, counts)
             f.Close()
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }

       func countLines(f *os.File, counts map[string]int) {
         input := bufio.NewScanner(f)
         for input.Scan() {
           counts[input.Text()]++
         }
         // NOTE: Ignora errores potenciales de input.Err()
       }
     < src..


#    The function @c(os.Open) returns two values. The first is an open file
#    (@c(*os.File)) that is used in subsequent reads by the @c(Scanner).
   La funcion @c(os.Open) devuelve dos valores. El primero es un archivo abierto
   (@c(*os.File)) que se utiliza en lecturas posteriores por @c(Scanner).

#    The second result of @c(os.Open) is a value of the built-in @c(error)
#    type. If @c(err) equals the special built-in value @c(nil), the file was
#    opened successfully. The file is read, and when the end of the input is
#    reached, @c(Close) closes the file and releases any resources. On the other
#    hand, if @c(err) is not @c(nil), something went wrong. In that case, the
#    error value describes the problem. Our simple-minded error handling prints a
#    message on the standard error stream using @c(Fprintf) and the verb @c(%v),
#    which displays a value of any type in a default format, and @$(dup) then
#    carries on with the next file; the @c(continue) statement goes to the next
#    iteration of the enclosing @c(for) loop.
   El segundo resultado de @c(os.Open) es un valor nativo de tipo @c(error). Si
   @c(err) es igual al valor especial nativo @c(nil), el archivo fue abierto
   correctamente. El archivo se lee, y cuando se llega al final de la entrada,
   @c(Close) cierra el archivo y libera cualquier recurso. Por otro lado, si
   @c(err) no es @c(nil), algo salio mal. En ese caso, el valor de error
   describe el problema. Nuestro sencillo manejo de errores imprime un mensaje
   en el flujo de error estandar utilizando @c(Fprintf) y el verbo @c(%v), que
   muestra un valor de cualquier tipo en un formato predeterminado, y luego
   @c(dup) continua con el siguiente archivo; la instruccion @c(continue) va a
   la siguiente iteracion del bucle @c(for).

#    In the interests of keeping code samples to a reasonable size, our early
#    examples are intentionally somewhat cavalier about error handling. Clearly we
#    must check for an error from @c(os.Open); however, we are ignoring the less
#    likely possibility that an error could occur while reading the file with
#    @c(input.Scan). We will note places where we’ve skipped error checking, and
#    we will go into the details of error handling in @l(#Section 5.4).
   Con el fin de mantener los ejemplos de codigo de un tamaño razonable,
   nuestros primeros ejemplos son intencionalmente un tanto descuidados en el
   manejo de errores. Es evidente que hay que comprobar si hay un error de parte
   de @c(os.Open); Sin embargo, estamos ignorando la menos probable posibilidad
   de que pueda producirse un error al leer el archivo con @c(input.Scan).
   Anotaremos los lugares donde hemos omitido la comprobacion de errores,
   entraremos en detalles sobre el manejo de errores en la @l(#Seccion 5.4).

#    Notice that the call to @c(countLines) precedes its declaration. Functions
#    and other package-level entities may be declared in any order.
   Observe que la llamada a @c(countLines) precede a su declaracion. Las
   funciones y otras entidades a nivel de paquete se pueden declarar en
   cualquier orden.

#    A map is a @e(reference) to the data structure created by @c(make). When a map is
#    passed to a function, the function receives a copy of the reference, so any
#    changes the called function makes to the underlying data structure will be
#    visible through the caller’s map reference too. In our example, the values
#    inserted into the counts map by @c(countLines) are seen by @c(main).
   Un mapa es una referencia a la estructura de datos creada por @c(make).
   Cuando un mapa se pasa a una funcion, la funcion recibe una copia de la
   referencia, De modo que cualquier cambio que haga la funcion llamada en la
   estructura de datos subyacente, sera tambien visible a traves de la
   referencia del mapa del llamador. En nuestro ejemplo, los valores insertados
   en el mapa @c(counts) por @c(countLines) son vistos por @c(main).

#    The versions of @$(dup) above operate in a @"(streaming) mode in which input
#    is read and broken into lines as needed, so in principle these programs can
#    handle an arbitrary amount of input. An alternative approach is to read the
#    entire input into memory in one big gulp, split it into lines all at once,
#    then process the lines. The following version, @$(dup3), operates in that
#    fashion. It introduces the function @c(ReadFile) (from the @c(io/ioutil)
#    package), which reads the entire contents of a named file, and
#    @c(strings.Split), which splits a string into a slice of substrings.
#    (@c(Split) is the opposite of @c(strings.Join), which we saw earlier.)
   Las versiones anteriores de @$(dup) operan en un modo @"(streaming) en el que
   la entrada se lee y divide en lineas segun sea necesario, por lo que, en
   principio, estos programas pueden manejar una cantidad arbitraria de
   entrada. Un enfoque alternativo es leer la entrada entera en la memoria de un
   solo trago, dividirlo en lineas a la vez, y luego procesar las lineas. La
   siguiente version, @$(dup3), funciona de esa manera. Se introduce la funcion
   @c(ReadFile) (del paquete @c(io/ioutil)), que lee todo el contenido de un
   archivo, y @c(strings.Split), que divide una cadena en un slice de
   subcadenas. (@c(Split) es lo contrario de @c(strings.Join), que vimos
   anteriormente.)

#    We’ve simplified @$(dup3) somewhat. First, it only reads named files, not the
#    standard input, since @c(ReadFile) requires a file name argument. Second, we
#    moved the counting of the lines back into @c(main), since it is now needed in
#    only one place.
   Hemos simplificado un poco @$(dup3). En primer lugar, solo lee archivos por
   su nombre, no la entrada estandar, ya que @c(ReadFile) requiere como
   argumento un nombre de archivo. En segundo lugar, se paso el conteo de las
   lineas de nuevo a @c(main), ya que ahora solo es necesario un solo lugar.

#    ..figure > @l(gopl.io/ch1/dup3/main.go<>gopl.io/ch1/dup3)
   ..figure > @l(gopl.io/ch1/dup3/main.go<>gopl.io/ch1/dup3)

#      ..src > go
#        package main
#
#        import (
#          "fmt"
#          "io/ioutil"
#          "os"
#          "strings"
#        )
#
#        func main() {
#          counts := make(map[string]int)
#          for _, filename := range os.Args[1:] {
#            data, err := ioutil.ReadFile(filename)
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
#              continue
#            }
#            for _, line := range strings.Split(string(data), "\n") {
#              counts[line]++
#            }
#          }
#          for line, n := range counts {
#            if n > 1 {
#              fmt.Printf("%d\t%s\n", n, line)
#            }
#          }
#        }
#      < src..
     ..src > go
       package main

       import (
         "fmt"
         "io/ioutil"
         "os"
         "strings"
       )

       func main() {
         counts := make(map[string]int)
         for _, filename := range os.Args[1:] {
           data, err := ioutil.ReadFile(filename)
           if err != nil {
             fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
             continue
           }
           for _, line := range strings.Split(string(data), "\n") {
             counts[line]++
           }
         }
         for line, n := range counts {
           if n > 1 {
             fmt.Printf("%d\t%s\n", n, line)
           }
         }
       }
     < src..


#    @c(ReadFile) returns a byte slice that must be converted into a @c(string) so
#    it can be split by @c(strings.Split). We will discuss strings and byte slices
#    at length in @l(#Section 3.5.4).
   @c(ReadFile) devuelve un slice de @c(byte)s que se debe convertirse en un
   @c(string) para que pueda ser dividido por @c(strings.Split). Vamos a
   discutir los strings y slices de bytes en detalle en la @l(#Seccion 3.5.4).

#    Under the covers, @c(bufio.Scanner), @c(ioutil.ReadFile), and
#    @c(ioutil.WriteFile) use the Read and Write methods of @c(*os.File), but it’s
#    rare that most programmers need to access those lower-level routines
#    directly. The higher-level functions like those from @c(bufio) and @c(io/ioutil)
#    are easier to use.
   Bajo la cubierta, @c(bufio.Scanner), @c(ioutil.ReadFile) y
   @c(ioutil.WriteFile) utilizan los metodos @c(Read) y @c(Write) de
   @c(*os.File), pero es raro que la mayoria de los programadores necesiten
   acceder directamente a las rutinas de bajo nivel. Las funciones de nivel
   superior como @c(bufio) y @c(io/ioutil) son mas faciles de usar.

#    @b(Exercise 1.4): Modify @$(dup2) to print the names of all files in which
#    each duplicated line occurs.
   @b(Ejercicio 1.4): Modificar @$(dup2) para imprimir los nombres de todos los
   archivos en los que se produce cada linea duplicada.

# ** Section 1.4 <> Animated GIFs
** Seccion 1.4 <> GIF animados

#    The next program demonstrates basic usage of Go’s standard image packages,
#    which we’ll use to create a sequence of bit-mapped images and then encode the
#    sequence as a GIF animation. The images, called @e(Lissajous figures), were a
#    staple visual effect in sci-fi films of the 1960s. They are the parametric
#    curves produced by harmonic oscillation in two dimensions, such as two sine
#    waves fed into the @m(x) and @m(y) inputs of an oscilloscope. Figure 1.1
#    shows some examples.
   El siguiente programa demuestra el uso basico de los paquetes de imagenes
   estandar en Go, que usaremos para crear una secuencia de imagenes de mapa de
   bits y luego codificar la secuencia como una animacion GIF. Las imagenes,
   llamadas @e(figuras de Lissajous), eran un efecto visual basico en peliculas
   de ciencia ficcion de la decada de 1960. Son las curvas parametricas
   producidas por oscilacion armonica en dos dimensiones, tales como dos ondas
   sinusoidales alimentados en entradas @m(x) e @m(y) de un osciloscopio. La
   Figura 1.1 muestra algunos ejemplos.

#    ..figure > Figure 1.1. Four Lissajous figures.
   ..figure > Figura 1.1. Cuatro figuras de Lissajous.

#      ..img > img/Figure-1.1.jpg
     ..img > img/Figure-1.1.jpg


#    There are several new constructs in this code, including @c(const) declarations,
#    struct types, and composite literals. Unlike most of our examples, this one
#    also involves floating-point computations. We’ll discuss these topics only
#    briefly here, pushing most details off to later chapters, since the primary
#    goal right now is to give you an idea of what Go looks like and the kinds of
#    things that can be done easily with the language and its libraries.
   Hay varias nuevas construcciones en este codigo, incluyendo declaraciones
   @c(const), tipos de estructura, y literales compuestos. A diferencia de la
   mayoria de nuestros ejemplos, este tambien implica calculos de punto
   flotante.  Aqui vamos a discutir estos temas solo brevemente, desplazando la
   mayoria de los detalles a los capitulos posteriores, ya que el objetivo
   principal en este momento es darle una idea de como se ve Go y el tipo de
   cosas que se pueden hacer facilmente con el lenguaje y sus librerias.

#    ..figure > @l(gopl.io/ch1/lissajous/main.go<>gopl.io/ch1/lissajous)
   ..figure > @l(gopl.io/ch1/lissajous/main.go<>gopl.io/ch1/lissajous)

#      ..src > go
#        // Lissajous generates GIF animations of random Lissajous figures.
#        package main
#
#        import (
#          "image"
#          "image/color"
#          "image/gif"
#          "io"
#          "math"
#          "math/rand"
#          "os"
#        )
#
#        var palette = []color.Color{color.White, color.Black}
#
#        const (
#          whiteIndex = 0 // first color in palette
#          blackIndex = 1 // next color in palette
#        )
#
#        func main() {
#          lissajous(os.Stdout)
#        }
#
#        func lissajous(out io.Writer) {
#          const (
#            cycles  = 5     // number of complete x oscillator revolutions
#            res     = 0.001 // angular resolution
#            size    = 100   // image canvas covers [-size..+size]
#            nframes = 64    // number of animation frames
#            delay   = 8     // delay between frames in 10ms units
#          )
#          freq := rand.Float64() * 3.0 // relative frequency of y oscillator
#          anim := gif.GIF{LoopCount: nframes}
#          phase := 0.0 // phase difference
#          for i := 0; i < nframes; i++ {
#            rect := image.Rect(0, 0, 2*size+1, 2*size+1)
#            img := image.NewPaletted(rect, palette)
#            for t := 0.0; t < cycles*2*math.Pi; t += res {
#              x := math.Sin(t)
#              y := math.Sin(t*freq + phase)
#              img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
#                blackIndex)
#            }
#            phase += 0.1
#            anim.Delay = append(anim.Delay, delay)
#            anim.Image = append(anim.Image, img)
#          }
#          gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
#        }
#      < src..
     ..src > go
       // Lissajous genera GIF animados de figuras Lissajous aleatorias.
       package main

       import (
         "image"
         "image/color"
         "image/gif"
         "io"
         "math"
         "math/rand"
         "os"
       )

       var palette = []color.Color{color.White, color.Black}

       const (
         whiteIndex = 0 // primer color en la paleta
         blackIndex = 1 // siguiente color en la paleta
       )

       func main() {
         lissajous(os.Stdout)
       }

       func lissajous(out io.Writer) {
         const (
           cycles  = 5     // numero de revoluciones completas del oscilador x
           res     = 0.001 // resolucion angular
           size    = 100   // dimencion de la imagen [-size..+size]
           nframes = 64    // numero de cuadros de animacion
           delay   = 8     // retardo entre fotogramas en unidades de 10ms
         )
         freq := rand.Float64() * 3.0 // frecuencia relativa del oscilador y
         anim := gif.GIF{LoopCount: nframes}
         phase := 0.0                 // diferencia de fase
         for i := 0; i < nframes; i++ {
           rect := image.Rect(0, 0, 2*size+1, 2*size+1)
           img := image.NewPaletted(rect, palette)
           for t := 0.0; t < cycles*2*math.Pi; t += res {
             x := math.Sin(t)
             y := math.Sin(t*freq + phase)
             img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
               blackIndex)
           }
           phase += 0.1
           anim.Delay = append(anim.Delay, delay)
           anim.Image = append(anim.Image, img)
         }
         gif.EncodeAll(out, &anim) // NOTA: ignorando errores de codificacion
       }
     < src..


#    After importing a package whose path has multiple components, like
#    @c(image/color), we refer to the package with a name that comes from the last
#    component. Thus the variable @c(color.White) belongs to the @c(image/color)
#    package and @c(gif.GIF) belongs to @c(image/gif).
   Despues de importar un paquete cuya ruta tiene multiples componentes, como
   @c(image/color), nos referimos al paquete con el nombre que procede del
   ultimo componente. Por lo tanto la variable @c(color.White) pertenece al
   paquete @c(image/color) y @c(gif.GIF) pertenece a @c(image/gif).

#    A @c(const) declaration (@l(#Section 3.6<>§3.6)) gives names to constants,
#    that is, values that are fixed at compile time, such as the numerical
#    parameters for cycles, frames, and delay. Like @c(var) declarations,
#    @c(const) declarations may appear at package level (so the names are visible
#    throughout the package) or within a function (so the names are visible only
#    within that function). The value of a constant must be a number, string, or
#    boolean.
   Una declaracion @c(const) (@l(#Seccion 3.6<>§3.6)) da nombres a las
   constantes, es decir, valores que se establecen en tiempo de compilacion,
   como los parametros numericos para ciclos, cuadros, y el retardo. Igual a las
   declaraciones @c(var), las declaraciones @c(const) pueden aparecer a nivel de
   paquete (por lo que los nombres son visibles en todo el paquete) o dentro de
   una funcion (por lo que los nombres son visibles solo dentro de esa
   funcion). El valor de una constante debe ser un numero, una cadena o un
   booleano.

#    The expressions @c([]color.Color{...}) and @c(gif.GIF{...}) are @e(composite
#    literals) (@l(#Section 4.2<>§4.2), @l(#Section 4.4.1<>§4.4.1)), a compact
#    notation for instantiating any of Go’s composite types from a sequence of
#    element values. Here, the first one is a slice and the second one is a
#    @e(struct).
   Las expresiones @c([]color.Color{...}) y @c(gif.GIF{...}) son @e(literales
   compuestos) (@l(#Seccion 4.2<>§4.2), @l(#Seccion 4.4.1<>§4.4.1)), una
   notacion compacta de Go para instanciar cualquiera de los tipos compuestos de
   una secuencia de valores de los elementos. Aqui, la primera es un slice y
   la segunda es una @e(estructura).

#    The type @c(gif.GIF) is a struct type (@l(#Section 4.4<>§4.4)). A struct is a
#    group of values called @e(fields), often of different types, that are
#    collected together in a single object that can be treated as a unit. The
#    variable @c(anim) is a struct of type @c(gif.GIF). The struct literal creates
#    a struct value whose @c(LoopCount) field is set to @c(nframes); all other
#    fields have the zero value for their type. The individual fields of a struct
#    can be accessed using dot notation, as in the final two assignments which
#    explicitly update the @c(Delay) and @c(Image) fields of @c(anim).
   El tipo @c(gif.GIF) es de tipo estructura (@l(#Seccion 4.4<>§4.4)). Una
   estructura es un grupo de valores denominados @e(campos), a menudo de
   diferentes tipos, que se recogen juntos en un unico objeto que puede tratarse
   como una unidad. La variable @c(anim) es una estructura de tipo @c(gif.GIF).
   La estructura literal crea un valor estructura cuyo campo @c(LoopCount) se
   establece en @c(nframes); Todos los demas campos tienen el valor cero para su
   tipo. Los campos individuales de una estructura se puede acceder usando la
   notacion punto, al igual que en las dos ultimas asignaciones que actualizan
   de forma explicita los campos @c(Delay) e @c(Image) de @c(anim).

#    The @c(lissajous) function has two nested loops. The outer loop runs for 64
#    iterations, each producing a single frame of the animation. It creates a new
#    201x201 image with a palette of two colors, white and black. All pixels are
#    initially set to the palette’s zero value (the zeroth color in the palette),
#    which we set to white. Each pass through the inner loop generates a new image
#    by setting some pixels to black. The result is appended, using the built-in
#    @c(append) function (@l(#Section 4.2.1<>§4.2.1)), to a list of frames in
#    @c(anim), along with a specified delay of 80ms. Finally the sequence of
#    frames and delays is encoded into GIF format and written to the output stream
#    @c(out). The type of @c(out) is @c(io.Writer), which lets us write to a wide
#    range of possible destinations, as we’ll show soon.
   La funcion @c(lissajous) tiene dos bucles anidados. El bucle exterior se
   ejecuta 64 iteraciones, cada uno produciendo un solo fotograma de la
   animacion. Crea una nueva imagen de 201x201 con una paleta de dos colores,
   blanco y negro. Todos los pixeles se ajustan inicialmente al valor cero de la
   paleta (el color cero de la paleta), que se establece en blanco. Cada paso a
   traves del bucle interno genera una nueva imagen estableciendo algunos
   pixeles en negro. El resultado se añade a una lista de cuadros en @c(anim)
   utilizando la funcion nativa @c(append) (@l(#Seccion 4.2.1<>§4.2.1)), junto
   con un retardo especificado de 80ms. Por ultimo, la secuencia de cuadros y
   los retrasos se codifican en formato GIF y se escribe en la salida de flujo
   @c(out). El tipo de @c(out) es @c(io.Writer), lo que nos permite escribir a
   una amplia gama de posibles destinos, como vamos a mostrar pronto.

#    The inner loop runs the two oscillators. The @c(x) oscillator is just the
#    sine function. The @c(y) oscillator is also a sinusoid, but its frequency
#    relative to the @c(x) oscillator is a random number between 0 and 3, and its
#    phase relative to the @c(x) oscillator is initially zero but increases with
#    each frame of the animation. The loop runs until the @c(x) oscillator has
#    completed five full cycles. At each step, it calls @c(SetColorIndex) to color
#    the pixel corresponding to (@c(x), @c(y)) black, which is at position 1 in
#    the palette.
   El bucle interior ejecuta los dos osciladores. El oscilador @c(x) es
   simplemente la funcion sinusoidal. El oscilador @c(y) es tambien una
   sinusoide, pero su frecuencia es relativa a la del oscilador @c(x) un numero
   aleatorio entre 0 y 3, y su fase relativa al oscilador @c(x) es inicialmente
   cero, pero aumenta con cada fotograma de la animacion. El bucle se ejecuta
   hasta que el oscilador @c(x) ha completado cinco ciclos completos. En cada
   paso, se llama a @c(SetColorIndex) para colorear el pixel (@c(x), @c(y))
   correspondiente en negro, que es en la posicion 1 de la paleta.

#    The @c(main) function calls the @c(lissajous) function, directing it to write
#    to the standard output, so this command produces an animated GIF with frames
#    like those in Figure 1.1:
   La funcion @c(main) llama a la funcion @c(lissajous), dirigiendola a escribir
   en la salida estandar, por lo que este comando produce un GIF animado con
   cuadros como los de la Figura 1.1:

#    ..src > sh
#      $ go build gopl.io/ch1/lissajous
#      $ ./lissajous >out.gif
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/lissajous
     $ ./lissajous >out.gif
   < src..

#    @b(Exercise 1.5): Change the Lissajous program’s color palette to green on
#    black, for added authenticity. To create the web color @c(#RRGGBB), use
#    @c(color.RGBA{0xRR, 0xGG, 0xBB, 0xff}), where each pair of hexadecimal digits
#    represents the intensity of the red, green, or blue component of the pixel.
   @b(Ejercicio 1.5): Cambiar la paleta de colores del programa Lissajous a
   verde sobre negro, para mayor autenticidad. Para crear el color web
   @c(#RRGGBB), utilice @c(color.RGBA{0xRR, 0xGG, 0xBB, 0xff}), donde cada par
   de digitos hexadecimales representa la intensidad del componente de color
   rojo, verde o azul del pixel.

#    @b(Exercise 1.6): Modify the Lissajous program to produce images in multiple
#    colors by adding more values to palette and then displaying them by changing
#    the third argument of @c(SetColorIndex) in some interesting way.
   @b(Ejercicio 1.6): Modificar el programa Lissajous para producir imagenes de
   multiples colores mediante la adicion de mas valores a la paleta y luego
   mostrarlos cambiando el tercer argumento de @c(SetColorIndex) de alguna
   manera interesante.

# ** Section 1.5 <> Fetching a URL
** Seccion 1.5 <> Obtener una URL

#    For many applications, access to information from the Internet is as
#    important as access to the local file system. Go provides a collection of
#    packages, grouped under net, that make it easy to send and receive
#    information through the Internet, make low-level network connections, and set
#    up servers, for which Go’s concurrency features (introduced in @l(#Chapter
#    8)) are particularly useful.
   Para muchas aplicaciones, el acceso a la informacion de Internet es tan
   importante como el acceso al sistema de archivos local. Go ofrece una
   coleccion de paquetes, agrupados bajo @c(net), que hacen que sea facil de
   enviar y recibir informacion a traves de Internet, realizar conexiones de red
   de bajo nivel, y configurar servidores, por lo que las caracteristicas de
   concurrencia de Go (introducidas en el @l(#Capitulo 8)) son particularmente
   utiles.

#    To illustrate the minimum necessary to retrieve information over HTTP, here’s
#    a simple program called @$(fetch) that fetches the content of each specified URL
#    and prints it as uninterpreted text; it’s inspired by the invaluable utility
#    @$(curl). Obviously one would usually do more with such data, but this shows the
#    basic idea. We will use this program frequently in the book.
   Para ilustrar el minimo necesario para recuperar la informacion a traves de
   HTTP, aqui esta un programa simple llamado @$(fetch) que recupera el
   contenido de cada URL y lo imprime como texto sin interpretar; esta inspirado
   en la invaluable utilidad @$(curl) . Obviamente uno normalmente haria mas con
   tales datos, pero esto muestra la idea basica. Usaremos este programa con
   frecuencia en el libro.

#    ..figure > @l(gopl.io/ch1/fetch/main.go<>gopl.io/ch1/fetch)
   ..figure > @l(gopl.io/ch1/fetch/main.go<>gopl.io/ch1/fetch)

#      ..src > go
#        // Fetch prints the content found at each specified URL.
#        package main
#
#        import (
#          "fmt"
#          "io/ioutil"
#          "net/http"
#          "os"
#        )
#
#        func main() {
#          for _, url := range os.Args[1:] {
#            resp, err := http.Get(url)
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
#              os.Exit(1)
#            }
#            b, err := ioutil.ReadAll(resp.Body)
#            resp.Body.Close()
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
#              os.Exit(1)
#            }
#            fmt.Printf("%s", b)
#          }
#        }
#      < src..
     ..src > go
       // Fetch imprime el contenido encontrado en cada URL especificada.
       package main

       import (
         "fmt"
         "io/ioutil"
         "net/http"
         "os"
       )

       func main() {
         for _, url := range os.Args[1:] {
           resp, err := http.Get(url)
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
             os.Exit(1)
           }
           b, err := ioutil.ReadAll(resp.Body)
           resp.Body.Close()
           if err != nil {
             fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
             os.Exit(1)
           }
           fmt.Printf("%s", b)
         }
       }
     < src..


#    This program introduces functions from two packages, @c(net/http) and
#    @c(io/ioutil). The @c(http.Get) function makes an HTTP request and, if there
#    is no error, returns the result in the response struct @c(resp). The @c(Body)
#    field of @c(resp) contains the server response as a readable stream. Next,
#    @c(ioutil.ReadAll) reads the entire response; the result is stored in
#    @c(b). The @c(Body) stream is closed to avoid leaking resources, and
#    @c(Printf) writes the response to the standard output.
   Este programa introduce funciones a partir de dos paquetes, @c(net/http) e
   @c(io/ioutil). La funcion @c(http.Get) realiza una peticion HTTP y, si no hay
   error, devuelve el resultado en la estructura @c(resp). El campo @c(Body) de
   @c(resp) contiene la respuesta del servidor como un flujo legible. A
   continuacion, @c(ioutil.ReadAll) lee toda la respuesta; el resultado se
   almacena en @c(b). El flujo @c(Body) es cerrado para evitar fuga de recursos
   y @c(Printf) escribe la respuesta a la salida estandar.

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://gopl.io
#      <html>
#      <head>
#      <title>The Go Programming Language</title>
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://gopl.io
     <html>
     <head>
     <title>The Go Programming Language</title>
     ...
   < src..

#    If the HTTP request fails, fetch reports the failure instead:
   Si la solicitud HTTP falla, en su lugar, @$(fetch) reportara el error:

#    ..src > sh
#      $ ./fetch http://bad.gopl.io
#      fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
#    < src..
   ..src > sh
     $ ./fetch http://bad.gopl.io
     fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
   < src..

#    In either error case, @c[os.Exit(1)] causes the process to exit with a status
#    code of 1.
   En cualquiera de los casos de error, @c[os.Exit(1)] hace que el proceso
   termine con un codigo de estado de valor 1.

#    @b(Exercise 1.7): The function call @c[io.Copy(dst, src)] reads from @c(src)
#    and writes to @c(dst). Use it instead of @c(ioutil.ReadAll) to copy the
#    response body to @c(os.Stdout) without requiring a buffer large enough to
#    hold the entire stream. Be sure to check the error result of @c(io.Copy).
   @b(Ejercicio 1.7): La funcion @c[io.Copy(dst, src)] lee desde @c(src) y
   escribe en @c(dst). Utilicelo en lugar de @c(ioutil.ReadAll) para copiar el
   cuerpo de la respuesta a @c(os.Stdout) sin requerir un buffer lo
   suficientemente grande como para contener todo el fluje de datos. Asegurese
   de comprobar el resultado del error de @c(io.Copy).

#    @b(Exercise 1.8): Modify @$(fetch) to add the prefix @c(http://) to each
#    argument URL if it is missing. You might want to use @c(strings.HasPrefix).
   @b(Ejercicio 1.8): Modificar @$(fetch) para agregar el prefijo @c(http://) a
   cada argumento URL si este no se proporciona. Es posible que desee utilizar
   @c(strings.HasPrefix).

#    @b(Exercise 1.9): Modify @$(fetch) to also print the HTTP status code, found
#    in @c(resp.Status).
   @b(Ejercicio 1.9): Modificar @$(fetch) para imprimir tambien el codigo de
   estado HTTP, que se encuentra en @c(resp.Status).

# ** Section 1.6 <> Fetching URLs Concurrently
** Seccion 1.6 <> Obteniendo URL Concurrentemente

#    One of the most interesting and novel aspects of Go is its support for
#    concurrent programming. This is a large topic, to which @l(#Chapter 8) and
#    Chapter 9 are devoted, so for now we’ll give you just a taste of Go’s main
#    concurrency mechanisms, goroutines and channels.
   Uno de los aspectos mas interesantes y novedosos de Go es su soporte para la
   programacion concurrente. Este es un tema muy amplio, al que se dedican el
   @l(#Capitulo 8) y el @l(#Capitulo 9), asi que por ahora le daremos solo una
   muestra de los principales mecanismos de la concurrencia en Go, @e(gorutinas)
   y @e(canales).

#    The next program, @$(fetchall), does the same fetch of a URL’s contents as
#    the previous example, but it fetches many URLs, all concurrently, so that the
#    process will take no longer than the longest fetch rather than the sum of all
#    the fetch times. This version of @$(fetchall) discards the responses but
#    reports the size and elapsed time for each one:
   El siguiente programa, @$(fetchall), realiza la misma busqueda del contenido
   de una URL como en el ejemplo anterior, pero obtiene muchas URL, todas al
   mismo tiempo, de modo que el proceso no tardara mas que la busqueda mas
   prolongada en lugar de la suma de todos los tiempos de busqueda. Esta version
   de @$(fetchall) descarta las respuestas, pero indica el tamaño y el tiempo
   transcurrido de cada una:

#    ..figure > @l(gopl.io/ch1/fetchall/main.go<>gopl.io/ch1/fetchall)
   ..figure > @l(gopl.io/ch1/fetchall/main.go<>gopl.io/ch1/fetchall)

#      ..src > go
#        // Fetchall fetches URLs in parallel and reports their times and sizes.
#        package main
#
#        import (
#          "fmt"
#          "io"
#          "io/ioutil"
#          "net/http"
#          "os"
#          "time"
#        )
#
#        func main() {
#          start := time.Now()
#          ch := make(chan string)
#          for _, url := range os.Args[1:] {
#            go fetch(url, ch) // start a goroutine
#          }
#          for range os.Args[1:] {
#            fmt.Println(<-ch) // receive from channel ch
#          }
#          fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
#        }
#
#        func fetch(url string, ch chan<- string) {
#          start := time.Now()
#          resp, err := http.Get(url)
#          if err != nil {
#            ch <- fmt.Sprint(err) // send to channel ch
#            return
#          }
#
#          nbytes, err := io.Copy(ioutil.Discard, resp.Body)
#          resp.Body.Close() // don't leak resources
#          if err != nil {
#            ch <- fmt.Sprintf("while reading %s: %v", url, err)
#            return
#          }
#          secs := time.Since(start).Seconds()
#          ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
#        }
#      < src..
     ..src > go
       // Fetchall busca URLs en paralelo e informa de sus tiempos y tamaños.
       package main

       import (
         "fmt"
         "io"
         "io/ioutil"
         "net/http"
         "os"
         "time"
       )

       func main() {
         start := time.Now()
         ch := make(chan string)
         for _, url := range os.Args[1:] {
           go fetch(url, ch) // inicia una gorutina
         }
         for range os.Args[1:] {
           fmt.Println(<-ch) // recibir desde el canal ch
         }
         fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
       }

       func fetch(url string, ch chan<- string) {
         start := time.Now()
         resp, err := http.Get(url)
         if err != nil {
           ch <- fmt.Sprint(err) // enviar al canal ch
           return
         }

         nbytes, err := io.Copy(ioutil.Discard, resp.Body)
         resp.Body.Close() // no pierdas recursos
         if err != nil {
           ch <- fmt.Sprintf("while reading %s: %v", url, err)
           return
         }
         secs := time.Since(start).Seconds()
         ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
       }
     < src..


#    Here’s an example:
   He aqui un ejemplo:

#    ..src > sh
#      $ go build gopl.io/ch1/fetchall
#      $ ./fetchall https://golang.org http://gopl.io https://godoc.org
#      0.14s     6852 https://godoc.org
#      0.16s     7261 https://golang.org
#      0.48s     2475 http://gopl.io
#      0.48s elapsed
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetchall
     $ ./fetchall https://golang.org http://gopl.io https://godoc.org
     0.14s     6852 https://godoc.org
     0.16s     7261 https://golang.org
     0.48s     2475 http://gopl.io
     0.48s elapsed
   < src..

#    A @e(goroutine) is a concurrent function execution. A @e(channel) is a
#    communication mechanism that allows one goroutine to pass values of a
#    specified type to another goroutine. The function @c(main) runs in a
#    goroutine and the @c(go) statement creates additional goroutines.
   Una @e(gorutina) es una funcion de ejecucion concurrente. Un @e(canal) es un
   mecanismo de comunicacion que permite a una @e(gorutina) para pasar valores
   de un tipo especificado a otra @e(gorutina). La funcion @e(main) se ejecuta
   en una gorutina y la sentencia @c(go) crea gorutinas adicionales.

#    The @c(main) function creates a channel of strings using @c(make). For each
#    command-line argument, the @c(go) statement in the first range loop starts a
#    new goroutine that calls @c(fetch) asynchronously to fetch the URL using
#    @c(http.Get). The @c(io.Copy) function reads the body of the response and
#    discards it by writing to the @c(ioutil.Discard) output stream. @c(Copy)
#    returns the byte count, along with any error that occurred. As each result
#    arrives, @c(fetch) sends a summary line on the channel @c(ch). The second
#    range loop in @c(main) receives and prints those lines.
   La funcion @c(main) crea un canal de strings utilizando @c(make). Para cada
   argumento de linea de comandos, la sentencia @c(go) en el primer bucle inicia
   una nueva gorutina que llama a @c(fetch) asincronamente para buscar la URL
   usando @c(http.Get). La funcion @c(io.Copy) lee el cuerpo de la respuesta y
   lo descarta escribiendo en el flujo de salida @c(ioutil.Discard). @c(Copy)
   devuelve el numero de bytes, junto con cualquier error prodicido. A medida
   que llega cada resultado, @c(fetch) envia una linea de resumen en el canal
   @c(ch). El segundo bucle en @c(main) recibe e imprime esas lineas.

#    When one goroutine attempts a send or receive on a channel, it blocks until
#    another goroutine attempts the corresponding receive or send operation, at
#    which point the value is transferred and both goroutines proceed. In this
#    example, each @c(fetch) sends a value (@c(ch <-) @e(expression)) on the
#    channel @c(ch), and @c(main) receives all of them (@c(<-ch)). Having @c(main)
#    do all the printing ensures that output from each goroutine is processed as a
#    unit, with no danger of interleaving if two goroutines finish at the same
#    time.
   Cuando una gorutina intenta enviar o recibir en un canal, se bloquea hasta
   que otra gorutina intente la operacion correspondiente de recepcion o envio,
   momento en el cual se transfiere el valor y ambas gorutinas continuan. En
   este ejemplo, cada @c(fetch) envia un valor (@e(expresion) @c(ch <-)) en el
   canal @c(ch), y @c(main) recibe todos ellos (@c(<-ch)). Tener a @c(main)
   haciendo toda la impresion, asegura que la salida de cada gorutina se procesa
   como una unidad, sin el peligro de entrelazado si dos gorutinas terminan al
   mismo tiempo.

#    @b(Exercise 1.10): Find a web site that produces a large amount of
#    data. Investigate caching by running @c(fetchall) twice in succession to see
#    whether the reported time changes much. Do you get the same content each
#    time? Modify @c(fetchall) to print its output to a file so it can be
#    examined.
   @b(Ejercicio 1.10): Encontrar un sitio web que produce una gran cantidad de
   datos. Investiga el almacenamiento en cache mediante la ejecucion de
   @$(fetchall) dos veces consecutivas para ver si el tiempo reportado cambia
   mucho. ¿Obtienes el mismo contenido cada vez? Modificar @$(fetchall) para
   imprimir su salida a un archivo para que pueda ser examinado.

#    @b(Exercise 1.11): Try @c(fetchall) with longer argument lists, such as
#    samples from the top million web sites available at @l(http://www.alexa.com/<>alexa.com). How does
#    the program behave if a web site just doesn’t respond? (@l(#Section 8.9)
#    describes mechanisms for coping in such cases.)
   @b(Ejercicio 1.11): Pruebe @$(fetchall) con listas de argumentos mas
   extensas, como muestras de los mejores sitios web disponibles en
   @l(http://www.alexa.com/<>alexa.com). ¿Como se comporta el programa si un
   sitio web simplemente no responde? (La @l(#Seccion 8.9) describe los
   mecanismos para hacer frente en estos casos.)

# ** Section 1.7 <> A Web Server
** Seccion 1.7 <> Un servidor Web

#    Go’s libraries makes it easy to write a web server that responds to client
#    requests like those made by @$(fetch). In this section, we’ll show a minimal
#    server that returns the path component of the URL used to access the
#    server. That is, if the request is for @c(http://localhost:8000/hello), the
#    response will be @c(URL.Path = "/hello").
   Las Librerias de Go hacen que sea facil escribir un servidor web que responde
   a las solicitudes de los clientes, como las realizadas por @$(fetch). En esta
   seccion, mostraremos un servidor minimo que devuelve el componente de ruta de
   la URL utilizada para acceder al servidor. Es decir, si la solicitud es
   @c(http://localhost:8000/hello), la respuesta sera @c(URL.Path = "/hello").

#    ..figure > @l(gopl.io/ch1/server1/main.go<>gopl.io/ch1/server1)
   ..figure > @l(gopl.io/ch1/server1/main.go<>gopl.io/ch1/server1)

#      ..src > go
#        // Server1 is a minimal "echo" server.
#        package main
#
#        import (
#          "fmt"
#          "log"
#          "net/http"
#        )
#
#        func main() {
#          http.HandleFunc("/", handler) // each request calls handler
#          log.Fatal(http.ListenAndServe("localhost:8000", nil))
#        }
#
#        // handler echoes the Path component of the requested URL.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
#        }
#      < src..
     ..src > go
       // Server1 es un servidor de "eco" minimo.
       package main

       import (
         "fmt"
         "log"
         "net/http"
       )

       func main() {
         http.HandleFunc("/", handler) // cada solicitud llama a handler
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }
     < src..


#    The program is only a handful of lines long because library functions do most
#    of the work. The @c(main) function connects a handler function to incoming
#    URLs that begin with @c(/), which is all URLs, and starts a server listening
#    for incoming requests on port 8000. A request is represented as a struct of
#    type @c(http.Request), which contains a number of related fields, one of
#    which is the URL of the incoming request. When a request arrives, it is given
#    to the handler function, which extracts the path component (@c(/hello)) from
#    the request URL and sends it back as the response, using @c(fmt.Fprintf). Web
#    servers will be explained in detail in @l(#Section 7.7).
   El programa esta formado por solo un puñado de lineas, porque las funciones
   de la libreria hacen la mayor parte del trabajo. La funcion @c(main) conecta
   una funcion de manejo a las direcciones URL entrantes que comienzan con
   @c(/), que son todas las direcciones URL, e inicia un servidor que escucha
   las peticiones entrantes en el puerto 8000. La solicitud se representa como
   una estructura de tipo @c(http.Request), que contiene una serie de campos
   relacionados, uno de los cuales es la URL de la solicitud entrante. Cuando
   llega una peticion, se le da a la funcion de manejo, que extrae el componente
   de ruta (@c(/hello)) a partir de la URL de solicitud y la envia de vuelta
   como la respuesta, utilizando @c(fmt.Fprintf). Los servidores web se
   explicaran en detalle en la @l(#Seccion 7.7).

#    Let’s start the server in the background. On Mac OS X or Linux, add an
#    ampersand (@c(&)) to the command; on Microsoft Windows, you will need to run
#    the command without the ampersand in a separate command window.
   Iniciemos el servidor en segundo plano. En Mac OS X o GNU/Linux, añadir un
   simbolo ampersand (@c(&)) al comando; En Microsoft Windows, necesitara
   ejecutar el comando sin el signo ampersand en una ventana de comandos
   distinta.

#    ..src > sh
#      $ go run src/gopl.io/ch1/server1/main.go &
#    < src..
   ..src > sh
     $ go run src/gopl.io/ch1/server1/main.go &
   < src..

#    We can then make client requests from the command line:
   A continuacion, podemos hacer solicitudes desde la linea de comandos:

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://localhost:8000
#      URL.Path = "/"
#      $ ./fetch http://localhost:8000/help
#      URL.Path = "/help"
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://localhost:8000
     URL.Path = "/"
     $ ./fetch http://localhost:8000/help
     URL.Path = "/help"
   < src..

#    Alternatively, we can access the server from a web browser, as shown in
#    Figure 1.2.
   Como alternativa, podemos acceder al servidor desde un navegador web, como se
   muestra en la Figura 1.2.

#    ..figure > Figure 1.2. A response from the echo server.
   ..figure > Figura 1.2. Una respuesta del servidor de eco.

#      ..img > img/Figure-1.2.jpg
     ..img > img/Figure-1.2.jpg


#    It’s easy to add features to the server. One useful addition is a specific
#    URL that returns a status of some sort. For example, this version does the
#    same echo but also counts the number of requests; a request to the URL
#    @c(/count) returns the count so far, excluding @c(/count) requests
#    themselves:
   Es facil agregar funciones al servidor. Una adicion util es una URL
   especifica que devuelve un estado de algun tipo. Por ejemplo, esta version
   hace eco, pero tambien cuenta el numero de peticiones; una peticion a la URL
   @c(/count) devuelve el recuento hasta el momento, excluyendo la solicitud
   @c(/count) a si misma:

#    ..figure > @l(gopl.io/ch1/server2/main.go<>gopl.io/ch1/server2)
   ..figure > @l(gopl.io/ch1/server2/main.go<>gopl.io/ch1/server2)

#      ..src > go
#        // Server2 is a minimal "echo" and counter server.
#        package main
#
#        import (
#          "fmt"
#          "log"
#          "net/http"
#          "sync"
#        )
#
#        var mu sync.Mutex
#        var count int
#
#        func main() {
#          http.HandleFunc("/", handler)
#          http.HandleFunc("/count", counter)
#          log.Fatal(http.ListenAndServe("localhost:8000", nil))
#        }
#
#        // handler echoes the Path component of the requested URL.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          mu.Lock()
#          count++
#          mu.Unlock()
#          fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
#        }
#
#        // counter echoes the number of calls so far.
#        func counter(w http.ResponseWriter, r *http.Request) {
#          mu.Lock()
#          fmt.Fprintf(w, "Count %d\n", count)
#          mu.Unlock()
#        }
#      < src..
     ..src > go
       // Server2 es un servidor de eco y conteo minimo
       package main

       import (
         "fmt"
         "log"
         "net/http"
         "sync"
       )

       var mu sync.Mutex
       var count int

       func main() {
         http.HandleFunc("/", handler)
         http.HandleFunc("/count", counter)
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }

       // handler hace eco del componente Path de la URL solicitida.
       func handler(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         count++
         mu.Unlock()
         fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
       }

       // counter hace eco del numero de lamadas hasta ahora.
       func counter(w http.ResponseWriter, r *http.Request) {
         mu.Lock()
         fmt.Fprintf(w, "Count %d\n", count)
         mu.Unlock()
       }
     < src..


#    The server has two handlers, and the request URL determines which one is
#    called: a request for @c(/count) invokes @c(counter) and all others invoke
#    @c(handler). A handler pattern that ends with a slash matches any URL that
#    has the pattern as a prefix. Behind the scenes, the server runs the handler
#    for each incoming request in a separate goroutine so that it can serve
#    multiple requests simultaneously. However, if two concurrent requests try to
#    update count at the same time, it might not be incremented consistently; the
#    program would have a serious bug called a @e(race condition) (@l(#Section
#    9.1<>§9.1)). To avoid this problem, we must ensure that at most one goroutine
#    accesses the variable at a time, which is the purpose of the @c[mu.Lock()]
#    and @c[mu.Unlock()] calls that bracket each access of @c(count). We’ll look
#    more closely at concurrency with shared variables in @l(#Chapter 9).
   El servidor tiene dos manejadores, y la URL de la solicitud determina cual se
   llama: una solicitud por @c(/count) invoca a @c(counter) y todas los demas
   invocan a @c(handler). Un patron de manejo que termina con una barra diagonal
   coincide con cualquier URL que tenga el patron como prefijo. Detras de
   escena, el servidor ejecuta el controlador para cada solicitud entrante en
   una gorutina separada para que pueda servir multiples solicitudes
   simultaneamente. Sin embargo, si dos solicitudes simultaneas intentan
   actualizar @c(count) al mismo tiempo, es posible que no se incremente
   consistentemente; El programa tendria un error grave llamado @e(condicion de
   carrera) (@l(#Seccion 9.1<>§9.1)). Para evitar este problema, debemos
   asegurarnos de que a lo sumo solo una gorutina accede a la variable a la vez,
   que es el proposito de las llamadas a @c[mu.Lock()] y @c[mu.Unlock()] que
   rodean el acceso a @c(count). Examinaremos mas de cerca a la concurrencia con
   variables compartidas en el @l(#Capitulo 9).

#    As a richer example, the handler function can report on the headers and form
#    data that it receives, making the server useful for inspecting and debugging
#    requests:
   Como un ejemplo mas rico, la funcion de manejo puede informar sobre los
   encabezados y datos de formulario que recibe, haciendo que el servidor sea
   util para inspeccionar y depurar peticiones:

#    ..figure > @l(gopl.io/ch1/server3/main.go<>gopl.io/ch1/server3)
   ..figure > @l(gopl.io/ch1/server3/main.go<>gopl.io/ch1/server3)

#      ..src > go
#        // handler echoes the HTTP request.
#        func handler(w http.ResponseWriter, r *http.Request) {
#          fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
#          for k, v := range r.Header {
#            fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
#          }
#          fmt.Fprintf(w, "Host = %q\n", r.Host)
#          fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
#          if err := r.ParseForm(); err != nil {
#            log.Print(err)
#          }
#          for k, v := range r.Form {
#            fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
#          }
#        }
#      < src..
     ..src > go
       // handler responde a la peticion HTTP.
       func handler(w http.ResponseWriter, r *http.Request) {
         fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)
         for k, v := range r.Header {
           fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
         }
         fmt.Fprintf(w, "Host = %q\n", r.Host)
         fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
         if err := r.ParseForm(); err != nil {
           log.Print(err)
         }
         for k, v := range r.Form {
           fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
         }
       }
     < src..


#    This uses the fields of the @c(http.Request) struct to produce output like
#    this:
   Este utiliza los campos de la estructura @c(http.Request) para producir una
   salida como esta:

#    ..pre >
#      GET /?q=query HTTP/1.1
#      Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
#      Header["Accept-Language"] = ["en-US,en;q=0.8"]
#      Header["Connection"] = ["keep-alive"]
#      Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
#      Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
#      Host = "localhost:8000"
#      RemoteAddr = "127.0.0.1:59911"
#      Form["q"] = ["query"]
#    < pre..
   ..pre >
     GET /?q=query HTTP/1.1
     Header["Accept-Encoding"] = ["gzip, deflate, sdch"]
     Header["Accept-Language"] = ["en-US,en;q=0.8"]
     Header["Connection"] = ["keep-alive"]
     Header["Accept"] = ["text/html,application/xhtml+xml,application/xml;..."]
     Header["User-Agent"] = ["Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)..."]
     Host = "localhost:8000"
     RemoteAddr = "127.0.0.1:59911"
     Form["q"] = ["query"]
   < pre..

#    Notice how the call to @c(ParseForm) is nested within an @c(if) statement. Go
#    allows a simple statement such as a local variable declaration to precede the
#    @c(if) condition, which is particularly useful for error handling as in this
#    example. We could have written it as
   Observe como la llamada a @c(ParseForm) esta anidada dentro de una sentencia
   @c(if). Go permite una declaracion simple, como una declaracion de variable
   local para preceder la sentencia @c(if), lo que es particularmente util para
   el tratamiento de errores como en este ejemplo. Podriamos haberlo escrito
   como

#    ..src > go
#      err := r.ParseForm()
#      if err != nil {
#        log.Print(err)
#      }
#    < src..
   ..src > go
     err := r.ParseForm()
     if err != nil {
       log.Print(err)
     }
   < src..

#    but combining the statements is shorter and reduces the scope of the variable
#    @c(err), which is good practice. We’ll define scope in @l(#Section 2.7).
   la combinacion de las sentencias es mas corta y reduce el alcance de la
   variable @c(err), que es una buena practica. Vamos a definir el alcance en la
   @l(#Seccion 2.7).

#    In these programs, we’ve seen three very different types used as output
#    streams. The @$(fetch) program copied HTTP response data to @c(os.Stdout), a
#    file, as did the @$(lissajous) program. The @$(fetchall) program threw the
#    response away (while counting its length) by copying it to the trivial sink
#    @c(ioutil.Discard). And the web server above used @c(fmt.Fprintf) to write to
#    an @c(http.ResponseWriter) representing the web browser.
   En estos programas, hemos visto tres tipos muy diferentes utilizados como
   flujos de salida. El programa @$(fetch) copia datos de la respuesta HTTP a
   @c(os.Stdout), a un archivo, al igual que el programa @$(lissajous). El
   programa @$(fetchall) arroja la respuesta copiando el flujo (mientras cuenta
   su longitud) de forma trivial en @c(ioutil.Discard). Y el anterior servidor
   web utiliza @c(fmt.Fprintf) para escribir una representacion del navegador
   @c(http.ResponseWriter).

#    Although these three types differ in the details of what they do, they all
#    satisfy a common @e(interface), allowing any of them to be used wherever an
#    output stream is needed. That interface, called @c(io.Writer), is discussed
#    in @l(#Section 7.1).
   Aunque estos tres tipos difieren en los detalles de lo que hacen, todos ellos
   satisfacen una interfaz comun, permitiendo que cualquiera pueda ser utilizado
   cuando sea necesario crear un flujo de salida. Esa interfaz, llamada
   @c(io.Writer), se discute en la @l(#Seccion 7.1).

#    Go’s interface mechanism is the topic of @l(#Chapter 7), but to give an idea
#    of what it’s capable of, let’s see how easy it is to combine the web server
#    with the @c(lissajous) function so that animated GIFs are written not to the
#    standard output, but to the HTTP client. Just add these lines to the web
#    server:
   El mecanismo de interfaz de Go es el tema del @l(#Capitulo 7), pero para dar
   una idea de lo que es capaz de hacer, vamos a ver lo facil que es combinar el
   servidor web con la funcion @c(lissajous) para que los archivos GIF animados
   se escriben no en la salida estandar, en su lugar en el cliente
   HTTP. Simplemente agregue estas lineas al servidor web:

#    ..src > go
#      handler := func(w http.ResponseWriter, r *http.Request) {
#        lissajous(w)
#      }
#      http.HandleFunc("/", handler)
#    < src..
   ..src > go
     handler := func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     }
     http.HandleFunc("/", handler)
   < src..

#    or equivalently:
   o su equivalente:

#    ..src > go
#      http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
#        lissajous(w)
#      })
#    < src..
   ..src > go
     http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
       lissajous(w)
     })
   < src..

#    The second argument to the @c(HandleFunc) function call immediately above is
#    a @e(function literal), that is, an anonymous function defined at its point
#    of use. We will explain it further in @l(#Section 5.6).
   El segundo argumento de la funcion @c(HandleFunc) se conoce como una
   e(funcion literal), es decir, una funcion anonima definida en su punto de
   uso. Vamos a explicar mas a fondo en la @l(#Seccion 5.6).

#    Once you’ve made this change, visit @l(http://localhost:8000) in your
#    browser. Each time you load the page, you’ll see a new animation like the one
#    in Figure 1.3.
   Una vez que haya realizado este cambio, visite @l(http://localhost:8000) en su
   navegador. Cada vez que cargue la pagina, vera una nueva animacion como la de
   la Figura 1.3.

#    @b(Exercise 1.12): Modify the Lissajous server to read parameter values from
#    the URL. For example, you might arrange it so that a URL like
#    @c(http://localhost:8000/?cycles=20) sets the number of cycles to 20 instead
#    of the default 5. Use the @c(strconv.Atoi) function to convert the string
#    parameter into an integer. You can see its documentation with @$(go doc
#    strconv.Atoi).
   @b(Ejercicio 1.12): Modificar el servidor de Lissajous para leer valores de
   los parametros de la URL. Por ejemplo, es posible disponer de forma que una
   URL como @c(http://localhost:8000/?cycles=20) establece el numero de ciclos a
   20 en lugar del predeterminado 5. Utilice la funcion @c(strconv.Atoi) para
   convertir el parametro de string a un entero. Puede ver su documentacion
   mediante con @$(go doc strconv.Atoi).

#    ..figure > Figure 1.3. Animated Lissajous figures in a browser.
   ..figure > Figura 1.3. Figuras animadas de Lissajous en un navegador.

#      ..img > img/Figure-1.3.jpg
     ..img > img/Figure-1.3.jpg

# ** Section 1.8 <> Loose Ends
** Seccion 1.8 <> Cabos sueltos

#    There is a lot more to Go than we’ve covered in this quick introduction. Here
#    are some topics we’ve barely touched upon or omitted entirely, with just
#    enough discussion that they will be familiar when they make brief appearances
#    before the full treatment.
   Hay mucho mas de Go de lo que hemos cubierto en esta introduccion rapida.
   Aqui hay algunos temas que apenas hemos tocado o omitido por completo, con
   tratamiento suficiente para empezar a familiarizarse con ellos antes de un
   tratamiento completo.

#    - Control flow :: We covered the two fundamental control-flow statements,
#      @c(if) # and @c(for), but not the @c(switch) statement, which is a
#      multi-way branch. Here’s a # small example:
   - Control de Flujo :: Cubrimos los dos estados de control de flujo
     fundamentales, @c(if) y @c(for), pero no la sentencia @c(switch), que es
     una via de multiples ramas. Aqui hay un pequeño ejemplo:

#      ..src > go
#        switch coinflip() {
#        case "heads":
#          heads++
#        case "tails":
#          tails++
#        default:
#          fmt.Println("landed on edge!")
#        }
#      < src..
     ..src > go
       switch coinflip() {
       case "heads":
         heads++
       case "tails":
         tails++
       default:
         fmt.Println("landed on edge!")
       }
     < src..

#      The result of calling @c(coinflip) is compared to the value of each
#      case. Cases are evaluated from top to bottom, so the first matching one
#      is executed. The optional default case matches if none of the other cases
#      does; it may be placed anywhere. Cases do not fall through from one to
#      the next as in C-like languages (though there is a rarely used
#      @c(fallthrough) statement that overrides this behavior).
     El resultado de llamar a @c(coinflip) se compara con el valor de cada
     caso. Los casos se evaluan de arriba a abajo, por lo que se ejecuta la
     primera coincidencia. El caso opcional @c(default) coincide si ninguno de
     los otros casos lo hace; Puede colocarse en cualquier lugar. Los casos no
     caen uno sobre otro, como en lenguajes tipo C (aunque hay una poco
     utilizada declaracion @c(fallthrough) que anula este comportamiento).

#      A @c(switch) does not need an operand; it can just list the cases, each of which
#      is a boolean expression:
     Un @c(switch) no necesita un operando; puede solo enumerar los casos, cada
     uno de los cuales es una expresion booleana:

#      ..src > go
#        func Signum(x int) int {
#          switch {
#          case x > 0:
#            return +1
#          default:
#            return 0
#          case x < 0:
#            return -1
#          }
#        }
#      < src..
     ..src > go
       func Signum(x int) int {
         switch {
         case x > 0:
           return +1
         default:
           return 0
         case x < 0:
           return -1
         }
       }
     < src..

#      This form is called a @e(tagless switch); it’s equivalent to @c(switch true).
     Esta forma se llama @e(switch sin etiquetas); que es equivalente a
     @c(switch true).

#      Like the @c(for) and @c(if) statements, a @c(switch) may include an
#      optional simple statement—a short variable declaration, an increment or
#      assignment statement, or a function call—that can be used to set a value
#      before it is tested.
     Al igual que las sentencias @c(for) e @c(if), un @c(switch) puede incluir
     una declaracion, una unica declaracion de variables compacta opcional, una
     declaracion de incremento o asignacion, o una funcion de llamada que se
     puede utilizar para establecer un valor antes de ser puesto a prueba.

#      The @c(break) and @c(continue) statements modify the flow of control. A
#      @c(break) causes control to resume at the next statement after the
#      innermost @c(for), @c(switch), or @c(select) statement (which we’ll see
#      later), and as we saw in @l(#Section 1.3), a @c(continue) causes the
#      innermost @c(for) loop to start its next iteration. Statements may be
#      labeled so that @c(break) and @c(continue) can refer to them, for
#      instance to break out of several nested loops at once or to start the
#      next iteration of the outermost loop. There is even a @c(goto) statement,
#      though it’s intended for machine-generated code, not regular use by
#      programmers.
     Las declaraciones @c(break) y @c(continue) modifican el flujo de control.
     Un @c(break) proboca que control se reanude la siguiente sentencia despues
     de la secuenca @c(for), @c(switch), o @c(select) (que veremos mas adelante)
     mas anidada, y como hemos visto en la @l(#Seccion 1.3), un @c(continue)
     proboca que el bucle @c(for) mas interno inicie su proxima iteracion. Las
     declaraciones pueden etiquetarse de forma que un @c(break) y @c(continue)
     pueden referirse a ellos, por ejemplo, para salir de varios bucles anidados
     a la vez o para iniciar la siguiente iteracion del bucle mas externo. Hay
     incluso una sentencia @c(goto), aunque esta destinada para el codigo
     generado por la maquina, sin el uso regular por los programadores.

#    - Named types :: A @c(type) declaration makes it possible to give a name to an
#      existing type. Since struct types are often long, they are nearly always
#      named. A familiar example is the definition of a @c(Point) type for a 2-D
#      graphics system:
   - Tipos con nombre :: Una declaracion @c(type) hace que sea posible dar un
     nombre a un tipo existente. Puesto que los tipos de la estructura son a
     menudo largos, se nombran casi siempre. Un ejemplo conocido es la
     definicion de un tipo para un sistema de graficos 2-D @c(Point):

#      ..src > go
#        type Point struct {
#          X, Y int
#        }
#        var p Point
#      < src..
     ..src > go
       type Point struct {
         X, Y int
       }
       var p Point
     < src..

#      Type declarations and named types are covered in @l(#Chapter 2).
     Las declaracion de tipos y tipos con nombre se trata en el @l(#Capitulo 2).

#    - Pointers :: Go provides pointers, that is, values that contain the address
#      of a variable. In some languages, notably C, pointers are relatively
#      unconstrained. In other languages, pointers are disguised as
#      @"(references,) and there’s not much that can be done with them except pass
#      them around. Go takes a position somewhere in the middle. Pointers are
#      explicitly visible. The @c(&) operator yields the address of a variable,
#      and the @c(*) operator retrieves the variable that the pointer refers to,
#      but there is no pointer arithmetic. We’ll explain pointers in @l(#Section
#      2.3.2).
   - Punteros :: Go proporciona punteros, es decir, los valores que contienen
     la direccion de una variable. En algunos lenguajes, notablemente C, los
     punteros son relativamente sin restricciones. En otros lenguajes, los
     punteros son disfrazados como @"(referencias), y no hay mucho que se pueda
     hacer con ellos, excepto pasarlos a alrededor. Go toma una posicion en
     algun lugar en el medio. Los punteros son explicitamente visibles. El operador
     @c(&) obtiene la direccion de una variable, y el operador @c(*) recupera la
     variable a la que se refiere el puntero, pero no hay aritmetica de
     punteros. Vamos a explicar los punteros en la @l(#Seccion 2.3.2).

#    - Methods and interfaces :: A method is a function associated with a named
#      type; Go is unusual in that methods may be attached to almost any named
#      type. Methods are covered in @l(#Chapter 6). Interfaces are abstract types
#      that let us treat different concrete types in the same way based on what
#      methods they have, not how they are represented or implemented. Interfaces
#      are the subject of @l(#Chapter 7).
   - Metodos e interfaces :: Un metodo es una funcion asociada con un tipo de
     dato; Go es inusual en el echo que los metodos se pueden vincular a casi
     cualquier tipo nombrado. Los Metodos son cubiertos en el @l(#Capitulo
     6). Las interfaces son tipos abstractos que nos permiten manejar tipos
     concretos diferentes de la misma manera basados ​​en que metodos tienen, no
     como se representan o implementan. Las interfaces son el tema del
     @l(#Capitulo 7).

#    - Packages :: Go comes with an extensive standard library of useful packages,
#      and the Go community has created and shared many more. Programming is often
#      more about using existing packages than about writing original code of
#      one’s own. Throughout the book, we will point out a couple of dozen of the
#      most important standard packages, but there are many more we don’t have
#      space to mention, and we cannot provide anything remotely like a complete
#      reference for any package.
   - Paquetes :: Go llega con una extensa libreria estandar de paquetes utiles,
     y la comunidad Go ha creado y compartido muchas mas. La programacion es a
     menudo mas sobre el uso de paquetes existentes que sobre la escritura de
     codigo propio original. A lo largo del libro, vamos a señalar un par de
     docenas de los paquetes estandar mas importantes, pero hay muchos mas que
     no tenemos espacio para mencionarlos, y no podemos proporcionar nada
     remotamente cercano a una referencia completa para cualquier paquete.

#      Before you embark on any new program, it’s a good idea to see if packages
#      already exist that might help you get your job done more easily. You can find
#      an index of the standard library packages at @l(https://golang.org/pkg) and
#      the packages contributed by the community at @l(https://godoc.org). The @$(go
#      doc) tool makes these documents easily accessible from the command line:
     Antes de embarcarse en cualquier programa nuevo, es una buena idea ver si
     ya existen paquetes que podrian ayudarle a hacer su trabajo mas facilmente.
     Puede encontrar un indice de los paquetes de librerias estandar en
     @l(https://golang.org/pkg) y los paquetes aportados por la comunidad en
     @l(https://godoc.org). La herramienta @$(go doc) hace que estos documentos
     sean facilmente accesibles desde la linea de comandos:

#      ..src > sh
#        $ go doc http.ListenAndServe
#        package http // import "net/http"
#
#        func ListenAndServe(addr string, handler Handler) error
#            ListenAndServe listens on the TCP network address addr and then
#            calls Serve with handler to handle requests on incoming connections.
#        ...
#      < src..
     ..src > sh
       $ go doc http.ListenAndServe
       package http // import "net/http"

       func ListenAndServe(addr string, handler Handler) error
           ListenAndServe listens on the TCP network address addr and then
           calls Serve with handler to handle requests on incoming connections.
       ...
     < src..

#    - Comments :: We have already mentioned documentation comments at the
#      beginning of a program or package. It’s also good style to write a comment
#      before the declaration of each function to specify its behavior. These
#      conventions are important, because they are used by tools like @$(go doc)
#      and @$(godoc) to locate and display documentation (@l(#Section
#      10.7.4<>§10.7.4)).
   - Comentarios :: Ya hemos mencionado los comentarios de documentacion al
     inicio de un programa o paquete. Tambien es un buen estilo escribir un
     comentario antes de la declaracion de cada funcion para especificar su
     comportamiento. Estas convenciones son importantes, ya que se utilizan por
     herramientas como @$(go doc) y @$(godoc) para localizar y monstrar la
     documentacion en pantalla (@l(#Seccion 10.7.4<>§10.7.4)).

#      For comments that span multiple lines or appear within an expression or
#      statement, there is also the @c(/* ... */) notation familiar from other
#      languages. Such comments are sometimes used at the beginning of a file for
#      a large block of explanatory text to avoid a @c(//) on every line. Within a
#      comment, @c(//) and @c(/*) have no special meaning, so comments do not
#      nest.
     Para los comentarios que abarcan varias lineas o aparecen dentro de una
     expresion o declaracion, tambien existe la conocida notacion @c(/* ... */)
     de otros lenguajes. Este tipo de comentarios se utilizan a veces al
     principio de un archivo en un gran bloque de texto explicativo para evitar
     un @c(//) en cada linea. Dentro de un comentario, @c(//) y @c(/*) no tienen
     ningun significado especial, por que los comentarios no se anidan.

# * Chapter 2 <> Program Structure
* Capitulo 2 <> Estructura del programa

#   In Go, as in any other programming language, one builds large programs from a
#   small set of basic constructs. Variables store values. Simple expressions are
#   combined into larger ones with operations like addition and subtraction. Basic
#   types are collected into aggregates like arrays and structs. Expressions are
#   used in statements whose execution order is determined by control-flow
#   statements like @c(if) and @c(for). Statements are grouped into functions for
#   isolation and reuse. Functions are gathered into source files and packages.
  En Go, como en cualquier otro lenguaje de programacion, se construyen grandes
  programas a partir de un pequeño conjunto de construcciones basicas. Las
  variables almacenan los valores. Las expresiones simples se combinan en las
  mas grandes con operaciones como suma y resta. Los tipos basicos se reunen en
  agregados como arreglos y estructuras. Las expresiones se utilizan en
  declaraciones cuyo orden de ejecucion es determinado por instrucciones de
  control de flujo como @c(if) y @c(for). Las declaraciones se agrupan en
  funciones por aislamiento y reutilizacion. Las funciones se agrupan en
  archivos de codigo fuente y paquetes.

#   We saw examples of most of these in the previous chapter. In this chapter,
#   we’ll go into more detail about the basic structural elements of a Go
#   program. The example programs are intentionally simple, so we can focus on the
#   language without getting sidetracked by complicated algorithms or data
#   structures.
  Vimos ejemplos de la mayoria de estos en el capitulo anterior. En este
  capitulo, vamos a entrar en mas detalles sobre los elementos estructurales
  basicos de un programa Go. Los programas de ejemplo son intencionalmente
  simples, por lo que podemos centrarnos en el lenguaje sin desviarnos de
  complicados algoritmos o estructuras de datos.

# ** Section 2.1 <> Names
** Seccion 2.1 <> Nombres

#    The names of Go functions, variables, constants, types, statement labels, and
#    packages follow a simple rule: a name begins with a letter (that is, anything
#    that Unicode deems a letter) or an underscore and may have any number of
#    additional letters, digits, and underscores. Case matters: @c(heapSort) and
#    @c(Heapsort) are different names.
   Los nombres de las funciones Go, variables, constantes, tipos, etiquetas de
   instrucciones y paquetes siguen una regla simple: un nombre comienza con una
   letra (es decir, cualquier cosa que Unicode considera una letra) o un guion
   bajo y puede tener cualquier numero de letras adicionales, Digitos y giones
   bajos. Las mayusculas importan: @c(heapSort) y @c(Heapsort) son nombres
   diferentes.

#    Go has 25 @e(keywords) like @c(if) and @c(switch) that may be used only where the
#    syntax permits; they can’t be used as names.
   Go tiene 25 @e(palabras claves) como @c(if) y @c(switch) que solo pueden
   utilizarse cuando la sintaxis lo permita; No pueden usarse como nombres.

#    ..pre >
#      break      default       func     interface   select
#      case       defer         go       map         struct
#      chan       else          goto     package     switch
#      const      fallthrough   if       range       type
#      continue   for           import   return      var
#    < pre..
   ..pre >
     break      default       func     interface   select
     case       defer         go       map         struct
     chan       else          goto     package     switch
     const      fallthrough   if       range       type
     continue   for           import   return      var
   < pre..

#    In addition, there are about three dozen @e(predeclared) names like @c(int)
#    and @c(true) for built-in constants, types, and functions:
   Ademas, hay cerca de tres docenas de nombres @e(predeclarados) como @c(int) y
   @c(true) para las constantes, tipos y funciones nativas:

#    - Constants ::
   - Constantes ::

#      ..pre >
#        true false iota nil
     ..pre >
       true false iota nil

#    - Types     ::
   - Tipos      ::

#      ..pre >
#        int int8 int16 int32 int64
#        uint uint8 uint16 uint32 uint64 uintptr
#        float32 float64 complex128 complex64
#        bool byte rune string error
     ..pre >
       int  int8  int16  int32  int64
       uint uint8 uint16 uint32 uint64 uintptr
       float32 float64 complex64 complex128
       bool byte rune string error

#    - Functions ::
   - Funciones  ::

#      ..pre >
#        make len cap new append copy close delete
#        complex real imag
#        panic recover
     ..pre >
       make len cap new append copy close delete
       complex real imag
       panic recover


#    These names are not reserved, so you may use them in declarations. We’ll see
#    a handful of places where redeclaring one of them makes sense, but beware of
#    the potential for confusion.
   Estos nombres no estan reservados, por lo que puede utilizarlos en
   declaraciones. Vamos a ver un puñado de lugares donde redeclarar uno de
   ellos tiene sentido, pero tenga cuidado con la potencial confusion.

#    If an entity is declared within a function, it is @e(local) to that
#    function. If declared outside of a function, however, it is visible in all
#    files of the package to which it belongs. The case of the first letter of a
#    name determines its visibility across package boundaries. If the name begins
#    with an upper-case letter, it is @e(exported), which means that it is visible
#    and accessible outside of its own package and may be referred to by other
#    parts of the program, as with @c(Printf) in the @c(fmt) package. Package
#    names themselves are always in lower case.
   Si una entidad se declara dentro de una funcion, esta es @e(local) a esa
   funcion. Si se declara fuera de una funcion, sin embargo, es visible en todos
   los archivos del paquete al que pertenece. La primer letra de un nombre
   determina su visibilidad a traves de los limites del paquete. Si el nombre
   comienza con una letra mayuscula, se exporta, lo que significa que es visible
   y accesible fuera de su propio paquete y puede hacer referencia a otras
   partes del programa, al igual que con @c(Printf) en el paquete @c(fmt). Los
   nombres de los paquetes estan siempre en minusculas.

#    There is no limit on name length, but convention and style in Go programs
#    lean toward short names, especially for local variables with small scopes;
#    you are much more likely to see variables named @c(i) than @c(theLoopIndex).
#    Generally, the larger the scope of a name, the longer and more meaningful it
#    should be.
   No hay limite en la longitud del nombre, pero la convencion y el estilo en
   los programas de Go se inclinan hacia nombres cortos, especialmente para
   variables locales con ambitos pequeños; es mucho mas probable ver variables
   con nombre @c(i) que @c(indiceDelBucle). Generalmente, cuanto mayor es el
   alcance de un nombre, mas largo y mas significativo debe ser.

#    Stylistically, Go programmers use @"(camel case) when forming names by
#    combining words; that is, interior capital letters are preferred over
#    interior underscores. Thus the standard libraries have functions with names
#    like @c(QuoteRuneToASCII) and @c(parseRequestLine) but never
#    @c(quote_rune_to_ASCII) or @c(parse_request_line). The letters of acronyms
#    and initialisms like @A(ASCII) and @A(HTML) are always rendered in the same
#    case, so a function might be called @c(htmlEscape), @c(HTMLEscape), or @c(escapeHTML),
#    but not @c(escapeHtml).
   Estilisticamente, los programadores Go utilizan la @"(notacion camello)
   cuando se forma nombres mediante la combinacion de palabras; Es decir, las
   letras mayusculas internas se prefieren sobre los subrayados interiores. Por
   lo tanto las librerias estandar tienen funciones con nombres como
   @c(QuoteRuneToASCII) y @c(parseRequestLine) pero nunca @c(quote_rune_to_ASCII)
   o @c(parse_request_line). Las letras de acronimos y siglas como @A(ASCII) y
   @A(HTML) siempre se prestan en el mismo tipo, por lo que una funcion sera
   llamada @c(htmlEscape), @c(HTMLEscape) o @c(escapeHTML), pero no
   @c(escapeHtml).

# ** Section 2.2 <> Declarations
** Seccion 2.2 <> Declaraciones

#    A @e(declaration) names a program entity and specifies some or all of its
#    properties. There are four major kinds of declarations: @c(var), @c(const),
#    @c(type), and @c(func). We’ll talk about variables and types in this chapter,
#    constants in @l(#Chapter 3), and functions in @l(#Chapter 5).
   Una @e(declaracion) nombra una entidad del programa y especifica todas o
   algunas de sus propiedades. Hay cuatro tipos principales de declaraciones:
   @c(var), @c(const), @c(type) y @c(func). Hablaremos sobre variables y tipos
   en este capitulo, constantes en el @l(#Capitulo 3), y funciones en el
   @l(#Capitulo 5).

#    A Go program is stored in one or more files whose names end in @f(.go). Each
#    file begins with a @c(package) declaration that says what package the file is
#    part of. The @c(package) declaration is followed by any @c(import)
#    declarations, and then a sequence of @e(package-level) declarations of types,
#    variables, constants, and functions, in any order. For example, this program
#    declares a constant, a function, and a couple of variables:
   Un programa Go se almacena en uno o mas archivos cuyos nombres terminan en
   @f(.go). Cada archivo comienza con una declaracion @c(package) que indica de
   que paquete forma parte el archivo. La declaracion @c(package) es seguida por
   cualquier numero de declaraciones @c(import), y luego una secuencia de
   declaraciones a nivel de paquete, como tipos, variables, constantes y funciones,
   en cualquier orden. Por ejemplo, este programa declara una constante, una
   funcion y un par de variables:

#    ..figure > @l(gopl.io/ch2/boiling/main.go<>gopl.io/ch2/boiling)
   ..figure > @l(gopl.io/ch2/boiling/main.go<>gopl.io/ch2/boiling)

#      ..src > go
#        // Boiling prints the boiling point of water.
#        package main
#
#        import "fmt"
#
#        const boilingF = 212.0
#
#        func main() {
#          var f = boilingF
#          var c = (f - 32) * 5 / 9
#          fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
#          // Output:
#          // boiling point = 212°F or 100°C
#        }
#      < src..
     ..src > go
       // Boiling imprime el punto de ebullicion del agua.
       package main

       import "fmt"

       const boilingF = 212.0

       func main() {
         var f = boilingF
         var c = (f - 32) * 5 / 9
         fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
         // Salida:
         // boiling point = 212°F or 100°C
       }
     < src..


#    The constant @c(boilingF) is a package-level declaration (as is @c(main)),
#    whereas the variables @c(f) and @c(c) are local to the function @c(main). The
#    name of each package-level entity is visible not only throughout the source
#    file that contains its declaration, but throughout all the files of the
#    package. By contrast, local declarations are visible only within the function
#    in which they are declared and perhaps only within a small part of it.
   La constante @c(boilingF) es una declaracion de nivel de paquete (como es
   @c(main)), mientras que las variables @c(f) y @c(c) son locales a la funcion
   @c(main). El nombre de cada entidad de nivel de paquete es visible no solo en
   todo el archivo de origen que contiene su declaracion, sino en todos los
   archivos del paquete. Por el contrario, las declaraciones locales son
   visibles solo dentro de la funcion en la que se declaran y tal vez solo
   dentro de una pequeña parte de ella.

#    A function declaration has a name, a list of parameters (the variables whose
#    values are provided by the function’s callers), an optional list of results,
#    and the function body, which contains the statements that define what the
#    function does. The result list is omitted if the function does not return
#    anything. Execution of the function begins with the first statement and
#    continues until it encounters a return statement or reaches the end of a
#    function that has no results. Control and any results are then returned to
#    the caller.
   Una declaracion de funcion tiene un nombre, una lista de parametros (las
   variables cuyos valores se proporcionan por quien llama a la funcion), una
   lista opcional de resultados y el cuerpo de la funcion, que contiene las
   sentencias que definen lo que hace la funcion. La lista de resultados se
   omite si la funcion no devuelve nada. La ejecucion de la funcion comienza con
   la primer instruccion y continua hasta que encuentra una instruccion de
   retorno o llega al final de una funcion que no tiene resultados. El control y
   los resultados se devuelven a quien hiso la llamada.

#    We’ve seen a fair number of functions already and there are lots more to
#    come, including an extensive discussion in @l(#Chapter 5), so this is only a
#    sketch. The function @c(fToC) below encapsulates the temperature conversion
#    logic so that it is defined only once but may be used from multiple
#    places. Here @c(main) calls it twice, using the values of two different local
#    constants:
   Hemos visto un buen numero de funciones ya y hay muchas mas por venir,
   incluyendo una extenso tratamiento en el @l(#Capitulo 5), asi que esto es
   solo un esbozo. La funcion @c(fToC) a continuacion, encapsula la logica de
   conversion de temperatura de manera que se define solo una vez, pero puede
   utilizarse desde multiples lugares. Aqui @c(main) la llama dos veces,
   utilizando los valores de las dos constantes locales diferentes:

#    ..figure > @l(gopl.io/ch2/ftoc/main.go<>gopl.io/ch2/ftoc)
   ..figure > @l(gopl.io/ch2/ftoc/main.go<>gopl.io/ch2/ftoc)

#      ..src > go
#        // Ftoc prints two Fahrenheit-to-Celsius conversions.
#        package main
#
#        import "fmt"
#
#        func main() {
#          const freezingF, boilingF = 32.0, 212.0
#          fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
#          fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
#        }
#
#        func fToC(f float64) float64 {
#          return (f - 32) * 5 / 9
#        }
#      < src..
     ..src > go
       // Ftoc imprime dos conversiones de Fahrenheit a Celsius.
       package main

       import "fmt"

       func main() {
         const freezingF, boilingF = 32.0, 212.0
         fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
         fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
       }

       func fToC(f float64) float64 {
         return (f - 32) * 5 / 9
       }
     < src..

# ** Section 2.3 <> Variables
** Seccion 2.3 <> Variables

#    A @c(var) declaration creates a variable of a particular type, attaches a
#    name to it, and sets its initial value. Each declaration has the general form
   Un declaracion @c(var) crea una variable de un tipo particular, vinculando un
   nombre a la misma, y definiendo su valor inicial. Cada declaracion tiene la
   forma general

#    ..src > go
#      var name type = expression
#    < src..
   ..src > go
     var nombre tipo = expresion
   < src..

#    Either the type or the @c(= expression) part may be omitted, but not both. If
#    the type is omitted, it is determined by the initializer expression. If the
#    expression is omitted, the initial value is the @e(zero value) for the type,
#    which is @c(0) for numbers, @c(false) for booleans, @c("") for strings, and
#    @c(nil) for interfaces and reference types (slice, pointer, map, channel,
#    function). The zero value of an aggregate type like an array or a struct has
#    the zero value of all of its elements or fields.
   O bien el tipo o la parte @c(= expresion) pueden omitirse, pero no ambos. Si
   se omite el tipo, se determina mediante la expresion del inicializador. Si se
   omite la expresion, el valor inicial es el @e(valor cero) para el tipo, que
   es 0 para los numeros, @c(false) para booleanos, @c("") para string, y
   @c(nil) para interfaces y tipos de referencia (slices, punteros, mapa, canal,
   funcion). El valor cero de un tipo agregado como una matriz o una estructura
   tiene el valor cero de todos sus elementos o campos.

#    The zero-value mechanism ensures that a variable always holds a well-defined
#    value of its type; in Go there is no such thing as an uninitialized
#    variable. This simplifies code and often ensures sensible behavior of
#    boundary conditions without extra work. For example,
   El mecanismo de valor cero asegura que una variable siempre tenga un valor
   bien definido de su tipo; En Go no hay tal cosa como una variable no
   inicializada. Esto simplifica el codigo y, a menudo, asegura un
   comportamiento sensible de las condiciones limite sin trabajo adicional. Por
   ejemplo,

#    ..src > go
#      var s string
#      fmt.Println(s) // ""
#    < src..
   ..src > go
     var s string
     fmt.Println(s) // ""
   < src..

#    prints an empty string, rather than causing some kind of error or
#    unpredictable behavior. Go programmers often go to some effort to make the
#    zero value of a more complicated type meaningful, so that variables begin
#    life in a useful state.
   Imprime una cadena vacia, en lugar de causar algun tipo de error o
   comportamiento impredecible. Los programadores Go, suelen hacer algun
   esfuerzo por hacer el valor cero de un tipo mas complicado significativo, por
   lo que las variables comienzan su vida en un estado util.

#    It is possible to declare and optionally initialize a set of variables in a
#    single declaration, with a matching list of expressions. Omitting the type
#    allows declaration of multiple variables of different types:
   Es posible declarar y opcionalmente inicializar un conjunto de variables en
   una sola declaracion, con una lista de expresiones correspondiente. Omitir el
   tipo permite la declaracion de multiples variables de diferentes tipos:

#    ..src > go
#      var i, j, k int                 // int, int, int
#      var b, f, s = true, 2.3, "four" // bool, float64, string
#    < src..
   ..src > go
     var i, j, k int                 // int, int, int
     var b, f, s = true, 2.3, "four" // bool, float64, string
   < src..

#    Initializers may be literal values or arbitrary expressions. Package-level
#    variables are initialized before @c(main) begins (@l(#Section
#    2.6.2<>§2.6.2)), and local variables are initialized as their declarations
#    are encountered during function execution.
   Los inicializadores pueden ser valores literales o expresiones arbitrarias.
   Las variables a nivel de paquete se inicializan antes del inicio de @c(main)
   (@l(#Seccion 2.6.2<>§2.6.2)), y las variables locales se inicializan a medida
   que se encuentran sus declaraciones durante la ejecucion de la funcion.

#    A set of variables can also be initialized by calling a function that returns
#    multiple values:
   Tambien se puede inicializar un conjunto de variables llamando a una funcion
   que devuelve valores multiples:

#    ..src > go
#      var f, err = os.Open(name) // os.Open returns a file and an error
#    < src..
   ..src > go
     var f, err = os.Open(name) // os.Open returns a file and an error
   < src..

# *** Section 2.3.1 <> Short Variable Declarations
*** Seccion 2.3.1 <> Declaraciones de Variables Compacta

#     Within a function, an alternate form called a @e(short variable declaration)
#     may be used to declare and initialize local variables. It takes the form
#     @c(name := expression), and the type of @c(name) is determined by the type
#     of @c(expression). Here are three of the many short variable declarations in
#     the @c(lissajous) function (@l(#Section 1.4<>§1.4)):
    Dentro de una funcion, una forma alternativa llamada @e(declaracion de
    variables compacta) se puede usar para declarar e inicializar las variables
    locales. Toma la forma @c(nombre := expresion), y el tipo de @c(nombre) esta
    determinada por el tipo de @c(expresion). Aqui estan tres de las muchas
    declaraciones de variables compacta en la funcion @c(lissajous) (@l(#Seccion
    1.4<>§1.4)):

#     ..src > go
#       anim := gif.GIF{LoopCount: nframes}
#       freq := rand.Float64() * 3.0
#       t := 0.0
#     < src..
    ..src > go
      anim := gif.GIF{LoopCount: nframes}
      freq := rand.Float64() * 3.0
      t := 0.0
    < src..

#     Because of their brevity and flexibility, short variable declarations are
#     used to declare and initialize the majority of local variables. A @c(var)
#     declaration tends to be reserved for local variables that need an explicit
#     type that differs from that of the initializer expression, or for when the
#     variable will be assigned a value later and its initial value is
#     unimportant.
    Debido a su brevedad y flexibilidad, la declaracion compacta de variables se
    utilizan para declarar e inicializar la mayoria de las variables
    locales. Una sentencia @c(var) tiende a ser reservado para las variables
    locales que necesitan un tipo explicito que difiere de la de la expresion de
    inicializacion, o para cuando se le asignara un valor mas adelante la
    variable y su valor inicial no es importante.

#     ..src > go
#       i := 100                  // an int
#       var boiling float64 = 100 // a float64
#
#       var names []string
#       var err error
#       var p Point
#     < src..
    ..src > go
      i := 100                  // un int
      var boiling float64 = 100 // un float64

      var names []string
      var err error
      var p Point
    < src..

#     As with @c(var) declarations, multiple variables may be declared and initialized
#     in the same short variable declaration,
    Como con las sentencias @c(var), multiples variables pueden ser declaradas e
    inicializadas en la misma declaracion compacta de variables,

#     ..src > go
#       i, j := 0, 1
#     < src..
    ..src > go
      i, j := 0, 1
    < src..

#     but declarations with multiple initializer expressions should be used only
#     when they help readability, such as for short and natural groupings like the
#     initialization part of a @c(for) loop.
    pero las declaraciones con multiples expresiones de inicializador deben
    utilizarse solo cuando ayudan a la legibilidad, como en agrupaciones cortas
    y naturales, como la parte de inicializacion de un bucle @c(for).

#     Keep in mind that @c(:=) is a declaration, whereas @c(=) is an assignment. A
#     multi-variable declaration should not be confused with a @e(tuple
#     assignment) (@l(#Section 2.4.1<>§2.4.1)), in which each variable on the
#     left-hand side is assigned the corresponding value from the right-hand side:
    Tenga en cuenta que @c(:=) es una declaracion, mientras que @c(=) es una
    asignacion. Una declaracion de multiples variables no debe confundirse con
    una asignacion de tuplas (@l(#Seccion 2.4.1<>§2.4.1)), en la que se asigna a
    cada variable en el lado de la izquierda el valor correspondiente de la
    parte derecha:

#     ..src > go
#       i, j = j, i // swap values of i and j
#     < src..
    ..src > go
      i, j = j, i // intercambiar valores de i y j
    < src..

#     Like ordinary @c(var) declarations, short variable declarations may be used
#     for calls to functions like @c(os.Open) that return two or more values:
    Al igual que en declaraciones @c(var) ordinarias, la declaraciones de
    variables compacta se puede utilizar para las llamadas a funciones como
    @c(os.Open) que devuelve dos o mas valores:

#     ..src > go
#       f, err := os.Open(name)
#       if err != nil {
#         return err
#       }
#       // ...use f...
#       f.Close()
#     < src..
    ..src > go
      f, err := os.Open(name)
      if err != nil {
        return err
      }
      // ...use f...
      f.Close()
    < src..

#     One subtle but important point: a short variable declaration does not
#     necessarily @e(declare) all the variables on its left-hand side. If some of
#     them were already declared in the @e(same) lexical block (@l(#Section
#     2.7<>§2.7)), then the short variable declaration acts like an @e(assignment)
#     to those variables.
    Un punto sutil pero importante: una declaracion de variables compacta no
    declara necesariamente todas las variables en su lado izquierdo. Si algunos
    de ellos ya fueron declarados en el @e(mismo) bloque lexico (@l(#Seccion
    2.7<>§2.7)), entonces la declaracion de variables compacta se comporta como
    una asignacion a esas variables.

#     In the code below, the first statement declares both @c(in) and @c(err). The second
#     declares @c(out) but only assigns a value to the existing @c(err) variable.
    En el codigo siguiente, la primera sentencia declara tanto @c(in) como
    @c(err). El segundo declara @c(out) pero solo asigna un valor a la variable
    @c(err) existente.

#     ..src > go
#       in, err := os.Open(infile)
#       // ...
#       out, err := os.Create(outfile)
#     < src..
    ..src > go
      in, err := os.Open(infile)
      // ...
      out, err := os.Create(outfile)
    < src..

#     A short variable declaration must declare at least one new variable,
#     however, so this code will not compile:
    Sin embargo, una declaracion de variable corta debe declarar al menos una
    variable nueva, por lo que este codigo no compilara:

#     ..src > go
#       f, err := os.Open(infile)
#       // ...
#       f, err := os.Create(outfile) // compile error: no new variables
#     < src..
    ..src > go
      f, err := os.Open(infile)
      // ...
      f, err := os.Create(outfile) // error de compilacion: no hay nuevas variables
    < src..


#     The fix is to use an ordinary assignment for the second statement.
    La correccion consiste en utilizar una asignacion ordinaria para la segunda
    instruccion.

#     A short variable declaration acts like an assignment only to variables that
#     were already declared in the same lexical block; declarations in an outer
#     block are ignored. We’ll see examples of this at the end of the chapter.
    Una declaracion de variable compacta actua como una asignacion solo a
    variables que ya estaban declaradas en el mismo bloque lexico; Las
    declaraciones en un bloque externo se ignoran. Veremos ejemplos de esto al
    final del capitulo.

# *** Section 2.3.2 <> Pointers
*** Seccion 2.3.2 <> Punteros

#     A @e(variable) is a piece of storage containing a value. Variables created
#     by declarations are identified by a name, such as @c(x), but many variables
#     are identified only by expressions like @c(x[i]) or @c(x.f). All these
#     expressions read the value of a variable, except when they appear on the
#     lefthand side of an assignment, in which case a new value is assigned to the
#     variable.
    Una variable es una pieza de almacenamiento que contiene un valor. Las
    variables creadas por las declaraciones se identifican por un nombre, como
    @c(x), pero muchas variables se idientifican solo por expresiones como
    @c(x[i]) o @c(x.f). Todas estas expresiones leen el valor de una variable,
    excepto cuando aparecen en el lado izquierdo de una asignacion, en cuyo caso
    se asigna un nuevo valor a la variable.

#     A @e(pointer) value is the @e(address) of a variable. A pointer is thus the
#     location at which a value is stored. Not every value has an address, but
#     every variable does. With a pointer, we can read or update the value of a
#     variable @e(indirectly), without using or even knowing the name of the
#     variable, if indeed it has a name.
    El valor de un @e(puntero) es la @e(direccion) de una variable. Un puntero
    es, por tanto, la ubicacion en la que se almacena un valor. No todos los
    valores tienen una direccion, pero todas las variables si. Con un puntero,
    podemos leer o actualizar el valor de una variable @e(indirectamente), sin
    utilizar o incluso saber el nombre de la variable, si es que tiene un
    nombre.

#     If a variable is declared @c(var x int), the expression @c(&x) (@"(address of
#     @c(x))) yields a pointer to an integer variable, that is, a value of type
#     @c(*int), which is pronounced @"(pointer to int.) If this value is called
#     @c(p), we say @"(@c(p) points to @c(x),) or equivalently @"(@c(p) contains
#     the address of @c(x).) The variable to which @c(p) points is written
#     @c(*p). The expression @c(*p) yields the value of that variable, an @c(int),
#     but since @c(*p) denotes a variable, it may also appear on the left-hand
#     side of an assignment, in which case the assignment updates the variable.
    Si se declara una variable @c(var x int), la expresion @c(&x) (@"(direccion
    de @c(x))) produce un puntero a una variable de de tipo entero, es decir, un
    valor de tipo @c(*int), que se pronuncia @"(puntero a int.) Si este valor se
    llama @c(p), decimos @"(@c(p) apunta a @c(x),)" o equivalentemente @"(@c(p)
    contiene la direccion de @c(x).) La variable a la que @c(p) apunta se
    escribe @c(*p). La expresion @c(*p) produce el valor de dicha variable, un
    @c(int), pero ya que @c(*p) indica una variable, tambien puede aparecer en la
    parte izquierda de una asignacion, en cuyo caso la asignacion actualiza la
    variable.

#     ..src > go
#       x := 1
#       p := &x         // p, of type *int, points to x
#       fmt.Println(*p) // "1"
#       *p = 2          // equivalent to x = 2
#       fmt.Println(x)  // "2"
#     < src..
    ..src > go
      x := 1
      p := &x         // p, de tipo *int, apunta a x
      fmt.Println(*p) // "1"
      *p = 2          // equivalente a x = 2
      fmt.Println(x)  // "2"
    < src..

#     Each component of a variable of aggregate type—a field of a struct or an
#     element of an array— is also a variable and thus has an address too.
    Cada componente de una variable de tipo agregado–un campo de una estructura
    o un elemento de una matriz–es tambien una variable y por lo tanto tiene
    una direccion tambien.

#     Variables are sometimes described as @e(addressable) values. Expressions
#     that denote variables are the only expressions to which the @e(address-of)
#     operator @c(&) may be applied.
    Las variables se describen a veces como valores @e(direccionables).
    Expresiones que denotan variables son las unicas expresiones a las que el
    operador de direccion @c(&) se puede aplicar.

#     The zero value for a pointer of any type is @c(nil). The test @c(p != nil) is true
#     if @c(p) points to a variable. Pointers are comparable; two pointers are equal
#     if and only if they point to the same variable or both are nil.
    El valor cero de un puntero de cualquier tipo es @c(nil). La prueba de @c(p
    != nil) es verdadera si @c(p) apunta a una variable. Los punteros son
    comparables; Dos punteros son iguales si y solo si apuntan a la misma
    variable o ambos son @c(nil).

#     ..src > go
#       var x, y int
#       fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
#     < src..
    ..src > go
      var x, y int
      fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
    < src..

#     It is perfectly safe for a function to return the address of a local
#     variable. For instance, in the code below, the local variable @c(v) created by
#     this particular call to @c(f) will remain in existence even after the call has
#     returned, and the pointer @c(p) will still refer to it:
    Es perfectamente seguro para una funcion devolver la direccion de una
    variable local. Por ejemplo, en el codigo siguiente, la variable local @c(v)
    creada por la llamada a @c(f) seguira existiendo incluso despues de devolver
    la llamada, y el puntero @c(p) todavia se referira a ella:

#     ..src > go
#       var p = f()
#
#       func f() *int {
#         v := 1
#         return &v
#       }
#     < src..
    ..src > go
      var p = f()

      func f() *int {
        v := 1
        return &v
      }
    < src..

#     Each call of @c(f) returns a distinct value:
    Cada llamada a @c(f) devuelve un valor distinto:

#     ..src > go
#       fmt.Println(f() == f()) // "false"
#     < src..
    ..src > go
      fmt.Println(f() == f()) // "false"
    < src..

#     Because a pointer contains the address of a variable, passing a pointer
#     argument to a function makes it possible for the function to update the
#     variable that was indirectly passed. For example, this function increments
#     the variable that its argument points to and returns the new value of the
#     variable so it may be used in an expression:
    Debido a que un puntero contiene la direccion de una variable, pasar un
    argumento de puntero a una funcion hace posible que la funcion actualice la
    variable que se paso indirectamente. Por ejemplo, esta funcion incrementa la
    variable a la que apunta su argumento y devuelve el nuevo valor de la
    variable para que pueda ser utilizada en una expresion:

#     ..src > go
#       func incr(p *int) int {
#         *p++ // increments what p points to; does not change p
#         return *p
#       }
#
#       v := 1
#       incr(&v)              // side effect: v is now 2
#       fmt.Println(incr(&v)) // "3" (and v is 3)
#     < src..
    ..src > go
      func incr(p *int) int {
        *p++ // incrementa a lo que apunta p; no cambia p
        return *p
      }

      v := 1
      incr(&v)              // efecto secundario: ahora v es 2
      fmt.Println(incr(&v)) // "3" (y v es 3)
    < src..

#     Each time we take the address of a variable or copy a pointer, we create new
#     @e(aliases) or ways to identify the same variable. For example, @c(*p) is an
#     alias for @c(v). Pointer aliasing is useful because it allows us to access a
#     variable without using its name, but this is a double-edged sword: to find
#     all the statements that access a variable, we have to know all its
#     aliases. It’s not just pointers that create aliases; aliasing also occurs
#     when we copy values of other reference types like slices, maps, and
#     channels, and even structs, arrays, and interfaces that contain these types.
    Cada vez que se toma la direccion de una variable o se copia un puntero,
    creamos nuevos @e(alias) o maneras de identificar a la misma variable. Por
    ejemplo, @c(*p) es un alias para @c(v). Los punteros como alias son utiles
    porque nos permite acceder a una variable sin usar su nombre, pero esto es
    una espada de doble filo: para encontrar todas las sentencias que acceden a
    una variable, tenemos que conocer todos sus alias. No son solo los punteros
    que crean alias; los alias tambien se crean cuando copiamos valores de otros
    tipos de referencia como slices, mapas y canales, e incluso estructuras,
    matrices e interfaces que contienen estos tipos.

#     Pointers are key to the @c(flag) package, which uses a program’s
#     command-line arguments to set the values of certain variables distributed
#     throughout the program. To illustrate, this variation on the earlier
#     @$(echo) command takes two optional flags: @c(-n) causes @$(echo) to omit
#     the trailing newline that would normally be printed, and @c(-s sep) causes
#     it to separate the output arguments by the contents of the string @c(sep)
#     instead of the default single space. Since this is our fourth version, the
#     package is called @f(gopl.io/ch2/echo4).
    Los punteros son clave para el paquete @c(flag), que utiliza los argumentos
    de linea de comandos de un programa, para establecer los valores de ciertas
    variables distribuidas a lo largo del programa. Para ilustrar, esta
    variacion en el anterior comando @$(echo) tiene dos indicadores opcionales:
    @c(-n) provoca que @$(echo) omita el salto de linea final que normalmente se
    imprime, y @c(-s sep) hace que se separe los argumentos de salida por el
    contenido de la cadena @c(sep) en lugar de el espacio unico predeterminado.
    Como esta es nuestra cuarta version, el paquete se llama @f(gopl.io/ch2/echo4).

#     ..figure > @l(gopl.io/ch2/echo4/main.go<>gopl.io/ch2/echo4)
    ..figure > @l(gopl.io/ch2/echo4/main.go<>gopl.io/ch2/echo4)

#       ..src > go
#         // Echo4 prints its command-line arguments.
#         package main
#
#         import (
#           "flag"
#           "fmt"
#           "strings"
#         )
#
#         var n = flag.Bool("n", false, "omit trailing newline")
#         var sep = flag.String("s", " ", "separator")
#
#         func main() {
#           flag.Parse()
#           fmt.Print(strings.Join(flag.Args(), *sep))
#           if !*n {
#             fmt.Println()
#           }
#         }
#       < src..
      ..src > go
        // Echo4 imprime sus argumentos de linea de comandos.
        package main

        import (
          "flag"
          "fmt"
          "strings"
        )

        var n = flag.Bool("n", false, "omitir linea nueva de salida")
        var sep = flag.String("s", " ", "separador")

        func main() {
          flag.Parse()
          fmt.Print(strings.Join(flag.Args(), *sep))
          if !*n {
            fmt.Println()
          }
        }
      < src..


#     The function @c(flag.Bool) creates a new flag variable of type @c(bool). It
#     takes three arguments: the name of the flag (@c("n")), the variable’s
#     default value (@c(false)), and a message that will be printed if the user
#     provides an invalid argument, an invalid flag, or @c(-h) or
#     @c(-help). Similarly, @c(flag.String) takes a name, a default value, and a
#     message, and creates a @c(string) variable. The variables @c(sep) and @c(n)
#     are pointers to the flag variables, which must be accessed indirectly as
#     @c(*sep) and @c(*n).
    La funcion @c(flag.Bool) crea una nueva variable bandera de tipo @c(bool).
    Toma tres argumentos: el nombre de la bandera (@c("n")), el valor por
    defecto de la variable (@c(false)), y un mensaje que se imprimira si el
    usuario proporciona un argumento invalido, una bandera invalida, o @c(-h) o
    @c(-help). Del mismo modo, @c(flag.String) toma un nombre, un valor por
    defecto, y un mensaje, y crea una variable @c(string). Las variables @c(sep)
    y @c(n) son punteros a las variables de la bandera, que deben accederse
    indirectamente como @c(*sep) y @c(*n).

#     When the program is run, it must call @c(flag.Parse) before the flags are
#     used, to update the flag variables from their default values. The non-flag
#     arguments are available from @c[flag.Args()] as a slice of strings. If
#     @c(flag.Parse) encounters an error, it prints a usage message and calls
#     @c[os.Exit(2)] to terminate the program.
    Cuando se ejecuta el programa, debe llamar a @c(flag.Parse) antes de
    utilizar las banderas, para actualizar las variables bandera de sus valores
    por defecto. Los argumentos que no sean banderas estan disponibles mediante
    @c[flag.Args()] como un slice de strings. Si @c(flag.Parse) encuentra un
    error, se imprime un mensaje sobre el uso y llama a @c[os.Exit(2)] para terminar
    el programa.

#     Let’s run some test cases on @$(echo):
    Vamos a ejecutar algunos casos de prueba a @$(echo):

#     ..src > sh
#       $ go build gopl.io/ch2/echo4
#       $ ./echo4 a bc def
#       a bc def
#       $ ./echo4 -s / a bc def
#       a/bc/def
#       $ ./echo4 -n a bc def
#       a bc def$
#       $ ./echo4 -help
#       Usage of ./echo4:
#         -n    omit trailing newline
#         -s string
#               separator (default " ")
#     < src..
    ..src > sh
      $ go build gopl.io/ch2/echo4
      $ ./echo4 a bc def
      a bc def
      $ ./echo4 -s / a bc def
      a/bc/def
      $ ./echo4 -n a bc def
      a bc def$
      $ ./echo4 -help
      Usage of ./echo4:
        -n    omit trailing newline
        -s string
              separator (default " ")
    < src..

# *** Section 2.3.3 <> The @c(new) Function
*** Seccion 2.3.3 <> La Funcion @c(new)

#     Another way to create a variable is to use the built-in function @c(new).
#     The expression @c[new(T)] creates an @e(unnamed variable) of type @c(T),
#     initializes it to the zero value of @c(T), and returns its address, which is
#     a value of type @c(*T).
    Otra forma de crear una variable es utilizar la funcion nativa @c(new). La
    expresion @c[new(T)] crea una @e(variable sin nombre) del tipo @c(T), la
    inicializa al valor cero de @c(T), y devuelve su direccion, que es un valor
    de tipo @c(*T).

#     ..src > go
#       p := new(int)   //  p, of type *int, points to an unnamed int variable
#       fmt.Println(*p) //  "0"
#       *p = 2          //  sets the unnamed int to 2
#       fmt.Println(*p) //  "2"
#     < src..
    ..src > go
      p := new(int)   //  p, de tipo *int, apunta a una varible int sin nombre
      fmt.Println(*p) //  "0"
      *p = 2          //  establece el int sin nombre a 2
      fmt.Println(*p) //  "2"
    < src..

#     A variable created with @c(new) is no different from an ordinary local
#     variable whose address is taken, except that there’s no need to invent (and
#     declare) a dummy name, and we can use @c[new(T)] in an expression. Thus
#     @c(new) is only a syntactic convenience, not a fundamental notion:
    Una variable creada con @c(new) no es diferente de una variable local
    ordinaria cuya direccion es tomada, excepto que no hay necesidad de inventar
    (y declarar) un nombre ficticio, y podemos usar @c[new(T)] en una expresion.
    De este modo @c(new) es solo una conveniencia sintactica, no es una idea
    fundamental:

#     the two @c(newInt) functions below have identical behaviors.
    las dos funciones @c(newInt) a continuacion tienen comportamientos
    identicos.

#     ..cols >
    ..cols >

#       ..src > go
#         func newInt() *int {
#           return new(int)
#         }
#       < src..
      ..src > go
        func newInt() *int {
          return new(int)
        }
      < src..

#       ::
      ::

#       ..src > go
#         func newInt() *int {
#           var dummy int
#           return &dummy
#         }
#       < src..
      ..src > go
        func newInt() *int {
          var dummy int
          return &dummy
        }
      < src..

#     Each call to @c(new) returns a distinct variable with a unique address:
    Cada llamada a @c(new) devuelve una variable distinta con una direccion
    unica:

#     ..src > go
#       p := new(int)
#       q := new(int)
#       fmt.Println(p == q) // "false"
#     < src..
    ..src > go
      p := new(int)
      q := new(int)
      fmt.Println(p == q) // "false"
    < src..

#     There is one exception to this rule: two variables whose type carries no
#     information and is therefore of size zero, such as @c(struct{}) or
#     @c([0]int), may, depending on the implementation, have the same address.
    Hay una excepcion a esta regla: dos variables cuyo tipo no lleva ninguna
    informacion y por lo tanto es de tamaño cero, como @c(struct{}) o
    @c([0]int), puede, dependiendo de la aplicacion, tener la misma direccion.

#     The @c(new) function is relatively rarely used because the most common
#     unnamed variables are of struct types, for which the struct literal syntax
#     (@l(#Section 4.4.1<>§4.4.1)) is more flexible.
    La funcion @c(new) se utiliza relativamente rara vez porque las variables
    sin nombre mas comunes son de tipo estructura, para el que la sintaxis
    literal @c(struct) (@l(#Seccion 4.4.1<>§4.4.1)) es mas flexible.

#     Since @c(new) is a predeclared function, not a keyword, it’s possible to redefine the name for
#     something else within a function, for example:
    Dado que @c(new) es una funcion nativa, no una palabra clave, es posible
    redefinir el nombre para algo distinto dentro de una funcion, por ejemplo:

#     ..src > go
#       func delta(old, new int) int { return new - old }
#     < src..
    ..src > go
      func delta(old, new int) int { return new - old }
    < src..

#     Of course, within @c(delta), the built-in @c(new) function is unavailable.
    Por supuesto, dentro de @c(delta), la funcion nativa @c(new) no esta
    disponible.

# *** Section 2.3.4 <> Lifetime of Variables
*** Seccion 2.3.4 <> Tiempo de Vida de las Variables

#     The @e(lifetime) of a variable is the interval of time during which it
#     exists as the program executes.  The lifetime of a package-level variable is
#     the entire execution of the program. By contrast, local variables have
#     dynamic lifetimes: a new instance is created each time the declaration
#     statement is executed, and the variable lives on until it becomes
#     @e(unreachable), at which point its storage may be recycled. Function
#     parameters and results are local variables too; they are created each time
#     their enclosing function is called.
    La @e(vida util) de una variable es el intervalo de tiempo durante el cual
    existe a medida que el programa se ejecuta. La duracion de una variable a
    nivel de paquete, es la ejecucion completa del programa. Por el contrario,
    las variables locales tienen una vida util dinamica: una nueva instancia se
    crea cada vez que se ejecuta la instruccion de declaracion, y la variable
    vive hasta que se vuelve @e(inaccesible), momento en el que su
    almacenamiento se puede reciclar. Los parametros de funcion y los resultados
    tambien son variables locales; Se crean cada vez que se llama a la funcion
    que las encierra.

#     For example, in this excerpt from the Lissajous program of @l(#Section 1.4),
    Por ejemplo, en este extracto del programa de Lissajous de la @l(#Seccion 1.4),

#     ..src > go
#       for t := 0.0; t < cycles*2*math.Pi; t += res {
#         x := math.Sin(t)
#         y := math.Sin(t*freq + phase)
#         img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
#           blackIndex)
#       }
#     < src..
    ..src > go
      for t := 0.0; t < cycles*2*math.Pi; t += res {
        x := math.Sin(t)
        y := math.Sin(t*freq + phase)
        img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
          blackIndex)
      }
    < src..

#     the variable @c(t) is created each time the @c(for) loop begins, and new
#     variables @c(x) and @c(y) are created on each iteration of the loop.
    la variable @c(t) se crea cada vez que el bucle @c(for) comienza, y nuevas
    variables @c(x) y @c(y) se crean en cada iteracion del bucle.

#     How does the garbage collector know that a variable’s storage can be
#     reclaimed? The full story is much more detailed than we need here, but the
#     basic idea is that every package-level variable, and every local variable of
#     each currently active function, can potentially be the start or root of a
#     path to the variable in question, following pointers and other kinds of
#     references that ultimately lead to the variable. If no such path exists, the
#     variable has become unreachable, so it can no longer affect the rest of the
#     computation.
    ¿Como sabe el recolector de basura que el almacenamiento de una variable
    puede ser recuperado? La historia completa es mucho mas detallada de lo que
    necesitamos aqui, pero la idea basica es que cada variable a nivel de
    paquete, y cada variable local de cada funcion actualmente activa, puede ser
    el inicio o la raiz de una ruta a la variable en cuestion, sugiendo punteros
    y otros tipos de referencias que finalmente conducen a la variable. Si no
    existe tal ruta, la variable se ha vuelto inaccesible, por lo que ya no
    puede afectar el resto del calculo.

#     Because the lifetime of a variable is determined only by whether or not it
#     is reachable, a local variable may outlive a single iteration of the
#     enclosing loop. It may continue to exist even after its enclosing function
#     has returned.
    Debido a que el tiempo de vida de una variable se determina por ser o no
    accesible, una variable local puede sobrevivir a una sola iteracion del
    bucle que lo rodea. Puede seguir existiendo incluso despues de que su
    funcion de inclusion ha regresado.

#     A compiler may choose to allocate local variables on the heap or on the
#     stack but, perhaps surprisingly, this choice is not determined by whether
#     var or @c(new) was used to declare the variable.
    Un compilador puede elegir asignar las variables locales en el monticulo o
    en la pila, pero, tal vez sorprendentemente, esta eleccion no depende de si
    se utiliza @c(var) o @c(new) para declarar la variable.

#     ..cols >
    ..cols >

#       ..src > go
#         var global *int
#
#         func f() {
#           var x int
#           x = 1
#           global = &x
#         }
#       < src..
      ..src > go
        var global *int

        func f() {
          var x int
          x = 1
          global = &x
        }
      < src..

#       ::
      ::

#       ..src > go
#         func g() {
#           y := new(int)
#           *y = 1
#         }
#       < src..
      ..src > go
        func g() {
          y := new(int)
          *y = 1
        }
      < src..

#     Here, @c(x) must be heap-allocated because it is still reachable from the
#     variable @c(global) after @c(f) has returned, despite being declared as a
#     local variable; we say @c(x) @e(escapes from) @c(f). Conversely, when @c(g)
#     returns, the variable @c(*y) becomes unreachable and can be recycled. Since
#     @c(*y) does not escape from @c(g), it’s safe for the compiler to allocate
#     @c(*y) on the stack, even though it was allocated with @c(new). In any case,
#     the notion of escaping is not something that you need to worry about in
#     order to write correct code, though it’s good to keep in mind during
#     performance optimization, since each variable that escapes requires an extra
#     memory allocation.
    Aqui, @c(x) debe ser asignado al monticulo porque todavia es accesible desde
    la variable @c(global) despues de haber devuelto @c(f), a pesar de ser
    declarado como una variable local; decimos que @c(x) escapa de @c(f). Por el
    contrario, cuando @c(g) regresa la variable @c(*y) se vuelve inaccesible y
    se pueden reciclar. Dado que @c(*y) no escapa de @c(g), es seguro para el
    compilador asignar @c(*y) en la pila, a pesar de que se asigno con @c(new).
    En cualquier caso, la nocion de escapar no es algo de lo que tengas que
    preocuparte para escribir codigo correcto, aunque es bueno tenerlo en cuenta
    durante la optimizacion de rendimiento, ya que cada variable que escapa
    requiere una asignacion de memoria adicional.

#     Garbage collection is a tremendous help in writing correct programs, but it
#     does not relieve you of the burden of thinking about memory. You don’t need
#     to explicitly allocate and free memory, but to write efficient programs you
#     still need to be aware of the lifetime of variables. For example, keeping
#     unnecessary pointers to short-lived objects within long-lived objects,
#     especially global variables, will prevent the garbage collector from
#     reclaiming the short-lived objects.
    El recolector de basura es una tremenda ayuda para escribir programas
    correctos, pero no elimina la carga de pensar en la memoria. No es necesario
    asignar y liberar memoria de forma explicita, pero para escribir programas
    eficientes es necesario tener en cuenta la duracion de las variables. Por
    ejemplo, mantener punteros innecesarios a objetos de corta duracion dentro
    de objetos de larga vida, especialmente variables globales, evitara que el
    recolector de basura recupere los objetos de corta duracion.

# ** Section 2.4 <> Assignments
** Seccion 2.4 <> Asignaciones

#    The value held by a variable is updated by an assignment statement, which in
#    its simplest form has a variable on the left of the @c(=) sign and an expression
#    on the right.
   El valor contenido en una variable es actualizado por una instruccion de
   asignacion, que en su forma mas simple tiene una variable a la izquierda del
   signo @c(=) y una expresion a la derecha.

#    ..src > go
#      x = 1                       // named variable
#      *p = true                   // indirect variable
#      person.name = "bob"         // struct field
#      count[x] = count[x] * scale // array or slice or map element
#    < src..
   ..src > go
     x = 1                       // variable con nombre
     *p = true                   // variable indirecta
     person.name = "bob"         // campo de ustructura
     count[x] = count[x] * scale // elemento de arreglo, slice o mapa
   < src..

#    Each of the arithmetic and bitwise binary operators has a corresponding
#    @e(assignment operator) allowing, for example, the last statement to be
#    rewritten as
   Cada uno de los operadores aritmeticos y operadores binarios a nivel de bits
   tiene su correspondiente @e(operador de asignacion) permitiendo, por ejemplo,
   reescribir la ultima instruccion como

#    ..src > go
#      count[x] *= scale
#    < src..
   ..src > go
     count[x] *= scale
   < src..

#    which saves us from having to repeat (and re-evaluate) the expression for the
#    variable.
   Lo que nos ahorra tener que repetir (y reevaluar) la expresion de la
   variable.

#    Numeric variables can also be incremented and decremented by @c(++) and
#    @c(--) statements:
   Las variables numericas tambien se pueden incrementar y disminuir con las
   declaraciones @c(++) y @c(--):

#    ..src > go
#      v := 1
#      v++    // same as v = v + 1; v becomes 2
#      v--    // same as v = v - 1; v becomes 1 again
#    < src..
   ..src > go
     v := 1
     v++    // igual a v = v + 1; v es 2
     v--    // igual a v = v - 1; v es 1 de nuevo
   < src..

# *** section 2.4.1 <> tuple assignment
*** seccion 2.4.1 <> Asignacion de Tuplas

#     another form of assignment, known as @e(tuple assignment), allows several
#     variables to be assigned at once. all of the right-hand side expressions are
#     evaluated before any of the variables are updated, making this form most
#     useful when some of the variables appear on both sides of the assignment, as
#     happens, for example, when swapping the values of two variables:
    Otra forma de asignacion, conocida como @e(asignacion de tuplas), permite
    asignar varias variables a la vez. Todas las expresiones del lado derecho se
    evaluan antes de actualizar cualquiera de las variables, haciendo que este
    formato sea mas util cuando algunas de las variables aparecen en ambos lados
    de la asignacion, como sucede, por ejemplo, al intercambiar los valores de
    dos variables:

#     ..src > go
#       x, y = y, x
#       a[i], a[j] = a[j], a[i]
#     < src..
    ..src > go
      x, y = y, x
      a[i], a[j] = a[j], a[i]
    < src..

#     or when computing the greatest common divisor (GCD) of two integers:
    O cuando se calcula el mayor comun divisor de dos enteros:

#     ..src > go
#       func gcd(x, y int) int {
#         for y != 0 {
#           x, y = y, x%y
#         }
#         return x
#       }
#     < src..
    ..src > go
      func gcd(x, y int) int {
        for y != 0 {
          x, y = y, x%y
        }
        return x
      }
    < src..

#     or when computing the n-th Fibonacci number iteratively:
    O al calcular el n-esimo numero de Fibonacci iterativamente:

#     ..src > go
#       func fib(n int) int {
#         x, y := 0, 1
#         for i := 0; i < n; i++ {
#           x, y = y, x+y
#         }
#         return x
#       }
#     < src..
    ..src > go
      func fib(n int) int {
        x, y := 0, 1
        for i := 0; i < n; i++ {
          x, y = y, x+y
        }
        return x
      }
    < src..

#     Tuple assignment can also make a sequence of trivial assignments more compact,
    La asignacion de tuplas tambien puede hacer una secuencia de tareas
    triviales mas compacta,

#     ..src > go
#       i, j, k = 2, 3, 5
#     < src..
    ..src > go
      i, j, k = 2, 3, 5
    < src..

#     though as a matter of style, avoid the tuple form if the expressions are
#     complex; a sequence of separate statements is easier to read.
    Aunque por una cuestion de estilo, evite la forma de tupla si las
    expresiones son complejas; una secuencia de declaraciones separadas es mas
    facil de leer.

#     Certain expressions, such as a call to a function with multiple results,
#     produce several values. When such a call is used in an assignment statement,
#     the left-hand side must have as many variables as the function has results.
    Ciertas expresiones, como una llamada a una funcion con resultados
    multiples, producen varios valores. Cuando se utiliza una llamada de este
    tipo en una instruccion de asignacion, el lado izquierdo debe tener tantas
    variables como la funcion tenga resultados.

#     ..src > go
#       f, err = os.Open("foo.txt") // function call returns two values
#     < src..
    ..src > go
      f, err = os.Open("foo.txt") // la funcion llamada devuelve dos valores
    < src..

#     Often, functions use these additional results to indicate some kind of
#     error, either by returning an @c(error) as in the call to @c(os.Open), or a
#     @c(bool), usually called @c(ok). As we’ll see in later chapters, there are
#     three operators that sometimes behave this way too. If a map lookup
#     (@l(#Section 4.3<>§4.3)), type assertion (@l(#Section 7.10<>§7.10)), or
#     channel receive (@l(#Section 8.4.2<>§8.4.2)) appears in an assignment in
#     which two results are expected, each produces an additional boolean result:
    A menudo, las funciones utilizan estos resultados adicionales para indicar
    algun tipo de error, ya sea devolviendo un @c(error) como en la llamada a
    @c(os.Open), o un @c(bool), generalmente llamado @c(ok). Como veremos en
    capitulos posteriores, hay tres operadores que a veces se comportan de esta
    manera tambien. Si la busqueda en un mapa (@l(#Seccion 4.3<>§4.3)), la
    asercion de tipo (@l(#Seccion 7.10<>§7.10)), o la recepcion de un canal
    (@l(#Seccion 8.4.2<>§8.4.2)) aparece en una asignacion en la que se esperan
    dos resultados, cada una produce un resultado booleano adicional:

#     ..src > go
#       v, ok = m[key]         // map lookup
#       v, ok = x.(T)          // type assertion
#       v, ok = <-ch           // channel receive
#     < src..
    ..src > go
      v, ok = m[key]         // busqueda en mapa
      v, ok = x.(T)          // asercion de tipo
      v, ok = <-ch           // recepcion de canal
    < src..

#     As with variable declarations, we can assign unwanted values to the blank
#     identifier:
    Al igual que con la declaracion de variables, podemos asignar valores no
    deseados al identificador en blanco:

#     ..src > go
#       _, err = io.Copy(dst, src) // discard byte count
#       _, ok = x.(T)              // check type but discard result
#     < src..
    ..src > go
      _, err = io.Copy(dst, src) // descarta conteo de bytes
      _, ok = x.(T)              // comprueba el tipo pero descarta el resultado
    < src..

# *** Section 2.4.2 <> Assignability
*** Seccion 2.4.2 <> Asignacion

#     Assignment statements are an explicit form of assignment, but there are many
#     places in a program where an assignment occurs @e(implicitly): a function
#     call implicitly assigns the argument values to the corresponding parameter
#     variables; a @c(return) statement implicitly assigns the @c(return) operands
#     to the corresponding result variables; and a literal expression for a
#     composite type (@l(#Section 4.2<>§4.2)) such as this slice:
    Las sentencias de asignacion son una forma explicita de asignacion, pero hay
    muchos lugares en un programa donde se produce una asignacion @e(implicita):
    una llamada de funcion asigna implicitamente los valores de los argumentos a
    las variables de parametros correspondientes; una instruccion @c(return)
    asigna implicitamente los operandos de retorno a las variables de resultado
    correspondientes; y una expresion literal para un tipo compuesto
    (@l(#Seccion 4.2<>§4.2)), como este slice:

#     ..src > go
#       medals := []string{"gold", "silver", "bronze"}
#     < src..
    ..src > go
      medallas := []string{"oro", "plata", "bronce"}
    < src..

#     implicitly assigns each element, as if it had been written like this:
    Implicitamente asigna cada elemento, como si se hubiera escrito asi:

#     ..src > go
#       medals[0] = "gold"
#       medals[1] = "silver"
#       medals[2] = "bronze"
#     < src..
    ..src > go
      medallas[0] = "oro"
      medallas[1] = "plata"
      medallas[2] = "bronce"
    < src..

#     The elements of maps and channels, though not ordinary variables, are also
#     subject to similar implicit assignments.
    Los elementos de mapas y canales, aunque no son variables ordinarias,
    tambien estan sujetos a asignaciones implicitas similares.

#     An assignment, explicit or implicit, is always legal if the left-hand side
#     (the variable) and the right-hand side (the value) have the same type. More
#     generally, the assignment is legal only if the value is @e(assignable) to
#     the type of the variable.
    Una asignacion, explicita o implicita, siempre es legal si el lado izquierdo
    (la variable) y el lado derecho (el valor) tienen el mismo tipo. En terminos
    mas generales, la asignacion es legal solo si el valor es @e(asignable) al
    tipo de la variable.

#     The rule for @e(assignability) has cases for various types, so we’ll explain
#     the relevant case as we introduce each new type. For the types we’ve
#     discussed so far, the rules are simple: the types must exactly match, and
#     @c(nil) may be assigned to any variable of interface or reference type.
#     Constants (@l(#Section 3.6<>§3.6)) have more flexible rules for
#     assignability that avoid the need for most explicit conversions.
    La regla para la @e(asignabilidad) tiene casos para varios tipos, por lo que
    vamos a explicar el caso relevante a medida que introducimos cada nuevo
    tipo. Para los tipos que hemos discutido hasta ahora, las reglas son
    simples: los tipos deben coincidir exactamente, y @c(nil) puede ser asignado
    a cualquier variable de interfaz o tipo de referencia. Las constantes
    (@l(#Seccion 3.6<>§3.6)) tienen reglas mas flexibles para la asignacion que
    evitan la necesidad de conversiones mas explicitas.

#     Whether two values may be compared with @c(==) and @c(!=) is related to
#     assignability: in any comparison, the first operand must be assignable to
#     the type of the second operand, or vice versa.  As with assignability, we’ll
#     explain the relevant cases for @e(comparability) when we present each new
#     type.
    Si dos valores pueden compararse con @c(==) y @c(!=) se relaciona con la
    asignacion: en cualquier comparacion, el primer operando debe ser asignable
    al tipo del segundo operando, o viceversa. Al igual que con la
    asignabilidad, vamos a explicar los casos relevantes para la comparabilidad
    cuando presentamos cada nuevo tipo.

# ** Section 2.5 <> Type Declarations
** Seccion 2.5 <> Declaraciones de tipo

#    The type of a variable or expression defines the characteristics of the
#    values it may take on, such as their size (number of bits or number of
#    elements, perhaps), how they are represented internally, the intrinsic
#    operations that can be performed on them, and the methods associated with
#    them.
   El tipo de una variable o expresion define las caracteristicas de los valores
   que puede tomar, como su tamaño (numero de bits o numero de elementos, tal
   vez), como se representan internamente, las operaciones intrinsecas que se
   pueden realizar en ellos, Y los metodos asociados con ellos.

#    In any program there are variables that share the same representation but
#    signify very different concepts. For instance, an @c(int) could be used to
#    represent a loop index, a timestamp, a file descriptor, or a month; a @c(float64)
#    could represent a velocity in meters per second or a temperature in one of
#    several scales; and a @c(string) could represent a password or the name of a
#    color.
   En cualquier programa hay variables que comparten la misma representacion
   pero que significan conceptos muy diferentes. Por ejemplo, un @c(int) podria
   ser usado para representar un indice de bucle, una marca de tiempo, un
   descriptor de archivo, o un mes; un @c(float64) podria representar una
   velocidad en metros por segundo o una temperatura en una de varias escalas; y
   un @c(string) podria representar una contraseña o el nombre de un color.

#    A @c(type) declaration defines a new @e(named type) that has the same
#    @e(underlying type) as an existing type. The named type provides a way to
#    separate different and perhaps incompatible uses of the underlying type so
#    that they can’t be mixed unintentionally.
   Una declaracion @c(type) define un nuevo @e(tipo con nombre) que tiene el
   mismo @e(tipo subyacente) como un tipo existente. El tipo nombrado
   proporciona una manera de separar los diferentes usos y quizas incompatibles
   del tipo subyacente para que no puedan ser mezclados involuntariamente.

#    ..src > go
#      type name underlying-type
#    < src..
   ..src > go
     type nombre tipo-subyacente
   < src..

#    Type declarations most often appear at package level, where the named type is
#    visible throughout the package, and if the name is exported (it starts with
#    an upper-case letter), it’s accessible from other packages as well.
   Las declaraciones de tipo aparecen mas a menudo en el nivel de paquete, donde
   el tipo nombrado es visible en todo el paquete, y si el nombre se exporta
   (inicia con una letra mayuscula), es accesible desde otros paquetes tambien.

#    To illustrate type declarations, let’s turn the different temperature scales
#    into different types:
   Para ilustrar la declaracion de tipos, vamos a convertir las diferentes
   escalas de temperatura en tipos distintos:

#    ..figure > @l(gopl.io/ch2/tempconv0/celsius.go<>gopl.io/ch2/tempconv0)
   ..figure > @l(gopl.io/ch2/tempconv0/celsius.go<>gopl.io/ch2/tempconv0)

#      ..src > go
#        // Package tempconv performs Celsius and Fahrenheit temperature computations.
#        package tempconv
#
#        import "fmt"
#
#        type Celsius float64
#        type Fahrenheit float64
#
#        const (
#          AbsoluteZeroC Celsius = -273.15
#          FreezingC     Celsius = 0
#          BoilingC      Celsius = 100
#        )
#
#        func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
#        func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
#      < src..
     ..src > go
       // Paquete tempconv realiza calculos de temperatura Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
         AbsoluteZeroC Celsius = -273.15
         FreezingC     Celsius = 0
         BoilingC      Celsius = 100
       )

       func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
       func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
     < src..


#    This package defines two types, @c(Celsius) and @c(Fahrenheit), for the two
#    units of temperature. Even though both have the same underlying type,
#    @c(float64), they are not the same type, so they cannot be compared or
#    combined in arithmetic expressions. Distinguishing the types makes it
#    possible to avoid errors like inadvertently combining temperatures in the two
#    different scales; an explicit type @e(conversion) like @c[Celsius(t)] or
#    @c[Fahrenheit(t)] is required to convert from a @c[float64]. @c[Celsius(t)]
#    and @c[Fahrenheit(t)] are conversions, not function calls. They don’t change
#    the value or representation in any way, but they make the change of meaning
#    explicit.  On the other hand, the functions @c(CToF) and @c(FToC) convert
#    between the two scales; they do return different values.
   Este paquete define dos tipos, @c(Celsius) y @c(Fahrenheit), para las dos
   unidades de temperatura. A pesar de que ambos tienen el mismo tipo
   subyacente, @c(float64), no son del mismo tipo, por lo que no pueden
   compararse o ser combinados en expresiones aritmeticas. Distinguir los tipos
   hace posible evitar errores como combinar inadvertidamente temperaturas en
   las dos escalas diferentes; es necesaria una conversion de tipo explicita
   como @c[Celsius(t)] o @c[Fahrenheit(t)] para convertir desde un @c(float64).
   @c[Celsius(t)] y @c[Fahrenheit(t)] son conversiones, no llamadas a funcion.
   No cambian el valor o la representacion de ninguna manera, pero hacen que el
   cambio de significado sea explicito. Por otro lado, las funciones @c(CToF) y
   @c(FToC) realizan conversiones entre las dos escalas; Estas devuelven valores
   diferentes.

#    For every type @c(T), there is a corresponding conversion operation @c[T(x)]
#    that converts the value @c(x) to type @c(T). A conversion from one type to
#    another is allowed if both have the same underlying type, or if both are
#    unnamed pointer types that point to variables of the same underlying type;
#    these conversions change the type but not the representation of the value. If
#    @c(x) is assignable to @c(T), a conversion is permitted but is usually
#    redundant,
   Para cada tipo @c(T), hay una operacion de conversion correspondiente
   @c[T(x)] que convierte el valor @c(x) al tipo @c(T). Se permite una
   conversion de un tipo a otro si ambos tienen el mismo tipo subyacente, o si
   ambos son tipos apuntador sin nombre que apuntan a variables del mismo tipo
   subyacente; Estas conversiones cambian el tipo pero no la representacion del
   valor. Si @c(x) es asignable a @c(T), se permite una conversion, pero suele
   ser redundante,

#    Conversions are also allowed between numeric types, and between string and
#    some slice types, as we will see in the next chapter. These conversions may
#    change the representation of the value. For instance, converting a
#    floating-point number to an integer discards any fractional part, and
#    converting a string to a @c([]byte) slice allocates a copy of the string
#    data. In any case, a conversion never fails at run time.
   Las conversiones tambien se permiten entre tipos numericos, y entre la cadena
   y algunos tipos de slices, como veremos en el siguiente capitulo. Estas
   conversiones pueden cambiar la representacion del valor. Por ejemplo, la
   conversion de un numero de coma flotante a un entero descarta cualquier parte
   fraccionaria, y la conversion de una cadena a un slice @c([]byte) asigna una
   copia de los datos de cadena. En cualquier caso, una conversion nunca falla
   en tiempo de ejecucion.

#    The underlying type of a named type determines its structure and
#    representation, and also the set of intrinsic operations it supports, which
#    are the same as if the underlying type had been used directly. That means
#    that arithmetic operators work the same for @c(Celsius) and @c(Fahrenheit) as
#    they do for @c(float64), as you might expect.
   El tipo subyacente de un tipo con nombre determina su estructura y
   representacion, asi como el conjunto de operaciones intrinsecas que admite,
   que son iguales que si el tipo subyacente se hubiera utilizado directamente.
   Eso significa que los operadores aritmeticos funcionan igual para @c(Celsius)
   y @c(Fahrenheit) como lo hacen para @c(float64), como se podria esperar.

#    ..src > go
#      fmt.Printf("%g\n", BoilingC-FreezingC)       // "100" °C
#      boilingF := CToF(BoilingC)
#      fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
#      fmt.Printf("%g\n", boilingF-FreezingC)       // compile error: type mismatch
#    < src..
   ..src > go
     fmt.Printf("%g\n", BoilingC-FreezingC)       // "100" °C
     boilingF := CToF(BoilingC)
     fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
     fmt.Printf("%g\n", boilingF-FreezingC)       // error de compilacion: tipo incorrecto
   < src..

#    Comparison operators like @c(==) and @c(<) can also be used to compare a
#    value of a named type to another of the same type, or to a value of the
#    underlying type. But two values of different named types cannot be compared
#    directly :
   Los operadores de comparacion como @c(==) y @c(<) tambien se puede utilizar
   para comparar un valor de un tipo con nombre a otro del mismo tipo, o a un
   valor del tipo subyacente. Pero dos valores de diferentes tipos con nombre no
   pueden compararse directamente:

#    ..src > go
#      var c Celsius
#      var f Fahrenheit
#      fmt.Println(c == 0)          // "true"
#      fmt.Println(f >= 0)          // "true"
#      fmt.Println(c == f)          // compile error: type mismatch
#      fmt.Println(c == Celsius(f)) // "true"!
#    < src..
   ..src > go
     var c Celsius
     var f Fahrenheit
     fmt.Println(c == 0)          // "true"
     fmt.Println(f >= 0)          // "true"
     fmt.Println(c == f)          // error de compilacion: tipo incorrecto
     fmt.Println(c == Celsius(f)) // "true"!
   < src..

#    Note the last case carefully. In spite of its name, the type conversion
#    @c[Celsius(f)] does not change the value of its argument, just its type. The
#    test is true because @c(c) and @c(f) are both zero.
   Anote cuidadosamente el ultimo caso. A pesar de su nombre, la conversion de
   tipo @c[Celsius(f)] no cambia el valor de su argumento, solo su tipo. La prueba
   es verdadera porque @c(c) y @c(f) son ambos cero.

#    A named type may provide notational convenience if it helps avoid writing out
#    complex types over and over again. The advantage is small when the underlying
#    type is simple like @c(float64), but big for complicated types, as we will see
#    when we discuss structs.
   Un tipo con nombre puede proporcionar conveniencia de notacion si ayuda a
   evitar escribir tipos complejos una y otra vez. La ventaja es pequeña cuando
   el tipo subyacente es tan simple como @c(float64), pero grande para los tipos
   complicados, como veremos cuando hablemos de las estructuras.

#    Named types also make it possible to define new behaviors for values of the
#    type. These behaviors are expressed as a set of functions associated with the
#    type, called the type’s @e(methods).  We’ll look at methods in detail in
#    @l(#Chapter 6) but will give a taste of the mechanism here.
   Los tipos nombrados tambien permiten definir nuevos comportamientos para los
   valores del tipo. Estos comportamientos se expresan como un conjunto de
   funciones asociadas con el tipo, denominados @e(metodos) del tipo. Veremos los
   metodos en detalle en el @l(#Capitulo 6), pero daremos una idea del mecanismo
   aqui.

#    The declaration below, in which the @c(Celsius) parameter @c(c) appears before the
#    function name, associates with the @c(Celsius) type a method named @c(String) that
#    returns @c(c)’s numeric value followed by @c(°C):
   La siguiente declaracion, en la que el parametro @c(c) de tipo @c(Celsius)
   aparece antes del nombre de la funcion, se asocia con el tipo @c(Celsius) un
   metodo llamado @c(String) que devuelve @c(c) como un valor numerico seguido
   por @c(°C):

#    ..src > go
#      func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
#    < src..
   ..src > go
     func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
   < src..


#    Many types declare a @c(String) method of this form because it controls how
#    values of the type appear when printed as a string by the @c(fmt) package, as
#    we will see in @l(#Section 7.1).
   Muchos tipos declaran un metodo @c(String) de esta forma debido a que controla
   como aparecen los valores del tipo cuando se imprimen en una cadena con el
   paquete @c(fmt), como veremos en la @l(#Seccion 7.1).

#    ..src > go
#      c := FToC(212.0)
#      fmt.Println(c.String()) // "100°C"
#      fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
#      fmt.Printf("%s\n", c)   // "100°C"
#      fmt.Println(c)          // "100°C"
#      fmt.Printf("%g\n", c)   // "100"; does not call String
#      fmt.Println(float64(c)) // "100"; does not call String
#    < src..
   ..src > go
     c := FToC(212.0)
     fmt.Println(c.String()) // "100°C"
     fmt.Printf("%v\n", c)   // "100°C"; no es necesario llamar a String explicitamente
     fmt.Printf("%s\n", c)   // "100°C"
     fmt.Println(c)          // "100°C"
     fmt.Printf("%g\n", c)   // "100"; no llama a String
     fmt.Println(float64(c)) // "100"; no llama a String
   < src..

# ** Section 2.6 <> Packages and Files
** Seccion 2.6 <> Paquetes y Ficheros

#    Packages in Go serve the same purposes as libraries or modules in other
#    languages, supporting modularity, encapsulation, separate compilation, and
#    reuse. The source code for a package resides in one or more @f(.go) files,
#    usually in a directory whose name ends with the import path; for instance,
#    the files of the @c(gopl.io/ch1/helloworld) package are stored in directory
#    @c($GOPATH/src/gopl.io/ch1/helloworld).
   Los paquetes en Go sirven a los mismos propositos que las librerias o modulos
   en otros lenguajes, soportando modularidad, encapsulacion, compilacion
   separada y reutilizacion. El codigo fuente de un paquete reside en uno o mas
   archivos @f(.go), por lo general en un directorio cuyo nombre termina con la
   ruta de importacion; por ejemplo, los archivos del paquete
   @c(gopl.io/ch1/helloworld) se almacenan en el directorio
   @c($GOPATH/src/gopl.io/ch1/helloworld).

#    Each package serves as a separate @e(name space) for its declarations. Within
#    the @e(image) package, for example, the identifier @c(Decode) refers to a
#    different function than does the same identifier in the @c(unicode/utf16)
#    package. To refer to a function from outside its package, we must @e(qualify)
#    the identifier to make explicit whether we mean @c(image.Decode) or
#    @c(utf16.Decode).
   Cada paquete sirve como un @e(espacio de nombres) separado para sus
   declaraciones. Por ejemplo, dentro del paquete @c(image), el identificador
   @c(Decode) se refiere a una funcion distinta a la del mismo identificador en
   el paquete @c(unicode/utf16). Para hacer referencia a una funcion desde fuera
   de su paquete, debemos @e(calificar) el identificador para hacer explicito si
   nos referimos a @c(image.Decode) o @c(utf16.Decode).

#    Packages also let us hide information by controlling which names are visible
#    outside the package, or @e(exported). In Go, a simple rule governs which
#    identifiers are exported and which are not: exported identifiers start with
#    an upper-case letter.
   Los paquetes tambien nos permiten ocultar informacion controlando que nombres
   son visibles fuera del paquete, o @e(exportados). En Go, una regla simple
   regula que identificadores se exportan y cuales no: los identificadores
   exportados comienzan con una letra mayuscula.

#    To illustrate the basics, suppose that our temperature conversion software
#    has become popular and we want to make it available to the Go community as a
#    new package. How do we do that?
   Para ilustrar los fundamentos, supongamos que nuestro software de conversion
   de temperatura se ha vuelto popular y queremos ponerlo a disposicion de la
   comunidad Go como un nuevo paquete. ¿Como hacemos eso?

#    Let’s create a package called @c(gopl.io/ch2/tempconv), a variation on the
#    previous example.  (Here we’ve made an exception to our usual rule of
#    numbering examples in sequence, so that the package path can be more
#    realistic.) The package itself is stored in two files to show how
#    declarations in separate files of a package are accessed; in real life, a
#    tiny package like this would need only one file.
   Vamos a crear un paquete llamado @c(gopl.io/ch2/tempconv), una variacion del
   ejemplo anterior. (Aqui hemos hecho una excepcion a nuestra regla habitual de
   ejemplos de numeracion en secuencia, de modo que la ruta del paquete puede
   ser mas realista.) El propio paquete se almacena en dos archivos para mostrar
   como se accede a las declaraciones en archivos separados de un paquete; En la
   vida real, un pequeño paquete como este solo necesitaria un archivo.

#    We have put the declarations of the types, their constants, and their methods
#    in @f(tempconv.go):
   Hemos puesto las declaraciones de los tipos, sus constantes y sus metodos en
   @f(tempconv.go):

#    ..figure > @l(gopl.io/ch2/tempconv/tempconv.go<>gopl.io/ch2/tempconv)
   ..figure > @l(gopl.io/ch2/tempconv/tempconv.go<>gopl.io/ch2/tempconv)

#      ..src > go
#        // Package tempconv performs Celsius and Fahrenheit conversions.
#        package tempconv
#
#        import "fmt"
#
#        type Celsius float64
#        type Fahrenheit float64
#
#        const (
#        	AbsoluteZeroC Celsius = -273.15
#        	FreezingC     Celsius = 0
#        	BoilingC      Celsius = 100
#        )
#
#        func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
#        func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
#      < src..
     ..src > go
       // El paquete tempconv realiza conversiones Celsius y Fahrenheit.
       package tempconv

       import "fmt"

       type Celsius float64
       type Fahrenheit float64

       const (
       	AbsoluteZeroC Celsius = -273.15
       	FreezingC     Celsius = 0
       	BoilingC      Celsius = 100
       )

       func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
       func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
     < src..


#    and the conversion functions in @f(conv.go):
   y las funciones de conversion en @f(conv.go):

#    ..src > go
#      package tempconv
#
#      // CToF converts a Celsius temperature to Fahrenheit.
#      func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
#
#      // FToC converts a Fahrenheit temperature to Celsius.
#      func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
#    < src..
   ..src > go
     package tempconv

     // CToF convierte una temperatura Celsius a Fahrenheit.
     func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

     // FToC convierte una temperatura Fahrenheit a Celsius.
     func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
   < src..

#    Each file starts with a @c(package) declaration that defines the package
#    name. When the package is imported, its members are referred to as
#    @c(tempconv.CToF) and so on. Package-level names like the types and constants
#    declared in one file of a package are visible to all the other files of the
#    package, as if the source code were all in a single file. Note that
#    @f(tempconv.go) imports @c(fmt), but @f(conv.go) does not, because it does not use
#    anything from @c(fmt).
   Cada archivo comienza con una declaracion @c(package) que define el nombre
   del paquete. Cuando se importa el paquete, sus miembros se conocen como
   @c(tempconv.CToF) y asi. Los nombres a nivel de paquete como los tipos y las
   constantes declaradas en un archivo de un paquete son visibles para todos los
   otros archivos del paquete, como si el codigo fuente estuviera todo en un
   solo archivo. Observe que @f(tempconv.go) importa @c(fmt), pero @f(conv.go)
   no lo hace, ya que no utiliza nada de @c(fmt).

#    Because the package-level @c(const) names begin with upper-case letters, they too
#    are accessible with qualified names like @c(tempconv.AbsoluteZeroC):
   Debido a que los nombres @c(const) de nivel de paquete comienzan con letras
   mayusculas, tambien son accesibles con nombres calificados, por ejemplo,
   @c(tempconv.AbsoluteZeroC):

#    ..src > go
#      fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
#    < src..
   ..src > go
     fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
   < src..

#    To convert a Celsius temperature to Fahrenheit in a package that imports
#    @c(gopl.io/ch2/tempconv), we can write the following code:
   Para convertir una temperatura Celsius a Fahrenheit en un paquete que importa
   @c(gopl.io/ch2/tempconv), podemos escribir el siguiente codigo:

#    ..src > go
#      fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
#    < src..
   ..src > go
     fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
   < src..

#    The @e(doc comment) (@l(#Section 10.7.4<>§10.7.4)) immediately preceding the
#    package declaration documents the package as a whole. Conventionally, it
#    should start with a summary sentence in the style illustrated. Only one file
#    in each package should have a package doc comment. Extensive doc comments are
#    often placed in a file of their own, conventionally called @f(doc.go).
   El @c(comentario de documentacion) (@l(#Seccion 10.7.4<>§10.7.4))
   inmediatamente anterior a la declaracion del paquete, documenta el paquete en
   su conjunto. Convencionalmente, debe comenzar con una oracion de resumen en
   el estilo ilustrado. Solo un archivo en cada paquete debe tener un comentario
   de documentacion del paquete. Los comentarios de documentacion extensos, a
   menudo se colocan en su propio fichero, convencionalmente llamado @f(doc.go).

#    @b(Exercise 2.1): Add types, constants, and functions to @c(tempconv) for
#    processing temperatures in the Kelvin scale, where zero Kelvin is -273.15°C
#    and a difference of 1K has the same magnitude as 1°C.
   @b(Ejercicio 2.1): Añadir tipos, constantes y funciones a @c(tempconv) para
   el procesamiento de temperaturas en la escala Kelvin, donde cero Kelvin es
   -273,15°C y una diferencia de 1K tiene la misma magnitud de 1°C.

# *** Section 2.6.1 <> Imports
*** Seccion 2.6.1 <> Importaciones

#     Within a Go program, every package is identified by a unique string called
#     its @e(import path).  These are the strings that appear in an @c(import)
#     declaration like @c("gopl.io/ch2/tempconv"). The language specification
#     doesn’t define where these strings come from or what they mean; it’s up to
#     the tools to interpret them. When using the @$(go) tool (@l(#Chapter 10)),
#     an import path denotes a directory containing one or more Go source files
#     that together make up the package.
    Dentro de un programa Go, cada paquete se identifica por una cadena unica
    llamada la @e(ruta de importacion). Estas son las cadenas que aparecen en
    una declaracion @c(import) como @c("gopl.io/ch2/tempconv"). La
    especificacion del lenguaje no define de donde provienen estas cadenas o lo
    que significan; Depende de las herramientas para interpretarlas. Cuando se
    utiliza la herramienta @$(go) de (@l(#Capitulo 10)), una ruta de importacion
    denota un directorio que contiene uno o mas archivos de codigo fuento Go que
    juntos componen el paquete.

#     In addition to its import path, each package has a @e(package name), which
#     is the short (and not necessarily unique) name that appears in its
#     @c(package) declaration. By convention, a package’s name matches the last
#     segment of its import path, making it easy to predict that the package name
#     of @c(gopl.io/ch2/tempconv) is @c(tempconv).
    Ademas de su ruta de importacion, cada paquete tiene un nombre de paquete,
    que es corto (y no necesariamente unico) nombre que aparece en su
    declaracion @c(package). Por convencion, el nombre de un paquete coincide
    con el ultimo segmento de la ruta de importacion, por lo que es facil
    predecir que el nombre del paquete de @c(gopl.io/ch2/tempconv) es
    @c(tempconv).

#     To use @c(gopl.io/ch2/tempconv), we must import it:
    Para utilizar @c(gopl.io/ch2/tempconv), hay que importarlo:

#     ..figure > @l(gopl.io/ch2/cf/main.go<>gopl.io/ch2/cf)
    ..figure > @l(gopl.io/ch2/cf/main.go<>gopl.io/ch2/cf)

#       ..src > go
#         // Cf converts its numeric argument to Celsius and Fahrenheit.
#         package main
#
#         import (
#           "fmt"
#           "os"
#           "strconv"
#
#           "gopl.io/ch2/tempconv"
#         )
#
#         func main() {
#           for _, arg := range os.Args[1:] {
#             t, err := strconv.ParseFloat(arg, 64)
#             if err != nil {
#               fmt.Fprintf(os.Stderr, "cf: %v\n", err)
#               os.Exit(1)
#             }
#             f := tempconv.Fahrenheit(t)
#             c := tempconv.Celsius(t)
#             fmt.Printf("%s = %s, %s = %s\n",
#               f, tempconv.FToC(f), c, tempconv.CToF(c))
#           }
#         }
#       < src..
      ..src > go
        // Cf conviente su argumento numerico en Celsius y Fahrenheit.
        package main

        import (
          "fmt"
          "os"
          "strconv"

          "gopl.io/ch2/tempconv"
        )

        func main() {
          for _, arg := range os.Args[1:] {
            t, err := strconv.ParseFloat(arg, 64)
            if err != nil {
              fmt.Fprintf(os.Stderr, "cf: %v\n", err)
              os.Exit(1)
            }
            f := tempconv.Fahrenheit(t)
            c := tempconv.Celsius(t)
            fmt.Printf("%s = %s, %s = %s\n",
              f, tempconv.FToC(f), c, tempconv.CToF(c))
          }
        }
      < src..

#     The import declaration binds a short name to the imported package that may
#     be used to refer to its contents throughout the file. The @c(import) above
#     lets us refer to names within @c(gopl.io/ch2/tempconv) by using a
#     @e(qualified identifier) like @c(tempconv.CToF). By default, the short name
#     is the package name—@c(tempconv) in this case—but an import declaration may
#     specify an alternative name to avoid a conflict (@l(#Section 10.3<>§10.3)).
    La declaracion de importacion vincula un nombre corto al paquete importado
    que se puede utilizar para referirse a su contenido en todo el archivo. El
    @c(import) anterior nos permite referimos a nombres dentro de
    @c(gopl.io/ch2/tempconv) mediante el uso de un identificador calificado como
    @c(tempconv.CToF). Por defecto, el nombre corto es el nombre del paquete–en
    este caso @c(tempconv), pero una declaracion de importacion puede
    especificar un nombre alternativo para evitar un conflicto (@l(#Seccion
    10.3<>§10.3)).

#     The @$(cf) program converts a single numeric command-line argument to its value
#     in both Celsius and Fahrenheit:
    El programa @$(cf) convierte un unico argumento numerico de la linea de
    comando a su valor en grados Celsius y Fahrenheit:

#     ..src > sh
#       $ go build gopl.io/ch2/cf
#       $ ./cf 32
#       32°F = 0°C, 32°C = 89.6°F
#       $ ./cf 212
#       212°F = 100°C, 212°C = 413.6°F
#       $ ./cf -40
#       -40°F = -40°C, -40°C = -40°F
#     < src..
    ..src > sh
      $ go build gopl.io/ch2/cf
      $ ./cf 32
      32°F = 0°C, 32°C = 89.6°F
      $ ./cf 212
      212°F = 100°C, 212°C = 413.6°F
      $ ./cf -40
      -40°F = -40°C, -40°C = -40°F
    < src..

#     It is an error to import a package and then not refer to it. This check
#     helps eliminate dependencies that become unnecessary as the code evolves,
#     although it can be a nuisance during debugging, since commenting out a line
#     of code like @c[log.Print("got here!")] may remove the sole reference to the
#     package name @c(log), causing the compiler to emit an error. In this situation,
#     you need to comment out or delete the unnecessary @c(import).
    Es un error importar un paquete y luego no hacer referencia a el. Esta
    verificacion ayuda a eliminar las dependencias que se hacen innecesarias,
    cuando el codigo evoluciona, aunque puede ser una molestia durante la
    depuracion, ya que al comentar una linea de codigo como @c[log.Print("got
    here!")] puede eliminar la unica referencia al de nombre de paquete @c(log),
    probocando que el compilador emita un error. En esta situacion, es necesario
    comentar o eliminar el @c(import) innecesario.

#     Better still, use the @c(golang.org/x/tools/cmd/goimports) tool, which
#     automatically inserts and removes packages from the import declaration as
#     necessary ; most editors can be configured to run @$(goimports) each time
#     you save a file. Like the @$(gofmt) tool, it also pretty-prints Go source
#     files in the canonical format.
    Mejor aun, utilice la herramienta @c(golang.org/x/tools/cmd/goimports), que
    inserta y elimina paquetes de la declaracion de importacion, segun sea
    necesario de forma automatica; la mayoria de los editores pueden
    configurarse para ejecutar @$(goimports) cada vez que se guarda un fichero.
    Al igual que la herramienta @$(gofmt), tambien imprime bonitos ficheros de
    codigo fuene en el formato canonico.

#     @b(Exercise 2.2): Write a general-purpose unit-conversion program analogous
#     to @c(cf) that reads numbers from its command-line arguments or from the
#     standard input if there are no arguments, and converts each number into
#     units like temperature in Celsius and Fahrenheit, length in feet and meters,
#     weight in pounds and kilograms, and the like.
   @b(Ejercicio 2.2): Escribir un programa de proposito general para conversion
   de unidades analogo a @$(cf) que leea los numeros de sus argumentos de linea
   de comando o de la entrada estandar si no hay argumentos, y convierta cada
   numero en unidades como la temperatura en grados Celsius y Fahrenheit,
   longitud en Pies y metros, peso en libras y kilogramos y similares.

# *** Section 2.6.2 <> Package Initialization
*** Seccion 2.6.2 <> Inicializacion del paquete

#     Package initialization begins by initializing package-level variables in the
#     order in which they are declared, except that dependencies are resolved
#     first:
    La inicializacion del paquete comienza inicializando las variables a nivel
    de paquete en el orden en que se declaran, excepto que las dependencias se
    resuelven primero:

#     ..src > go
#       var a = b + c      // a initialized third, to 3
#       var b = f()        // b initialized second, to 2, by calling f
#       var c = 1          // c initialized first, to 1
#
#       func f() int { return c + 1 }
#     < src..
    ..src > go
      var a = b + c      // a inicializado tercero, a 3
      var b = f()        // b inicializado segundo, a 2, llamando a f
      var c = 1          // c inicializado primero, a 1

      func f() int { return c + 1 }
    < src..

#     If the package has multiple @f(.go) files, they are initialized in the order in
#     which the files are given to the compiler; the @$(go) tool sorts @f(.go) files by
#     name before invoking the compiler.
    Si el paquete tiene multiples ficheros @f(.go), se inicializan en el orden
    en que se dan los archivos al compilador; La herramienta @$(go) ordena los
    ficheros @f(.go) archivos por nombre antes de invocar el compilador.

#     Each variable declared at package level starts life with the value of its
#     initializer expression, if any, but for some variables, like tables of data,
#     an initializer expression may not be the simplest way to set its initial
#     value. In that case, the @c(init) function mechanism may be simpler. Any file
#     may contain any number of functions whose declaration is just
    Cada variable declarada en el nivel del paquete comienza su vida con el
    valor de su expresion de inicializador, pero para algunas variables, como
    tablas de datos, una expresion del inicializador no puede ser la manera mas
    simple de establecer su valor inicial. En ese caso, el mecanismo de la
    funcion @c(init) puede ser mas simple. Cualquier archivo puede contener
    cualquier numero de funciones cuya declaracion sea

#     ..src > go
#       func init() { /* ... */ }
#     < src..
    ..src > go
      func init() { /* ... */ }
    < src..

#     Such @c(init) functions can’t be called or referenced, but otherwise they
#     are normal functions.  Within each file, @c(init) functions are automatically
#     executed when the program starts, in the order in which they are declared.
    No se puede llamar o hacer referencia a estas funciones @c(init), pero por
    lo demas son funciones normales. Dentro de cada archivo, las funciones
    @c(init) se ejecutan automaticamente cuando se inicia el programa, en el
    orden en que se declaran.

#     One package is initialized at a time, in the order of imports in the
#     program, dependencies first, so a package @c(p) importing @c(q) can be sure
#     that @c(q) is fully initialized before @c(p)’s initialization begins.
#     Initialization proceeds from the bottom up; the @c(main) package is the last
#     to be initialized. In this manner, all packages are fully initialized before
#     the application’s @c(main) function begins.
    Los paquetes se inician uno a la vez, en el orden de las importaciones en el
    programa, las dependencias en primer lugar, por lo que un paquete @c(p) que
    importa a @c(q) puede estar seguro de que @c(q) se inicializa completamente
    antes de la inicialiacion de @c(p). La inicializacion procede de abajo hacia
    arriba; el paquete @c(main) es el ultimo en ser inicializado. De esta
    manera, todos los paquetes se inicializan completamente antes de que inicie
    la funcion @c(main).

#     The package below defines a function @c(PopCount) that returns the number of
#     set bits, that is, bits whose value is 1, in a @c(uint64) value, which is
#     called its @e(population count). It uses an @c(init) function to precompute
#     a table of results, @c(pc), for each possible 8-bit value so that the
#     @c(PopCount) function needn’t take 64 steps but can just return the sum of
#     eight table lookups. (This is definitely @e(not) the fastest algorithm for
#     counting bits, but it’s convenient for illustrating @c(init) functions, and
#     for showing how to precompute a table of values, which is often a useful
#     programming technique.)
    El paquete a continuacion define una funcion @c(PopCount) que devuelve el
    numero de bits establecidos, es decir, los bits cuyo valor es 1, en un valor
    @c(uint64), que se llama @e(conteo de poblacion). Utiliza una funcion
    @c(init) para calcular previamente una tabla de resultados, @c(pc), para
    cada posible valor de 8 bits de modo que la funcion @c(PopCount) no necesite
    tomar 64 pasos, pero solo puede devolver la suma de ocho consultas de
    tabla. (Esto definitivamente no es el algoritmo mas rapido para el recuento
    de bits, pero es conveniente para ilustrar las funciones @c(init), y para
    mostrar como calcular previamente una tabla de valores, que a menudo es una
    tecnica de programacion util).

#     ..figure > @l(gopl.io/ch2/popcount/main.go<>gopl.io/ch2/popcount)
    ..figure > @l(gopl.io/ch2/popcount/main.go<>gopl.io/ch2/popcount)

#       ..src > go
#         package popcount
#
#         // pc[i] is the population count of i.
#         var pc [256]byte
#
#         func init() {
#           for i := range pc {
#             pc[i] = pc[i/2] + byte(i&1)
#           }
#         }
#
#         // PopCount returns the population count (number of set bits) of x.
#         func PopCount(x uint64) int {
#           return int(pc[byte(x>>(0*8))] +
#             pc[byte(x>>(1*8))] +
#             pc[byte(x>>(2*8))] +
#             pc[byte(x>>(3*8))] +
#             pc[byte(x>>(4*8))] +
#             pc[byte(x>>(5*8))] +
#             pc[byte(x>>(6*8))] +
#             pc[byte(x>>(7*8))])
#         }
#       < src..
      ..src > go
        package popcount

        // pc[i] es el recuento de poblacion de i.
        var pc [256]byte

        func init() {
          for i := range pc {
            pc[i] = pc[i/2] + byte(i&1)
          }
        }

        // PopCount regresa el conteo de la poblacion (numero de bist establecidos) de x.
        func PopCount(x uint64) int {
          return int(pc[byte(x>>(0*8))] +
            pc[byte(x>>(1*8))] +
            pc[byte(x>>(2*8))] +
            pc[byte(x>>(3*8))] +
            pc[byte(x>>(4*8))] +
            pc[byte(x>>(5*8))] +
            pc[byte(x>>(6*8))] +
            pc[byte(x>>(7*8))])
        }
      < src..


#     Note that the range loop in @c(init) uses only the index; the value is
#     unnecessary and thus need not be included. The loop could also have been
#     written as for
    Observe que el rango del bucle en @c(init) utiliza solo el indice; El valor
    es innecesario y por lo tanto no necesita ser incluido. El bucle tambien
    podria haber sido escrito como

#     ..src > go
#       i, _ := range pc {
#     < src..
    ..src > go
      i, _ := range pc {
    < src..

#     We’ll see other uses of @c(init) functions in the next section and in
#     @l(#Section 10.5).
    Veremos otros usos de funciones @c(init) en la siguiente seccion y en la seccion
    @l(#Seccion 10.5).

#     @b(Exercise 2.3): Rewrite @c(PopCount) to use a loop instead of a single
#     expression. Compare the performance of the two versions. (@l(#Section 11.4)
#     shows how to compare the performance of different implementations
#     systematically.)
    @b(Ejercicio 2.3): Vuelve a escribir @c(PopCount) para utilizar un bucle en
    lugar de una sola expresion. Compare el rendimiento de las dos versiones. La
    (@l(#Seccion 11.4) muestra como comparar el rendimiento de diferentes
    implementaciones de forma sistematica.)

#     @b(Exercise 2.4): Write a version of @c(PopCount) that counts bits by shifting
#     its argument through 64 bit positions, testing the rightmost bit each
#     time. Compare its performance to the tablelookup version.
    @b(Ejercicio 2.4): Escribe una version de @c(PopCount) que cuenta los bits
    desplazando su argumento a traves de posiciones de 64 bits, poniendo a
    prueba el bit mas a la derecha cada vez. Compare su rendimiento con la
    version de buesqueda por la tabla.

#     @b(Exercise 2.5): The expression @c[x&(x-1)] clears the rightmost non-zero
#     bit of @c(x). Write a version of PopCount that counts bits by using this
#     fact, and assess its performance.
    @b(Ejercicio 2.5): La expresion @c&x&(x-1)] despeja el bit mas a la derecha
    no-cero de @c(x). Escribe una version de @c(PopCount) que cuente bits
    mediante este hecho, y evalua su rendimiento.

# ** Section 2.7 <> Scope
** Seccion 2.7 <> Alcance

#    A declaration associates a name with a program entity, such as a function or
#    a variable. The @e(scope) of a declaration is the part of the source code
#    where a use of the declared name refers to that declaration.
   Una declaracion asocia un nombre a una entidad de programa, como una funcion
   o una variable. El @e(alcance) de una declaracion es la parte del codigo
   fuente, donde el uso de un nombre declarado hace referencia a esa
   declaracion.

#    Don’t confuse scope with lifetime. The scope of a declaration is a region of
#    the program text; it is a compile-time property. The lifetime of a variable
#    is the range of time during execution when the variable can be referred to by
#    other parts of the program; it is a run-time property.
   No confunda el alcance con el tiempo de vida. El alcance de una declaracion
   es una region del texto del programa; Es una propiedad de tiempo de
   compilacion. La vida util de una variable es el intervalo de tiempo durante
   la ejecucion cuando la variable puede ser referida por otras partes del
   programa; Es una propiedad en tiempo de ejecucion.

#    A syntactic @e(block) is a sequence of statements enclosed in braces like
#    those that surround the body of a function or loop. A name declared inside a
#    syntactic block is not visible outside that block. The block encloses its
#    declarations and determines their scope. We can generalize this notion of
#    blocks to include other groupings of declarations that are not explicitly
#    surrounded by braces in the source code; we’ll call them all @e(lexical
#    blocks). There is a lexical block for the entire source code, called the
#    @e(universe block); for each package; for each file; for each @c(for),
#    @c(if), and @c(switch) statement; for each case in a @c(switch) or @c(select)
#    statement; and, of course, for each explicit syntactic block.
   Un @e(bloque) sintactico es una secuencia de sentencias encerradas entre
   llaves como las que rodean el cuerpo de una funcion o bucle. Un nombre
   declarado dentro de un bloque sintactico no es visible fuera de ese
   bloque. El bloque incluye sus declaraciones y determina su alcance. Podemos
   generalizar esta nocion de bloques para incluir otras agrupaciones de
   declaraciones que no estan explicitamente rodeadas por llaves en el codigo
   fuente; los llamaremos a todos @e(bloques lexicos). Hay un bloque lexico para
   todo el codigo fuente, llamado @e(bloque del universo); para cada paquete;
   para cada archivo; para cada sentencia @c(for), @c(if), y @c(switch); para
   cada caso en una sentencia @c(switch) o @c(select); Y, por supuesto, para
   cada bloque sintactico explicito.

#    A declaration’s lexical block determines its scope, which may be large or
#    small. The declarations of built-in types, functions, and constants like
#    @c(int), @c(len), and @c(true) are in the universe block and can be referred
#    to throughout the entire program. Declarations outside any function, that is,
#    at @e(package level), can be referred to from any file in the same
#    package. Imported packages, such as @c(fmt) in the @c(tempconv) example, are
#    declared at the @e(file level), so they can be referred to from the same
#    file, but not from another file in the same package without another
#    @c(import). Many declarations, like that of the variable @c(c) in the
#    @c(tempconv.CToF) function, are @e(local), so they can be referred to only
#    from within the same function or perhaps just a part of it.
   El bloque lexico de una declaracion determina su alcance, que puede ser
   grande o pequeño. Las declaracion de tipos nativos, funciones y constantes,
   por ejemplo @c(int), @c(len), y @c(true) estan en el bloque universo y pueden
   ser referidos a lo largo de todo el programa. Declaraciones fuera de
   cualquier funcion, es decir, a @e(nivel de paquete), puede ser refenciadas en
   cualquier archivo en el mismo paquete. Paquetes importados, como @c(fmt) en
   el ejemplo @c(tempconv), se declaran a @e(nivel de archivo), por lo que se
   puede hacer referencia a partir del mismo archivo, pero no desde otro archivo
   en el mismo paquete sin otro @c(import). Muchas declaraciones, como la de la
   variable @c(c) en la funcion @c(tempconv.CToF), son @e(locales), por lo que
   puden ser referidos solo desde dentro de la misma funcion o tal vez solo en
   una parte de ella.

#    The scope of a control-flow label, as used by @c(break), @c(continue), and
#    @c(goto) statements, is the entire enclosing function.
   El alcance de una etiqueta de flujo de control, tal como se utiliza por las
   sentencias @c(break), @c(continue), y @c(goto), es toda la funcion que la
   rodea.

#    A program may contain multiple declarations of the same name so long as each
#    declaration is in a different lexical block. For example, you can declare a
#    local variable with the same name as a package-level variable. Or, as shown
#    in @l(#Section 2.3.3), you can declare a function parameter called @c(new),
#    even though a function of this name is predeclared in the universe
#    block. Don’t overdo it, though; the larger the scope of the redeclaration,
#    the more likely you are to surprise the reader.
   Un programa puede contener varias declaraciones del mismo nombre, siempre y
   cuando cada declaracion este en un bloque lexico diferente. Por ejemplo,
   puede declarar una variable local con el mismo nombre que una variable a
   nivel de paquete. O, como se muestra en la @l(#Seccion 2.3.3), se puede
   declarar un parametro de funcion llamado @c(new), a pesar de tener una
   funcion con este nombre declarada con anterioridad en el bloque universo. No
   exagere, cuanto mayor sea el alcance de la redeclaracion, mas probable es que
   sorprenda al lector.

#    When the compiler encounters a reference to a name, it looks for a
#    declaration, starting with the innermost enclosing lexical block and working
#    up to the universe block. If the compiler finds no declaration, it reports an
#    @"(undeclared name) error. If a name is declared in both an outer block and
#    an inner block, the inner declaration will be found first. In that case, the
#    inner declaration is said to @e(shadow) or @e(hide) the outer one, making it
#    inaccessible:
   Cuando el compilador encuentra una referencia a un nombre, busca una
   declaracion, comenzando con el bloque lexico interno mas cercano y explorando
   hasta el bloque universo. Si el compilador no encuentra ninguna declaracion,
   se informa de un error de @"(nombre no declarado.) Si se declara un nombre
   tanto en un bloque externo como en un bloque interno, se encontrara primero
   la declaracion interna. En ese caso, se dice que la declaracion interna
   @e(obscurese) u @e(ocultar) la exterior, por lo que es inaccesible:

#    ..src > go
#      func f() {}
#      var g = "g"
#      func main() {
#        f := "f"
#        fmt.Println(f) // "f"; local var f shadows package-level func f
#        fmt.Println(g) // "g"; package-level var
#        fmt.Println(h) // compile error: undefined: h
#      }
#    < src..
   ..src > go
     func f() {}
     var g = "g"
     func main() {
       f := "f"
       fmt.Println(f) // "f"; la variable f local oculta la funcion f a nivel de paquete
       fmt.Println(g) // "g"; variable a nivel de paquete
       fmt.Println(h) // error de compilacion: sin definir: h
     }
   < src..

#    Within a function, lexical blocks may be nested to arbitrary depth, so one
#    local declaration can shadow another. Most blocks are created by control-flow
#    constructs like @c(if) statements and @c(for) loops. The program below has
#    three different variables called @c(x) because each declaration appears in a
#    different lexical block. (This example illustrates scope rules, not good
#    style!)
   Dentro de una funcion, los bloques lexicos pueden anidarse en una profundidad
   arbitraria, por lo que una declaracion local puede sombrear a otra. La
   mayoria de los bloques son creados por construcciones de flujo de control,
   como las declaraciones @c(if) y los bucles @c(for). El programa siguiente
   tiene tres variables distintas llamadas @c(x), ya que cada declaracion
   aparece en un bloque lexico diferente. (Este ejemplo ilustra las reglas de
   alcance, no es un buen estilo de programacion!)

#    ..src > go
#      func main() {
#        x := "hello!"
#        for i := 0; i < len(x); i++ {
#          x := x[i]
#          if x != '!' {
#            x := x + 'A' - 'a'
#            fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
#          }
#        }
#      }
#    < src..
   ..src > go
     func main() {
       x := "hello!"
       for i := 0; i < len(x); i++ {
         x := x[i]
         if x != '!' {
           x := x + 'A' - 'a'
           fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
         }
       }
     }
   < src..

#    The expressions @c(x[i]) and @c(x + 'A' - 'a') each refer to a declaration of
#    @c(x) from an outer block; we’ll explain that in a moment. (Note that the
#    latter expression is @e(not) equivalent to @c(unicode.ToUpper).)
   Las expresiones @c(x[i]) y @c(x + 'A' - 'a') se refieren cada una a una
   declaracion de @c(x) a partir de un bloque exterior; Lo explicaremos en un
   momento. (Tenga en cuenta que esta ultima expresion @e(no) es equivalente a
   @c(unicode.ToUpper)).

#    As mentioned above, not all lexical blocks correspond to explicit
#    brace-delimited sequences of statements; some are merely implied. The @c(for)
#    loop above creates two lexical blocks: the explicit block for the loop body,
#    and an implicit block that additionally encloses the variables declared by
#    the initialization clause, such as @c(i). The scope of a variable declared in
#    the implicit block is the condition, post-statement (@c(i++)), and body of
#    the @c(for) statement.
   Como se menciono anteriormente, no todos los bloques lexicos corresponden con
   secuencias delimitadas explicitamente por llaves; Algunos simplemente son
   implicitos. El bucle @c(for) anterior crea dos bloques lexicos: el bloque
   explicito para el cuerpo del bucle, y un bloque implicito que adicionalmente
   encierra las variables declaradas por la clausula de inicializacion, como
   @c(i). El alcance de una variable declarada en el bloque implicito es la
   condicion, post-declaracion (@c(i++)), y el cuerpo del comunicado @c(for).

#    The example below also has three variables named @c(x), each declared in a
#    different block—one in the function body, one in the @c(for) statement’s block,
#    and one in the loop body—but only two of the blocks are explicit:
   El siguiente ejemplo tambien tiene tres variables denominadas @c(x), cada una
   declarada en un bloque distinto–una en el cuerpo de la funcion, una en un
   bloque de sentencia @c(for) y uno en el cuerpo del bucle–pero solo dos de los
   bloques son explicitos:

#    ..src > go
#      func main() {
#        x := "hello"
#        for _, x := range x {
#          x := x + 'A' - 'a'
#          fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
#        }
#      }
#    < src..
   ..src > go
     func main() {
       x := "hello"
       for _, x := range x {
         x := x + 'A' - 'a'
         fmt.Printf("%c", x) // "HELLO" (una letra por iteracion)
       }
     }
   < src..

#    Like @c(for) loops, @c(if) statements and @c(switch) statements also create
#    implicit blocks in addition to their body blocks. The code in the following
#    @c(if)-@c(else) chain shows the scope of @c(x) and @c(y):
   Al igual que bucle @c(for), las declaraciones @c(if) y @c(switch) tambien
   crean un bloque implicito que, ademas del cuerpo de sus bloques. El codigo en
   la siguiente cadena @c(if)-@c(else) muestra el alcance de @c(x) y @c(y):

#    ..src > go
#      if x := f(); x == 0 {
#        fmt.Println(x)
#      } else if y := g(x); x == y {
#        fmt.Println(x, y)
#      } else {
#        fmt.Println(x, y)
#      }
#      fmt.Println(x, y) // compile error: x and y are not visible here
#    < src..
   ..src > go
     if x := f(); x == 0 {
       fmt.Println(x)
     } else if y := g(x); x == y {
       fmt.Println(x, y)
     } else {
       fmt.Println(x, y)
     }
     fmt.Println(x, y) // error de compilacion: x y y no son visibles aqui
   < src..

#    The second @c(if) statement is nested within the first, so variables declared
#    within the first statement’s initializer are visible within the
#    second. Similar rules apply to each case of a switch statement: there is a
#    block for the condition and a block for each case body.
   La segunda declaracion @c(if) esta anidada dentro de la primera, por lo que
   las variables declaradas dentro de la inicializacion de la primer declaracion
   son visibles dentro de la segunda. Reglas similares se aplican a cada caso de
   una sentencia @c(switch): hay un bloque para la condicion y un bloque para
   cada cuerpo de caso.

#    At the package level, the order in which declarations appear has no effect on
#    their scope, so a declaration may refer to itself or to another that follows
#    it, letting us declare recursive or mutually recursive types and
#    functions. The compiler will report an error if a constant or variable
#    declaration refers to itself, however.
   En el nivel de paquete, el orden en el que aparecen las declaraciones no
   tiene ningun efecto en su alcance, por lo que una declaracion puede referirse
   a si misma, o a otra que le sigue, permitiendonos declarar tipos y funciones
   recursivos o recursivos mutuamente. Sin embargo, el compilador reportara un
   error si una declaracion constante o variable se refiere a si misma.

#    In this program:
   En este programa:

#    ..src > go
#      if f, err := os.Open(fname); err != nil { // compile error: unused: f
#        return err
#      }
#      f.ReadByte() // compile error: undefined f
#      f.Close()    // compile error: undefined f
#    < src..
   ..src > go
     if f, err := os.Open(fname); err != nil { // error de compilacion: sin usar: f
       return err
     }
     f.ReadByte() // error de compilacion: f sin definir
     f.Close()    // error de compilacion: f sin definir
   < src..

#    the scope of @c(f) is just the @c(if) statement, so @c(f) is not accessible to the
#    statements that follow, resulting in compiler errors. Depending on the
#    compiler, you may get an additional error reporting that the local variable @c(f)
#    was never used.
   el alcance de @c(f) es solo la sentencia @c(if), por lo que @c(f) no es
   accesible a los estados que despues de enta, lo que resulta en errores de
   compilacion. Dependiendo del compilador, puede obtener un informe de errores
   adicional de que la variable local @c(f) nunca fue utilizada.

#    Thus it is often necessary to declare @c(f) before the condition so that it
#    is accessible after:
   Por lo tanto, a menudo es necesario declarar @c(f) antes de la condicion de modo
   que sea accesible mas tarde:

#    ..src > go
#      f, err := os.Open(fname)
#      if err != nil {
#        return err
#      }
#      f.ReadByte()
#      f.Close()
#    < src..
   ..src > go
     f, err := os.Open(fname)
     if err != nil {
       return err
     }
     f.ReadByte()
     f.Close()
   < src..

#    You may be tempted to avoid declaring @c(f) and @c(err) in the outer block by
#    moving the calls to @c(ReadByte) and @c(Close) inside an @c(else) block:
   Es posible que se sienta tentado a evitar declarar @c(f) y @c(err) en el
   bloque externo moviendo las llamadas a @c(ReadByte) y @c(Close) dentro del
   bloque @c(else):

#    ..src > go
#      if f, err := os.Open(fname); err != nil {
#        return err
#      } else {
#        // f and err are visible here too
#        f.ReadByte()
#        f.Close()
#      }
#    < src..
   ..src > go
     if f, err := os.Open(fname); err != nil {
       return err
     } else {
       // f and err are visible here too
       f.ReadByte()
       f.Close()
     }
   < src..

#    but normal practice in Go is to deal with the error in the @c(if) block and
#    then return, so that the successful execution path is not indented.
   pero una practica normal en Go es tratar con el error en el bloque @c(if) y
   luego regresar, de modo que la ruta de ejecucion exitosa no este indentada.

#    Short variable declarations demand an awareness of scope. Consider the
#    program below, which starts by obtaining its current working directory and
#    saving it in a package-level variable. This could be done by calling
#    @c(os.Getwd) in function @c(main), but it might be better to separate this
#    concern from the primary logic, especially if failing to get the directory is
#    a fatal error. The function @c(log.Fatalf) prints a message and calls
#    @c[os.Exit(1)].
   Las declaracion de variables compacta exige un conocimiento del
   alcance. Considere el siguiente programa, que comienza obteniendo su
   directorio de trabajo actual y guardandolo en una variable a nivel de
   paquete. Esto podria hacerse llamando a @c(os.Getwd) en la funcion @c(main),
   pero podria ser mejor separar esta preocupacion de la logica primaria, sobre
   todo si no podemos conseguir el directorio, es un error fatal. La funcion
   @c(log.Fatalf) imprime un mensaje y llama @c[os.Exit(1)].

#    ..src > go
#      var cwd string
#
#      func init() {
#        cwd, err := os.Getwd() // compile error: unused: cwd
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // error de compilacion: sin usar: cwd
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..
  var cadena cwd

#    Since neither @c(cwd) nor @c(err) is already declared in the init function’s block,
#    the @c(:=) statement declares both of them as local variables. The inner
#    declaration of @c(cwd) makes the outer one inaccessible, so the statement does
#    not update the package-level @c(cwd) variable as intended.
  Dado que ni @c(cwd) ni @c(err) se declaran en el bloque de la funcion
  @c(init), la sentencia @c(:=) declara ambas como variables locales. La
  declaracion interna de @c(cwd) hace que la externa sea inaccesible, por lo que
  la sentencia no actualiza la variable @c(cdw) de nivel de paquete como se
  pretende.

#    Current Go compilers detect that the local @c(cwd) variable is never used and
#    report this as an error, but they are not strictly required to perform this
#    check. Furthermore, a minor change, such as the addition of a logging
#    statement that refers to the local @c(cwd) would defeat the check.
  Los compiladores de Go actuales detectan que la variable local @c(cwd) nunca
  se utilza e informar de esto como un error, pero no son estrictamente
  necesarias para llevar a cabo esta comprobacion. Por otra parte, un cambio
  menor, como la adicion de una declaracion de registro que se hace referencia a
  la @c(cwd) local, anularia la comprobacion.

#    ..src > go
#      var cwd string
#
#      func init() {
#        cwd, err := os.Getwd() // NOTE: wrong!
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#        log.Printf("Working directory = %s", cwd)
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       cwd, err := os.Getwd() // NOTA: incorrecto!
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
       log.Printf("Working directory = %s", cwd)
     }
   < src..

#    The global @c(cwd) variable remains uninitialized, and the apparently normal
#    log output obfuscates the bug.
   La variable global @c(cwd) permanece sin inicializar, y la salida del
   registro aparentemente normal ofusca el fallo.

#    There are a number of ways to deal with this potential problem. The most
#    direct is to avoid @c(:=) by declaring @c(err) in a separate @c(var)
#    declaration:
   Hay un numero de maneras de lidiar con este problema potencial. La mas
   directa es evitar @c(:=) declarando @c(err) en una declaracion @c(var)
   separada:

#    ..src > go
#      var cwd string
#
#      func init() {
#        var err error
#        cwd, err = os.Getwd()
#        if err != nil {
#          log.Fatalf("os.Getwd failed: %v", err)
#        }
#      }
#    < src..
   ..src > go
     var cwd string

     func init() {
       var err error
       cwd, err = os.Getwd()
       if err != nil {
         log.Fatalf("os.Getwd failed: %v", err)
       }
     }
   < src..

#    We’ve now seen how packages, files, declarations, and statements express the
#    structure of programs. In the next two chapters, we’ll look at the structure
#    of data.
   Hemos visto como los paquetes, archivos, declaraciones y declaraciones
   expresan la estructura de los programas. En los proximos dos capitulos,
   veremos la estructura de los datos.

# * Chapter 3 <> Basic Data Types
* Capitulo 3 <> Tipos de datos basicos

#   It’s all bits at the bottom, of course, but computers operate fundamentally on
#   fixed-size numbers called @e(words), which are interpreted as integers,
#   floating-point numbers, bit sets, or memory addresses, then combined into
#   larger aggregates that represent packets, pixels, portfolios, poetry, and
#   everything else. Go offers a variety of ways to organize data, with a spectrum
#   of data types that at one end match the features of the hardware and at the
#   other end provide what programmers need to conveniently represent complicated
#   data structures.
  En el fondo todo son solo bits, por supuesto, pero las computadoras operan
  fundamentalmente en numeros de tamaño fijo llamados palabras, que se
  interpretan como numeros enteros, numeros de punto flotante, conjuntos de
  bits, o direcciones de memoria, que luego se combinana en agregados mas
  grandes que representan paquetes, pixeles, carteras, poesia y todo lo
  demas. Go ofrece una variedad de formas de organizar los datos, con un
  espectro de tipos de datos que en un extremo coinciden con las caracteristicas
  del hardware y en el otro extremo proporcionan lo que los programadores
  necesitan para representar convenientemente estructuras de datos complicadas.

#   Go’s types fall into four categories: @e(basic types), @e(aggregate types),
#   @e(reference types), and @e(interface types). Basic types, the topic of this
#   chapter, include numbers, strings, and booleans. Aggregate types—arrays
#   (@l(#Section 4.1<>§4.1)) and structs (@l(#Section 4.4<>§4.4))—form more
#   complicated data types by combining values of several simpler ones. Reference
#   types are a diverse group that includes pointers (@l(#Section 2.3.2<>§2.3.2)),
#   slices (@l(#Section 4.2<>§4.2)), maps (@l(#Section 4.3<>§4.3)), functions
#   (@l(#Chapter 5)), and channels (@l(#Chapter 8)), but what they have in common
#   is that they all refer to program variables or state @e(indirectly), so that
#   the effect of an operation applied to one reference is observed by all copies
#   of that reference. Finally, we’ll talk about interface types in @l(#Chapter
#   7).
  Los tipos de datos de Go se dividen en cuatro categorias: @e(tipos basicos),
  @e(tipos de agregados), @e(tipos de referencia), y @e(tipos de interfaz). Los
  tipos basicos, el tema de este capitulo, incluyen numeros, cadenas y
  booleanos. Los tipos agregados–arreglos (@l(#Seccion 4.1<>§4.1)) y estructuras
  (@l(#Seccion 4.4<>§4.4))–forma tipos de datos mas complejos mediante la
  combinacion de otros valores mas simples. Los tipos de referencia son un grupo
  diverso, que incluye punteros (@l(#Seccion 2.3.2<>§2.3.2)), slices
  (@l(#Seccion 4.2<>§4.2)), mapas (@l(#Seccion 4.3<>§4.3)), funciones
  (@l(#Capitulo 5)), y canales (@l(#Capitulo 8)), pero lo que tienen en comun es
  que se todos ellos se refieren a variables del programa o estados
  indirectamente, por lo que el efecto de una operacion que se aplica a una
  referencia es observado por todas las copias de esa referencia. Por ultimo,
  hablaremos de los tipos de interfaz en el @l(#Capitulo 7).

# ** Section 3.1 <> Integers
** Seccion 3.1 <> Enteros

#    Go’s numeric data types include several sizes of integers, floating-point
#    numbers, and complex numbers. Each numeric type determines the size and
#    signedness of its values. Let’s begin with integers.
   Los tipos de datos numericos de Go incluyen varios tamaños de enteros,
   numeros de coma flotante y numeros complejos. Cada tipo numerico determina el
   tamaño y la firma de sus valores. Comencemos con numeros enteros.

#    Go provides both signed and unsigned integer arithmetic. There are four
#    distinct sizes of signed integers—8, 16, 32, and 64 bits—represented by the
#    types @c(int8), @c(int16), @c(int32), and @c(int64), and corresponding
#    unsigned versions @c(uint8), @c(uint16), @c(uint32), and @c(uint64).
   Go proporciona tanto aritmetica con y sin signo. Hay cuatro tamaños distintos
   de numeros enteros–8, 16, 32 y 64 bits–representados por los tipos @c(int8),
   @c(int16), @c(int32), y @c(int64), y las correspondientes versiones sin signo
   @c(uint8), @c(uint16), @c(uint32), y @c(uint64).

#    There are also two types called just @c(int) and @c(uint) that are the
#    natural or most efficient size for signed and unsigned integers on a
#    particular platform; @c(int) is by far the most widely used numeric
#    type. Both these types have the same size, either 32 or 64 bits, but one must
#    not make assumptions about which; different compilers may make different
#    choices even on identical hardware.
   Tambien hay dos tipos llamados simplemente @c(int) y @c(uint) que son del
   tamaño natural o mas eficiente para los numeros enteros con y sin signo en
   una plataforma en particular; @c(int) es de lejos el tipo numerico mas
   utilizado. Ambos tipos tienen el mismo tamaño, 32 o 64 bits, pero uno no debe
   hacer suposiciones sobre cual es; Diferentes compiladores pueden tomar
   diferentes opciones incluso en hardware identico.

#    The type @c(rune) is an synonym for @c(int32) and conventionally indicates
#    that a value is a Unicode code point. The two names may be used
#    interchangeably. Similarly, the type @c(byte) is an synonym for @c(uint8),
#    and emphasizes that the value is a piece of raw data rather than a small
#    numeric quantity.
   El tipo @c(rune) es un sinonimo de @c(int32) y convencionalmente indica que
   un valor es un punto de codigo Unicode. Los dos nombres pueden utilizarse
   indistintamente. Del mismo modo, el tipo de @c(byte) es un sinonimo de
   @c(uint8), y hace hincapie en que el valor es una pieza de datos en bruto mas
   que una pequeña cantidad numerica.

#    Finally, there is an unsigned integer type @c(uintptr), whose width is not
#    specified but is sufficient to hold all the bits of a pointer value. The
#    @c(uintptr) type is used only for low-level programming, such as at the
#    boundary of a Go program with a C library or an operating system. We’ll see
#    examples of this when we deal with the @c(unsafe) package in @l(#Chapter 13).
   Por ultimo, existe un tipo entero sin signo @c(uintptr), cuya anchura no se
   especifica, pero es suficiente para contener todos los bits de un valor de
   puntero. El tipo @c(uintptr) solo se utiliza para la programacion a bajo
   nivel, por ejemplo, en el limite de un programa Go con una libreria C o un
   sistema operativo. Veremos ejemplos de esto cuando nos ocupemos del paquete
   @c(unsafe) en el @l(#Capitulo 13).

#    Regardless of their size, @c(int), @c(uint), and @c(uintptr) are different types
#    from their explicitly sized siblings. Thus @c(int) is not the same type as
#    @c(int32), even if the natural size of integers is 32 bits, and an explicit
#    conversion is required to use an @c(int) value where an @c(int32) is needed,
#    and vice versa.
   Independientemente de su tamaño, @c(int), @c(uint) y @c(uintptr) son
   diferentes tipos de sus hermanos de tamaño de forma explicita. Por lo tanto
   @c(int) no es el mismo tipo que @c(int32), incluso si el tamaño natural de
   enteros es de 32 bits, y requiere una conversion explicita utilizar un valor
   @c(int) donde se necesita un @c(int32), y viceversa.

#    Signed numbers are represented in 2’s-complement form, in which the
#    high-order bit is reserved for the sign of the number and the range of values
#    of an @m(n)-bit number is from -2ⁿ⁻¹ to 2ⁿ⁻¹-1. Unsigned integers use the
#    full range of bits for non-negative values and thus have the range 0 to
#    2ⁿ-1. For instance, the range of @c(int8) is -128 to 127, whereas the range
#    of @c(uint8) is 0 to 255.
   Numeros con signo se representan en forma de complemento a 2, en el que el
   bit de orden superior esta reservado para el signo del numero y la gama de
   valores de un numero de @m(n) bits es de -2ⁿ⁻¹ a 2ⁿ⁻¹-1. Los numeros enteros
   sin signo usan el rango completo de bits para valores no negativos y por lo
   tanto tienen el rango de 0 a 2ⁿ-1. Por ejemplo, la gama de @c(int8) entre
   -128 y 127, mientras que la gama de @c(uint8) es de 0 a 255.

#    Go’s binary operators for arithmetic, logic, and comparison are listed here
#    in order of decreasing precedence:
   En Go Los operadores binarios de aritmetica, logica y comparacion se enumeran
   aqui en orden decreciente de precedencia:

#    ..pre >
#      *   /   %  <<  >>  &   &^
#      +   -   |  ^
#      ==  !=  <  <=  >   >=
#      &&
#      ||
#    < pre..
   ..pre >
     *   /   %  <<  >>  &   &^
     +   -   |  ^
     ==  !=  <  <=  >   >=
     &&
     ||
   < pre..

#    There are only five levels of precedence for binary operators. Operators at
#    the same level associate to the left, so parentheses may be required for
#    clarity, or to make the operators evaluate in the intended order in an
#    expression like @c[mask & (1 << 28)].
   Solo hay cinco niveles de precedencia para los operadores binarios. Los
   operadores en el mismo nivel se asocian a la izquierda, por lo que pueden ser
   necesarios parentesis, para mayor claridad, o para hacer que los operadores
   evaluan en el orden deseado en una expresion como @c[mask & (1 << 28)].

#    Each operator in the first two lines of the table above, for instance @c(+),
#    has a corresponding @c(assignment operator) like @c(+=) that may be used to
#    abbreviate an assignment statement.
   Cada operador en las dos primeras lineas de la tabla anterior, por ejemplo
   @c(+), tiene un operador de asignacion correspondiente como @c(+=) que pueden
   utilizarse para abreviar una instruccion de asignacion.

#    The integer arithmetic operators @c(+), @c(-), @c(*), and @c(/) may be
#    applied to integer, floating-point, and complex numbers, but the remainder
#    operator @c(%) applies only to integers. The behavior of @c(%) for negative
#    numbers varies across programming languages. In Go, the sign of the remainder
#    is always the same as the sign of the dividend, so @c(-5%3) and @c(-5%-3) are
#    both @c(-2). The behavior of @c(/) depends on whether its operands are
#    integers, so @c(5.0/4.0) is @c(1.25), but @c(5/4) is @c(1) because integer
#    division truncates the result toward zero.
   Los operadores aritmetica enteros @c(+), @c(-), @c(*), y @c(/) pueden
   aplicarse a numeros enteros, de coma flotante, y numeros complejos, pero el
   operador @c(%) solo se aplica a numeros enteros. El comportamiento de @c(%)
   para los numeros negativos varia a traves de los lenguajes de
   programacion. En Go, el signo del resto es siempre el mismo que el signo del
   dividendo, por lo @c(-5%3) y @c(-5%-3) son ambos @c(-2). El comportamiento de
   @c(/) depende de si sus operandos son numeros enteros, por lo que @c(5.0/4.0)
   es @c(1.25), pero @c(5/4) es @c(1) porque la division entera trunca el
   resultado hacia cero.

#    If the result of an arithmetic operation, whether signed or unsigned, has
#    more bits than can be represented in the result type, it is said to
#    @e(overflow). The high-order bits that do not fit are silently discarded. If
#    the original number is a signed type, the result could be negative if the
#    leftmost bit is a 1, as in the @c(int8) example here:
   Si el resultado de una operacion aritmetica, ya sea con o sin signo, tiene
   mas bits de los que pueden ser representados en el tipo del resultado, se
   dice que se @e(desborda). Los bits de orden superior que no encajan se
   descartan silenciosamente. Si el numero original es un tipo con signo, el
   resultado podria ser negativo si el bit mas a la izquierda es un 1, como en
   el @c(int8) ejemplo aqui:

#    ..src > go
#      var u uint8 = 255
#      fmt.Println(u, u+1, u*u) // "255 0 1"
#
#      var i int8 = 127
#      fmt.Println(i, i+1, i*i) // "127 -128 1"
#    < src..
   ..src > go
     var u uint8 = 255
     fmt.Println(u, u+1, u*u) // "255 0 1"

     var i int8 = 127
     fmt.Println(i, i+1, i*i) // "127 -128 1"
   < src..

#    Two integers of the same type may be compared using the binary comparison
#    operators below; the type of a comparison expression is a boolean.
   Dos numeros enteros del mismo tipo pueden compararse usando los operadores de
   comparacion binarios siguientes; El tipo de una expresion de comparacion es
   un booleano.

#    | @c(==) | equal to                 |
#    |--------|--------------------------|
#    | @c(!=) | not equal to             |
#    |--------|--------------------------|
#    | @c(<)  | less than                |
#    |--------|--------------------------|
#    | @c(<=) | less than or equal to    |
#    |--------|--------------------------|
#    | @c(>)  | greater than             |
#    |--------|--------------------------|
#    | @c(>=) | greater than or equal to |
   | @c(==) | igual a             |
   |--------|---------------------|
   | @c(!=) | no igual a          |
   |--------|---------------------|
   | @c(<)  | menor que           |
   |--------|---------------------|
   | @c(<=) | Menor que o igual a |
   |--------|---------------------|
   | @c(>)  | mayor que           |
   |--------|---------------------|
   | @c(>=) | Mayor que o igual a |

#    In fact, all values of basic type—booleans, numbers, and strings—are
#    @e(comparable), meaning that two values of the same type may be compared
#    using the @c(==) and @c(!=) operators. Furthermore, integers, floating-point
#    numbers, and strings are @e(ordered) by the comparison operators. The values
#    of many other types are not comparable, and no other types are ordered. As we
#    encounter each type, we’ll present the rules governing the @e(comparability)
#    of its values.
   De hecho, todos los valores de tipo basico–booleanos, numeros y cadenas–son
   comparables, lo que significa que dos valores del mismo tipo pueden ser
   comparados con los operadores @c(==) y @c(!=). Por otra parte, los numeros
   enteros, numeros de punto flotante y cadenas son @e(ordenados) por los
   operadores de comparacion. Los valores de muchos otros tipos no son
   comparables y no se ordenan otros tipos. A medida que nos encontramos cada
   tipo, vamos a presentar las normas que rigen la comparacion de sus valores.

#    There are also unary addition and subtraction operators:
   Tambien hay operadores unarios de suma y resta:

#    | @c(+) | unary positive (no effect) |
#    |-------|----------------------------|
#    | @c(-) | unary negation             |
   | @c(+) | Unario positivo (sin efecto) |
   |-------|------------------------------|
   | @c(-) | Negacion unaria              |

#    For integers, @c(+x) is a shorthand for @c(0+x) and @c(-x) is a shorthand for
#    @c(0-x); for floating-point and complex numbers, @c(+x) is just @c(x) and
#    @c(-x) is the negation of @c(x).
   Para enteros, @c(+x) es una abreviatura de @c(0+x) y @c(-x) es una
   abreviatura de @c(0-x); para los numeros de punto flotante y complejos,
   @c(+x) es @c(x) y @c(-x) es la negacion de @c(x).

#    Go also provides the following bitwise binary operators, the first four of
#    which treat their operands as bit patterns with no concept of arithmetic
#    carry or sign:
   Go tambien proporciona los siguientes operadores binarios a nivel de bits,
   cuyos cuatro primeros tratan a sus operandos como patrones de bits sin ningun
   concepto aritmetico o signo:

#    | @c(&)  | bitwise AND         |
#    |--------|---------------------|
#    | @c(|)  | bitwise OR          |
#    |--------|---------------------|
#    | @c(^)  | bitwise XOR         |
#    |--------|---------------------|
#    | @c(&^) | bit clear (AND NOT) |
#    |--------|---------------------|
#    | @c(<<) | left shift          |
#    |--------|---------------------|
#    | @c(>>) | right shift         |
   | @c(&)  | AND bit a bit                 |
   |--------|-------------------------------|
   | @c(|)  | OR bit a bit                  |
   |--------|-------------------------------|
   | @c(^)  | XOR bit a bit                 |
   |--------|-------------------------------|
   | @c(&^) | AND NOT                       |
   |--------|-------------------------------|
   | @c(<<) | desplazamiento a la izquierdo |
   |--------|-------------------------------|
   | @c(>>) | desplazamiento a la derecha   |

#    The operator @c(^) is bitwise exclusive OR (XOR) when used as a binary
#    operator, but when used as a unary prefix operator it is bitwise negation or
#    complement; that is, it returns a value with each bit in its operand
#    inverted. The @c(&^) operator is bit clear (AND NOT): in the expression @c(z
#    = x &^ y), each bit of @c(z) is 0 if the corresponding bit of @c(y) is 1;
#    other wise it equals the corresponding bit of @c(x).
   El operador bit a bit @c(^) es un OR exclusivo (XOR) cuando se utiliza como
   un operador binario (coloca un uno en cada posicion en donde sus operandos
   tienen bits distintos, y un cero en donde son iguales), pero cuando se
   utiliza como un operador de prefijo unario es el complemento a uno; es decir,
   devuelve un valor con cada bit en su operando invertido. El operador @c(&^)
   es para lipiar bits (AND NOT): en la expresion @c(z = x &^ y), cada bit de
   @c(z) es 0 si el bit correspondiente de @c(y) es 1; de lo contrario es igual
   al bit correspondiente de @c(x).

#    The code below shows how bitwise operations can be used to interpret a
#    @c(uint8) value as a compact and efficient set of 8 independent bits. It uses
#    @c(Printf)’s @c(%b) verb to print a number’s binary digits; @c(08) modifies
#    @c(%b) (an adverb!) to pad the result with zeros to exactly 8 digits.
   El siguiente codigo muestra como se pueden utilizar las operaciones a nivel
   de bit para interpretar un valor @c(uint8) como un conjunto compacto y
   eficiente de 8 bits independientes. Se utiliza el verbo @c(%b) de @c(Printf)
   para imprimir los digitos binarios de un numero; @c(08) modifica @c(%b) (un
   adverbio!)  para rellenar el resultado con ceros a exactamente 8 digitos.

#    ..src > go
#      package main
#
#      import "fmt"
#
#      func main(){
#        var x uint8 = 1<<1 | 1<<5
#        var y uint8 = 1<<1 | 1<<2
#
#        fmt.Printf("%08b\n", x)    // "00100010", the set {1, 5}
#        fmt.Printf("%08b\n", y)    // "00000110", the set {1, 2}
#        fmt.Printf("%08b\n", x&y)  // "00000010", the intersection {1}
#        fmt.Printf("%08b\n", x|y)  // "00100110", the union {1, 2, 5}
#        fmt.Printf("%08b\n", x^y)  // "00100100", the symmetric difference {2, 5}
#        fmt.Printf("%08b\n", x&^y) // "00100000", the difference {5}
#
#        for i := uint(0); i < 8; i++ {
#          if x&(1<<i) != 0 { // membership test
#            fmt.Println(i)   // "1", "5"
#          }
#        }
#
#        fmt.Printf("%08b\n", x<<1) // "01000100", the set {2, 6}
#        fmt.Printf("%08b\n", x>>1) // "00010001", the set {0, 4}
#      }
#    < src..
   ..src > go
     package main

     import "fmt"

     func main(){
       var x uint8 = 1<<1 | 1<<5
       var y uint8 = 1<<1 | 1<<2

       fmt.Printf("%08b\n", x)    // "00100010", el conjunto {1, 5}
       fmt.Printf("%08b\n", y)    // "00000110", el conjunto {1, 2}
       fmt.Printf("%08b\n", x&y)  // "00000010", la interseccion {1}
       fmt.Printf("%08b\n", x|y)  // "00100110", la union {1, 2, 5}
       fmt.Printf("%08b\n", x^y)  // "00100100", la diferencia simetrica {2, 5}
       fmt.Printf("%08b\n", x&^y) // "00100000", la diferencia {5}

       for i := uint(0); i < 8; i++ {
         if x&(1<<i) != 0 { // prueba de pertenencia
           fmt.Println(i)   // "1", "5"
         }
       }

       fmt.Printf("%08b\n", x<<1) // "01000100", el conjunto {2, 6}
       fmt.Printf("%08b\n", x>>1) // "00010001", el conjunto {0, 4}
     }
   < src..

#    (@l(#Section 6.5) shows an implementation of integer sets that can be much
#    bigger than a byte.)
   (La @l(#Seccion 6.5) muestra una implementacion de conjuntos de numeros
   enteros que pueden ser mucho mas grande que un byte).

#    In the shift operations @c(x<<n) and @c(x>>n), the @c(n) operand determines
#    the number of bit positions to shift and must be unsigned; the @c(x) operand
#    may be unsigned or signed. Arithmetically, a left shift @c(x<<n) is
#    equivalent to multiplication by 2ⁿ and a right shift @c(x>>n) is equivalent
#    to the floor of division by 2ⁿ.
   En las operaciones de desplazamiento @c(x<<n) y @c(x>>n), el operando @c(n)
   determina el numero de posiciones de bits a cambiar y debe ser sin signo; el
   operando @c(x) puede tener o no signo. Aritmeticamente, el desplazamiento a
   la izquierda @c(x<<n) es equivalente a la multiplicacion por 2ⁿ y un
   desplazamiento a la derecha @c(x>>n) es equivalente a dividir por 2ⁿ.

#    Left shifts fill the vacated bits with zeros, as do right shifts of unsigned
#    numbers, but right shifts of signed numbers fill the vacated bits with copies
#    of the sign bit. For this reason, it is important to use unsigned arithmetic
#    when you’re treating an integer as a bit pattern.
   Los desplazamientos a la izquierda o derecha en enteros sin singno llenan los
   bits desocupados con ceros, pero los desplazamientos a la derecha de numeros
   con signo llenan los bits desocupados con copias del bit de signo. Por esta
   razon, es importante utilizar aritmetica sin signo cuando se esta tratando un
   entero como un patron de bits.

#    Although Go provides unsigned numbers and arithmetic, we tend to use the
#    signed @c(int) form even for quantities that can’t be negative, such as the
#    length of an array, though @c(uint) might seem a more obvious choice. Indeed,
#    the built-in @c(len) function returns a signed @c(int), as in this loop which
#    announces prize medals in reverse order:
   Aunque Go proporciona aritmetica y numeros sin signo, se tiende a utilizar un
   int con signo incluso para cantidades que no pueden ser negativas, tales como
   la longitud de un arreglo, aunque @c(uint) puede parecer una eleccion mas
   obvia. De hecho, la funcion nativa @c(len) devuelve un @c(int) con signo,
   como en este bucle que anuncia medallas de premio en el orden inverso:

#    ..src > go
#      medals := []string{"gold", "silver", "bronze"}
#      for i := len(medals) - 1; i >= 0; i-- {
#        fmt.Println(medals[i]) // "bronze", "silver", "gold"
#      }
#    < src..
   ..src > go
     medallas := []string{"oro", "plata", "bronce"}
     for i := len(medallas) - 1; i >= 0; i-- {
       fmt.Println(medallas[i]) // "bornce", "plata", "oro"
     }
   < src..

#    The alternative would be calamitous. If @c(len) returned an unsigned number,
#    then @c(i) too would be a @c(uint), and the condition @c(i >= 0) would always
#    be true by definition. After the third iteration, in which @c(i == 0), the
#    @c(i--) statement would cause @c(i) to become not -1, but the maximum
#    @c(uint) value (for example, 2⁶⁴-1), and the evaluation of @c(medals[i])
#    would fail at run time, or @e(panic) (@l(#Section 5.9<>§5.9)), by attempting
#    to access an element outside the bounds of the slice.
   La alternativa seria calamitosa. Si @c(len) devuelve un numero sin signo,
   entonces @c(i) tambien seria un @c(uint), y la condicion @c(i >= 0) siempre
   seria verdadera por definicion. Despues de la tercera iteracion, en la cual
   @c(i == 0), la instruccion @c(i--) no haria que @c(i) se volviera -1, en
   cambion seria el valor maximo de @c(uint) (es decir, 2⁶⁴-1), y la evaluacion
   de @c(medallas[i]) fallaria en tiempo de ejecucion, o de @e(panico)
   (@l(#Seccion 5.9<>§5.9)), al tratar de acceder a un elemento fuera de los
   limites del slice.

#    For this reason, unsigned numbers tend to be used only when their bitwise
#    operators or peculiar arithmetic operators are required, as when implementing
#    bit sets, parsing binary file formats, or for hashing and cryptography. They
#    are typically not used for merely non-negative quantities.
   Por esta razon, los numeros sin signo tienden a utilizarse solo cuando se
   requieren sus operadores bit a bit u operadores aritmeticos peculiares, como
   cuando se implementan conjuntos de bits, se analizan formatos binarios de
   archivos o se usan hash y criptografia. Normalmente no se usan para
   cantidades meramente no negativas.

#    In general, an explicit conversion is required to convert a value from one
#    type to another, and binary operators for arithmetic and logic (except
#    shifts) must have operands of the same type. Although this occasionally
#    results in longer expressions, it also eliminates a whole class of problems
#    and makes programs easier to understand.
   En general, se requiere una conversion explicita para convertir un valor de
   un tipo a otro, y los operadores binarios para aritmetica y logica (excepto
   los desplazamientos) deben tener operandos del mismo tipo. Aunque esto
   resulta ocasionalmente en expresiones mas largas, tambien elimina toda una
   clase de problemas y hace que los programas sean mas faciles de entender.

#    As an example familiar from other contexts, consider this sequence:
   Como ejemplo familiar de otros contextos, considere esta secuencia:

#    ..src > go
#      var apples int32 = 1
#      var oranges int16 = 2
#      var compote int = apples + oranges // compile error
#    < src..
   ..src > go
     var manzanas int32 = 1
     var naranjas int16 = 2
     var compota int = manzanas + naranjas // Error de compiacion
   < src..

#    Attempting to compile these three declarations produces an error message:
   Al intentar compilar estas tres declaraciones se genera un mensaje de error:

#    ..pre >
#      invalid operation: apples + oranges (mismatched types int32 and int16)
#    < pre..
   ..pre >
     invalid operation: manzanas + naranjas (mismatched types int32 and int16)
   < pre..

#    This type mismatch can be fixed in several ways, most directly by converting
#    everything to a common type:
   Este tipo de incompatibilidad se puede corregir de varias maneras, mas
   directamente convirtiendo todo a un tipo comun:

#    ..src > go
#      var compote = int(apples) + int(oranges)
#    < src..
   ..src > go
     var compota = int(manzanas) + int(naranjas)
   < src..

#    As described in @l(#Section 2.5), for every type @c(T), the conversion
#    operation @c[T(x)] converts the value @c(x) to type @c(T) if the conversion
#    is allowed. Many integer-to-integer conversions do not entail any change in
#    value; they just tell the compiler how to interpret a value. But a conversion
#    that narrows a big integer into a smaller one, or a conversion from integer
#    to floating-point or vice versa, may change the value or lose precision:
   Como se describe en la @l(#Seccion 2.5), para cada tipo @c(T), la operacion
   de conversion @c[T(x)] convierte el valor @c(x) a tipo @c(T) si se permite la
   conversion. Muchas conversiones de entero a entero no implican ningun cambio
   en el valor; Solo le dicen al compilador como interpretar un valor. Pero una
   conversion que reduce un entero grande a uno mas pequeño o una conversion de
   entero a punto flotante o viceversa, puede cambiar el valor o perder
   precision:

#    ..src > go
#      f := 3.141          // a float64
#      i := int(f)
#      fmt.Println(f, i)   // "3.141 3"
#      f = 1.99
#      fmt.Println(int(f)) // "1"
#    < src..
   ..src > go
     f := 3.141          // un float64
     i := int(f)
     fmt.Println(f, i)   // "3.141 3"
     f = 1.99
     fmt.Println(int(f)) // "1"
   < src..

#    Float to integer conversion discards any fractional part, truncating toward
#    zero. You should avoid conversions in which the operand is out of range for
#    the target type, because the behavior depends on the implementation:
   La conversion de float a entero descarta cualquier parte fraccional,
   truncando hacia cero. Debe evitar las conversiones en las que el operando
   este fuera del rango del tipo destino, ya que el comportamiento depende de la
   implementacion:

#    ..src > go
#      f := 1e100  // a float64
#      i := int(f) // result is implementation-dependent
#    < src..
   ..src > go
     f := 1e100  // un float64
     i := int(f) // el resultado depende de la implementacion
   < src..

#    Integer literals of any size and type can be written as ordinary decimal
#    numbers, or as octal numbers if they begin with @c(0), as in @c(0666), or as
#    hexadecimal if they begin with @c(0x) or @c(0X), as in @c(0xdeadbeef). Hex
#    digits may be upper or lower case. Nowadays octal numbers seem to be used for
#    exactly one purpose—file permissions on POSIX systems—but hexadecimal numbers
#    are widely used to emphasize the bit pattern of a number over its numeric
#    value.
   Los literales enteros de cualquier tamaño y tipo se pueden escribir como
   numeros decimales ordinarios, o bien con numeros octales si comienzan con
   @c(0), como en @c(0666), o como hexadecimal si comienzan con @c(0x) o @c(0X),
   como en @c(0xdeadbeef). Los digitos hexadecimales pueden ser mayusculas o
   minusculas. Hoy en dia los numeros octales parecen ser utilizados para
   exactamente un proposito–permisos de archivo en sistemas POSIX–pero los
   numeros hexadecimales se utilizan ampliamente para enfatizar el patron de
   bits de un numero sobre su valor numerico.

#    When printing numbers using the fmt package, we can control the radix and
#    format with the @c(%d), @c(%o), and @c(%x) verbs, as shown in this example:
   Al imprimir numeros usando el paquete @c(fmt), podemos controlar la base y el
   formato con los verbos @c(%d), @c(%o), y @c(%x), como se muestra en este
   ejemplo:

#    ..src > go
#      o := 0666
#      fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
#      x := int64(0xdeadbeef)
#      fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
#      // Output:
#      // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
#    < src..
   ..src > go
     o := 0666
     fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
     x := int64(0xdeadbeef)
     fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
     // Salida:
     // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
   < src..

#    Note the use of two @c(fmt) tricks. Usually a @c(Printf) format string
#    containing multiple @c(%) verbs would require the same number of extra
#    operands, but the @c([1]) @"(adverbs) after @c(%) tell @c(Printf) to use the
#    first operand over and over again. Second, the @c(#) adverb for @c(%o) or
#    @c(%x) or @c(%X) tells @c(Printf) to emit a @c(0) or @c(0x) or @c(0X) prefix
#    respectively.
   Observe el uso de dos trucos de @c(fmt). Por lo general, una cadena de
   formato @c(Printf) que contiene multiples verbos @c(%) requeriria el mismo
   numero de operandos adicionales, pero los @"(adverbios) @c([1]) despues de
   @c(%) le indican a @c(Printf) utilizar el primer operando una y otra vez. En
   segundo lugar, el adverbio @c(#) enr @c(%o) o @c(%x) o @c(%X) indica a
   @c(Printf) emitir un prefijo @c(0) o @c(0x) o @c(0X) respectivamente.

#    Rune literals are written as a character within single quotes. The simplest
#    example is an ASCII character like @c('a'), but it’s possible to write any
#    Unicode code point either directly or with numeric escapes, as we will see
#    shortly.
   Las literales de runa se escriben como un caracter entre comillas
   simples. El ejemplo mas simple es un caracter ASCII como @c('a'), pero es
   posible escribir cualquier punto de codigo Unicode directamente o con escapes
   numericos, como veremos en breve.

#    Runes are printed with @c(%c), or with @c(%q) if quoting is desired:
   Las runas se imprimen con @c(%c), o con @c(%q) si se desea citar:

#    ..src > go
#      ascii := 'a'
#      unicode := '𢉩'
#      newline := '\n'
#      fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
#      fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 𢉩 '𢉩'"
#      fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
#    < src..
   ..src > go
     ascii := 'a'
     unicode := '𢉩'
     newline := '\n'
     fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 un 'a'"
     fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 𢉩 '𢉩'"
     fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
   < src..

# ** Section 3.2 <> Floating-Point Numbers
** Seccion 3.2 <> Numeros de punto flotante

#    Go provides two sizes of floating-point numbers, @c(float32) and
#    @c(float64). Their arithmetic properties are governed by the IEEE 754
#    standard implemented by all modern CPUs.
   Go ofrece dos tamaños de numeros de punto flotante, @c(float32) y
   @c(float64). Sus propiedades aritmeticas se rigen por el estandar IEEE 754
   implementado por todas las CPUs modernas.

#    Values of these numeric types range from tiny to huge. The limits of
#    floating-point values can be found in the @c(math) package. The constant
#    @c(math.MaxFloat32), the largest @c(float32), is about @c(3.4e38), and
#    @c(math.MaxFloat64) is about @c(1.8e308). The smallest positive values are
#    near @c(1.4e-45) and @c(4.9e-324), respectively.
   Los valores de estos tipos numericos varian de pequeño a enorme. Los limites
   de valores de coma flotante se pueden encontrar en el paquete @c(math). La
   constante @c(math.MaxFloat32), el mayor valor de @c(float32), es cerca de
   @c(3.4e38) y @c(math.MaxFloat64) es @c(1.8e308). Los valores positivos mas
   pequeños son @c(1.4e-45) y @c(4.9e-324), respectivamente.

#    A @c(float32) provides approximately six decimal digits of precision, whereas
#    a @c(float64) provides about 15 digits; @c(float64) should be preferred for
#    most purposes because @c(float32) computations accumulate error rapidly
#    unless one is quite careful, and the smallest positive integer that cannot be
#    exactly represented as a @c(float32) is not large:
   Un @c(float32) proporciona aproximadamente seis digitos decimales de
   precision, mientras que un @c(float64) proporciona alrededor de 15 digitos;
   @c(float64) debe ser preferido para la mayoria de los propositos porque los
   calculos sobre @c(float32) acumulan errores rapidamente a menos que sea
   bastante cuidadoso, y el numero entero positivo mas pequeño que no se puede
   representar exactamente como @c(float32) no es grande:

#    ..src > go
#      var f float32 = 16777216 // 1 << 24
#      fmt.Println(f == f+1)    // "true"!
#    < src..
   ..src > go
     var f float32 = 16777216 // 1 << 24
     fmt.Println(f == f+1)    // "true"!
   < src..

#    Floating-point numbers can be written literally using decimals, like this:
   Los numeros de punto flotante se pueden escribir literalmente usando
   decimales, asi:

#    ..src > go
#      const e = 2.71828 // (approximately)
#    < src..
   ..src > go
     const e = 2.71828 // (aproximadamente)
   < src..

#    Digits may be omitted before the decimal point (@c(.707)) or after it
#    (@c(1.)). Very small or very large numbers are better written in scientific
#    notation, with the letter @c(e) or @c(E) preceding the decimal exponent:
   Pueden omitirse los digitos antes del punto decimal (@c(.707)) o despues de
   el (@c(1.)). Es mejor escribir numeros muy pequeños o muy grandes en notacion
   cientifica, con la letra @c(e) o @c(E) precediendo el exponente decimal:

#    ..src > go
#      const Avogadro = 6.02214129e23
#      const Planck   = 6.62606957e-34
#    < src..
   ..src > go
     const Avogadro = 6.02214129e23
     const Planck   = 6.62606957e-34
   < src..

#    Floating-point values are conveniently printed with @c(Printf)’s @c(%g) verb,
#    which chooses the most compact representation that has adequate precision,
#    but for tables of data, the @c(%e) (exponent) or @c(%f) (no exponent) forms
#    may be more appropriate. All three verbs allow field width and numeric
#    precision to be controlled.
   Los Valores de coma flotante se imprimen convenientemente con el verbo @c(%g)
   de @c(Printf), que elige la representacion mas compacta con la precision
   adecuada, pero para las tablas de datos, es mas adecuado el formato @c(%e)
   (exponente) o %f (sin exponente). Los tres verbos permiten controlar el ancho
   del campo y la precision numerica.

#    ..src > go
#      for x := 0; x < 8; x++ {
#        fmt.Printf("x = %d eˣ = %8.3f\n", x, math.Exp(float64(x)))
#      }
#    < src..
   ..src > go
     for x := 0; x < 8; x++ {
       fmt.Printf("x = %d eˣ = %8.3f\n", x, math.Exp(float64(x)))
     }
   < src..

#    The code above prints the powers of @e(e) with three decimal digits of
#    precision, aligned in an eight-character field:
   El codigo anterior imprime las potencias de @e(e) con tres digitos decimales
   de precision, alineados en un campo de ocho caracteres:

#    ..pre >
#      x = 0 eˣ =    1.000
#      x = 1 eˣ =    2.718
#      x = 2 eˣ =    7.389
#      x = 3 eˣ =   20.086
#      x = 4 eˣ =   54.598
#      x = 5 eˣ =  148.413
#      x = 6 eˣ =  403.429
#      x = 7 eˣ = 1096.633
   ..pre >
     x = 0 eˣ =    1.000
     x = 1 eˣ =    2.718
     x = 2 eˣ =    7.389
     x = 3 eˣ =   20.086
     x = 4 eˣ =   54.598
     x = 5 eˣ =  148.413
     x = 6 eˣ =  403.429
     x = 7 eˣ = 1096.633

#    In addition to a large collection of the usual mathematical functions, the
#    @c(math) package has functions for creating and detecting the special values
#    defined by IEEE 754: the positive and negative infinities, which represent
#    numbers of excessive magnitude and the result of division by zero; and NaN
#    (@"(not a number)), the result of such mathematically dubious operations as
#    @c(0/0) or @c[Sqrt(-1)].
   Ademas de una gran coleccion de las funciones matematicas comunes, el paquete
   @c(math) tiene funciones para crear y detectar los valores especiales
   definidas por IEEE 754: los infinitos positivo y negativo, que representan
   los numeros de magnitud excesiva y el resultado de la division por cero; y
   NaN (@"(not a number)), el resultado de operaciones matematicamente dudosas
   como @c(0/0) o @[Sqrt(-1)].

#    ..src > go
#      var z float64
#      fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
#    < src..
   ..src > go
     var z float64
     fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
   < src..

#    The function @c(math.IsNaN) tests whether its argument is a not-a-number
#    value, and @c(math.NaN) returns such a value. It’s tempting to use NaN as a
#    sentinel value in a numeric computation, but testing whether a specific
#    computational result is equal to NaN is fraught with peril because any
#    comparison with NaN @e(always) yields @c(false):
   La funcion @c(math.IsNaN) prueba si su argumento es un valor no-numerico, y
   @c(math.NaN) devuelve ese valor. Es tentador utilizar NaN como un valor
   centinela en un calculo numerico, pero probar si el resultado de un calculo
   especifico es igual NaN esta lleno de peligros, ya que cualquier comparacion
   con NaN @e(siempre) produce @c(false):

#    ..src > go
#      nan := math.NaN()
#      fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
#    < src..
   ..src > go
     nan := math.NaN()
     fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
   < src..

#    If a function that returns a floating-point result might fail, it’s better to
#    report the failure separately, like this:
   Si una funcion que devuelve un resultado de coma flotante puede fallar, es
   mejor informar el error por separado, como aqui:

#    ..src > go
#      func compute() (value float64, ok bool) {
#        // ...
#        if failed {
#          return 0, false
#        }
#        return result, true
#      }
#    < src..
   ..src > go
     func compute() (value float64, ok bool) {
       // ...
       if failed {
         return 0, false
       }
       return result, true
     }
   < src..

#    The next program illustrates floating-point graphics computation. It plots a
#    function of two variables @c[z = f(x, y)] as a wire mesh 3-D surface, using
#    Scalable Vector Graphics (@A(SVG)), a standard @A(XML) notation for line
#    drawings. Figure 3.1 shows an example of its output for the function
#    @c[sin(r)/r], where @c(r) is @c[sqrt(x*x+y*y)].
   El siguiente programa ilustra el calculo de graficos en coma flotante. Se
   traza una funcion de dos variables @c[z = f(x, y)] como una superficie de
   malla de alambre 3-D, utilizando graficos vectoriales escalables (SVG), en
   notacion XML estandar para dibujos lineales. La Figura 3.1 muestra un ejemplo
   de salida de la funcion @c[sin(r)/r], donde @c(r) es @c[sqrt(x*x+y*y)].

#    ..figure > Figure 3.1. A surface plot of the function @c[sin(r)/r].
   ..figure > Figura 3.1. Un grafico superficial de la funcion @c[sin(r)/r].

#      ..img > img/Figure-3.1.jpg
     ..img > img/Figure-3.1.jpg


#    ..figure > @l(gopl.io/ch3/surface/main.go<>gopl.io/ch3/surface)
   ..figure > @l(gopl.io/ch3/surface/main.go<>gopl.io/ch3/surface)

#      ..src > go
#        // Surface computes an SVG rendering of a 3-D surface function.
#        package main
#
#        import (
#          "fmt"
#          "math"
#        )
#
#        const (
#          width, height = 600, 320            // canvas size in pixels
#          cells         = 100                 // number of grid cells
#          xyrange       = 30.0                // axis ranges (-xyrange..+xyrange)
#          xyscale       = width / 2 / xyrange // pixels per x or y unit
#          zscale        = height * 0.4        // pixels per z unit
#          angle         = math.Pi / 6         // angle of x, y axes (=30°)
#        )
#
#        var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)
#
#        func main() {
#          fmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+
#            "style='stroke: grey; fill: white; stroke-width: 0.7' "+
#            "width='%d' height='%d'>", width, height)
#          for i := 0; i < cells; i++ {
#            for j := 0; j < cells; j++ {
#              ax, ay := corner(i+1, j)
#              bx, by := corner(i, j)
#              cx, cy := corner(i, j+1)
#              dx, dy := corner(i+1, j+1)
#              fmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
#                ax, ay, bx, by, cx, cy, dx, dy)
#            }
#          }
#          fmt.Println("</svg>")
#        }
#
#        func corner(i, j int) (float64, float64) {
#          // Find point (x,y) at corner of cell (i,j).
#          x := xyrange * (float64(i)/cells - 0.5)
#          y := xyrange * (float64(j)/cells - 0.5)
#
#          // Compute surface height z.
#          z := f(x, y)
#
#          // Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).
#          sx := width/2 + (x-y)*cos30*xyscale
#          sy := height/2 + (x+y)*sin30*xyscale - z*zscale
#          return sx, sy
#        }
#
#        func f(x, y float64) float64 {
#          r := math.Hypot(x, y) // distance from (0,0)
#          return math.Sin(r) / r
#        }
#      < src..
     ..src > go
       // Surface calcula una representacion SVG de una funcion de superficie 3D
       package main

       import (
         "fmt"
         "math"
       )

       const (
         width, height = 600, 320            // tamaño de la superficie en pixeles
         cells         = 100                 // numero de celdas de la cuadricula
         xyrange       = 30.0                // ejes (-xyrange..+xyrange)
         xyscale       = width / 2 / xyrange // pixeles por unidad x o y
         zscale        = height * 0.4        // pixeles por unidad z
         angle         = math.Pi / 6         // angulo de ejes x, y (=30°)
       )

       var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)

       func main() {
         fmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+
           "style='stroke: grey; fill: white; stroke-width: 0.7' "+
           "width='%d' height='%d'>", width, height)
         for i := 0; i < cells; i++ {
           for j := 0; j < cells; j++ {
             ax, ay := corner(i+1, j)
             bx, by := corner(i, j)
             cx, cy := corner(i, j+1)
             dx, dy := corner(i+1, j+1)
             fmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
               ax, ay, bx, by, cx, cy, dx, dy)
           }
         }
         fmt.Println("</svg>")
       }

       func corner(i, j int) (float64, float64) {
         // Hallar el punto (x,y) en la esquina de la celda (i,j).
         x := xyrange * (float64(i)/cells - 0.5)
         y := xyrange * (float64(j)/cells - 0.5)

         // Calcular la altura de la superficie z.
         z := f(x, y)

         // Proyeccion isometrica (x,y,z) sobre superficie SVG 2-D (sx,sy).
         sx := width/2 + (x-y)*cos30*xyscale
         sy := height/2 + (x+y)*sin30*xyscale - z*zscale
         return sx, sy
       }

       func f(x, y float64) float64 {
         r := math.Hypot(x, y) // distancia de (0,0)
         return math.Sin(r) / r
       }
     < src..


#    Notice that the function corner returns two values, the coordinates of the
#    corner of the cell.
   Observe que la esquina de funcion devuelve dos valores, las coordenadas de la
   esquina de la celda.

#    The explanation of how the program works requires only basic geometry, but
#    it’s fine to skip over it, since the point is to illustrate floating-point
#    computation. The essence of the program is mapping between three different
#    coordinate systems, shown in Figure 3.2. The first is a 2-D grid of 100&100
#    cells identified by integer coordinates @m[(i, j)], starting at @m[(0, 0)] in
#    the far back corner. We plot from the back to the front so that background
#    polygons may be obscured by foreground ones.
   La explicacion de como funciona el programa requiere solo geometria basica,
   pero esta bien pasarla por alto, ya que el punto es ilustrar la computacion
   de punto flotante. La esencia del programa es el mapeo entre tres sistemas de
   coordenadas diferentes, como se muestra en la Figura 3.2. La primera es una
   red de 2D de 100 y 100 celdas identificadas por coordenadas enteras @m[(i,
   j)], a partir de @m[(0, 0)] en la esquina mas lejanas. Trazamos desde la
   parte posterior al frente de modo que los poligonos del fondo puedan ser
   oscurecidos por los primeros.

#    The second coordinate system is a mesh of 3-D floating-point coordinates
#    @m[(x, y, z)], where @m(x) and @m(y) are linear functions of @m(i) and @m(j),
#    translated so that the origin is in the center, and scaled by the constant
#    @c(xyrange). The height @m(z) is the value of the surface function @m[ƒ(x,
#    y)].
   El segundo sistema de coordenadas es una malla de coordenadas 3-D de punto
   flotante @m[(x, y, z)], donde @m(x) e @m(y) son funciones lineales de @m(i) y
   @m(j), traducido de manera que el origen esta en el centro, y escalado por la
   constante @c(xyrange). La altura @m(z) es el valor de la funcion de
   superficie @m[ƒ(x, y)].

#    The third coordinate system is the 2-D image canvas, with @m[(0, 0)] in the
#    top left corner. Points in this plane are denoted @m[(sx, sy)]. We use an
#    isometric projection to map each 3-D point
   El tercer sistema de coordenadas es la superficie 2-D de la imagen, con
   @m[(0, 0)] en la esquina superior izquierda. Los puntos en este plano se
   denotan @m[(sx, sy)]. Utilizamos una proyeccion isometrica para correlacionar
   cada punto 3D

#    ..figure > Figure 3.2. Three different coordinate systems.
   ..figure > Figura 3.2. Tres sistemas de coordenadas diferentes.

#      ..img > img/Figure-3.2.jpg
     ..img > img/Figure-3.2.jpg


#    @m[(x, y, z)] onto the 2-D canvas. A point appears farther to the right on
#    the canvas the greater its @m(x) value or the @e(smaller) its @m(y)
#    value. And a point appears farther down the canvas the greater its @m(x)
#    value or @m(y) value, and the smaller its @m(z) value. The vertical and
#    horizontal scale factors for @m(x) and @m(y) are derived from the sine and
#    cosine of a 30° angle. The scale factor for @m(z), 0.4, is an arbitrary
#    parameter.
   @m[(x, y, z)] sobre la superficie 2-D. Un punto aparece mas a la derecha en
   la superficie cuanto mayor sera su valor @m(x) o menor sea su valor @m(y). Y
   un punto aparece mas abajo en la superficie cuanto mayor sera su valor @m(x)
   o el valor @m(y), y cuanto menor sea su valor @m(z). Los factores de escala
   horizontal o vertical para @m(x) e @m(y) se derivan del seno y coseno de un
   angulo de 30°. El factor de escala para @m(z), 0.4, es un parametro
   arbitrario.

#    For each cell in the 2-D grid, the main function computes the coordinates on
#    the image canvas of the four corners of the polygon ABCD, where B corresponds
#    to @m[(i, j)] and A, C, and D are its neighbors, then prints an SVG
#    instruction to draw it.
   Para cada celda de la cuadricula 2-D, la funcion principal calcula las
   coordenadas en la superficie de imagen de las cuatro esquinas del poligono
   ABCD, donde B corresponde a @m[(i, j)] y A, C, y D son sus vecinos, entonces
   imprime una instruccion SVG para dibujarla.

#    @b(Exercise 3.1): If the function @c(f) returns a non-finite @c(float64)
#    value, the SVG file will contain invalid @c(<polygon>) elements (although
#    many SVG renderers handle this gracefully). Modify the program to skip
#    invalid polygons.
   @b(Ejercicio 3.1): Si la funcion @c(f) devuelve un valor @c(float64)
   no-finito, el archivo SVG contendra elementos @c(<polygon>) no validos
   (aunque muchos procesadores SVG manejan esto con gracia). Modifique el
   programa para omitir poligonos no validos.

#    @b(Exercise 3.2): Experiment with visualizations of other functions from the
#    @c(math) package. Can you produce an egg box, moguls, or a saddle?
   @b(Ejercicio 3.2): Experimente con visualizaciones de otras funciones del
   paquete @c(math). ¿Puede usted producir una caja de huevos, moguls, o una
   montura?

#    @b(Exercise 3.3): Color each polygon based on its height, so that the peaks
#    are colored red (@c(#ff0000)) and the valleys blue (@c(#0000ff)).
   @b(Ejercicio 3.3): El color de cada poligono en funcion de su altura, por lo
   que los picos son de color rojo (@c(#ff0000)) y los valles azul
   (@c(#0000ff)).

#    @b(Exercise 3.4): Following the approach of the Lissajous example in
#    @l(#Section 1.7), construct a web server that computes surfaces and writes
#    SVG data to the client. The server must set the @c(Content-Type) header like
#    this:
   @b(Ejercicio 3.4): Siguiendo el enfoque del ejemplo Lissajous en la
   @l(#Seccion 1.7), construya un servidor web que calcule superficies y escriba
   los datos SVG al cliente. El servidor debe establecer el manejador
   @c(Content-Type) asi:

#    ..src > go
#      w.Header().Set("Content-Type", "image/svg+xml")
#    < src..
   ..src > go
     w.Header().Set("Content-Type", "image/svg+xml")
   < src..

#    (This step was not required in the Lissajous example because the server uses
#    standard heuristics to recognize common formats like PNG from the first 512
#    bytes of the response and generates the proper header.) Allow the client to
#    specify values like height, width, and color as HTTP request parameters.
   (Este paso no era necesario en el ejemplo de Lissajous porque el servidor
   utiliza la heuristica estandar para reconocer formatos comunes como PNG de
   los primeros 512 bytes de la respuesta y generar el encabezado
   adecuado). Permitir al cliente especificar valores como altura, ancho y color
   como parametros de peticion HTTP.

# ** Section 3.3 <> Complex Numbers
** Seccion 3.3 <> Numeros complejos

#    Go provides two sizes of complex numbers, @c(complex64) and @c(complex128),
#    whose components are @c(float32) and @c(float64) respectively. The built-in
#    function @c(complex) creates a complex number from its real and imaginary
#    components, and the built-in @c(real) and @c(imag) functions extract those
#    components:
   Go proporciona dos tamaños de numeros complejos, @c(complex64) y
   @c(complex128), cuyos componentes son @c(float32) y @c(float64)
   respectivamente. La funcion nativa @c(complex) crea un numero complejo a
   partir de sus componentes real e imaginario, e incorpora funciones @c(real) y
   @c(imag) para extraer estos componentes:

#    ..src > go
#      var x complex128 = complex(1, 2) // 1+2i
#      var y complex128 = complex(3, 4) // 3+4i
#      fmt.Println(x*y)                 // "(-5+10i)"
#      fmt.Println(real(x*y))           // "-5"
#      fmt.Println(imag(x*y))           // "10"
#    < src..
   ..src > go
     var x complex128 = complex(1, 2) // 1+2i
     var y complex128 = complex(3, 4) // 3+4i
     fmt.Println(x*y)                 // "(-5+10i)"
     fmt.Println(real(x*y))           // "-5"
     fmt.Println(imag(x*y))           // "10"
   < src..

#    If a floating-point literal or decimal integer literal is immediately
#    followed by @c(i), such as @c(3.141592i) or @c(2i), it becomes an
#    @e(imaginary literal), denoting a complex number with a zero real
#    component:
   Si un punto flotante literal entero o decimal literal es seguido
   inmediatamente por @c(i), como @c(3.141592i) o @c(2i), se convierte en un
   literal imaginario, que denota un numero complejo con un componente real
   cero:

#    ..src > go
#      fmt.Println(1i * 1i) // "(-1+0i)", i² = -1
#    < src..
   ..src > go
     fmt.Println(1i * 1i) // "(-1+0i)", i² = -1
   < src..

#    Under the rules for constant arithmetic, complex constants can be added to
#    other constants (integer or floating point, real or imaginary), allowing us
#    to write complex numbers naturally, like @c(1+2i), or equivalently,
#    @c(2i+1). The declarations of @c(x) and @c(y) above can be simplified:
   Bajo las reglas de la aritmetica constante, constantes complejas se pueden
   añadir a otras constantes (enteras o de coma flotante, real o imaginarias),
   lo que nos permite escribir numeros complejos de forma natural, como
   @c(1+2i), o equivalentemente, @c(2i+1) . Las anteriores declaraciones @c(x) y
   @c(y) se pueden simplificar:

#    ..src > go
#      x := 1 + 2i
#      y := 3 + 4i
#    < src..
   ..src > go
     x := 1 + 2i
     y := 3 + 4i
   < src..

#    Complex numbers may be compared for equality with @c(==) and @c(!=). Two
#    complex numbers are equal if their real parts are equal and their imaginary
#    parts are equal.
   Los numeros complejos se pueden comparar por igualdad con @c(==) y
   @c(!=). Dos numeros complejos son iguales si sus partes reales son iguales y
   sus partes imaginarias son iguales.

#    The @c(math/cmplx) package provides library functions for working with
#    complex numbers, such as the complex square root and exponentiation
#    functions.
   El paquete @c(math/cmplx) proporciona funciones de libreria para trabajar con
   numeros complejos, tales como las raiz cuadrada compleja y las funciones de
   exponenciacion.

#    ..src > go
#      fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"
#    < src..
   ..src > go
     fmt.Println(cmplx.Sqrt(-1)) // "(0+1i)"
   < src..

#    The following program uses @c(complex128) arithmetic to generate a Mandelbrot
#    set.
   El siguiente programa utiliza aritmetica @c(complex128) para generar un
   conjunto de Mandelbrot.

#    ..figure > @l(gopl.io/ch3/mandelbrot/main.go<>gopl.io/ch3/mandelbrot)
   ..figure > @l(gopl.io/ch3/mandelbrot/main.go<>gopl.io/ch3/mandelbrot)

#      ..src > go
#        // Mandelbrot emits a PNG image of the Mandelbrot fractal.
#        package main
#
#        import (
#          "image"
#          "image/color"
#          "image/png"
#          "math/cmplx"
#          "os"
#        )
#
#        func main() {
#          const (
#            xmin, ymin, xmax, ymax = -2, -2, +2, +2
#            width, height          = 1024, 1024
#          )
#
#          img := image.NewRGBA(image.Rect(0, 0, width, height))
#          for py := 0; py < height; py++ {
#            y := float64(py)/height*(ymax-ymin) + ymin
#            for px := 0; px < width; px++ {
#              x := float64(px)/width*(xmax-xmin) + xmin
#              z := complex(x, y)
#              // Image point (px, py) represents complex value z.
#              img.Set(px, py, mandelbrot(z))
#            }
#          }
#          png.Encode(os.Stdout, img) // NOTE: ignoring errors
#        }
#
#        func mandelbrot(z complex128) color.Color {
#          const iterations = 200
#          const contrast = 15
#
#          var v complex128
#          for n := uint8(0); n < iterations; n++ {
#            v = v*v + z
#            if cmplx.Abs(v) > 2 {
#              return color.Gray{255 - contrast*n}
#            }
#          }
#          return color.Black
#        }
#      < src..
     ..src > go
       // Mandelbrot emite una imagen PNG del fractal de Mandelbrot.
       package main

       import (
         "image"
         "image/color"
         "image/png"
         "math/cmplx"
         "os"
       )

       func main() {
         const (
           xmin, ymin, xmax, ymax = -2, -2, +2, +2
           width, height          = 1024, 1024
         )

         img := image.NewRGBA(image.Rect(0, 0, width, height))
         for py := 0; py < height; py++ {
           y := float64(py)/height*(ymax-ymin) + ymin
           for px := 0; px < width; px++ {
             x := float64(px)/width*(xmax-xmin) + xmin
             z := complex(x, y)
             // El punto de imagen (px, py) representa el valor complejo z.
             img.Set(px, py, mandelbrot(z))
           }
         }
         png.Encode(os.Stdout, img) // NOTA: ignorando errores
       }

       func mandelbrot(z complex128) color.Color {
         const iterations = 200
         const contrast = 15

         var v complex128
         for n := uint8(0); n < iterations; n++ {
           v = v*v + z
           if cmplx.Abs(v) > 2 {
             return color.Gray{255 - contrast*n}
           }
         }
         return color.Black
       }
     < src..


#    The two nested loops iterate over each point in a 1024x1024 grayscale raster
#    image representing the -2 to +2 portion of the complex plane. The program
#    tests whether repeatedly squaring and adding the number that point represents
#    eventually @"(escapes) the circle of radius 2. If so, the point is shaded by
#    the number of iterations it took to escape. If not, the value belongs to the
#    Mandelbrot set, and the point remains black. Finally, the program writes to
#    its standard output the PNG-encoded image of the iconic fractal, shown in
#    Figure 3.3.
   Los dos bucles anidados iteran sobre cada punto en una imagen en cuadricula
   de escala de grises de 1024x1024 que representa la porcion de -2 a +2 del
   plano complejo. El programa prueba si repetidamente cuadrando y añadiendo el
   numero del punto representado eventualmente @"(escapa) el circulo de
   radio 2. Si es asi, el punto es sombreado por el numero de iteraciones que se
   tardo en escapar. Si no, el valor pertenece al conjunto de Mandelbrot, y el
   punto permanece negro. Finalmente, el programa escribe en su salida estandar
   la imagen codificada en PNG del iconico fractal, que se muestra en la Figura
   3.3.

#    ..figure > Figure 3.3. The Mandelbrot set.
   ..figure > Figura 3.3. El conjunto de Mandelbrot.

#      ..img > img/Figure-3.3.jpg
     ..img > img/Figure-3.3.jpg


#    @b(Exercise 3.5): Implement a full-color Mandelbrot set using the function
#    @c(image.NewRGBA) and the type @c(color.RGBA) or @c(color.YCbCr).
   @b(Ejercicio 3.5): Implementar a todo color el cojunto de Mandelbrot usando
   la funcion @c(image.NewRGBA) y el tipo @c(color.RGBA) o @c(color.YCbCr).

#    @b(Exercise 3.6): Supersampling is a technique to reduce the effect of
#    pixelation by computing the color value at several points within each pixel
#    and taking the average. The simplest method is to divide each pixel into four
#    @"(subpixels.) Implement it.
   @b(Ejercicio 3.6): Supermuestreo es una tecnica para reducir el efecto de
   pixelacion calculando el valor del color en varios puntos dentro de cada
   pixel y tomando el promedio. El metodo mas simple consiste en dividir cada
   pixel en cuatro @"(subpixeles.) Implementalo.

#    @b(Exercise 3.7): Another simple fractal uses Newton’s method to find complex
#    solutions to a function such as @m(z⁴-1 = 0). Shade each starting point by
#    the number of iterations required to get close to one of the four
#    roots. Color each point by the root it approaches.
   @b(Ejercicio 3.7): Otro fractal sencillo utiliza el metodo Newton para
   encontrar soluciones complejas a una funcion como @m(z⁴-1 = 0). Sombrea cada
   punto de partida por el numero de iteraciones necesarias para acercarse a una
   de las cuatro raices. Colorea cada punto por la raiz que se aproxima.

#    @b(Exercise 3.8): Rendering fractals at high zoom levels demands great
#    arithmetic precision. Implement the same fractal using four different
#    representations of numbers: @c(complex64), @c(complex128), @c(big.Float), and
#    @c(big.Rat). (The latter two types are found in the @c(math/big) package.
#    @c(Float) uses arbitrary but bounded-precision floating-point; @c(Rat) uses
#    unbounded-precision rational numbers.) How do they compare in performance and
#    memory usage? At what zoom levels do rendering artifacts become visible?
   @b(Ejercicio 3.8): La Representacion de fractales con altos niveles de zoom
   exige una gran precision aritmetica. Implementa el mismo fractal utilizando
   cuatro representaciones diferentes de numeros: @c(complex64), @c(complex128),
   @c(big.Float), y @c(big.Rat). (Los ultimos dos tipos se encuentran en el
   paquete @c(math/big). @c(Float) utiliza arbitraria, pero delimitada precision
   de punto flotante; @c(Rat) utiliza numeros racionales sin limites de
   precision.)  ¿Como se comparan en el rendimiento y uso de memoria? ¿A que
   niveles de zoom se hacen visibles los artefactos de renderizacion?

#    @b(Exercise 3.9): Write a web server that renders fractals and writes the
#    image data to the client.  Allow the client to specify the @m(x), @m(y), and
#    zoom values as parameters to the HTTP request.
   @b(Ejercicio 3.9): Escriba un servidor web que procese fractales y escribe
   los datos de imagen al cliente. Permita que el cliente especifique las
   coordenadas @c(x), @c(y), y los valores de zoom como parametros en la
   peticion HTTP.

# ** Section 3.4 <> Booleans
** Seccion 3.4 <> Booleanos

#    A value of type @c(bool), or @e(boolean), has only two possible values,
#    @c(true) and @c(false). The conditions in @c(if) and @c(for) statements are
#    booleans, and comparison operators like @c(==) and @c(<) produce a boolean
#    result. The unary operator @c(!) is logical negation, so @c(!true) is
#    @c(false), or, one might say, @c[(!true==false)==true], although as a matter
#    of style, we always simplify redundant boolean expressions like @c(x==true)
#    to @c(x).
   Un valor de tipo @c(bool), o @e(booleano), tiene solo dos valores posibles,
   @c(true) y @c(false). Las condiciones en @c(if) y @c(for) son declaraciones
   booleanas, y los operadores de comparacion como @c(==) y @c(<) producen un
   resultado booleano. El operador unario @c(!) es la negacion logica, de modo
   que @c(!true) es @c(false), o, por decirlo asi, @c[(!true==false)==true],
   aunque por cuestion de estilo, siempre simplificamos las expresiones
   booleanas redundantes como @c(x==true) a @c(x).

#    Boolean values can be combined with the @c(&&) (AND) and @c(||) (OR)
#    operators, which have @e(shortcircuit) behavior: if the answer is already
#    determined by the value of the left operand, the right operand is not
#    evaluated, making it safe to write expressions like this:
   Los valores booleanos pueden ser combinados con los operadores @c(&&) (AND) y
   @c(||) (OR), que tienen un comportamiento de @e(cortocircuito): si la
   respuesta ya esta determinada por el valor del operando de la izquierda, el
   operando de la derecha no se evalua, por lo que es seguro para escribir
   expresiones como esta:

#    ..src > go
#      s != "" && s[0] == 'x'
#    < src..
   ..src > go
     s != "" && s[0] == 'x'
   < src..

#    where @c(s[0]) would panic if applied to an empty string.
   donde @c(s[0]) produciria un panico si se aplica a una cadena vacia.

#    Since @c(&&) has higher precedence than @c(||) (mnemonic: @c(&&) is boolean
#    multiplication, @c(||) is boolean addition), no parentheses are required for
#    conditions of this form:
   Ya que @c(&&) tiene mayor precedencia que @c(||) (mnemonico: @c(&&) es la
   multiplicacion booleana, @c(||) es la adicion boolean), no se requieren
   parentesis para las condiciones de esta forma:

#    ..src > go
#      if 'a' <= c && c <= 'z' ||
#        'A' <= c && c <= 'Z' ||
#        '0' <= c && c <= '9' {
#        // ...ASCII letter or digit...
#      }
#    < src..
   ..src > go
     if 'a' <= c && c <= 'z' ||
       'A' <= c && c <= 'Z' ||
       '0' <= c && c <= '9' {
       // ...letra o digito ASCII...
     }
   < src..

#    There is no implicit conversion from a boolean value to a numeric value like
#    0 or 1, or vice versa. It’s necessary to use an explicit @c(if), as in
   No hay una conversion implicita de un valor booleano a un valor numerico como
   0 o 1, o viceversa. Es necesario utilizar un @c(if) explicito, como en

#    ..src > go
#      i := 0
#      if b {
#        i = 1
#      }
#    < src..
   ..src > go
     i := 0
     if b {
       i = 1
     }
   < src..

#    It might be worth writing a conversion function if this operation were needed often:
   Podria valer la pena escribir una funcion de conversion si esta operacion se
   necesita a menudo:

#    ..src > go
#      // btoi returns 1 if b is true and 0 if false.
#      func btoi(b bool) int {
#        if b {
#          return 1
#        }
#        return 0
#      }
#    < src..
   ..src > go
     // btoi regresa 1 si b es verdadero y 0 sy es falso.
     func btoi(b bool) int {
       if b {
         return 1
       }
       return 0
     }
   < src..

#    The inverse operation is so simple that it doesn’t warrant a function, but
#    for symmetry here it is:
   La operacion inversa es tan simple que no necesita una funcion, pero por
   simetria aqui esta:

#    ..src > go
#      // itob reports whether i is non-zero.
#      func itob(i int) bool { return i != 0 }
#    < src..
   ..src > go
     // itob reporta cuando i no es cero.
     func itob(i int) bool { return i != 0 }
   < src..

# ** Section 3.5 <> Strings
** Seccion 3.5 <> Cadenas

#    A string is an immutable sequence of bytes. Strings may contain arbitrary
#    data, including bytes with value 0, but usually they contain human-readable
#    text. Text strings are conventionally interpreted as UTF-8-encoded sequences
#    of Unicode code points (runes), which we’ll explore in detail very soon.
   Una cadena es una secuencia inmutable de bytes. Las cadenas pueden contener
   datos arbitrarios, incluyendo bytes con valor 0, pero normalmente contienen
   texto legible por humanos. Las cadenas de texto se interpretan de forma
   convencional como secuencias codificadas en UTF-8 de puntos de codigo Unicode
   (runas), que exploraremos en detalle muy pronto.

#    The built-in @c(len) function returns the number of bytes (not runes) in a
#    string, and the @e(index) operation @c(s[i]) retrieves the @m(i)-th byte of
#    string @c(s), where @c(0) ≤ @c(i) < @c[len(s)].
   La funcion nativa @c(len) devuelve el numero de bytes (no runas) en una
   cadena, y la operacion de indice @c(s[i]) recupera el @m(n)-esimo byte de la
   cadena @c(s), donde @c(0) ≤ @c(i) < @c[len(s)].

#    ..src > go
#      s := "hello, world"
#      fmt.Println(len(s))     // "12"
#      fmt.Println(s[0], s[7]) // "104 119"  ('h' and 'w')
#    < src..
   ..src > go
     s := "hello, world"
     fmt.Println(len(s))     // "12"
     fmt.Println(s[0], s[7]) // "104 119"  ('h' and 'w')
   < src..

#    Attempting to access a byte outside this range results in a panic:
   Intentar acceder a un byte fuera de este rango produce un panico:

#    ..src > go
#      c := s[len(s)] // panic: index out of range
#    < src..
   ..src > go
     c := s[len(s)] // panico: indice fuera de rango
   < src..

#    The @m(i)-th byte of a string is not necessarily the @m(i)-th @e(character)
#    of a string, because the UTF-8 encoding of a non-ASCII code point requires
#    two or more bytes. Working with characters is discussed shortly.
   El @m(n)-esimo byte de una cadena no es necesariamente el @m(n)-esimo
   caracter de una cadena, porque la codificacion UTF-8 de un punto de codigo no
   ASCII requiere dos o mas bytes. Como Trabajar con caracteres se discutira en
   breve.

#    The @e(substring) operation @c(s[i:j]) yields a new string consisting of the
#    bytes of the original string starting at index @c(i) and continuing up to,
#    but not including, the byte at index @c(j). The result contains @c(j-i)
#    bytes.
   La operacion de subcadena @c(s[i:j]) produce una nueva cadena que consta de
   los bytes de la cadena original a partir del indice @c(i) y continua hasta,
   pero no incluyendo, el byte en el indice @c(j). El resultado contiene @c(j-i)
   bytes.

#    ..src > go
#      fmt.Println(s[0:5]) // "hello"
#    < src..
   ..src > go
     fmt.Println(s[0:5]) // "hello"
   < src..

#    Again, a panic results if either index is out of bounds or if @c(j) is less
#    than @c(i).
   De nuevo, se produce un panico si cualquiera de los indices esta fuera de
   limite o si @c(j) es menor que @c(i).

#    Either or both of the @c(i) and @c(j) operands may be omitted, in which case the
#    default values of 0 (the start of the string) and @c[len(s)] (its end) are
#    assumed, respectively.
   Cualquiera o ambos operandos @c(i) y @c(j) pueden omitirse, en cuyo caso los
   valores por defecto son 0 (el inicio de la cadena) y @c[len(s)] (su final),
   respectivamente.

#    ..src > go
#      fmt.Println(s[:5]) // "hello"
#      fmt.Println(s[7:]) // "world"
#      fmt.Println(s[:])  // "hello, world"
#    < src..
   ..src > go
     fmt.Println(s[:5]) // "hello"
     fmt.Println(s[7:]) // "world"
     fmt.Println(s[:])  // "hello, world"
   < src..

#    The @c(+) operator makes a new string by concatenating two strings:
   El operador c(+) crea una nueva cadena mediante la concatenacion de dos
   cadenas:

#    ..src > go
#      fmt.Println("goodbye" + s[5:]) // "goodbye, world"
#    < src..
   ..src > go
     fmt.Println("goodbye" + s[5:]) // "goodbye, world"
   < src..

#    Strings may be compared with comparison operators like @c(==) and @c(<); the
#    comparison is done byte by byte, so the result is the natural lexicographic
#    ordering.
   Las cadenas pueden compararse con los operadores de comparacion como @c(==) y
   @c(<); La comparacion se realiza byte a byte, por lo que el resultado es el
   orden lexicografico natural.

#    String values are immutable: the byte sequence contained in a string value
#    can never be changed, though of course we can assign a new value to a string
#    @e(variable). To append one string to another, for instance, we can write
   Los valores de cadena son inmutables: la secuencia de bytes contenidos en un
   valor de cadena no se puede cambiar, aunque, por supuesto, podemos asignar un
   nuevo valor a una variable de cadena. Para añadir una cadena a otra, por
   ejemplo, podemos escribir

#    ..src > go
#      s := "left foot"
#      t := s
#      s += ", right foot"
#    < src..
   ..src > go
     s := "left foot"
     t := s
     s += ", right foot"
   < src..

#    This does not modify the string that @c(s) originally held but causes @c(s)
#    to hold the new string formed by the @c(+=) statement; meanwhile, @c(t) still
#    contains the old string.
   Esto no modifica la cadena que retenia @c(s) originalmente, pero hace que
   @c(s) contenga la nueva cadena formada por la sentencia @c(+=); Mientras
   tanto, @c(t) aun contiene la cadena antigua.

#    ..src > go
#      fmt.Println(s) // "left foot, right foot"
#      fmt.Println(t) // "left foot"
#    < src..
   ..src > go
     fmt.Println(s) // "left foot, right foot"
     fmt.Println(t) // "left foot"
   < src..

#    Since strings are immutable, constructions that try to modify a string’s data
#    in place are not allowed:
   Dado que las cadenas son inmutables, no se permiten las construcciones que
   intentan modificar los datos de una cadena en su lugar:

#    ..src > go
#      s[0] = 'L' // compile error: cannot assign to s[0]
#    < src..
   ..src > go
     s[0] = 'L' // error de compilacion: no se puede asignar a s[0]
   < src..

#    Immutability means that it is safe for two copies of a string to share the
#    same underlying memory, making it cheap to copy strings of any length.
#    Similarly, a string @c(s) and a substring like @c(s[7:]) may safely share the
#    same data, so the substring operation is also cheap. No new memory is
#    allocated in either case. Figure 3.4 illustrates the arrangement of a string
#    and two of its substrings sharing the same underlying byte array.
   Inmutabilidad significa que es seguro que dos copias de una cadena compartan
   la misma memoria subyacente, por lo que es barato copiar cadenas de cualquier
   longitud. Del mismo modo, una cadena @c(s) y una subcadena como @c(s[7:])
   pueden compartir de forma segura los mismos datos, por lo que la operacion
   subcadena tambien es barata. No se asigna ninguna memoria nueva en ningun
   caso. La Figura 3.4 ilustra la disposicion de una cadena y dos de sus
   subcadenas que comparten el mismo arreglo de bytes subyacente.

#    ..figure > Figure 3.4. The string @c("hello, world") and two substrings.
   ..figure > Figura 3.4. La cadena @c("hello, world") y dos subcadenas.

#      ..img > img/Figure-3.4.jpg
     ..img > img/Figure-3.4.jpg

# *** Section 3.5.1 <> String Literals
*** Seccion 3.5.1 <> Cadenas Literales

#     A string value can be written as a @e(string literal), a sequence of bytes
#     enclosed in double quotes:
    Un valor de cadena se puede escribir como una @e(cadena literal), una
    secuencia de bytes entre comillas dobles:

#     ..src > go
#       "Hello, 世界"
#     < src..
    ..src > go
      "Hello, 世界"
    < src..

#     Because Go source files are always encoded in UTF-8 and Go text strings are
#     conventionally interpreted as UTF-8, we can include Unicode code points in
#     string literals.
    Debido a que los archivos fuente de Go siempre estan codificados en UTF-8 y
    las cadenas de texto Go son interpretadas convencionalmente como UTF-8,
    podemos incluir puntos de codigo Unicode en literales de cadena.

#     Within a double-quoted string literal, @e(escape sequences) that begin with
#     a backslash @c(\) can be used to insert arbitrary byte values into the
#     string. One set of escapes handles ASCII control codes like newline,
#     carriage return, and tab:
    Dentro de una literal de cadena entre comillas dobles, las secuencias de
    escape que comienzan con una barra invertida @c(\) se pueden utilizar para
    insertar valores arbitrarios de bytes en la cadena. Un conjunto de escape
    maneja codigos de control ASCII como newline, retorno de carro y tabulacion:

#     | @c(\a) | @"(alert) or bell                            |
#     |--------|----------------------------------------------|
#     | @c(\b) | backspace                                    |
#     |--------|----------------------------------------------|
#     | @c(\f) | form feed                                    |
#     |--------|----------------------------------------------|
#     | @c(\n) | newline                                      |
#     |--------|----------------------------------------------|
#     | @c(\r) | carriage return                              |
#     |--------|----------------------------------------------|
#     | @c(\t) | tab                                          |
#     |--------|----------------------------------------------|
#     | @c(\v) | vertical tab                                 |
#     |--------|----------------------------------------------|
#     | @c(\') | single quote (only in the rune literal '\'') |
#     |--------|----------------------------------------------|
#     | @c(\") | double quote (only within "..." literals)    |
#     |--------|----------------------------------------------|
#     | @c(\\) | backslash                                    |
    | @c(\a) | @"(alerta) o  campana                            |
    |--------|--------------------------------------------------|
    | @c(\b) | retroceso                                        |
    |--------|--------------------------------------------------|
    | @c(\f) | form feed                                        |
    |--------|--------------------------------------------------|
    | @c(\n) | linea nueva                                      |
    |--------|--------------------------------------------------|
    | @c(\r) | retorno de carro                                 |
    |--------|--------------------------------------------------|
    | @c(\t) | tabulador                                        |
    |--------|--------------------------------------------------|
    | @c(\v) | tabulador vertical                               |
    |--------|--------------------------------------------------|
    | @c(\') | comilla simple (solo en la runa literal '\'')    |
    |--------|--------------------------------------------------|
    | @c(\") | comillas dobles (solo dentro de "..." literales) |
    |--------|--------------------------------------------------|
    | @c(\\) | barra invertida                                  |

#     Arbitrary bytes can also be included in literal strings using hexadecimal or
#     octal escapes. A @e(hexadecimal) escape is written @c(\x)@e(hh), with exactly
#     two hexadecimal digits @e(h) (in upper or lower case). An octal escape is
#     written @e(\ooo) with exactly three octal digits @e(o) (0 through 7) not
#     exceeding @e(\377). Both denote a single byte with the specified
#     value. Later, we’ll see how to encode Unicode code points numerically in
#     string literals.
    Los bytes arbitrarios tambien se pueden incluir en cadenas literales usando
    escapes hexadecimales u octales. Un escape hexadecimal se escribe
    @c(\x)@e(hh), con exactamente dos digitos hexadecimales @e(h) (en mayusculas
    o minusculas). Un escape octal se escribe @e(\ooo) con exactamente tres
    digitos octales @e(o) (0 a 7) no superior a @c(\377). Ambos denotan un solo
    byte con el valor especificado. Mas adelante, veremos como codificar
    numericamente los puntos de codigo Unicode en literales de cadena.

#     A @e(raw string literal) is written @c(`...`), using backquotes instead of
#     double quotes. Within a raw string literal, no escape sequences are
#     processed; the contents are taken literally, including backslashes and
#     newlines, so a raw string literal may spread over several lines in the
#     program source. The only processing is that carriage returns are deleted so
#     that the value of the string is the same on all platforms, including those
#     that conventionally put carriage returns in text files.
    Una @e(literal de cadena sin formato) se escribe @c(`...`), utilizando
    comillas inversas en lugar de comillas dobles. Dentro de una literal de
    cadena sin formato, no se procesan secuencias de escape; Los contenidos se
    toman literalmente, incluyendo barras invertidas y lineas nuevas, por lo que
    un literal de cadena sin formato puede extenderse por varias lineas en el
    codigo del programa. El unico procesamiento es que los retornos de carro se
    eliminan para que el valor de la cadena sea el mismo en todas las
    plataformas, incluidas aquellas que convencionalmente ponen retornos de
    carro en archivos de texto.

#     Raw string literals are a convenient way to write regular expressions, which
#     tend to have lots of backslashes. They are also useful for HTML templates,
#     JSON literals, command usage messages, and the like, which often extend over
#     multiple lines.
    Las literales de cadenas sin formato son una manera conveniente de escribir
    expresiones regulares, que tienden a tener un monton de barras
    inversas. Tambien son utiles para plantillas HTML, literales JSON, mensajes
    de uso de comandos y similares, que a menudo se extienden sobre varias
    lineas.

#     ..src > go
#       const GoUsage = `Go is a tool for managing Go source code.
#
#       Usage:
#           go command [arguments]
#       ...`
#     < src..
    ..src > go
      const GoUsage = `Go is a tool for managing Go source code.

      Usage:
          go command [arguments]
      ...`
    < src..

# *** Section 3.5.2 <> Unicode
*** Seccion 3.5.2 <> Unicode

#     Long ago, life was simple and there was, at least in a parochial view, only
#     one character set to deal with: ASCII, the American Standard Code for
#     Information Interchange. ASCII, or more precisely US-ASCII, uses 7 bits to
#     represent 128 @"(characters): the upper- and lower-case letters of English,
#     digits, and a variety of punctuation and device-control characters. For much
#     of the early days of computing, this was adequate, but it left a very large
#     fraction of the world’s population unable to use their own writing systems
#     in computers. With the growth of the Internet, data in myriad languages has
#     become much more common. How can this rich variety be dealt with at all and,
#     if possible, efficiently?
    Hace mucho tiempo, la vida era simple y habia, por lo menos un punto de
    vista parroquial, solo un conjunto de caracteres a manejar: ASCII, el codigo
    estandar americano para el intercambio de la informacion (@e(American
    Standard Code for Information Interchange)). ASCII, o mas precisamente
    US-ASCII, utiliza 7 bits para representar 128 @"(caracteres): las letras
    mayusculas y minusculas del ingles, digitos y una variedad de caracteres de
    puntuacion y control de dispositivo. Durante gran parte de los primeros dias
    de la informatica, esto fue adecuado, pero dejo a una gran parte de la
    poblacion mundial incapaz de utilizar sus propios sistemas de escritura en
    las computadoras. Con el crecimiento de Internet, los datos en innumerables
    idiomas se han vuelto mucho mas comunes. ¿Como puede manejarse esta rica
    variedad y, si es posible, de forma eficiente?

#     The answer is Unicode (@l(http://unicode.org/<>unicode.org)), which collects
#     all of the characters in all of the world’s writing systems, plus accents
#     and other diacritical marks, control codes like tab and carriage return, and
#     plenty of esoterica, and assigns each one a standard number called a
#     @e(Unicode code point) or, in Go terminology, a @c(rune).
    La respuesta es Unicode (@l(http://unicode.org/<>unicode.org)), que recoge
    todos los caracteres de todos los sistemas de escritura del mundo, ademas de
    acentos y otros signos diacriticos, codigos de control como tabulador y
    retorno de carro, y plenty of esoterica, y asigna a cada uno un numero
    estandar denominado @e(punto de codigo Unicode) o, en la terminologia Go,
    una runa.

#     Unicode version 8 defines code points for over 120,000 characters in well
#     over 100 languages and scripts. How are these represented in computer
#     programs and data? The natural data type to hold a single rune is @c(int32),
#     and that’s what Go uses; it has the synonym @c(rune) for precisely this
#     purpose.
    Unicode version 8 define puntos de codigo para mas de 120.000 caracteres en
    mas de 100 idiomas y scripts. ¿Como se representan esto en los datos y
    programas de computadora? El tipo de datos naturales para almacenar una sola
    runa es @c(int32), y eso es lo utiliza Go; tiene el sinonimo @c(rune)
    precisamente para este proposito.

#     We could represent a sequence of runes as a sequence of @c(int32) values. In
#     this representation, which is called UTF-32 or UCS-4, the encoding of each
#     Unicode code point has the same size, 32 bits. This is simple and uniform,
#     but it uses much more space than necessary since most computer-readable text
#     is in ASCII, which requires only 8 bits or 1 byte per character. All the
#     characters in widespread use still number fewer than 65,536, which would fit
#     in 16 bits. Can we do better?
    Podriamos representar una secuencia de runas como una secuencia de valores
    @c(int32). Esta representacion, se llama UTF-32 o UCS-4, la codificacion de
    cada punto de codigo Unicode tiene el mismo tamaño, 32 bits. Esto es simple
    y uniforme, pero utiliza mucho mas espacio de lo necesario, ya que la
    mayoria de texto legible por computadora esta en ASCII, que requiere solo 8
    bits o 1 byte por caracter. Todos los caracteres en uso generalizado todavia
    aun son menos de 65.536, que cabrian en 16 bits. ¿Podemos hacerlo mejor?

# *** Section 3.5.3 <> UTF-8
*** Seccion 3.5.3 <> UTF-8

#     UTF-8 is a variable-length encoding of Unicode code points as bytes. UTF-8
#     was invented by Ken Thompson and Rob Pike, two of the creators of Go, and is
#     now a Unicode standard. It uses between 1 and 4 bytes to represent each
#     rune, but only 1 byte for ASCII characters, and only 2 or 3 bytes for most
#     runes in common use. The high-order bits of the first byte of the encoding
#     for a rune indicate how many bytes follow. A high-order @c(0) indicates
#     7-bit ASCII, where each rune takes only 1 byte, so it is identical to
#     conventional ASCII. A high-order @c(110) indicates that the rune takes 2
#     bytes; the second byte begins with @c(10). Larger runes have analogous
#     encodings.
    UTF-8 es una codificacion de longitud variable de puntos de codigo Unicode
    como bytes. UTF-8 fue inventado por Ken Thompson y Rob Pike, dos de los
    creadores de Go, y ahora es un estandar Unicode. Utiliza entre 1 y 4 bytes
    para representar cada runa, pero solo 1 byte para caracteres ASCII y solo 2
    o 3 bytes para la mayoria de runas en uso comun. Los bits de orden alto del
    primer byte de la codificacion de una runa indican cuantos bytes siguen. Un
    alto orden 0 indica ASCII de 7 bits, donde cada runa toma solo 1 byte, por
    lo que es identica a ASCII convencional. Un alto orden @c(110) indica que la
    runa toma 2 bytes; el segundo byte comienza con @c(10). Las runas mas
    grandes tienen codificaciones analogas.

#     | @c(0xxxxxx)                            | runes 0−127    | (ASCII)               |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(11xxxxx 10xxxxxx)                   | 128−2047       | (values <128 unused)  |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(110xxxx 10xxxxxx 10xxxxxx)          | 2048−65535     | (values <2048 unused) |
#     |----------------------------------------|----------------|-----------------------|
#     | @c(1110xxx 10xxxxxx 10xxxxxx 10xxxxxx) | 65536−0x10ffff | (other values unused) |
    | @c(0xxxxxx)                            | runas 0−127    | (ASCII)                       |
    |----------------------------------------|----------------|-------------------------------|
    | @c(11xxxxx 10xxxxxx)                   | 128−2047       | (valores <128 no utilizados)  |
    |----------------------------------------|----------------|-------------------------------|
    | @c(110xxxx 10xxxxxx 10xxxxxx)          | 2048−65535     | (valores <2048 no utilizados) |
    |----------------------------------------|----------------|-------------------------------|
    | @c(1110xxx 10xxxxxx 10xxxxxx 10xxxxxx) | 65536−0x10ffff | (otros valores no utiliados)  |

#     A variable-length encoding precludes direct indexing to access the @m(n)-th
#     character of a string, but UTF-8 has many desirable properties to compensate.
#     The encoding is compact, compatible with ASCII, and self-synchronizing: it’s
#     possible to find the beginning of a character by backing up no more than
#     three bytes. It’s also a prefix code, so it can be decoded from left to
#     right without any ambiguity or lookahead. No rune’s encoding is a substring
#     of any other, or even of a sequence of others, so you can search for a rune
#     by just searching for its bytes, without worrying about the preceding
#     context. The lexicographic byte order equals the Unicode code point order,
#     so sorting UTF-8 works naturally. There are no embedded NUL (zero) bytes,
#     which is convenient for programming languages that use NUL to terminate
#     strings.
    Una codificacion de longitud variable impide la indexacion directa para
    acceder al @m(n)-esimo caracter de una cadena, pero UTF-8 tiene muchas
    propiedades deseables para compensar. La codificacion es compacta,
    compatible con ASCII y auto-sincronizada: es posible encontrar el inicio de
    un caracter al realizar una copia de seguridad de no mas de tres
    bytes. Tambien es un prefijo de codigo, por lo que se puede decodificar de
    izquierda a derecha sin ninguna ambigüedad o lookahead. La codificacion de
    ninguna runa es una subcadena de cualquier otra, o incluso de una secuencia
    de otras, por lo que puedes buscar una runa simplemente buscando sus bytes,
    sin preocuparte por el contexto anterior. El orden de bytes lexicografico es
    igual al orden de los puntos de codigo Unicode, por lo que la ordenacion de
    UTF-8 funciona de forma natural. No hay ningun NUL incrustado (cero) bytes,
    que es conveniente para los lenguajes de programacion que utilizan NUL para
    terminar cadenas.

#     Go source files are always encoded in UTF-8, and UTF-8 is the preferred
#     encoding for text strings manipulated by Go programs. The @c(unicode)
#     package provides functions for working with individual runes (such as
#     distinguishing letters from numbers, or converting an uppercase letter to a
#     lower-case one), and the @c(unicode/utf8) package provides functions for
#     encoding and decoding runes as bytes using UTF-8.
    Los archivos de codigo fuente de Go siempre estan codificados en UTF-8 y
    UTF-8 es la codificacion preferida para las cadenas de texto manipuladas por
    los programas Go. El paquete @c(unicode) proporciona funciones para trabajar
    con runas individuales (como distinguir letras de numeros, o la conversion
    de una letra mayuscula a una minuscula), y el paquete @c(unicode/utf8)
    proporciona funciones para codificar y decodificar runas como bytes usando
    UTF-8.

#     Many Unicode characters are hard to type on a keyboard or to distinguish
#     visually from similar-looking ones; some are even invisible. Unicode escapes
#     in Go string literals allow us to specify them by their numeric code point
#     value. There are two forms, @c(\u)@e(hhhh) for a 16-bit value and @c(\U)@e(hhhhhhhh)
#     for a 32-bit value, where each @e(h) is a hexadecimal digit; the need for the
#     32-bit form arises very infrequently. Each denotes the UTF-8 encoding of the
#     specified code point. Thus, for example, the following string literals all
#     represent the same six-byte string:
    Muchos caracteres Unicode son dificiles de escribir en un teclado o
    distinguir visualmente de otros de similar aspecto; Algunos son incluso
    invisibles. Go nos permite el escape de literales Unicode en una cadena Go
    al especificarlos por su valor numerico. Hay dos formas, @c(\u)@e(hhhh) para
    un valor de 16 bits y @c(\U)@e(hhhhhhhh) para un valor de 32 bits, donde
    cada @e(h) es un digito hexadecimal; La necesidad de la forma de 32 bits se
    presenta con poca frecuencia. Cada uno denota la codificacion UTF-8 del
    punto de codigo especificado. Asi, por ejemplo, los siguientes literales de
    cadena representan la misma cadena de seis bytes:

#     ..src > go
#       "世界"
#       "\xe4\xb8\x96\xe7\x95\x8c"
#       "\u4e16\u754c"
#       "\U00004e16\U0000754c"
#     < src..
    ..src > go
      "世界"
      "\xe4\xb8\x96\xe7\x95\x8c"
      "\u4e16\u754c"
      "\U00004e16\U0000754c"
    < src..

#     The three escape sequences above provide alternative notations for the first
#     string, but the values they denote are identical.  Unicode escapes may also
#     be used in rune literals. These three literals are equivalent:
    Las tres secuencias de escape anteriores proporcionan notaciones
    alternativas para la primera cadena, pero los valores que denotan son
    identicos. Los escapes Unicode tambien se puede utilizar en runas
    literales. Estos tres literales son equivalentes:

#     ..pre >
#       '世' '\u4e16' '\U00004e16'
    ..pre >
      '世' '\u4e16' '\U00004e16'

#     A rune whose value is less than 256 may be written with a single hexadecimal
#     escape, such as @c('\x41') for @c('A'), but for higher values, a @c(\u) or
#     @c(\U) escape must be used. Consequently, @c('\xe4\xb8\x96') is not a legal
#     rune literal, even though those three bytes are a valid UTF-8 encoding of a
#     single code point.
    Una runa cuyo valor es menor que 256 se puede escribir con una sola de
    escape hexadecimal, por ejemplo @c('\x41') para @c('A'), pero para los
    valores mas altos, debe utilizar un @c(\u) o @c(\U) de escape. En
    consecuencia, @c('\xe4\xb8\x96') no es una runa literal legal, a pesar de
    que esos tres bytes son un UTF-8 valido de un unico punto de codigo.

#     Thanks to the nice properties of UTF-8, many string operations don’t require
#     decoding. We can test whether one string contains another as a prefix:
    Gracias a las buenas propiedades de UTF-8, muchas operaciones de cadena no
    requieren decodificacion. Podemos probar si una cadena contiene otra como
    prefijo:

#     ..src > go
#       func HasPrefix(s, prefix string) bool {
#         return len(s) >= len(prefix) && s[:len(prefix)] == prefix
#       }
#     < src..
    ..src > go
      func HasPrefix(s, prefix string) bool {
        return len(s) >= len(prefix) && s[:len(prefix)] == prefix
      }
    < src..

#     or as a suffix:
    O como sufijo:

#     ..src > go
#       func HasSuffix(s, suffix string) bool {
#         return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
#       }
#     < src..
    ..src > go
      func HasSuffix(s, suffix string) bool {
        return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
      }
    < src..

#     or as a substring:
    O como una subcadena:

#     ..src > go
#       func Contains(s, substr string) bool {
#         for i := 0; i < len(s); i++ {
#           if HasPrefix(s[i:], substr) {
#             return true
#           }
#         }
#         return false
#       }
#     < src..
    ..src > go
      func Contains(s, substr string) bool {
        for i := 0; i < len(s); i++ {
          if HasPrefix(s[i:], substr) {
            return true
          }
        }
        return false
      }
    < src..

#     using the same logic for UTF-8-encoded text as for raw bytes. This is not
#     true for other encodings. (The functions above are drawn from the @c(strings)
#     package, though its implementation of @c(Contains) uses a hashing technique to
#     search more efficiently.)
    Utilizando la misma logica para un texto codificado en UTF-8 como para bytes
    sin procesar. Esto no es cierto para otras codificaciones. (Las funciones
    anteriores se han extraido del paquete @c(strings), aunque su implementacion
    de @c(Contains) utiliza una tecnica de hash para buscar de manera mas
    eficiente.)

#     On the other hand, if we really care about the individual Unicode
#     characters, we have to use other mechanisms. Consider the string from our
#     very first example, which includes two East Asian characters. Figure 3.5
#     illustrates its representation in memory. The string contains 13 bytes,
#     but interpreted as UTF-8, it encodes only nine code points or runes:
    Por otro lado, si realmente nos preocupamos por los caracteres Unicode
    individuales, tenemos que usar otros mecanismos. Consideremos la cadena de
    nuestro primer ejemplo, la cual incluye dos caracteres asiaticos. La Figura
    3.5 ilustra su representacion en la memoria. La cadena contiene 13 bytes,
    pero interpretada como UTF-8, codifica solo nueve puntos de codigo o runas:

#     ..src > go
#       import "unicode/utf8"
#
#       s := "Hello, 世界"
#       fmt.Println(len(s))                    // "13"
#       fmt.Println(utf8.RuneCountInString(s)) // "9"
#     < src..
    ..src > go
      import "unicode/utf8"

      s := "Hello, 世界"
      fmt.Println(len(s))                    // "13"
      fmt.Println(utf8.RuneCountInString(s)) // "9"
    < src..

#     To process those characters, we need a UTF-8 decoder. The @c(unicode/utf8)
#     package provides one that we can use like this:
    Para procesar esos caracteres, necesitamos un decodificador UTF-8. El
    paquete @c(unicode/utf8) proporciona uno que podemos utilizar de la
    siguiente manera:

#     ..src > go
#       for i := 0; i < len(s); {
#         r, size := utf8.DecodeRuneInString(s[i:])
#         fmt.Printf("%d\t%c\n", i, r)
#         i += size
#       }
#     < src..
    ..src > go
      for i := 0; i < len(s); {
        r, size := utf8.DecodeRuneInString(s[i:])
        fmt.Printf("%d\t%c\n", i, r)
        i += size
      }
    < src..

#     Each call to @c(DecodeRuneInString) returns @c(r), the rune itself, and
#     @c(size), the number of bytes occupied by the UTF-8 encoding of @c(r). The
#     size is used to update the byte index @c(i) of the next rune in the
#     string. But this is clumsy, and we need loops of this kind all the
#     time. Fortunately, Go’s @c(range) loop, when applied to a string, performs
#     UTF-8 decoding implicitly. The output of the loop below is also shown in
#     Figure 3.5; notice how the index jumps by more than 1 for each non-ASCII
#     rune.
    Cada llamada a @c(DecodeRuneInString) regresa @c(r), la runa en si, y
    @c(size), el numero de bytes ocupados por la codificacion UTF-8 de @c(r). El
    tamaño se utiliza para actualizar el indice del byte @c(i) de la siguiente
    runa en la cadena. Pero esto es torpe, y necesitamos bucles de este tipo
    todo el tiempo. Afortunadamente, Go tiene los bucles @c(range), cuando se
    aplica a una cadena, realiza decodificacion UTF-8 de forma implicita. La
    salida del bucle de siguiente se muestra en la Figura 3.5; Observe como el
    indice salta en mas de 1 para cada runa no ASCII.

#     ..src > go
#       for i, r := range "Hello, 世界" {
#         fmt.Printf("%d\t%q\t%d\n", i, r, r)
#       }
#     < src..
    ..src > go
      for i, r := range "Hello, 世界" {
        fmt.Printf("%d\t%q\t%d\n", i, r, r)
      }
    < src..

#     ..figure > Figure 3.5. A @c(range) loop decodes a UTF-8-encoded string.
    ..figure > Figura 3.5. Un bucle @c(range) descodifica una cadena UTF-8-codificado.

#       ..img  > img/Figure-3.5.jpg
      ..img  > img/Figure-3.5.jpg


#     We could use a simple @c(range) loop to count the number of runes in a string,
#     like this:
    Podriamos usar un simple bucle @c(range) para contar el numero de runas en
    una cadena, como aqui:

#     ..src > go
#       n := 0
#       for _, _ = range s {
#         n++
#       }
#     < src..
    ..src > go
      n := 0
      for _, _ = range s {
        n++
      }
    < src..

#     As with the other forms of @c(range) loop, we can omit the variables we
#     don’t need:
    Al igual que con las otras formas de bucle @c(range), podemos omitir las
    variables que no necesitamos:

#     ..src > go
#       n := 0
#       for range s {
#         n++
#       }
#     < src..
    ..src > go
      n := 0
      for range s {
        n++
      }
    < src..

#     Or we can just call @c[utf8.RuneCountInString(s)].
    O podemos simplemente llamar a @c[utf8.RuneCountInString(s)].

#     We mentioned earlier that it is mostly a matter of convention in Go that
#     text strings are interpreted as UTF-8-encoded sequences of Unicode code
#     points, but for correct use of @c(range) loops on strings, it’s more than a
#     convention, it’s a necessity. What happens if we range over a string
#     containing arbitrary binary data or, for that matter, UTF-8 data containing
#     errors?
    Ya hemos mencionado que es sobre todo una cuestion de convencion en Go que
    las cadenas de texto se interpretan como secuencias codificadas en UTF-8 de
    puntos de codigo Unicode, pero para el uso correcto de bucles @c(range) de
    cadenas, es mas que una convencion, es una necesidad. ¿Que sucede si
    aplicamos @c(range) en cadena que contiene datos binarios arbitrarios o, de
    hecho, datos UTF-8 que contienen errores?

#     Each time a UTF-8 decoder, whether explicit in a call to
#     @c(utf8.DecodeRuneInString) or implicit in a @c(range) loop, consumes an
#     unexpected input byte, it generates a special Unicode @e(replacement
#     character), @c('\uFFFD'), which is usually printed as a white question mark
#     inside a black hexagonal or diamond-like shape �. When a program encounters
#     this rune value, it’s often a sign that some upstream part of the system
#     that generated the string data has been careless in its treatment of text
#     encodings.
    Cada vez que un decodificador UTF-8, ya sea explicito en una llamada a
    @c(utf8.DecodeRuneInString) o implicito en un bucle @c(range), consume un
    byte de entrada inesperado, se genera un caracter Unicode de reemplazo
    especial, @c('\uFFFD'), que generalmente se impreme como un signo de
    interrogacion dentro de una forma hexagonal o un diamante negro �. Cuando un
    programa encuentra este valor de runa, a menudo es un signo de que parte del
    sistema que genero los datos de cadena ha sido descuidado en su tratamiento
    de las codificaciones de texto.

#     UTF-8 is exceptionally convenient as an interchange format but within a
#     program runes may be more convenient because they are of uniform size and
#     are thus easily indexed in arrays and slices.
    UTF-8 es excepcionalmente conveniente como un formato de intercambio, pero
    dentro de un programa las runas puede ser mas conveniente porque son de
    tamaño uniforme y por lo tanto, de facil indexado en arreglos y slices.

#     A @c([]rune) conversion applied to a UTF-8-encoded string returns the
#     sequence of Unicode code points that the string encodes:
    Una conversion @c([]rune) aplicada a una cadena codificada en UTF-8 devuelve la
    secuencia de codigos Unicode:

#     ..src > go
#       // "program" in Japanese katakana
#       s := "プログラム"
#       fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
#       r := []rune(s)
#       fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
#     < src..
    ..src > go
      // "programa" en katakana
      s := "プログラム"
      fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
      r := []rune(s)
      fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
    < src..

#     (The verb @c(% x) in the first @c(Printf) inserts a space between each pair
#     of hex digits.)
    (El verbo @c(% x) en el primer @c(Printf) inserta un espacio entre cada par
    de digitos hexadecimales.)

#     If a slice of runes is converted to a string, it produces the concatenation
#     of the UTF-8 encodings of each rune:
    Si un slice de runas se convierte en una cadena, produce la concatenacion de
    las codificaciones UTF-8 de cada runa:

#     ..src > go
#       fmt.Println(string(r)) // "プログラム"
#     < src..
    ..src > go
      fmt.Println(string(r)) // "プログラム"
    < src..

#     Converting an integer value to a string interprets the integer as a rune
#     value, and yields the UTF-8 representation of that rune:
    Convertir un valor entero en una cadena interpre el entero como un valor
    de runa, y produce la representacion UTF-8 de esa runa:

#     ..src > go
#       UTF-8 representation of that rune:
#       fmt.Println(string(65))     // "A", not "65"
#       fmt.Println(string(0x4eac)) // "京"
#     < src..
    ..src > go
      fmt.Println(string(65))     // "A", not "65"
      fmt.Println(string(0x4eac)) // "京"
    < src..

#     If the rune is invalid, the replacement character is substituted:
    Si la runa no es valida, se reemplasa por el caracter de sustitucion:

#     ..src > go
#       fmt.Println(string(1234567)) // "�"
#     < src..
    ..src > go
      fmt.Println(string(1234567)) // "�"
    < src..

# *** Section 3.5.4 <> Strings and Byte Slices
*** Seccion 3.5.4 <> Cadenas y Slices de Bytes

#     Four standard packages are particularly important for manipulating strings:
#     @c(bytes), @c(strings), @c(strconv), and @c(unicode). The @c(string) spackage
#     provides many functions for searching, replacing, comparing, trimming,
#     splitting, and joining strings.
    cuatro paquetes estandar son particularmente importantes para la
    manipulacion de cadenas: @c(bytes), @c(strings), @c(strconv) y
    @c(unicode). El paquete @c(strings) ofrece muchas funciones para busqueda,
    reemplazo, comparacion, recorte, division, y union en cadenas.

#     The @c(bytes) package has similar functions for manipulating slices of
#     bytes, of type @c([]byte), which share some properties with strings. Because
#     strings are immutable, building up strings incrementally can involve a lot
#     of allocation and copying. In such cases, it’s more efficient to use the
#     @c(bytes.Buffer) type, which we’ll show in a moment.
    El paquete @c(bytes) tiene funciones similares para manipular slices de
    bytes, de tipo @c([]byte), que comparten algunas propiedades con
    @c(strings). Debido a que las cadenas son inmutables, la construccion de
    cadenas de forma incremental puede implicar una gran cantidad de asignacion
    y copiado. En tales casos, es mas eficaz utilizar el tipo @c(bytes.Buffer),
    que vamos a mostrar en un momento.

#     The @c(strconv) package provides functions for converting boolean, integer,
#     and floating-point values to and from their string representations, and
#     functions for quoting and unquoting strings.
    El paquete @c(strconv) proporciona funciones para convertir booleanos,
    enteros, y valores de coma flotante hacia y desde sus representaciones en
    cadenas, y funciones para citar y des-citar cadenas.

#     The @c(unicode) package provides functions like @c(IsDigit), @c(IsLetter),
#     @c(IsUpper), and @c(IsLower) for classifying runes. Each function takes a
#     single rune argument and returns a boolean. Conversion functions like
#     @c(ToUpper) and @c(ToLower) convert a rune into the given case if it is a
#     letter. All these functions use the Unicode standard categories for letters,
#     digits, and so on. The @c(strings) package has similar functions, also
#     called @c(ToUpper) and @c(ToLower), that return a new string with the
#     specified transformation applied to each character of the original string.
    El paquete @c(unicode) proporciona funciones como @c(IsDigit), @c(IsLetter),
    @c(IsUpper) y @c(IsLower) para la clasificacion de runas. Cada funcion toma
    un unico argumento de tipo runa y devuelve un booleano. Las funciones de
    conversion como @c(ToUpper) y @c(ToLower) convierten una runa en el caso
    concreto si se trata de una letra. Todas estas funciones utilizan las
    categorias estandar de Unicode para las letras, los digitos, etc. El paquete
    @c(strings) tiene funciones similares, tambien llamadas @c(ToUpper) y
    @c(ToLower), que devuelven una nueva cadena con la transformacion
    especificada aplicada a cada caracter de la cadena original.

#     The @c(basename) function below was inspired by the Unix shell utility of
#     the same name. In our version, @c(basename)(s) removes any prefix of s that
#     looks like a file system path with components separated by slashes, and it
#     removes any suffix that looks like a file type:
    La siguiente funcion @c(basename) se inspiro en la utilidad de shell Unix
    del mismo nombre. En nuestra version, @c[basename(s)] elimina cualquier
    prefijo de @c(s) que paresca una ruta de sistema con componentes separados
    por barras, y elimina cualquier sufijo que se parece a un tipo de archivo:

#     ..src > go
#       fmt.Println(basename("a/b/c.go")) // "c"
#       fmt.Println(basename("c.d.go"))   // "c.d"
#       fmt.Println(basename("abc"))      // "abc"
#     < src..
    ..src > go
      fmt.Println(basename("a/b/c.go")) // "c"
      fmt.Println(basename("c.d.go"))   // "c.d"
      fmt.Println(basename("abc"))      // "abc"
    < src..

#     The first version of @c(basename) does all the work without the help of
#     libraries:
    La primer version de basename hace todo el trabajo sin la ayuda de
    librerias:

#     ..figure > @l(gopl.io/ch3/basename1/main.go<>gopl.io/ch3/basename1)
    ..figure > @l(gopl.io/ch3/basename1/main.go<>gopl.io/ch3/basename1)

#       ..src > go
#         // basename removes directory components and a .suffix.
#         // e.g., a => a, a.go => a, a/b/c.go => c, a/b.c.go => b.c
#         func basename(s string) string {
#           // Discard last '/' and everything before.
#           for i := len(s) - 1; i >= 0; i-- {
#             if s[i] == '/' {
#               s = s[i+1:]
#               break
#             }
#           }
#           // Preserve everything before last '.'.
#           for i := len(s) - 1; i >= 0; i-- {
#             if s[i] == '.' {
#               s = s[:i]
#               break
#             }
#           }
#           return s
#         }
#       < src..
      ..src > go
        // basename elimina los .subfijos y componentes de directorios.
        // e.g., a => a, a.go => a, a/b/c.go => c, a/b.c.go => b.c
        func basename(s string) string {
          // Descarta el ultimo '/' y todo lo anterior.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '/' {
              s = s[i+1:]
              break
            }
          }
          // Conserva todo antes del ultimo '.'.
          for i := len(s) - 1; i >= 0; i-- {
            if s[i] == '.' {
              s = s[:i]
              break
            }
          }
          return s
        }
      < src..


#     A simpler version uses the @c(strings.LastIndex) library function:
    Una version mas simple utiliza la funcion de libreria @c(strings.LastIndex):

#     ..figure > @l(gopl.io/ch3/basename2/main.go<>gopl.io/ch3/basename2)
    ..figure > @l(gopl.io/ch3/basename2/main.go<>gopl.io/ch3/basename2)

#       ..src > go
#         func basename(s string) string {
#           slash := strings.LastIndex(s, "/") // -1 if "/" not found
#           s = s[slash+1:]
#           if dot := strings.LastIndex(s, "."); dot >= 0 {
#             s = s[:dot]
#           }
#           return s
#         }
#       < src..
      ..src > go
        func basename(s string) string {
          slash := strings.LastIndex(s, "/") // -1 si no se encuentra "/"
          s = s[slash+1:]
          if dot := strings.LastIndex(s, "."); dot >= 0 {
            s = s[:dot]
          }
          return s
        }
      < src..


#     The @c(path) and @c(path/filepath) packages provide a more general set of
#     functions for manipulating hierarchical names. The @c(path) package works
#     with slash-delimited paths on any platform. It shouldn’t be used for file
#     names, but it is appropriate for other domains, like the path component of a
#     URL. By contrast, @c(path/filepath) manipulates file names using the rules
#     for the host platform, such as @c(/foo/bar) for POSIX or @c(c:\foo\bar) on
#     Microsoft Windows.
    Los paquetes @c(path) y @c(path/filepath) proporcionan un conjunto general
    de funciones para manipular nombres jerarquicos. El paquete @c(path)
    funciona con rutas delimitada por barras en cualquier plataforma. No se debe
    utilizar para nombres de archivo, pero es apropiado para otros dominios,
    como los componente de ruta de una URL. Por el contrario, @c(path/filepath)
    manipula los nombres de archivos usando las reglas para la plataforma
    huesped, tales como @c(/foo/bar) para POSIX o @c(c:\foo\bar) en Microsoft
    Windows.

#     Let’s continue with another substring example. The task is to take a string
#     representation of an integer, such as @c("12345"), and insert commas every
#     three places, as in @c("12,345"). This version only works for integers;
#     handling floating-point numbers is left as a exercise.
    Vamos a continuar con otro ejemplo de subcadena. La tarea es tomar una
    representacion de cadena de un entero, como @c("12345"), e insertar comas
    cada tres posiciones, como en @c("12,345") . Esta version solo funciona para
    enteros; El manejo de numeros de coma flotante se deja como un ejercicio.

#     ..figure > @l(gopl.io/ch3/comma/main.go<>gopl.io/ch3/comma)
    ..figure > @l(gopl.io/ch3/comma/main.go<>gopl.io/ch3/comma)

#       ..src > go
#         // comma inserts commas in a non-negative decimal integer string.
#         func comma(s string) string {
#           n := len(s)
#           if n <= 3 {
#             return s
#           }
#           return comma(s[:n-3]) + "," + s[n-3:]
#         }
#       < src..
      ..src > go
        // comma inserta comas en una cadena de numeros enteros decimales negativos.
        func comma(s string) string {
          n := len(s)
          if n <= 3 {
            return s
          }
          return comma(s[:n-3]) + "," + s[n-3:]
        }
      < src..


#     The argument to @c(comma) is a string. If its length is less than or equal
#     to 3, no comma is necessary. Otherwise, @c(comma) calls itself recursively
#     with a substring consisting of all but the last three characters, and
#     appends a comma and the last three characters to the result of the recursive
#     call.
    El argumento de @c(comma) es una cadena. Si su longitud es menor o igual a
    3, no es necesaria una coma. De lo contrario, comma se llama a si misma de
    forma recursiva con una subcadena formada por todos menos los tres ultimos
    caracteres, y añåde una coma y los tres ultimos caracteres en el resultado
    de la llamada recursiva.

#     A string contains an array of bytes that, once created, is immutable. By
#     contrast, the elements of a byte slice can be freely modified.
    Una cadena contiene un arreglo de bytes que, una vez creado, es
    inmutable. Por el contrario, los elementos de una slice de bytes se pueden
    modificar libremente.

#     Strings can be converted to byte slices and back again:
    Las cadenas se pueden convertir en slices de bytes y viceversa:

#     ..src > go
#       s := "abc"
#       b := []byte(s)
#       s2 := string(b)
#     < src..
    ..src > go
      s := "abc"
      b := []byte(s)
      s2 := string(b)
    < src..

#     Conceptually, the @c{[]byte(s)} conversion allocates a new byte array
#     holding a copy of the bytes of @c(s), and yields a slice that references the
#     entirety of that array. An optimizing compiler may be able to avoid the
#     allocation and copying in some cases, but in general copying is required to
#     ensure that the bytes of @c(s) remain unchanged even if those of @c(b) are
#     subsequently modified. The conversion from byte slice back to string with
#     @c[string(b)] also makes a copy, to ensure immutability of the resulting
#     string @c(s2).
    Conceptualmente, la conversion @c{[]byte(s)} asigna un nuevo arreglo de
    bytes que guarda una copia de bytes de @c(s), y produce un slice que hace
    referencia a la totalidad del arreglo. Un compilador optimizado puede ser
    capaz de evitar la asignacion y la copia en algunos casos, pero en general,
    la copia es necesaria para asegurar que los bytes de @c(s) se mantienen sin
    cambios incluso si los de @c(b) son modificados posteriormente. La
    conversion de slice de byte de nuevo a cadena con @c[string(b)] tambien
    genera una copia, para asegurar inmutabilidad de la cadena resultante
    @c(s2).

#     To avoid conversions and unnecessary memory allocation, many of the utility
#     functions in the @c(bytes) package directly parallel their counterparts in
#     the @c(strings) package. For example, here are half a dozen functions from
#     @c(strings):
    Para evitar conversiones y asignacion de memoria innecesaria, muchas
    de las funciones de utilidad en el paquete @c(bytes) directamente paralelos a
    sus contrapartes en el paquete @c(strings). Por ejemplo, aqui hay una media
    docena de funciones en @c(strings):

#     ..src > go
#       func Contains(s, substr string) bool
#       func Count(s, sep string) int
#       func Fields(s string) []string
#       func HasPrefix(s, prefix string) bool
#       func Index(s, sep string) int
#       func Join(a []string, sep string) string
#     < src..
    ..src > go
      func Contains(s, substr string) bool
      func Count(s, sep string) int
      func Fields(s string) []string
      func HasPrefix(s, prefix string) bool
      func Index(s, sep string) int
      func Join(a []string, sep string) string
    < src..

#     and the corresponding ones from @c(bytes):
    y las correspondientes en bytes :

#     ..src > go
#       func Contains(b, subslice []byte) bool
#       func Count(s, sep []byte) int
#       func Fields(s []byte) [][]byte
#       func HasPrefix(s, prefix []byte) bool
#       func Index(s, sep []byte) int
#       func Join(s [][]byte, sep []byte) []byte
#     < src..
    ..src > go
      func Contains(b, subslice []byte) bool
      func Count(s, sep []byte) int
      func Fields(s []byte) [][]byte
      func HasPrefix(s, prefix []byte) bool
      func Index(s, sep []byte) int
      func Join(s [][]byte, sep []byte) []byte
    < src..

#     The only difference is that strings have been replaced by byte slices.
    La unica diferencia es que las cadenas han sido reemplazadas por slices de
    bytes.

#     The @c(bytes) package provides the @c(Buffer) type for efficient
#     manipulation of byte slices. A @c(Buffer) starts out empty but grows as data
#     of types like @c(string), @c(byte), and @c([]byte) are written to it. As the
#     example below shows, a @c(bytes.Buffer) variable requires no initialization
#     because its zero value is usable:
    El paquete @c(bytes) proporciona el tipo @c(Buffer) para la manipulacion
    eficiente de slices de @c(byte). Un @c(Buffer) comienza vacio, pero crece a
    medida que los datos de tipos como @c(string), @c(byte), y @c([]byte) se
    escriben en el. Como muestra el siguiente ejemplo, una variable
    @c(bytes.Buffer) no requiere inicializacion porque su valor cero es
    utilizable:

#     ..figure > @l(gopl.io/ch3/printints/main.go<>gopl.io/ch3/printints)
    ..figure > @l(gopl.io/ch3/printints/main.go<>gopl.io/ch3/printints)

#       ..src > go
#         // intsToString is like fmt.Sprint(values) but adds commas.
#         func intsToString(values []int) string {
#           var buf bytes.Buffer
#           buf.WriteByte('[')
#           for i, v := range values {
#             if i > 0 {
#               buf.WriteString(", ")
#             }
#             fmt.Fprintf(&buf, "%d", v)
#           }
#           buf.WriteByte(']')
#           return buf.String()
#         }
#
#         func main() {
#           fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
#         }
#       < src..
      ..src > go
        // intsToString es como fmt.Sprint(values) pero agrega comas.
        func intsToString(values []int) string {
          var buf bytes.Buffer
          buf.WriteByte('[')
          for i, v := range values {
            if i > 0 {
              buf.WriteString(", ")
            }
            fmt.Fprintf(&buf, "%d", v)
          }
          buf.WriteByte(']')
          return buf.String()
        }

        func main() {
          fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
        }
      < src..


#     When appending the UTF-8 encoding of an arbitrary rune to a
#     @c(bytes.Buffer), it’s best to use @c(bytes.Buffer)’s @c(WriteRune) method,
#     but @c(WriteByte) is fine for ASCII characters such as @c('[') and @c(']').
    Cuando se agrega la codificacion UTF-8 de un runa arbitraria a un
    @c(bytes.Buffer), lo mejor es utilizar el metodo @c(WriteRune) de
    @c(bytes.Buffer), pero @c(WriteByte) esta bien para caracteres ASCII como
    @c('[') y @c(']').

#     The @c(bytes.Buffer) type is extremely versatile, and when we discuss
#     interfaces in @l(#Chapter 7), we’ll see how it may be used as a replacement
#     for a file whenever an I/O function requires a sink for bytes
#     (@c(io.Writer)) as @c(Fprintf) does above, or a source of bytes
#     (@c(io.Reader)).
    El tipo @c(bytes.Buffer) es extremadamente versatil, y cuando hablemos de
    interfaces en el @l(#Capitulo 7), vamos a ver como se puede utilizar como un
    sustituto de un archivo cada vez que una funcion de E/S requiere un poso de
    bytes (@c(io.Writer)) como @c(Fprintf), o una fuente de bytes
    (@c(io.Reader)).

#     @b(Exercise 3.10): Write a non-recursive version of @c(comma), using
#     @c(bytes.Buffer) instead of string concatenation.
   @b(Ejercicio 3.10): Escribir una version no recursiva de @c(comma),
   utilizando @c(bytes.Buffer) en lugar de la concatenacion de cadenas.

#     @b(Exercise 3.11): Enhance @c(comma) so that it deals correctly with
#     floating-point numbers and an optional sign.
   @b(Ejercicio 3.11): Mejorar @c(comma) para que se maneje correctamente los
   numeros de punto flotante y un opcionalmente con signo.

#     @b(Exercise 3.12): Write a function that reports whether two strings are
#     anagrams of each other, that is, they contain the same letters in a
#     different order.
   @b(Ejercicio 3.12): Escribir una funcion que informa de si dos cadenas son
   anagramas entre si, es decir, que contienen las mismas letras en un orden
   diferente.

# *** Section 3.5.5 <> Conversions between Strings and Numbers
*** Seccion 3.5.5 <> Conversiones entre cadenas y numeros

#     In addition to conversions between strings, runes, and bytes, it’s often
#     necessary to convert between numeric values and their string
#     representations. This is done with functions from the @c(strconv) package.
    Ademas de las conversiones entre cadenas, runas y bytes, a menudo es
    necesario convertir entre valores numericos y sus representaciones de
    cadena. Esto se realiza con las funciones del paquete @c(strconv).

#     To convert an integer to a string, one option is to use @c(fmt.Sprintf);
#     another is to use the function @c(strconv.Itoa) (@"(integer to ASCII)):
    Para convertir un entero a una cadena, una opcion es utilizar @c(fmt.Sprintf);
    otra es utilizar la funcion @c(strconv.Itoa) (@"(entero a ASCII)):

#     ..src > go
#       x := 123
#       y := fmt.Sprintf("%d", x)
#       fmt.Println(y, strconv.Itoa(x)) // "123 123"
#     < src..
    ..src > go
      x := 123
      y := fmt.Sprintf("%d", x)
      fmt.Println(y, strconv.Itoa(x)) // "123 123"
    < src..

#     @c(FormatInt) and @c(FormatUint) can be used to format numbers in a
#     different base:
    @c(FormatInt) y @c(FormatUint) se pueden utilizar para dar formato a numeros
    en una base diferente:

#     ..src > go
#       fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
#     < src..
    ..src > go
      fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
    < src..

#     The @c(fmt.Printf) verbs @c(%b), @c(%d), @c(%u), and @c(%x) are often more
#     convenient than @c(Format) functions, especially if we want to include
#     additional information besides the number:
    Los verbos @c(%b), @c(%d), @c(%u) y @c(%x) de @c(fmt.Printf) a menudo son
    mas conveniente que las funciones @c(Format), sobre todo si queremos incluir
    informacion adicional ademas del numero:

#     ..src > go
#       s := fmt.Sprintf("x=%b", x) // "x=1111011"
#     < src..
    ..src > go
      s := fmt.Sprintf("x=%b", x) // "x=1111011"
    < src..

#     To parse a string representing an integer, use the @c(strconv) functions
#     @c(Atoi) or @c(ParseInt), or ParseUint for unsigned integers:
    Para analizar una cadena que representa un numero entero, utilice las
    funciones de @c(strconv) como @c(Atoi) o @c(ParseInt), o @c(ParseUint) para
    enteros sin signo:

#     ..src > go
#       x, err := strconv.Atoi("123")             // x is an int
#       y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
#     < src..
    ..src > go
      x, err := strconv.Atoi("123")             // x es un entero
      y, err := strconv.ParseInt("123", 10, 64) // base 10, hasta 64 bits
    < src..

#     The third argument of @c(ParseInt) gives the size of the integer type that
#     the result must fit into; for example, 16 implies @c(int16), and the special
#     value of 0 implies @c(int). In any case, the type of the result y is always
#     @c(int64), which you can then convert to a smaller type.
    El tercer argumento de @c(ParseInt) da el tamaño del tipo de entero que debe
    ser el resultado; por ejemplo, 16 implica @c(int16), y el valor especial 0
    implica @c(int) . En cualquier caso, el tipo del resultado @c(y) es siempre
    @c(int64), que luego se puede convertir a un tipo mas pequeño.

#     Sometimes @c(fmt.Scanf) is useful for parsing input that consists of orderly
#     mixtures of strings and numbers all on a single line, but it can be
#     inflexible, especially when handling incomplete or irregular input.
    A veces es util @c(fmt.Scanf) para el analisis de entrada que consta de
    mezclas ordenadas de cadenas y numeros todo en una sola linea, pero puede
    ser inflexible, especialmente cuando se maneja una entrada incompleta o
    irregular.

# ** Section 3.6 <> Constants
** Seccion 3.6 <> Constantes

#    Constants are expressions whose value is known to the compiler and whose
#    evaluation is guaranteed to occur at compile time, not at run time. The
#    underlying type of every constant is a basic type: boolean, string, or
#    number.
   Las constantes son expresiones cuyo valor es conocido por el compilador y
   cuya evaluacion se garantiza que se produzca en tiempo de compilacion, no en
   tiempo de ejecucion. El tipo subyacente de cada constante es un tipo basico:
   booleano, cadena o numero.

#    A @c(const) declaration defines named values that look syntactically like
#    variables but whose value is constant, which prevents accidental (or
#    nefarious) changes during program execution.  For instance, a constant is
#    more appropriate than a variable for a mathematical constant like @c(pi),
#    since its value won’t change:
   Una declaracion @c(const) define los valores que se ven sintacticamente como
   variables con nombre pero cuyo valor es constante, lo que evita cambios
   accidentales (o nefastos) durante la ejecucion del programa. Por ejemplo, una
   constante es mas apropiada que una variable para una constante matematica
   como @c(pi), ya que su valor no cambiara:

#    ..src > go
#      const pi = 3.14159 // approximately; math.Pi is a better approximation
#    < src..
   ..src > go
     const pi = 3.14159 // aproximadamente; math.Pi un una mejor aproximacion
   < src..

#    As with variables, a sequence of constants can appear in one declaration;
#    this would be appropriate for a group of related values:
   Al igual que con las variables, una secuencia de constantes puede aparecer en
   una declaracion; Esto seria apropiado para un grupo de valores relacionados:

#    ..src > go
#      const (
#        e  = 2.71828182845904523536028747135266249775724709369995957496696763
#        pi = 3.14159265358979323846264338327950288419716939937510582097494459
#      )
#    < src..
   ..src > go
     const (
       e  = 2.71828182845904523536028747135266249775724709369995957496696763
       pi = 3.14159265358979323846264338327950288419716939937510582097494459
     )
   < src..

#    Many computations on constants can be completely evaluated at compile time,
#    reducing the work necessary at run time and enabling other compiler
#    optimizations. Errors ordinarily detected at run time can be reported at
#    compile time when their operands are constants, such as integer division by
#    zero, string indexing out of bounds, and any floating-point operation that
#    would result in a non-finite value.
   Muchos calculos de constantes pueden evaluarse completamente en tiempo de
   compilacion, reduciendo el trabajo necesario en tiempo de ejecucion y
   habilitando otras optimizaciones de compilador. Los errores ordinariamente
   detectados en tiempo de ejecucion pueden ser reportados en tiempo de
   compilacion cuando sus operandos son constantes, como la division entera por
   cero, una cadena de indexacion fuera de limites y cualquier operacion de
   punto flotante que daria lugar a un valor no finito.

#    The results of all arithmetic, logical, and comparison operations applied to
#    constant operands are themselves constants, as are the results of conversions
#    and calls to certain built-in functions such as @c(len), @c(cap), @c(real),
#    @c(imag), @c(complex), and @c(unsafe.Sizeof) (@l(#Section 13.1<>§13.1)).
   Los resultados de toda la aritmetica, y operaciones de comparacion logicos
   aplicados a operandos constantes son en si mismas constantes, como son los
   resultados de las conversiones y las llamadas a ciertas funciones nativas
   como @c(len), @c(cap), @c(real), @c(imag), @c(complex), y @c(unsafe.Sizeof)
   (@l(#Seccion 13.1<>§13.1)).

#    Since their values are known to the compiler, constant expressions may appear
#    in types, specifically as the length of an array type:
   Ya que sus valores son conocidos por el compilador, las expresiones
   constantes pueden aparecer en los tipos, especificamente como la longitud de
   un tipo de arreglo:

#    ..src > go
#      const IPv4Len = 4
#
#      // parseIPv4 parses an IPv4 address (d.d.d.d).
#      func parseIPv4(s string) IP {
#        var p [IPv4Len]byte
#        // ...
#      }
#    < src..
   ..src > go
     const IPv4Len = 4

     // parseIPv4 analiza una direccion IPv4 (d.d.d.d).
     func parseIPv4(s string) IP {
       var p [IPv4Len]byte
       // ...
     }
   < src..

#    A constant declaration may specify a type as well as a value, but in the
#    absence of an explicit type, the type is inferred from the expression on the
#    right-hand side. In the following, @c(time.Duration) is a named type whose
#    underlying type is @c(int64), and @c(time.Minute) is a constant of that
#    type. Both of the constants declared below thus have the type
#    @c(time.Duration) as well, as revealed by @c(%T):
   Una declaracion constante puede especificar un tipo como un valor, pero en
   ausencia de un tipo explicito, el tipo se infiere de la expresion en el lado
   derecho. En el siguiente ejemplo, @c(time.Duration) es un tipo con nombre
   cuyo tipo subyacente es @c(int64), y @c(time.Minute) es una constante de ese
   tipo. Por lo tanto las dos constantes declaradas a continuacion tienen el
   tipo @c(time.Duration), como lo revela @c(%T):

#    ..src > go
#      const noDelay time.Duration = 0
#      const timeout = 5 * time.Minute
#
#      fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
#      fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s
#      fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
#    < src..
   ..src > go
     const noDelay time.Duration = 0
     const timeout = 5 * time.Minute

     fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
     fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s
     fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
   < src..

#    When a sequence of constants is declared as a group, the right-hand side
#    expression may be omitted for all but the first of the group, implying that
#    the previous expression and its type should be used again. For example:
   Cuando una secuencia de constantes se declara como un grupo, la expresion del
   lado derecho se puede omitir para todas excepto para la primera del grupo, lo
   que implica que la expresion anterior y su tipo deben ser utilizados de
   nuevo. Por ejemplo:

#    ..src > go
#      const (
#        a = 1
#        b
#        c = 2
#        d
#      )
#
#      fmt.Println(a, b, c, d) // "1 1 2 2"
#    < src..
   ..src > go
     const (
       a = 1
       b
       c = 2
       d
     )

     fmt.Println(a, b, c, d) // "1 1 2 2"
   < src..

#    This is not very useful if the implicitly copied right-hand side expression
#    always evaluates to the same thing. But what if it could vary? This brings us
#    to @c(iota).
   Esto no es muy util si la expresion del lado derecho implicitamente copiada
   se evalua siempre con el mismo valor. Pero, ¿y si pudiera variar? Esto nos
   lleva a @c(iota).

# *** Section 3.6.1 <> The Constant Generator @c(iota)
*** Seccion 3.6.1 <> El Generador Constante @c(iota)

#     A @c(const) declaration may use the @e(constant generator) @c(iota), which
#     is used to create a sequence of related values without spelling out each one
#     explicitly. In a @c(const) declaration, the value of @c(iota) begins at zero
#     and increments by one for each item in the sequence.
    Una declaracion @c(const) puede utilizar el generador de constante @c(iota),
    que se utiliza para crear una secuencia de valores relacionados sin escribir
    cada uno de forma explicita. En una declaracion @c(const), el valor de
    @c(iota) comienza en cero y se incrementa en uno en cada elemento de la
    secuencia.

#     Here’s an example from the @c(time) package, which defines named constants
#     of type @c(Weekday) for the days of the week, starting with zero for
#     @c(Sunday). Types of this kind are often called @e(enumerations), or
#     @e(enums) for short.
    He aqui un ejemplo del paquete @c(time), que define constantes de tipo
    @c(Weekday) de los dias de la semana, a partir de cero para @c(Sunday).
    Tipos de esta clase a menudo se conocen como @e(enumeraciones), o @e(enums),
    para abreviar.

#     ..src > go
#       type Weekday int
#
#       const (
#         Sunday Weekday = iota
#         Monday
#         Tuesday
#         Wednesday
#         Thursday
#         Friday
#         Saturday
#       )
#     < src..
    ..src > go
      type Weekday int

      const (
        Sunday Weekday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
      )
    < src..

#     This declares @c(Sunday) to be 0, @c(Monday) to be 1, and so on.
    Esto declara que @c(Sunday) debe ser 0, @c(Monday) debe ser 1, y asi
    sucesivamente.

#     We can use @c(iota) in more complex expressions too, as in this example from
#     the @c(net) package where each of the lowest 5 bits of an unsigned integer
#     is given a distinct name and boolean interpretation:
    Podemos utilizar @c(iota) en expresiones mas complejas, como en este ejemplo
    del paquete @c(net) en el que se le da a cada uno de los 5 bits mas bajos de
    un entero sin signo un nombre distinto e interpretacion booleana:

#     ..src > go
#       type Flags uint
#
#       const (
#         FlagUp Flags = 1 << iota // is up
#         FlagBroadcast            // supports broadcast access capability
#         FlagLoopback             // is a loopback interface
#         FlagPointToPoint         // belongs to a point-to-point link
#         FlagMulticast            // supports multicast access capability
#       )
#     < src..
    ..src > go
      type Flags uint

      const (
        FlagUp Flags = 1 << iota // esta arriba
        FlagBroadcast            // soporta acceso broadcast
        FlagLoopback             // es una interface loopback
        FlagPointToPoint         // pertenece a un enlace punto-a-punto
        FlagMulticast            // soporta acceso multicast
      )
    < src..

#     As @c(iota) increments, each constant is assigned the value of @c(1 <<
#     iota), which evaluates to successive powers of two, each corresponding to a
#     single bit. We can use these constants within functions that test, set, or
#     clear one or more of these bits:
    Como @c(iota) incrementa, a cada constante se le asigna el valor de @c(1 <<
    iota), que evalua a potencias consecutivas de dos, cada un corresponde a un
    solo bit. Podemos utilizar estas constantes dentro de funciones que prueban,
    establecen o borran uno o mas de estos bits:

#     ..figure > @l(gopl.io/ch3/netflag/netflag.go<>gopl.io/ch3/netflag)
    ..figure > @l(gopl.io/ch3/netflag/netflag.go<>gopl.io/ch3/netflag)

#       ..src > go
#         func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
#         func TurnDown(v *Flags)     { *v &^= FlagUp }
#         func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
#         func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }
#
#         func main() {
#           var v Flags = FlagMulticast | FlagUp
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10001 true"
#           TurnDown(&v)
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10000 false"
#           SetBroadcast(&v)
#           fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
#           fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
#         }
#       < src..
      ..src > go
        func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
        func TurnDown(v *Flags)     { *v &^= FlagUp }
        func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
        func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }

        func main() {
          var v Flags = FlagMulticast | FlagUp
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10001 true"
          TurnDown(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10000 false"
          SetBroadcast(&v)
          fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
          fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
        }
      < src..


#     As a more complex example of @c(iota), this declaration names the powers of
#     1024:
    Como un ejemplo mas complejo de @c(iota), esta declaracion nombra las
    potencias de 1024:

#     ..src > go
#       const (
#         _ = 1 << (10 * iota)
#         KiB // 1024
#         MiB // 1048576
#         GiB // 1073741824
#         TiB // 1099511627776              (exceeds 1 << 32)
#         PiB // 1125899906842624
#         EiB // 1152921504606846976
#         ZiB // 1180591620717411303424     (exceeds 1 << 64)
#         YiB // 1208925819614629174706176
#       )
#     < src..
    ..src > go
      const (
        _ = 1 << (10 * iota)
        KiB // 1024
        MiB // 1048576
        GiB // 1073741824
        TiB // 1099511627776              (exede 1 << 32)
        PiB // 1125899906842624
        EiB // 1152921504606846976
        ZiB // 1180591620717411303424     (exede 1 << 64)
        YiB // 1208925819614629174706176
      )
    < src..

#     The @c(iota) mechanism has its limits. For example, it’s not possible to
#     generate the more familiar powers of 1000 (KB, MB, and so on) because there
#     is no exponentiation operator.
    El mecanismo @c(iota) tiene sus limites. Por ejemplo, no es posible generar
    las potencias mas familiares de 1000 (KB, MB, etc.) porque no hay un
    operador de exponenciacion.

#     @b(Exercise 3.13): Write @c(const) declarations for KB, MB, up through YB as
#     compactly as you can.
   @b(Ejercicio 3.13): Escribir declaraciones @c(const) para KB, MB, hasta YB lo
   mas compacto como sea posible.

# *** Section 3.6.2 <> Untyped Constants
*** Seccion 3.6.2 <> Constantes Sin Tipo

#     Constants in Go are a bit unusual. Although a constant can have any of the
#     basic data types like @c(int) or @c(float64), including named basic types
#     like @c(time.Duration), many constants are not committed to a particular
#     type. The compiler represents these uncommitted constants with much greater
#     numeric precision than values of basic types, and arithmetic on them is more
#     precise than machine arithmetic; you may assume at least 256 bits of
#     precision. There are six flavors of these uncommitted constants, called
#     @e(untyped) boolean, untyped integer, untyped rune, untyped floating-point,
#     untyped complex, and untyped string.
    Las constantes en Go son un poco inusuales. Aunque una constante puede tener
    cualquiera de los tipos de datos basicos como @c(int) o @c(float64),
    incluyendo tipos basicos con nombre como @c(time.Duration), muchas
    constantes no estan comprometidas con un tipo particular. El compilador
    representa estas constantes no comprometidas con una precision numerica
    mucho mayor que los valores de tipos basicos, y la aritmetica en ellas es
    mas precisa que la aritmetica de la maquina; Puede suponer al menos 256 bits
    de precision. Hay seis sabores de estas constantes no comprometidos, llamado
    booleanos @e(sin tipo), enteros sin tipo, runas sin tipo, punto flotante sin
    tipo, complejos sin tipo y cadenas sin tipo.

#     By deferring this commitment, untyped constants not only retain their higher
#     precision until later, but they can participate in many more expressions
#     than committed constants without requiring conversions. For example, the
#     values @c(ZiB) and @c(YiB) in the example above are too big to store in any
#     integer variable, but they are legitimate constants that may be used in
#     expressions like this one:
    Al aplazar este compromiso, las constantes no tipificadas no solo conservan
    su mayor precision hasta mas tarde, sino que pueden participar en muchas mas
    expresiones que las constantes comprometidas sin requerir conversiones. Por
    ejemplo, los valores @c(ZiB) y @c(YiB) en el ejemplo anterior son demasiado
    grandes para almacenase en cualquier variable entera, pero son legitimas
    constantes que pueden utilizarse en las expresiones como esta:

#     ..src > go
#       fmt.Println(YiB/ZiB) // "1024"
#     < src..
    ..src > go
      fmt.Println(YiB/ZiB) // "1024"
    < src..

#     As another example, the floating-point constant @c(math.Pi) may be used
#     wherever any floatingpoint or complex value is needed:
    Como otro ejemplo, la constante de coma flotante @c(math.Pi) puede
    utilizarse alli donde se necesite cualquier valor de coma flotante o
    complejo:

#     ..src > go
#       var x float32 = math.Pi
#       var y float64 = math.Pi
#       var z complex128 = math.Pi
#     < src..
    ..src > go
      var x float32 = math.Pi
      var y float64 = math.Pi
      var z complex128 = math.Pi
    < src..

#     If @c(math.Pi) had been committed to a specific type such as @c(float64),
#     the result would not be as precise, and type conversions would be required
#     to use it when a @c(float32) or @c(complex128) value is wanted:
    Si @c(math.Pi) entubiera comprometido con un tipo especifico, como
    @c(float64), el resultado no seria tan preciso, y se requerira de conversion
    de tipos para usarlo con valores @c(float32) o @c(complex128):

#     ..src > go
#       const Pi64 float64 = math.Pi
#
#       var x float32 = float32(Pi64)
#       var y float64 = Pi64
#       var z complex128 = complex128(Pi64)
#     < src..
    ..src > go
      const Pi64 float64 = math.Pi

      var x float32 = float32(Pi64)
      var y float64 = Pi64
      var z complex128 = complex128(Pi64)
    < src..

#     For literals, syntax determines flavor. The literals @c(0), @c(0.0), @c(0i),
#     and @c('\u0000') all denote constants of the same value but different
#     flavors: untyped integer, untyped floating-point, untyped complex, and
#     untyped rune, respectively. Similarly, @c(true) and @c(false) are untyped
#     booleans and string literals are untyped strings.
    Para literales, la sintaxis determina el sabor. Los literales de @c(0),
    @c(0.0), @c(0i), y @c('\u0000') representan constantes del mismo valor pero
    diferentes sabores: entero sin tipo, sin tipo de punto flotante, complejo
    sin tipo, y runa sin tipo, respectivamente. Del mismo modo, @c(true) y
    @c(false) son booleanos sin tipo y literales de cadena son cadenas sin tipo.

#     Recall that @c(/) may represent integer or floating-point division depending on
#     its operands.  Consequently, the choice of literal may affect the result of
#     a constant division expression:
    Recordemos que @c(/) puede representar un numero entero o division de punto
    flotante dependiendo de sus operandos. En consecuencia, la eleccion de
    literal puede afectar el resultado de una expresion de division constante:

#     ..src > go
#       var f float64 = 212
#       fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 is a float64
#       fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 is an untyped integer, 0
#       fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 is an untyped float
#     < src..
    ..src > go
      var f float64 = 212
      fmt.Println((f - 32) * 5 / 9)     // "100"; (f - 32) * 5 es un float64
      fmt.Println(5 / 9 * (f - 32))     // "0";   5/9 es un entero sin tipo, 0
      fmt.Println(5.0 / 9.0 * (f - 32)) // "100"; 5.0/9.0 es un float sin tipo
    < src..

#     Only constants can be untyped. When an untyped constant is assigned to a
#     variable, as in the first statement below, or appears on the right-hand side
#     of a variable declaration with an explicit type, as in the other three
#     statements, the constant is implicitly converted to the type of that
#     variable if possible.
    Solo las constantes pueden no tener tipo. Cuando una constante no tipificada
    se asigna a una variable, como en la primer instruccion a continuacion, o
    aparece en el lado derecho de una declaracion de variable con un tipo
    explicito, como en las otras tres sentencias, la constante se convierte
    implicitamente en el tipo de esa variable si es posible.

#     ..src > go
#       var f float64 = 3 + 0i // untyped complex -> float64
#       f = 2                  // untyped integer -> float64
#       f = 1e123              // untyped floating-point -> float64
#       f = 'a'                // untyped rune -> float64
#     < src..
    ..src > go
      var f float64 = 3 + 0i // complejo sin tipo -> float64
      f = 2                  // entero sin tipo -> float64
      f = 1e123              // punto flotante sin tipo -> float64
      f = 'a'                // runa sin tipo -> float64
    < src..

#     The statements above are thus equivalent to these:
    Las afirmaciones anteriores son, pues, equivalentes a estas:

#     ..src > go
#       var f float64 = float64(3 + 0i)
#       f = float64(2)
#       f = float64(1e123)
#       f = float64('a')
#     < src..
    ..src > go
      var f float64 = float64(3 + 0i)
      f = float64(2)
      f = float64(1e123)
      f = float64('a')
    < src..

#     Whether implicit or explicit, converting a constant from one type to another
#     requires that the target type can represent the original value. Rounding is
#     allowed for real and complex floating-point numbers:
    Ya sea implicita o explicitamente, la conversion de una constante de un tipo
    a otro requiere que el tipo de destino pueda representar el valor
    original. Se permite el redondeo para numeros reales y complejos de coma
    flotante:

#     ..src > go
#       const (
#         deadbeef = 0xdeadbeef // untyped int with value 3735928559
#         a = uint32(deadbeef)  // uint32 with value 3735928559
#         b = float32(deadbeef) // float32 with value 3735928576 (rounded up)
#         c = float64(deadbeef) // float64 with value 3735928559 (exact)
#         d = int32(deadbeef)   // compile error: constant overflows int32
#         e = float64(1e309)    // compile error: constant overflows float64
#         f = uint(-1)          // compile error: constant underflows uint
#       )
#     < src..
    ..src > go
      const (
        deadbeef = 0xdeadbeef // int sin tipo con valor 3735928559
        a = uint32(deadbeef)  // uint32 con valor 3735928559
        b = float32(deadbeef) // float32 con valor 3735928576 (rounded up)
        c = float64(deadbeef) // float64 con valor 3735928559 (exact)
        d = int32(deadbeef)   // error de compilacion: desbordamiento constante int32
        e = float64(1e309)    // error de compilacion: desbordamiento constante float64
        f = uint(-1)          // error de compilacion: subdesbordamiento constante uint
      )
    < src..

#     In a variable declaration without an explicit type (including short variable
#     declarations), the flavor of the untyped constant implicitly determines the
#     default type of the variable, as in these examples:
    En una declaracion de variable sin un tipo explicito (incluyendo declaracion
    de variables compacto), el sabor de la constante no tipificada determina
    implicitamente el tipo predeterminado de la variable, como en estos
    ejemplos:

#     ..src > go
#       i := 0      // untyped integer;        implicit int(0)
#       r := '\000' // untyped rune;           implicit rune('\000')
#       f := 0.0    // untyped floating-point; implicit float64(0.0)
#       c := 0i     // untyped complex;        implicit complex128(0i)
#     < src..
    ..src > go
      i := 0      // entero sin tipo;         int(0) implicitio
      r := '\000' // runa sin tipo;           rune('\000') implicitio
      f := 0.0    // punto flotante sin tipo; float64(0.0) implicitio
      c := 0i     // complejo sin tipo;       complex128(0i) implicitio
    < src..

#     Note the asymmetry: untyped integers are converted to @c(int), whose size is
#     not guaranteed, but untyped floating-point and complex numbers are converted
#     to the explicitly sized types @c(float64) and @c(complex128). The language
#     has no unsized @c(float) and @c(complex) types analogous to unsized @c(int),
#     because it is very difficult to write correct numerical algorithms without
#     knowing the size of one’s floating-point data types.
    Observese la asimetria: los enteros sin tipo se convierten en @c(int), cuyo
    tamaño no esta garantizado, pero los numeros de punto flotante y numeros
    complejos se convierten a los tipos de tamaño @c(float64) y @c(complex128)
    de forma explicita. El lenguaje no cuenta con tipos @c(float) y @c(complex)
    sin tamaño, analogos a @c(int) sin tamaño, porque es muy dificil escribir
    algoritmos numericos correctos sin conocer el tamaño de uno de los tipos de
    datos de punto flotante.

#     To give the variable a different type, we must explicitly convert the
#     untyped constant to the desired type or state the desired type in the
#     variable declaration, as in these examples:
    Para dar un tipo diferente a la variable, debemos convertir explicitamente
    la constante no tipificada en el tipo deseado o indicar el tipo deseado en
    la declaracion de variables, como en estos ejemplos:

#     ..src > go
#       var i = int8(0)
#       var i int8 = 0
#     < src..
    ..src > go
      var i = int8(0)
      var i int8 = 0
    < src..

#     These defaults are particularly important when converting an untyped
#     constant to an interface value (see @l(#Chapter 7)) since they determine its
#     dynamic type.
    Estos valores predeterminados son particularmente importantes cuando se
    convierte una constante sin tipo a un valor de interfaz (ver @l(#Capitulo
    7)) ya que determinan su tipo dinamico.

#     ..src > go
#       fmt.Printf("%T\n", 0)      // "int"
#       fmt.Printf("%T\n", 0.0)    // "float64"
#       fmt.Printf("%T\n", 0i)     // "complex128"
#       fmt.Printf("%T\n", '\000') // "int32" (rune)
#     < src..
    ..src > go
      fmt.Printf("%T\n", 0)      // "int"
      fmt.Printf("%T\n", 0.0)    // "float64"
      fmt.Printf("%T\n", 0i)     // "complex128"
      fmt.Printf("%T\n", '\000') // "int32" (rune)
    < src..

#     We’ve now covered the basic data types of Go. The next step is to show how
#     they can be combined into larger groupings like arrays and structs, and then
#     into data structures for solving real programming problems; that is the
#     topic of @l(#Chapter 4).
    Ahora hemos cubierto los tipos de datos basicos de Go. El siguiente paso es
    mostrar como se pueden combinar en agrupaciones mas grandes como arreglos y
    estructuras, y luego en estructuras de datos para resolver problemas de
    programacion real; ese es el tema del @l(#Capitulo 4).

# * Chapter 4 <> Composite Types
* Capitulo 4 <> Tipos Compuestos

#   In @l(#Chapter 3) we discussed the basic types that serve as building blocks
#   for data structures in a Go program; they are the atoms of our universe. In
#   this chapter, we’ll take a look at @e(composite) types, the molecules created
#   by combining the basic types in various ways. We’ll talk about four such
#   types—arrays, slices, maps, and structs—and at the end of the chapter, we’ll
#   show how structured data using these types can be encoded as and parsed from
#   JSON data and used to generate HTML from templates.
  En el @l(#Capitulo 3) hablamos de los tipos basicos que sirven como bloques de
  construccion para estructuras de datos en un programa Go; Son los atomos de
  nuestro universo. En este capitulo, vamos a echar un vistazo a los tipos
  @e(compuestos), las moleculas creadas mediante la combinacion de los tipos
  basicos de diversas maneras. Hablaremos de cuatro de estos tipos–arreglos,
  slices, mapas y estructuras–y al final del capitulo mostraremos como los datos
  estructurados que utilizan estos tipos pueden ser codificados y analizados a
  partir de datos JSON y usados ​​para generar HTML desde plantillas.

#   Arrays and structs are @e(aggregate) types; their values are concatenations of
#   other values in memory. Arrays are homogeneous—their elements all have the
#   same type—whereas structs are heterogeneous. Both arrays and structs are fixed
#   size. In contrast, slices and maps are dynamic data structures that grow as
#   values are added.
  Arreglos y estructuras son tipos de @e(agregados); Sus valores son
  concatenaciones de otros valores en la memoria. Los arreglos son homogeneos,
  sus elementos tienen el mismo tipo, mientras que las estructuras son
  heterogeneas. Los arreglos y las estructuras son de tamaño fijo. Por el
  contrario, slices y mapas son estructuras de datos dinamicas que crecen a
  medida que se agregan valores.

# ** Section 4.1 <> Arrays
** Seccion 4.1 <> Arreglos

#    An array is a fixed-length sequence of zero or more elements of a particular
#    type. Because of their fixed length, arrays are rarely used directly in
#    Go. Slices, which can grow and shrink, are much more versatile, but to
#    understand slices we must understand arrays first.
   Un arreglo es una secuencia de longitud fija de cero o mas elementos de un
   tipo particular. Debido a su longitud fija, en Go raramente se utilizan
   arreglos directamente. Los slices, pueden crecer y encogerse, son mucho mas
   versatiles, pero para entender los slices primero debemos entender los
   arreglos.

#    Individual array elements are accessed with the conventional subscript
#    notation, where subscripts run from zero to one less than the array
#    length. The built-in function @c(len) returns the number of elements in the
#    array.
   Los elementos individuales de arreglo se acceden con la notacion de
   subindices convencional, donde los subindices abarcan desde cero a uno menos
   que la longitud de la arreglo. La funcion nativa @c(len) devuelve el numero
   de elementos de la arreglo.

#    ..src > go
#      var a [3]int             // array of 3 integers
#      fmt.Println(a[0])        // print the first element
#      fmt.Println(a[len(a)-1]) // print the last element, a[2]
#
#      // Print the indices and elements.
#      for i, v := range a {
#        fmt.Printf("%d %d\n", i, v)
#      }
#
#      // Print the elements only.
#      for _, v := range a {
#        fmt.Printf("%d\n", v)
#      }
#    < src..
   ..src > go
     var a [3]int             // arreglo de 3 enteros
     fmt.Println(a[0])        // imprime el primer elemento
     fmt.Println(a[len(a)-1]) // imprime el ultime elemento, a[2]

     // imprimir los indices y elementos.
     for i, v := range a {
       fmt.Printf("%d %d\n", i, v)
     }

     // imprimir solo los elementos.
     for _, v := range a {
       fmt.Printf("%d\n", v)
     }
   < src..

#    By default, the elements of a new array variable are initially set to the
#    zero value for the element type, which is 0 for numbers. We can use an
#    @e(array literal) to initialize an array with a list of values:
   Por defecto, los elementos de un nuevo arreglo de variables estan
   configurados inicialmente a el valor cero para el tipo de elemento, que es 0
   para los numeros. Podemos utilizar un @e(arreglo literal) para inicializar un
   arreglo con una lista de valores:

#    ..src > go
#      var q [3]int = [3]int{1, 2, 3}
#      var r [3]int = [3]int{1, 2}
#      fmt.Println(r[2]) // "0"
#    < src..
   ..src > go
     var q [3]int = [3]int{1, 2, 3}
     var r [3]int = [3]int{1, 2}
     fmt.Println(r[2]) // "0"
   < src..

#    In an array literal, if an ellipsis @"(@c(...)) appears in place of the
#    length, the array length is determined by the number of initializers. The
#    definition of @c(q) can be simplified to
   En un arreglo literal, si aparece una elipsis @c("...") aparece en lugar de
   la longitud, la longitud del arreglo se determina por el numero de
   inicializadores. La definicion de @c(q) se puede simplificar como

#    ..src > go
#      q := [...]int{1, 2, 3}
#      fmt.Printf("%T\n", q) // "[3]int"
#    < src..
   ..src > go
     q := [...]int{1, 2, 3}
     fmt.Printf("%T\n", q) // "[3]int"
   < src..

#    The size of an array is part of its type, so @c([3]int) and @c([4]int) are
#    different types. The size must be a constant expression, that is, an
#    expression whose value can be computed as the program is being compiled.
   El tamaño de un arreglo es parte de su tipo, por lo que @c([3]int) y
   @c([4]int) son tipos diferentes. El tamaño debe ser una expresion constante,
   es decir, una expresion cuyo valor se puede calcular a medida que se esta
   compilando el programa.

#    ..src > go
#      q := [3]int{1, 2, 3}
#      q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int
#    < src..
   ..src > go
     q := [3]int{1, 2, 3}
     q = [4]int{1, 2, 3, 4} // error de compilacion: no puede asignar [4]int a [3]int
   < src..

#    As we’ll see, the literal syntax is similar for arrays, slices, maps, and
#    structs. The specific form above is a list of values in order, but it is also
#    possible to specify a list of index and value pairs, like this:
   Como veremos, la sintaxis literal es similar para arreglos, slices, mapas y
   estructuras. El formato especifico anterior es una lista de valores en
   orden, pero tambien es posible especificar una lista de pares de indice y
   valor, como aqui:

#    ..src > go
#      type Currency int
#
#      const (
#        USD Currency = iota
#        EUR
#        GBP
#        RMB
#      )
#      symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RMB: "¥"}
#
#      fmt.Println(RMB, symbol[RMB]) // "3 ¥"
#    < src..
   ..src > go
     type Currency int

     const (
       USD Currency = iota
       EUR
       GBP
       RMB
     )
     symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RMB: "¥"}

     fmt.Println(RMB, symbol[RMB]) // "3 ¥"
   < src..

#    In this form, indices can appear in any order and some may be omitted; as
#    before, unspecified values take on the zero value for the element type. For
#    instance,
   En esta forma, los indices pueden aparecer en cualquier orden y algunos
   pueden ser omitidos; Como antes, los valores no especificados toman el valor
   cero para el tipo de elemento. Por ejemplo,

#    ..src > go
#      r := [...]int{99: -1}
#    < src..
   ..src > go
     r := [...]int{99: -1}
   < src..

#    defines an array @c(r) with 100 elements, all zero except for the last, which
#    has value -1.
   define un arreglo @c(r) con 100 elementos, todos en cero excepto para el
   ultimo, que tiene un valor -1.

#    If an array’s element type is @e(comparable) then the array type is
#    comparable too, so we may directly compare two arrays of that type using the
#    @c(==) operator, which reports whether all corresponding elements are
#    equal. The @c(!=) operator is its negation.
   Si el tipo de los elementos de un arreglo es @e(comparable) entonces, el tipo
   del arreglo tambien es comparable, asi que podemos comparar directamente dos
   arreglos de ese tipo usando el operador @c(==), que informa de si todos los
   elementos correspondientes son iguales. El operador @c(!=) es su negacion.

#    ..src > go
#      a := [2]int{1, 2}
#      b := [...]int{1, 2}
#      c := [2]int{1, 3}
#      fmt.Println(a == b, a == c, b == c) // "true false false"
#      d := [3]int{1, 2}
#      fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
#    < src..
   ..src > go
     a := [2]int{1, 2}
     b := [...]int{1, 2}
     c := [2]int{1, 3}
     fmt.Println(a == b, a == c, b == c) // "true false false"
     d := [3]int{1, 2}
     fmt.Println(a == d) // error de compilacion: no puede comparar [2]int == [3]int
   < src..

#    As a more plausible example, the function @c(Sum256) in the @c(crypto/sha256)
#    package produces the SHA256 cryptographic hash or @e(digest) of a message
#    stored in an arbitrary byte slice. The digest has 256 bits, so its type is
#    @c([32]byte). If two digests are the same, it is extremely likely that the
#    two messages are the same; if the digests differ, the two messages are
#    different. This program prints and compares the SHA256 digests of @c("x") and
#    @c("X"):
   Como un ejemplo mas plausible, la funcion @c(Sum256) en el paquete
   @c(crypto/sha256) produce el @e(digest) o hash criptografico SHA256 o DIGEST
   de un mensaje almacenado en un slice arbitrario de bytes. El hash tiene 256
   bits, por lo que su tipo es @c([32]byte) . Si dos hash son los mismos, es muy
   probable que los dos mensajes sean iguales; Si los hash difieren, los dos
   mensajes son diferentes. Este programa imprime y compara los hash SHA256 de
   @c("x") y @c("X"):

#    ..figure > @l(gopl.io/ch4/sha256/main.go<>gopl.io/ch4/sha256)
   ..figure > @l(gopl.io/ch4/sha256/main.go<>gopl.io/ch4/sha256)

#      ..src > go
#        import "crypto/sha256"
#
#        func main() {
#          c1 := sha256.Sum256([]byte("x"))
#          c2 := sha256.Sum256([]byte("X"))
#          fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
#          // Output:
#          // 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
#          // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
#          // false
#          // [32]uint8
#        }
#      < src..
     ..src > go
       import "crypto/sha256"

       func main() {
         c1 := sha256.Sum256([]byte("x"))
         c2 := sha256.Sum256([]byte("X"))
         fmt.Printf("%x\n%x\n%t\n%T\n", c1, c2, c1 == c2, c1)
         // Output:
         // 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
         // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
         // false
         // [32]uint8
       }
     < src..


#    The two inputs differ by only a single bit, but approximately half the bits
#    are different in the digests. Notice the @c(Printf) verbs: @c(%x) to print
#    all the elements of an array or slice of bytes in hexadecimal, @c(%t) to show
#    a boolean, and @c(%T) to display the type of a value.
   Las dos entradas difieren por un solo bit, pero aproximadamente la mitad de
   los bits son diferentes en los hash. Note las verbos @c(Printf): @c(%x) para
   imprimir todos los elementos de un arreglo o una slice de bytes en
   hexadecimal, @c(%t) para mostrar un valor booleano, y @c(%T) para mostrar el
   tipo de un valor.

#    When a function is called, a copy of each argument value is assigned to the
#    corresponding parameter variable, so the function receives a copy, not the
#    original. Passing large arrays in this way can be inefficient, and any
#    changes that the function makes to array elements affect only the copy, not
#    the original. In this regard, Go treats arrays like any other type, but this
#    behavior is different from languages that implicitly pass arrays @e(by
#    reference).
   Cuando se llama a una funcion, se asigna una copia de cada valor de argumento
   a la variable de parametro correspondiente, por lo que la funcion recibe una
   copia, no el original. Pasar grandes arreglos de esta manera puede ser
   ineficiente, y cualquier cambio que la funcion hace a elementos de arreglo
   afectan solo a la copia, no al original. En este sentido, Go trata a los
   arreglos como a cualquier otro tipo, pero este comportamiento es diferente de
   otros lenguajes que implicitamente pasan arreglos por referencia.

#    Of course, we can explicitly pass a pointer to an array so that any
#    modifications the function makes to array elements will be visible to the
#    caller. This function zeroes the contents of a @c([32]byte) array:
   Por supuesto, podemos pasar explicitamente un puntero a un arreglo para que
   cualquier modificacion que la funcion hace a los elementos del arreglo sean
   visibles para quien llama a la funcion. Esta funcion pone a cero el contenido
   de un arreglo @c([32]byte):

#    ..src > go
#      func zero(ptr *[32]byte) {
#        for i := range ptr {
#          ptr[i] = 0
#        }
#      }
#    < src..
   ..src > go
     func zero(ptr *[32]byte) {
       for i := range ptr {
         ptr[i] = 0
       }
     }
   < src..

#    The array literal @c([32]byte{}) yields an array of 32 bytes. Each element of
#    the array has the zero value for @c(byte), which is zero. We can use that
#    fact to write a different version of @c(zero):
   El arreglo literal @c([32]byte{}) produce una serie de 32 bytes. Cada
   elemento del arreglo tiene el valor cero para @c(byte), que es cero. Podemos
   utilizar este hecho para escribir una version diferente de zero:

#    ..src > go
#      func zero(ptr *[32]byte) {
#        *ptr = [32]byte{}
#      }
#    < src..
   ..src > go
     func zero(ptr *[32]byte) {
       *ptr = [32]byte{}
     }
   < src..

#    Using a pointer to an array is efficient and allows the called function to
#    mutate the caller’s variable, but arrays are still inherently inflexible
#    because of their fixed size. The @c(zero) function will not accept a pointer
#    to a @c([16]byte) variable, for example, nor is there any way to add or
#    remove array elements. For these reasons, other than special cases like
#    SHA256’s fixed-size hash, arrays are seldom used as function parameters;
#    instead, we use slices.
   El uso de un puntero a un arreglo es eficiente y permite que la funcion
   llamada mute la variable de quien la llama, pero los arreglos son
   intrinsecamente inflexibles debido a su tamaño fijo. La funcion @c(zero) no
   aceptara un puntero a una variable @c([16]byte), por ejemplo, ni hay ninguna
   manera de añadir o eliminar elementos del arreglo. Por estas razones, aparte
   de casos especiales como el hash SHA256 de tamaño fijo, rara vez se usan
   arreglos como parametros de funcion; En su lugar, utilizamos slices.

#    @b(Exercise 4.1): Write a function that counts the number of bits that are
#    different in two SHA256 hashes. (See @c(PopCount) from @l(#Section 2.6.2).)
   @b(Ejercicio 4.1): Escribir una funcion que cuente el numero de bits que son
   diferentes en dos hash SHA256. (Ver @c(PopCount) en la @l(#Seccion 2.6.2).)

#    @b(Exercise 4.2): Write a program that prints the SHA256 hash of its standard
#    input by default but supports a command-line flag to print the SHA384 or
#    SHA512 hash instead.
   @b(Ejercicio 4.2): Escribir un programa que imprima el hash SHA256 de su
   entrada estandar por defecto, pero que accepte una bandera de linea de
   comando para imprimir tambien los hash SHA384 o SHA512.

# ** Section 4.2 <> Slices
** Seccion 4.2 <> Slices

#    Slices represent variable-length sequences whose elements all have the same
#    type. A slice type is written @c([]T), where the elements have type @c(T); it
#    looks like an array type without a size.
   Los slices representan secuencias de longitud variable cuyos elementos tienen
   todos el mismo tipo. Un tipo slice se escribe @c([]T), donde los elementos
   tienen el tipo @c(T); es como un tipo arreglo pero sin un tamaño.

#    Arrays and slices are intimately connected. A slice is a lightweight data
#    structure that gives access to a subsequence (or perhaps all) of the elements
#    of an array, which is known as the slice’s @e(underlying array). A slice has
#    three components: a pointer, a length, and a capacity. The pointer points to
#    the first element of the array that is reachable through the slice, which is
#    not necessarily the array’s first element. The length is the number of slice
#    elements; it can’t exceed the capacity, which is usually the number of
#    elements between the start of the slice and the end of the underlying
#    array. The built-in functions @c(len) and @c(cap) return those values.
   Arreglos y slices estan intimamente conectados. Un slice es una estructura de
   datos ligera que da acceso a una subsecuencia de (o tal vez todos) los
   elementos de un arreglo, que se conoce como @e(arreglo subyacente) del
   slice. Una slice tiene tres componentes: un puntero, una longitud y una
   capacidad. El puntero apunta al primer elemento del arreglo que se puede
   acceder a traves del slice, que no es necesariamente el primer elemento del
   arreglo. La longitud es el numero de elementos del slice; No puede exceder la
   capacidad, que suele ser el numero de elementos entre el inicio de la
   division y el final del arreglo subyacente. Las funciones nativas @c(len) y
   @c(cap) regresan esos valores.

#    Multiple slices can share the same underlying array and may refer to
#    overlapping parts of that array. Figure 4.1 shows an array of strings for the
#    months of the year, and two overlapping slices of it. The array is declared
#    as
   Multiples slices pueden compartir el mismo arreglo subyacente y pueden
   referirse a partes superpuestas de ese arreglo. La Figura 4.1 muestra un
   arreglo de cadenas para los meses del año, y dos slices superpuestos del
   mismo. El arreglo se declara como

#    ..src > go
#      months := [...]string{1: "January", /* ... */, 12: "December"}
#    < src..
   ..src > go
     meses := [...]string{1: "Enero", /* ... */, 12: "Diciembre"}
   < src..

#    so January is @c(months[1]) and December is @c(months[12]). Ordinarily, the
#    array element at index 0 would contain the first value, but because months
#    are always numbered from 1, we can leave it out of the declaration and it
#    will be initialized to an empty string.
   asi Enero es @c(meses[1]) y Diciembre es @c(meses[12]). Normalmente, el
   elemento de arreglo en el indice 0 contendria el primer valor, pero como los
   meses siempre estan numerados apartir de 1, podemos dejarlo fuera de la
   declaracion y se inicializara en una cadena vacia.

#    ..figure > Figure 4.1. Two overlapping slices of an array of months.
   ..figure > Figura 4.1. Dos slices superpuestos de un arreglo de meses.

#      ..img > img/Figure-4.1.jpg
     ..img > img/Figure-4.1.jpg


#    The @e(slice operator) @c(s[i:j]), where @c(0) ≤ @c(i) ≤ @c(j) ≤ @c[cap(s)],
#    creates a new slice that refers to elements @c(i) through @c(j-1) of the
#    sequence @c(s), which may be an array variable, a pointer to an array, or
#    another slice. The resulting slice has @c(j-i) elements. If @c(i) is omitted,
#    it’s 0, and if @c(j) is omitted, it’s @c[len(s)]. Thus the slice
#    @c(months[1:13]) refers to the whole range of valid months, as does the slice
#    @c(months[1:]); the slice @c(months[:]) refers to the whole array. Let’s
#    define overlapping slices for the second quarter and the northern summer:
   El @e(operador de slice) @c(s[i:j]), donde @c(0) ≤ @c(i) ≤ @c(j) ≤
   @c[cap(s)], crea un nuevo segmento que se refiere a los elementos de @c(i) a
   @c(j-1) de la secuencia @c(s), que puede ser una variable del arreglo, un
   puntero a un arreglo u otra porcion. El slice resultante tiene @c(j-i)
   elementos. Si @c(i) se omite, es 0, y si @c(j) se omite, es @c[len(s)]. Asi,
   el slice @c(meses[1:13]) se refiere a toda la gama de meses validos, como lo
   hace el slice @c(meses[1:]); el slice @c(meses[:]) se refiere a todo el
   arreglo. Vamos a definir slices superpuestos para el segundo trimestre y el
   verano boreal:

#    ..src > go
#      Q2 := months[4:7]
#      summer := months[6:9]
#      fmt.Println(Q2)     // ["April" "May" "June"]
#      fmt.Println(summer) // ["June" "July" "August"]
#    < src..
   ..src > go
     Q2 := meses[4:7]
     verano := meses[6:9]
     fmt.Println(Q2)     // ["Abril" "Mayo" "Junio"]
     fmt.Println(verano) // ["Junio" "Julio" "Augosto"]
   < src..

#    June is included in each and is the sole output of this (inefficient) test
#    for common elements:
   Junio ​​se incluye en ambos y es la unica salida de esta (ineficiente) prueba
   para elementos comunes:

#    ..src > go
#      for _, s := range summer {
#        for _, q := range Q2 {
#          if s == q {
#            fmt.Printf("%s appears in both\n", s)
#          }
#        }
#      }
#    < src..
   ..src > go
     for _, s := range verano {
       for _, q := range Q2 {
         if s == q {
           fmt.Printf("%s aparece en ambos\n", s)
         }
       }
     }
   < src..

#    Slicing beyond @c[cap(s)] causes a panic, but slicing beyond @c[len(s)]
#    extends the slice, so the result may be longer than the original:
   Seccionar mas alla de @c[cap(s)] causa un panico, pero seccionar mas alla
   @c[len(s)] extiende el slice, por lo que el resultado puede ser mas largo que
   el original:

#    ..src > go
#      fmt.Println(summer[:20])    // panic: out of range
#
#      endlessSummer := summer[:5] // extend a slice (within capacity)
#      fmt.Println(endlessSummer)  // "[June July August September October]"
#    < src..
   ..src > go
     fmt.Println(verano[:20])    // panico: fuera de rango

     veranoSinFin := verano[:5] // ampliar slice (dentro de la capacidad)
     fmt.Println(veranoSinFin)  // "[Junio Julio Augosto Septiembre Octubre]"
   < src..

#    As an aside, note the similarity of the substring operation on strings to the
#    slice operator on @c([]byte) slices. Both are written @c(x[m:n]), and both
#    return a subsequence of the original bytes, sharing the underlying
#    representation so that both operations take constant time. The expression
#    @c(x[m:n]) yields a string if @c(x) is a string, or a @c([]byte) if @c(x) is
#    a @c([]byte).
   Como anotacion, tenga en cuenta la similitud de la operacion de subcadena en
   cadenas con el operador slice en slices de @c([]byte). Ambos se escriben
   @c(x[m:n]), y ambos vuelven una subsecuencia de los bytes originales,
   compartiendo la representacion subyacente de modo que ambas operaciones toman
   tiempo constante. La expresion @c(x[m:n]) produce una cadena si @c(x) es una
   cadena, o un @c([]byte) si @c(x) es un @c([]byte).

#    Since a slice contains a pointer to an element of an array, passing a slice
#    to a function permits the function to modify the underlying array
#    elements. In other words, copying a slice creates an @e(alias) (@l(#Section
#    2.3.2<>§2.3.2)) for the underlying array. The function @c(reverse) reverses
#    the elements of an @c([]int) slice in place, and it may be applied to slices
#    of any length.
   Dado que un slice contiene un puntero a un elemento de un arreglo, el paso de
   un slice a una funcion permite a la funcion modificar los elementos del
   arreglo subyacente. En otras palabras, la copia de una slice crea un alias
   (@l(#Seccion 2.3.2<>§2.3.2)) para el arreglo subyacente. La funcion
   @c(reverse) invierte los elementos de un slice @c([]int) en su lugar, y se
   puede aplicar a slices de cualquier longitud.

#    ..figure > @l(gopl.io/ch4/rev/main.go<>gopl.io/ch4/rev)
   ..figure > @l(gopl.io/ch4/rev/main.go<>gopl.io/ch4/rev)

#      ..src > go
#        // reverse reverses a slice of ints in place.
#        func reverse(s []int) {
#          for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
#            s[i], s[j] = s[j], s[i]
#          }
#        }
#      < src..
     ..src > go
       // reverse invierte un slice de enteros en su posicion.
       func reverse(s []int) {
         for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
           s[i], s[j] = s[j], s[i]
         }
       }
     < src..


#    Here we reverse the whole array a:
   Aqui invertimos todo el conjunto:

#    ..src > go
#      a := [...]int{0, 1, 2, 3, 4, 5}
#      reverse(a[:])
#      fmt.Println(a) // "[5 4 3 2 1 0]"
#    < src..
   ..src > go
     a := [...]int{0, 1, 2, 3, 4, 5}
     reverse(a[:])
     fmt.Println(a) // "[5 4 3 2 1 0]"
   < src..

#    A simple way to @e(rotate) a slice left by @m(n) elements is to apply the
#    @c(reverse) function three times, first to the leading @m(n) elements, then
#    to the remaining elements, and finally to the whole slice. (To rotate to the
#    right, make the third call first.)
   Una forma sencilla de @e(rotar) un slice a la izquierda @m(n) elementos es
   aplicar la funcion @c(reverse) tres veces, primero a los @m(n) elementos
   iniciales, luego a los elementos restantes, y finalmente a todo el slice.
   (Para rotar a la derecha, primero haga la tercer llamada.)

#    ..src > go
#      s := []int{0, 1, 2, 3, 4, 5}
#      // Rotate s left by two positions.
#      reverse(s[:2])
#      reverse(s[2:])
#      reverse(s)
#      fmt.Println(s) // "[2 3 4 5 0 1]"
#    < src..
   ..src > go
     s := []int{0, 1, 2, 3, 4, 5}
     // rotar s a la izquierda dos posiciones.
     reverse(s[:2])
     reverse(s[2:])
     reverse(s)
     fmt.Println(s) // "[2 3 4 5 0 1]"
   < src..

#    Notice how the expression that initializes the slice @c(s) differs from that
#    for the array @c(a). A @e(slice literal) looks like an array literal, a
#    sequence of values separated by commas and surrounded by braces, but the size
#    is not given. This implicitly creates an array variable of the right size and
#    yields a slice that points to it. As with array literals, slice literals may
#    specify the values in order, or give their indices explicitly, or use a mix
#    of the two styles.
   Observe como la expresion que inicializa el slice @c(s) difiere de la del
   arreglo de @c(a). Una @e(slice literal) se ve similar a un arreglo literal,
   una secuencia de valores separados por comas y rodeada por llaves, pero el
   tamaño no se proporciona. Esto crea implicitamente una variable de arreglo
   del tamaño correcto y produce una division que apunta a el. Al igual que con
   los arreglos literales, los slices literales pueden especificar los valores
   en orden, o dar sus indices explicitamente, o usar una mezcla de los dos
   estilos.

#    Unlike arrays, slices are not comparable, so we cannot use @c(==) to test
#    whether two slices contain the same elements. The standard library provides
#    the highly optimized @c(bytes.Equal) function for comparing two slices of
#    bytes (@c([]byte)), but for other types of slice, we must do the comparison
#    ourselves:
   A diferencia de los arreglos, los slices no son comparables, por lo que no
   pueden usar @c(==) para probar si dos slices contienen los mismos elementos.
   La libreria estandar proporciona la funcion @c(bytes.Equal) altamente
   optimizada para comparar dos slices de bytes (@c([]byte)), pero para otros
   tipos de slice, tenemos que hacer la comparacion nosotros mismos:

#    ..src > go
#      func equal(x, y []string) bool {
#        if len(x) != len(y) {
#          return false
#        }
#        for i := range x {
#          if x[i] != y[i] {
#            return false
#          }
#        }
#        return true
#      }
#    < src..
   ..src > go
     func equal(x, y []string) bool {
       if len(x) != len(y) {
         return false
       }
       for i := range x {
         if x[i] != y[i] {
           return false
         }
       }
       return true
     }
   < src..

#    Given how natural this @"(deep) equality test is, and that it is no more
#    costly at run time than the @c(==) operator for arrays of strings, it may be
#    puzzling that slice comparisons do not also work this way. There are two
#    reasons why deep equivalence is problematic. First, unlike array elements,
#    the elements of a slice are indirect, making it possible for a slice to
#    contain itself.  Although there are ways to deal with such cases, none is
#    simple, efficient, and most importantly, obvious.
   En vista de lo natural, que es esta prueba de igualdad de la @"(profundidad),
   y que no es mas costosa en tiempo de ejecucion que el operador @c(==) para
   arreglos de cadenas, puede ser desconcertante que la comparacion de slice no
   funcionen tambien de esta manera. Hay dos razones por las cuales la
   equivalencia de profunda es problematica. En primer lugar, a diferencia de
   los elementos del arreglo, los elementos de un slice son indirectos, lo que
   hace posible que una slice se contenga a si mismo. Aunque hay maneras de
   tratar con tales casos, ninguno es simple, eficiente, y lo mas importante,
   obvio.

#    Second, because slice elements are indirect, a fixed slice value may contain
#    different elements at different times as the contents of the underlying array
#    are modified. Because a hash table such as Go’s map type makes only shallow
#    copies of its keys, it requires that equality for each key remain the same
#    throughout the lifetime of the hash table. Deep equivalence would thus make
#    slices unsuitable for use as map keys. For reference types like pointers and
#    channels, the @c(==) operator tests @e(reference identity), that is, whether
#    the two entities refer to the same thing. An analogous @"(shallow) equality
#    test for slices could be useful, and it would solve the problem with maps,
#    but the inconsistent treatment of slices and arrays by the @c(==) operator
#    would be confusing. The safest choice is to disallow slice comparisons
#    altogether.
   En segundo lugar, debido a que los elementos del slice son indirectos, un
   valor fijo del slice puede contener diferentes elementos en momentos
   diferentes a medida que se modifican los contenidos del arreglo
   subyacente. Dado que una tabla hash como el tipo de mapa de Go solo hace
   copias poco profundas de sus claves, requiere que la igualdad para cada clave
   permanezca igual durante toda la vida de la tabla hash. La equivalencia
   profunda haria asi que los slices no fueran adecuados para ser utilizados
   como mapas de claves. Para los tipos de referencia como punteros y canales,
   el operador @c(==) prueba la @e(identidad de la referencia), es decir, si las
   dos entidades se refieren a la misma cosa. Una prueba de igualdad
   @"(superficial) similar para slices podria ser util, y resolveria el problema
   con los mapas, pero el tratamiento inconsistente de slices y arreglos por el
   operador @c(==) seria confuso. La opcion mas segura es no permitir
   comparaciones de slices por completo.

#    The only legal slice comparison is against @c(nil), as in
   La unica comparacion legal en slices es contra @c(nil), como en

#    ..src > go
#      if summer == nil { /* ... */ }
#    < src..
   ..src > go
     if summer == nil { /* ... */ }
   < src..

#    The zero value of a slice type is @c(nil). A nil slice has no underlying
#    array. The nil slice has length and capacity zero, but there are also non-nil
#    slices of length and capacity zero, such as @c([]int{}) or @c{make([]int,
#    3)[3:]}. As with any type that can have nil values, the nil value of a
#    particular slice type can be written using a conversion expression such as
#    @c{[]int(nil)}.
   El valor cero de un tipo slice es @c(nil). Un slice nil no tiene arreglo
   subyacente. El slice nil tiene longitud y capacidad cero, pero tambien hay
   slices no nulos de longitud y capacidad cero, como @c([]int{}) o
   @c{make([]int, 3)[3:]}. Como con cualquier tipo que puede tener valores
   nulos, el valor nulo de un tipo de segmento particular puede ser escrito
   utilizando una expresion de conversion como @c{[]int(nil)}.

#    ..src > go
#      var s []int    // len(s) == 0, s == nil
#      s = nil        // len(s) == 0, s == nil
#      s = []int(nil) // len(s) == 0, s == nil
#      s = []int{}    // len(s) == 0, s != nil
#    < src..
   ..src > go
     var s []int    // len(s) == 0, s == nil
     s = nil        // len(s) == 0, s == nil
     s = []int(nil) // len(s) == 0, s == nil
     s = []int{}    // len(s) == 0, s != nil
   < src..

#    So, if you need to test whether a slice is empty, use @c[len(s) == 0], not
#    @c(s == nil). Other than comparing equal to @c(nil), a nil slice behaves like
#    any other zero-length slice; @c[reverse(nil)] is perfectly safe, for
#    example. Unless clearly documented to the contrary, Go functions should treat
#    all zero-length slices the same way, whether nil or non-nil.
   Por lo tanto, si usted necesita probar si una slice esta vacio, utilice
   @c[len(s) == 0], no @c(s == nil). Ademas de comparar la igualdad con @c(nil),
   una slice nil se comporta como cualquier otro slice de longitud cero; por
   ejemplo, @c[reverse(nil)] es perfectamente seguro. A menos que se demuestre
   claramente lo contrario, las funciones de Go deben tratar todos los slices de
   longitud cero de la misma manera, sea o no nulo.

#    The built-in function @c(make) creates a slice of a specified element type,
#    length, and capacity. The capacity argument may be omitted, in which case the
#    capacity equals the length.
   La funcion nativa @c(make) crea un slice de un tipo de elemento, con longitud
   y capacidad especifico. Se puede omitir el argumento capacidad, en cuyo caso
   la capacidad es igual a la longitud.

#    ..src > go
#      make([]T, len)
#      make([]T, len, cap) // same as make([]T, cap)[:len]
#    < src..
   ..src > go
     make([]T, len)
     make([]T, len, cap) // igual que make([]T, cap)[:len]
   < src..

#    Under the hood, @c(make) creates an unnamed array variable and returns a
#    slice of it; the array is accessible only through the returned slice. In the
#    first form, the slice is a view of the entire array. In the second, the slice
#    is a view of only the array’s first @c(len) elements, but its capacity
#    includes the entire array. The additional elements are set aside for future
#    growth.
   Bajo el capo, @c(make) crea una variable de arreglo sin nombre y devuelve un
   slice de este; El arreglo es accesible solo a traves del slice devuelto. En
   la primera forma, el slice es una vista de todo el arreglo. En el segundo, el
   slice es una vista de solo los primeros @c(len) elementos, pero su capacidad
   incluye toda el arreglo arreglo. Los elementos adicionales se reservan para
   el futuro crecimiento.

# *** Section 4.2.1 <> The @c(append) Function
*** Seccion 4.2.1 <> La Funcion @c(append)

#     The built-in @c(append) function appends items to slices:
    La funcion nativa @c(append) agrega elementos a slices:

#     ..src > go
#       var runes []rune
#       for _, r := range "Hello, 世界" {
#         runes = append(runes, r)
#       }
#       fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' 'B' 'F']"
#     < src..
    ..src > go
      var runes []rune
      for _, r := range "Hello, 世界" {
        runes = append(runes, r)
      }
      fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' 'B' 'F']"
    < src..

#     The loop uses @c(append) to build the slice of nine runes encoded by the
#     string literal, although this specific problem is more conveniently solved
#     by using the built-in conversion @c{[]rune("Hello, 世界")}.
    El bucle utiliza @c(append) para construir el slice codificado de nueve
    runas literales, aunque este problema especifico se resuelve mas
    convenientemente mediante el uso de la conversion nativa @c{[]rune("Hello,
    世界")}.

#     The @c(append) function is crucial to understanding how slices work, so
#     let’s take a look at what is going on. Here’s a version called @c(appendInt)
#     that is specialized for @c([]int) slices:
    La funcion @c(append) es crucial para la comprension de como trabajan los
    slices, asi que vamos a echar un vistazo a lo que esta pasando. Aqui hay una
    version llamada @c(appendInt) que se especializa en slices @c([]int):

#     ..figure > @l(gopl.io/ch4/append/main.go<>gopl.io/ch4/append)
    ..figure > @l(gopl.io/ch4/append/main.go<>gopl.io/ch4/append)

#       ..src > go
#         func appendInt(x []int, y int) []int {
#           var z []int
#           zlen := len(x) + 1
#           if zlen <= cap(x) {
#             // There is room to grow.  Extend the slice.
#             z = x[:zlen]
#           } else {
#             // There is insufficient space.  Allocate a new array.
#             // Grow by doubling, for amortized linear complexity.
#             zcap := zlen
#             if zcap < 2*len(x) {
#               zcap = 2 * len(x)
#             }
#             z = make([]int, zlen, zcap)
#             copy(z, x) // a built-in function; see text
#           }
#           z[len(x)] = y
#           return z
#         }
#       < src..
      ..src > go
        func appendInt(x []int, y int) []int {
          var z []int
          zlen := len(x) + 1
          if zlen <= cap(x) {
            // Hay espacio para crecer. Extiende el slice
            z = x[:zlen]
          } else {
            // No hay suficiente espacio.  Asigna un nuevo arreglo.
            // Crecer al doble, para compenzar la complejidad lineal.
            zcap := zlen
            if zcap < 2*len(x) {
              zcap = 2 * len(x)
            }
            z = make([]int, zlen, zcap)
            copy(z, x) // a built-in function; see text
          }
          z[len(x)] = y
          return z
        }
      < src..


#     Each call to @c(appendInt) must check whether the slice has sufficient
#     capacity to hold the new elements in the existing array. If so, it extends
#     the slice by defining a larger slice (still within the original array),
#     copies the element @c(y) into the new space, and returns the slice. The
#     input @c(x) and the result @c(z) share the same underlying array.
    Cada llamada a @c(appendInt) debe comprobar si el slice tiene capacidad
    suficiente para contener los nuevos elementos en el arreglo existente. Si es
    asi, se extiende el slice mediante la definicion de una slice mas grande
    (todavia dentro de la arreglo original), copia el elemento @c(y) en el nuevo
    espacio, y devuelve el slice. La entrada @c(x) y el resultado @c(z)
    comparten el misma arreglo subyacente.

#     If there is insufficient space for growth, @c(appendInt) must allocate a new
#     array big enough to hold the result, copy the values from @c(x) into it,
#     then append the new element @c(y). The result @c(z) now refers to a
#     different underlying array than the array that @c(x) refers to.
    Si no hay suficiente espacio para el crecimiento, @c(appendInt) debe asignar
    un nueva arreglo lo suficientemente grande para contener el resultado,
    copiar los valores de @c(x) en el y, a continuacion, añadir el nuevo
    elemento @c(y). Ahora el resultado @c(z) hace referencia a un arreglo
    subyacente diferente al que referia el arreglo @c(x).

#     It would be straightforward to copy the elements with explicit loops, but
#     it’s easier to use the built-in function @c(copy), which copies elements
#     from one slice to another of the same type. Its first argument is the
#     destination and its second is the source, resembling the order of operands
#     in an assignment like @c(dst = src). The slices may refer to the same
#     underlying array ; they may even overlap. Although we don’t use it here,
#     @c(copy) returns the number of elements actually copied, which is the
#     smaller of the two slice lengths, so there is no danger of running off the
#     end or overwriting something out of range.
    Seria facil copiar los elementos con bucles explicitas, pero es mas facil
    utilizar la funcion nativa @c(copy), que copia los elementos de un slice a
    otro del mismo tipo. Su primer argumento es el destino y el segundo es la
    fuente, parecido al orden de los operandos de una asignacion como @c(dst =
    src). Los slices pueden referirse al mismo arreglo subyacente; Incluso
    pueden superponerse. Aunque no lo usamos aqui, @c(copy) devuelve el numero
    de elementos copiados realmente, que es la longitud del menor de los slices,
    por lo que no hay peligro de se acabe o sobreescriba algo fuera del rango.

#     For efficiency, the new array is usually somewhat larger than the minimum
#     needed to hold @c(x) and @c(y). Expanding the array by doubling its size at
#     each expansion avoids an excessive number of allocations and ensures that
#     appending a single element takes constant time on average.  This program
#     demonstrates the effect:
    Por eficiencia, el nueva arreglo es generalmente algo mayor que el minimo
    necesario para almacenar @c(x) y @c(y). La expandir el arreglo duplicando su
    tamaño en cada expansion evita un numero excesivo de asignaciones y asegura
    que anexar un solo elemento tome un tiempo constante en promedio. Este
    programa demuestra el efecto:

    ..src > go
      func main() {
        var x, y []int
        for i := 0; i < 10; i++ {
          y = appendInt(x, i)
          fmt.Printf("%d cap=%d\t%v\n", i, cap(y), y)
          x = y
        }
      }
    < src..

#     Each change in capacity indicates an allocation and a copy:
    Cada cambio de capacidad indica una asignacion y una copia:

#     ..pre >
#       0  cap=1     [0]
#       1  cap=2     [0 1]
#       2  cap=4     [0 1 2]
#       3  cap=4     [0 1 2 3]
#       4  cap=8     [0 1 2 3 4]
#       5  cap=8     [0 1 2 3 4 5]
#       6  cap=8     [0 1 2 3 4 5 6]
#       7  cap=8     [0 1 2 3 4 5 6 7]
#       8  cap=16    [0 1 2 3 4 5 6 7 8]
#       9  cap=16    [0 1 2 3 4 5 6 7 8 9]
#     < pre..
    ..pre >
      0  cap=1     [0]
      1  cap=2     [0 1]
      2  cap=4     [0 1 2]
      3  cap=4     [0 1 2 3]
      4  cap=8     [0 1 2 3 4]
      5  cap=8     [0 1 2 3 4 5]
      6  cap=8     [0 1 2 3 4 5 6]
      7  cap=8     [0 1 2 3 4 5 6 7]
      8  cap=16    [0 1 2 3 4 5 6 7 8]
      9  cap=16    [0 1 2 3 4 5 6 7 8 9]
    < pre..


#     Let’s take a closer look at the @c(i=3) iteration. The slice @c(x) contains
#     the three elements @c([0 1 2]) but has capacity 4, so there is a single
#     element of slack at the end, and @c(appendInt) of the element 3 may proceed
#     without reallocating. The resulting slice @c(y) has length and capacity 4, and
#     has the same underlying array as the original slice @c(x), as Figure 4.2
#     shows.
    Echemos un vistazo mas cercano a la iteracion @c(i=3). El slice @c(x)
    contiene tres elementos @c([0 1 2]), pero tiene la capacidad de 4, por lo
    que hay un solo elemento de holgura en el extremo, y agrerar el elemento 3
    procede sin reasignacion en @c(appendInt). El slice @c(y) resultante tiene
    longitud y capacidad 4, y tiene el mismo arreglo subyacente que el slice
    @c(x) original, como lo muestra la Figura 4.2.

#     ..figure > Figure 4.2. Appending with room to grow.
    ..figure > Figura 4.2. Adicion con espacio para crecer.

#       ..img > img/Figure-4.2.jpg
      ..img > img/Figure-4.2.jpg


#     On the next iteration, @c(i=4), there is no slack at all, so @c(appendInt)
#     allocates a new array of size 8, copies the four elements @c([0 1 2 3]) of
#     @c(x), and appends 4, the value of @c(i). The resulting slice @c(y) has a
#     length of 5 but a capacity of 8; the slack of 3 will save the next three
#     iterations from the need to reallocate. The slices @c(y) and @c(x) are views
#     of different arrays. This operation is depicted in Figure 4.3.
    En la siguiente iteracion, @c(i=4), no hay holgura en absoluto, por lo que
    @c(appendInt) asigna un nueva arreglo de tamaño 8, copia los cuatro
    elementos de @c(x) (@c([0 1 2 3])), y agrega 4, el valor de @c(i). El slice
    resultante @c(y) tiene una longitud de 5, pero una capacidad de 8; La
    holgura de 3 guardara las siguientes tres iteraciones. Las slices @c(y) y
    @c(x) son vistas de diferentes arreglos. Esta operacion se muestra en la
    Figura 4.3.

#     ..figure > Figure 4.3. Appending without room to grow.
    ..figure > Figura 4.3. Adicion sin crear espacio.

#       ..img > img/Figure-4.3.jpg
      ..img > img/Figure-4.3.jpg


#     The built-in @c(append) function may use a more sophisticated growth
#     strategy than @c(appendInt)’s simplistic one. Usually we don’t know whether
#     a given call to @c(append) will cause a reallocation, so we can’t assume
#     that the original slice refers to the same array as the resulting slice, nor
#     that it refers to a different one. Similarly, we must not assume that
#     operations on elements of the old slice will (or will not) be reflected in
#     the new slice. As a result, it’s usual to assign the result of a call to
#     @c(append) to the same slice variable whose value we passed to @c(append):
    La funcion nativa @c(append) puede utilizar una estrategia de crecimiento
    mas sofisticado que la simplista @c(appendInt). Por lo general, no sabemos
    si una llamada a @c(append) provocara una reasignacion, asi que no podemos
    asumir que el slice original se refiere al mismo arreglo que el slice
    resultante, ni que este se refiere a uno diferente. Del mismo modo, no
    debemos suponer que las operaciones sobre los elementos del antiguo slice se
    reflejaran (o no) en la nuevo slice. Como resultado de ello, es habitual
    asignar el resultado de una llamada a @c(append) al mismo slice cuyo valor
    pasamos a @c(append):

#     ..src > go
#       runes = append(runes, r)
#     < src..
    ..src > go
      runes = append(runes, r)
    < src..

#     Updating the slice variable is required not just when calling @c(append), but
#     for any function that may change the length or capacity of a slice or make
#     it refer to a different underlying array. To use slices correctly, it’s
#     important to bear in mind that although the elements of the underlying array
#     are indirect, the slice’s pointer, length, and capacity are not. To update
#     them requires an assignment like the one above. In this respect, slices are
#     not @"(pure) reference types but resemble an aggregate type such as this
#     struct:
    La actualizacion de la variable slice se requiere no solo al llamar a
    @c(append), sino tambien a cualquier funcion que pueda cambiar la longitud o
    la capacidad de una slice o hacer que se refiere a un arreglo subyacente
    diferente. Para usar los slices correctamente, es importante tener en cuenta
    que aunque los elementos del arreglo subyacente son indirectos, el puntero,
    la longitud y la capacidad de la slice no lo son. Para actualizarlos se
    requiere una asignacion como la anterior. En este sentido, los slices no son
    los tipos de referencia @"(puros), sino que se asemejan a un tipo de
    agregado como esta estructura:

#     ..src > go
#       type IntSlice struct {
#         ptr      *int
#         len, cap int
#       }
#     < src..
    ..src > go
      type IntSlice struct {
        ptr      *int
        len, cap int
      }
    < src..

#     Our @c(appendInt) function adds a single element to a slice, but the
#     built-in @c(append) lets us add more than one new element, or even a whole
#     slice of them.
    Nuestra funcion @c(appendInt) añade un elemento a un slice, pero el
    @c(append) nativo nos permite añadir mas de un elemento nuevo, o incluso
    todo un slice de ellos.

#     ..src > go
#       var x []int
#       x = append(x, 1)
#       x = append(x, 2, 3)
#       x = append(x, 4, 5, 6)
#       x = append(x, x...) // append the slice x
#       fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
#     < src..
    ..src > go
      var x []int
      x = append(x, 1)
      x = append(x, 2, 3)
      x = append(x, 4, 5, 6)
      x = append(x, x...) // añade el slice x
      fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
    < src..

#     With the small modification shown below, we can match the behavior of the
#     built-in @c(append).  The ellipsis @"(@c(...)) in the declaration of
#     @c(appendInt) makes the function @e(variadic): it accepts any number of
#     final arguments. The corresponding ellipsis in the call above to @c(append)
#     shows how to supply a list of arguments from a slice. We’ll explain this
#     mechanism in detail in @l(#Section 5.7).
    Con la pequeña modificacion se muestra a continuacion, podemos hacer
    coincidir el comportamiento con el @c(append) nativo. Los puntos suspensivos
    (@c("...")) en la declaracion de @c(appendInt) crean una funcion
    @e(variadic): acepta cualquier numero de argumentos finales. Los puntos
    suspensivos en la llamada @c(append) anterior muestran como suministrar una
    lista de argumentos apartir de un slice. Vamos a explicar este mecanismo en
    detalle en la @l(#Seccion 5.7).

#     ..src > go
#       func appendInt(x []int, y ...int) []int {
#         var z []int
#         zlen := len(x) + len(y)
#         // ...expand z to at least zlen...
#         copy(z[len(x):], y)
#         return z
#       }
#     < src..
    ..src > go
      func appendInt(x []int, y ...int) []int {
        var z []int
        zlen := len(x) + len(y)
        // ...expand z to at least zlen...
        copy(z[len(x):], y)
        return z
      }
    < src..

#     The logic to expand @c(z)’s underlying array remains unchanged and is not
#     shown.
    La logica para expandir el arreglo @c(z) subyacente, se mantiene sin
    cambios y no se muestra.

# *** Section 4.2.2 <> In-Place Slice Techniques
*** Seccion 4.2.2 <> Tecnicas de Slices In Situ

#     Let’s see more examples of functions that, like @c(rotate) and @c(reverse),
#     modify the elements of a slice in place. Given a list of strings, the
#     @c(nonempty) function returns the non-empty ones:
    Veamos mas ejemplos de funciones que, como @c(rotate) y @c(reverse), modifican
    los elementos de un slice en su lugar. Dada una lista de cadenas, la
    funcion @c(nonempty) devuelve las que no estan vacias:

#     ..figure > @l(gopl.io/ch4/nonempty/main.go<>gopl.io/ch4/nonempty)
    ..figure > @l(gopl.io/ch4/nonempty/main.go<>gopl.io/ch4/nonempty)

#       ..src > go
#         // Nonempty is an example of an in-place slice algorithm.
#         package main
#
#         import "fmt"
#
#         // nonempty returns a slice holding only the non-empty strings.
#         // The underlying array is modified during the call.
#         func nonempty(strings []string) []string {
#           i := 0
#           for _, s := range strings {
#             if s != "" {
#               strings[i] = s
#               i++
#             }
#           }
#           return strings[:i]
#         }
#       < src..
      ..src > go
        // Nonempty es un ejemplo de algoritmo in situ.
        package main

        import "fmt"

        // nonempty regresa un slice que contiene solo las cadenas no vacias.
        // El arreglo subyacente se modifica durante la llamada.
        func nonempty(strings []string) []string {
          i := 0
          for _, s := range strings {
            if s != "" {
              strings[i] = s
              i++
            }
          }
          return strings[:i]
        }
      < src..


#     The subtle part is that the input slice and the output slice share the same
#     underlying array.  This avoids the need to allocate another array, though of
#     course the contents of @c(data) are partly overwritten, as evidenced by the
#     second print statement:
    La parte sutil es que la porcion de entrada y la porcion de salida comparten
    el mismo arreglo subyacente. Esto evita la necesidad de asignar otro
    arreglo, aunque por supuesto los contenidos de datos se sobrescriben en
    parte, como se evidencia por la segunda instruccion de impresion:

#     ..src > go
#       data := []string{"one", "", "three"}
#       fmt.Printf("%q\n", nonempty(data)) // `["one" "three"]`
#       fmt.Printf("%q\n", data)           // `["one" "three" "three"]`
#     < src..
    ..src > go
      data := []string{"uno", "", "tres"}
      fmt.Printf("%q\n", nonempty(data)) // `["uno" "tres"]`
      fmt.Printf("%q\n", data)           // `["uno" "tres" "tres"]`
    < src..

#     Thus we would usually write: @c[data = nonempty(data)].
    Por lo tanto normalmente escribe: @c[data = nonempty(data)].

#     The @c(nonempty) function can also be written using @c(append):
    La funcion @c(nonempty) tambien se puede escribir utilizando @c(append):

#     ..src > go
#       func nonempty2(strings []string) []string {
#         out := strings[:0] // zero-length slice of original
#         for _, s := range strings {
#           if s != "" {
#             out = append(out, s)
#           }
#         }
#         return out
#       }
#     < src..
    ..src > go
      func nonempty2(strings []string) []string {
        out := strings[:0] // slice del original con longitud cero
        for _, s := range strings {
          if s != "" {
            out = append(out, s)
          }
        }
        return out
      }
    < src..

#     Whichever variant we use, reusing an array in this way requires that at most
#     one output value is produced for each input value, which is true of many
#     algorithms that filter out elements of a sequence or combine adjacent
#     ones. Such intricate slice usage is the exception, not the rule, but it can
#     be clear, efficient, and useful on occasion.
    Cualquiera que sea la variante que utilicemos, la reutilizacion de un
    arreglo de este modo requiere que se produzca como maximo un valor de salida
    para cada valor de entrada, lo que es cierto para muchos algoritmos que
    filtran elementos de una secuencia o combinan elementos adyacentes. Este uso
    intrincado de un slice es la excepcion, no la regla, pero puede ser clara,
    eficiente y util en ocasiones.

#     A slice can be used to implement a stack. Given an initially empty slice
#     @c(stack), we can push a new value onto the end of the slice with
#     @c(append):
    Se puede usar un slice para implementar una pila. Dada que tenemos un slice
    vacio @c(stack), podemos empujar un nuevo valor en el extremo del slice con
    @c(append):

#     ..src > go
#       stack = append(stack, v) // push v
#     < src..
    ..src > go
      stack = append(stack, v) // push v
    < src..

#     The top of the stack is the last element:
    La parte superior del stack es el ultimo elemento:

#     ..src > go
#       top := stack[len(stack)-1] // top of stack
#     < src..
    ..src > go
      top := stack[len(stack)-1] // parte superior del stack
    < src..

#     and shrinking the stack by popping that element is
    y para  sacar el elemento del stack es

#     ..src > go
#       stack = stack[:len(stack)-1] // pop
#     < src..
    ..src > go
      stack = stack[:len(stack)-1] // sacar
    < src..

#     To remove an element from the middle of a slice, preserving the order of the
#     remaining elements, use @c(copy) to slide the higher-numbered elements down
#     by one to fill the gap:
    Para eliminar un elemento a la mitad de una slice, preservando el orden de
    los elementos restantes, utilice @c(copy) para deslizar los elementos de
    numeros mas altos hacia abajo por uno, para llenar el hueco:

#     ..src > go
#       func remove(slice []int, i int) []int {
#         copy(slice[i:], slice[i+1:])
#         return slice[:len(slice)-1]
#       }
#       func main() {
#         s := []int{5, 6, 7, 8, 9}
#         fmt.Println(remove(s, 2)) // "[5 6 8 9]"
#       }
#     < src..
    ..src > go
      func remove(slice []int, i int) []int {
        copy(slice[i:], slice[i+1:])
        return slice[:len(slice)-1]
      }
      func main() {
        s := []int{5, 6, 7, 8, 9}
        fmt.Println(remove(s, 2)) // "[5 6 8 9]"
      }
    < src..

#     And if we don’t need to preserve the order, we can just move the last
#     element into the gap:
    Y si no necesitamos preservar el orden, podemos solo mover el ultimo
    elemento al hueco:

#     ..src > go
#       func remove(slice []int, i int) []int {
#         slice[i] = slice[len(slice)-1]
#         return slice[:len(slice)-1]
#       }
#       func main() {
#         s := []int{5, 6, 7, 8, 9}
#         fmt.Println(remove(s, 2)) // "[5 6 9 8]
#       }
#     < src..
    ..src > go
      func remove(slice []int, i int) []int {
        slice[i] = slice[len(slice)-1]
        return slice[:len(slice)-1]
      }
      func main() {
        s := []int{5, 6, 7, 8, 9}
        fmt.Println(remove(s, 2)) // "[5 6 9 8]
      }
    < src..

#     @b(Exercise 4.3): Rewrite @c(reverse) to use an array pointer instead of a
#     slice.
   @b(Ejercicio 4.3): Reescribir @c(reverse) para utilizar un puntero a
   un arreglo en lugar de un slice.

#     @b(Exercise 4.4): Write a version of @c(rotate) that operates in a single
#     pass.
   @b(Ejercicio 4.4): Escribir una version de @c(rotate) que opere en una sola
   pasada.

#     @b(Exercise 4.5): Write an in-place function to eliminate adjacent
#     duplicates in a @c([]string) slice.
   @b(Ejercicio 4.5): Escribir una funcion in situ para eliminar duplicados
   adyacentes en una slice @c([]string).

#     @b(Exercise 4.6): Write an in-place function that squashes each run of
#     adjacent Unicode spaces (see @c(unicode.IsSpace)) in a UTF-8-encoded
#     @c([]byte) slice into a single ASCII space.
   @b(Ejercicio 4.6): Escribir una funcion in situ que aplaste cada sequencia
   Unicode de espacios adyacentes (ver @c(unicode.IsSpace)) en un slice
   @c([]byte) codificado en UTF-8 en solo espacio ASCII.

#     @b(Exercise 4.7): Modify @c(reverse) to reverse the characters of a
#     @c([]byte) slice that represents a UTF-8-encoded string, in place. Can you
#     do it without allocating new memory?
   @b(Ejercicio 4.7): Modificar @c(reverse) para invertir in situ los caracteres
   de una slice @c([]byte) que represente una cadena codificado en
   UTF-8. ¿Puedes hacerlo sin asignar nueva memoria?

# ** Section 4.3 <> Maps
** Seccion 4.3 <> Mapas

#    The hash table is one of the most ingenious and versatile of all data
#    structures. It is an unordered collection of key/value pairs in which all the
#    keys are distinct, and the value associated with a given key can be
#    retrieved, updated, or removed using a constant number of key comparisons on
#    the average, no matter how large the hash table.
   La tabla hash es una de las mas ingeniosas y versatiles de todas las
   estructuras de datos. Es una coleccion desordenada de pares clave/valor en la
   que todas las claves son distintas, y el valor asociado con una clave dada
   puede ser recuperado, actualizado o eliminado, usando un numero constante de
   comparaciones clave en promedio, no importa cuan grande sea el tamaño de la
   tabla hash.

#    In Go, a @e(map) is a reference to a hash table, and a map type is written
#    @c(map[K]V), where @c(K) and @c(V) are the types of its keys and values. All
#    of the keys in a given map are of the same type, and all of the values are of
#    the same type, but the keys need not be of the same type as the values. The
#    key type @c(K) must be comparable using @c(==), so that the map can test
#    whether a given key is equal to one already within it. Though floating-point
#    numbers are comparable, it’s a bad idea to compare floats for equality and,
#    as we mentioned in @l(#Chapter 3), especially bad if NaN is a possible
#    value. There are no restrictions on the value type @c(V).
   En Go, un @e(mapa) es una referencia a una tabla hash, y un tipo de mapa se
   escribe como @c(map[K]V), en donde @c(K) y @c(V) son los tipos de sus claves
   y valores. Todas las claves en un mapa son del mismo tipo, y todos los
   valores son del mismo tipo, pero las claves no necesitan ser del mismo tipo
   que los valores. El tipo de clave @c(K) debe ser comparable usando @c(==), de
   modo que el mapa puede probar si una clave dada es igual a una que ya esta
   dentro de ell. Aunque los numeros de punto flotante son comparables, es una
   mala idea comparar floats por igualdad y, como mencionamos en el @l(#Capitulo
   3), es especialmente malo si NaN es un valor posible. No hay restricciones
   sobre el tipo de valor @c(V).

#    The built-in function @c(make) can be used to create a map:
   Se puede utilizar la funcion nativa @c(make) para crear un mapa:

#    ..src > go
#      ages := make(map[string]int) // mapping from strings to ints
#    < src..
   ..src > go
     edades := make(map[string]int) // mapeo de cadenas a ints
   < src..

#    We can also use a @e(map literal) to create a new map populated with some
#    initial key/value pairs:
   Tambien podemos usar un @e(mapa literal) para crear un nuevo mapa poblada con
   algunos pares iniciales clave/valor:

#    ..src > go
#      ages := map[string]int{
#        "alice":   31,
#        "charlie": 34,
#      }
#    < src..
   ..src > go
     edades := map[string]int{
       "alice":   31,
       "charlie": 34,
     }
   < src..

#    This is equivalent to
   Esto es equivalente a

#    ..src > go
#      ages := make(map[string]int)
#      ages["alice"] = 31
#      ages["charlie"] = 34
#    < src..
   ..src > go
     edades := make(map[string]int)
     edades["alice"] = 31
     edades["charlie"] = 34
   < src..

#    so an alternative expression for a new empty map is @c(map[string]int{}).
   por lo que una expresion alternativa para un nuevo mapa vacio es
   @c(map[string]int{}).

#    Map elements are accessed through the usual subscript notation:
   Los elementos del mapa se acceden a traves de la notacion de subindice usual:

#    ..src > go
#      ages["alice"] = 32
#      fmt.Println(ages["alice"]) // "32"
#    < src..
   ..src > go
     edades["alice"] = 32
     fmt.Println(edades["alice"]) // "32"
   < src..

#    and removed with the built-in function @c(delete):
   y se remueve con la funcion nativa @c(delete):

#    ..src > go
#      delete(ages, "alice") // remove element ages["alice"]
#    < src..
   ..src > go
     delete(edades, "alice") // remover elemento ages["alice"]
   < src..

#    All of these operations are safe even if the element isn’t in the map; a map
#    lookup using a key that isn’t present returns the zero value for its type,
#    so, for instance, the following works even when @c("bob") is not yet a key in
#    the map because the value of @c(ages["bob"]) will be @c(0).
   Todas estas operaciones son seguras incluso si el elemento no esta en el
   mapa; una busqueda en el mapa utulizando una clave que no esta presente
   devuelve el valor cero para su tipo, por ejemplo, lo siguiente funciona
   incluso cuando @c("bob") aun no es una clave en el mapa, por lo que el valor
   de @c(edades["bob"]) sera 0.

#    ..src > go
#      ages["bob"] = ages["bob"] + 1 // happy birthday!
#    < src..
   ..src > go
     edades["bob"] = edades["bob"] + 1 // feliz cumpleaños!
   < src..

#    The shorthand assignment forms @c(x += y) and @c(x++) also work for map
#    elements, so we can rewrite the statement above as
   Las formas de asignacion abreviada @c(x += y) y @c(x++) tambien funcionan
   para elementos del mapa, asi que podemos rescribir la sentencia anterior como

#    ..src > go
#      ages["bob"] += 1
#    < src..
   ..src > go
     edades["bob"] += 1
   < src..

#    or even more concisely as
   O incluso mas conciso como

#    ..src > go
#      ages["bob"]++
#    < src..
   ..src > go
     edades["bob"]++
   < src..

#    But a map element is not a variable, and we cannot take its address:
   Pero un elemento del mapa no es una variable, y no podemos tomar su
   direccion:

#    ..src > go
#      _ = &ages["bob"] // compile error: cannot take address of map element
#    < src..
   ..src > go
     _ = &ages["bob"] // error de compilacion: no puede tomar la direccion del elemento mapa
   < src..

#    One reason that we can’t take the address of a map element is that growing a
#    map might cause rehashing of existing elements into new storage locations,
#    thus potentially invalidating the address.
   Una de las razones por las que no podemos tomar la direccion de un elemento
   de un mapa es que el crecimiento de un mapa podria provocar la reorganizacion
   de elementos existentes en nuevas ubicaciones de almacenamiento, lo que
   podria invalidar la direccion.

#    To enumerate all the key/value pairs in the map, we use a @c(range)-based
#    @c(for) loop similar to those we saw for slices. Successive iterations of the
#    loop cause the @c(name) and @c(age) variables to be set to the next key/value
#    pair:
   Para enumerar todos los pares clave/valor en el mapa, se utiliza un bucle
   @c(for) basado en @c(range) similar al que vimos para los slices. Las
   iteraciones sucesivas del bucle hacen que las variables @c(name) y @c(age) se
   establecen en el siguiente par clave/valor:

#    ..src > go
#      for name, age := range ages {
#        fmt.Printf("%s\t%d\n", name, age)
#      }
#    < src..
   ..src > go
     for nombre, edad := range edades {
       fmt.Printf("%s\t%d\n", nombre, edad)
     }
   < src..

#    The order of map iteration is unspecified, and different implementations
#    might use a different hash function, leading to a different ordering. In
#    practice, the order is random, varying from one execution to the next. This
#    is intentional; making the sequence vary helps force programs to be robust
#    across implementations. To enumerate the key/value pairs in order, we must
#    sort the keys explicitly, for instance, using the @c(Strings) function from
#    the @c(sort) package if the keys are strings. This is a common pattern:
   El orden de iteracion del mapa no se especifica, y las diferentes
   implementaciones pueden utilizar una funcion de hash diferente, lo que
   conduce a un orden diferente. En la practica, el orden es aleatorio, variando
   de una ejecucion a la siguiente. Esto es intencional; Haciendo que la
   secuencia varie ayuda a obligar a los programas a ser robustos en todas las
   implementaciones. Para enumerar los pares clave/valor en orden, hay que
   ordenar las claves de forma explicita, por ejemplo, mediante la funcion
   @c(Strings) del paquete @c(sort) si las claves son cadenas. Este es un patron
   comun:

#    ..src > go
#      import "sort"
#
#      var names []string
#      for name := range ages {
#        names = append(names, name)
#      }
#      sort.Strings(names)
#      for _, name := range names {
#        fmt.Printf("%s\t%d\n", name, ages[name])
#      }
#    < src..
   ..src > go
     import "sort"

     var nombres []string
     for nombre := range edades {
       nombres = append(nombres, nombre)
     }

     sort.Strings(nombres)
     for _, nombre := range nombres {
       fmt.Printf("%s\t%d\n", nombre, edades[nombre])
     }
   < src..

#    Since we know the final size of @c(names) from the outset, it is more
#    efficient to allocate an array of the required size up front. The statement
#    below creates a slice that is initially empty but has sufficient capacity to
#    hold all the keys of the @c(ages) map:
   Dado que sabemos el tamaño final de nombres desde el principio, es mas
   eficiente asignar un arreglo del tamaño requerido por adelantado. La
   siguiente declaracion crea un slice que esta inicialmente vacio, pero tiene
   la capacidad suficiente para contener todas las llaves del mapa @e(edades):

#    ..src > go
#      names := make([]string, 0, len(ages))
#    < src..
   ..src > go
     nombres := make([]string, 0, len(edades))
   < src..

#    In the first @c(range) loop above, we require only the keys of the @c(ages)
#    map, so we omit the second loop variable. In the second loop, we require only
#    the elements of the @c(names) slice, so we use the blank identifier @c(_) to
#    ignore the first variable, the index.
   En el primer @c(range) del bucle anterior, solo necesitamos las llaves claves
   del mapa @c(edades), por lo que se omite la segunda variable de bucle. En el
   segundo bucle, se requieren solo los elementos del slice @c(nombres), por lo
   que se utiliza el identificador en blanco @c(_) para ignorar la primer
   variable, el indice.

#    The zero value for a map type is @c(nil), that is, a reference to no hash
#    table at all.
   El valor cero para el tipo de un mapa es @c(nil), es decir, una referencia a
   ninguna tabla hash en absoluto.

#    ..src > go
#      var ages map[string]int
#      fmt.Println(ages == nil)    // "true"
#      fmt.Println(len(ages) == 0) // "true"
#    < src..
   ..src > go
     var edades map[string]int
     fmt.Println(edades == nil)    // "true"
     fmt.Println(len(edades) == 0) // "true"
   < src..

#    Most operations on maps, including lookup, @c(delete), @c(len), and @c(range)
#    loops, are safe to perform on a nil map reference, since it behaves like an
#    empty map. But storing to a nil map causes a panic:
   La mayoria de las operaciones en los mapas, incluyendo las operaciones de
   busqueda, @c(delete), @c(len) y bucles @c(range), son seguros para llevar a
   cabo en un mapa de referencia a @c(nil), ya que se comporta como un mapa
   vacio. Pero almacenar en un mapa nil provoca un panico:

#    ..src > go
#      ages["carol"] = 21 // panic: assignment to entry in nil map
#    < src..
   ..src > go
     ages["carol"] = 21 // panic: assignment to entry in nil map
   < src..

#    You must allocate the map before you can store into it.
   Debe asignar el mapa antes de poder almacenarlo.

#    Accessing a map element by subscripting always yields a value. If the key is
#    present in the map, you get the corresponding value; if not, you get the zero
#    value for the element type, as we saw with @c(ages["bob"]). For many purposes
#    that’s fine, but sometimes you need to know whether the element was really
#    there or not. For example, if the element type is numeric, you might have to
#    distinguish between a nonexistent element and an element that happens to have
#    the value zero, using a test like this:
   El acceso a un elemento de un mapa mediante subindice siempre produce un
   valor. Si la clave esta presente en el mapa, se obtiene el valor
   correspondiente; si no, se obtiene el valor cero para el tipo de elemento,
   como hemos visto con @c(edades["bob"]). Para muchos propositos eso esta bien,
   pero a veces necesitas saber si el elemento estaba realmente ahi o no. Por
   ejemplo, si el tipo de elemento es numerico, es posible que tenga que
   distinguir entre un elemento inexistente y un elemento que tiene el valor
   cero, mediante una prueba como esta:

#    ..src > go
#      age, ok := ages["bob"]
#      if !ok { /* "bob" is not a key in this map; age == 0. */ }
#    < src..
   ..src > go
     edad, ok := edades["bob"]
     if !ok { /* "bob" no es una clave en este mapa; edad == 0. */ }
   < src..

#    You’ll often see these two statements combined, like this:
   A menudo vera estas dos afirmaciones combinadas, como aqui:

#    ..src > go
#      if age, ok := ages["bob"]; !ok { /* ... */ }
#    < src..
   ..src > go
     if age, ok := ages["bob"]; !ok { /* ... */ }
   < src..

#    Subscripting a map in this context yields two values; the second is a boolean
#    that reports whether the element was present. The boolean variable is often
#    called @c(ok), especially if it is immediately used in an @c(if) condition.
   El subindice de un mapa en este contexto produce dos valores; El segundo es
   un booleano que informa si el elemento estaba presente. La variable booleana
   a menudo se denomina @c(ok), especialmente si se utiliza inmediatamente en
   una condicion @c(if).

#    As with slices, maps cannot be compared to each other; the only legal
#    comparison is with @c(nil). To test whether two maps contain the same keys
#    and the same associated values, we must write a loop:
   Como con los slices, los mapas no pueden ser compararse uno con otro; la
   unica comparacion legal es con @c(nil). Para probar si dos mapas contienen
   las mismas claves y los mismos valores asociados, debemos escribir un bucle:

#    ..src > go
#      func equal(x, y map[string]int) bool {
#        if len(x) != len(y) {
#          return false
#        }
#        for k, xv := range x {
#          if yv, ok := y[k]; !ok || yv != xv {
#            return false
#          }
#        }
#        return true
#      }
#    < src..
   ..src > go
     func equal(x, y map[string]int) bool {
       if len(x) != len(y) {
         return false
       }
       for k, xv := range x {
         if yv, ok := y[k]; !ok || yv != xv {
           return false
         }
       }
       return true
     }
   < src..

#    Observe how we use @c(!ok) to distinguish the @"(missing) and @"(present but
#    zero) cases. Had we naïvely written @c(xv != y[k]), the call below would
#    incorrectly report its arguments as equal:
   Observe como se utiliza @c(!ok) para distinguir los casos @"(que faltan) y
   los @"(presentes, pero en cero). Si hubieramos escrito ingenuamente @c(xv !=
   y[k]), la llamada de abajo reportaria incorrectamente sus argumentos como
   iguales:

#    ..src > go
#      // True if equal is written incorrectly.
#      equal(map[string]int{"A": 0}, map[string]int{"B": 42})
#    < src..
   ..src > go
     // Verdadero si equal esta escrito incorrectamente.
     equal(map[string]int{"A": 0}, map[string]int{"B": 42})
   < src..

#    Go does not provide a @c(set) type, but since the keys of a map are distinct,
#    a map can serve this purpose. To illustrate, the program @$(dedup) reads a
#    sequence of lines and prints only the first occurrence of each distinct
#    line. (It’s a variant of the @$(dup) program that we showed in @l(#Section
#    1.3).)  The @$(dedup) program uses a map whose keys represent the set of
#    lines that have already appeared to ensure that subsequent occurrences are
#    not printed.
   Go no proporciona un tipo @c(set), pero ya que las claves de un mapa son
   distintas, un mapa puede servir a este proposito. Para ilustrarlo, el
   programa @$(dedup) lee una secuencia de lineas e imprime solo la primera
   ocurrencia de cada linea distinta. (Es una variante del programa @$(dup) que
   mostramos en la @l(#Seccion 1.3)). El programa @$(dedup) utiliza un mapa
   cuyas claves representan el conjunto de lineas que ya han aparecido para
   asegurar que las ocurrencias posteriores no se impriman.

#    ..figure > @l(gopl.io/ch4/dedup/main.go<>gopl.io/ch4/dedup)
   ..figure > @l(gopl.io/ch4/dedup/main.go<>gopl.io/ch4/dedup)

#      ..src > go
#        func main() {
#          seen := make(map[string]bool) // a set of strings
#          input := bufio.NewScanner(os.Stdin)
#          for input.Scan() {
#            line := input.Text()
#            if !seen[line] {
#              seen[line] = true
#              fmt.Println(line)
#            }
#          }
#
#          if err := input.Err(); err != nil {
#            fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
#            os.Exit(1)
#          }
#        }
#      < src..
     ..src > go
       func main() {
         consulta := make(map[string]bool) // un conjunto de cadenas
         entrada  := bufio.NewScanner(os.Stdin)
         for entrada.Scan() {
           linea := input.Text()
           if !consulta[linea] {
             consulta[linea] = true
             fmt.Println(linea)
           }
         }

         if err := entrada.Err(); err != nil {
           fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
           os.Exit(1)
         }
       }
     < src..


#    Go programmers often describe a map used in this fashion as a @"(set of
#    strings) without further ado, but beware, not all @c(map[string]bool) values
#    are simple sets; some may contain both @c(true) and @c(false) values.
   Los programadores de Go a menudo describen un mapa de esta manera
   utilizandolo como un @"(conjunto de cadenas) sin mas preambulos, pero
   cuidado, no todo los valores @c(map[string]bool) son conjuntos simples;
   algunos pueden contener valores tanto @c(true) y @c(false).

#    Sometimes we need a map or set whose keys are slices, but because a map’s
#    keys must be comparable, this cannot be expressed directly. However, it can
#    be done in two steps. First we define a helper function @c(k) that maps each
#    key to a string, with the property that @c[k(x) == k(y)] if and only if we
#    consider @c(x) and @c(y) equivalent. Then we create a map whose keys are
#    strings, applying the helper function to each key before we access the map.
   A veces necesitamos un mapa o conjunto cuyas claves sean slices, pero ya que
   las claves de un mapa deben ser comparables, esto se no puede expresar
   directamente. Sin embargo, se puede hacer en dos pasos. Primero definimos una
   funcion auxiliar @c(k) que mapea cada clave en una cadena, con la
   caracteristica que @c[k(x) == k(y)] si y solo si consideramos @c(x) e @c(y)
   equivalentes. Luego creamos un mapa cuyas claves son cadenas, aplicando la
   funcion auxiliar a cada clave antes de acceder al mapa.

#    The example below uses a map to record the number of times @c(Add) has been
#    called with a given list of strings. It uses @c(fmt.Sprintf) to convert a
#    slice of strings into a single string that is a suitable map key, quoting
#    each slice element with @c(%q) to record string boundaries faithfully:
   El siguiente ejemplo utiliza un mapa para registrar el numero de veces que se
   ha llamado a @c(Add) con una lista dada de cadenas. Utiliza @c(fmt.Sprintf)
   para convertir un slice de cadenas en una sola cadena que es una clave de
   mapa adecuada, citando cada elemento del slice con @c(%q) para registrar los
   limites de las cadena fielmente:

#    ..src > go
#      var m = make(map[string]int)
#
#      func k(list []string) string  { return fmt.Sprintf("%q", list) }
#
#      func Add(list []string)       { m[k(list)]++ }
#      func Count(list []string) int { return m[k(list)] }
#    < src..
   ..src > go
     var m = make(map[string]int)

     func k(list []string) string  { return fmt.Sprintf("%q", list) }

     func Add(list []string)       { m[k(list)]++ }
     func Count(list []string) int { return m[k(list)] }
   < src..

#    The same approach can be used for any non-comparable key type, not just
#    slices. It’s even useful for comparable key types when you want a definition
#    of equality other than @c(==), such as case-insensitive comparisons for
#    strings. And the type of @c[k(x)] needn’t be a string; any comparable type
#    with the desired equivalence property will do, such as integers, arrays, or
#    structs.
   El mismo enfoque se puede utilizar para cualquier tipo de clave no
   comparable, no solo para slices. Incluso es util para este tipo de claves
   comparables cuando se desea una definicion de igualdad distinta de @c(==),
   como comparaciones entre mayusculas y minusculas para cadenas. Y el tipo de
   @c[k(x)] no necesita ser una cadena; Cualquier tipo comparable con la
   propiedad de equivalencia deseada lo hara, como enteros, arreglos o
   estructuras.

#    Here’s another example of maps in action, a program that counts the
#    occurrences of each distinct Unicode code point in its input. Since there are
#    a large number of possible characters, only a small fraction of which would
#    appear in any particular document, a map is a natural way to keep track of
#    just the ones that have been seen and their corresponding counts.
   Aqui hay otro ejemplo de mapas en accion, un programa que cuenta las
   apariciones de cada punto de codigo Unicode distinto en su entrada. Puesto
   que hay un gran numero de caracteres posibles, solo una pequeña fraccion de
   ellos aparecera en cualquier documento en particular, un mapa es una manera
   natural de hacer un seguimiento de solo los que se han visto y su conteo
   correspondiente.

#    ..figure > @l(gopl.io/ch4/charcount/main.go<>gopl.io/ch4/charcount)
   ..figure > @l(gopl.io/ch4/charcount/main.go<>gopl.io/ch4/charcount)

#      ..src > go
#        // Charcount computes counts of Unicode characters.
#        package main
#
#        import (
#          "bufio"
#          "fmt"
#          "io"
#          "os"
#          "unicode"
#          "unicode/utf8"
#        )
#
#        func main() {
#          counts := make(map[rune]int)    // counts of Unicode characters
#          var utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodings
#          invalid := 0                    // count of invalid UTF-8 characters
#
#          in := bufio.NewReader(os.Stdin)
#          for {
#            r, n, err := in.ReadRune()    // returns rune, nbytes, error
#            if err == io.EOF {
#              break
#            }
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "charcount: %v\n", err)
#              os.Exit(1)
#            }
#            if r == unicode.ReplacementChar && n == 1 {
#              invalid++
#              continue
#            }
#            counts[r]++
#            utflen[n]++
#          }
#          fmt.Printf("rune\tcount\n")
#          for c, n := range counts {
#            fmt.Printf("%q\t%d\n", c, n)
#          }
#          fmt.Print("\nlen\tcount\n")
#          for i, n := range utflen {
#            if i > 0 {
#              fmt.Printf("%d\t%d\n", i, n)
#            }
#          }
#          if invalid > 0 {
#            fmt.Printf("\n%d invalid UTF-8 characters\n", invalid)
#          }
#        }
#      < src..
     ..src > go
       // Charcount calcula la cuenta de caracteres Unicode.
       package main

       import (
         "bufio"
         "fmt"
         "io"
         "os"
         "unicode"
         "unicode/utf8"
       )

       func main() {
         counts := make(map[rune]int)    // cuenta de caracteres Unicode
         var utflen [utf8.UTFMax + 1]int // cuenta de longitudes de codificaciones UTF-8
         invalid := 0                    // cuenta de caracteres UTF-8 invalidos

         in := bufio.NewReader(os.Stdin)
         for {
           r, n, err := in.ReadRune()    // regresa runa, nbytes, error
           if err == io.EOF {
             break
           }
           if err != nil {
             fmt.Fprintf(os.Stderr, "charcount: %v\n", err)
             os.Exit(1)
           }
           if r == unicode.ReplacementChar && n == 1 {
             invalid++
             continue
           }
           counts[r]++
           utflen[n]++
         }
         fmt.Printf("rune\tcount\n")
         for c, n := range counts {
           fmt.Printf("%q\t%d\n", c, n)
         }
         fmt.Print("\nlen\tcount\n")
         for i, n := range utflen {
           if i > 0 {
             fmt.Printf("%d\t%d\n", i, n)
           }
         }
         if invalid > 0 {
           fmt.Printf("\n%d invalid UTF-8 characters\n", invalid)
         }
       }
     < src..


#    The @c(ReadRune) method performs UTF-8 decoding and returns three values: the
#    decoded rune, the length in bytes of its UTF-8 encoding, and an error
#    value. The only error we expect is end-of-file. If the input was not a legal
#    UTF-8 encoding of a rune, the returned rune is @c(unicode.ReplacementChar)
#    and the length is 1.
   El metodo @c(ReadRune) realiza la decodificacion UTF-8 y devuelve tres
   valores: la runa decodificada, la longitud en bytes de su codificacion UTF-8,
   y un valor de error. El unico error que esperamos es el fin de archivo. Si la
   entrada no era la codificacion UTF-8 legal de una runa, la runa devuelta es
   @c(unicode.ReplacementChar) y la su longitud es 1.

#    The @$(charcount) program also prints a count of the lengths of the UTF-8
#    encodings of the runes that appeared in the input. A map is not the best data
#    structure for that; since encoding lengths range only from 1 to @c(utf8.UTFMax)
#    (which has the value 4), an array is more compact.
   El programa @$(charcount) tambien imprime un recuento de las longitudes de
   las codificaciones UTF-8 de las runas que aparecieron en la entrada. Un mapa
   no es la mejor estructura de datos para eso; ya que las longitudes de
   codificacion varian solo de 1 a utf8.UTFMax (que tiene el valor 4), un
   arreglo es mas compacto.

#    As an experiment, we ran @$(charcount) on this book itself at one
#    point. Although it’s mostly in English, of course, it does have a fair number
#    of non-ASCII characters. Here are the top ten:
   Como un experimento, en un momento ejecutamos @$(charcount). Aunque
   (originalmente) esta principalmente en Ingles, por supuesto, tiene un buen
   numero de caracteres no ASCII. Aqui estan los diez primeros:

#    ..pre >
#      ° 27 世 15 界 14 é 13 ˣ 10 ≤ 5 × 5 𢉩 4 � 4 □ 3
   ..pre >
     ° 27 世 15 界 14 é 13 ˣ 10 ≤ 5 × 5 𢉩 4 � 4 □ 3

#    and here is the distribution of the lengths of all the UTF-8 encodings:
   Y aqui esta la distribucion de las longitudes de todas las codificaciones
   UTF-8:

#    ..pre >
#      len  count
#      1    765391
#      2    60
#      3    70
#      4    0
#    < pre..
   ..pre >
     len  count
     1    765391
     2    60
     3    70
     4    0
   < pre..

#    The value type of a map can itself be a composite type, such as a map or
#    slice. In the following code, the key type of @c(graph) is @c(string) and the
#    value type is @c(map[string]bool), representing a set of strings.
#    Conceptually, @c(graph) maps a string to a set of related strings, its
#    successors in a directed graph.
   El tipo de valor de un mapa puede ser un tipo compuesto, como un mapa o un
   slice. En el siguiente codigo, el tipo de la clave de @c(graph) es @c(string)
   y el tipo de valor es @c(map[string]bool), lo que representa un conjunto de
   cadenas. Conceptualmente, @c(graph) asigna una cadena a un conjunto de cadenas
   relacionadas, sus sucesores en un grafo dirigido.

#    ..figure > @l(gopl.io/ch4/graph/main.go<>gopl.io/ch4/graph)
   ..figure > @l(gopl.io/ch4/graph/main.go<>gopl.io/ch4/graph)

#      ..src > go
#        var graph = make(map[string]map[string]bool)
#
#        func addEdge(from, to string) {
#          edges := graph[from]
#          if edges == nil {
#            edges = make(map[string]bool)
#            graph[from] = edges
#          }
#          edges[to] = true
#        }
#
#        func hasEdge(from, to string) bool {
#          return graph[from][to]
#        }
#      < src..
     ..src > go
       var graph = make(map[string]map[string]bool)

       func addEdge(from, to string) {
         edges := graph[from]
         if edges == nil {
           edges = make(map[string]bool)
           graph[from] = edges
         }
         edges[to] = true
       }

       func hasEdge(from, to string) bool {
         return graph[from][to]
       }
     < src..


#    The @c(addEdge) function shows the idiomatic way to populate a map lazily,
#    that is, to initialize each value as its key appears for the first time. The
#    @c(hasEdge) function shows how the zero value of a missing map entry is often
#    put to work: even if neither @c(from) nor @c(to) is present,
#    @c(graph[from][to]) will always give a meaningful result.
   La funcion @c(addEdge) muestra la forma idiomatica para poblar un mapa
   perezosamente, es decir, para inicializar cada valor como su clave cuando
   aparece por primera vez. La funcion @c(hasEdge) muestra como el valor cero de
   una entrada del mapa que falta se pone a trabajar: incluso si no estan
   precentes ni @c(from) ni @c(to), @c(graph[from][to]) siempre dara un
   resultado significativo.

#    @b(Exercise 4.8): Modify @$(charcount) to count letters, digits, and so on in
#    their Unicode categories, using functions like @c(unicode.IsLetter).
   @b(Ejercicio 4.8): Modificar @$(charcount) para contar letras, digitos, y
   demas en sus categorias Unicode, utilizando funciones como
   @c(unicode.IsLetter).

#    @b(Exercise 4.9): Write a program @$(wordfreq) to report the frequency of
#    each word in an input text file. Call @c[input.Split(bufio.ScanWords)] before
#    the first call to @c(Scan) to break the input into words instead of lines.
   @b(Ejercicio 4.9): Escribir un programa @$(wordfreq) para reportar la
   frecuencia de cada palabra en un archivo de texto de entrada. Llamar a
   @c[input.Split(bufio.ScanWords)] antes de la primer llamada a @c(Scan) para
   romper la entrada en palabras en lugar de lineas.

# ** Section 4.4 <> Structs
** Seccion 4.4 <> Estructuras

#    A @e(struct) is an aggregate data type that groups together zero or more
#    named values of arbitrary types as a single entity. Each value is called a
#    @e(field). The classic example of a struct from data processing is the
#    employee record, whose fields are a unique ID, the employee’s name, address,
#    date of birth, position, salary, manager, and the like. All of these fields
#    are collected into a single entity that can be copied as a unit, passed to
#    functions and returned by them, stored in arrays, and so on.
   Una @e(estructura) es un tipo de datos agregada que agrupa de cero a mas
   valores con nombre de tipos arbitrarios como una entidad unica. Cada valor se
   denomina @e(campo). El ejemplo clasico de una estructura de procesamiento de
   datos es el registro de un empleado, cuyos campos son un identificador unico,
   el nombre del empleado, direccion, fecha de nacimiento, posicion, salario,
   gerente y similares. Todos estos campos se recopilan en una sola entidad que
   puede ser copiada como una unidad, pasada a funciones y devuelta por ellas,
   almacenada en arreglos, y demas.

#    These two statements declare a struct type called @c(Employee) and a variable
#    called @c(dilbert) that is an instance of an @c(Employee):
   Estas dos declaraciones declaran un tipo de estructura llamada @c(Empleado) y una
   variable llamada @c(dilbert) que es una instancia de un @c(Empleado):

#    ..src > go
#      type Employee struct {
#        ID        int
#        Name      string
#        Address   string
#        DoB       time.Time
#        Position  string
#        Salary    int
#        ManagerID int
#      }
#
#      var dilbert Employee
#    < src..
   ..src > go
     type Empleado struct {
       ID        int
       Nombre    string
       Direccion string
       DoB       time.Time
       Posicion  string
       Salario   int
       GerenteID int
     }

     var dilbert Empleado
   < src..

#    The individual fields of @c(dilbert) are accessed using dot notation like
#    @c(dilbert.Name) and @c(dilbert.DoB). Because dilbert is a variable, its
#    fields are variables too, so we may assign to a field:
   Los campos individuales de @c(dilbert) se accede usando la notacion de punto
   como @c(dilbert.Nombre) y @c(dilbert.DoB). Puesto que @c(dilbert) es una
   variable, sus campos son variables tambien, por lo que podemos establecer un
   campo:

#    ..src > go
#      dilbert.Salary -= 5000 // demoted, for writing too few lines of code
#    < src..
   ..src > go
     dilbert.Salario -= 5000 // Rebajado, por escribir muy pocas lineas de codigo
   < src..

#    or take its address and access it through a pointer:
   O tomar su direccion y acceder a ella a traves de un puntero:

#    ..src > go
#      position := &dilbert.Position
#      *position = "Senior " + *position // promoted, for outsourcing to Elbonia
#    < src..
   ..src > go
     posicion := &dilbert.Posicion
     *posicion = "Senior " + *posicion // promovido, para subcontrata a Elbonia
   < src..

#    The dot notation also works with a pointer to a struct:
   La notacion de punto tambien funciona con un puntero a una estructura:

#    ..src > go
#      var employeeOfTheMonth *Employee = &dilbert
#      employeeOfTheMonth.Position += " (proactive team player)"
#    < src..
   ..src > go
     var empleadoDelMes *Empleado = &dilbert
     empleadoDelMes.Posicion += " (proactive team player)"
   < src..

#    The last statement is equivalent to
   La ultima sentencia es equivalente a

#    ..src > go
#      (*employeeOfTheMonth).Position += " (proactive team player)"
#    < src..
   ..src > go
     (*empleadoDelMes).Posicion += " (proactive team player)"
   < src..

#    Given an employee’s unique ID, the function @c(EmployeeByID) returns a
#    pointer to an @c(Employee) struct. We can use the dot notation to access its
#    fields:
   Ya que un empleado tiene un ID unico, la funcion @c(EmpleadoPorID) devuelve
   un puntero a una estructura @c(Empleado). Podemos usar la notacion de punto
   para acceder a sus campos:

#    ..src > go
#      func EmployeeByID(id int) *Employee { /* ... */ }
#
#      fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // "Pointy-haired boss"
#
#      id := dilbert.ID
#      EmployeeByID(id).Salary = 0 // fired for... no real reason
#    < src..
   ..src > go
     func EmpleadoPorID(id int) *Empleado { /* ... */ }

     fmt.Println(EmpleadoPorID(dilbert.GerenteID).Posicion) // "Jefe de pelo puntiagudo"

     id := dilbert.ID
     EmpleadoPorID(id).Salario = 0 // despedido por... ninguna razon real
   < src..

#    The last statement updates the @c(Employee) struct that is pointed to by the
#    result of the call to @c(EmployeeByID). If the result type of
#    @c(EmployeeByID) were changed to @c(Employee) instead of @c(*Employee), the
#    assignment statement would not compile since its left-hand side would not
#    identify a variable.
   La ultima instruccion actualiza la estructura @c(Empleado) a la que apunta el
   resultado de la llamada a @c(EmpleadoPorID). Si el tipo de resultado de
   @c(EmpleadoPorID) se cambiara a @c(Empleado) en lugar de @c(*Empleado), la
   instruccion de asignacion no compilara ya que su lado izquierdo no
   identificaria a una variable.

#    Fields are usually written one per line, with the field’s name preceding its
#    type, but consecutive fields of the same type may be combined, as with
#    @c(Name) and @c(Address) here:
   Generalmente, se escribe un campo por linea, con el nombre del campo que
   precede a su tipo, pero pueden combinarse los campos consecutivos del mismo
   tipo, como con @c(Nombre) y @c(Direccion):

#    ..src > go
#      type Employee struct {
#        ID            int
#        Name, Address string
#        DoB           time.Time
#        Position      string
#        Salary        int
#        ManagerID     int
#      }
#    < src..
   ..src > go
     type Empleado struct {
       ID                int
       Nombre, Direccion string
       DoB               time.Time
       Posicion          string
       Salario           int
       GerenteID         int
     }
   < src..

#    Field order is significant to type identity. Had we also combined the
#    declaration of the @c(Position) field (also a string), or interchanged
#    @c(Name) and @c(Address), we would be defining a different struct
#    type. Typically we only combine the declarations of related fields.
   El orden del campo es significativo para identificar el tipo. Si hubieramos
   combinado tambien la declaracion del campo @c(Posicion) (tambien una cadena),
   o intercambiado @c(Nombre) y @c(Direccion), estariamos definiendo un tipo de
   estructura diferente. Normalmente solo combinamos la declaracion de campos
   relacionados.

#    The name of a struct field is exported if it begins with a capital letter;
#    this is Go’s main access control mechanism. A struct type may contain a
#    mixture of exported and unexported fields.
   El nombre de un campo en la estructura se exporta si comienza con una letra
   mayuscula; este es el mecanismo principal de control de acceso en Go. Una
   estructura puede contener una mezcla de campos exportados y no exportados.

#    Struct types tend to be verbose because they often involve a line for each
#    field. Although we could write out the whole type each time it is needed, the
#    repetition would get tiresome. Instead, struct types usually appear within
#    the declaration of a named type like @c(Employee).
   Los tipos estructura tienden a ser detallados porque a menudo implican una
   linea para cada campo. Aunque podriamos escribir todo el tipo cada vez que
   sea necesario, la repeticion cansaria. En cambio, los tipos estructura suelen
   aparecer dentro de la declaracion de un tipo con nombre como @c(Empleado).

#    A named struct type @c(S) can’t declare a field of the same type @c(S): an
#    aggregate value cannot contain itself. (An analogous restriction applies to
#    arrays.) But @c(S) may declare a field of the pointer type @c(*S), which lets
#    us create recursive data structures like linked lists and trees. This is
#    illustrated in the code below, which uses a binary tree to implement an
#    insertion sort:
   Un llamado tipo de estructura @c(S) no puede declarar un campo del mismo tipo
   @c(S): un valor agregado no puede contenerse a si mismo. (Una restriccion
   analoga se aplica a los arreglos.) Pero @c(S) puede declarar un campo del
   tipo puntero @c(*S), lo que nos permite crear estructuras de datos recursivas
   como listas enlazadas y arboles. Esto se ilustra en el siguiente codigo, que
   utiliza un arbol binario para implementar un tipo de insercion:

#    ..figure > @l(gopl.io/ch4/treesort/sort.go<>gopl.io/ch4/treesort)
   ..figure > @l(gopl.io/ch4/treesort/sort.go<>gopl.io/ch4/treesort)

#      ..src > go
#        type tree struct {
#          value       int
#          left, right *tree
#        }
#
#        // Sort sorts values in place.
#        func Sort(values []int) {
#          var root *tree
#          for _, v := range values {
#            root = add(root, v)
#          }
#          appendValues(values[:0], root)
#        }
#
#        // appendValues appends the elements of t to values in order
#        // and returns the resulting slice.
#        func appendValues(values []int, t *tree) []int {
#          if t != nil {
#            values = appendValues(values, t.left)
#            values = append(values, t.value)
#            values = appendValues(values, t.right)
#          }
#          return values
#        }
#
#        func add(t *tree, value int) *tree {
#          if t == nil {
#            // Equivalent to return &tree{value: value}.
#            t = new(tree)
#            t.value = value
#            return t
#          }
#          if value < t.value {
#            t.left = add(t.left, value)
#          } else {
#            t.right = add(t.right, value)
#          }
#          return t
#        }
#      < src..
     ..src > go
       type tree struct {
         value       int
         left, right *tree
       }

       // Sort ordena los valores en su lugar.
       func Sort(values []int) {
         var root *tree
         for _, v := range values {
           root = add(root, v)
         }
         appendValues(values[:0], root)
       }

       // appendValues agrega los alementos de t a los valores en orden
       // y devuelve el slice resultante.
       func appendValues(values []int, t *tree) []int {
         if t != nil {
           values = appendValues(values, t.left)
           values = append(values, t.value)
           values = appendValues(values, t.right)
         }
         return values
       }

       func add(t *tree, value int) *tree {
         if t == nil {
           // Equivalente a regresar &tree{value: value}.
           t = new(tree)
           t.value = value
           return t
         }
         if value < t.value {
           t.left = add(t.left, value)
         } else {
           t.right = add(t.right, value)
         }
         return t
       }
     < src..


#    The zero value for a struct is composed of the zero values of each of its
#    fields. It is usually desirable that the zero value be a natural or sensible
#    default. For example, in @c(bytes.Buffer), the initial value of the struct is
#    a ready-to-use empty buffer, and the zero value of @c(sync.Mutex), which
#    we’ll see in @l(#Chapter 9), is a ready-to-use unlocked mutex. Sometimes this
#    sensible initial behavior happens for free, but sometimes the type designer
#    has to work at it.
   El valor cero de una estructura se compone de los valores cero de cada uno de
   sus campos. Por lo general, es deseable que el valor cero sea un defecto
   natural o razonable. Por ejemplo, en @c(bytes.Buffer), el valor inicial de la
   estructura es un buffer vacio listo para su uso, y el valor cero de
   @c(sync.Mutex), que veremos en el @l(#Capitulo 9), es un mutex desbloqueado
   listo para usas. A veces este comportamiento inicial razonable ocurre de
   forma gratuita, pero a veces el diseñador de tipo tiene que trabajar en ello.

#    The struct type with no fields is called the @e(empty struct), written
#    @c(struct{}). It has size zero and carries no information but may be useful
#    nonetheless. Some Go programmers use it instead of @c(bool) as the value type
#    of a map that represents a set, to emphasize that only the keys are
#    significant, but the space saving is marginal and the syntax more cumbersome,
#    so we generally avoid it.
   El tipo de una estructura sin campos se denomina @e(estructura vacia), se
   escribe @c(struct{}). Tiene un tamaño cero y no lleva ninguna informacion,
   sin embargo puede ser util. Algunos programadores lo utilizan en lugar de
   @c(bool) como el tipo de valor de un mapa que representa un conjunto, hacer
   hincapie en que solo las claves son significativas, pero el ahorro de espacio
   es marginal y la sintaxis es mas engorrosa, por lo que generalmente lo
   evitamos.

#    ..src > go
#      seen := make(map[string]struct{}) // set of strings
#      // ...
#      if _, ok := seen[s]; !ok {
#        seen[s] = struct{}{}
#        // ...first time seeing s...
#      }
#    < src..
   ..src > go
     seen := make(map[string]struct{}) // conjunto de strings
     // ...
     if _, ok := seen[s]; !ok {
       seen[s] = struct{}{}
       // ...primera ves viendo s...
     }
   < src..

# *** Section 4.4.1 <> Struct Literals
*** Seccion 4.4.1 <> Estructuras Literales

#     A value of a struct type can be written using a @e(struct literal) that
#     specifies values for its fields.
    Un valor de un tipo de estructura se puede escribir usando una estructura
    literal que especifique los valores de sus campos.

#     ..src > go
#       type Point struct{ X, Y int }
#
#       p := Point{1, 2}
#     < src..
    ..src > go
      type Point struct{ X, Y int }

      p := Point{1, 2}
    < src..

#     There are two forms of struct literal. The first form, shown above, requires
#     that a value be specified for @e(every) field, in the right order. It
#     burdens the writer (and reader) with remembering exactly what the fields
#     are, and it makes the code fragile should the set of fields later grow or be
#     reordered. Accordingly, this form tends to be used only within the package
#     that defines the struct type, or with smaller struct types for which there
#     is an obvious field ordering convention, like @c(image.Point{x, y}) or
#     @c(color.RGBA{red, green, blue, alpha}).
    Hay dos formas de struct literal. La primer forma, mostrada arriba, requiere
    que se especifique un valor de @e(cada) campo, en el orden correcto. Se
    carga al escritor (y al lector) el recordar exactamente cuales son los
    campos, y hace que el codigo sea fragil si el conjunto de campos crece mas
    tarde o se reordena. En consequencia, esta forma tiende a ser utilizado solo
    dentro del paquete que define el tipo de estructura o con tipos de
    estructuras mas pequeños para los cuales existe una convencion de ordenacion
    de campos obvia, como @c(image.Point{x, y}) o @c(color.RGBA{red, green,
    blue, alpha}).

#     More often, the second form is used, in which a struct value is initialized
#     by listing some or all of the field names and their corresponding values, as
#     in this statement from the Lissajous program of @l(#Section 1.4):
    Mas a menudo, se utiliza la segunda forma, en la que una estructura se
    inicia haciendo una lista de todos o algunos de los nombres de los campos y
    sus valores correspondientes, como en esta declaracion del programa
    Lissajous de la @l(#Seccion 1.4):

#     ..src > go
#       anim := gif.GIF{LoopCount: nframes}
#     < src..
    ..src > go
      anim := gif.GIF{LoopCount: nframes}
    < src..

#     If a field is omitted in this kind of literal, it is set to the zero value
#     for its type. Because names are provided, the order of fields doesn’t
#     matter.
    Si se omite un campo en este tipo de literal, se establece en el valor cero
    para su tipo. Ya que los nombres se proporcionan, el orden de los campos no
    importa.

#     The two forms cannot be mixed in the same literal. Nor can you use the
#     (order-based) first form of literal to sneak around the rule that unexported
#     identifiers may not be referred to from another package.
    Las dos formas no se pueden mezclar en el mismo literal. Tampoco se puede
    usar la primer forma de literal (basada en ordenes) para colarse alrededor
    de la regla de que los identificadores no exportados no pueden ser referidos
    desde otro paquete.

#     ..src > go
#       package p
#       type T struct{ a, b int } // a and b are not exported
#     < src..

#     ..src > go
#       package q
#       import "p"
#       var _ = p.T{a: 1, b: 2} // compile error: can't reference a, b
#       var _ = p.T{1, 2}       // compile error: can't reference a, b
#     < src..
    ..src > go
      package p
      type T struct{ a, b int } // no se exportan a y b
    < src..

    ..src > go
      package q
      import "p"
      var _ = p.T{a: 1, b: 2} // error de compilacion: no se puede referenciar a, b
      var _ = p.T{1, 2}       // error de compilacion: no se puede referenciar a, b
    < src..

#     Although the last line above doesn’t mention the unexported field
#     identifiers, it’s really using them implicitly, so it’s not allowed.
    Aunque la ultima linea no menciona los identificadores de campo no
    exportados, realmente los esta usando implicitamente, por lo que no es
    permitido.

#     Struct values can be passed as arguments to functions and returned from
#     them. For instance, this function scales a @c(Point) by a specified factor:
    Los valores de una estructura se pueden pasar como argumentos a funciones y
    ser devueltos. Por ejemplo, esta funcion escala un @c(Point) por un factor
    especifico:

#     ..src > go
#       func Scale(p Point, factor int) Point {
#         return Point{p.X * factor, p.Y * factor}
#       }
#
#       fmt.Println(Scale(Point{1, 2}, 5)) // "{5 10}"
#     < src..
    ..src > go
      func Scale(p Point, factor int) Point {
        return Point{p.X * factor, p.Y * factor}
      }

      fmt.Println(Scale(Point{1, 2}, 5)) // "{5 10}"
    < src..

#     For efficiency, larger struct types are usually passed to or returned from
#     functions indirectly using a pointer,
    Por eficiencia, las estructuras mas grandes normalmente se pasan a las
    funciones o se devuelven indirectamente mediante un puntero,

#     ..src > go
#       func Bonus(e *Employee, percent int) int {
#         return e.Salary * percent / 100
#       }
#     < src..
    ..src > go
      func Bonus(e *Employee, percent int) int {
        return e.Salary * percent / 100
      }
    < src..

#     and this is required if the function must modify its argument, since in a
#     call-by-value language like Go, the called function receives only a copy of
#     an argument, not a reference to the original argument.
    Y esto es necesario si la funcion debe modificar su argumento, ya que en un
    lenguaje de llamada por valor como Go, la funcion llamada recibe solo una
    copia, no una referencia al argumento original.

#     ..src > go
#       func AwardAnnualRaise(e *Employee) {
#         e.Salary = e.Salary * 105 / 100
#       }
#     < src..
    ..src > go
      func AwardAnnualRaise(e *Employee) {
        e.Salary = e.Salary * 105 / 100
      }
    < src..

#     Because structs are so commonly dealt with through pointers, it’s possible
#     to use this shorthand notation to create and initialize a struct variable
#     and obtain its address:
    Debido a que las estructuras se manejan tan comunmente mediante punteros, es
    posible utilizar esta notacion conpacta para crear e inicializar una
    estructura y obtener su direccion:

#     ..src > go
#       pp := &Point{1, 2}
#     < src..
    ..src > go
      pp := &Point{1, 2}
    < src..

#     It is exactly equivalent to
    Es exactamente equivalente a

#     ..src > go
#       pp := new(Point)
#       *pp = Point{1, 2}
#     < src..
    ..src > go
      pp := new(Point)
      *pp = Point{1, 2}
    < src..

#     but @c(&Point{1, 2}) can be used directly within an expression, such as a
#     function call.
    pero @c(&Point{1, 2}) se puede utilizar directamente dentro de una
    expresion, como una llamada de funcion.

# *** Section 4.4.2 <> Comparing Structs
*** Seccion 4.4.2 <> Comparacion de estructuras

#     If all the fields of a struct are comparable, the struct itself is
#     comparable, so two expressions of that type may be compared using @c(==) or
#     @c(!=). The @c(==) operation compares the corresponding fields of the two
#     structs in order, so the two printed expressions below are equivalent:
    Si todos los campos de una estructura son comparables, la estructura en si
    es comparable, por lo que se puede comparar dos expresiones de ese tipo
    usando @c(==) o @c(!=). La operacion @c(==) compara los campos
    correspondientes de las dos estructuras en orden, por lo que las dos
    expresiones a continuacion son equivalentes:

#     ..src > go
#       type Point struct{ X, Y int }
#
#       p := Point{1, 2}
#       q := Point{2, 1}
#       fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
#       fmt.Println(p == q)                   // "false"
#     < src..
    ..src > go
      type Point struct{ X, Y int }

      p := Point{1, 2}
      q := Point{2, 1}
      fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
      fmt.Println(p == q)                   // "false"
    < src..

#     Comparable struct types, like other comparable types, may be used as the key
#     type of a map.
    Las estructuras de tipos comparables, al igual que otros tipos comparables,
    se pueden utilizar como la clave de un mapa.

#     ..src > go
#       type address struct {
#         hostname string
#         port     int
#       }
#
#       hits := make(map[address]int)
#       hits[address{"golang.org", 443}]++
#     < src..
    ..src > go
      type address struct {
        hostname string
        port     int
      }

      hits := make(map[address]int)
      hits[address{"golang.org", 443}]++
    < src..

# *** Section 4.4.3 <> Struct Embedding and Anonymous Fields
*** Seccion 4.4.3 <> Estructura Enbebida y Campos Anonimos

#     In this section, we’ll see how Go’s unusual @e(struct embedding) mechanism
#     lets us use one named struct type as an @e(anonymous field) of another
#     struct type, providing a convenient syntactic shortcut so that a simple dot
#     expression like @c(x.f) can stand for a chain of fields like @c(x.d.e.f).
    En esta seccion, veremos como utilizar el inusual mecanismo de @e(estructura
    enbebida) de Go que nos permite usar una estructura como un @e(campo
    anonimo) de otra estructura, proporcionando un acceso directo,
    sintacticamente conveniente para que una simple expresion de punto como
    @c(x.f) puede representar una cadena de campos como @c(x.d.e.f).

#     Consider a 2-D drawing program that provides a library of shapes, such as
#     rectangles, ellipses, stars, and wheels. Here are two of the types it might
#     define:
    Considere un programa de dibujo 2-D que proporciona una libreria de formas,
    como rectangulos, elipses, estrellas y ruedas. Aqui hay dos de los tipos que
    podria definir:

#     ..src > go
#       type Circle struct {
#         X, Y, Radius int
#       }
#       type Wheel struct {
#         X, Y, Radius, Spokes int
#       }
#     < src..
    ..src > go
      type Circulo struct {
        X, Y, Radio int
      }
      type Rueda struct {
        X, Y, Radio, Rayos int
      }
    < src..

#     A @c(Circle) has fields for the @c(X) and @c(Y) coordinates of its center,
#     and a @c(Radius). A @c(Wheel) has all the features of a @c(Circle), plus
#     @c(Spokes), the number of inscribed radial spokes. Let’s create a wheel:
    Un @c(Circulo) tiene campos para las coordenadas de su centro @c(X) y @c(Y),
    y un @c(Radio). Una @c(Rueda) tiene todas las caracteristicas de un
    @c(Circulo), ademas de @c(Rayos), el numero de radios radiales
    inscritos. Vamos a crear una rueda:

#     ..src > go
#       var w Wheel
#       w.X = 8
#       w.Y = 8
#       w.Radius = 5
#       w.Spokes = 20
#     < src..
    ..src > go
      var w Rueda
      w.X = 8
      w.Y = 8
      w.Radio = 5
      w.Rayos = 20
    < src..

#     As the set of shapes grows, we’re bound to notice similarities and
#     repetition among them, so it may be convenient to factor out their common
#     parts:
    A medida que el conjunto de formas crece, estamos obligados a notar
    semejanzas y repeticiones entre ellos, por lo que puede ser conveniente
    factorizar sus partes comunes:

#     ..src > go
#       type Point struct {
#         X, Y int
#       }
#
#       type Circle struct {
#         Center Point
#         Radius int
#       }
#
#       type Wheel struct {
#         Circle Circle
#         Spokes int
#       }
#     < src..
    ..src > go
      type Punto struct {
        X, Y int
      }

      type Circulo struct {
        Centro Punto
        Radio  int
      }

      type Rueda struct {
        Circulo Circulo
        Rayos   int
      }
    < src..

#     The application may be clearer for it, but this change makes accessing the
#     fields of a @c(Wheel) more verbose:
    La aplicacion puede ser mas clara para ello, pero este cambio hace que el
    acceso a los campos de una Rueda sea mas detallado:

#     ..src > go
#       var w Wheel
#       w.Circle.Center.X = 8
#       w.Circle.Center.Y = 8
#       w.Circle.Radius = 5
#       w.Spokes = 20
#     < src..
    ..src > go
      var w Rueda
      w.Circulo.Centro.X = 8
      w.Circulo.Centro.Y = 8
      w.Circulo.Radio = 5
      w.Rayos = 20
    < src..

#     Go lets us declare a field with a type but no name; such fields are called
#     @e(anonymous fields). The type of the field must be a named type or a
#     pointer to a named type. Below, @c(Circle) and @c(Wheel) have one anonymous
#     field each. We say that a @c(Point) is @e(embedded) within @c(Circle), and a
#     @c(Circle) is embedded within @c(Wheel).
    Go nos permite declarar un campo con un tipo pero sin nombre; estos campos
    se denominan campos anonimos. El tipo del campo debe ser un tipo con nombre
    o un puntero a un tipo con nombre. Debajo, @c(Circulo) y @c(Rueda) tienen un
    campo anonimo cada uno. Se dice que un @c(Punto) esta enbebido dentro del
    @c(Circulo), y un @c(Circulo) esta enbebido dentro de la @c(Rueda).

#     ..src > go
#       type Circle struct {
#         Point
#         Radius int
#       }
#
#       type Wheel struct {
#         Circle
#         Spokes int
#       }
#     < src..
    ..src > go
      type Circulo struct {
        Punto
        Radio int
      }

      type Rueda struct {
        Circulo
        Rayos   int
      }
    < src..

#     Thanks to embedding, we can refer to the names at the leaves of the implicit
#     tree without giving the intervening names:
    Gracias al embebido, podemos referirnos a los nombres en las hojas
    del arbol implicitamento sin dar los nombres participantes:

#     ..src > go
#       var w Wheel
#       w.X = 8        // equivalent to w.Circle.Point.X = 8
#       w.Y = 8        // equivalent to w.Circle.Point.Y = 8
#       w.Radius = 5   // equivalent to w.Circle.Radius = 5
#       w.Spokes = 20
#     < src..
    ..src > go
      var w Rueda
      w.X = 8        // equivalente a w.Circulo.Punto.X = 8
      w.Y = 8        // equivalente a w.Circulo.Punto.Y = 8
      w.Radio = 5    // equivalente a w.Circulo.Radio = 5
      w.Rayos = 20
    < src..

#     The explicit forms shown in the comments above are still valid, however,
#     showing that @"(anonymous field) is something of a misnomer. The fields
#     @c(Circle) and @c(Point) do have names—that of the named type—but those
#     names are optional in dot expressions. We may omit any or all of the
#     anonymous fields when selecting their subfields.
    Las formas explicitas que se muestran en los comentarios anteriores siguen
    siendo validas, sin embargo, demuestra que @"(campo anonimo) es un termino
    inapropiado. Los campos @c(Circulo) y @c(Punto) tienen nombres–del tipo
    nombrado–pero esos nombres son opcionales en las expresiones de punto.
    Podemos omitir cualquiera o todos los campos anonimos al seleccionar sus
    subcampos.

#     Unfortunately, there’s no corresponding shorthand for the struct literal
#     syntax, so neither of these will compile:
    Desafortunadamente, no hay una sintaxis compacta correspondiente para una
    estructura literal, por lo que ninguna de ellas compilara:

#     ..src > go
#       w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields
#       w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
#     < src..
    ..src > go
      w = Wheel{8, 8, 5, 20}                       // error de compilacion: campos desconocidos
      w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // error de compilacion: campos desconocidos
    < src..

#     The struct literal must follow the shape of the type declaration, so we must
#     use one of the two forms below, which are equivalent to each other:
    La estructura literal debe seguir el formato de la declaracion del tipo, por
    lo que debemos utilizar una de las siguientes dos formas, que son
    equivalentes entre si:

#     ..figure > @l(gopl.io/ch4/embed/main.go<>gopl.io/ch4/embed)
    ..figure > @l(gopl.io/ch4/embed/main.go<>gopl.io/ch4/embed)

#       ..src > go
#           w = Wheel{Circle{Point{8, 8}, 5}, 20}
#
#           w = Wheel{
#             Circle: Circle{
#               Point:  Point{X: 8, Y: 8},
#               Radius: 5,
#             },
#             Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
#           }
#
#           fmt.Printf("%#v\n", w)
#           // Output:
#           // Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}
#
#           w.X = 42
#
#           fmt.Printf("%#v\n", w)
#           // Output:
#           // Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}
#       < src..
      ..src > go
          w = Rueda{Circulo{Punto{8, 8}, 5}, 20}

          w = Rueda{
            Circulo: Circulo{
              Punto:  Punto{X: 8, Y: 8},
              Radio: 5,
            },
            Rayos: 20, // NOTA: comma necesaria aqui (y en el Radio)
          }

          fmt.Printf("%#v\n", w)
          // Salida:
          // Rueda{Circulo:Circulo{Punto:Punto{X:8, Y:8}, Radio:5}, Rayos:20}

          w.X = 42

          fmt.Printf("%#v\n", w)
          // Salida:
          // Rueda{Circulo:Circulo{Punto:Punto{X:42, Y:8}, Radio:5}, Rayos:20}
      < src..


#     Notice how the @c(#) adverb causes @c(Printf)’s @c(%v) verb to display
#     values in a form similar to Go syntax. For struct values, this form includes
#     the name of each field.
    Observe como el adverbio @c(#) hace que el verbo @c(%v) de @c(Printf)
    muestre los valores en una forma similar a la sintaxis Go. Para los valores
    de estructura, este formato incluye el nombre de cada campo.

#     Because @"(anonymous) fields do have implicit names, you can’t have two
#     anonymous fields of the same type since their names would conflict. And
#     because the name of the field is implicitly determined by its type, so too
#     is the visibility of the field. In the examples above, the @c(Point) and
#     @c(Circle) anonymous fields are exported. Had they been unexported
#     (@c(point) and @c(circle)), we could still use the shorthand form
    Dado que los campos @"(anonimos) tienen nombres implicitos, no se puede
    tener dos campos anonimos del mismo tipo, ya que sus nombres entran en
    conflicto. Y debido a que el nombre del campo esta implicitamente
    determinado por su tipo, tambien lo es la visibilidad del campo. En los
    ejemplos anteriores, se exportan campos anonimos @c(Punto) y
    @c(Circulo). Si no hubieran sido exportados (@c(punto) y @c(circulo)),
    podriamos utilizar la forma compacta

#     ..src > go
#       w.X = 8 // equivalent to w.circle.point.X = 8
#     < src..
    ..src > go
      w.X = 8 // equivalente a w.circulo.punto.X = 8
    < src..

#     but the explicit long form shown in the comment would be forbidden outside
#     the declaring package because @c(circle) and @c(point) would be
#     inaccessible.
    pero el fomato explicito que se muestra en el comentario estaria prohibido
    fuera del paquete porque @c(circulo) y @c(punto) serian inaccesibles.

#     What we’ve seen so far of struct embedding is just a sprinkling of syntactic
#     sugar on the dot notation used to select struct fields. Later, we’ll see
#     that anonymous fields need not be struct types; any named type or pointer to
#     a named type will do. But why would you want to embed a type that has no
#     subfields?
    Lo que hemos visto hasta ahora sobre estructuras enbebidas es solo una pisca
    de azucar sintactico en la notacion de punto utilizada para seleccionar los
    campos de la estructura. Mas adelante, veremos que los campos anonimos no
    necesitan ser de tipo estructura; puede ser cualquier tipo con nombre o
    puntero a un tipo con nombre. Pero, ¿para que querrias incorporar un tipo
    que no tiene subcampos?

#     The answer has to do with methods. The shorthand notation used for selecting
#     the fields of an embedded type works for selecting its methods as well. In
#     effect, the outer struct type gains not just the fields of the embedded type
#     but its methods too. This mechanism is the main way that complex object
#     behaviors are composed from simpler ones. @e(Composition) is central to
#     object-oriented programming in Go, and we’ll explore it further in
#     @l(#Section 6.3).
    La respuesta tiene que ver con los metodos. La notacion compacta utilizada
    para seleccionar los campos de un tipo enbebido funciona para seleccionar
    tambien sus metodos. En efecto, el tipo de estructura externa gana no solo
    los campos del tipo enbebido sino tambien sus metodos. Este mecanismo es la
    forma principal en que los comportamientos de objetos complejos se componen
    de los mas simples. La composicion es fundamental para la programacion
    orientada a objetos en Go, y la exploraremos mas adelante en la @l(#Seccion
    6.3).

# ** Section 4.5 <> JSON
** Seccion 4.5 <> JSON

#    JavaScript Object Notation (JSON) is a standard notation for sending and
#    receiving structured information. JSON is not the only such notation. XML
#    (@l(#Section 7.14<>§7.14)), ASN.1, and Google’s Protocol Buffers serve
#    similar purposes and each has its niche, but because of its simplicity,
#    readability, and universal support, JSON is the most widely used.
   JavaScript Object Notation (JSON) es una notacion estandar para enviar y
   recibir informacion estructurada. JSON no es la unica notacion. XML
   (@l(#Seccion 7.14<>§7.14)), ASN.1, y Google’s Protocol Buffers sirven a
   propositos similares y cada uno tiene su nicho, pero debido a su simplicidad,
   facilidad de lectura, y un apoyo universal, JSON es el mas utilizado.

#    Go has excellent support for encoding and decoding these formats, provided by
#    the standard library packages @c(encoding/json), @c(encoding/xml),
#    @c(encoding/asn1), and so on, and these packages all have similar APIs. This
#    section gives a brief overview of the most important parts of the
#    @c(encoding/json) package.
   Go tiene un excelente soporte para la codificacion y decodificacion de estos
   formatos, proporcionado por los paquetes de las librerias estandar
   @c(encoding/json), @c(encoding/xml), @c(encoding/asn1), y demas, y todos
   estos paquetes tienen APIs similares. En esta seccion se presenta una breve
   descripcion de las partes mas importantes del paquete @c(encoding/json).

#    JSON is an encoding of JavaScript values—strings, numbers, booleans, arrays,
#    and objects—as Unicode text. It’s an efficient yet readable representation
#    for the basic data types of @l(#Chapter 3) and the composite types of this
#    chapter—arrays, slices, structs, and maps.
   JSON es una codificacion de valores JavaScript–cadenas, numeros, booleanos,
   arreglos y objetos–como texto Unicode. Es una representacion eficiente pero
   legible para los tipos de datos basicos del @l(#Capitulo 3) y los tipos
   compuestos de este capitulo–arreglos, slices, estructuras, y mapas.

#    The basic JSON types are numbers (in decimal or scientific notation),
#    booleans (@c(true) or @c(false)), and strings, which are sequences of Unicode
#    code points enclosed in double quotes, with backslash escapes using a similar
#    notation to Go, though JSON’s @c(\U)@e(hhhh) numeric escapes denote UTF-16
#    codes, not runes.
   Los tipos JSON basicos son numeros (en notacion decimal o cientifica),
   booleanos (@c(true) o @c(false)), y cadenas, que son secuencias de puntos de
   codigo Unicode entre comillas dobles, con escapes mediante la barra invertida
   utilizando una notacion similar a Go, aunque los escapes JSON @c(\U)@e(hhhh)
   denotan codigos UTF-16, no runas.

#    These basic types may be combined recursively using JSON arrays and
#    objects. A JSON array is an ordered sequence of values, written as a
#    comma-separated list enclosed in square brackets; JSON arrays are used to
#    encode Go arrays and slices. A JSON object is a mapping from strings to
#    values, written as a sequence of @c(name:value) pairs separated by commas and
#    surrounded by braces; JSON objects are used to encode Go maps (with string
#    keys) and structs.  For example:
   Estos tipos basicos se pueden combinar recursivamente utilizando arreglos
   JSON y objetos. Un arreglo JSON es una secuencia ordenada de valores, escrita
   como una lista separada por comas entre corchetes; los arreglos JSON se
   utilizan para codificar arreglos Go y slices. Un objeto JSON es un mapeo de
   cadenas a valores, escrito como una secuencia de pares @c(nombre:valor)
   separados por comas y rodeados por llaves; Los objetos JSON se usan para
   codificar mapas Go (con claves de tipo cadena) y estructuras. Por ejemplo:

#    | @c(boolean) | @c(true)                                 |
#    |-------------|------------------------------------------|
#    | @c(number)  | @c(-273.15)                              |
#    |-------------|------------------------------------------|
#    | @c(string)  | @c("She said \"Hello, 世界\"")             |
#    |-------------|------------------------------------------|
#    | @c(array)   | @c(["gold", "silver", "bronze"])         |
#    |-------------|------------------------------------------|
#    | @c(object)  | @c({"year": 1980,                        |
#    |             | "event": "archery",                      |
#    |             | "medals": ["gold", "silver", "bronze"]}) |
   | @c(booleano) | @c(true)                                 |
   |--------------|------------------------------------------|
   | @c(numero)   | @c(-273.15)                              |
   |--------------|------------------------------------------|
   | @c(cadena)   | @c("She said \"Hello,  世界\"")            |
   |--------------|------------------------------------------|
   | @c(arreglo)  | @c(["gold", "silver", "bronze"])         |
   |--------------|------------------------------------------|
   | @c(objeto)   | @c({"year": 1980,                        |
   |              | "event": "archery",                      |
   |              | "medals": ["gold", "silver", "bronze"]}) |


#    Consider an application that gathers movie reviews and offers
#    recommendations. Its @c(Movie) data type and a typical list of values are
#    declared below. (The string literals after the @c(Year) and @c(Color) field
#    declarations are @e(field tags); we’ll explain them in a moment.)
   Considere una aplicacion que reune reseñas de peliculas y ofrece
   recomendaciones. A continuacion se declara un tipo de datos @c(Movie) y luego
   una lista de estos valores. (Los literales de cadena despues de las
   declaraciones @c(Year) y @c(Color) son etiquetas de campo; las explicaremos
   en un momento.)

#    ..figure > @l(gopl.io/ch4/movie/main.go<>gopl.io/ch4/movie)
   ..figure > @l(gopl.io/ch4/movie/main.go<>gopl.io/ch4/movie)

#      ..src > go
#        type Movie struct {
#          Title  string
#          Year   int  `json:"released"`
#          Color  bool `json:"color,omitempty"`
#          Actors []string
#        }
#
#        var movies = []Movie{
#          {Title: "Casablanca", Year: 1942, Color: false,
#            Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
#          {Title: "Cool Hand Luke", Year: 1967, Color: true,
#            Actors: []string{"Paul Newman"}},
#          {Title: "Bullitt", Year: 1968, Color: true,
#            Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
#          // ...
#        }
#      < src..
     ..src > go
       type Movie struct {
         Title  string
         Year   int  `json:"released"`
         Color  bool `json:"color,omitempty"`
         Actors []string
       }

       var movies = []Movie{
         {Title: "Casablanca", Year: 1942, Color: false,
           Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
         {Title: "Cool Hand Luke", Year: 1967, Color: true,
           Actors: []string{"Paul Newman"}},
         {Title: "Bullitt", Year: 1968, Color: true,
           Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
         // ...
       }
     < src..


#    Data structures like this are an excellent fit for JSON, and it’s easy to
#    convert in both directions. Converting a Go data structure like @c(movies) to
#    JSON is called @e(marshaling). Marshaling is done by @c(json.Marshal):
   Las estructuras de datos como esta son un excelente ajuste para JSON, y es
   facil de convertir en ambas direcciones. Convertir una estructura de datos Go
   como @c(movies) a JSON se denomina @e(marshaling). La ordenacion se se
   realiza con @c(json.Marshal):

#    ..src > go
#      data, err := json.Marshal(movies)
#      if err != nil {
#        log.Fatalf("JSON marshaling failed: %s", err)
#      }
#      fmt.Printf("%s\n", data)
#    < src..
   ..src > go
     data, err := json.Marshal(movies)
     if err != nil {
       log.Fatalf("JSON marshaling failed: %s", err)
     }
     fmt.Printf("%s\n", data)
   < src..

#    @c(Marshal) produces a byte slice containing a very long string with no
#    extraneous white space; we’ve folded the lines so it fits:
   @c(Marshal) produce una slice de bytes que contiene una cadena muy grande sin
   ningun espacio en blanco:

#    ..src > go
#      [{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingrid Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Actors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]}]
#    < src..
   ..src > go
     [{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingrid Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Actors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]}]
   < src..

#    This compact representation contains all the information but it’s hard to
#    read. For human consumption, a variant called @c(json.MarshalIndent) produces
#    neatly indented output. Two additional arguments define a prefix for each
#    line of output and a string for each level of indentation:
   Esta representacion compacta contiene toda la informacion, pero es dificil de
   leer. Para el consumo humano, una variante llamada @c(json.MarshalIndent)
   produce una salida perfectamente indentada. Dos argumentos adicionales
   definen un prefijo para cada linea de salida y una cadena para cada nivel de
   sangria:

#    ..src > go
#      data, err := json.MarshalIndent(movies, "", "    ")
#      if err != nil {
#        log.Fatalf("JSON marshaling failed: %s", err)
#      }
#      fmt.Printf("%s\n", data)
#    < src..
   ..src > go
     data, err := json.MarshalIndent(movies, "", "    ")
     if err != nil {
       log.Fatalf("JSON marshaling failed: %s", err)
     }
     fmt.Printf("%s\n", data)
   < src..

#    The code above prints
   El codigo anterior

#    ..src > go
#      [
#          {
#              "Title": "Casablanca",
#              "released": 1942,
#              "Actors": [
#                  "Humphrey Bogart",
#                  "Ingrid Bergman"
#              ]
#          },
#          {
#              "Title": "Cool Hand Luke",
#              "released": 1967,
#              "color": true,
#              "Actors": [
#                  "Paul Newman"
#              ]
#          },
#          {
#              "Title": "Bullitt",
#              "released": 1968,
#              "color": true,
#              "Actors": [
#                  "Steve McQueen",
#                  "Jacqueline Bisset"
#              ]
#          }
#      ]
#    < src..
   ..src > go
     [
         {
             "Title": "Casablanca",
             "released": 1942,
             "Actors": [
                 "Humphrey Bogart",
                 "Ingrid Bergman"
             ]
         },
         {
             "Title": "Cool Hand Luke",
             "released": 1967,
             "color": true,
             "Actors": [
                 "Paul Newman"
             ]
         },
         {
             "Title": "Bullitt",
             "released": 1968,
             "color": true,
             "Actors": [
                 "Steve McQueen",
                 "Jacqueline Bisset"
             ]
         }
     ]
   < src..

#    Marshaling uses the Go struct field names as the field names for the JSON
#    objects (through @e(reflection), as we’ll see in @l(#Section 12.6)). Only
#    exported fields are marshaled, which is why we chose capitalized names for
#    all the Go field names.
   Marshaling utiliza los nombres de los campos en la estructura Go como los
   nombres de campo de los objetos JSON (mediante @e(reflexion), como veremos en
   la @l(#Seccion 12.6)). Solo se exportan los campos exportables, por lo que
   elegimos nombres en mayusculas para todos los nombres de campo.

#    You may have noticed that the name of the @c(Year) field changed to
#    @c(released) in the output, and @c(Color) changed to @c(color). That’s
#    because of the @e(field tags). A field tag is a string of metadata associated
#    at compile time with the field of a struct:
   Habra notado que el nombre del campo @c(Year) cambia a @c(released) en la
   salida, y @c(Color) cambia a @c(color) . Eso es debido a las etiquetas de los
   campos. Una etiqueta de campo es una cadena de metadatos asociados en tiempo
   de compilacion con el campo de una estructura:

#    ..src > go
#      Year  int  `json:"released"`
#      Color bool `json:"color,omitempty"`
#    < src..
   ..src > go
     Year  int  `json:"released"`
     Color bool `json:"color,omitempty"`
   < src..

#    A field tag may be any literal string, but it is conventionally interpreted
#    as a space-separated list of @c(key:"value") pairs; since they contain double
#    quotation marks, field tags are usually written with raw string literals. The
#    @c(json) key controls the behavior of the @c(encoding/json) package, and
#    other @c(encoding/...) packages follow this convention. The first part of the
#    @c(json) field tag specifies an alternative JSON name for the Go field. Field
#    tags are often used to specify an idiomatic JSON name like @c(total_count)
#    for a Go field named @c(TotalCount). The tag for @c(Color) has an additional
#    option, @c(omitempty), which indicates that no JSON output should be produced
#    if the field has the zero value for its type (@c(false), here) or is
#    otherwise empty.  Sure enough, the JSON output for @e(Casablanca), a
#    black-and-white movie, has no @c(color) field.
   Una etiqueta de campo puede ser cualquier cadena literal, pero se interpreta
   convencionalmente como una lista separada por espacios de pares
   @c(clave:"valor"); Ya que contiene comillas dobles, las etiquetas de campo
   normalmente se escriben con literales de cadena sin formato. La clave
   @c(json) controla el comportamiento del paquete @c(encoding/json), y otros
   paquetes @c(encoding/...) siguen esta convencion. La primera parte de la
   etiqueta de campo @c(json) especifica un nombre JSON alternativo para el
   campo Go. Las etiquetas de los campos a menudo se utilizan para especificar
   un nombre JSON idiomatico como @c(total_count) para un campo Go llamado
   @c(TotalCount). La etiqueta @c(Color) tiene una opcion adicional,
   @c(omitempty), lo que indica que no se debe producir ninguna salida JSON si
   el campo tiene el valor cero para su tipo (@c(false), aqui) o esta
   vacia. Efectivamente, la salida JSON para Casablanca, una pelicula en blanco
   y negro, no tiene el campo @c(color).

#    The inverse operation to marshaling, decoding JSON and populating a Go data
#    structure, is called @e(unmarshaling), and it is done by @c(json.Unmarshal).
#    The code below unmarshals the JSON movie data into a slice of structs whose
#    only field is @c(Title). By defining suitable Go data structures in this way,
#    we can select which parts of the JSON input to decode and which to
#    discard. When @c(Unmarshal) returns, it has filled in the slice with the
#    @c(Title) information; other names in the JSON are ignored.
   La operacion inversa para marshaling, la decodificacion de JSON y rellenar
   una estructura de datos Go, se denomina @e(unmarshaling), y se realiza por
   @c(json.Unmarshal). El codigo de abajo descoloca los datos de la pelicula
   JSON en un slice de estructuras cuyo unico campo es Title . De esta manera,
   al definir estructuras de datos Go adecuadas, podemos seleccionar que partes
   de la entrada JSON se deben descifrar y cuales descartar. Cuando
   @c(Unmarshal) regresa, se ha llenado el slice con la informacion de
   @c(Title); Otros nombres en el JSON se ignoran.

#    ..src > go
#      var titles []struct{ Title string }
#      if err := json.Unmarshal(data, &titles); err != nil {
#        log.Fatalf("JSON unmarshaling failed: %s", err)
#      }
#      fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
#    < src..
   ..src > go
     var titles []struct{ Title string }
     if err := json.Unmarshal(data, &titles); err != nil {
       log.Fatalf("JSON unmarshaling failed: %s", err)
     }
     fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
   < src..

#    Many web services provide a JSON interface—make a request with HTTP and back
#    comes the desired information in JSON format. To illustrate, let’s query the
#    GitHub issue tracker using its web-service interface. First we’ll define the
#    necessary types and constants:
   Muchos servicios web proporcionan una interfaz JSON–se hace una solicitud con
   HTTP y devuelve la informacion deseada en formato JSON. Para ilustrarlo,
   vamos a consultar el seguimiento de problemas en GitHub con su interfaz de
   servicio web. Primero definiremos los tipos y constantes necesarios:

#    ..figure > @l(gopl.io/ch4/github/github.go<>gopl.io/ch4/github)
   ..figure > @l(gopl.io/ch4/github/github.go<>gopl.io/ch4/github)

#      ..src > go
#        // Package github provides a Go API for the GitHub issue tracker.
#        // See https://developer.github.com/v3/search/#search-issues.
#        package github
#
#        import "time"
#
#        const IssuesURL = "https://api.github.com/search/issues"
#
#        type IssuesSearchResult struct {
#          TotalCount int `json:"total_count"`
#          Items      []*Issue
#        }
#
#        type Issue struct {
#          Number    int
#          HTMLURL   string `json:"html_url"`
#          Title     string
#          State     string
#          User      *User
#          CreatedAt time.Time `json:"created_at"`
#          Body      string    // in Markdown format
#        }
#
#        type User struct {
#          Login   string
#          HTMLURL string `json:"html_url"`
#        }
#      < src..
     ..src > go
       // El paquete github proporciana una API en Go para el seguimiento de problemas.
       // Ver https://developer.github.com/v3/search/#search-issues.
       package github

       import "time"

       const IssuesURL = "https://api.github.com/search/issues"

       type IssuesSearchResult struct {
         TotalCount int `json:"total_count"`
         Items      []*Issue
       }

       type Issue struct {
         Number    int
         HTMLURL   string `json:"html_url"`
         Title     string
         State     string
         User      *User
         CreatedAt time.Time `json:"created_at"`
         Body      string    // En formato Markdown
       }

       type User struct {
         Login   string
         HTMLURL string `json:"html_url"`
       }
     < src..


#    As before, the names of all the struct fields must be capitalized even if
#    their JSON names are not. However, the matching process that associates JSON
#    names with Go struct names during unmarshaling is case-insensitive, so it’s
#    only necessary to use a field tag when there’s an underscore in the JSON name
#    but not in the Go name. Again, we are being selective about which fields to
#    decode; the GitHub search response contains considerably more information
#    than we show here.
   Como antes, los nombres de todos los campos de estructura deben estar en
   mayuscula incluso si sus nombres JSON no. Sin embargo, el proceso de
   coincidencia que asocia los nombres de JSON con los nombres de una estructura
   de Go durante el unmarshaling no distingue entre mayusculas y minusculas, por
   lo que solo es necesario utilizar una etiqueta de campo cuando hay un
   subrayado en el nombre JSON pero no en el nombre Go. Una vez mas, estamos
   siendo selectivos acerca de que campos decodificar; La respuesta de busqueda
   de GitHub contiene considerablemente mas informacion de la que mostramos
   aqui.

#    The @c(SearchIssues) function makes an HTTP request and decodes the result as
#    JSON. Since the query terms presented by a user could contain characters like
#    @c(?) and @c(&) that have special meaning in a URL, we use
#    @c(url.QueryEscape) to ensure that they are taken literally.
   La funcion @c(SearchIssues) realiza una peticion HTTP y decodifica el
   resultado como JSON. Puesto que los terminos de consulta presentados por un
   usuario pueden contener caracteres como @c(?) y @c(&) que tienen un
   significado especial en una URL, usamos @c(url.QueryEscape) para asegurar de
   que se tomen literalmente.

#    ..figure > @l(gopl.io/ch4/github/search.go<>gopl.io/ch4/github)
   ..figure > @l(gopl.io/ch4/github/search.go<>gopl.io/ch4/github)

#      ..src > go
#        package github
#
#        import (
#          "encoding/json"
#          "fmt"
#          "net/http"
#          "net/url"
#          "strings"
#        )
#
#        // SearchIssues queries the GitHub issue tracker.
#        func SearchIssues(terms []string) (*IssuesSearchResult, error) {
#          q := url.QueryEscape(strings.Join(terms, " "))
#          resp, err := http.Get(IssuesURL + "?q=" + q)
#          if err != nil {
#            return nil, err
#          }
#
#          // We must close resp.Body on all execution paths.
#          // (Chapter 5 presents 'defer', which makes this simpler.)
#          if resp.StatusCode != http.StatusOK {
#            resp.Body.Close()
#            return nil, fmt.Errorf("search query failed: %s", resp.Status)
#          }
#
#          var result IssuesSearchResult
#          if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
#            resp.Body.Close()
#            return nil, err
#          }
#          resp.Body.Close()
#          return &result, nil
#        }
#      < src..
     ..src > go
       package github

       import (
         "encoding/json"
         "fmt"
         "net/http"
         "net/url"
         "strings"
       )

       // SearchIssues consulta el seguimiento de problemas de GitHub.
       func SearchIssues(terms []string) (*IssuesSearchResult, error) {
         q := url.QueryEscape(strings.Join(terms, " "))
         resp, err := http.Get(IssuesURL + "?q=" + q)
         if err != nil {
           return nil, err
         }

         // Debemos cerrar resp.Body en todas las rutas de ejecucion.
         // (El Capitulo 5 presenta 'defer', lo que simplifica esto.)
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("search query failed: %s", resp.Status)
         }

         var result IssuesSearchResult
         if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
           resp.Body.Close()
           return nil, err
         }
         resp.Body.Close()
         return &result, nil
       }
     < src..


#    The earlier examples used @c(json.Unmarshal) to decode the entire contents of
#    a byte slice as a single JSON entity. For variety, this example uses the
#    @e(streaming) decoder, @c(json.Decoder), which allows several JSON entities
#    to be decoded in sequence from the same stream, although we don’t need that
#    feature here. As you might expect, there is a corresponding streaming encoder
#    called @c(json.Encoder).
   Los ejemplos anteriores utilizaron @c(json.Unmarshal) para decodificar todo
   el contenido de una slice de bytes como una sola entidad JSON. Para variar,
   este ejemplo utiliza el decodificador de @e(flujo), @c(json.Decoder), que
   permite que varias entidades JSON sean decodificados en secuencia desde el
   mismo flujo, aunque aqui no necesitamos esa caracteristica. Como era de
   esperar, hay un codificador de flujo correspondiente llamado @c(json.Encoder).

#    The call to @c(Decode) populates the variable @c(result). There are various
#    ways we can format its value nicely. The simplest, demonstrated by the
#    @c(issues) command below, is as a text table with fixed-width columns, but in
#    the next section we’ll see a more sophisticated approach based on templates.
   La llamada a @c(Decode) rellena la variable @c(result). Hay varias maneras en
   que podemos dar un formato agradable a su valor. A continuacion mostramos el
   mas simple, con el commando @c(issues), es como una tabla de texto con
   columnas de ancho fijo, pero en la siguiente seccion vamos a ver un enfoque
   mas sofisticado basado en plantillas.

#    ..figure > @l(gopl.io/ch4/issues/main.go<>gopl.io/ch4/issues)
   ..figure > @l(gopl.io/ch4/issues/main.go<>gopl.io/ch4/issues)

#      ..src > go
#        // Issues prints a table of GitHub issues matching the search terms.
#        package main
#
#        import (
#          "fmt"
#          "log"
#          "os"
#
#          "gopl.io/ch4/github"
#        )
#
#        func main() {
#          result, err := github.SearchIssues(os.Args[1:])
#          if err != nil {
#            log.Fatal(err)
#          }
#          fmt.Printf("%d issues:\n", result.TotalCount)
#          for _, item := range result.Items {
#            fmt.Printf("#%-5d %9.9s %.55s\n",
#              item.Number, item.User.Login, item.Title)
#          }
#        }
#      < src..
     ..src > go
       // Issues imprime una tabla de coincidencia de problemas que coinciden
       // con los terminos de busqueda
       package main

       import (
         "fmt"
         "log"
         "os"

         "gopl.io/ch4/github"
       )

       func main() {
         result, err := github.SearchIssues(os.Args[1:])
         if err != nil {
           log.Fatal(err)
         }
         fmt.Printf("%d issues:\n", result.TotalCount)
         for _, item := range result.Items {
           fmt.Printf("#%-5d %9.9s %.55s\n",
             item.Number, item.User.Login, item.Title)
         }
       }
     < src..


#    The command-line arguments specify the search terms. The command below
#    queries the Go project’s issue tracker for the list of open bugs related to
#    JSON decoding:
   Los argumentos de linea de comandos especifican los terminos de busqueda. El
   comando siguiente consulta el rastreador de problemas del proyecto Go para la
   lista de errores abiertos relacionados con la descodificacion JSON:

#    ..src > sh
#      $ go build gopl.io/ch4/issues
#      $ ./issues repo:golang/go is:open json decoder
#      13 issues:
#      #5680    eaigner encoding/json: set key converter on en/decoder
#      #6050  gopherbot encoding/json: provide tokenizer
#      #8658  gopherbot encoding/json: use bufio
#      #8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal
#      #5901        rsc encoding/json: allow override type marshaling
#      #9812  klauspost encoding/json: string tag not symmetric
#      #7872  extempora encoding/json: Encoder internally buffers full output
#      #9650    cespare encoding/json: Decoding gives errPhase when unmarshalin
#      #6716  gopherbot encoding/json: include field name in unmarshal error me
#      #6901  lukescott encoding/json, encoding/xml: option to treat unknown fi
#      #6384    joeshaw encoding/json: encode precise floating point integers u
#      #6647    btracey x/tools/cmd/godoc: display type kind of each named type
#      #4237  gjemiller encoding/base64: URLEncoding padding is optional
#    < src..
   ..src > sh
     $ go build gopl.io/ch4/issues
     $ ./issues repo:golang/go is:open json decoder
     13 issues:
     #5680    eaigner encoding/json: set key converter on en/decoder
     #6050  gopherbot encoding/json: provide tokenizer
     #8658  gopherbot encoding/json: use bufio
     #8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal
     #5901        rsc encoding/json: allow override type marshaling
     #9812  klauspost encoding/json: string tag not symmetric
     #7872  extempora encoding/json: Encoder internally buffers full output
     #9650    cespare encoding/json: Decoding gives errPhase when unmarshalin
     #6716  gopherbot encoding/json: include field name in unmarshal error me
     #6901  lukescott encoding/json, encoding/xml: option to treat unknown fi
     #6384    joeshaw encoding/json: encode precise floating point integers u
     #6647    btracey x/tools/cmd/godoc: display type kind of each named type
     #4237  gjemiller encoding/base64: URLEncoding padding is optional
   < src..

#    The GitHub web-service interface at @l(https://developer.github.com/v3/) has
#    many more features than we have space for here.
   La interfaz de servicio web en GitHub @l(https://developer.github.com/v3/)
   tiene muchas mas funciones delas que tenemos espacio para mostrar aqui.

#    @b(Exercise 4.10): Modify @c(issues) to report the results in age categories,
#    say less than a month old, less than a year old, and more than a year old.
   @b(Ejercicio 4.10): Modificar @c(issues) para reportar los resultados en
   categorias de edad, es decir menos de un mes de edad, menos de un año de
   edad, y mas de un año de edad.

#    @b(Exercise 4.11): Build a tool that lets users create, read, update, and
#    delete GitHub issues from the command line, invoking their preferred text
#    editor when substantial text input is required.
   @b(Ejercicio 4.11): Construir una herramienta que permite a los usuarios
   crear, leer, actualizar y eliminar los problemas de GitHub desde la linea de
   comandos, invocando su editor de texto preferido cuando se requiera la
   introduccion de texto sustancial.

#    @b(Exercise 4.12): The popular web comic @e(xkcd) has a JSON interface. For
#    example, a request to @l(https://xkcd.com/571/info.0.json) produces a
#    detailed description of comic 571, one of many favorites. Download each URL
#    (once!)  and build an offline index. Write a tool @$(xkcd) that, using this
#    index, prints the URL and transcript of each comic that matches a search term
#    provided on the command line.
   @b(Ejercicio 4.12): El popular comic web @e(xkcd) tiene una interfaz
   JSON. Por ejemplo, una solicitud a @l(https://xkcd.com/571/info.0.json)
   produce una descripcion detallada del comic 571, uno de mis muchos
   favoritos. Descargue cada URL (una vez) y construya un indice sin
   conexion. Escriba una herramienta @$(xkcd) que, utilizando este indice,
   imprima la URL y transcripcion de cada comic que coincida con un termino de
   busqueda proporcionado en la linea de comandos.

#    @b(Exercise 4.13): The JSON-based web service of the Open Movie Database lets
#    you search @l(https://omdbapi.com/) for a movie by name and download its
#    poster image. Write a tool @$(poster) that downloads the poster image for the
#    movie named on the command line.
   @b(Ejercicio 4.13): El servicio web basado en JSON de Open Movie Database le
   permite buscar en @l(https://omdbapi.com/) una pelicula por su nombre y
   descargar la su imagen del poster. Escriba una herramienta @$(poster) que
   descargue la imagen del poster de la pelicula que se nombre en la linea de
   comandos.

# ** Section 4.6 <> Text and HTML Templates
** Seccion 4.6 <> Plantillas de Texto y HTML

#    The previous example does only the simplest possible formatting, for which
#    @c(Printf) is entirely adequate. But sometimes formatting must be more
#    elaborate, and it’s desirable to separate the format from the code more
#    completely. This can be done with the @c(text/template) and @c(html/template)
#    packages, which provide a mechanism for substituting the values of variables
#    into a text or HTML template.
   El ejemplo anterior muestra como hacer el formato lo mas simple posible, para
   lo cual @c(Printf) es completamente adecuado. Pero a veces el formato debe
   ser mas elaborado, y es deseable separar el formato del codigo completamente.
   Esto se puede hacer con los paquetes @c(text/template) y @c(html/template),
   que proporcionan un mecanismo para la sustitucion de los valores de las
   variables en una plantilla de texto o HTML.

#    A template is a string or file containing one or more portions enclosed in
#    double braces, @c({{...}}), called @e(actions). Most of the string is printed
#    literally, but the actions trigger other behaviors. Each action contains an
#    expression in the template language, a simple but powerful notation for
#    printing values, selecting struct fields, calling functions and methods,
#    expressing control flow such as @c(if)-@c(else) statements and @c(range)
#    loops, and instantiating other templates. A simple template string is shown
#    below:
   Una plantilla es una cadena o un archivo que contiene una o mas partes
   encerradas entre llaves dobles, @c({{...}}), llamadas @e(acciones). La mayor
   parte de la cadena se imprime literalmente, pero las acciones desencadenan
   otros comportamientos. Cada accion contiene una expresion en el lenguaje de
   la plantilla, una notacion sencilla pero poderosa para imprimir valores,
   seleccionar de campos de la estructura, llamar a la funciones y metodos,
   expresar el flujo de control, como sentencias @c(if)-@c(else) y bucles
   @c(range), y crear instancias de otras plantillas. A continuacion se muestra
   una cadena de plantilla simple:

#    ..figure > @l(gopl.io/ch4/issuesreport/main.go<>gopl.io/ch4/issuesreport)
   ..figure > @l(gopl.io/ch4/issuesreport/main.go<>gopl.io/ch4/issuesreport)

#      ..src > go
#        const templ = `{{.TotalCount}} issues:
#        {{range .Items}}----------------------------------------
#        Number: {{.Number}}
#        User:   {{.User.Login}}
#        Title:  {{.Title | printf "%.64s"}}
#        Age:    {{.CreatedAt | daysAgo}} days
#        {{end}}`
#      < src..
     ..src > go
       const templ = `{{.TotalCount}} issues:
       {{range .Items}}----------------------------------------
       Number: {{.Number}}
       User:   {{.User.Login}}
       Title:  {{.Title | printf "%.64s"}}
       Age:    {{.CreatedAt | daysAgo}} days
       {{end}}`
     < src..


#    This template first prints the number of matching issues, then prints the
#    number, user, title, and age in days of each one. Within an action, there is
#    a notion of the current value, referred to as @"(dot) and written as @"(.), a
#    period. The dot initially refers to the template’s parameter, which will be a
#    @c(github.IssuesSearchResult) in this example. The @c({{.TotalCount}}) action
#    expands to the value of the @c(TotalCount) field, printed in the usual
#    way. The @c({{range .Items}}) and @c({{end}}) actions create a loop, so the
#    text between them is expanded multiple times, with dot bound to successive
#    elements of @c(Items).
   Esta plantilla primero imprime el numero de problemas encontrados, luego
   imprime el numero, usuario, titulo y edad en dias de cada uno. Dentro de una
   accion, hay una nocion del valor actual, denominado como @"(punto) y escrita
   como @"(.), un punto. El punto se refiere inicialmente al parametro de la
   plantilla, que sera en este ejemplo @c(github.IssuesSearchResult). La accion
   @c({{.TotalCount}}) expande al valor del campo @c(TotalCount), que se imprime
   en la forma habitual. Las acciones @c({{range .Items}}) y @c({{end}}) crean
   un bucle, por lo que el texto entre ellos se expande varias veces, con el
   punto ligado a elementos sucesivos de @c(Items).

#    Within an action, the @c(|) notation makes the result of one operation the
#    argument of another, analogous to a Unix shell pipeline. In the case of
#    @c(Title), the second operation is the @c(printf) function, which is a
#    built-in synonym for @c(fmt.Sprintf) in all templates. For @c(Age), the
#    second operation is the following function, @c(daysAgo), which converts the
#    @c(CreatedAt) field into an elapsed time, using @c(time.Since):
   Dentro de una accion, la notacion @c(|) hace que el resultado de una
   operacion sea el argumento de otra, analoga a una tuberia del shell de
   Unix. En el caso de @c(Title), la segunda operacion es la funcion @c(printf),
   que es un sinonimo nativo para @c(fmt.Sprintf) en todas las plantillas. Para
   @c(Age), la segunda operacion es la funcion, @c(daysAgo), que convierte el
   campo @c(CreatedAt) en el tiempo transcurrido, usando @c(time.Since):

#    ..src > go
#      func daysAgo(t time.Time) int {
#        return int(time.Since(t).Hours() / 24)
#      }
#    < src..
   ..src > go
     func daysAgo(t time.Time) int {
       return int(time.Since(t).Hours() / 24)
     }
   < src..

#    Notice that the type of @c(CreatedAt) is @c(time.Time), not @c(string). In
#    the same way that a type may control its string formatting (@l(#Section
#    2.5<>§2.5)) by defining certain methods, a type may also define methods to
#    control its JSON marshaling and unmarshaling behavior. The JSON-marshaled
#    value of a @c(time.Time) is a string in a standard format.
   Observe que el tipo de @c(CreatedAt) es @c(time.Time), no @c(string). Del
   mismo modo que un tipo puede controlar su formato de cadena (@l(#Seccion
   2.5<>§2.5)) mediante la definicion de ciertos metodos, un tipo puede definir
   tambien metodos para controlar su comportamiento para el marshaling y
   unmarshaling JSON. El valor marshaling JSON de un @c(time.Time) es una cadena
   en un formato estandar.

#    Producing output with a template is a two-step process. First we must parse
#    the template into a suitable internal representation, and then execute it on
#    specific inputs. Parsing need be done only once. The code below creates and
#    parses the template @c(templ) defined above. Note the chaining of method
#    calls: @c(template.New) creates and returns a template; @c(Funcs) adds
#    @c(daysAgo) to the set of functions accessible within this template, then
#    returns that template; finally, @c(Parse) is called on the result.
   Producir la salida con una plantilla es un proceso de dos pasos. Primero
   debemos analizar la plantilla en una representacion interna adecuada, y luego
   ejecutarla en entradas especificas. El analisis se debe hacer solo una
   vez. El siguiente codigo crea y analiza la plantilla templ definida
   anteriormente. Observe el encadenamiento de llamadas a metodos:
   @c(template.New) crea y devuelve una plantilla; @c(Funcs) añade @c(daysAgo)
   al conjunto de funciones accesibles dentro de esta plantilla, luego, devuelve
   esa plantilla; Por ultimo, se llama a @c(Parse) en el resultado.

#    ..src > go
#      report, err := template.New("report").
#        Funcs(template.FuncMap{"daysAgo": daysAgo}).
#        Parse(templ)
#      if err != nil {
#        log.Fatal(err)
#      }
#    < src..
   ..src > go
     report, err := template.New("report").
       Funcs(template.FuncMap{"daysAgo": daysAgo}).
       Parse(templ)
     if err != nil {
       log.Fatal(err)
     }
   < src..

#    Because templates are usually fixed at compile time, failure to parse a
#    template indicates a fatal bug in the program. The @c(template.Must) helper
#    function makes error handling more convenient: it accepts a template and an
#    error, checks that the error is nil (and panics otherwise), and then returns
#    the template. We’ll come back to this idea in @l(#Section 5.9).
   Dado que las plantillas suelen fijarse en tiempo de compilacion, la falta de
   analisis de una plantilla indica un error fatal en el programa. La funcion
   auxiliar @c(template.Must) hace que el manejo de errores sea mas conveniente:
   acepta una plantilla y un error, comprueba que el error es nil (y panicos de
   lo contrario) y, luego devuelve la plantilla. Volveremos a esta idea en la
   @l(#Seccion 5.9).

#    Once the template has been created, augmented with @c(daysAgo), parsed, and
#    checked, we can execute it using a @c(github.IssuesSearchResult) as the data
#    source and @c(os.Stdout) as the destination:
   Una vez la plantilla ha sido creada, aumentada con @c(daysAgo), analizada y
   comprobada, podemos ejecutarla utilizando como fuente de datos
   @c(github.IssuesSearchResult) y @c(os.Stdout) como el destino:

#    ..src > go
#      var report = template.Must(template.New("issuelist").
#        Funcs(template.FuncMap{"daysAgo": daysAgo}).
#        Parse(templ))
#
#      func main() {
#        result, err := github.SearchIssues(os.Args[1:])
#        if err != nil {
#          log.Fatal(err)
#        }
#        if err := report.Execute(os.Stdout, result); err != nil {
#          log.Fatal(err)
#        }
#      }
#    < src..
   ..src > go
     var report = template.Must(template.New("issuelist").
       Funcs(template.FuncMap{"daysAgo": daysAgo}).
       Parse(templ))

     func main() {
       result, err := github.SearchIssues(os.Args[1:])
       if err != nil {
         log.Fatal(err)
       }
       if err := report.Execute(os.Stdout, result); err != nil {
         log.Fatal(err)
       }
     }
   < src..

#    The program prints a plain text report like this:
   El programa imprime un informe en texto plano como este:

#    ..src > sh
#      $ go build gopl.io/ch4/issuesreport
#      $ ./issuesreport repo:golang/go is:open json decoder
#      13 issues:
#      ---------------------------------------
#      Number: 5680
#      User:   eaigner
#      Title:  encoding/json: set key converter on en/decoder
#      Age:    750 days
#      ---------------------------------------
#      Number: 6050
#      User:   gopherbot
#      Title:  encoding/json: provide tokenizer
#      Age:    695 days
#      ---------------------------------------
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch4/issuesreport
     $ ./issuesreport repo:golang/go is:open json decoder
     13 issues:
     ---------------------------------------
     Number: 5680
     User:   eaigner
     Title:  encoding/json: set key converter on en/decoder
     Age:    750 days
     ---------------------------------------
     Number: 6050
     User:   gopherbot
     Title:  encoding/json: provide tokenizer
     Age:    695 days
     ---------------------------------------
     ...
   < src..

#    Now let’s turn to the @c(html/template) package. It uses the same API and
#    expression language as @c(text/template) but adds features for automatic and
#    context-appropriate escaping of strings appearing within HTML, JavaScript,
#    CSS, or URLs. These features can help avoid a perennial security problem of
#    HTML generation, an @e(injection attack), in which an adversary crafts a
#    string value like the title of an issue to include malicious code that, when
#    improperly escaped by a template, gives them control over the page.
   Ahora pasemos al paquete @c(html/template). Utiliza el mismo API y el mismo
   lenguaje de expresion que @c(text/template) pero añade caracteristicas para
   el escape automatico y apropiado de cadanes que aparecen dentro de HTML,
   JavaScript, CSS o URLs. Estas caracteristicas pueden ayudar a evitar un
   problema de seguridad perenne de la generacion de HTML, un @e(ataque de
   inyeccion), en el que un adversario crea un valor de cadena como el titulo de
   un tema, para incluir codigo malicioso, que cuando se escapa indebidamente
   por una plantilla, les da control sobre la pagina.

#    The template below prints the list of issues as an HTML table. Note the
#    different import:
   La plantilla siguiente muestra la lista de temas como una tabla HTML.
   Observe la diferente importacion:

#    ..figure > @l(gopl.io/ch4/issueshtml/main.go<>gopl.io/ch4/issueshtml)
   ..figure > @l(gopl.io/ch4/issueshtml/main.go<>gopl.io/ch4/issueshtml)

#      ..src > go
#        import "html/template"
#
#        var issueList = template.Must(template.New("issuelist").Parse(`
#        <h1>{{.TotalCount}} issues</h1>
#        <table>
#        <tr style='text-align: left'>
#          <th>#</th>
#          <th>State</th>
#          <th>User</th>
#          <th>Title</th>
#        </tr>
#        {{range .Items}}
#        <tr>
#          <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>
#          <td>{{.State}}</td>
#          <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>
#          <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>
#        </tr>
#        {{end}}
#        </table>
#        `))
#      < src..
     ..src > go
       import "html/template"

       var issueList = template.Must(template.New("issuelist").Parse(`
       <h1>{{.TotalCount}} issues</h1>
       <table>
       <tr style='text-align: left'>
         <th>#</th>
         <th>State</th>
         <th>User</th>
         <th>Title</th>
       </tr>
       {{range .Items}}
       <tr>
         <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>
         <td>{{.State}}</td>
         <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>
         <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>
       </tr>
       {{end}}
       </table>
       `))
     < src..


#    The command below executes the new template on the results of a slightly
#    different query:
   El siguiente comando ejecuta la nueva plantilla en los resultados de una
   consulta ligeramente diferente:

#    ..src > sh
#      $ go build gopl.io/ch4/issueshtml
#      $ ./issueshtml repo:golang/go commenter:gopherbot json encoder >issues.html
#    < src..
   ..src > sh
     $ go build gopl.io/ch4/issueshtml
     $ ./issueshtml repo:golang/go commenter:gopherbot json encoder >issues.html
   < src..

#    Figure 4.4 shows the appearance of the table in a web browser. The links
#    connect to the appropriate web pages at GitHub.
   La figura 4.4 muestra la apariencia de la tabla en un navegador web. Los
   enlaces se conectan a las paginas web apropiadas en GitHub.

#    ..figure > Figure 4.4. An HTML table of Go project issues relating to JSON
#      encoding.
   ..figure > Figura 4.4. Una tabla HTML de los temas del proyecto Go
     relacionados con la codificacion JSON.

#      ..img > img/Figure-4.4.jpg
     ..img > img/Figure-4.4.jpg


#    None of the issues in Figure 4.4 pose a challenge for HTML, but we can see
#    the effect more clearly with issues whose titles contain HTML metacharacters
#    like @c(&) and @c(<). We’ve selected two such issues for this example:
   Ninguno de los temas en la Figura 4.4 representan un desafio para HTML, pero
   podemos ver el efecto mas claramente con temas cuyos titulos contienen
   metacaracteres HTML como @c(&) y @c(<). Hemos seleccionado dos problemas para
   este ejemplo:

#    ..src > sh
#      $ ./issueshtml repo:golang/go 3133 10535 >issues2.html
#    < src..
   ..src > sh
     $ ./issueshtml repo:golang/go 3133 10535 >issues2.html
   < src..

#    Figure 4.5 shows the result of this query. Notice that the @c(html/template)
#    package automatically HTML-escaped the titles so that they appear
#    literally. Had we used the @c(text/template) package by mistake, the
#    four-character string @c("&lt;") would have been rendered as a less-than
#    character @c('<'), and the string @c("<link>") would have become a @c(link)
#    element, changing the structure of the HTML document and perhaps compromising
#    its security.
   La Figura 4.5 muestra el resultado de esta consulta. Observe que el paquete
   @c(html/template) de forma automatica escapa los titulos HTML de modo que
   aparezcan literalmente. Si por error hubieramos usado el paquete
   @c(text/template), la cadena de cuatro caracteres "&lt;" se habria convertido
   en el caracter @c('<') y la cadena @c("<link>") se habria convertido en un
   elemento @c(link), cambiando la estructura del documento HTML y tal vez
   comprometiendo su seguridad.

#    We can suppress this auto-escaping behavior for fields that contain trusted
#    HTML data by using the named string type @c(template.HTML) instead of
#    @c(string). Similar named types exist for trusted JavaScript, CSS, and
#    URLs. The program below demonstrates the principle by using two fields with
#    the same value but different types: @c(A) is a string and @c(B) is a
#    @c(template.HTML).
   Podemos suprimir este comportamiento de auto-escape para los campos que
   contienen datos HTML confiables mediante el uso de un  tipo de cadena
   denominada @c(template.HTML) en lugar de @c(string) . Existen tipos con nombres
   similares para JavaScript, CSS y URL de confianza. El siguiente programa
   demuestra el principio usando  campos con el mismo valor, pero
   con diferentes tipos: c(A) es un @c(string) y @c(B) es un @c(template.HTML).

#    ..figure > Figure 4.5. HTML metacharacters in issue titles are correctly
#      displayed.
   ..figure > Figura 4.5. Los metacaracteres HTML del titulos de temas se
     muestran correctamente.

#      ..img > img/Figure-4.5.jpg
     ..img > img/Figure-4.5.jpg

#    ..figure > @l(gopl.io/ch4/autoescape/main.go<>gopl.io/ch4/autoescape)
   ..figure > @l(gopl.io/ch4/autoescape/main.go<>gopl.io/ch4/autoescape)

#      ..src > go
#        func main() {
#          const templ = `<p>A: {{.A}}</p><p>B: {{.B}}</p>`
#          t := template.Must(template.New("escape").Parse(templ))
#          var data struct {
#            A string        // untrusted plain text
#            B template.HTML // trusted HTML
#          }
#          data.A = "<b>Hello!</b>"
#          data.B = "<b>Hello!</b>"
#          if err := t.Execute(os.Stdout, data); err != nil {
#            log.Fatal(err)
#          }
#        }
#      < src..
     ..src > go
       func main() {
         const templ = `<p>A: {{.A}}</p><p>B: {{.B}}</p>`
         t := template.Must(template.New("escape").Parse(templ))
         var data struct {
           A string        // texto sin fiavilidad
           B template.HTML // HTML confiable
         }
         data.A = "<b>Hello!</b>"
         data.B = "<b>Hello!</b>"
         if err := t.Execute(os.Stdout, data); err != nil {
           log.Fatal(err)
         }
       }
     < src..


#    Figure 4.6 shows the template’s output as it appears in a browser. We can see
#    that @c(A) was subject to escaping but @c(B) was not.
   La Figura 4.6 muestra la salida de la plantilla tal como aparece en un
   navegador. Podemos ver que @c(A) esta sujeto a escapar, pero @c(B) no.

#    ..figure > Figure 4.6. String values are HTML-escaped but @c(template.HTML)
#      values are not.
   ..figure > Figura 4.6. Los valores de cadena tinen escapado HTML escapado,
     pero los valores @c(template.HTML) no.

#      ..img > img/Figure-4.6.jpg
     ..img > img/Figure-4.6.jpg


#    We have space here to show only the most basic features of the template
#    system. As always, for more information, consult the package documentation:
   Tenemos espacio aqui para mostrar solo las caracteristicas mas basicas del
   sistema de plantillas. Como siempre, para obtener mas informacion, consulte
   la documentacion del paquete:

#    ..src > sh
#      $ go doc text/template
#      $ go doc html/template
#    < src..
   ..src > sh
     $ go doc text/template
     $ go doc html/template
   < src..

#    @b(Exercise 4.14): Create a web server that queries GitHub once and then
#    allows navigation of the list of bug reports, milestones, and users.
   @b(Ejercicio 4.14): Crear un servidor web que consulta GitHub una vez y luego
   permita la navegacion de la lista de informe de errores, hitos y usuarios.

# * Chapter 5 <> Functions
* Capitulo 5 <> Funciones

#   A function lets us wrap up a sequence of statements as a unit that can be
#   called from elsewhere in a program, perhaps multiple times. Functions make it
#   possible to break a big job into smaller pieces that might well be written by
#   different people separated by both time and space.  A function hides its
#   implementation details from its users. For all of these reasons, functions are
#   a critical part of any programming language.
  Una funcion nos permite envolver una secuencia de sentencias como una unidad
  que se puede llamar desde cualquier lugar de un programa, tal vez varias
  veces. Las funciones hacen posible romper un gran trabajo en pedazos mas
  pequeños que bien podrian ser escritos por diferentes personas separadas por
  el tiempo y el espacio. Una funcion oculta sus detalles de implementacion a
  sus usuarios. Por todas estas razones, las funciones son una parte critica de
  cualquier lenguaje de programacion.

#   We’ve seen many functions already. Now let’s take time for a more thorough
#   discussion. The running example of this chapter is a web crawler, that is, the
#   component of a web search engine responsible for fetching web pages,
#   discovering the links within them, fetching the pages identified by those
#   links, and so on. A web crawler gives us ample opportunity to explore
#   recursion, anonymous functions, error handling, and aspects of functions that
#   are unique to Go.
  Ya hemos visto muchas funciones. Ahora tomaremos un tiempo para una discusion
  mas exhaustiva. El ejemplo de ejecucion de este capitulo es un rastreador web,
  es decir, el componente de un motor de busqueda web responsable de buscar
  paginas web, descubrir los vinculos dentro de ellas, buscar las paginas
  identificadas por dichos vinculos, etc. Un rastreador web nos da una amplia
  oportunidad para explorar la recursividad, funciones anonimas, manejo de
  errores y aspectos de funciones que son unicos de Go.

# ** Section 5.1 <> Function Declarations
** Seccion 5.1 <> Declaracion de Funciones

#    A function declaration has a name, a list of parameters, an optional list of
#    results, and a body:
   Una declaracion de funcion tiene un nombre, una lista de parametros, una
   lista opcional de resultados y un cuerpo:

#    ..src > go
#      func name(parameter-list) (result-list) {
#        body
#      }
#    < src..
   ..src > go
     func rombre(lista-de-parametros) (lista-de-resultados) {
       cuerpo
     }
   < src..

#    The parameter list specifies the names and types of the function’s
#    @e(parameters), which are the local variables whose values or @e(arguments)
#    are supplied by the caller. The result list specifies the types of the values
#    that the function returns. If the function returns one unnamed result or no
#    results at all, parentheses are optional and usually omitted. Leaving off the
#    result list entirely declares a function that does not return any value and
#    is called only for its effects. In the @c(hypot) function,
   La lista de parametros especifica el nombres y tipos de los @e(parametros) de
   la funcion, que son las variables locales cuyos valores o argumentos son
   suministrados por quien hace la llamada. La lista de resultados especifica
   los tipos de los valores que devuelve la funcion. Si la funcion devuelve un
   resultado sin nombre o ningun resultado, los parentesis son opcionales y
   normalmente se omiten. Dejar fuera la lista de resultados declara
   completamente que una funcion que no devuelve ningun valor y se llama solo
   por sus efectos. En la funcion @c(hypot),

#    ..src > go
#      func hypot(x, y float64) float64 {
#        return math.Sqrt(x*x + y*y)
#      }
#
#      fmt.Println(hypot(3, 4)) // "5"
#    < src..
   ..src > go
     func hypot(x, y float64) float64 {
       return math.Sqrt(x*x + y*y)
     }

     fmt.Println(hypot(3, 4)) // "5"
   < src..

#    @c(x) and @c(y) are parameters in the declaration, @c(3) and @c(4) are
#    arguments of the call, and the function returns a @c(float64) value.
   @c(x) y @c(y) son parametros en la declaracion, @c(3) y @c(4) son argumentos
   de la llamada, y la funcion devuelve un valor @c(float64).

#    Like parameters, results may be named. In that case, each name declares a
#    local variable initialized to the zero value for its type.
   Al igual que los parametros, los resultados pueden tener nombre. En ese caso,
   cada nombre declara una variable local inicializada al valor cero para su
   tipo.

#    A function that has a result list must end with a @c(return) statement unless
#    execution clearly cannot reach the end of the function, perhaps because the
#    function ends with a call to @c(panic) or an infinite @c(for) loop with no
#    @c(break).
   Una funcion que tiene una lista de resultados debe terminar con una
   declaracion @c(return), a menos que la ejecucion claramente no pueda llegar
   al final de la funcion, tal vez porque la funcion termina con una llamada a
   @c(panic) o un bucle @c(for) infinito sin @c(break).

#    As we saw with @c(hypot), a sequence of parameters or results of the same
#    type can be factored so that the type itself is written only once. These two
#    declarations are equivalent:
   Como hemos visto con @c(hypot), una secuencia de parametros o resultados del
   mismo tipo puede ser un factor para que el propio tipo se escriba una sola
   vez. Estas dos declaraciones son equivalentes:

#    ..src > go
#      func f(i, j, k int, s, t string)                { /* ... */ }
#      func f(i int, j int, k int, s string, t string) { /* ... */ }
#    < src..
   ..src > go
     func f(i, j, k int, s, t string)                { /* ... */ }
     func f(i int, j int, k int, s string, t string) { /* ... */ }
   < src..

#    Here are four ways to declare a function with two parameters and one result,
#    all of type @c(int).  The blank identifier can be used to emphasize that a
#    parameter is unused.
   Aqui hay cuatro formas de declarar una funcion con dos parametros y un
   resultado, todos de tipo @c(int). El identificador en blanco puede usarse
   para enfatizar que un parametro no se utiliza.

#    ..src > go
#      func add(x int, y int) int   { return x + y }
#      func sub(x, y int) (z int)   { z = x - y; return }
#      func first(x int, _ int) int { return x }
#      func zero(int, int) int      { return 0 }
#
#      fmt.Printf("%T\n", add)   // "func(int, int) int"
#      fmt.Printf("%T\n", sub)   // "func(int, int) int"
#      fmt.Printf("%T\n", first) // "func(int, int) int"
#      fmt.Printf("%T\n", zero)  // "func(int, int) int"
#    < src..
   ..src > go
     func add(x int, y int) int   { return x + y }
     func sub(x, y int) (z int)   { z = x - y; return }
     func first(x int, _ int) int { return x }
     func zero(int, int) int      { return 0 }

     fmt.Printf("%T\n", add)   // "func(int, int) int"
     fmt.Printf("%T\n", sub)   // "func(int, int) int"
     fmt.Printf("%T\n", first) // "func(int, int) int"
     fmt.Printf("%T\n", zero)  // "func(int, int) int"
   < src..

#    The type of a function is sometimes called its @e(signature). Two functions
#    have the same type or signature if they have the same sequence of parameter
#    types and the same sequence of result types. The names of parameters and
#    results don’t affect the type, nor does whether or not they were declared
#    using the factored form.
   El tipo de una funcion a veces se denomina su @e(firma). Dos funciones tienen
   el mismo tipo o firma si tienen la misma secuencia de tipos de parametros y
   la misma secuencia de tipos de resultados. Los nombres de los parametros y
   resultados no afectan al tipo, ni tampoco si se declararon utilizando el
   formto factorizado.

#    Every function call must provide an argument for each parameter, in the order
#    in which the parameters were declared. Go has no concept of default parameter
#    values, nor any way to specify arguments by name, so the names of parameters
#    and results don’t matter to the caller except as documentation.
   Cada llamada de funcion debe proporcionar un argumento para cada parametro,
   en el orden en que se declararon los parametros. Go no tiene concepto de
   valores de parametro predeterminados, ni ninguna forma de especificar
   argumentos por nombre, por lo que los nombres de parametros y resultados no
   importan al llamador, excepto como documentacion.

#    Parameters are local variables within the body of the function, with their
#    initial values set to the arguments supplied by the caller. Function
#    parameters and named results are variables in the same lexical block as the
#    function’s outermost local variables.
   Los parametros son variables locales dentro del cuerpo de la funcion, con sus
   valores iniciales establecidos a los argumentos proporcionados por quien
   realiza la llamada. Los parametros de funcion y los resultados con nombre son
   variables en el mismo bloque lexico que las variables locales mas externas de
   la funcion.

#    Arguments are passed @e(by value), so the function receives a copy of each
#    argument; modifications to the copy do not affect the caller. However, if the
#    argument contains some kind of reference, like a pointer, slice, map,
#    function, or channel, then the caller may be affected by any modifications
#    the function makes to variables @e(indirectly) referred to by the argument.
   Los argumentos se pasan por valor, por lo que la funcion recibe una copia de
   cada argumento; Las modificaciones a la copia no afectan a la persona que
   llama. Sin embargo, si el argumento contiene algun tipo de referencia, como
   un puntero, slice, mapa, funcion o canal, entonces la persona que llama puede
   verse afectada por las modificaciones que hace la funcion de las variables
   que referencian @e(indirectamente) por el argumento.

#    You may occasionally encounter a function declaration without a body,
#    indicating that the function is implemented in a language other than Go. Such
#    a declaration defines the function signature.
   De vez en cuando puede encontrar una declaracion de funcion sin un cuerpo, lo
   que indica que la funcion se implementa en un idioma que no es Go. Dicha
   declaracion define la firma de la funcion.

#    ..src > go
#      package math
#
#      func Sin(x float64) float64 // implemented in assembly language
#    < src..
   ..src > go
     package math

     func Sin(x float64) float64 // implementado en lenguaje ensamblador
   < src..

# ** Section 5.2 <> Recursion
** Seccion 5.2 <> Recursividad

#    Functions may be @e(recursive), that is, they may call themselves, either
#    directly or indirectly.  Recursion is a powerful technique for many problems,
#    and of course it’s essential for processing recursive data structures. In
#    @l(#Section 4.4), we used recursion over a tree to implement a simple
#    insertion sort. In this section, we’ll use it again for processing HTML
#    documents.
   Las funciones pueden ser @e(recursivas), es decir, que pueden llamarse a si
   mismas, ya sea directa o indirectamente. La recursion es una tecnica poderosa
   para muchos problemas, y por supuesto es esencial para procesar estructuras
   de datos recursivas. En la @l(#Seccion 4.4), se utilizo la recursividad sobre
   un arbol para implementar un mecanismo de insercion sencillo. En esta
   seccion, volveremos a usarlo para procesar documentos HTML.

#    The example program below uses a non-standard package,
#    @c(golang.org/x/net/html), which provides an HTML parser. The
#    @c(golang.org/x/...) repositories hold packages designed and maintained by
#    the Go team for applications such as networking, internationalized text
#    processing, mobile platforms, image manipulation, cryptography, and developer
#    tools. These packages are not in the standard library because they’re still
#    under development or because they’re rarely needed by the majority of Go
#    programmers.
   El siguiente programa de ejemplo utiliza un paquete no estandar,
   @c(golang.org/x/net/html), que proporciona un analizador de HTML. Los
   repositorios @c(golang.org/x/...) tienen paquetes diseñados y mantenidos por
   el equipo de Go para aplicaciones tales como redes, procesamiento de texto
   internacionalizado, plataformas moviles, manipulacion de imagenes,
   criptografia, y herramientas de desarrollo. Estos paquetes no estan en la
   libreria estandar porque todavia estan en desarrollo o porque son raramente
   necesarios por la mayoria de los programadores de Go.

#    The parts of the @c(golang.org/x/net/html) API that we’ll need are shown
#    below. The function @c(html.Parse) reads a sequence of bytes, parses them,
#    and returns the root of the HTML document tree, which is an @c(html.Node).
#    HTML has several kinds of nodes—text, comments, and so on—but here we are
#    concerned only with element nodes of the form @c(<name key='value'>).
   Las partes de  la API @c(golang.org/x/net/html) que tendremos que se muestran a
   continuacion. La funcion @c(html.Parse) lee una secuencia de bytes, los analiza,
   y devuelve la raiz del arbol del documento HTML, que es un @c(html.Node). HTML
   tiene varios tipos de nodos–texto, comentarios, etc.–pero aqui solo nos
   interesan con nodos de elemento de la forma @c(<nombre clave='valor'>).

#    ..figure > @c(golang.org/x/net/html)
   ..figure > @c(golang.org/x/net/html)

#      ..src > go
#        package html
#        type Node struct {
#          Type                    NodeType
#          Data                    string
#          Attr                    []Attribute
#          FirstChild, NextSibling *Node
#        }
#
#        type NodeType int32
#
#        const (
#          ErrorNode NodeType = iota
#          TextNode
#          DocumentNode
#          ElementNode
#          CommentNode
#          DoctypeNode
#        )
#
#        type Attribute struct {
#          Key, Val string
#        }
#
#        func Parse(r io.Reader) (*Node, error)
#      < src..
     ..src > go
       package html
       type Node struct {
         Type                    NodeType
         Data                    string
         Attr                    []Attribute
         FirstChild, NextSibling *Node
       }

       type NodeType int32

       const (
         ErrorNode NodeType = iota
         TextNode
         DocumentNode
         ElementNode
         CommentNode
         DoctypeNode
       )

       type Attribute struct {
         Key, Val string
       }

       func Parse(r io.Reader) (*Node, error)
     < src..


#    The @c(main) function parses the standard input as HTML, extracts the links
#    using a recursive @c(visit) function, and prints each discovered link:
   La funcion @c(main) analiza la entrada estandar como HTML, extrae los enlaces
   usando un cuncion recursiva @c(visit), e imprime cada enlace descubierto:

#    ..figure > @l(gopl.io/ch5/findlinks1/main.go<>gopl.io/ch5/findlinks1)
   ..figure > @l(gopl.io/ch5/findlinks1/main.go<>gopl.io/ch5/findlinks1)

#      ..src > go
#        // Findlinks1 prints the links in an HTML document read from standard input.
#        package main
#
#        import (
#          "fmt"
#          "os"
#
#          "golang.org/x/net/html"
#        )
#
#        func main() {
#          doc, err := html.Parse(os.Stdin)
#          if err != nil {
#            fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
#            os.Exit(1)
#          }
#          for _, link := range visit(nil, doc) {
#            fmt.Println(link)
#          }
#        }
#      < src..
     ..src > go
       // Findlinks1 imprime los enlaces en un documento HTML leido en la entrada estandar
       package main

       import (
         "fmt"
         "os"

         "golang.org/x/net/html"
       )

       func main() {
         doc, err := html.Parse(os.Stdin)
         if err != nil {
           fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
           os.Exit(1)
         }
         for _, link := range visit(nil, doc) {
           fmt.Println(link)
         }
       }
     < src..


#    The @c(visit) function traverses an HTML node tree, extracts the link from
#    the @c(href) attribute of each @e(anchor) element @c(<a href='...'>), appends
#    the links to a slice of strings, and returns the resulting slice:
   La funcion @c(visit) atraviesa un arbol de nodos HTML, extrae el enlace desde
   el atributo @c(href) de cada elemento de @e(anclaje) @c(<a href='...'>),
   añade los enlaces a un slice de strings, y devuelve el slice resultante:

#    ..src > go
#      // visit appends to links each link found in n and returns the result.
#      func visit(links []string, n *html.Node) []string {
#        if n.Type == html.ElementNode && n.Data == "a" {
#          for _, a := range n.Attr {
#            if a.Key == "href" {
#              links = append(links, a.Val)
#            }
#          }
#        }
#        for c := n.FirstChild; c != nil; c = c.NextSibling {
#          links = visit(links, c)
#        }
#        return links
#      }
#    < src..
   ..src > go
     // visit agrega los enlaces de cada enlace encontrado en n y devuelve el resultado
     func visit(links []string, n *html.Node) []string {
       if n.Type == html.ElementNode && n.Data == "a" {
         for _, a := range n.Attr {
           if a.Key == "href" {
             links = append(links, a.Val)
           }
         }
       }
       for c := n.FirstChild; c != nil; c = c.NextSibling {
         links = visit(links, c)
       }
       return links
     }
   < src..

#    To descend the tree for a node @c(n), @c(visit) recursively calls itself for
#    each of @c(n)’s children, which are held in the @c(FirstChild) linked list.
   Para descender por el arbol a un nodo @c(n), @c(visit) se llama a si misma
   recursivamente para cada uno de los hijos de @c(n), que se mantienen en el
   lista enlazada @c(FirstChild).

#    Let’s run @$(findlinks) on the Go home page, piping the output of @$(fetch)
#    (@l(#Section 1.5<>§1.5)) to the input of @$(findlinks). We’ve edited the
#    output slightly for brevity.
   Vamos a ejecutar @$(findlinks) en la pagina principal de Go, canalizando el
   resultado de @$(fetch) (@l(#Seccion 1.5<>§1.5)) a la entrada de
   @$(findlinks). Hemos modificado la salida ligeramente por brevedad.

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ go build gopl.io/ch5/findlinks1
#      $ ./fetch https://golang.org | ./findlinks1
#      #
#      /doc/
#      /pkg/
#      /help/
#      /blog/
#      http://play.golang.org/
#      //tour.golang.org/
#      https://golang.org/dl/
#      //blog.golang.org/
#      /LICENSE
#      /doc/tos.html
#      http://www.google.com/intl/en/policies/privacy/
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ go build gopl.io/ch5/findlinks1
     $ ./fetch https://golang.org | ./findlinks1
     #
     /doc/
     /pkg/
     /help/
     /blog/
     http://play.golang.org/
     //tour.golang.org/
     https://golang.org/dl/
     //blog.golang.org/
     /LICENSE
     /doc/tos.html
     http://www.google.com/intl/en/policies/privacy/
   < src..

#    Notice the variety of forms of links that appear in the page. Later we’ll see
#    how to resolve them relative to the base URL, @c(https://golang.org), to make
#    absolute URLs.
   Observe la variedad de formas de enlaces que aparecen en la pagina. Mas
   adelante veremos como resolverlos con relacion al URL base,
   @c(https://golang.org), para crear URL absolutas.

#    The next program uses recursion over the HTML node tree to print the
#    structure of the tree in outline. As it encounters each element, it pushes
#    the element’s tag onto a stack, then prints the stack.
   El siguiente programa utiliza la recursion sobre el arbol de nodos HTML para
   imprimir la estructura del arbol en esquema. Cuando encuentra cada elemento,
   empuja la etiqueta del elemento sobre una pila, luego imprime la pila.

#    ..figure > @l(gopl.io/ch5/outline/main.go<>gopl.io/ch5/outline)
   ..figure > @l(gopl.io/ch5/outline/main.go<>gopl.io/ch5/outline)

#      ..src > go
#        func main() {
#          doc, err := html.Parse(os.Stdin)
#          if err != nil {
#            fmt.Fprintf(os.Stderr, "outline: %v\n", err)
#            os.Exit(1)
#          }
#          outline(nil, doc)
#        }
#
#        func outline(stack []string, n *html.Node) {
#          if n.Type == html.ElementNode {
#            stack = append(stack, n.Data) // push tag
#            fmt.Println(stack)
#          }
#          for c := n.FirstChild; c != nil; c = c.NextSibling {
#            outline(stack, c)
#          }
#        }
#      < src..
     ..src > go
       func main() {
         doc, err := html.Parse(os.Stdin)
         if err != nil {
           fmt.Fprintf(os.Stderr, "outline: %v\n", err)
           os.Exit(1)
         }
         outline(nil, doc)
       }

       func outline(stack []string, n *html.Node) {
         if n.Type == html.ElementNode {
           stack = append(stack, n.Data) // push tag
           fmt.Println(stack)
         }
         for c := n.FirstChild; c != nil; c = c.NextSibling {
           outline(stack, c)
         }
       }
     < src..


#    Note one subtlety: although @c(outline) @"(pushes) an element on @c(stack),
#    there is no corresponding pop. When outline calls itself recursively, the
#    callee receives a copy of @c(stack). Although the callee may append elements
#    to this slice, modifying its underlying array and perhaps even allocating a
#    new array, it doesn’t modify the initial elements that are visible to the
#    caller, so when the function returns, the caller’s @c(stack) is as it was
#    before the call.
   Considere una sutileza: aunque @c(outline) @"(empuja) un elemento en el
   @c(stack), no hay ninguna extraccion correspondiente. Cuando @c(outline) se
   llama a si misma de forma recursiva, el receptor recibe una copia del
   @c(stack). Aunque el destinatario de la llamada puede añadir elementos a este
   slice, modificando de su arreglo subyacente e incluso asignando un nuevo
   arreglo, no modifica los elementos iniciales que son visibles para quien
   realiza la llamada, asi que cuando la funcion regresa, el @c(stack) del
   llamantede es tal cual antes de la llamada.

#    Here’s the outline of @c(https://golang.org), again edited for brevity:
   Aqui esta el esquema de @c(https://golang.org), editado nuevamente por
   razones de brevedad:

#    ..src > sh
#      $ go build gopl.io/ch5/outline
#      $ ./fetch https://golang.org | ./outline
#      [html]
#      [html head]
#      [html head meta]
#      [html head title]
#      [html head link]
#      [html body]
#      [html body div]
#      [html body div]
#      [html body div div]
#      [html body div div form]
#      [html body div div form div]
#      [html body div div form div a]
#    < src..
   ..src > sh
     $ go build gopl.io/ch5/outline
     $ ./fetch https://golang.org | ./outline
     [html]
     [html head]
     [html head meta]
     [html head title]
     [html head link]
     [html body]
     [html body div]
     [html body div]
     [html body div div]
     [html body div div form]
     [html body div div form div]
     [html body div div form div a]
   < src..

#    As you can see by experimenting with @c(outline), most HTML documents can be
#    processed with only a few levels of recursion, but it’s not hard to construct
#    pathological web pages that require extremely deep recursion.
   Como puede ver mediante la experimentacion con @c(outline), la mayoria de los
   documentos HTML pueden ser procesados con solo unos pocos niveles de
   recursividad, pero no es dificil de construir paginas web patologicas que
   requieren una recursion extremadamente profunda.

#    Many programming language implementations use a fixed-size function call
#    stack; sizes from 64KB to 2MB are typical. Fixed-size stacks impose a limit
#    on the depth of recursion, so one must be careful to avoid a @e(stack
#    overflow) when traversing large data structures recursively; fixed-size
#    stacks may even pose a security risk. In contrast, typical Go implementations
#    use variable-size stacks that start small and grow as needed up to a limit on
#    the order of a gigabyte.  This lets us use recursion safely and without
#    worrying about overflow.
   Muchas implementaciones de lenguaje de programacion utilizan una funcion
   stack de tamaño fijo; Tamaños de 64KB a 2MB son tipicos. Pilas de tamaño fijo
   imponen un limite en la profundidad de la recursividad, por lo que hay que
   tener cuidado para evitar un desbordamiento de pila cuando se atraviesa
   grandes estructuras de datos de forma recursiva; Las pilas de tamaño fijo
   pueden incluso suponer un riesgo para la seguridad. En contraste, las
   implementaciones tipicas de Go usan pilas de tamaño variable que comienzan
   pequeñas y crecen segun sea necesario hasta un limite del orden de un
   gigabyte. Esto nos permite usar la recursion de forma segura y sin
   preocuparnos por el desbordamiento.

#    @b(Exercise 5.1): Change the @$(findlinks) program to traverse the
#    @c(n.FirstChild) linked list using recursive calls to @c(visit) instead of a
#    loop.
   @b(Ejercicio 5.1): Cambiar el programa @$(findlinks) para atravesar la lista
   enlazada @c(n.FirstChild) mediante llamadas recursivas a @c(visit) en lugar
   de un bucle.

#    @b(Exercise 5.2): Write a function to populate a mapping from element
#    names—@c(p), @c(div), @c(span), and so on—to the number of elements with that
#    name in an HTML document tree.
   @b(Ejercicio 5.2): Escribir una funcion para rellenar un mapeo con los
   nombres de los elementos–@c(p), @c(div), @c(span), y asi sucesivamente-al
   numero de elementos con ese nombre en un arbol de documentos HTML.

#    @b(Exercise 5.3): Write a function to print the contents of all text nodes in
#    an HTML document tree. Do not descend into @c(<script>) or @c(<style>)
#    elements, since their contents are not visible in a web browser.
   @b(Ejercicio 5.3): Escribir una funcion para imprimir el contenido de todos
   los nodos de texto en un arbol de documentos HTML. No descender dentro de
   elementos @c(<script>) o @c(<style>), ya que sus contenidos no son visibles
   en un navegador web.

#    @b(Exercise 5.4): Extend the @c(visit) function so that it extracts other
#    kinds of links from the document, such as images, scripts, and style sheets.
   @b(Ejercicio 5.4): Extender la funcion @c(visit) para que los extractos otros
   tipos de enlaces desde el documento, como imagenes, scripts y hojas de
   estilo.

# ** Section 5.3 <> Multiple Return Values
** Seccion 5.3 <> Multiples Valores de Retorno

#    A function can return more than one result. We’ve seen many examples of
#    functions from standard packages that return two values, the desired
#    computational result and an error value or boolean that indicates whether the
#    computation worked. The next example shows how to write one of our own.
   Una funcion puede devolver mas de un resultado. Hemos visto muchos ejemplos
   de funciones de paquetes estandar que devuelven dos valores, el resultado
   computacional deseado y un valor de error o booleano que indica si el calculo
   funciono. El siguiente ejemplo muestra como escribir una nosotros mismos.

#    The program below is a variation of @$(findlinks) that makes the HTTP request
#    itself so that we no longer need to run @$(fetch). Because the HTTP and
#    parsing operations can fail, @$(findLinks) declares two results: the list of
#    discovered links and an error. Incidentally, the HTML parser can usually
#    recover from bad input and construct a document containing error nodes, so
#    @c(Parse) rarely fails; when it does, it’s typically due to underlying I/O
#    errors.
   El programa siguiente es una variacion de @$(findlinks) que hace la peticion
   HTTP por si mismo, asi que ya no necesitamos para ejecutar @$(fetch). Ya que
   las operaciones de analisis y HTTP pueden fallar, @$(findLinks) declara dos
   resultados: la lista de enlaces descubiertos y un error. Por cierto, el
   analizador de HTML por lo general puede recuperarse de una entrada incorrecta
   y construir un documento que contiene nodos de error, por lo @c(Parse)
   raramente falla; Cuando lo hace, normalmente se debe a errores de E/S
   subyacentes.

#    ..figure > @l(gopl.io/ch5/findlinks2/main.go<>gopl.io/ch5/findlinks2)
   ..figure > @l(gopl.io/ch5/findlinks2/main.go<>gopl.io/ch5/findlinks2)

#      ..src > go
#        func main() {
#          for _, url := range os.Args[1:] {
#            links, err := findLinks(url)
#            if err != nil {
#              fmt.Fprintf(os.Stderr, "findlinks2: %v\n", err)
#              continue
#            }
#            for _, link := range links {
#              fmt.Println(link)
#            }
#          }
#        }
#
#        // findLinks performs an HTTP GET request for url, parses the
#        // response as HTML, and extracts and returns the links.
#        func findLinks(url string) ([]string, error) {
#          resp, err := http.Get(url)
#          if err != nil {
#            return nil, err
#          }
#          if resp.StatusCode != http.StatusOK {
#            resp.Body.Close()
#            return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
#          }
#          doc, err := html.Parse(resp.Body)
#          resp.Body.Close()
#          if err != nil {
#            return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
#          }
#          return visit(nil, doc), nil
#        }
#      < src..
     ..src > go
       func main() {
         for _, url := range os.Args[1:] {
           links, err := findLinks(url)
           if err != nil {
             fmt.Fprintf(os.Stderr, "findlinks2: %v\n", err)
             continue
           }
           for _, link := range links {
             fmt.Println(link)
           }
         }
       }

       // findLinks realiza una peticion HTTP GET por la url, analiza la
       // respuesta como HTML, y extrae y regresa los enlaces.
       func findLinks(url string) ([]string, error) {
         resp, err := http.Get(url)
         if err != nil {
           return nil, err
         }
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
         }
         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
         }
         return visit(nil, doc), nil
       }
     < src..


#    There are four return statements in @c(findLinks), each of which returns a
#    pair of values. The first three @c(return)s cause the function to pass the
#    underlying errors from the @c(http) and @c(html) packages on to the
#    caller. In the first case, the error is returned unchanged; in the second and
#    third, it is augmented with additional context information by @c(fmt.Errorf)
#    (@l(#Section 7.8<>§7.8)). If @c(findLinks) is successful, the final return
#    statement returns the slice of links, with no error.
   Hay cuatro sentencias @c(return) en @c(findLinks), cada uno de las cuales
   devuelve un par de valores. Los tres primeros @c(return) hacen la funcion
   pase los errores subyacentes de los paquetes @c(http) y @c(html) al
   llamador. En el primer caso, el error se devuelve sin cambios; en el segundo
   y tercero, que expande con informacion de contexto adicional con
   @c(fmt.Errorf) (@l(#Seccion 7.8<>§7.8)). Si @c(findLinks) tiene exito, la
   ultima sentencia @c(return) devuelve el slice de enlaces, sin error.

#    We must ensure that @c(resp.Body) is closed so that network resources are
#    properly released even in case of error. Go’s garbage collector recycles
#    unused memory, but do not assume it will release unused operating system
#    resources like open files and network connections. They should be closed
#    explicitly.
   Debemos asegurarnos de cerrar @c(resp.Body) para que los recursos de red se
   liberen adecuadamente, incluso en caso de error. El recolector de basura de
   Go recicla la memoria no utilizada, pero no asume que liberara recursos del
   sistema operativo no utilizados como archivos abiertos y conexiones de
   red. Deberan cerrarse explicitamente.

#    The result of calling a multi-valued function is a tuple of values. The
#    caller of such a function must explicitly assign the values to variables if
#    any of them are to be used:
   El resultado de llamar a una funcion multi-valor es una tupla de valores. El
   llamador de tal funcion debe asignar explicitamente los valores a las
   variables si se desea utilizar alguna de ellas:

#    ..src > go
#      links, err := findLinks(url)
#    < src..
   ..src > go
     links, err := findLinks(url)
   < src..

#    To ignore one of the values, assign it to the blank identifier:
   Para ignorar uno de los valores, asintelo al identificador en blanco:

#    ..src > go
#      links, _ := findLinks(url) // errors ignored
#    < src..
   ..src > go
     links, _ := findLinks(url) // errors ignored
   < src..

#    The result of a multi-valued call may itself be returned from a
#    (multi-valued) calling function, as in this function that behaves like
#    @c(findLinks) but logs its argument:
   El resultado de una llamada multi-valor en si puede ser devuelto desde una
   llamada funcion (multi-valor), como en esta funcion que se comporta como
   @c(findLinks) pero registra su argumento:

#    ..src > go
#      func findLinksLog(url string) ([]string, error) {
#        log.Printf("findLinks %s", url)
#        return findLinks(url)
#      }
#    < src..
   ..src > go
     func findLinksLog(url string) ([]string, error) {
       log.Printf("findLinks %s", url)
       return findLinks(url)
     }
   < src..

#    A multi-valued call may appear as the sole argument when calling a function
#    of multiple parameters. Although rarely used in production code, this feature
#    is sometimes convenient during debugging since it lets us print all the
#    results of a call using a single statement. The two print statements below
#    have the same effect.
   Una llamada multi-valor puede aparecer como el unico argumento cuando se
   llama a una funcion de multiples parametros. Aunque rara vez se utiliza en
   codigo de produccion, esta caracteristica es a veces conveniente durante la
   depuracion, ya que nos permite imprimir todos los resultados de una llamada
   utilizando una sola sentencia. Las dos instrucciones de impresion siguientes
   tienen el mismo efecto.

#    ..src > go
#      log.Println(findLinks(url))
#
#      links, err := findLinks(url)
#      log.Println(links, err)
#    < src..
   ..src > go
     log.Println(findLinks(url))

     links, err := findLinks(url)
     log.Println(links, err)
   < src..

#    Well-chosen names can document the significance of a function’s
#    results. Names are particularly valuable when a function returns multiple
#    results of the same type, like
   Los nombres bien elegidos pueden documentar la importancia de los resultados
   de una funcion. Los nombres son particularmente valiosos cuando una funcion
   devuelve multiples resultados del mismo tipo, como

#    ..src > go
#      func Size(rect image.Rectangle) (width, height int)
#      func Split(path string) (dir, file string)
#      func HourMinSec(t time.Time) (hour, minute, second int)
#    < src..
   ..src > go
     func Size(rect image.Rectangle) (width, height int)
     func Split(path string) (dir, file string)
     func HourMinSec(t time.Time) (hour, minute, second int)
   < src..

#    but it’s not always necessary to name multiple results solely for
#    documentation. For instance, convention dictates that a final @c(bool) result
#    indicates success; an @c(error) result often needs no explanation.
   Pero no siempre es necesario nombrar multiples resultados unicamente para la
   documentacion. Por ejemplo, la convencion dicta que un resultado final
   @c(bool) indica el exito; un resultado erroneo a menudo no necesita
   explicacion.

#    In a function with named results, the operands of a return statement may be
#    omitted. This is called a @e(bare return).
   En una funcion con resultados nombrados, se pueden omitir los operandos de
   una sentencia de devolucion. Esto se llama un @c(retorno desnudo).

#    ..src > go
#      // CountWordsAndImages does an HTTP GET request for the HTML
#      // document url and returns the number of words and images in it.
#      func CountWordsAndImages(url string) (words, images int, err error) {
#        resp, err := http.Get(url)
#        if err != nil {
#          return
#        }
#
#        doc, err := html.Parse(resp.Body)
#        resp.Body.Close()
#        if err != nil {
#          err = fmt.Errorf("parsing HTML: %s", err)
#          return
#        }
#        words, images = countWordsAndImages(doc)
#        return
#      }
#
#      func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ }
#    < src..
   ..src > go
     // CountWordsAndImages realiza una peticion HTTP GET para la URL del
     // documento HTML y regresa el numero de palabras e imagenes que contiene.
     func CountWordsAndImages(url string) (words, images int, err error) {
       resp, err := http.Get(url)
       if err != nil {
         return
       }

       doc, err := html.Parse(resp.Body)
       resp.Body.Close()
       if err != nil {
         err = fmt.Errorf("parsing HTML: %s", err)
         return
       }
       words, images = countWordsAndImages(doc)
       return
     }

     func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ }
   < src..

#    A bare return is a shorthand way to return each of the named result variables
#    in order, so in the function above, each return statement is equivalent to
   Un retorno desnudo es una forma abreviada de devolver cada una de las
   variables de resultado nombradas en orden, por lo que en la funcion anterior,
   cada sentencia @c(return) es equivalente a

#    ..src > go
#      return words, images, err
#    < src..
   ..src > go
     return words, images, err
   < src..

#    In functions like this one, with many return statements and several results,
#    bare returns can reduce code duplication, but they rarely make code easier to
#    understand. For instance, it’s not obvious at first glance that the two early
#    returns are equivalent to @c(return 0, 0, err) (because the result variables
#    @c(words) and @c(images) are initialized to their zero values) and that the
#    final @c(return) is equivalent to @c(return words, images, nil). For this
#    reason, bare returns are best used sparingly.
   En funciones como esta, con muchas declaraciones de retorno y varios
   resultados, los resultados desnudos pueden reducir la duplicacion de codigo,
   pero rara vez hacen que el codigo sea mas facil de entender. Por ejemplo, no
   es obvio a primera vista que los dos primeros resultados son equivalentes a
   @c(return 0, 0, err) (porque las variables de resultado @c(words) e
   @c(images) se inicializan con sus valores cero) y que el ultimo @c(return) es
   equivalente a @c(return words, images, nil). Por esta razon, es mejor
   utilizar los resultados desnudos con moderacion.

#    @b(Exercise 5.5): Implement @c(countWordsAndImages). (See Exercise 4.9 for
#    word-splitting.)
   @b(Ejercicio 5.5): Implementar @c(countWordsAndImages). (Ver el ejercicio 4.9
   para la division de palabras.)

#    @b(Exercise 5.6): Modify the @c(corner) function in @c(gopl.io/ch3/surface)
#    (@l(#Section 3.2<>§3.2)) to use named results and a bare return statement.
   @b(Ejercicio 5.6): Modificar la funcion @c(corner) en @c(gopl.io/ch3/surface)
   (@l(#Seccion 3.2<>§3.2)) para utilizar resultados con nombre y una
   declaracion de retorno desnudo.

# ** Section 5.4 <> Errors
** Seccion 5.4 <> Errores

#    Some functions always succeed at their task. For example,
#    @c(strings.Contains) and @c(strconv.FormatBool) have well-defined results for
#    all possible argument values and cannot fail— barring catastrophic and
#    unpredictable scenarios like running out of memory, where the symptom is far
#    from the cause and from which there’s little hope of recovery.
   Algunas funciones siempre tienen exito en su tarea. Por ejemplo,
   @c(strings.Contains) y @c(strconv.FormatBool) tienen bien definidos todos los
   posibles valores de los argumentos y no pueden fallar–salvo escenarios
   catastroficos e impredecibles como quedarse sin memoria, donde el sintoma
   esta lejos de la causa y de la cual hay poca esperanza de recuperacion.

#    Other functions always succeed so long as their preconditions are met. For
#    example, the @c(time.Date) function always constructs a @c(time.Time) from
#    its components—year, month, and so on—unless the last argument (the time
#    zone) is @c(nil), in which case it panics. This panic is a sure sign of a bug
#    in the calling code and should never happen in a well-written program.
   Otras funciones siempre tienen exito siempre y cuando se cumplan sus
   condiciones previas. Por ejemplo, la funcion @c(time.Date) siempre construye
   un @c(time.Time) a partir de sus componentes–año, mes, y asi sucesivamente–a
   menos que el ultimo argumento (la zona horaria) sea @c(nil), en cuyo caso se
   entra en panico. Este panico es un signo seguro de un error en el codigo de
   llamada y nunca debe suceder en un programa bien escrito.

#    For many other functions, even in a well-written program, success is not
#    assured because it depends on factors beyond the programmer’s control. Any
#    function that does I/O, for example, must confront the possibility of error,
#    and only a naïve programmer believes a simple read or write cannot
#    fail. Indeed, it’s when the most reliable operations fail unexpectedly that
#    we most need to know why.
   Para muchas otras funciones, incluso en un programa bien escrito, el exito no
   esta asegurado porque depende de factores ajenos al control del
   programador. Cualquier funcion que haga E/S, por ejemplo, debe enfrentarse a
   la posibilidad de error, y solo un programador ingenuo cree que una simple
   lectura o escritura no puede fallar. De hecho, es cuando las operaciones mas
   confiables fallan inesperadamente que necesitamos saber por que.

#    Errors are thus an important part of a package’s API or an application’s user
#    interface, and failure is just one of several expected behaviors. This is the
#    approach Go takes to error handling.
   Los errores son, por lo tanto, una parte importante de la API de un paquete o
   de la interfaz de usuario de una aplicacion, y el error es solo uno de varios
   comportamientos esperados. Este es el enfoque que Go toma respecto al manejo
   de errores.

#    A function for which failure is an expected behavior returns an additional
#    result, conventionally the last one. If the failure has only one possible
#    cause, the result is a boolean, usually called @c(ok), as in this example of a
#    cache lookup that always succeeds unless there was no entry for that key:
   Una funcion cuyo fallo es un comportamiento esperado devuelve un resultado
   adicional, convencionalmente el ultimo. Si el fallo tiene solo una causa
   posible, el resultado es un valor booleano, generalmente llamado @c(ok), como
   en este ejemplo de una busqueda en la cache que siempre tiene exito a menos
   que no hubiera ninguna entrada para esa clave:

#    ..src > go
#      value, ok := cache.Lookup(key)
#      if !ok {
#        // ...cache[key] does not exist...
#      }
#    < src..
   ..src > go
     value, ok := cache.Lookup(key)
     if !ok {
       // ...cache[key] does not exist...
     }
   < src..

#    More often, and especially for I/O, the failure may have a variety of causes
#    for which the caller will need an explanation. In such cases, the type of the
#    additional result is @c(error).
   Mas a menudo, y especialmente para E/S, el fallo puede tener una variedad
   de causas para las cuales el llamador necesitara una explicacion. En tales
   casos, el tipo del resultado adicional es @c(error).

#    The built-in type @c(error) is an interface type. We’ll see more of what this
#    means and its implications for error handling in @l(#Chapter 7). For now it’s
#    enough to know that an error may be nil or non-nil, that nil implies success
#    and non-nil implies failure, and that a non-nil @c(error) has an error
#    message string which we can obtain by calling its @c(Error) method or print
#    by calling @c[fmt.Println(err)] or @c[fmt.Printf("%v", err)].
   El tipo nativo @c(error) es un tipo de interfaz. Veremos mas de lo que esto
   significa y sus implicaciones para el manejo de errores en el @l(#Capitulo
   7). Por ahora es suficiente saber que un error puede ser o no @c(nil), que
   nil implica el exito y no-nil implica el fracaso, y que un error no-nil tiene
   una cadena del mensaje de error que se puede obtener llamando a su metodo
   @c(Error) o imprimir mediante @c[fmt.Println(err)] o @c[fmt.Printf("%v",
   err)].

#    Usually when a function returns a non-nil error, its other results are
#    undefined and should be ignored. However, a few functions may return partial
#    results in error cases. For example, if an error occurs while reading from a
#    file, a call to @c(Read) returns the number of bytes it was able to read
#    @e(and) an @c(error) value describing the problem. For correct behavior, some
#    callers may need to process the incomplete data before handling the error, so
#    it is important that such functions clearly document their results.
   Normalmente cuando una funcion devuelve un error no-nil, sus otros resultados
   son indefinidos y se deben ignorar. Sin embargo, algunas funciones pueden
   devolver resultados parciales en casos de error. Por ejemplo, si se produce
   un error durante la lectura de un archivo, una llamada a @c(Read) devuelve el
   numero de bytes que fue capaz de leer @e(y) un valor @c(error) que describe
   el problema. Para el comportamiento correcto, algunos llamadores pueden
   necesitar procesar los datos incompletos antes de manejar el error, por lo
   que es importante que estas funciones documente claramente sus resultados.

#    Go’s approach sets it apart from many other languages in which failures are
#    reported using @e(exceptions), not ordinary values. Although Go does have an
#    exception mechanism of sorts, as we will see in @l(#Section 5.9), it is used
#    only for reporting truly unexpected errors that indicate a bug, not the
#    routine errors that a robust program should be built to expect.
   El enfoque de Go lo diferencia de muchos otros lenguajes en los que se
   reportan fallos utilizando @e(excepciones), no valores normales. Aunque Go
   tiene un mecanismo de excepcion, como veremos en la @l(#Seccion 5.9), se
   utiliza solo para informar de los errores realmente inesperadas que indican
   un error, no los errores de rutina que un programa robusto deberia esperar.

#    The reason for this design is that exceptions tend to entangle the
#    description of an error with the control flow required to handle it, often
#    leading to an undesirable outcome: routine errors are reported to the end
#    user in the form of an incomprehensible stack trace, full of information
#    about the structure of the program but lacking intelligible context about
#    what went wrong.
   La razon de este diseño es que las excepciones tienden a enredar la
   descripcion de un error con el flujo de control requerido para manejarlo,
   conduciendo a menudo a un resultado indeseable: los errores de rutina se
   informan al usuario final en forma de un rastro de pila incomprensible, lleno
   de informacion sobre la estructura del programa pero carece de un contexto
   inteligible sobre lo que salio mal.

#    By contrast, Go programs use ordinary control-flow mechanisms like @c(if) and
#    @c(return) to respond to errors. This style undeniably demands that more
#    attention be paid to error-handling logic, but that is precisely the point.
   Por el contrario, los programas Go utilizan mecanismos de control de flujo
   normales como @c(if) y @c(return) para responder a los errores. Este estilo
   indudablemente exige que se preste mas atencion a la logica de manejo de
   errores, pero ese es precisamente el punto.

# *** Section 5.4.1 <> Error-Handling Strategies
*** Seccion 5.4.1 <> Estrategias de Manejo de Errores

#     When a function call returns an error, it’s the caller’s responsibility to
#     check it and take appropriate action. Depending on the situation, there may
#     be a number of possibilities. Let’s take a look at five of them.
    Cuando una llamada de funcion devuelve un error, es responsabilidad del
    llamador comprobarlo y tomar la accion apropiada. Dependiendo de la
    situacion, puede haber una serie de posibilidades. Echemos un vistazo a
    cinco de ellas.

#     First, and most common, is to @e(propagate) the error, so that a failure in
#     a subroutine becomes a failure of the calling routine. We saw examples of
#     this in the @c(findLinks) function of @l(#Section 5.3). If the call to
#     @c(http.Get) fails, @c(findLinks) returns the HTTP error to the caller without
#     further ado:
    La primera y mas comun, es @e(propagar) el error, por lo que un fallo en una
    subrutina se convierte en un fracaso de la rutina de llamada. Vimos ejemplos
    de esto en la funcion @c(findLinks) de la @l(#Seccion 5.3). Si la llamada a
    @c(http.Get) falla, @c(findLinks) devuelve el error HTTP a la persona al
    llamador sin mas preambulos:

#     ..src > go
#       resp, err := http.Get(url)
#       if err != nil {
#         return nil, err
#       }
#     < src..
    ..src > go
      resp, err := http.Get(url)
      if err != nil {
        return nil, err
      }
    < src..

#     In contrast, if the call to @c(html.Parse) fails, @c(findLinks) does not
#     return the HTML parser’s error directly because it lacks two crucial pieces
#     of information: that the error occurred in the parser, and the URL of the
#     document that was being parsed. In this case, @c(findLinks) constructs a new
#     error message that includes both pieces of information as well as the
#     underlying parse error:
    Por el contrario, si la llamada a @c(html.Parse) falla, @c(findLinks) no
    devuelve el error del analizador de HTML directamente, porque carece de dos
    piezas cruciales de informacion: que se produjo el error en el analizador, y
    la direccion URL del documento que se esta analizando. En este caso,
    @c(findLinks) construye un nuevo mensaje de error que incluye las dos piezas
    de informacion, asi como un analisis del error subyacente:

#     ..src > go
#       doc, err := html.Parse(resp.Body)
#       resp.Body.Close()
#       if err != nil {
#         return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
#       }
#     < src..
    ..src > go
      doc, err := html.Parse(resp.Body)
      resp.Body.Close()
      if err != nil {
        return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
      }
    < src..

#     The @c(fmt.Errorf) function formats an error message using @c(fmt.Sprintf)
#     and returns a new @c(error) value. We use it to build descriptive errors by
#     successively prefixing additional context information to the original error
#     message. When the error is ultimately handled by the program’s @c(main)
#     function, it should provide a clear causal chain from the root problem to
#     the overall failure, reminiscent of a NASA accident investigation:
    La funcion @c(fmt.Errorf) da formato a un mensaje de error utilizando
    @c(fmt.Sprintf) y devuelve un nuevo valor @c(error). Lo utilizamos para
    generar errores descriptivos mediante el prefijo sucesivo de informacion de
    contexto adicional al mensaje de error original. Cuando el error es en
    ultima instancia, manejado por la funcion @c(main) del programa, se debe
    proporcionar una cadena causal clara a partir de la raiz del problema de la
    falta en su conjunto, que recuerda a una investigacion de accidentes de la
    NASA:

#     ..pre >
#       genesis: crashed: no parachute: G-switch failed: bad relay orientation
    ..pre >
      genesis: crashed: no parachute: G-switch failed: bad relay orientation

#     Because error messages are frequently chained together, message strings
#     should not be capitalized and newlines should be avoided. The resulting
#     errors may be long, but they will be selfcontained when found by tools like
#     @$(grep).
    Debido a que los mensajes de error con frecuencia se encadenan juntos, las
    cadenas de mensajes no deben ser mayusculas y las lineas nuevas deben
    evitarse. Los errores resultantes pueden ser largos, pero seran
    autocontenidos cuando sean encuontrados por herramientas como grep.

#     When designing error messages, be deliberate, so that each one is a
#     meaningful description of the problem with sufficient and relevant detail,
#     and be consistent, so that errors returned by the same function or by a
#     group of functions in the same package are similar in form and can be dealt
#     with in the same way.
    Cuando diseñe mensajes de error, sea deliberado, de modo que cada uno sea
    una descripcion significativa del problema con detalles suficientes y
    relevantes, y sea consistente, de modo que los errores devueltos por la
    misma funcion o por un grupo de funciones en el mismo paquete sean similares
    en forma y se puedan tratar de la misma manera.

#     For example, the @c(os) package guarantees that every error returned by a
#     file operation, such as @c(os.Open) or the @c(Read), @c(Write), or @c(Close)
#     methods of an open file, describes not just the nature of the failure
#     (permission denied, no such directory, and so on) but also the name of the
#     file, so the caller needn’t include this information in the error message it
#     constructs.
    Por ejemplo, el paquete @c(os) garantiza que cada error devuelto por una
    operacion de archivo, como @c(os.Open) o los metodos @c(Read), @c(Write), o
    @c(Close) de un archivo abierto, no describen solo la naturaleza de la falla
    (permiso denegado, directorio erroneo, etc), sino tambien el nombre del
    archivo, por lo el que llamador no necesita incluir esta informacion en el
    mensaje de error.

#     In general, the call @c[f(x)] is responsible for reporting the attempted
#     operation @c(f) and the argument value @c(x) as they relate to the context
#     of the error. The caller is responsible for adding further information that
#     it has but the call @c[f(x)] does not, such as the URL in the call to
#     @c(html.Parse) above.
    En general, la llamada @c[f(x)] es responsable de informar el intento de
    operacion @c(f) y el valor del argumento @c(x) en su relacion con el
    contexto del error. El llamador es responsable de añadir mas informacion que
    tiene, pero la llamada @c[f(x)] no, tal como la URL en la llamada a
    @c(html.Parse) anterior.

#     Let’s move on to the second strategy for handling errors. For errors that
#     represent transient or unpredictable problems, it may make sense to
#     @e(retry) the failed operation, possibly with a delay between tries, and
#     perhaps with a limit on the number of attempts or the time spent trying
#     before giving up entirely.
    Pasemos a la segunda estrategia para manejar errores. Para errores que
    representan problemas transitorios o impredecibles, puede tener sentido
    volver a intentar la operacion fallida, posiblemente con un retardo entre
    intentos, y tal vez con un limite en el numero de intentos o el tiempo
    dedicado a tratar antes de renunciar por completo.

#     ..figure > @l(gopl.io/ch5/wait/wait.go<>gopl.io/ch5/wait)
    ..figure > @l(gopl.io/ch5/wait/wait.go<>gopl.io/ch5/wait)

#       ..src > go
#         // WaitForServer attempts to contact the server of a URL.
#         // It tries for one minute using exponential back-off.
#         // It reports an error if all attempts fail.
#         func WaitForServer(url string) error {
#           const timeout = 1 * time.Minute
#           deadline := time.Now().Add(timeout)
#           for tries := 0; time.Now().Before(deadline); tries++ {
#             _, err := http.Head(url)
#             if err == nil {
#               return nil // success
#             }
#             log.Printf("server not responding (%s); retrying...", err)
#             time.Sleep(time.Second << uint(tries)) // exponential back-off
#           }
#           return fmt.Errorf("server %s failed to respond after %s", url, timeout)
#         }
#       < src..
      ..src > go
        // WaitForServer intenta ponerse en contacto con el servidor de una URL
        // Se intenta durante un minuto usando retroceso exponencial.
        // Informa un error si todos los intentos fallan.
        func WaitForServer(url string) error {
          const timeout = 1 * time.Minute
          deadline := time.Now().Add(timeout)
          for tries := 0; time.Now().Before(deadline); tries++ {
            _, err := http.Head(url)
            if err == nil {
              return nil // exito
            }
            log.Printf("server not responding (%s); retrying...", err)
            time.Sleep(time.Second << uint(tries)) // retroceso exponencial
          }
          return fmt.Errorf("server %s failed to respond after %s", url, timeout)
        }
      < src..


#     Third, if progress is impossible, the caller can print the error and stop
#     the program gracefully, but this course of action should generally be
#     reserved for the main package of a program.  Library functions should
#     usually propagate errors to the caller, unless the error is a sign of an
#     internal inconsistency—that is, a bug.
    En tercer lugar, si el progreso es imposible, el llamante puede imprimir el
    error y detener el programa con gracia, pero este curso de accion
    generalmente debe reservarse para el paquete principal de un programa. Las
    funciones de la libreria normalmente deben propagar errores al llamante, a
    menos que el error sea un signo de una inconsistencia interna, es decir, un
    error.

#     ..src > go
#       // (In function main.)
#       if err := WaitForServer(url); err != nil {
#         fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
#         os.Exit(1)
#       }
#     < src..
    ..src > go
      // (Dentro de la funcion main.)
      if err := WaitForServer(url); err != nil {
        fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
        os.Exit(1)
      }
    < src..

#     A more convenient way to achieve the same effect is to call @c(log.Fatalf).
#     As with all the @c(log) functions, by default it prefixes the time and date
#     to the error message.
    Una forma mas conveniente para lograr el mismo efecto es llamar a
    @c(log.Fatalf). Al igual que con todas las funciones @c(log), por defecto se
    prefija la hora y la fecha para el mensaje de error.

#     ..src > go
#       if err := WaitForServer(url); err != nil {
#         log.Fatalf("Site is down: %v\n", err)
#       }
#     < src..
    ..src > go
      if err := WaitForServer(url); err != nil {
        log.Fatalf("Site is down: %v\n", err)
      }
    < src..

#     The default format is helpful in a long-running server, but less so for an
#     interactive tool:
    El formato predeterminado es util en un servidor de larga ejecucion, pero
    menos para una herramienta interactiva:

#     ..pre >
#       2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io
    ..pre >
      2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io

#     For a more attractive output, we can set the prefix used by the @c(log) package
#     to the name of the command, and suppress the display of the date and time:
    Para una salida mas atractiva, podemos establecer el prefijo utilizado por
    el paquete @c(log) en el nombre del comando, y suprimir la visualizacion de la
    fecha y hora:

#     ..src > go
#       log.SetPrefix("wait: ")
#       log.SetFlags(0)
#     < src..
    ..src > go
      log.SetPrefix("wait: ")
      log.SetFlags(0)
    < src..

#     Fourth, in some cases, it’s sufficient just to log the error and then
#     continue, perhaps with reduced functionality. Again there’s a choice between
#     using the @c(log) package, which adds the usual prefix:
    En cuarto lugar, en algunos casos, basta con registrar el error y luego
    continuar, tal vez con funcionalidad reducida. Una vez mas hay una eleccion
    entre utilizar el paquete @c(log), que añade el prefijo habitual:

#     ..src > go
#       if err := Ping(); err != nil {
#         log.Printf("ping failed: %v; networking disabled", err)
#       }
#     < src..
    ..src > go
      if err := Ping(); err != nil {
        log.Printf("ping failed: %v; networking disabled", err)
      }
    < src..

#     and printing directly to the standard error stream:
    e imprimir directamente a flujo de error estardar:

#     ..src > go
#       if err := Ping(); err != nil {
#         fmt.Fprintf(os.Stderr, "ping failed: %v; networking disabled\n", err)
#       }
#     < src..
    ..src > go
      if err := Ping(); err != nil {
        fmt.Fprintf(os.Stderr, "ping failed: %v; networking disabled\n", err)
      }
    < src..

#     (All @c(log) functions append a newline if one is not already present.)
    (Todas las funciones log añaden un salto de linea si no hay uno presente).

#     And fifth and finally, in rare cases we can safely ignore an error entirely:
    Y quinto y ultimo, en casos raros podemos ignorar un error completamente:

#     ..src > go
#       dir, err := ioutil.TempDir("", "scratch")
#       if err != nil {
#         return fmt.Errorf("failed to create temp dir: %v", err)
#       }
#
#       // ...use temp dir...
#
#       os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically
#     < src..
    ..src > go
      dir, err := ioutil.TempDir("", "scratch")
      if err != nil {
        return fmt.Errorf("failed to create temp dir: %v", err)
      }

      // ...use temp dir...

      os.RemoveAll(dir) // ignorar errores; $TMPDIR se limpia periodicamente
    < src..

#     The call to @c(os.RemoveAll) may fail, but the program ignores it because
#     the operating system periodically cleans out the temporary directory. In
#     this case, discarding the error was intentional, but the program logic would
#     be the same had we forgotten to deal with it. Get into the habit of
#     considering errors after every function call, and when you deliberately
#     ignore one, document your intention clearly.
    La llamada a os.RemoveAll puede fallar, pero el programa lo ignora porque el
    sistema operativo periodicamente limpia el directorio temporal. En este
    caso, descartar el error fue intencional, pero la logica del programa seria
    la misma si hubieramos olvidado tratar con el. Adquiera el habito de
    considerar errores despues de cada llamada de funcion, y cuando
    deliberadamente ignora uno, documente claramente su intencion.

#     Error handling in Go has a particular rhythm. After checking an error,
#     failure is usually dealt with before success. If failure causes the function
#     to return, the logic for success is not indented within an @c(else) block
#     but follows at the outer level. Functions tend to exhibit a common
#     structure, with a series of initial checks to reject errors, followed by the
#     substance of the function at the end, minimally indented.
    El manejo de errores en Go tiene un ritmo particular. Despues de comprobar
    un error, el fracaso suele tratarse antes del exito. Si el fallo hace que la
    funcion regrese, la logica para el exito no se sangra dentro de un bloque
    @c(else), pero continua en el nivel externo. Las funciones tienden a exhibir
    una estructura comun, con una serie de comprobaciones iniciales para
    rechazar errores, seguidas por la esencia de la funcion al final,
    minimamente indentada.

# *** Section 5.4.2 <> End of File (EOF)
*** Seccion 5.4.2 <> Fin de Archivo (EOF)

#     Usually, the variety of errors that a function may return is interesting to
#     the end user but not to the intervening program logic. On occasion, however,
#     a program must take different actions depending on the kind of error that
#     has occurred. Consider an attempt to read @m(n) bytes of data from a
#     file. If @m(n) is chosen to be the length of the file, any error represents
#     a failure. On the other hand, if the caller repeatedly tries to read
#     fixed-size chunks until the file is exhausted, the caller must respond
#     differently to an end-of-file condition than it does to all other errors.
#     For this reason, the @c(io) package guarantees that any read failure caused
#     by an end-of-file condition is always reported by a distinguished error,
#     @c(io.EOF), which is defined as follows:
    Normalmente, la variedad de errores que una funcion puede devolver es
    interesante para el usuario final, pero no para la logica del programa
    intermedio. En ocasiones, sin embargo, un programa debe tomar diferentes
    acciones dependiendo del tipo de error que se ha producido. Considere un
    intento de leer @m(n) bytes de datos de un archivo. Si se elige @m(n) para
    ser la longitud del archivo, cualquier error representa un fracaso. Por otro
    lado, si el llamador trata repetidamente de leer fragmentos de tamaño fijo
    hasta que el archivo se agote, el llamador debe responder de manera
    diferente a una condicion de fin de archivo que a todos los demas
    errores. Por esta razon, el paquete @c(io) garantiza que cualquier daño
    causado por una condicion de fin de archivo siempre informa de un error
    distinguida, @c(io.EOF), que se define de la siguiente manera:

#     ..src > go
#       package io
#
#       import "errors"
#
#       // EOF is the error returned by Read when no more input is available.
#       var EOF = errors.New("EOF")
#     < src..
    ..src > go
      package io

      import "errors"

      // EOF es el error devuelto por Read cuando no hay mas entrada disponible.
      var EOF = errors.New("EOF")
    < src..

#     The caller can detect this condition using a simple comparison, as in the
#     loop below, which reads runes from the standard input. (The @$(charcount)
#     program in @l(#Section 4.3) provides a more complete example.)
    El llamador puede detectar esta condicion usando una comparacion simple,
    como en el bucle siguiente, que lee runas de la entrada estandar. (El
    programa @$(charcount) en la @l(#Seccion 4.3) ofrece un ejemplo mas
    completo.)

#     ..src > go
#       in := bufio.NewReader(os.Stdin)
#       for {
#         r, _, err := in.ReadRune()
#         if err == io.EOF {
#           break // finished reading
#         }
#         if err != nil {
#           return fmt.Errorf("read failed: %v", err)
#         }
#         // ...use r...
#       }
#     < src..
    ..src > go
      in := bufio.NewReader(os.Stdin)
      for {
        r, _, err := in.ReadRune()
        if err == io.EOF {
          break // lectura terminada
        }
        if err != nil {
          return fmt.Errorf("read failed: %v", err)
        }
        // ...usar r...
      }
    < src..

#     Since in an end-of-file condition there is no information to report besides
#     the fact of it, @c(io.EOF) has a fixed error message, @c("EOF"). For other
#     errors, we may need to report both the quality and quantity of the error, so
#     to speak, so a fixed error value will not do. In @l(#Section 7.11), we’ll
#     present a more systematic way to distinguish certain error values from
#     others.
    Puesto que en una condicion de fin de archivo no existe informacion que
    informar ademas del hecho de que, @c(io.EOF) tiene un mensaje de error fijo,
    @c("EOF"). Para otros errores, es posible que tengamos que informar tanto la
    calidad como la cantidad del error, por asi decirlo, por lo que un valor de
    error fijo no lo hara. En la @l(#Seccion 7.11), vamos a presentar de manera
    mas sistematica a distinguir ciertos valores de error de los demas.

# ** Section 5.5 <> Function Values
** Seccion 5.5 <> Valores de la Funcion

#    Functions are @e(first-class values) in Go: like other values, function
#    values have types, and they may be assigned to variables or passed to or
#    returned from functions. A function value may be called like any other
#    function. For example:
   En Go las funciones son valores de primera clase: al igual que otros valores,
   los valores de funcion tienen tipos, y pueden ser asignados a variables o
   pasarse a o regresarlas de funciones. Un valor de funcion puede ser llamado
   como cualquier otra funcion. Por ejemplo:

#    ..src > go
#      func square(n int) int     { return n * n }
#      func negative(n int) int   { return -n }
#      func product(m, n int) int { return m * n }
#
#      f := square
#      fmt.Println(f(3))     // "9"
#
#      f = negative
#      fmt.Println(f(3))     // "-3"
#      fmt.Printf("%T\n", f) // "func(int) int"
#
#      f = product // compile error: can't assign f(int, int) int to f(int) int
#    < src..
   ..src > go
     func square(n int) int     { return n * n }
     func negative(n int) int   { return -n }
     func product(m, n int) int { return m * n }

     f := square
     fmt.Println(f(3))     // "9"

     f = negative
     fmt.Println(f(3))     // "-3"
     fmt.Printf("%T\n", f) // "func(int) int"

     f = product // error de compilacion: no se puede asignar f(int, int) int a f(int) int
   < src..

#    The zero value of a function type is @c(nil). Calling a nil function value
#    causes a panic:
   El valor cero para el tipo funcion es @c(nil). Llamar a un valor de funcion
   nulo produce un panico:

#    ..src > go
#      var f func(int) int
#      f(3) // panic: call of nil function
#    < src..
   ..src > go
     var f func(int) int
     f(3) // panico: llamar a funcion nil
   < src..

#    Function values may be compared with @c(nil):
   Los valores de funcion pueden compararse con @c(nil):

#    ..src > go
#      var f func(int) int
#      if f != nil {
#        f(3)
#      }
#    < src..
   ..src > go
     var f func(int) int
     if f != nil {
       f(3)
     }
   < src..

#    but they are not comparable, so they may not be compared against each other
#    or used as keys in a map.
   Pero no son comparables, por lo que no pueden comparse entre si o utilizarse
   como claves en un mapa.

#    Function values let us parameterize our functions over not just data, but
#    behavior too. The standard libraries contain many examples. For instance,
#    @c(strings.Map) applies a function to each character of a string, joining the
#    results to make another string.
   Los valores de las funciones nos permiten parametrizar nuestras funciones no
   solo sobre los datos sino tambien sobre el comportamiento. Las librerias
   estandar contienen muchos ejemplos. Por ejemplo, @c(strings.Map) aplica una
   funcion a cada caracter de una cadena, uniendo los resultados para formar
   otra cadena.

#    ..src > go
#      func add1(r rune) rune { return r + 1 }
#
#      fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
#      fmt.Println(strings.Map(add1, "VMS"))      // "WNT"
#
#      fmt.Println(strings.Map(add1, "Admix"))    // "Benjy"
#    < src..
   ..src > go
     func add1(r rune) rune { return r + 1 }

     fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
     fmt.Println(strings.Map(add1, "VMS"))      // "WNT"

     fmt.Println(strings.Map(add1, "Admix"))    // "Benjy"
   < src..

#    The @c(findLinks) function from @l(#Section 5.2) uses a helper function,
#    @c(visit), to visit all the nodes in an HTML document and apply an action to
#    each one. Using a function value, we can separate the logic for tree
#    traversal from the logic for the action to be applied to each node, letting
#    us reuse the traversal with different actions.
   La funcion @c(findLinks) de la @l(#Seccion 5.2) utiliza una funcion auxiliar,
   @c(visit), para visitar todos los nodos en un documento HTML y aplicar una
   accion a cada uno. Usando el valor de una funcion, podemos separar la logica
   del recorrido del arbol de la logica para la accion a aplicar a cada nodo,
   permitiendonos reutilizar el recorrido con diferentes acciones.

#    ..figure > @l(gopl.io/ch5/outline2/outline.go<>gopl.io/ch5/outline2)
   ..figure > @l(gopl.io/ch5/outline2/outline.go<>gopl.io/ch5/outline2)

#      ..src > go
#        // forEachNode calls the functions pre(x) and post(x) for each node
#        // x in the tree rooted at n. Both functions are optional.
#        // pre is called before the children are visited (preorder) and
#        // post is called after (postorder).
#        func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
#          if pre != nil {
#            pre(n)
#          }
#
#          for c := n.FirstChild; c != nil; c = c.NextSibling {
#            forEachNode(c, pre, post)
#          }
#
#          if post != nil {
#            post(n)
#          }
#        }
#      < src..
     ..src > go
       // forEachNode llama a las funciones pre(x) y post(x) para cada nodo
       // x en el arbol originado en n. Ambas funciones son opcionales.
       // pre se llama antes de que los hijos sean visitados (preorden) y
       // post se llama despues (postorden).
       func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
         if pre != nil {
           pre(n)
         }

         for c := n.FirstChild; c != nil; c = c.NextSibling {
           forEachNode(c, pre, post)
         }

         if post != nil {
           post(n)
         }
       }
     < src..


#    The @c(forEachNode) function accepts two function arguments, one to call
#    before a node’s children are visited and one to call after. This arrangement
#    gives the caller a great deal of flexibility. For example, the functions
#    @c(startElement) and @c(endElement) print the start and end tags of an HTML
#    element like @c(<b>...</b>):
   La funcion @c(forEachNode) acepta dos argumentos de funcion, una para llamar
   antes de que se visiten los hijos de un nodo y otra para llamar despues. Esta
   disposicion da a al lamador una gran flexibilidad. Por ejemplo, las funciones
   @c(startElement) y @c(endElement) imprimen las etiquetas de inicio y fin de
   un elemento HTML, como @c(<b>...</b>):

#    ..src > go
#      var depth int
#
#      func startElement(n *html.Node) {
#        if n.Type == html.ElementNode {
#          fmt.Printf("%*s<%s>\n", depth*2, "", n.Data)
#          depth++
#        }
#      }
#
#      func endElement(n *html.Node) {
#        if n.Type == html.ElementNode {
#          depth--
#          fmt.Printf("%*s</%s>\n", depth*2, "", n.Data)
#        }
#      }
#    < src..
   ..src > go
     var depth int

     func startElement(n *html.Node) {
       if n.Type == html.ElementNode {
         fmt.Printf("%*s<%s>\n", depth*2, "", n.Data)
         depth++
       }
     }

     func endElement(n *html.Node) {
       if n.Type == html.ElementNode {
         depth--
         fmt.Printf("%*s</%s>\n", depth*2, "", n.Data)
       }
     }
   < src..

#    The functions also indent the output using another @c(fmt.Printf) trick. The
#    @c(*) adverb in @c(%*s) prints a string padded with a variable number of
#    spaces. The width and the string are provided by the arguments @c(depth*2)
#    and @c("").
   Las funciones tambien indentan la salida usando otro truco de
   @c(fmt.Printf). El adverbio @c(*) en @c(%*s) imprime una cadena rellena con
   un numero variable de espacios. La anchura y la cadena se proporcionan por
   los argumentos @c(depth*2) y @c("").

#    If we call @c(forEachNode) on an HTML document, like this:
   Si llamamos a @c(forEachNode) en un documento HTML, de esta forma:

#    ..src > go
#      forEachNode(doc, startElement, endElement)
#    < src..
   ..src > go
     forEachNode(doc, startElement, endElement)
   < src..

#    we get a more elaborate variation on the output of our earlier @$(outline)
#    program:
   obtenemos una variacion mas elaborada en la salida de nuestra programa
   @$(outline) anterior:

#    ..src > sh
#      $ go build gopl.io/ch5/outline2
#      $ ./outline2 http://gopl.io
#      <html>
#        <head>
#          <meta>
#          </meta>
#          <title>
#          </title>
#          <style>
#          </style>
#        </head>
#      <body>
#        <table>
#          <tbody>
#            <tr>
#              <td>
#                <a>
#                  <img>
#                  </img>
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch5/outline2
     $ ./outline2 http://gopl.io
     <html>
       <head>
         <meta>
         </meta>
         <title>
         </title>
         <style>
         </style>
       </head>
     <body>
       <table>
         <tbody>
           <tr>
             <td>
               <a>
                 <img>
                 </img>
     ...
   < src..

#    @b(Exercise 5.7): Develop @c(startElement) and @c(endElement) into a general
#    HTML pretty-printer.  Print comment nodes, text nodes, and the attributes of
#    each element (@c(<a href='...'>)). Use short forms like @c(<img/>) instead of
#    @c(<img></img>) when an element has no children. Write a test to ensure that
#    the output can be parsed successfully. (See @l(#Chapter 11).)
   @b(Ejercicio 5.7): Desarrolla @c(startElement) y @c(endElement) en una
   agradable impresora HTML general. Imprime los nodos de comentarios, nodos de
   texto y los atributos de cada elemento (@c(<a href='...'>)). Utilizar formas
   cortas como @c(<img/>) en lugar de @c(<img></img>) cuando un elemento no
   tiene hijos. Escribir una prueba para asegurarse de que la salida se puede
   analizar con exito. (Vease el @l(#Capitulo 11)).

#    @b(Exercise 5.8): Modify @c(forEachNode) so that the @c(pre) and @c(post)
#    functions return a boolean result indicating whether to continue the
#    traversal. Use it to write a function @c(ElementByID) with the following
#    signature that finds the first HTML element with the specified @c(id)
#    attribute. The function should stop the traversal as soon as a match is
#    found.
   @b(Ejercicio 5.8): Modificar @c(forEachNode) para que las funciones @c(pre) y
   @c(post) devuelvan un resultado booleano que señale si se debe continuar el
   recorrido. Utilicelo para escribir una funcion @c(ElementByID) con la
   siguiente firma que se encuentra el primer elemento HTML con el atributo id
   especificado. La funcion debe detener el recorrido tan pronto como se
   encuentre una coincidencia.

#    ..src > go
#      func ElementByID(doc *html.Node, id string) *html.Node
#    < src..
   ..src > go
     func ElementByID(doc *html.Node, id string) *html.Node
   < src..

#    @b(Exercise 5.9): Write a function @c[expand(s string, f func(string) string)
#    string] that replaces each substring @"(@c($foo)) within s by the text
#    returned by @c[f("foo")].
   @b(Ejercicio 5.9): Escribir una funcion @c[expand(s string, f func(string)
   string) string] que reemplaze cada subcadena @c("$foo") dentro de @c(s) con
   el texto devuelto por @c[f("foo")].

# ** Section 5.6 <> Anonymous Functions
** Seccion 5.6 <> Funciones Anonimas

#    Named functions can be declared only at the package level, but we can use a
#    @e(function literal) to denote a function value within any expression. A
#    function literal is written like a function declaration, but without a name
#    following the @c(func) keyword. It is an expression, and its value is called
#    an @e(anonymous function).
   Funciones con nombre se pueden declarar solo a nivel de paquete, pero podemos
   utilizar un @e(literal de funcion) para denotar un valor de funcion dentro de
   cualquier expresion. Un literal funcion se escribe como una declaracion de la
   funcion, pero sin un nombre despues de la palabra clave @c(func). Es una
   expresion, y su valor se denomina @e(funcion anonima).

#    Function literals let us define a function at its point of use. As an
#    example, the earlier call to @c(strings.Map) can be rewritten as
   Los literales de la funcion definen una funcion en su punto de uso. A modo de
   ejemplo, la llamada anterior a @c(strings.Map) se puede reescribir como

#    ..src > go
#      strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
#    < src..
   ..src > go
     strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
   < src..

#    More importantly, functions defined in this way have access to the entire
#    lexical environment, so the inner function can refer to variables from the
#    enclosing function, as this example shows:
   Mas importante aun, las funciones definidas de esta manera tienen acceso a
   todo el entorno lexico, por lo que la funcion interna puede referirse a
   variables de la funcion de inclusion, como muestra este ejemplo:

#    ..figure > @l(gopl.io/ch5/squares/main.go<>gopl.io/ch5/squares)
   ..figure > @l(gopl.io/ch5/squares/main.go<>gopl.io/ch5/squares)

#      ..src > go
#        // squares returns a function that returns
#        // the next square number each time it is called.
#        func squares() func() int {
#          var x int
#          return func() int {
#            x++
#            return x * x
#          }
#        }
#
#        func main() {
#          f := squares()
#          fmt.Println(f()) // "1"
#          fmt.Println(f()) // "4"
#          fmt.Println(f()) // "9"
#          fmt.Println(f()) // "16"
#        }
#      < src..
     ..src > go
       // squares regresa una funcion que devuelve el siguiente
       // cuadrado del numero cada ves que se llama.
       func squares() func() int {
         var x int
         return func() int {
           x++
           return x * x
         }
       }

       func main() {
         f := squares()
         fmt.Println(f()) // "1"
         fmt.Println(f()) // "4"
         fmt.Println(f()) // "9"
         fmt.Println(f()) // "16"
       }
     < src..


#    The function @c(squares) returns another function, of type @c[func() int]. A
#    call to @c(squares) creates a local variable @c(x) and returns an anonymous
#    function that, each time it is called, increments @c(x) and returns its
#    square. A second call to @c(squares) would create a second variable @c(x) and
#    return a new anonymous function which increments that variable.
   La funcion @c(squares) devuelve otra funcion, de tipo @c[func() int]. Una
   llamada a @c(squares) crea una variable local @c(x) y devuelve una funcion
   anonima que, cada vez que se llama, incrementa @c(x) y devuelve su
   cuadrado. Una segunda llamada a @c(squares) crearia una segunda variable
   @c(x) y devolvera una nueva funcion anonima que incremente esa variable.

#    The @c(squares) example demonstrates that function values are not just code
#    but can have state.  The anonymous inner function can access and update the
#    local variables of the enclosing function @c(squares). These hidden variable
#    references are why we classify functions as reference types and why function
#    values are not comparable. Function values like these are implemented using a
#    technique called @e(closures), and Go programmers often use this term for
#    function values.
   El ejemplo @c(squares) demuestra que los valores de funcion no son solo
   codigo, sino que pueden tener estado. La funcion anonima interna puede
   acceder y actualizar las variables locales dentro de la funcion @c(squares).
   Estas referencias de variables ocultas son el por que clasificamos a las
   funciones como tipos de referencia y motivo de que los valores de las
   funciones no sean comparables. Los valores de funcion como estos se
   implementan utilizando una tecnica llamada @e(closures), y los programadores
   Go a menudo utilizan este termino para los valores de la funcion.

#    Here again we see an example where the lifetime of a variable is not
#    determined by its scope: the variable @c(x) exists after @c(squares) has
#    returned within @c(main), even though @c(x) is hidden inside @c(f).
   Aqui de nuevo vemos un ejemplo donde el tiempo de vida de una variable no
   esta determinada por su ambito de aplicacion: la variable @c(x) existe
   despues del retorno de @c(squares) dentro de @c(main), aunque @c(x) este
   oculta dentro de @c(f).

#    As a somewhat academic example of anonymous functions, consider the problem
#    of computing a sequence of computer science courses that satisfies the
#    prerequisite requirements of each one. The prerequisites are given in the
#    @c(prereqs) table below, which is a mapping from each course to the list of
#    courses that must be completed before it.
   Como un ejemplo un tanto academico de funciones anonimas, considere el
   problema de calcular una secuencia de los cursos de ciencias de la
   computacion que satisfagan los requisitos previos de cada uno. Los
   prerequisitos se dan en la tabla @c(prereqs) de abajo, que es un mapeo de
   cada curso a la lista de cursos que se deben completar antes de ella.

#    ..figure > @l(gopl.io/ch5/toposort/main.go<>gopl.io/ch5/toposort)
   ..figure > @l(gopl.io/ch5/toposort/main.go<>gopl.io/ch5/toposort)

#      ..src > go
#        // prereqs maps computer science courses to their prerequisites.
#        var prereqs = map[string][]string{
#          "algorithms": {"data structures"},
#          "calculus":   {"linear algebra"},
#
#          "compilers": {
#            "data structures",
#            "formal languages",
#            "computer organization",
#          },
#
#          "data structures":       {"discrete math"},
#          "databases":             {"data structures"},
#          "discrete math":         {"intro to programming"},
#          "formal languages":      {"discrete math"},
#          "networks":              {"operating systems"},
#          "operating systems":     {"data structures", "computer organization"},
#          "programming languages": {"data structures", "computer organization"},
#        }
#      < src..
     ..src > go
       // prereqs asigna cursos de ciencia de la computacion a sus prerequisitos.
       var prereqs = map[string][]string{
         "algoritmos": {"estructura de datos"},
         "calculo":   {"algebra lineal"},

         "compiladores": {
           "estructura de datos",
           "lenguajes formales",
           "organizacion de computadoras",
         },

         "estructura de datos":       {"matematicas discretas"},
         "bases de datos":            {"estructura de datos"},
         "matematicas discretas":     {"introduccion a la programacion"},
         "lenguajes formales":        {"matematicas discretas"},
         "redes":                     {"sitemas operativos"},
         "sistemas operativos":       {"estructura de datos", "organizacion de computadoras"},
         "lenguajes de programacion": {"estructura de datos", "organizacion de computadoras"},
       }
     < src..


#    This kind of problem is known as topological sorting. Conceptually, the
#    prerequisite information forms a directed graph with a node for each course
#    and edges from each course to the courses that it depends on. The graph is
#    acyclic: there is no path from a course that leads back to itself. We can
#    compute a valid sequence using depth-first search through the graph with the
#    code below :
   Este tipo de problema se conoce como clasificacion topologica.
   Conceptualmente, la informacion de los requisitos previos forma un grafico
   dirigido con un nodo para cada curso y los bordes de cada curso a los cursos
   de los que depende. El grafico es aciclico: no hay camino de un curso que
   vuelva a si mismo. Podemos calcular una secuencia valida usando la busqueda
   de profundidad en el grafico con el siguiente codigo:

#    ..src > go
#      func main() {
#        for i, course := range topoSort(prereqs) {
#          fmt.Printf("%d:\t%s\n", i+1, course)
#        }
#      }
#
#      func topoSort(m map[string][]string) []string {
#        var order []string
#        seen := make(map[string]bool)
#        var visitAll func(items []string)
#
#        visitAll = func(items []string) {
#          for _, item := range items {
#            if !seen[item] {
#              seen[item] = true
#              visitAll(m[item])
#              order = append(order, item)
#            }
#          }
#        }
#
#        var keys []string
#        for key := range m {
#          keys = append(keys, key)
#        }
#
#        sort.Strings(keys)
#        visitAll(keys)
#        return order
#      }
#    < src..
   ..src > go
     func main() {
       for i, course := range topoSort(prereqs) {
         fmt.Printf("%d:\t%s\n", i+1, course)
       }
     }

     func topoSort(m map[string][]string) []string {
       var order []string
       seen := make(map[string]bool)
       var visitAll func(items []string)

       visitAll = func(items []string) {
         for _, item := range items {
           if !seen[item] {
             seen[item] = true
             visitAll(m[item])
             order = append(order, item)
           }
         }
       }

       var keys []string
       for key := range m {
         keys = append(keys, key)
       }

       sort.Strings(keys)
       visitAll(keys)
       return order
     }
   < src..


#    When an anonymous function requires recursion, as in this example, we must
#    first declare a variable, and then assign the anonymous function to that
#    variable. Had these two steps been combined in the declaration, the function
#    literal would not be within the scope of the variable @c(visitAll) so it
#    would have no way to call itself recursively:
   Cuando una funcion anonima requiere recursion, como en este ejemplo, primero
   debemos declarar una variable, y luego asignar la funcion anonima a esa
   variable. Si estos dos pasos estuvieran combinados en la declaracion, la
   funcion literal no estaria dentro del alcance de la variable @c(visitAll) por
   lo que no tendria ninguna manera de llamarse a si misma de forma recursiva:

#    ..src > go
#      visitAll := func(items []string) {
#        // ...
#        visitAll(m[item]) // compile error: undefined: visitAll
#        // ...
#      }
#    < src..
   ..src > go
     visitAll := func(items []string) {
       // ...
       visitAll(m[item]) // compile error: undefined: visitAll
       // ...
     }
   < src..

#    The output of the @$(toposort) program is shown below. It is deterministic,
#    an often-desirable property that doesn’t always come for free. Here, the
#    values of the @c(prereqs) map are slices, not more maps, so their iteration
#    order is deterministic, and we sorted the keys of @c(prereqs) before making
#    the initial calls to @c(visitAll).
   La salida del programa @$(toposort) se muestra a continuacion. Es
   determinista, una propiedad a menudo deseable que no siempre viene de forma
   gratuita. En este caso, los valores del mapa @c(prereqs) son slices, no mas
   mapas, por lo que su orden de iteracion es determinista, y ordenamos las
   llaves de @c(prereqs) antes de hacer las llamadas iniciales a @c(visitAll) .

#    ..pre >
#      1:      intro to programming
#      2:      discrete math
#      3:      data structures
#      4:      algorithms
#      5:      linear algebra
#      6:      calculus
#      7:      formal languages
#      8:      computer organization
#      9:      compilers
#      10:     databases
#      11:     operating systems
#      12:     networks
#      13:     programming languages
#    < pre..
   ..pre >
     1:      introduccion a la programacion
     2:      matematicas discretas
     3:      estructura de datos
     4:      algoritmos
     5:      algebra lineal
     6:      calculo
     7:      lenguajes formales
     8:      organizacion de computadoras
     9:      compiladores
     10:     bases de datos
     11:     sistemas operativos
     12:     redes
     13:     Lenguajes de programacion
   < pre..

#    Let’s return to our @c(findLinks) example. We’ve moved the link-extraction
#    function @c(links.Extract) to its own package, since we’ll use it again in
#    @l(#Chapter 8). We replaced the @c(visit) function with an anonymous function
#    that appends to the @c(links) slice directly, and used @c(forEachNode) to
#    handle the traversal. Since @c(Extract) needs only the @c(pre) function, it
#    passes @c(nil) for the @c(post) argument.
   Volvamos a nuestro ejemplo @c(findLinks). Hemos movido la funcion de
   extraccion de enlaces @c(links.Extract) a su propio paquete, ya que la
   usaremos de nuevo en el @l(#Capitulo 8). Hemos sustituido la funcion
   @c(visit) con una funcion anonima que agrega directamente los @c(links) al
   slice, y utilizamos @c(forEachNode) para manejar el recorrido. Ya que
   @c(Extract) solo necesita la funcion @c(pre), se pasa @c(nil) para el
   argumento @c(post).

#    ..figure > @l(gopl.io/ch5/links/links.go<>gopl.io/ch5/links)
   ..figure > @l(gopl.io/ch5/links/links.go<>gopl.io/ch5/links)

#      ..src > go
#        // Package links provides a link-extraction function.
#        package links
#
#        import (
#          "fmt"
#          "net/http"
#
#          "golang.org/x/net/html"
#        )
#
#        // Extract makes an HTTP GET request to the specified URL, parses
#        // the response as HTML, and returns the links in the HTML document.
#        func Extract(url string) ([]string, error) {
#          resp, err := http.Get(url)
#          if err != nil {
#            return nil, err
#          }
#          if resp.StatusCode != http.StatusOK {
#            resp.Body.Close()
#            return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
#          }
#
#          doc, err := html.Parse(resp.Body)
#          resp.Body.Close()
#          if err != nil {
#            return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
#          }
#
#          var links []string
#          visitNode := func(n *html.Node) {
#            if n.Type == html.ElementNode && n.Data == "a" {
#              for _, a := range n.Attr {
#                if a.Key != "href" {
#                  continue
#                }
#                link, err := resp.Request.URL.Parse(a.Val)
#                if err != nil {
#                  continue // ignore bad URLs
#                }
#                links = append(links, link.String())
#              }
#            }
#          }
#          forEachNode(doc, visitNode, nil)
#          return links, nil
#        }
#      < src..
     ..src > go
       // El paquete links proporciona una funcion de extraccion de links.
       package links

       import (
         "fmt"
         "net/http"

         "golang.org/x/net/html"
       )

       // Extract hace una peticion HTTP GET a la URL especificada, analiza
       // la respuesta como HTML, y regresa el enlace en el documento HTML.
       func Extract(url string) ([]string, error) {
         resp, err := http.Get(url)
         if err != nil {
           return nil, err
         }
         if resp.StatusCode != http.StatusOK {
           resp.Body.Close()
           return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
         }

         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         var links []string
         visitNode := func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "a" {
             for _, a := range n.Attr {
               if a.Key != "href" {
                 continue
               }
               link, err := resp.Request.URL.Parse(a.Val)
               if err != nil {
                 continue // ignora URLs incorrectas
               }
               links = append(links, link.String())
             }
           }
         }
         forEachNode(doc, visitNode, nil)
         return links, nil
       }
     < src..


#    Instead of appending the raw @c(href) attribute value to the @c(links) slice,
#    this version parses it as a URL relative to the base URL of the document,
#    @c(resp.Request.URL). The resulting @c(link) is in absolute form, suitable
#    for use in a call to @c(http.Get).
   En lugar de añadir el atributo @c(href) en bruto al slice @c(links), esta
   version lo analiza como una direccion URL relativa a la URL base del
   documento, @c(resp.Request.URL). El enlace resultante esta en formato
   absoluta, adecuado para su uso en una llamada a @c(http.Get).

#    Crawling the web is, at its heart, a problem of graph traversal. The
#    @c(topoSort) example showed a depth-first traversal; for our web crawler,
#    we’ll use breadth-first traversal, at least initially. In @l(#Chapter 8),
#    we’ll explore concurrent traversal.
   El rastreador web es, en su corazon, un problema de grafico transversal. El
   ejemplo @c(topoSort) mostra un recorrido en profundidad; Para nuestro
   rastreador web, vamos a utilizar la anchura de primera transversal, al menos
   inicialmente. En el @l(#Capitulo 8), vamos a explorar el recorrido
   concurrente.

#    The function below encapsulates the essence of a breadth-first traversal. The
#    caller provides an initial list @c(worklist) of items to visit and a function
#    value @c(f) to call for each item. Each item is identified by a string. The
#    function @c(f) returns a list of new items to append to the worklist. The
#    @c(breadthFirst) function returns when all items have been visited. It
#    maintains a set of strings to ensure that no item is visited twice.
   La siguiente funcion encapsula la esencia de un recorrido de
   primer-anchura. El llamador proporciona una lista inicial @c(worklist) de
   elementos a visitar y un valor de la funcion @c(f) a llamar para cada
   elemento. Cada elemento se identifica mediante una cadena. La funcion @c(f)
   devuelve una lista de elementos nuevos a añadir a la lista de trabajo. La
   funcion @c(breadthFirst) regresa cuando todos los elementos han sido
   visitados. Mantiene un conjunto de cadenas para garantizar que ningun
   elemento se visita dos veces.

#    ..figure > @l(gopl.io/ch5/findlinks3/findlinks.go<>gopl.io/ch5/findlinks3)
   ..figure > @l(gopl.io/ch5/findlinks3/findlinks.go<>gopl.io/ch5/findlinks3)

#      ..src > go
#        // breadthFirst calls f for each item in the worklist.
#        // Any items returned by f are added to the worklist.
#        // f is called at most once for each item.
#        func breadthFirst(f func(item string) []string, worklist []string) {
#          seen := make(map[string]bool)
#          for len(worklist) > 0 {
#            items := worklist
#            worklist = nil
#            for _, item := range items {
#              if !seen[item] {
#                seen[item] = true
#                worklist = append(worklist, f(item)...)
#              }
#            }
#          }
#        }
#      < src..
     ..src > go
       // breadthFirst llama a f para cada elemento en worklist.
       // Todos los elementos devueltos por f se agregan a worklist.
       // f se llama como maximo una vez para cada elemento.
       func breadthFirst(f func(item string) []string, worklist []string) {
         seen := make(map[string]bool)
         for len(worklist) > 0 {
           items := worklist
           worklist = nil
           for _, item := range items {
             if !seen[item] {
               seen[item] = true
               worklist = append(worklist, f(item)...)
             }
           }
         }
       }
     < src..


#    As we explained in passing in @l(#Chapter 3), the argument @"{@c[f(item)...]}
#    causes all the items in the list returned by @c(f) to be appended to the
#    worklist.
   Como explicamos al pasar por el @l(#Capitulo 3), el argumento de
   @"{@c[f(item)...]}  hace que todos los elementos de la lista devuelta por f
   que se añadan a la lista de trabajo.

#    In our crawler, items are URLs. The @c(crawl) function we’ll supply to
#    @c(breadthFirst) prints the URL, extracts its links, and returns them so that
#    they too are visited.
   En nuestro rastreador, los elementos son URL. La funcion @c(crawl) que
   suministramos a @c(breadthFirst) imprime la URL, extrae sus enlaces, y los
   devuelve para que tambien se visiten..

#    ..src > go
#      func crawl(url string) []string {
#        fmt.Println(url)
#        list, err := links.Extract(url)
#        if err != nil {
#          log.Print(err)
#        }
#        return list
#      }
#    < src..
   ..src > go
     func crawl(url string) []string {
       fmt.Println(url)
       list, err := links.Extract(url)
       if err != nil {
         log.Print(err)
       }
       return list
     }
   < src..

#    To start the crawler off, we’ll use the command-line arguments as the initial
#    URLs.
   Para iniciar el rastreador, utilizaremos los argumentos de la linea de
   comandos como las URL iniciales.

#    ..src > go
#      func main() {
#        // Crawl the web breadth-first,
#        // starting from the command-line arguments.
#        breadthFirst(crawl, os.Args[1:])
#      }
#    < src..
   ..src > go
     func main() {
       // Rastrear la web la primer-anchura,
       // partiendo de los argumentos de la linea de comandos.
       breadthFirst(crawl, os.Args[1:])
     }
   < src..

#    Let’s crawl the web starting from @c(https://golang.org). Here are some of
#    the resulting links:
   Vamos a rastrear la web desde @c(https://golang.org). Estos son algunos de
   los enlaces resultantes:

#    ..src > sh
#      $ go build gopl.io/ch5/findlinks3
#      $ ./findlinks3 https://golang.org
#      https://golang.org/
#      https://golang.org/doc/
#      https://golang.org/pkg/
#      https://golang.org/project/
#      https://code.google.com/p/go-tour/
#      https://golang.org/doc/code.html
#      https://www.youtube.com/watch?v=XCsL89YtqCs
#      http://research.swtch.com/gotour
#      https://vimeo.com/53221560
#    < src..
   ..src > sh
     $ go build gopl.io/ch5/findlinks3
     $ ./findlinks3 https://golang.org
     https://golang.org/
     https://golang.org/doc/
     https://golang.org/pkg/
     https://golang.org/project/
     https://code.google.com/p/go-tour/
     https://golang.org/doc/code.html
     https://www.youtube.com/watch?v=XCsL89YtqCs
     http://research.swtch.com/gotour
     https://vimeo.com/53221560
   < src..

#    The process ends when all reachable web pages have been crawled or the memory
#    of the computer is exhausted.
   El proceso finaliza cuando todas las paginas web alcanzables se han rastreado
   o se ha agotado la memoria del equipo.

#    @b(Exercise 5.10): Rewrite @c(topoSort) to use maps instead of slices and
#    eliminate the initial sort.  Verify that the results, though
#    nondeterministic, are valid topological orderings.
   @b(Ejercicio 5.10): Vuelve a escribir @c(topoSort) para utilizar mapas en
   lugar de slices y eliminar la clasificacion inicial. Verifique que los
   resultados, aunque no deterministicos, sean ordenamientos topologicos
   validos.

#    @b(Exercise 5.11): The instructor of the linear algebra course decides that
#    calculus is now a prerequisite. Extend the @c(topoSort) function to report
#    cycles.
   @b(Ejercicio 5.11): El instructor del curso de algebra lineal decide que
   ahora es un requisito previo. Extender la funcion @c(topoSort) para reportar
   ciclos.

#    @b(Exercise 5.12): The @c(startElement) and @c(endElement) functions in
#    @c(gopl.io/ch5/outline2) (@l(#Section 5.5<>§5.5)) share a global variable,
#    @c(depth). Turn them into anonymous functions that share a variable local to
#    the @c(outline) function.
   @b(Ejercicio 5.12): Las funciones @c(startElement) y @c(endElement) en
   @c(gopl.io/ch5/outline2) (@l(#Seccion 5.5<>§5.5)) comparten una variable
   global, @c(depth). Conviertalas en funciones anonimas que compartan una
   variable local de la funcion @c(outline).

#    @b(Exercise 5.13): Modify @c(crawl) to make local copies of the pages it
#    finds, creating directories as necessary. Don’t make copies of pages that
#    come from a different domain. For example, if the original page comes from
#    @l(https://golang.org<>golang.org), save all files from there, but exclude
#    ones from @l(https://vimeo.com<>vimeo.com).
   @b(Ejercicio 5.13): Modificar @c(crawl) para hacer copias locales de las
   paginas que encuentre, la creando directorios segun sea necesario. No haga
   copias de paginas que provengan de un dominio diferente. Por ejemplo, si la
   pagina original proviene de @l(https://golang.org<>golang.org), guarda todos
   los archivos de alli, pero excluyen los de @l(https://vimeo.com<>vimeo.com).

#    @b(Exercise 5.14): Use the @c(breadthFirst) function to explore a different
#    structure. For example, you could use the course dependencies from the
#    @c(topoSort) example (a directed graph), the file system hierarchy on your
#    computer (a tree), or a list of bus or subway routes downloaded from your
#    city government’s web site (an undirected graph).
   @b(Ejercicio 5.14): Usar la funcion @c(breadthFirst) para explorar una
   estructura diferente. Por ejemplo, podria utilizar las dependencias de cursos
   del ejemplo @c(topoSort) (un grafo dirigido), la jerarquia del sistema de
   archivos en el ordenador (un arbol), o una lista de rutas de autobus o de
   metro descargados desde el sitio web de su gobierno de la ciudad (un grafo no
   dirigido).

# *** Section 5.6.1 <> Caveat: Capturing Iteration Variables
*** Seccion 5.6.1 <> Advertencia: Captura de Variables de Iteracion

#     In this section, we’ll look at a pitfall of Go’s lexical scope rules that
#     can cause surprising results.  We urge you to understand the problem before
#     proceeding, because the trap can ensnare even experienced programmers.
    En esta seccion, veremos una trampa de las reglas de alcance lexico de Go
    que pueden causar resultados sorprendentes. Le recomendamos que comprenda el
    problema antes de proceder, porque la trampa puede atrapar incluso a
    programadores experimentados.

#     Consider a program that must create a set of directories and later remove
#     them. We can use a slice of function values to hold the clean-up
#     operations. (For brevity, we have omitted all error handling in this
#     example.)
    Considere un programa que debe crear un conjunto de directorios y luego
    eliminarlos. Podemos usar una porcion de valores de funcion para mantener
    las operaciones de limpieza. (Para mayor brevedad, hemos omitido todo el
    manejo de errores en este ejemplo.)

#     ..src > go
#       var rmdirs []func()
#       for _, d := range tempDirs() {
#         dir := d               // NOTE: necessary!
#         os.MkdirAll(dir, 0755) // creates parent directories too
#         rmdirs = append(rmdirs, func() {
#           os.RemoveAll(dir)
#         })
#       }
#
#       // ...do some work...
#
#       for _, rmdir := range rmdirs {
#         rmdir() // clean up
#       }
#     < src..
    ..src > go
      var rmdirs []func()
      for _, d := range tempDirs() {
        dir := d               // NOTA: necesario!
        os.MkdirAll(dir, 0755) // tambien crea los directorios padre
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dir)
        })
      }

      // ...algo de trabajo...

      for _, rmdir := range rmdirs {
        rmdir() // clean up
      }
    < src..

#     You may be wondering why we assigned the loop variable @c(d) to a new local
#     variable @c(dir) within the loop body, instead of just naming the loop
#     variable @c(dir) as in this subtly incorrect variant:
    Es posible que se pregunte por que asignamos la variable de bucle @c(d) a
    una nueva variable local @c(dir) dentro del cuerpo del bucle, en lugar de
    simplemente nombrar a la variable de bucle @c(dir) que en esta variante
    sutil incorrectos:

#     ..src > go
#       var rmdirs []func()
#       for _, dir := range tempDirs() {
#         os.MkdirAll(dir, 0755)
#         rmdirs = append(rmdirs, func() {
#           os.RemoveAll(dir) // NOTE: incorrect!
#         })
#       }
#     < src..
    ..src > go
      var rmdirs []func()
      for _, dir := range tempDirs() {
        os.MkdirAll(dir, 0755)
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dir) // NOTA: incorrecto!
        })
      }
    < src..

#     The reason is a consequence of the scope rules for loop variables. In the
#     program immediately above, the @c(for) loop introduces a new lexical block
#     in which the variable @c(dir) is declared. All function values created by
#     this loop @"(capture) and share the same variable—an addressable storage
#     location, not its value at that particular moment. The value of @c(dir) is
#     updated in successive iterations, so by the time the cleanup functions are
#     called, the @c(dir) variable has been updated several times by the
#     now-completed @c(for) loop. Thus @c(dir) holds the value from the final
#     iteration, and consequently all calls to @c(os.RemoveAll) will attempt to
#     remove the same directory.
    La razon es una consecuencia de las reglas de alcance para variables de
    bucle. En el programa inmediatamente anterior, el bucle @c(for) introduce un
    nuevo bloque lexico en el que se declara la variable @c(dir). Todos los
    valores de la funcion creados por esta bucle @"(capturan) y comparten la
    misma variable–Un lugar de almacenamiento direccionable, no su valor en ese
    momento en particular. El valor de @c(dir) se actualiza en iteraciones
    sucesivas, de manera que cuando las funciones de limpieza son llamados, la
    variable @c(dir) ha sido actualizado varias veces por el ahora completado
    bucle @c(for). Por lo tanto @c(dir) mantiene el valor de la iteracion final,
    y por lo tanto todas las llamadas a @c(os.RemoveAll) intentaran eliminar el
    mismo directorio.

#     Frequently, the inner variable introduced to work around this
#     problem—@c(dir) in our example—is given the exact same name as the outer
#     variable of which it is a copy, leading to odd-looking but crucial variable
#     declarations like this:
    Con frecuencia, la variable interna introducido para evitar este
    problema–@c(dir) en nuestro ejemplo–se le da exactamente el mismo nombre que
    la variable externa de la que es una copia, lo que lleva a las declaraciones
    de variables de aspecto extraño pero cruciales como este:

#     ..src > go
#       for _, dir := range tempDirs() {
#         dir := dir // declares inner dir, initialized to outer dir
#         // ...
#       }
#     < src..
    ..src > go
      for _, dir := range tempDirs() {
        dir := dir // declara dir interno, inicializado a dir externo
        // ...
      }
    < src..

#     The risk is not unique to @c(range)-based @c(for) loops. The loop in the
#     example below suffers from the same problem due to unintended capture of the
#     index variable @c(i).
    El riesgo no es unica para bucles @c(for) basados en @c(range). El bucle en
    el siguiente ejemplo adolece del mismo problema debido a la captura no
    intencionada de la variable de indice @c(i).

#     ..src > go
#       var rmdirs []func()
#       dirs := tempDirs()
#       for i := 0; i < len(dirs); i++ {
#         os.MkdirAll(dirs[i], 0755) // OK
#         rmdirs = append(rmdirs, func() {
#           os.RemoveAll(dirs[i]) // NOTE: incorrect!
#         })
#       }
#     < src..
    ..src > go
      var rmdirs []func()
      dirs := tempDirs()
      for i := 0; i < len(dirs); i++ {
        os.MkdirAll(dirs[i], 0755) // OK
        rmdirs = append(rmdirs, func() {
          os.RemoveAll(dirs[i]) // NOTA: incorrecto!
        })
      }
    < src..

#     The problem of iteration variable capture is most often encountered when
#     using the @c(go) statement (@l(#Chapter 8)) or with @c(defer) (which we will
#     see in a moment) since both may delay the execution of a function value
#     until after the loop has finished. But the problem is not inherent to @c(go)
#     or @c(defer).
    El problema de la iteracion de captura variable se encuentran mas a menudo
    cuando se utiliza la sentencia @c(go) (@l(#Capitulo 8)) o con @c(defer) (que
    veremos en un momento), ya que ambos pueden retrasar la ejecucion de un
    valor de funcion hasta despues de que el bucle ha finalizado. Pero el
    problema no es inherente a @c(go) o @c(defer).

# ** Section 5.7 <> Variadic Functions
** Seccion 5.7 <> Funciones Variadic

#    A @e(variadic function) is one that can be called with varying numbers of
#    arguments. The most familiar examples are @c(fmt.Printf) and its
#    variants. @c(Printf) requires one fixed argument at the beginning, then
#    accepts any number of subsequent arguments.
   Una @e(funcion variadic) es uno que se puede llamar con un numero de
   argumentos variable. Los ejemplos mas conocidos son @c(fmt.Printf) y sus
   variantes. @c(Printf) requiere un argumento fijo al principio, luego acepta
   cualquier numero de argumentos posteriores.

#    To declare a variadic function, the type of the final parameter is preceded
#    by an ellipsis, @"(@c(...)), which indicates that the function may be called with
#    any number of arguments of this type.
   Para declarar una funcion variadic, el tipo del parametro final va precedida
   por una elipsis, @"(@c(...)), que indica que la funcion puede ser llamada con
   cualquier numero de argumentos de este tipo.

#    ..figure > @l(gopl.io/ch5/sum/main.go<>gopl.io/ch5/sum)
   ..figure > @l(gopl.io/ch5/sum/main.go<>gopl.io/ch5/sum)

#      ..src > go
#        func sum(vals ...int) int {
#          total := 0
#          for _, val := range vals {
#            total += val
#          }
#          return total
#        }
#      < src..
     ..src > go
       func sum(vals ...int) int {
         total := 0
         for _, val := range vals {
           total += val
         }
         return total
       }
     < src..


#    The @c(sum) function above returns the sum of zero or more @c(int)
#    arguments. Within the body of the function, the type of @c(vals) is an
#    @c([]int) slice. When @c(sum) is called, any number of values may be provided
#    for its @c(vals) parameter.
   La funcion @c(sum) anterior devuelve la suma de cero o mas argumentos
   @c(int). Dentro del cuerpo de la funcion, el tipo de @c(vals) es un slice
   @c([]int). Cuando llame a @c(sum), cualquier numero de valores puede ser
   proporcionado pora su parametro @c(vals).

#    ..src > go
#      fmt.Println(sum())           // "0"
#      fmt.Println(sum(3))          // "3"
#      fmt.Println(sum(1, 2, 3, 4)) // "10"
#    < src..
   ..src > go
     fmt.Println(sum())           // "0"
     fmt.Println(sum(3))          // "3"
     fmt.Println(sum(1, 2, 3, 4)) // "10"
   < src..

#    Implicitly, the caller allocates an array, copies the arguments into it, and
#    passes a slice of the entire array to the function. The last call above thus
#    behaves the same as the call below, which shows how to invoke a variadic
#    function when the arguments are already in a slice: place an ellipsis after
#    the final argument.
   Implicitamente, el llamador asigna un arreglo, copia los argumentos en ell y
   pasa un slice de toda la arreglo a la funcion. La llamada anterior se
   comporta de la misma manera que la llamada que se muestra a continuacion, que
   muestra como invocar una funcion variadica cuando los argumentos ya estan en
   un slice: coloca una elipsis despues del argumento final.

#    ..src > go
#      values := []int{1, 2, 3, 4}
#      fmt.Println(sum(values...)) // "10"
#    < src..
   ..src > go
     values := []int{1, 2, 3, 4}
     fmt.Println(sum(values...)) // "10"
   < src..

#    Although the @c(...int) parameter behaves like a slice within the function
#    body, the type of a variadic function is distinct from the type of a function
#    with an ordinary slice parameter.
   Aunque el parametro @c(...int) se comporta como una slice dentro del cuerpo
   de la funcion, el tipo de una funcion variadic es distinto del tipo de una
   funcion con un parametro slice ordinario.

#    ..src > go
#      func f(...int) {}
#      func g([]int)  {}
#
#      fmt.Printf("%T\n", f) // "func(...int)"
#      fmt.Printf("%T\n", g) // "func([]int)"
#    < src..
   ..src > go
     func f(...int) {}
     func g([]int)  {}

     fmt.Printf("%T\n", f) // "func(...int)"
     fmt.Printf("%T\n", g) // "func([]int)"
   < src..

#    Variadic functions are often used for string formatting. The @c(errorf)
#    function below constructs a formatted error message with a line number at the
#    beginning. The suffix @c(f) is a widely followed naming convention for
#    variadic functions that accept a @c(Printf)-style format string.
   Las funciones variadic se utilizan a menudo para el formato de la
   secuencia. La funcion @c(errorf) a continuacion construye un mensaje de error
   con formato con un numero de linea en el principio. El sufijo @c(f) es una
   convencion de nomenclatura ampliamente seguido para funciones variadic que
   aceptan una cadena de formato de estilo @c(Printf).

#    ..src > go
#      func errorf(linenum int, format string, args ...interface{}) {
#        fmt.Fprintf(os.Stderr, "Line %d: ", linenum)
#        fmt.Fprintf(os.Stderr, format, args...)
#        fmt.Fprintln(os.Stderr)
#      }
#
#      linenum, name := 12, "count"
#      errorf(linenum, "undefined: %s", name) // "Line 12: undefined: count"
#    < src..
   ..src > go
     func errorf(linenum int, format string, args ...interface{}) {
       fmt.Fprintf(os.Stderr, "Line %d: ", linenum)
       fmt.Fprintf(os.Stderr, format, args...)
       fmt.Fprintln(os.Stderr)
     }

     linenum, name := 12, "count"
     errorf(linenum, "undefined: %s", name) // "Linea 12: sin definir: count"
   < src..

#    The @c(interface{}) type means that this function can accept any values at
#    all for its final arguments, as we’ll explain in @l(#Chapter 7).
   El tipo @c(interface{}) significa que esta funcion puede aceptar cualquier
   valor en absoluto para sus argumentos finales, como explicaremos en el
   @l(#Capitulo 7).

#    @b(Exercise 5.15): Write variadic functions @c(max) and @c(min), analogous to
#    @c(sum). What should these functions do when called with no arguments? Write
#    variants that require at least one argument.
   @b(Ejercicio 5.15): Escribir funciones variadic @c(max) y @c(min), analoga a
   @c(sum). ¿Que deben hacer estas funciones cuando se llaman sin argumentos?
   Escribir variantes que requieren al menos un argumento.

#    @b(Exercise 5.16): Write a variadic version of @c(strings.Join).
   @b(Ejercicio 5.16): Escribir una version variadic @c(de strings.Join) .

#    @b(Exercise 5.17): Write a variadic function @c(ElementsByTagName) that,
#    given an HTML node tree and zero or more names, returns all the elements that
#    match one of those names. Here are two example calls:
   @b(Ejercicio 5.17): Escribir una funcion variadic @c(ElementsByTagName) que, dado
   un arbol de nodos HTML y cero o mas nombres, devuelve todos los elementos que
   coinciden con uno de esos nombres. Aqui hay dos ejemplos de llamadas:

#    ..src > go
#      func ElementsByTagName(doc *html.Node, name ...string) []*html.Node
#
#      images := ElementsByTagName(doc, "img")
#      headings := ElementsByTagName(doc, "h1", "h2", "h3", "h4")
#    < src..
   ..src > go
     func ElementsByTagName(doc *html.Node, name ...string) []*html.Node

     images := ElementsByTagName(doc, "img")
     headings := ElementsByTagName(doc, "h1", "h2", "h3", "h4")
   < src..

# ** Section 5.8 <> Deferred Function Calls
** Seccion 5.8 <> Llamadas de Funcion Diferida

#    Our @c(findLinks) examples used the output of @c(http.Get) as the input to
#    @c(html.Parse). This works well if the content of the requested URL is indeed
#    HTML, but many pages contain images, plain text, and other file
#    formats. Feeding such files into an HTML parser could have undesirable
#    effects.
   Nuestros ejemplos @c(findLinks) utilizan la salida de @c(http.Get) como la
   entrada de @c(html.Parse). Esto funciona bien si el contenido de la URL
   solicitada es de hecho HTML, pero muchas paginas contienen imagenes, texto
   sin formato y otros formatos de archivo. La alimentacion de estos archivos en
   un analizador HTML podria tener efectos no deseados.

#    The program below fetches an HTML document and prints its title. The
#    @c(title) function inspects the @c(Content-Type) header of the server’s
#    response and returns an error if the document is not HTML.
   El siguiente programa recupera un documento HTML e imprime su titulo. La
   funcion @c(title) inspecciona la cabecera @c(Content-Type) de la respuesta
   del servidor y devuelve un error si el documento no es HTML.

#    ..figure > @l(gopl.io/ch5/title1/title.go<>gopl.io/ch5/title1)
   ..figure > @l(gopl.io/ch5/title1/title.go<>gopl.io/ch5/title1)

#      ..src > go
#        func title(url string) error {
#          resp, err := http.Get(url)
#          if err != nil {
#            return err
#          }
#
#          // Check Content-Type is HTML (e.g., "text/html; charset=utf-8").
#          ct := resp.Header.Get("Content-Type")
#          if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
#            resp.Body.Close()
#            return fmt.Errorf("%s has type %s, not text/html", url, ct)
#          }
#
#          doc, err := html.Parse(resp.Body)
#          resp.Body.Close()
#          if err != nil {
#            return fmt.Errorf("parsing %s as HTML: %v", url, err)
#          }
#
#          visitNode := func(n *html.Node) {
#            if n.Type == html.ElementNode && n.Data == "title" &&
#              n.FirstChild != nil {
#              fmt.Println(n.FirstChild.Data)
#            }
#          }
#          forEachNode(doc, visitNode, nil)
#          return nil
#        }
#      < src..
     ..src > go
       func title(url string) error {
         resp, err := http.Get(url)
         if err != nil {
           return err
         }

         // Comprueba que Content-Type sea HTML (e.g., "text/html; charset=utf-8").
         ct := resp.Header.Get("Content-Type")
         if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
           resp.Body.Close()
           return fmt.Errorf("%s has type %s, not text/html", url, ct)
         }

         doc, err := html.Parse(resp.Body)
         resp.Body.Close()
         if err != nil {
           return fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         visitNode := func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "title" &&
             n.FirstChild != nil {
             fmt.Println(n.FirstChild.Data)
           }
         }
         forEachNode(doc, visitNode, nil)
         return nil
       }
     < src..


#    Here’s a typical session, slightly edited to fit:
   Aqui esta una sesion tipica, ligeramente editada para encajar:

#    ..src > sh
#      $ go build gopl.io/ch5/title1
#      $ ./title1 http://gopl.io
#      The Go Programming Language
#      $ ./title1 https://golang.org/doc/effective_go.html
#      Effective Go - The Go Programming Language
#      $ ./title1 https://golang.org/doc/gopher/frontpage.png
#      title: https://golang.org/doc/gopher/frontpage.png
#          has type image/png, not text/html
#    < src..
   ..src > sh
     $ go build gopl.io/ch5/title1
     $ ./title1 http://gopl.io
     The Go Programming Language
     $ ./title1 https://golang.org/doc/effective_go.html
     Effective Go - The Go Programming Language
     $ ./title1 https://golang.org/doc/gopher/frontpage.png
     title: https://golang.org/doc/gopher/frontpage.png
         has type image/png, not text/html
   < src..

#    Observe the duplicated @c[resp.Body.Close()] call, which ensures that
#    @c(title) closes the network connection on all execution paths, including
#    failures. As functions grow more complex and have to handle more errors, such
#    duplication of clean-up logic may become a maintenance problem. Let’s see how
#    Go’s novel @c(defer) mechanism makes things simpler.
   Observe la llamada duplicada @c[resp.Body.Close()], que asegura que @c(title)
   se cierre la conexion de red en todas las rutas de ejecucion, incluyendo las
   fallas. A medida que las funciones se vuelven mas complejas y tienen que
   manejar mas errores, tal duplicacion de la logica de limpieza puede
   convertirse en un problema de mantenimiento. Veamos como el nuevo mecanismo
   @c(defer) de Go hace las cosas mas sencillas.

#    Syntactically, a @c(defer) statement is an ordinary function or method call
#    prefixed by the keyword @c(defer). The function and argument expressions are
#    evaluated when the statement is executed, but the actual call is @e(deferred)
#    until the function that contains the @c(defer) statement has finished,
#    whether normally, by executing a return statement or falling off the end, or
#    abnormally, by panicking. Any number of calls may be deferred; they are
#    executed in the reverse of the order in which they were deferred.
   Sintacticamente, una sentencia @c(defer) es una funcion ordinaria o una
   llamada a un metodo con la palabra clave @c(defer) como prefijo. Las
   expresiones de funcion y los argumentos se evaluan cuando se ejecuta la
   instruccion, pero la llamada real se aplaza hasta que la funcion que contiene
   la declaracion @c(defer) ha terminado, ya sea ejecutando una instruccion de
   retorno o llegando al final, o anormalmente, por un panico. Cualquier numero
   de llamadas puede ser diferido; se ejecutan en el orden inverso en que fueron
   aplazadas.

#    A @c(defer) statement is often used with paired operations like open and
#    close, connect and disconnect, or lock and unlock to ensure that resources
#    are released in all cases, no matter how complex the control flow. The right
#    place for a @c(defer) statement that releases a resource is immediately after
#    the resource has been successfully acquired. In the @c(title) function below,
#    a single deferred call replaces both previous calls to @c[resp.Body.Close()]:
   Una sentencia @c(defer) se utiliza a menudo con operaciones pareadas como
   abrir y cerrar, conectar y desconectar o bloquear y desbloquear para
   garantizar que los recursos se liberan en todos los casos, independientemente
   de la complejidad del flujo de control. El lugar adecuado para una sentencia
   @c(defer) que libera un recurso es inmediatamente despues de que el recurso
   se ha adquirido con exito. En la funcion @c(title) a continuacion, una sola
   llamada diferida sustituye a las dos llamadas anteriores de
   @c[resp.Body.Close()]:

#    ..figure > @l(gopl.io/ch5/title2/title.go<>gopl.io/ch5/title2)
   ..figure > @l(gopl.io/ch5/title2/title.go<>gopl.io/ch5/title2)

#      ..src > go
#        func title(url string) error {
#          resp, err := http.Get(url)
#          if err != nil {
#            return err
#          }
#          defer resp.Body.Close()
#
#          ct := resp.Header.Get("Content-Type")
#          if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
#            return fmt.Errorf("%s has type %s, not text/html", url, ct)
#          }
#
#          doc, err := html.Parse(resp.Body)
#          if err != nil {
#            return fmt.Errorf("parsing %s as HTML: %v", url, err)
#          }
#
#          // ...print doc's title element...
#
#          return nil
#        }
#      < src..
     ..src > go
       func title(url string) error {
         resp, err := http.Get(url)
         if err != nil {
           return err
         }
         defer resp.Body.Close()

         ct := resp.Header.Get("Content-Type")
         if ct != "text/html" && !strings.HasPrefix(ct, "text/html;") {
           return fmt.Errorf("%s has type %s, not text/html", url, ct)
         }

         doc, err := html.Parse(resp.Body)
         if err != nil {
           return fmt.Errorf("parsing %s as HTML: %v", url, err)
         }

         // ...imprimir los elementos title del documento...

         return nil
       }
     < src..

#    The same pattern can be used for other resources beside network connections,
#    for instance to close an open file:
   El mismo patron se puede utilizar para otros recursos ademas de las
   conexiones de red, por ejemplo para cerrar un archivo abierto:

#    ..figure > @c(io/ioutil)
   ..figure > @c(io/ioutil)

#      ..src > go
#        package ioutil
#
#        func ReadFile(filename string) ([]byte, error) {
#          f, err := os.Open(filename)
#          if err != nil {
#            return nil, err
#          }
#          defer f.Close()
#          return ReadAll(f)
#        }
#      < src..
     ..src > go
       package ioutil

       func ReadFile(filename string) ([]byte, error) {
         f, err := os.Open(filename)
         if err != nil {
           return nil, err
         }
         defer f.Close()
         return ReadAll(f)
       }
     < src..


#    or to unlock a mutex (@l(#Section 9.2<>§9.2)):
   o para desbloquear un mutex (@l(#Seccion 9.2<>§9.2)):

#    ..src > go
#      var mu sync.Mutex
#      var m = make(map[string]int)
#
#      func lookup(key string) int {
#        mu.Lock()
#        defer mu.Unlock()
#        return m[key]
#      }
#    < src..
   ..src > go
     var mu sync.Mutex
     var m = make(map[string]int)

     func lookup(key string) int {
       mu.Lock()
       defer mu.Unlock()
       return m[key]
     }
   < src..

#    The @c(defer) statement can also be used to pair @"(on entry) and @"(on exit)
#    actions when debugging a complex function. The @c(bigSlowOperation) function
#    below calls @c(trace) immediately, which does the @"(on entry) action then
#    returns a function value that, when called, does the corresponding @"(on
#    exit) action. By deferring a call to the returned function in this way, we
#    can instrument the entry point and all exit points of a function in a single
#    statement and even pass values, like the @c(start) time, between the two
#    actions. But don’t forget the final parentheses in the @c(defer) statement,
#    or the @"(on entry) action will happen on exit and the on-exit action won’t
#    happen at all!
   La sentencia @c(defer) tambien se puede utilizar para emparejar acciones de
   @"(entrada) y @"(salida) al depurar una funcion compleja. A continuacion la
   funcion @c(bigSlowOperation) llama inmediatamente a @c(trace), lo que la hace
   una accion de @"(entrada) que devuelve un valor de funcion que, cuando se le
   llama, hace la accion de @"(salida).  Al diferir una llamada a la funcion
   devuelta de esta manera, podemos instrumentar el punto de entrada y todos los
   puntos de salida de una funcion en una sola declaracion, e incluso pasar
   valores, como el tiempo de inicion @c(start), entre las dos acciones. Pero no
   se olvide de los parentesis finales en el sentencia @c(defer), o la accion de
   @"(entrada) ocurrira en la salida y la accion en la salida no ocurrira en
   absoluto!

#    ..figure > @l(gopl.io/ch5/trace/main.go<>gopl.io/ch5/trace)
   ..figure > @l(gopl.io/ch5/trace/main.go<>gopl.io/ch5/trace)

#      ..src > go
#        func bigSlowOperation() {
#          defer trace("bigSlowOperation")() // don't forget the extra parentheses
#          // ...lots of work...
#          time.Sleep(10 * time.Second)      // simulate slow operation by sleeping
#        }
#
#        func trace(msg string) func() {
#          start := time.Now()
#          log.Printf("enter %s", msg)
#          return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
#        }
#      < src..
     ..src > go
       func bigSlowOperation() {
         defer trace("bigSlowOperation")() // no olvide los parentesis adicionales
         // ...mucho trabajo...
         time.Sleep(10 * time.Second)      // simula el funcionamiento lento durmiendo
       }

       func trace(msg string) func() {
         start := time.Now()
         log.Printf("enter %s", msg)
         return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
       }
     < src..


#    Each time @c(bigSlowOperation) is called, it logs its entry and exit and the
#    elapsed time between them. (We used @c(time.Sleep) to simulate a slow
#    operation.)
   Cada vez @c(bigSlowOperation) se llama, registra su entrada y salida y el
   tiempo transcurrido entre ellos. (Utilizamos @c(time.Sleep) para simular una
   operacion lenta.)

#    ..src > sh
#      $ go build gopl.io/ch5/trace
#      $ ./trace
#      2015/11/18 09:53:26 enter bigSlowOperation
#      2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s)
#    < src..
   ..src > sh
     $ go build gopl.io/ch5/trace
     $ ./trace
     2015/11/18 09:53:26 enter bigSlowOperation
     2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s)
   < src..

#    Deferred functions run @e(after) return statements have updated the function’s
#    result variables.  Because an anonymous function can access its enclosing
#    function’s variables, including named results, a deferred anonymous function
#    can observe the function’s results.
   Las funciones diferidas se ejecutan despues de las declaraciones de retorno
   han actualizado las variables de resultado de la funcion. Debido a que una
   funcion anonima puede acceder a las variables de su funcion de inclusion,
   incluidos los resultados con nombra, una funcion anonima diferida puede
   observar los resultados de la funcion.

#    Consider the function @c(double):
   Considere la funcion @c(doble):

#    ..src > go
#      func double(x int) int {
#        return x + x
#      }
#    < src..
   ..src > go
     func doble(x int) int {
       return x + x
     }
   < src..

#    By naming its result variable and adding a @c(defer) statement, we can make
#    the function print its arguments and results each time it is called.
   Al nombrar a su variable de resultado y agregar una sentecia @c(defer),
   podemos hacer que la funcion imprimir sus argumentos y resultados cada vez
   que se llame.

#    ..src > go
#      func double(x int) (result int) {
#        defer func() { fmt.Printf("double(%d) = %d\n", x, result) }()
#        return x + x
#      }
#
#      _ = double(4)
#      // Output:
#      // "double(4) = 8"
#    < src..
   ..src > go
     func doble(x int) (resultado int) {
       defer func() { fmt.Printf("doble(%d) = %d\n", x, resultado) }()
       return x + x
     }

     _ = double(4)
     // Salida:
     // "doble(4) = 8"
   < src..

#    This trick is overkill for a function as simple as @c(double) but may be useful
#    in functions with many return statements.
   Este truco es exesivo para una funcion tan simple como @c(doble), pero puede
   ser util en funciones con muchas declaraciones de retorno.

#    A deferred anonymous function can even change the values that the enclosing
#    function returns to its caller:
   Una funcion anonima diferida puede incluso cambiar los valores que la funcion
   devuelve a su interlocutor:

#    ..src > go
#      func triple(x int) (result int) {
#        defer func() { result += x }()
#        return double(x)
#      }
#
#      fmt.Println(triple(4)) // "12"
#    < src..
   ..src > go
     func triple(x int) (result int) {
       defer func() { result += x }()
       return doble(x)
     }

     fmt.Println(triple(4)) // "12"
   < src..

#    Because deferred functions aren’t executed until the very end of a function’s
#    execution, a @c(defer) statement in a loop deserves extra scrutiny. The code
#    below could run out of file descriptors since no file will be closed until
#    all files have been processed:
   Dado que las funciones diferidos no se ejecutan hasta el final de la
   ejecucion de una funcion, una declaracion @c(defer) en un bucle merece un
   escrutinio adicional. El codigo siguiente podria quedar sin los descriptores
   de archivo ya que ningun archivo se cerrara hasta que todos los archivos se
   hayan procesado:

#    ..src > go
#      for _, filename := range filenames {
#        f, err := os.Open(filename)
#        if err != nil {
#          return err
#        }
#        defer f.Close() // NOTE: risky; could run out of file descriptors
#        // ...process f...
#      }
#    < src..
   ..src > go
     for _, filename := range filenames {
       f, err := os.Open(filename)
       if err != nil {
         return err
       }
       defer f.Close() // NOTA: arriesgado; podria quedarse sin los descriptores de archivo
       // ...procesando f...
     }
   < src..

#    One solution is to move the loop body, including the @c(defer) statement,
#    into another function that is called on each iteration.
   Una solucion es mover el cuerpo del bucle, incluyendo la declaracion
   @c(defer), a otra funcion que se llame en cada iteracion.

#    ..src > go
#      for _, filename := range filenames {
#        if err := doFile(filename); err != nil {
#          return err
#        }
#      }
#
#      func doFile(filename string) error {
#        f, err := os.Open(filename)
#        if err != nil {
#          return err
#        }
#        defer f.Close()
#        // ...process f...
#      }
#    < src..
   ..src > go
     for _, filename := range filenames {
       if err := doFile(filename); err != nil {
         return err
       }
     }

     func doFile(filename string) error {
       f, err := os.Open(filename)
       if err != nil {
         return err
       }
       defer f.Close()
       // ...procesando f...
     }
   < src..

#    The example below is an improved @$(fetch) program (@l(#Section 1.5<>§1.5))
#    that writes the HTTP response to a local file instead of to the standard
#    output. It derives the file name from the last component of the URL path,
#    which it obtains using the @c(path.Base) function.
   El siguiente ejemplo es una mejora del programa @$(fetch) (@l(#Seccion
   1.5<>§1.5)) que escribe la respuesta HTTP a un archivo local en lugar de a la
   salida estandar. Deriva el nombre del archivo del el ultimo componente de la
   ruta URL, que obtiene utilizando la funcion @c(path.Base).

#    ..figure > @l(gopl.io/ch5/fetch/main.go<>gopl.io/ch5/fetch)
   ..figure > @l(gopl.io/ch5/fetch/main.go<>gopl.io/ch5/fetch)

#      ..src > go
#        // Fetch downloads the URL and returns the
#        // name and length of the local file.
#        func fetch(url string) (filename string, n int64, err error) {
#          resp, err := http.Get(url)
#          if err != nil {
#            return "", 0, err
#          }
#          defer resp.Body.Close()
#
#          local := path.Base(resp.Request.URL.Path)
#          if local == "/" {
#            local = "index.html"
#          }
#          f, err := os.Create(local)
#          if err != nil {
#            return "", 0, err
#          }
#          n, err = io.Copy(f, resp.Body)
#          // Close file, but prefer error from Copy, if any.
#          if closeErr := f.Close(); err == nil {
#            err = closeErr
#          }
#          return local, n, err
#        }
#      < src..
     ..src > go
       // Fetch descarga la URL y regresa el rombre
       // y la longitud del archivo local.
       func fetch(url string) (filename string, n int64, err error) {
         resp, err := http.Get(url)
         if err != nil {
           return "", 0, err
         }
         defer resp.Body.Close()

         local := path.Base(resp.Request.URL.Path)
         if local == "/" {
           local = "index.html"
         }
         f, err := os.Create(local)
         if err != nil {
           return "", 0, err
         }
         n, err = io.Copy(f, resp.Body)
         // Close file, but prefer error from Copy, if any.
         if closeErr := f.Close(); err == nil {
           err = closeErr
         }
         return local, n, err
       }
     < src..


#    The deferred call to @c(resp.Body.Close) should be familiar by now. It’s
#    tempting to use a second deferred call, to @c(f.Close), to close the local
#    file, but this would be subtly wrong because @c(os.Create) opens a file for
#    writing, creating it as needed. On many file systems, notably NFS, write
#    errors are not reported immediately but may be postponed until the file is
#    closed. Failure to check the result of the close operation could cause
#    serious data loss to go unnoticed.  However, if both @c(io.Copy) and
#    @c(f.Close) fail, we should prefer to report the error from @c(io.Copy) since
#    it occurred first and is more likely to tell us the root cause.
   La llamada diferida a @c(resp.Body.Close) deberia resultar familiar por
   ahora. Es tentador utilizar una segunda llamada diferida, a @c(f.Close), para
   cerrar el archivo local, pero esto seria sutilmente incorrecto porque
   @c(os.Create) abre un archivo para escribir, crear, segun sea necesario. En
   muchos sistemas de archivos, notablemente NFS, los errores de escritura no se
   informan inmediatamente pero se pueden posponer hasta que se cierre el
   archivo. Si no se comprueba el resultado de la operacion de cierre, la
   perdida de datos graves podria pasar desapercibida. Sin embargo, si ambos
   @c(io.Copy) y @c(f.Close) fallan, debemos preferir reportar el error de
   @c(io.Copy) desde que ocurre por primera vez y es mas probable que nos diga
   la causa raiz.

#    @b(Exercise 5.18): Without changing its behavior, rewrite the @c(fetch)
#    function to use @c(defer) to close the writable file.
   @b(Ejercicio 5.18): Sin cambiar su comportamiento, reescriba la funcion
   @c(fetch) utilizando @c(defer) para cerrar el archivo de escritura.

# ** Section 5.9 <> Panic
** Seccion 5.9 <> Panico

#    Go’s type system catches many mistakes at compile time, but others, like an
#    out-of-bounds array access or nil pointer dereference, require checks at run
#    time. When the Go runtime detects these mistakes, it @e(panics).
   El sistema de tipado de Go captura muchos errores en tiempo de compilacion,
   pero otros, como un acceso a un arreglo fuera de limites o una desreferencia
   de puntero nulo, requieren comprobaciones en tiempo de ejecucion. Cuando go
   detecta errores en tiempo de ejecucion, entra en @e(panico).

#    During a typical panic, normal execution stops, all deferred function calls
#    in that goroutine are executed, and the program crashes with a log
#    message. This log message includes the @e(panic value), which is usually an
#    error message of some sort, and, for each goroutine, a @e(stack Trace)
#    showing the stack of function calls that were active at the time of the
#    panic. This log message often has enough information to diagnose the root
#    cause of the problem without running the program again, so it should always
#    be included in a bug report about a panicking program.
   Durante un panico tipico, la ejecucion normal se detiene, todas las llamadas
   de funcion diferida en esa gorutina se ejecutan, y el programa se bloquea con
   un mensaje de registro. Este mensaje de registro incluye el @e(valor de
   panico), que suele ser un mensaje de error de algun tipo, y, para cada
   goroutine, un @e(seguimiento de pila) que muestra la pila de llamadas a
   funciones que estaban activas en el momento del panico. Este mensaje de
   registro a menudo tiene suficiente informacion para diagnosticar la causa
   raiz del problema sin ejecutar el programa de nuevo, por lo que siempre debe
   incluirse en un informe de error acerca de un programa de panico.

#    Not all panics come from the runtime. The built-in @c(panic) function may be
#    called directly ; it accepts any value as an argument. A panic is often the
#    best thing to do when some @"(impossible) situation happens, for instance,
#    execution reaches a case that logically can’t happen:
   No todos los panicos provienen del tiempo de ejecucion. La funcion nativa
   @c(panic) se puede llamar directamente; acepta cualquier valor como
   argumento. Un panico es a menudo lo mejor que puede hacer cuando ocurre
   alguna situacion @"(imposible), por ejemplo, la ejecucion llega a un caso que
   logicamente, no puede suceder:

#    ..src > go
#      switch s := suit(drawCard()); s {
#      case "Spades":   // ...
#      case "Hearts":   // ...
#      case "Diamonds": // ...
#      case "Clubs":    // ...
#      default:
#        panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
#      }
#    < src..
   ..src > go
     switch s := suit(drawCard()); s {
     case "Spades":   // ...
     case "Hearts":   // ...
     case "Diamonds": // ...
     case "Clubs":    // ...
     default:
       panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
     }
   < src..

#    It’s good practice to assert that the preconditions of a function hold, but
#    this can easily be done to excess. Unless you can provide a more informative
#    error message or detect an error sooner, there is no point asserting a
#    condition that the runtime will check for you.
   Es una buena practica afirmar que las precondiciones de una funcion se
   mantienen, pero esto puede hacerse facilmente en exceso. A menos que pueda
   proporcionar un mensaje de error mas informativo o detectar un error antes,
   no tiene sentido afirmar una condicion que el tiempo de ejecucion comprobara
   por usted.

#    ..src > go
#      func Reset(x *Buffer) {
#        if x == nil {
#          panic("x is nil") // unnecessary!
#        }
#        x.elements = nil
#      }
#    < src..
   ..src > go
     func Reset(x *Buffer) {
       if x == nil {
         panic("x is nil") // innecesario!
       }
       x.elements = nil
     }
   < src..

#    Although Go’s panic mechanism resembles exceptions in other languages, the
#    situations in which panic is used are quite different. Since a panic causes
#    the program to crash, it is generally used for grave errors, such as a
#    logical inconsistency in the program; diligent programmers consider any crash
#    to be proof of a bug in their code. In a robust program, @"(expected) errors,
#    the kind that arise from incorrect input, misconfiguration, or failing I/O,
#    should be handled gracefully; they are best dealt with using @c(error)
#    values.
   Aunque el mecanismo de panico de Go se parece a las excepciones de otros
   lenguajes, las situaciones en las que se utiliza el panico son muy
   diferentes. Puesto que un panico hace que el programa se bloquee,
   generalmente se usa para errores graves, como una inconsistencia logica en el
   programa; Los programadores diligentes consideran cualquier accidente como
   prueba de un error en su codigo. En un programa robusto, los errores
   @"(esperados), el tipo que surgen de una entrada incorrecta, mala
   configuracion, o un defecto de E/S, deben manejarse con gracia; se tratan
   mejor con el uso de valores de @c(error).

#    Consider the function @c(regexp.Compile), which compiles a regular expression
#    into an efficient form for matching. It returns an @c(error) if called with
#    an ill-formed pattern, but checking this error is unnecessary and burdensome
#    if the caller knows that a particular call cannot fail. In such cases, it’s
#    reasonable for the caller to handle an error by panicking, since it is
#    believed to be impossible.
   Considere la funcion @c(regexp.Compile), que compila una expresion regular en
   una forma eficiente para la coincidencia. Se devuelve un @c(error) si se
   llama con un patron mal formado, pero la comprobacion de este error es
   innecesaria y onerosa si la persona que llama sabe que una llamada en
   particular no puede fallar. En tales casos, es razonable que el llamador
   maneje un error con un panico, ya que se cree que es imposible.

#    Since most regular expressions are literals in the program source code, the
#    @c(regexp) package provides a wrapper function @c(regexp.MustCompile) that
#    does this check:
   Como la mayoria de las expresiones regulares son literales en el codigo
   fuente del programa, la paquete @c(regexp) proporciona una funcion de
   envoltura @c(regexp.MustCompile) que hace esta comprobacion:

#    ..src > go
#      package regexp
#
#      func Compile(expr string) (*Regexp, error) { /* ... */ }
#
#      func MustCompile(expr string) *Regexp {
#        re, err := Compile(expr)
#        if err != nil {
#          panic(err)
#        }
#        return re
#      }
#    < src..
   ..src > go
     package regexp

     func Compile(expr string) (*Regexp, error) { /* ... */ }

     func MustCompile(expr string) *Regexp {
       re, err := Compile(expr)
       if err != nil {
         panic(err)
       }
       return re
     }
   < src..

#    The wrapper function makes it convenient for clients to initialize a
#    package-level variable with a compiled regular expression, like this:
   La funcion de envoltura hace que sea conveniente para los clientes
   inicializar una variable de nivel de paquete con una expresion regular
   compilada, como esta:

#    ..src > go
#      var httpSchemeRE = regexp.MustCompile(`^https?:`) // "http:" or "https:"
#    < src..
   ..src > go
     var httpSchemeRE = regexp.MustCompile(`^https?:`) // "http:" or "https:"
   < src..

#    Of course, @c(MustCompile) should not be called with untrusted input
#    values. The @c(Must) prefix is a common naming convention for functions of
#    this kind, like @c(template.Must) in @l(#Section 4.6).
   Por supuesto, @c(MustCompile) no debe ser llamada con valores de entrada no
   confiables. El prefijo @c(Must) es una convencion de nomenclatura comun para
   este tipo de funciones, como @c(template.Must) en la @l(#Seccion 4.6).

#    When a panic occurs, all deferred functions are run in reverse order,
#    starting with those of the topmost function on the stack and proceeding up to
#    @c(main), as the program below demonstrates:
   Cuando se produce una situacion de panico, todas las funciones diferidas se
   ejecutan en orden inverso, comenzando con las funciones en lo mas alto de la
   pila y procediendo hasta @c(main), como muestra el siguiente programa:

#    ..figure > @l(gopl.io/ch5/defer1/defer.go<>gopl.io/ch5/defer1)
   ..figure > @l(gopl.io/ch5/defer1/defer.go<>gopl.io/ch5/defer1)

#      ..src > go
#        func main() {
#          f(3)
#        }
#
#        func f(x int) {
#          fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
#          defer fmt.Printf("defer %d\n", x)
#          f(x - 1)
#        }
#      < src..
     ..src > go
       func main() {
         f(3)
       }

       func f(x int) {
         fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
         defer fmt.Printf("defer %d\n", x)
         f(x - 1)
       }
     < src..

#    When run, the program prints the following to the standard output:
   Cuando se ejecuta, el programa imprime lo siguiente en la salida estandar:

#    ..pre >
#      f(3)
#      f(2)
#      f(1)
#      defer 1
#      defer 2
#      defer 3
   ..pre >
     f(3)
     f(2)
     f(1)
     defer 1
     defer 2
     defer 3

#    A panic occurs during the call to @c[f(0)], causing the three deferred calls
#    to @c(fmt.Printf) to run.  Then the runtime terminates the program, printing
#    the panic message and a stack dump to the standard error stream (simplified
#    for clarity):
   Un panico se produce durante la llamada a @c[f(0)], provocando que se
   ejecuten las tres llamadas diferidas a @c(fmt.Printf). A continuacion, el
   tiempo de ejecucion finaliza el programa, imprimiendo el mensaje de panico y
   un volcado de pila en el flujo de error estandar (simplificado para mayor
   claridad):

#    ..pre >
#       panic: runtime error: integer divide by zero
#       main.f(0)
#               src/gopl.io/ch5/defer1/defer.go:14
#       main.f(1)
#               src/gopl.io/ch5/defer1/defer.go:16
#       main.f(2)
#               src/gopl.io/ch5/defer1/defer.go:16
#
#       main.f(3)
#               src/gopl.io/ch5/defer1/defer.go:16
#       main.main()
#               src/gopl.io/ch5/defer1/defer.go:10
#    < pre..
   ..pre >
      panic: runtime error: integer divide by zero
      main.f(0)
              src/gopl.io/ch5/defer1/defer.go:14
      main.f(1)
              src/gopl.io/ch5/defer1/defer.go:16
      main.f(2)
              src/gopl.io/ch5/defer1/defer.go:16

      main.f(3)
              src/gopl.io/ch5/defer1/defer.go:16
      main.main()
              src/gopl.io/ch5/defer1/defer.go:10
   < pre..

#    As we will see soon, it is possible for a function to recover from a panic so
#    that it does not terminate the program.
   Como veremos mas adelante, es posible que una funcion se recupere de un
   panico para que no termine el programa.

#    For diagnostic purposes, the @c(runtime) package lets the programmer dump the
#    stack using the same machinery. By deferring a call to @c(printStack) in
#    @c(main),
   Por propositod de diagnostico, el paquete @c(runtime) permite al programador
   volcar la pila utilizando la misma maquinaria. Al diferir una llamada a
   @c(printStack) en @c(main),

#    ..figure > @l(gopl.io/ch5/defer2/defer.go<>gopl.io/ch5/defer2)
   ..figure > @l(gopl.io/ch5/defer2/defer.go<>gopl.io/ch5/defer2)

#      ..src > go
#        func main() {
#          defer printStack()
#          f(3)
#        }
#
#        func printStack() {
#          var buf [4096]byte
#          n := runtime.Stack(buf[:], false)
#          os.Stdout.Write(buf[:n])
#        }
#      < src..
     ..src > go
       func main() {
         defer printStack()
         f(3)
       }

       func printStack() {
         var buf [4096]byte
         n := runtime.Stack(buf[:], false)
         os.Stdout.Write(buf[:n])
       }
     < src..


#    the following additional text (again simplified for clarity) is printed to
#    the standard output:
   El siguiente texto adicional (simplificado de nuevo para mayor claridad) se
   imprime a la salida estandar:

#    ..pre >
#       goroutine 1 [running]:
#       main.printStack()
#         src/gopl.io/ch5/defer2/defer.go:20
#       main.f(0)
#         src/gopl.io/ch5/defer2/defer.go:27
#       main.f(1)
#         src/gopl.io/ch5/defer2/defer.go:29
#       main.f(2)
#         src/gopl.io/ch5/defer2/defer.go:29
#       main.f(3)
#         src/gopl.io/ch5/defer2/defer.go:29
#       main.main()
#         src/gopl.io/ch5/defer2/defer.go:15
#    < pre..
   ..pre >
      goroutine 1 [running]:
      main.printStack()
        src/gopl.io/ch5/defer2/defer.go:20
      main.f(0)
        src/gopl.io/ch5/defer2/defer.go:27
      main.f(1)
        src/gopl.io/ch5/defer2/defer.go:29
      main.f(2)
        src/gopl.io/ch5/defer2/defer.go:29
      main.f(3)
        src/gopl.io/ch5/defer2/defer.go:29
      main.main()
        src/gopl.io/ch5/defer2/defer.go:15
   < pre..


#    Readers familiar with exceptions in other languages may be surprised that
#    @c(runtime.Stack) can print information about functions that seem to have
#    already been @"(unwound.) Go’s panic mechanism runs the deferred functions
#    @c(before) it unwinds the stack.
   Los lectores familiarizados con excepciones en otros lenguajes pueden
   sorprenderse de que @c(runtime.Stack) pueda imprimir informacion sobre
   funciones que parecen haber sido @"(desenrolladas). El Mecanismo de panico de
   Go ejecuta las funciones diferidos antes de desenrollar la pila.

# ** Section 5.10 <> Recover
** Seccion 5.10 <> Recover

#    Giving up is usually the right response to a panic, but not always. It might
#    be possible to recover in some way, or at least clean up the mess before
#    quitting. For example, a web server that encounters an unexpected problem
#    could close the connection rather than leave the client hanging, and during
#    development, it might report the error to the client too.
   Desistir es generalmente la respuesta correcta a un panico, pero no
   siempre. Podria ser posible recuperarse de alguna manera, o al menos limpiar
   el lio antes de marcharse. Por ejemplo, un servidor web que encuentra un
   problema inesperado podria cerrar la conexion en lugar de dejar al cliente
   colgado y, durante el desarrollo, podria informar el error al cliente
   tambien.

#    If the built-in @c(recover) function is called within a deferred function and
#    the function containing the @c(defer) statement is panicking, @c(recover)
#    ends the current state of panic and returns the panic value. The function
#    that was panicking does not continue where it left off but returns
#    normally. If @c(recover) is called at any other time, it has no effect and
#    returns @c(nil).
   Si la funcion nativa @c(recover) se llama dentro de una funcion diferida y la
   funcion que contiene la sentencia @c(defer) es presa del panico, @c(recover)
   termina el actual estado de panico y devuelve el valor de panico. La funcion
   que estaba en panico no continua donde lo dejo pero devuelve normalmente. Si
   @c(recover) se llama en cualquier otro momento, no tiene ningun efecto y
   devuelve @c(nil).

#    To illustrate, consider the development of a parser for a language. Even when
#    it appears to be working well, given the complexity of its job, bugs may
#    still lurk in obscure corner cases. We might prefer that, instead of
#    crashing, the parser turns these panics into ordinary parse errors, perhaps
#    with an extra message exhorting the user to file a bug report.
   Para ilustrar, considere el desarrollo de un analizador para un
   lenguaje. Incluso cuando parece estar funcionando bien, dada la complejidad
   de su trabajo, los bichos todavia pueden acechar en esquinas
   oscuras. Podriamos preferir que, en lugar de fallar, el analizador convierta
   estos panicos en errores comunes de analisis, quizas con un mensaje extra
   exhortando al usuario a presentar un informe de error.

#    ..src > go
#      func Parse(input string) (s *Syntax, err error) {
#        defer func() {
#          if p := recover(); p != nil {
#            err = fmt.Errorf("internal error: %v", p)
#          }
#        }()
#        // ...parser...
#      }
#    < src..
   ..src > go
     func Parse(input string) (s *Syntax, err error) {
       defer func() {
         if p := recover(); p != nil {
           err = fmt.Errorf("internal error: %v", p)
         }
       }()
       // ...analizador...
     }
   < src..

#    The deferred function in @c(Parse) recovers from a panic, using the panic
#    value to construct an error message; a fancier version might include the
#    entire call stack using @c(runtime.Stack). The deferred function then assigns
#    to the @c(err) result, which is returned to the caller.
   La funcion diferida en @c(Parse) se recupera de una situacion de panico,
   utilizando el valor de panico para construir un mensaje de error; una version
   mas elegante podria incluir toda la pila de llamadas usando @c(runtime.Stack).
   Luego la funcion diferida, asigna @c(err) al resultado, que se devuelve al
   llamador.

#    Recovering indiscriminately from panics is a dubious practice because the
#    state of a package’s variables after a panic is rarely well defined or
#    documented. Perhaps a critical update to a data structure was incomplete, a
#    file or network connection was opened but not closed, or a lock was acquired
#    but not released. Furthermore, by replacing a crash with, say, a line in a
#    log file, indiscriminate recovery may cause bugs to go unnoticed.
   La recuperacion indiscriminada de los panicos es una practica dudosa porque
   el estado de las variables de un paquete despues de un panico raramente esta
   bien definido o documentado. Quizas una actualizacion critica de una
   estructura de datos estaba incompleta, se abrio una conexion de archivo o de
   red pero no se cerro o se obtuvo un bloqueo pero no se libero. Ademas, al
   reemplazar un bloqueo con, por ejemplo, una linea en un archivo de registro,
   la recuperacion indiscriminada puede hacer que los errores pasen
   desapercibidos.

#    Recovering from a panic within the same package can help simplify the
#    handling of complex or unexpected errors, but as a general rule, you should
#    not attempt to recover from another package’s panic. Public APIs should
#    report failures as @c(errors). Similarly, you should not recover from a panic
#    that may pass through a function you do not maintain, such as a
#    caller-provided callback, since you cannot reason about its safety.
   La recuperacion de un panico dentro del mismo paquete puede ayudar a
   simplificar el manejo de errores complejos o inesperados, pero como regla
   general, no debe intentar recuperarse del panico de otro paquete. Las APIs
   publicas deben informar de fallos como @c(errores). Del mismo modo, no debe
   recuperarse de un panico que puede pasar a traves de una funcion que no
   mantiene, como una llamador de devolucion de lllamada, ya que no puede
   razonar sobre su seguridad.

#    For example, the @c(net/http) package provides a web server that dispatches
#    incoming requests to user-provided handler functions. Rather than let a panic
#    in one of these handlers kill the process, the server calls @c(recover),
#    prints a stack trace, and continues serving. This is convenient in practice,
#    but it does risk leaking resources or leaving the failed handler in an
#    unspecified state that could lead to other problems.
   Por ejemplo, el paquete @c(net/http) proporciona un servidor web que envia
   las solicitudes entrantes a funciones de controlador proporcionados por el
   usuario. En lugar de permitir que un panico en uno de estos controladores
   elimine el proceso, el servidor llama a @c(recover), imprime un seguimiento
   de la pila, y sigue atendiendo. Esto es conveniente en la practica, pero se
   corre el riesgo de perder recursos o dejar al manejador fallido en un estado
   no especificado que podria conducir a otros problemas.

#    For all the above reasons, it’s safest to recover selectively if at all. In
#    other words, recover only from panics that were intended to be recovered
#    from, which should be rare. This intention can be encoded by using a
#    distinct, unexported type for the panic value and testing whether the value
#    returned by @c(recover) has that type. (We’ll see one way to do this in the
#    next example.) If so, we report the panic as an ordinary @c(error); if not,
#    we call @c(panic) with the same value to resume the state of panic.
   Por todas las razones anteriores, es mas seguro recuperarse selectivamente si
   es necesario. En otras palabras, recuperar solo de los panicos que estaban
   destinados a ser recuperados, lo que deberia ser raro. Esta intencion puede
   ser codificado mediante el uso de un tipo distinto, sin exportar para el
   valor de panico y probar si el valor devuelto por @c(recover) tiene ese
   tipo. (Veremos una manera de hacer esto en el siguiente ejemplo.) Si es asi,
   el informamos el panico como un error ordinario; si no, que llamamos a
   @c(panic) con el mismo valor para reanudar el estado de panico.

#    The example below is a variation on the @$(title) program that reports an
#    error if the HTML document contains multiple @c(<title>) elements. If so, it
#    aborts the recursion by calling @c(panic) with a value of the special type
#    @c(bailout).
   El ejemplo siguiente es una variacion sobre el programa @$(title) que informa
   de un error si el documento HTML contiene multiples elementos @c(<title>). Si
   es asi, se aborta la recursividad llamando a @c(panic) con un valor del tipo
   especial @c(bailout).

#    ..figure > @l(gopl.io/ch5/title3/title.go<>gopl.io/ch5/title3)
   ..figure > @l(gopl.io/ch5/title3/title.go<>gopl.io/ch5/title3)

#      ..src > go
#        // soleTitle returns the text of the first non-empty title element
#        // in doc, and an error if there was not exactly one.
#        func soleTitle(doc *html.Node) (title string, err error) {
#          type bailout struct{}
#
#          defer func() {
#            switch p := recover(); p {
#            case nil:
#              // no panic
#            case bailout{}:
#              // "expected" panic
#              err = fmt.Errorf("multiple title elements")
#            default:
#              panic(p) // unexpected panic; carry on panicking
#            }
#          }()
#
#          // Bail out of recursion if we find more than one non-empty title.
#          forEachNode(doc, func(n *html.Node) {
#            if n.Type == html.ElementNode && n.Data == "title" &&
#              n.FirstChild != nil {
#              if title != "" {
#                panic(bailout{}) // multiple title elements
#              }
#              title = n.FirstChild.Data
#            }
#          }, nil)
#          if title == "" {
#            return "", fmt.Errorf("no title element")
#          }
#          return title, nil
#        }
#      < src..
     ..src > go
       // soleTitle regresa el siguiente texto del primer elemento title no vacio
       // en doc, y un error si no existiera exactamente uno.
       func soleTitle(doc *html.Node) (title string, err error) {
         type bailout struct{}

         defer func() {
           switch p := recover(); p {
           case nil:
             // sin panico
           case bailout{}:
             // panico "esperado"
             err = fmt.Errorf("multiple title elements")
           default:
             panic(p) // panico inersperado; continuar el panico
           }
         }()

         // Bail out de recursion si encontramos mas de un titulo no vacio.
         forEachNode(doc, func(n *html.Node) {
           if n.Type == html.ElementNode && n.Data == "title" &&
             n.FirstChild != nil {
             if title != "" {
               panic(bailout{}) // multiples elementos titulo
             }
             title = n.FirstChild.Data
           }
         }, nil)
         if title == "" {
           return "", fmt.Errorf("no title element")
         }
         return title, nil
       }
     < src..


#    The deferred handler function calls @c(recover), checks the panic value, and
#    reports an ordinary error if the value was @c(bailout{}). All other non-nil
#    values indicate an unexpected panic, in which case the handler calls
#    @c(panic) with that value, undoing the effect of @c(recover) and resuming the
#    original state of panic. (This example does somewhat violate our advice about
#    not using panics for @"(expected) errors, but it provides a compact
#    illustration of the mechanics.)
   La funcion diferida que llama a @c(recover), comprueba el valor de panico, e
   informa de un error ordinario si el valor era @c(bailout{}). Todos los demas
   valores no nulos indican un panico inesperados, en cuyo caso el controlador
   llama a @c(panic) con ese valor, deshace el efecto de @c(recover) y reanuda
   el estado original de panico. (Este ejemplo viola algo nuestro consejo acerca
   de no usar panicos para errores @"(esperados), pero proporciona una
   ilustracion compacta de la mecanica).

#    From some conditions there is no recovery. Running out of memory, for
#    example, causes the Go runtime to terminate the program with a fatal error.
   De algunas condiciones no hay recuperacion. La falta de memoria, por ejemplo,
   provoca en tiempo de ejecucion que el programa termine con un error grave.

#    @b(Exercise 5.19): Use @c(panic) and @c(recover) to write a function that
#    contains no @c(return) statement yet returns a non-zero value.
   @b(Ejercicio 5.19): Utilice @c(panic) y @c(recover) para escribir una funcion
   que no contenga ninguna sentencia @c(return) y devuelva un valor distinto de
   cero.

# * Chapter 6 <> Methods
* Capitulo 6 <> Metodos

#   Since the early 1990s, object-oriented programming (OOP) has been the dominant
#   programming paradigm in industry and education, and nearly all widely used
#   languages developed since then have included support for it. Go is no
#   exception.
  Desde principios de los noventa, la programacion orientada a objetos (OOP) ha
  sido el paradigma de programacion dominante en la industria y la educacion, y
  casi todos las lenguajes ampliamente utilizadas desarrolladas desde entonces
  han incluido el soporte para ello. Go no es una excepcion.

#   Although there is no universally accepted definition of object-oriented
#   programming, for our purposes, an @e(object) is simply a value or variable
#   that has methods, and a @e(method) is a function associated with a particular
#   type. An object-oriented program is one that uses methods to express the
#   properties and operations of each data structure so that clients need not
#   access the object’s representation directly.
  Aunque no existe una definicion universalmente aceptada de la programacion
  orientada a objetos, para nuestros propositos, un @e(objeto) es simplemente un
  valor o variable que tiene metodos, y un metodo es una funcion asociada a un
  tipo particular. Un programa orientado a objetos es aquel que utiliza metodos
  para expresar las propiedades y operaciones de cada estructura de datos de
  modo que los clientes no necesitan acceder directamente a la representacion
  del objeto.

#   In earlier chapters, we have made regular use of methods from the standard
#   library, like the @c(Seconds) method of type @c(time.Duration):
  En los capitulos anteriores, hemos hecho uso regular de metodos de la libreria
  estandar, como el metodo @c(Seconds) del tipo @c(time.Duration):

#   ..src > go
#     const day = 24 * time.Hour
#     fmt.Println(day.Seconds()) // "86400"
#   < src..
  ..src > go
    const day = 24 * time.Hour
    fmt.Println(day.Seconds()) // "86400"
  < src..

#   and we defined a method of our own in @l(#Section 2.5), a @c(String) method
#   for the @c(Celsius) type:
  y definimos un metodo de propia en la @l(#Seccion 2.5), una metodo @c(String)
  para el Tipo @c(Celsius):

#   ..src > go
#     func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
#   < src..
  ..src > go
    func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
  < src..

#   In this chapter, the first of two on object-oriented programming, we’ll show
#   how to define and use methods effectively. We’ll also cover two key principles
#   of object-oriented programming, @e(encapsulation) and @e(composition).
  En este capitulo, el primero de dos en la programacion orientada a objetos,
  mostraremos como definir y utilizar metodos de manera eficaz. Tambien vamos a
  cubrir dos principios fundamentales de la programacion orientada a objetos,
  encapsulacion y composicion.

# ** Section 6.1 <> Method Declarations
** Seccion 6.1 <> Declaracion de Metodos

#    A method is declared with a variant of the ordinary function declaration in
#    which an extra parameter appears before the function name. The parameter
#    attaches the function to the type of that parameter.
   Se declara un metodo con una variante de la declaracion de funcion ordinaria
   en la que aparece un parametro extra antes del nombre de la funcion. El
   parametro asigna la funcion al tipo de ese parametro.

#    Let’s write our first method in a simple package for plane geometry:
   Vamos a escribir nuestro primer metodo en un simple paquete de geometria
   plana:

#    ..figure > @l(gopl.io/ch6/geometry/geometry.go<>gopl.io/ch6/geometry)
   ..figure > @l(gopl.io/ch6/geometry/geometry.go<>gopl.io/ch6/geometry)

#      ..src > go
#        package geometry
#
#        import "math"
#
#        type Point struct{ X, Y float64 }
#
#        // traditional function
#        func Distance(p, q Point) float64 {
#          return math.Hypot(q.X-p.X, q.Y-p.Y)
#        }
#
#        // same thing, but as a method of the Point type
#        func (p Point) Distance(q Point) float64 {
#          return math.Hypot(q.X-p.X, q.Y-p.Y)
#        }
#      < src..
     ..src > go
       package geometria

       import "math"

       type Punto struct{ X, Y float64 }

       // funcion tradicional
       func Distancia(p, q Punto) float64 {
         return math.Hypot(q.X-p.X, q.Y-p.Y)
       }

       // lo mismo, pero como un metodo del tipo Punto
       func (p Punto) Distancia(q Punto) float64 {
         return math.Hypot(q.X-p.X, q.Y-p.Y)
       }
     < src..

#    The extra parameter @c(p) is called the method’s @e(receiver), a legacy from
#    early object-oriented languages that described calling a method as @"(sending
#    a message to an object.)
   El parametro extra @c(p) se denomina el @e(receptor) del metodo, un legado de
   los primeros lenguajes orientados a objetos que describen la llamada a un
   metodo como @"(el envio de un mensaje a un objeto).

#    In Go, we don’t use a special name like @c(this) or @c(self) for the
#    receiver; we choose receiver names just as we would for any other
#    parameter. Since the receiver name will be frequently used, it’s a good idea
#    to choose something short and to be consistent across methods. A common
#    choice is the first letter of the type name, like @c(p) For @c(Point).
   En Go, no utilizamos un nombre especial como @c(this) o @c(self) para el
   receptor; Elegimos los nombres de los receptores tal como lo hariamos para
   cualquier otro parametro. Pusto que el nombre del receptor se utilizara con
   frecuencia, es una buena idea elegir algo corto y ser coherente entre los
   metodos. Una opcion comun es la primer letra del nombre del tipo, como @c(p)
   por @c(Point).

#    In a method call, the receiver argument appears before the method name. This
#    parallels the declaration, in which the receiver parameter appears before the
#    method name.
   En una llamada al metodo, el argumento del receptor aparece antes del nombre
   del metodo. Esto es paralelo a la declaracion, en la que el parametro del
   receptor aparece antes del nombre del metodo.

#    ..src > go
#      p := Point{1, 2}
#      q := Point{4, 6}
#      fmt.Println(Distance(p, q)) // "5", function call
#      fmt.Println(p.Distance(q))  // "5", method call
#    < src..
   ..src > go
     p := Punto{1, 2}
     q := Punto{4, 6}
     fmt.Println(Distancia(p, q)) // "5", llamada a funcion
     fmt.Println(p.Distancia(q))  // "5", llamada a metodo
   < src..

#    There’s no conflict between the two declarations of functions called
#    @c(Distance) above. The first declares a package-level function called
#    @c(geometry.Distance). The second declares a method of the type @c(Point), so
#    its name is @c(Point.Distance).
   No hay conflicto entre las dos declaraciones de funcion llamadas @c(Distancia)
   anteriores. La primera declara una funcion de nivel paquete llamada
   @c(geometria.Distancia). La segunda declara un procedimiento del tipo @c(Punto), por
   lo que su nombre es @c(Punto.Distancia).

#    The expression @c(p.Distance) is called a @e(selector), because it selects
#    the appropriate @c(Distance) method for the receiver @c(p) of type
#    @c(Point). Selectors are also used to select fields of struct types, as in
#    @c(p.X). Since methods and fields inhabit the same name space, declaring a
#    method @c(X) on the struct type @c(Point) would be ambiguous and the compiler
#    will reject it.
   La expresion @c(p.Distancia) se denomina un @e(selector), porque selecciona
   el metodo apropiado @c(Distancia) para el receptor @c(p) de tipo @c(Punto).
   Los selectores tambien se utilizan para seleccionar los campos de un tipo
   estructura, como en @c(p.X). Dado que los metodos y campos habitan el mismo
   espacio de nombres, si declara un metodo @c(X) para el tipo de estructura
   @c(Punto) seria ambiguo y el compilador lo rechazara.

#    Since each type has its own name space for methods, we can use the name
#    @c(Distance) for other methods so long as they belong to different
#    types. Let’s define a type @c(Path) that represents a sequence of line
#    segments and give it a @c(Distance) method too.
   Debido a que cada tipo tiene su propio espacio de nombres para los metodos,
   podemos usar el nombre @c(Distancia) para otros metodos, siempre y cuando
   pertenecen a diferentes tipos. Vamos a definir un tipo @c(Ruta) que
   representa una secuencia de segmentos de linea y a darle un metodo
   @c(Distancia) tambien.

#    ..src > go
#      // A Path is a journey connecting the points with straight lines.
#      type Path []Point
#
#      // Distance returns the distance traveled along the path.
#      func (path Path) Distance() float64 {
#        sum := 0.0
#        for i := range path {
#          if i > 0 {
#            sum += path[i-1].Distance(path[i])
#          }
#        }
#        return sum
#      }
#    < src..
   ..src > go
     // Una Ruta es un caminoA que conecta los puntos con lineas reactas.
     type Ruta []Punto

     // Distancia devuelve la distancia recorrida a lo largo de la Ruta.
     func (ruta Ruta) Distancia() float64 {
       sum := 0.0
       for i := range ruta {
         if i > 0 {
           sum += ruta[i-1].Distancia(ruta[i])
         }
       }
       return sum
     }
   < src..

#    @c(Path) is a named slice type, not a struct type like @c(Point), yet we can
#    still define methods for it.  In allowing methods to be associated with any
#    type, Go is unlike many other object-oriented languages. It is often
#    convenient to define additional behaviors for simple types such as numbers,
#    strings, slices, maps, and sometimes even functions. Methods may be declared
#    on any named type defined in the same package, so long as its underlying type
#    is neither a pointer nor an interface.
   @c(Ruta) es un tipo de slice con nombre, no un tipo de estructura como
   @c(Punto), sin embargo, podemos definir metodos para el. Al permitir que los
   metodos se asocien con cualquier tipo, Go es diferente de muchos otros
   lenguajes orientados a objetos. A menudo es conveniente definir
   comportamientos adicionales para tipos simples como numeros, cadenas, slices,
   mapas, y a veces, incluso funciones. Los metodos pueden ser declarados en
   cualquier tipo con nombre definido en el mismo paquete, siempre y cuando su
   tipo subyacente no sea un puntero ni una interfaz.

#    The two @c(Distance) methods have different types. They’re not related to
#    each other at all, though @c(Path.Distance) uses @c(Point.Distance)
#    internally to compute the length of each segment that connects adjacent
#    points.
   Las dos metodos @c(Distancia) tienen diferentes tipos. No estan relacionados
   entre si en absoluto, aunque @c(Ruta.Distancia) utiliza a @c(Punto.Distancia)
   internamente para calcular la longitud de cada segmento que une los puntos
   adyacentes.

#    Let’s call the new method to compute the perimeter of a right triangle:
   Vamos a llamar al nuevo metodo para calcular el perimetro de un triangulo
   rectangulo:

#    ..cols >
   ..cols >

#      ..src > go
#        perim := Path{
#          {1, 1},
#          {5, 1},
#          {5, 4},
#          {1, 1},
#        }
#        fmt.Println(perim.Distance()) // "12"
#      < src..
     ..src > go
       perim := Ruta{
         {1, 1},
         {5, 1},
         {5, 4},
         {1, 1},
       }
       fmt.Println(perim.Distancia()) // "12"
     < src..

#      ::
     ::

#      ..img > img/perim.Distance.jpg
     ..img > img/perim.Distance.jpg


#    In the two calls above to methods named @c(Distance), the compiler determines
#    which function to call based on both the method name and the type of the
#    receiver. In the first, @c(path[i-1]) has type @c(Point) so
#    @c(Point.Distance) is called; in the second, @c(perim) has type @c(Path), so
#    @c(Path.Distance) is called.
   En las dos llamadas anterior a metodos con nombre @c(Distancia), el
   compilador determina que funcion debe llamar basandose tanto en el nombre del
   metodo y el tipo de receptor. En el primero, @c(ruta[i-1]) tiene tipo
   @c(Punto), asi que se llama a @c(Punto.Distancia); en el segundo, @c(perim)
   tiene el tipo Ruta, por lo que se llama a @c(Ruta.Distancia).

#    All methods of a given type must have unique names, but different types can
#    use the same name for a method, like the @c(Distance) methods for @c(Point)
#    and @c(Path); there’s no need to qualify function names (for example,
#    @c(PathDistance)) to disambiguate. Here we see the first benefit to using
#    methods over ordinary functions: method names can be shorter. The benefit is
#    magnified for calls originating outside the package, since they can use the
#    shorter name @e(and) omit the package name:
   Todos los metodos de un tipo dado deben tener nombres unicos, pero diferentes
   tipos pueden utilizar el mismo nombre para un metodo, al igual que los
   metodos @c(Distancia) para @c(Punto) y @c(Ruta); no hay necesidad de
   calificar los nombres de funcion (por ejemplo, @c(RutaDistancia)) para
   eliminar la ambigüedad. Aqui vemos el primer beneficio al usar metodos sobre
   funciones ordinarias: los nombres de metodos pueden ser mas cortos. El
   beneficio se magnifica para las llamadas que se originan fuera del paquete,
   ya que pueden utilizar el nombre mas corto y omitir el nombre del paquete:

#    ..src > go
#      import "gopl.io/ch6/geometry"
#
#      perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}}
#      fmt.Println(geometry.PathDistance(perim)) // "12", standalone function
#      fmt.Println(perim.Distance())             // "12", method of geometry.Path
#    < src..
   ..src > go
     import "gopl.io/ch6/geometry"

     perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}}
     fmt.Println(geometry.PathDistance(perim)) // "12", funcion independiente
     fmt.Println(perim.Distance())             // "12", metodo de geometry.Path
   < src..

# ** Section 6.2 <> Methods with a Pointer Receiver
** Seccion 6.2 <> Metodos con un Receptor de Puntero

#    Because calling a function makes a copy of each argument value, if a function
#    needs to update a variable, or if an argument is so large that we wish to
#    avoid copying it, we must pass the address of the variable using a
#    pointer. The same goes for methods that need to update the receiver variable:
#    we attach them to the pointer type, such as @c(*Point).
   Ya que llamar a una funcion crea una copia de cada valor de argumento, si una
   funcion necesita actualizar una variable, o si un argumento es tan grande que
   queremos evitar copiarlo, debemos pasar la direccion de la variable usando un
   puntero. Lo mismo ocurre con los metodos que necesitan actualizar la variable
   del receptor: los adjudicamos al tipo como puntero, como @c(*Point).

#    ..src > go
#      func (p *Point) ScaleBy(factor float64) {
#        p.X *= factor
#        p.Y *= factor
#      }
#    < src..
   ..src > go
     func (p *Point) ScaleBy(factor float64) {
       p.X *= factor
       p.Y *= factor
     }
   < src..

#    The name of this method is @c[(*Point).ScaleBy]. The parentheses are
#    necessary ; without them, the expression would be parsed as
#    @c[*(Point.ScaleBy)].
   El nombre de este metodo es @c[(*Point).ScaleBy]. Los parentesis son necesarios;
   sin ellos, la expresion se analiza como @c[*(Point.ScaleBy)].

#    In a realistic program, convention dictates that if any method of @c(Point)
#    has a pointer receiver, then @e(all) methods of @c(Point) should have a
#    pointer receiver, even ones that don’t strictly need it.  We’ve broken this
#    rule for @c(Point) so that we can show both kinds of method.
   En un programa realista, la convencion dicta que si cualquier metodo de
   @c(Point) tiene un receptor puntero, entonces todos los metodos de @c(Point)
   deben tener un receptor puntero, incluso los que no lo necesitan
   estrictamente. Hemos roto esta regla para @c(Point) de modo que podamos
   mostrar ambos tipos de metodo.

#    Named types (@c(Point)) and pointers to them @c[(*Point)] are the only types
#    that may appear in a receiver declaration. Furthermore, to avoid ambiguities,
#    method declarations are not permitted on named types that are themselves
#    pointer types:
   Tipos con nombre (@c(Point)) y punteros a ellos @c[(*Point)] son los unicos
   tipos que pueden aparecer en una declaracion receptor. Ademas, para evitar
   ambigüedades, las declaraciones de metodos no estan permitidas en tipos con
   nombre que son ellos mismos tipos de puntero:

#    ..src > go
#      type P *int
#      func (P) f() { /* ... */ } // compile error: invalid receiver type
#    < src..
   ..src > go
     type P *int
     func (P) f() { /* ... */ } // error de compilacion: tipo de receptor invalido
   < src..

#    The @c[(*Point).ScaleBy] method can be called by providing a @c(*Point)
#    receiver, like this:
   El metodo @c[(*Point).ScaleBy] se puede llamar al proporcionar un receptor
   @c(*Point), asi:

#    ..src > go
#      r := &Point{1, 2}
#      r.ScaleBy(2)
#      fmt.Println(*r) // "{2, 4}"
#    < src..
   ..src > go
     r := &Point{1, 2}
     r.ScaleBy(2)
     fmt.Println(*r) // "{2, 4}"
   < src..

#    or this:
   o asi:

#    ..src > go
#      p := Point{1, 2}
#      pptr := &p
#      pptr.ScaleBy(2)
#      fmt.Println(p) // "{2, 4}"
#    < src..
   ..src > go
     p := Point{1, 2}
     pptr := &p
     pptr.ScaleBy(2)
     fmt.Println(p) // "{2, 4}"
   < src..

#    or this:
   o asi:

#    ..src > go
#      p := Point{1, 2}
#      (&p).ScaleBy(2)
#      fmt.Println(p) // "{2, 4}"
#    < src..
   ..src > go
     p := Point{1, 2}
     (&p).ScaleBy(2)
     fmt.Println(p) // "{2, 4}"
   < src..

#    But the last two cases are ungainly. Fortunately, the language helps us
#    here. If the receiver @c(p) is a @e(variable) of type @c(Point) but the
#    method requires a @c(*Point) receiver, we can use this shorthand:
   Pero los dos ultimos casos son desagradables. Afortunadamente, el lenguaje
   nos ayuda aqui. Si el receptor @c(p) es una variable de tipo @c(Point), pero
   el metodo requiere un receptor @c(*Point), podemos emplear esta abreviatura:

#    ..src > go
#      p.ScaleBy(2)
#    < src..
   ..src > go
     p.ScaleBy(2)
   < src..

#    and the compiler will perform an implicit @c(&p) on the variable. This works
#    only for variables, including struct fields like @c(p.X) and array or slice
#    elements like @c(perim[0]). We cannot call a @c(*Point) method on a
#    non-addressable @c(Point) receiver, because there’s no way to obtain the
#    address of a temporary value.
   y el compilador realizara un @c(&p) implicito sobre la variable. Esto solo
   funciona para las variables, incluyendo los campos de la estructura como
   @c(p.X) y elementos de la arreglo o slice como @c(perim[0]). No podemos
   llamar a un metodo @c(*Point) en un receptor @c(Point) no direccionable,
   porque no hay manera de obtener la direccion de un valor temporal.

#    ..src > go
#      Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
#    < src..
   ..src > go
     Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
   < src..

#    But we @e(can) call a @c(Point) method like @c(Point.Distance) with a
#    @c(*Point) receiver, because there is a way to obtain the value from the
#    address: just load the value pointed to by the receiver. The compiler inserts
#    an implicit @c(*) operation for us. These two function calls are equivalent:
   Sin embargo, podemos llamar a un metodo @c(Point) como @c(Point.Distance) con
   un receptor @c(*Point), porque hay una manera de obtener el valor de la
   direccion: solo tiene que cargar el valor apuntado por el receptor. El
   compilador inserta una operacion @c(*) implicita por nosotros. Estas dos
   llamadas de funcion son equivalentes:

#    ..src > go
#      pptr.Distance(q)
#      (*pptr).Distance(q)
#    < src..
   ..src > go
     pptr.Distance(q)
     (*pptr).Distance(q)
   < src..

#    Let’s summarize these three cases again, since they are a frequent point of
#    confusion. In every valid method call expression, exactly one of these three
#    statements is true.
   Vamos a resumir estos tres casos de nuevo, ya que son un punto frecuente de
   confusion. En cada expresion de llamada de metodo valida, exactamente una de
   estas tres sentencias es verdadera.

#    Either the receiver argument has the same type as the receiver parameter, for
#    example both have type @c(T) or both have type @c(*T):
   O bien el argumento receptor tiene el mismo tipo que el parametro del
   receptor, por ejemplo ambos tienen tipo @c(T) o ambos tienen tipo @c(*T):

#    ..src > go
#      Point{1, 2}.Distance(q) //  Point
#      pptr.ScaleBy(2)         // *Point
#    < src..
   ..src > go
     Point{1, 2}.Distance(q) //  Point
     pptr.ScaleBy(2)         // *Point
   < src..

#    Or the receiver argument is a @e(variable) of type @c(T) and the receiver
#    parameter has type @c(*T). The compiler implicitly takes the address of the
#    variable:
   O el argumento de receptor es una variable de tipo @c(T) y el parametro receptor
   tiene tipo @c(*T). El compilador toma implicitamente la direccion de la
   variable:

#    ..src > go
#      p.ScaleBy(2) // implicit (&p)
#    < src..
   ..src > go
     p.ScaleBy(2) // implicit (&p)
   < src..

#    Or the receiver argument has type @c(*T) and the receiver parameter has type
#    @c(T). The compiler implicitly dereferences the receiver, in other words,
#    loads the value:
   O el argumento receptor tiene tipo @c(*T) y el parametro receptor tiene tipo
   @c(T). El compilador dereferencia implicitamente al receptor, en otras
   palabras, carga el valor:

#    ..src > go
#      pptr.Distance(q) // implicit (*pptr)
#    < src..
   ..src > go
     pptr.Distance(q) // implicit (*pptr)
   < src..

#    If all the methods of a named type @c(T) have a receiver type of @c(T) itself
#    (not @c(*T)), it is safe to copy instances of that type; calling any of its
#    methods necessarily makes a copy. For example, @c(time.Duration) values are
#    liberally copied, including as arguments to functions. But if any method has
#    a pointer receiver, you should avoid copying instances of @c(T) because doing
#    so may violate internal invariants. For example, copying an instance of
#    @c(bytes.Buffer) would cause the original and the copy to alias (@l(#Section
#    2.3.2<>§2.3.2)) the same underlying array of bytes. Subsequent method calls
#    would have unpredictable effects.
   Si todos los metodos de un tipo con nombre @c(T) tienen un tipo de receptor
   @c(T) en si (no @c(*T)), es seguro copiar las instancias de ese tipo; Llamar
   a cualquiera de sus metodos necesariamente hace una copia. Por ejemplo, los
   valores @c(time.Duration) se copian liberalmente, incluyendo como argumentos
   a las funciones. Pero si cualquier metodo tiene un receptor de puntero, se
   debe evitar copiar instancas de @c(T), ya que hacerlo puede violar
   invariantes internos. Por ejemplo, copiar una instancia de @c(bytes.Buffer)
   haria que el original y la copia como alias (@l(#Seccion 2.3.2<>§2.3.2))
   tubieran el mismo arreglo subyacente de bytes. Las llamadas de metodo
   subsiguientes tendrian efectos impredecibles.

# *** Section 6.2.1 <> Nil Is a Valid Receiver Value
*** Seccion 6.2.1 <> Nil es un Valor de Receptor Valido

#     Just as some functions allow nil pointers as arguments, so do some methods
#     for their receiver, especially if @c(nil) is a meaningful zero value of the
#     type, as with maps and slices. In this simple linked list of integers,
#     @c(nil) represents the empty list:
    Al igual que algunas funciones permiten punteros nulos como argumentos,
    tambien lo hacen algunos metodos para su receptor, especialmente si @c(nil)
    es un valor cero significativo del tipo, al igual que con los mapas y los
    slices. En esta sencilla lista enlazada de numeros enteros, @c(nil)
    representa la lista vacia:

#     ..src > go
#       // An IntList is a linked list of integers.
#       // A nil *IntList represents the empty list.
#       type IntList struct {
#         Value int
#         Tail *IntList
#       }
#
#       // Sum returns the sum of the list elements.
#       func (list *IntList) Sum() int {
#         if list == nil {
#           return 0
#         }
#         return list.Value + list.Tail.Sum()
#       }
#     < src..
    ..src > go
      // Un IntList es una lista enlazada de enteros.
      // Un nil *IntList representa la lista vacia.
      type IntList struct {
        Value int
        Tail *IntList
      }

      // Sum regresa la suma de la lista de elementos.
      func (list *IntList) Sum() int {
        if list == nil {
          return 0
        }
        return list.Value + list.Tail.Sum()
      }
    < src..

#     When you define a type whose methods allow @c(nil) as a receiver value, it’s
#     worth pointing this out explicitly in its documentation comment, as we did
#     above.
    Cuando se define un tipo cuyos metodos permiten @c(nil) como valor receptor,
    vale la pena señalar esto explicitamente en su comentario de documentacion,
    como lo hicimos arriba.

#     Here’s part of the definition of the @c(Values) type from the @c(net/url)
#     package:
    Aqui esta parte de la definicion del tipo @c(Values) del paquete @c(net/url):

#     ..figure > @c(net/url)
    ..figure > @c(net/url)

#       ..src > go
#         package url
#
#         // Values maps a string key to a list of values.
#         type Values map[string][]string
#
#         // Get returns the first value associated with the given key,
#         // or "" if there are none.
#         func (v Values) Get(key string) string {
#           if vs := v[key]; len(vs) > 0 {
#             return vs[0]
#           }
#           return ""
#         }
#
#         // Add adds the value to key.
#         // It appends to any existing values associated with key.
#         func (v Values) Add(key, value string) {
#           v[key] = append(v[key], value)
#         }
#       < src..
      ..src > go
        package url

        // Values map asigna clave de cadena a una lista de valores.
        type Values map[string][]string

        // Get devuelve el primer valor asociado con la clave dada,
        // o "" si no hay nada.
        func (v Values) Get(key string) string {
          if vs := v[key]; len(vs) > 0 {
            return vs[0]
          }
          return ""
        }

        // Add agrega el valor a la clave.
        // Se añade a cualquier valor existente asociado con la clave.
        func (v Values) Add(key, value string) {
          v[key] = append(v[key], value)
        }
      < src..


#     It exposes its representation as a map but also provides methods to simplify
#     access to the map, whose values are slices of strings—it’s a @e(multimap).
#     Its clients can use its intrinsic operators (@c(make), slice literals,
#     @c(m[key]), and so on), or its methods, or both, as they prefer:
    Expone su representacion como un mapa, pero tambien proporciona metodos para
    simplificar el acceso al mapa, cuyos valores son slices de cadenas–es un
    @e(mapa multiple). Sus clientes pueden utilizar sus operadores intrinsecos
    (@c(make), slice literales, @c(m[key]), etc.), o sus metodos, o ambos, como
    prefiera:

#     ..figure > @l(gopl.io/ch6/urlvalues/main.go<>gopl.io/ch6/urlvalues)
    ..figure > @l(gopl.io/ch6/urlvalues/main.go<>gopl.io/ch6/urlvalues)

#       ..src > go
#         m := url.Values{"lang": {"en"}} // direct construction
#         m.Add("item", "1")
#         m.Add("item", "2")
#
#         fmt.Println(m.Get("lang")) // "en"
#         fmt.Println(m.Get("q"))    // ""
#         fmt.Println(m.Get("item")) // "1"      (first value)
#         fmt.Println(m["item"])     // "[1 2]"  (direct map access)
#
#         m = nil
#         fmt.Println(m.Get("item")) // ""
#         m.Add("item", "3")         // panic: assignment to entry in nil map
#       < src..
      ..src > go
        m := url.Values{"lang": {"en"}} // construccion directa
        m.Add("item", "1")
        m.Add("item", "2")

        fmt.Println(m.Get("lang")) // "en"
        fmt.Println(m.Get("q"))    // ""
        fmt.Println(m.Get("item")) // "1"      (primer valor)
        fmt.Println(m["item"])     // "[1 2]"  (acceso directo al mapa)

        m = nil
        fmt.Println(m.Get("item")) // ""
        m.Add("item", "3")         // panico: asignacion a ingresar en un mapa nil
      < src..


#     In the final call to @c(Get), the @c(nil) receiver behaves like an empty map. We
#     could equivalently have written it as @c[Values(nil).Get("item"))], but
#     @c[nil.Get("item")] will not compile because the type of @c(nil) has not
#     been determined. By contrast, the final call to @c(Add) panics as it tries
#     to update a nil map.
    En la llamada final a @c(Get), el receptor @c(nil) se comporta como un mapa
    vacio. Podriamos haberlo escrito como @c[Values(nil).Get("item")], pero
    @c[nil.Get("item")] no se compilara porque el tipo @c(nil) no se ha
    determinado. Por el contrario, la llamada final a @c(Add) proboca un panico,
    ya que trata de actualizar un mapa nil.

#     Because @c(url.Values) is a map type and a map refers to its key/value pairs
#     indirectly, any updates and deletions that @c(url.Values.Add) makes to the
#     map elements are visible to the caller. However, as with ordinary functions,
#     any changes a method makes to the reference itself, like setting it to
#     @c(nil) or making it refer to a different map data structure, will not be
#     reflected in the caller.
    Debido a que @c(url.Values) es un tipo de mapa y un mapa se refiere a sus
    pares clave/valor indirectamente, las actualizaciones y supresiones que
    @c(url.Values.Add) hace a los elementos del mapa son visibles para el
    llamador. Sin embargo, al igual que con las funciones ordinarias, los
    cambios que un metodo hace a la propia referencia, como establecerlo en
    @c(nil) o hacer que se refiera a una estructura de mapa de datos diferente,
    no se reflejaran en el llamador.

# ** Section 6.3 <> Composing Types by Struct Embedding
** Seccion 6.3 <> Composicion de Tipos por Estructuras Enbebidas

#    Consider the type @c(ColoredPoint):
   Considere el tipo @c(ColoredPoint):

#    ..figure > @l(gopl.io/ch6/coloredpoint/main.go<>gopl.io/ch6/coloredpoint)
   ..figure > @l(gopl.io/ch6/coloredpoint/main.go<>gopl.io/ch6/coloredpoint)

#      ..src > go
#        import "image/color"
#
#        type Point struct{ X, Y float64 }
#
#        type ColoredPoint struct {
#          Point
#          Color color.RGBA
#        }
#      < src..
     ..src > go
       import "image/color"

       type Point struct{ X, Y float64 }

       type ColoredPoint struct {
         Point
         Color color.RGBA
       }
     < src..


#    We could have defined @c(ColoredPoint) as a struct of three fields, but
#    instead we @e(embedded) a @c(Point) to provide the @c(X) and @c(Y) fields. As
#    we saw in @l(#Section 4.4.3), embedding lets us take a syntactic shortcut to
#    defining a @c(ColoredPoint) that contains all the fields of @c(Point), plus
#    some more. If we want, we can select the fields of @c(ColoredPoint) that were
#    contributed by the embedded @c(Point) without mentioning @c(Point):
   Podriamos haber definido @c(ColoredPoint) como una estructura de tres campos,
   pero en su lugar, @e(enbebimos) un @c(Point) para proporcionar los campos
   @c(X) e @c(Y). Como vimos en la @l(#Seccion 4.4.3), la incrustacion nos
   permite tomar un atajo sintactico para definir un tipo @c(ColoredPoint) que
   contiene todos los campos de @c(Point), ademas de un poco mas. Si queremos,
   podemos seleccionar los campos de @c(ColoredPoint) que fueron aportados por
   el @c(Point) embebido sin mencionar a @c(Point):

#    ..src > go
#      var cp ColoredPoint
#      cp.X = 1
#      fmt.Println(cp.Point.X) // "1"
#      cp.Point.Y = 2
#      fmt.Println(cp.Y)       // "2"
#    < src..
   ..src > go
     var cp ColoredPoint
     cp.X = 1
     fmt.Println(cp.Point.X) // "1"
     cp.Point.Y = 2
     fmt.Println(cp.Y)       // "2"
   < src..

#    A similar mechanism applies to the @e(methods) of @c(Point). We can call
#    methods of the embedded @c(Point) field using a receiver of type
#    @c(ColoredPoint), even though @c(ColoredPoint) has no declared methods:
   Un mecanismo similar se aplica a los @e(metodos) de @c(Point). Podemos llamar
   a los metodos del enbebido @c(Point) utilizando un receptor de tipo
   @c(ColoredPoint), a pesar de que @c(ColoredPoint) no tiene metodos
   declarados:

#    ..src > go
#      red := color.RGBA{255, 0, 0, 255}
#      blue := color.RGBA{0, 0, 255, 255}
#      var p = ColoredPoint{Point{1, 1}, red}
#      var q = ColoredPoint{Point{5, 4}, blue}
#      fmt.Println(p.Distance(q.Point)) // "5"
#      p.ScaleBy(2)
#      q.ScaleBy(2)
#      fmt.Println(p.Distance(q.Point)) // "10"
#    < src..
   ..src > go
     red := color.RGBA{255, 0, 0, 255}
     blue := color.RGBA{0, 0, 255, 255}
     var p = ColoredPoint{Point{1, 1}, red}
     var q = ColoredPoint{Point{5, 4}, blue}
     fmt.Println(p.Distance(q.Point)) // "5"
     p.ScaleBy(2)
     q.ScaleBy(2)
     fmt.Println(p.Distance(q.Point)) // "10"
   < src..

#    The methods of @c(Point) have been @e(promoted) to @c(ColoredPoint). In this
#    way, embedding allows complex types with many methods to be built up by the
#    @e(composition) of several fields, each providing a few methods.
   Los metodos de @c(Point) han sido @e(promovidos) a @c(ColoredPoint). De esta
   manera, la incrustacion permite tipos complejos con muchos metodos que se
   construiran por la composicion de varios campos, cada uno proporcionando unos
   pocos metodos.

#    Readers familiar with class-based object-oriented languages may be tempted to
#    view @c(Point) as a base class and @c(ColoredPoint) as a subclass or derived
#    class, or to interpret the relationship between these types as if a
#    @c(ColoredPoint) @"(is a) @c(Point). But that would be a mistake. Notice the
#    calls to @c(Distance) above. @c(Distance) has a parameter of type @c(Point),
#    and @c(q) is not a @c(Point), so although @c(q) does have an embedded field of
#    that type, we must explicitly select it. Attempting to pass @c(q) would be an
#    error:
   Los lectores familiarizados con lenguajes orientados a objetos basados en
   clases pueden ser tentados a ver @c(Point) como una clase base y
   @c(ColoredPoint) como una subclase o clase derivada, o a interpretar la
   relacion entre estos tipos como si @c(ColoredPoint) @"(es un) @c(Point). Pero
   eso seria un error. Observe las llamadas a @c(Distance) arriba. @c(Distance)
   tiene un parametro de tipo @c(Point), ya que @c(q) no es un @c(Point), asi
   que aunque @c(q) tiene un campo enbebido de ese tipo, debemos seleccionarlo
   explicitamente. Si intenta pasar @c(q) seria un error:

#    ..src > go
#      p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point
#    < src..
   ..src > go
     p.Distance(q) // error de compilacion: no se puede utilizar q (ColoredPoint) como Point
   < src..

#    A @c(ColoredPoint) is not a @c(Point), but it @"(has a) @c(Point), and it has
#    two additional methods @c(Distance) and @c(ScaleBy) promoted from @c(Point).
#    If you prefer to think in terms of implementation, the embedded field
#    instructs the compiler to generate additional wrapper methods that delegate
#    to the declared methods, equivalent to these:
   Un @c(ColoredPoint) no es un @c(Point), pero @"(tiene un) @c(Point), y tiene
   dos metodos adicionales @c(Distance) y @c(ScaleBy) promocionados desde
   @c(Point). Si prefiere pensar en terminos de implementacion, el campo
   enbebido instruye al compilador a generar metodos de envoltura adicionales
   que delegan en los metodos declarados, equivalentes a los siguientes:

#    ..src > go
#      func (p ColoredPoint) Distance(q Point) float64 {
#        return p.Point.Distance(q)
#      }
#
#      func (p *ColoredPoint) ScaleBy(factor float64) {
#        p.Point.ScaleBy(factor)
#      }
#    < src..
   ..src > go
     func (p ColoredPoint) Distance(q Point) float64 {
       return p.Point.Distance(q)
     }

     func (p *ColoredPoint) ScaleBy(factor float64) {
       p.Point.ScaleBy(factor)
     }
   < src..

#    When @c(Point.Distance) is called by the first of these wrapper methods, its
#    receiver value is @c(p.Point), not @c(p), and there is no way for the method
#    to access the @c(ColoredPoint) in which the @c(Point) is embedded.
   Cuando @c(Point.Distance) es llamado por el primero de estos metodos de
   envoltura, su valor receptor es @c(p.Point), no @c(p), y no hay manera de que
   el metodo accededa a @c(ColoredPoint) en el que @c(Point) esta enbebido.

#    The type of an anonymous field may be a @e(pointer) to a named type, in which
#    case fields and methods are promoted indirectly from the pointed-to
#    object. Adding another level of indirection lets us share common structures
#    and vary the relationships between objects dynamically. The declaration of
#    @c(ColoredPoint) below embeds a @c(*Point):
   El tipo de un campo anonimo puede ser un @e(puntero) a un tipo con nombre, en
   cuyo caso los campos y metodos se promueven indirectamente del puntero al
   objeto. Agregar otro nivel de indireccion nos permite compartir estructuras
   comunes y variar las relaciones entre los objetos dinamicamente. La
   declaracion de @c(ColoredPoint) a continuacion incorpora un @c(*Point):

#    ..src > go
#      type ColoredPoint struct {
#        *Point
#        Color color.RGBA
#      }
#
#      p := ColoredPoint{&Point{1, 1}, red}
#      q := ColoredPoint{&Point{5, 4}, blue}
#      fmt.Println(p.Distance(*q.Point)) // "5"
#      q.Point = p.Point                 // p and q now share the same Point
#      p.ScaleBy(2)
#      fmt.Println(*p.Point, *q.Point)   // "{2 2} {2 2}"
#    < src..
   ..src > go
     type ColoredPoint struct {
       *Point
       Color color.RGBA
     }

     p := ColoredPoint{&Point{1, 1}, red}
     q := ColoredPoint{&Point{5, 4}, blue}
     fmt.Println(p.Distance(*q.Point)) // "5"
     q.Point = p.Point                 // ahora p y q comparten el mismo Point
     p.ScaleBy(2)
     fmt.Println(*p.Point, *q.Point)   // "{2 2} {2 2}"
   < src..

#    A struct type may have more than one anonymous field. Had we declared
#    @c(ColoredPoint) as
   Un tipo de estructura puede tener mas de un campo anonimo. Si hubieramos
   declarado @c(ColoredPoint) como

#    ..src > go
#      type ColoredPoint struct {
#        Point
#        color.RGBA
#      }
#    < src..
   ..src > go
     type ColoredPoint struct {
       Point
       color.RGBA
     }
   < src..

#    then a value of this type would have all the methods of @c(Point), all the
#    methods of @c(RGBA), and any additional methods declared on @c(ColoredPoint)
#    directly. When the compiler resolves a selector such as @c(p.ScaleBy) to a
#    method, it first looks for a directly declared method named @c(ScaleBy), then
#    for methods promoted once from @c(ColoredPoint)’s embedded fields, then for
#    methods promoted twice from embedded fields within @c(Point) and @c(RGBA),
#    and so on. The compiler reports an error if the selector was ambiguous
#    because two methods were promoted from the same rank.
   entonces un valor de este tipo tendria todos los metodos de @c(Point), todos
   los metodos de @c(RGBA), y cualesquiera otros metodos declarados en
   @c(ColoredPoint) directamente. Cuando el compilador resuelve un selector como
   @c(p.ScaleBy) a un metodo, primero se busca un metodo llamado directamente
   declarada @c(ScaleBy), luego, para los metodos promovidos de campos
   incrustados en @c(ColoredPoint), luego, para los metodos promovidos dos veces
   de campos incrustados dentro @c(Point) y @c(RGBA), y asi sucesivamente. El
   compilador informa de un error si el selector es ambiguo porque se
   promocionaron dos metodos desde el mismo rango.

#    Methods can be declared only on named types (like @c(Point)) and pointers to
#    them (@c[*Point]), but thanks to embedding, it’s possible and sometimes
#    useful for @e(unnamed) struct types to have methods too.
   Los metodos pueden ser declaradas solo en tipos con nombre (como @c(Point)) y
   punteros a ellos (@c(*Point)), pero gracias al embedido, es posible y, a
   veces util que los tipos de estructura @e(sin nombre) tambien tengan metodos.

#    Here’s a nice trick to illustrate. This example shows part of a simple cache
#    implemented using two package-level variables, a mutex (@l(#Section
#    9.2<>§9.2)) and the map that it guards:
   Aqui hay un buen truco para ilustrarlo. Este ejemplo muestra parte de una
   cache simple implementada usando dos variables a nivel de paquete, un mutex
   (@l(#Seccion 9.2<>§9.2)) y el mapa que lo protege:

#    ..src > go
#      var (
#        mu sync.Mutex // guards mapping
#        mapping = make(map[string]string)
#      )
#
#      func Lookup(key string) string {
#        mu.Lock()
#        v := mapping[key]
#        mu.Unlock()
#        return v
#      }
#    < src..
   ..src > go
     var (
       mu sync.Mutex // protege a mapping
       mapping = make(map[string]string)
     )

     func Lookup(key string) string {
       mu.Lock()
       v := mapping[key]
       mu.Unlock()
       return v
     }
   < src..

#    The version below is functionally equivalent but groups together the two
#    related variables in a single package-level variable, @c(cache):
   La version de abajo es funcionalmente equivalente pero agrupa a las dos
   variables relacionadas en una unica variable de nivel de paquete, @c(cache):

#    ..src > go
#      var cache = struct {
#        sync.Mutex
#        mapping map[string]string
#      } {
#        mapping: make(map[string]string),
#      }
#
#      func Lookup(key string) string {
#        cache.Lock()
#        v := cache.mapping[key]
#        cache.Unlock()
#        return v
#      }
#    < src..
   ..src > go
     var cache = struct {
       sync.Mutex
       mapping map[string]string
     } {
       mapping: make(map[string]string),
     }

     func Lookup(key string) string {
       cache.Lock()
       v := cache.mapping[key]
       cache.Unlock()
       return v
     }
   < src..

#    The new variable gives more expressive names to the variables related to the
#    cache, and because the @c(sync.Mutex) field is embedded within it, its
#    @c(Lock) and @c(Unlock) methods are promoted to the unnamed struct type,
#    allowing us to lock the @c(cache) with a self-explanatory syntax.
   La nueva variable da nombres mas expresivos a las variables relacionadas con
   la @c(cache), y debido a que el campo @c(sync.Mutex) esta enbebido dentro de
   ella, su metodos @c(Lock) y @c(Unlock) se promueven al tipo de estructura sin
   nombre, lo que nos permite bloquear la @c(cache) con una sintaxis auto
   explicativa.

# ** Section 6.4 <> Method Values and Expressions
** Seccion 6.4 <> Valores y Expresiones de los Metodos

#    Usually we select and call a method in the same expression, as in
#    @c[p.Distance()], but it’s possible to separate these two operations. The
#    selector @c(p.Distance) yields a @e(method value), a function that binds a
#    method (@c[Point.Distance]) to a specific receiver value @c(p). This function
#    can then be invoked without a receiver value; it needs only the non-receiver
#    arguments.
   Normalmente seleccionamos y llamamos a un metodo en la misma expresion, como
   en @c[p.Distance()], pero es posible separar estas dos operaciones. El
   selector @c(p.Distance) produce un @e(valor de metodo), una funcion une un
   metodo (@c[Point.Distance]) a un valor de receptor especifico @c(p). Esta
   funcion puede entonces ser invocada sin un valor de receptor; Solo necesita
   los argumentos del no receptor.

#    ..src > go
#      p := Point{1, 2}
#      q := Point{4, 6}
#
#      distanceFromP := p.Distance        // method value
#      fmt.Println(distanceFromP(q))      // "5"
#      var origin Point                   // {0, 0}
#      fmt.Println(distanceFromP(origin)) // "2.23606797749979", √5
#
#      scaleP := p.ScaleBy // method value
#      scaleP(2)           // p becomes (2, 4)
#      scaleP(3)           //      then (6, 12)
#      scaleP(10)          //      then (60, 120)
#    < src..
   ..src > go
     p := Point{1, 2}
     q := Point{4, 6}

     distanceFromP := p.Distance        // volor del metodo
     fmt.Println(distanceFromP(q))      // "5"
     var origin Point                   // {0, 0}
     fmt.Println(distanceFromP(origin)) // "2.23606797749979", √5

     scaleP := p.ScaleBy // valor del metodo
     scaleP(2)           // p se vuelve (2, 4)
     scaleP(3)           //       luego (6, 12)
     scaleP(10)          //       luego (60, 120)
   < src..

#    Method values are useful when a package’s API calls for a function value, and
#    the client’s desired behavior for that function is to call a method on a
#    specific receiver. For example, the function @c(time.AfterFunc) calls a
#    function value after a specified delay. This program uses it to launch the
#    rocket @c(r) after 10 seconds:
   Los valores de metodo son utiles cuando la API de un paquete solicita un
   valor de funcion y el comportamiento deseado del cliente para esa funcion es
   llamar a un metodo en un receptor especifico. Por ejemplo, la funcion
   @c(time.AfterFunc) llama a un valor de funcion despues de un retardo
   especificado. Este programa lo utiliza para lanzar el cohete @c(r) despues de
   10 segundos:

#    ..src > go
#      type Rocket struct { /* ... */ }
#      func (r *Rocket) Launch() { /* ... */ }
#
#      r := new(Rocket)
#      time.AfterFunc(10 * time.Second, func() { r.Launch() })
#    < src..
   ..src > go
     type Rocket struct { /* ... */ }
     func (r *Rocket) Launch() { /* ... */ }

     r := new(Rocket)
     time.AfterFunc(10 * time.Second, func() { r.Launch() })
   < src..

#    The method value syntax is shorter:
   La sintaxis del valor del metodo es mas corta:

#    ..src > go
#      time.AfterFunc(10 * time.Second, r.Launch)
#    < src..
   ..src > go
     time.AfterFunc(10 * time.Second, r.Launch)
   < src..

#    Related to the method value is the @e(method expression). When calling a
#    method, as opposed to an ordinary function, we must supply the receiver in a
#    special way using the selector syntax. A method expression, written @c(T.f)
#    or @c[(*T).f] where @c(T) is a type, yields a function value with a regular
#    first parameter taking the place of the receiver, so it can be called in the
#    usual way.
   En relacion con el valor del metodo es la @e(expresion del metodo). Al llamar
   a un metodo, a diferencia de una funcion ordinaria, debemos suministrar al
   receptor de una manera especial usando la sintaxis del selector. Una
   expresion de metodo, escrita @c(T.f) o @c[(*T).f] donde @c(T) es un tipo,
   produce un valor de funcion con un primer parametro tomando el lugar del
   receptor, por lo que puede ser llamado de la manera habitual.

#    ..src > go
#      p := Point{1, 2}
#      q := Point{4, 6}
#
#      distance := Point.Distance   // method expression
#      fmt.Println(distance(p, q))  // "5"
#      fmt.Printf("%T\n", distance) // "func(Point, Point) float64"
#
#      scale := (*Point).ScaleBy
#      scale(&p, 2)
#      fmt.Println(p)            // "{2 4}"
#      fmt.Printf("%T\n", scale) // "func(*Point, float64)"
#    < src..
   ..src > go
     p := Point{1, 2}
     q := Point{4, 6}

     distance := Point.Distance   // expresion del metodo
     fmt.Println(distance(p, q))  // "5"
     fmt.Printf("%T\n", distance) // "func(Point, Point) float64"

     scale := (*Point).ScaleBy
     scale(&p, 2)
     fmt.Println(p)            // "{2 4}"
     fmt.Printf("%T\n", scale) // "func(*Point, float64)"
   < src..

#    Method expressions can be helpful when you need a value to represent a choice
#    among several methods belonging to the same type so that you can call the
#    chosen method with many different receivers. In the following example, the
#    variable @c(op) represents either the addition or the subtraction method of
#    type @c(Point), and @c(Path.TranslateBy) calls it for each point in the
#    @c(Path):
   Las expresiones de metodo pueden ser utiles cuando se necesita un valor para
   representar una eleccion entre varios metodos pertenecientes al mismo tipo
   para que pueda llamar al metodo elegido con muchos receptores diferentes. En
   el siguiente ejemplo, la variable @c(op) representa el metodo de suma o resta
   del tipo @c(Point), y @c(Path.TranslateBy) lo llama para cada punto en
   @c(Path):

#    ..src > go
#      type Point struct{ X, Y float64 }
#
#      func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
#      func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }
#
#      type Path []Point
#
#      func (path Path) TranslateBy(offset Point, add bool) {
#        var op func(p, q Point) Point
#        if add {
#          op = Point.Add
#        } else {
#          op = Point.Sub
#        }
#        for i := range path {
#          // Call either path[i].Add(offset) or path[i].Sub(offset).
#          path[i] = op(path[i], offset)
#        }
#      }
#    < src..
   ..src > go
     type Point struct{ X, Y float64 }

     func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
     func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }

     type Path []Point

     func (path Path) TranslateBy(offset Point, add bool) {
       var op func(p, q Point) Point
       if add {
         op = Point.Add
       } else {
         op = Point.Sub
       }
       for i := range path {
         // llama en cada path[i].Add(offset) o path[i].Sub(offset).
         path[i] = op(path[i], offset)
       }
     }
   < src..

# ** Section 6.5 <> Example: Bit Vector Type
** Seccion 6.5 <> Ejemplo: Tipo de Vector de Bits

#    Sets in Go are usually implemented as a @c(map[T]bool), where @c(T) is the
#    element type. A set represented by a map is very flexible but, for certain
#    problems, a specialized representation may outperform it. For example, in
#    domains such as dataflow analysis where set elements are small non-negative
#    integers, sets have many elements, and set operations like union and
#    intersection are common, a @e(bit vector) is ideal.
   Los conjuntos en Go se implementan generalmente como un @c(map[T]bool), donde
   @c(T) es el tipo del elemento. Un conjunto representado por un mapa es muy
   flexible pero, para ciertos problemas, una representacion especializada puede
   superarla. Por ejemplo, en dominios tales como el analisis de flujo de datos
   donde los elementos del conjunto son pequeños numeros enteros no negativos,
   los conjuntos tienen muchos elementos, y las operaciones de conjunto como
   union e interseccion son comunes, un vector de bits es ideal.

#    A bit vector uses a slice of unsigned integer values or @"(words,) each bit
#    of which represents a possible element of the set. The set contains @m(i) if
#    the @m(i)-th bit is set. The following program demonstrates a simple bit
#    vector type with three methods:
   Un vector de bits utiliza una slice de valores o @"(palabras) de enteros sin
   signo, cada bit de los cuales representa un posible elemento del conjunto. El
   conjunto contiene @c(i) si se establece el enesimo bit. El siguiente programa
   muestra un tipo de vector de bits simple con tres metodos:

#    ..figure > @l(gopl.io/ch6/intset/intset.go<>gopl.io/ch6/intset)
   ..figure > @l(gopl.io/ch6/intset/intset.go<>gopl.io/ch6/intset)

#      ..src > go
#        // An IntSet is a set of small non-negative integers.
#        // Its zero value represents the empty set.
#        type IntSet struct {
#          words []uint64
#        }
#
#        // Has reports whether the set contains the non-negative value x.
#        func (s *IntSet) Has(x int) bool {
#          word, bit := x/64, uint(x%64)
#          return word < len(s.words) && s.words[word]&(1<<bit) != 0
#        }
#
#        // Add adds the non-negative value x to the set.
#        func (s *IntSet) Add(x int) {
#          word, bit := x/64, uint(x%64)
#          for word >= len(s.words) {
#            s.words = append(s.words, 0)
#          }
#          s.words[word] |= 1 << bit
#        }
#
#        // UnionWith sets s to the union of s and t.
#        func (s *IntSet) UnionWith(t *IntSet) {
#          for i, tword := range t.words {
#            if i < len(s.words) {
#              s.words[i] |= tword
#            } else {
#              s.words = append(s.words, tword)
#            }
#          }
#        }
#      < src..
     ..src > go
       // un IntSet es us conjunto pequeño de enteros no negativos.
       // El valor cero representa un conjunto vacio.
       type IntSet struct {
         words []uint64
       }

       // Has Informa cuando el conjunto contiene valores x no negativos.
       func (s *IntSet) Has(x int) bool {
         word, bit := x/64, uint(x%64)
         return word < len(s.words) && s.words[word]&(1<<bit) != 0
       }

       // Add agrega el valor x no negativo al conjunto.
       func (s *IntSet) Add(x int) {
         word, bit := x/64, uint(x%64)
         for word >= len(s.words) {
           s.words = append(s.words, 0)
         }
         s.words[word] |= 1 << bit
       }

       // UnionWith establece s a la union de s y t.
       func (s *IntSet) UnionWith(t *IntSet) {
         for i, tword := range t.words {
           if i < len(s.words) {
             s.words[i] |= tword
           } else {
             s.words = append(s.words, tword)
           }
         }
       }
     < src..


#    Since each word has 64 bits, to locate the bit for @c(x), we use the quotient
#    @c(x/64) as the word index and the remainder @c(x%64) as the bit index within
#    that word. The @c(UnionWith) operation uses the bitwise OR operator @c(|) to
#    compute the union 64 elements at a time. (We’ll revisit the choice of 64-bit
#    words in Exercise 6.5.)
   Ya que cada palabra tiene 64 bits, para localizar el bit para @c(x), se
   utiliza el cociente @c(x/64) como el indice de la palabra y el resto @c(x%64)
   como el indice de bit dentro de esa palabra. La operacion @c(UnionWith)
   utiliza el operador binario OR @c(|) Para calcular la union de 64 elementos a
   la vez. (Vamos a revisar la eleccion de palabras de 64 bits en el Ejercicio
   6.5.)

#    This implementation lacks many desirable features, some of which are posed as
#    exercises below, but one is hard to live without: way to print an @c(IntSet)
#    as a string. Let’s give it a @c(String) method as we did with @c(Celsius) in
#    @l(#Section 2.5):
   Esta aplicacion carece de muchas caracteristicas deseables, algunas de las
   cuales se plantean como ejercicios, pero es dificil vivir sin : una forma de
   imprimir un @c(IntSet) como una cadena. Vamos a darle una String metodo como
   lo hicimos con @c(Celsius) en la @l(#Seccion 2.5):

#    ..src > go
#      // String returns the set as a string of the form "{1 2 3}".
#      func (s *IntSet) String() string {
#        var buf bytes.Buffer
#        buf.WriteByte('{')
#        for i, word := range s.words {
#          if word == 0 {
#            continue
#          }
#          for j := 0; j < 64; j++ {
#            if word&(1<<uint(j)) != 0 {
#              if buf.Len() > len("{") {
#                buf.WriteByte(' ')
#              }
#              fmt.Fprintf(&buf, "%d", 64*i+j)
#            }
#          }
#        }
#        buf.WriteByte('}')
#        return buf.String()
#      }
#    < src..
   ..src > go
     // String regresa el conjunto como una cadena de la forma "{1 2 3}".
     func (s *IntSet) String() string {
       var buf bytes.Buffer
       buf.WriteByte('{')
       for i, word := range s.words {
         if word == 0 {
           continue
         }
         for j := 0; j < 64; j++ {
           if word&(1<<uint(j)) != 0 {
             if buf.Len() > len("{") {
               buf.WriteByte(' ')
             }
             fmt.Fprintf(&buf, "%d", 64*i+j)
           }
         }
       }
       buf.WriteByte('}')
       return buf.String()
     }
   < src..

#    Notice the similarity of the @c(String) method above with @c(intsToString) in
#    @l(#Section 3.5.4); @c(bytes.Buffer) is often used this way in @c(String)
#    methods. The @c(fmt) package treats types with a @c(String) method specially
#    so that values of complicated types can display themselves in a userfriendly
#    manner. Instead of printing the raw representation of the value (a struct in
#    this case), @c(fmt) calls the @c(String) method. The mechanism relies on
#    interfaces and type assertions, which we’ll explain in @l(#Chapter 7).
   Note la similitud del metodo anterior @c(String) con @c(intsToString) en la
   @l(#Seccion 3.5.4); @c(bytes.Buffer) se utiliza a menudo de esta manera en
   metodos @c(String). El paquete @c(fmt) maneja tipos con un metodo @c(String)
   especialmente para que los valores de los tipos complicados se puedan mostrar
   de una manera amigable para el usuario. En lugar de imprimir la
   representacion del valor en bruto (una estructura en este caso), @c(fmt)
   llama al metodo @c(String). El mecanismo se basa en interfaces y tipo de
   afirmaciones, que vamos a explicar en el @l(#Capitulo 7).

#    We can now demonstrate @c(IntSet) in action:
   Ahora podemos demostrar @c(IntSet) en accion:

#    ..src > go
#      var x, y IntSet
#      x.Add(1)
#      x.Add(144)
#      x.Add(9)
#      fmt.Println(x.String()) // "{1 9 144}"
#
#      y.Add(9)
#      y.Add(42)
#      fmt.Println(y.String()) // "{9 42}"
#
#      x.UnionWith(&y)
#      fmt.Println(x.String()) // "{1 9 42 144}"
#
#      fmt.Println(x.Has(9), x.Has(123)) // "true false"
#    < src..
   ..src > go
     var x, y IntSet
     x.Add(1)
     x.Add(144)
     x.Add(9)
     fmt.Println(x.String()) // "{1 9 144}"

     y.Add(9)
     y.Add(42)
     fmt.Println(y.String()) // "{9 42}"

     x.UnionWith(&y)
     fmt.Println(x.String()) // "{1 9 42 144}"

     fmt.Println(x.Has(9), x.Has(123)) // "true false"
   < src..

#    A word of caution: we declared @c(String) and @c(Has) as methods of the
#    pointer type @c(*IntSet) not out of necessity, but for consistency with the
#    other two methods, which need a pointer receiver because they assign to
#    @c(s.words). Consequently, an @c(IntSet) @e(value) does not have a @c(String)
#    method, occasionally leading to surprises like this:
   Una palabra de precaucion: declaramos @c(String) y @c(Has) como metodos del
   tipo de puntero @c(*IntSet) no por necesidad, sino por coherencia con los
   otros dos metodos, los cuales necesitan un receptor puntero porque asignan a
   @c(s.words). En consecuencia, un valor @c(IntSet) no tiene una metodo
   @c(String), en ocasiones, conduce a sorpresas como esta:

#    ..src > go
#      fmt.Println(&x)         // "{1 9 42 144}"
#      fmt.Println(x.String()) // "{1 9 42 144}"
#      fmt.Println(x)          // "{[4398046511618 0 65536]}"
#    < src..
   ..src > go
     fmt.Println(&x)         // "{1 9 42 144}"
     fmt.Println(x.String()) // "{1 9 42 144}"
     fmt.Println(x)          // "{[4398046511618 0 65536]}"
   < src..

#    In the first case, we print an @c(*IntSet) pointer, which does have a
#    @c(String) method. In the second case, we call @c[String()] on an @c(IntSet)
#    variable; the compiler inserts the implicit @c(&) operation, giving us a
#    pointer, which has the @c(String) method. But in the third case, because the
#    @c(IntSet) value does not have a @c(String) method, @c(fmt.Println) prints
#    the representation of the struct instead. It’s important not to forget the
#    @c(&) operator. Making @c(String) a method of @c(IntSet), not @c(*IntSet),
#    might be a good idea, but this is a case-by-case judgment.
   En el primer caso, Imprimimos un puntero @c(*IntSet), que tiene un metodo
   @c(String). En el segundo caso, que llamamos a @c[String()] en una variable
   @c(IntSet); el compilador inserta la operacion @c(&) implicita, que nos da un
   puntero, que tiene el metodo @c(String). Sin embargo, en el tercer caso,
   debido a que el valor @c(IntSet) no tiene un metodo @c(String), fmt.Println
   imprime la representacion de la estructura en su lugar. Es importante no
   olvidar el operador @c(&). Hacer @c(String) un metodo de @c(IntSet), no
   @c(*IntSet), podria ser una buena idea, pero esto es un juicio caso por caso.

#    @b(Exercise 6.1): Implement these additional methods:
   @b(Ejercicio 6.1): Implementar estos metodos adicionales:

#    ..src > go
#      func (*IntSet) Len() int      // return the number of elements
#      func (*IntSet) Remove(x int)  // remove x from the set
#      func (*IntSet) Clear()        // remove all elements from the set
#      func (*IntSet) Copy() *IntSet // return a copy of the set
#    < src..
   ..src > go
     func (*IntSet) Len() int      // regresa el numero de elementos
     func (*IntSet) Remove(x int)  // elimina x del conjunto
     func (*IntSet) Clear()        // elimina todos los elementos del conjunto
     func (*IntSet) Copy() *IntSet // regresa una copia del conjunto
   < src..

#    @b(Exercise 6.2): Define a variadic @c[(*IntSet).AddAll(...int)] method that
#    allows a list of values to be added, such as @c[s.AddAll(1, 2, 3)].
   @b(Ejercicio 6.2): Definir una metodo variadic @c[(*IntSet).AddAll(...int)]
   que permita añadir una lista de valores, como @c[s.AddAll(1, 2, 3)].

#    @b(Exercise 6.3): @c[(*IntSet).UnionWith] computes the union of two sets
#    using @c(|), the word-parallel bitwise OR operator. Implement methods for
#    @c(IntersectWith), @c(DifferenceWith), and @c(SymmetricDifference) for the
#    corresponding set operations. (The symmetric difference of two sets contains
#    the elements present in one set or the other but not both.)
   @b(Ejercicio 6.3): @c[(*IntSet).UnionWith] calcula la union de dos conjuntos
   utilizando @c(|), el operador OR binario. Implementar metodos para
   @c(IntersectWith), @c(DifferenceWith), y @c(SymmetricDifference) para las
   operaciones de conjuntos correspondientes. (La diferencia simetrica de dos
   conjuntos contiene los elementos presentes en un conjunto o el otro, pero no
   ambos.)

#    @b(Exercise 6.4): Add a method @c(Elems) that returns a slice containing the
#    elements of the set, suitable for iterating over with a @c(range) loop.
   @b(Ejercicio 6.4): añadir un metodo @c(Elems) que devuelve una slice que
   contiene los elementos del conjunto, apto para iterar sobre el con una bucle
   @c(range).

#    @b(Exercise 6.5): The type of each word used by @c(IntSet) is @c(uint64), but
#    64-bit arithmetic may be inefficient on a 32-bit platform. Modify the program
#    to use the @c(uint) type, which is the most efficient unsigned integer type
#    for the platform. Instead of dividing by 64, define a constant holding the
#    effective size of @c(uint) in bits, 32 or 64. You can use the perhaps
#    too-clever expression @c[32 << (^uint(0) >> 63)] for this purpose.
   @b(Ejercicio 6.5): El tipo de cada palabra usada por @c(IntSet) es
   @c(uint64), pero la aritmetica de 64 bits puede ser ineficiente en una
   plataforma de 32 bits. Modificar el programa para usar el tipo @c(uint), que
   es el tipo entero sin signo mas eficiente para la plataforma. En lugar de
   dividir por 64, definir una constante que almacene el tamaño efectivo de
   @c(uint) en bits, 32 o 64. Se puede utilizar la expresion tal vez demasiado
   inteligente @c[32 << (^uint(0) >> 63)] para este proposito.

# ** Section 6.6 <> Encapsulation
** Seccion 6.6 <> Encapsulacion

#    A variable or method of an object is said to be @e(encapsulated) if it is
#    inaccessible to clients of the object. Encapsulation, sometimes called
#    @e(information hiding), is a key aspect of object-oriented programming.
   Se dice que una variable o metodo de un objeto esta encapsulado si es
   inaccesible para los clientes del objeto. La encapsulacion, a veces llamado
   ocultacion de la informacion, es un aspecto clave de la programacion
   orientada a objetos.

#    Go has only one mechanism to control the visibility of names: capitalized
#    identifiers are exported from the package in which they are defined, and
#    uncapitalized names are not. The same mechanism that limits access to members
#    of a package also limits access to the fields of a struct or the methods of a
#    type. As a consequence, to encapsulate an object, we must make it a struct.
   Go solo tiene un mecanismo para controlar la visibilidad de los nombres: los
   identificadores en mayusculas se exportan desde el paquete en el que estan
   definidos y los nombres no capitalizados no. El mismo mecanismo que limita el
   acceso a los miembros de un paquete tambien limita el acceso a los campos de
   una estructura o los metodos de un tipo. Como consecuencia, para encapsular
   un objeto, debemos hacer que sea una estructura.

#    That’s the reason the @c(IntSet) type from the previous section was declared as a
#    struct type even though it has only a single field:
   Esa es la razon por la que el tipo @c(IntSet) de la seccion anterior fue
   declarado como un tipo de estructura a pesar de que solo tiene un unico
   campo:

#    ..src > go
#      type IntSet struct {
#        words []uint64
#      }
#    < src..
   ..src > go
     type IntSet struct {
       words []uint64
     }
   < src..

#    We could instead define @c(IntSet) as a slice type as follows, though of
#    course we’d have to replace each occurrence of @c(s.words) by @c(*s) in its
#    methods:
   En cambio podriamos definir @c(IntSet) como un tipo de slice de la siguiente
   manera, aunque por supuesto tendriamos que sustituir cada ocurrencia de
   @c(s.words) por @c(*s) en sus metodos:

#    ..src > go
#      type IntSet []uint64
#    < src..
   ..src > go
     type IntSet []uint64
   < src..

#    Although this version of @c(IntSet) would be essentially equivalent, it would
#    allow clients from other packages to read and modify the slice directly. Put
#    another way, whereas the expression @c(*s) could be used in any package,
#    @c(s.words) may appear only in the package that defines @c(IntSet).
   Aunque esta version de @c(IntSet) esencialmente seria equivalente, permitiria
   a clientes de otros paquetes leer y modificar el slice directamente. Dicho de
   otra manera, mientras que la expresion @c(*s) se podrian utilizar en
   cualquier paquete, @c(s.words) solo puede aparecer en el paquete que define
   @c(IntSet).

#    Another consequence of this name-based mechanism is that the unit of
#    encapsulation is the package, not the type as in many other languages. The
#    fields of a struct type are visible to all code within the same
#    package. Whether the code appears in a function or a method makes no
#    difference.
   Otra consecuencia de este mecanismo basado en el nombre es que la unidad de
   encapsulacion es el paquete, no el tipo como en muchos otros lenguajes. Los
   campos de un tipo de estructura son visibles para todo el codigo dentro del
   mismo paquete. Si el codigo aparece en una funcion o un metodo no hace
   ninguna diferencia.

#    Encapsulation provides three benefits. First, because clients cannot directly
#    modify the object’s variables, one need inspect fewer statements to
#    understand the possible values of those variables.
   La encapsulacion proporciona tres beneficios. En primer lugar, debido a que
   los clientes no pueden modificar directamente las variables del objeto, es
   necesario inspeccionar menos enunciados para comprender los valores posibles
   de esas variables.

#    Second, hiding implementation details prevents clients from depending on
#    things that might change, which gives the designer greater freedom to evolve
#    the implementation without breaking API compatibility.
   En segundo lugar, ocultar los detalles de la implementacion impide que los
   clientes dependan de las cosas que podrian cambiar, lo que le da al diseñador
   mayor libertad para evolucionar la implementacion sin romper la
   compatibilidad de la API.

#    As an example, consider the @c(bytes.Buffer) type. It is frequently used to
#    accumulate very short strings, so it is a profitable optimization to reserve
#    a little extra space in the object to avoid memory allocation in this common
#    case. Since @c(Buffer) is a struct type, this space takes the form of an
#    extra field of type @c([64]byte) with an uncapitalized name. When this field
#    was added, because it was not exported, clients of @c(Buffer) outside the
#    @c(bytes) package were unaware of any change except improved
#    performance. @c(Buffer) and its @c(Grow) method are shown below, simplified
#    for clarity :
   Como ejemplo, considere el tipo @c(bytes.Buffer) tipo. Se utiliza con
   frecuencia para acumular cadenas muy cortas, por lo que es una optimizacion
   rentable para reservar un poco mas de espacio en el objeto para evitar la
   asignacion de memoria en este caso comun. Ya que @c(Buffer) es un tipo
   @c(struct), este espacio tiene la forma de un campo adicional de tipo
   @c([64]byte) con un nombre en minusculas. Cuando se añadio este campo, ya que
   no se exporto, los clientes de @c(Buffer) fuera del paquete @c(bytes) no eran
   conscientes de ningun cambio, excepto un rendimiento mejorado. @c(Buffer) y
   su metodo @c(Grow) se muestran a continuacion, simplificado para mayor
   claridad:

#    ..src > go
#      type Buffer struct {
#        buf     []byte
#        initial [64]byte
#        /* ... */
#      }
#
#      // Grow expands the buffer's capacity, if necessary,
#      // to guarantee space for another n bytes. [...]
#      func (b *Buffer) Grow(n int) {
#        if b.buf == nil {
#          b.buf = b.initial[:0] // use preallocated space initially
#        }
#        if len(b.buf)+n > cap(b.buf) {
#          buf := make([]byte, b.Len(), 2*cap(b.buf) + n)
#          copy(buf, b.buf)
#          b.buf = buf
#        }
#      }
#    < src..
   ..src > go
     type Buffer struct {
       buf     []byte
       initial [64]byte
       /* ... */
     }

     // Grow apmlia la capacidad del buffer, si es necesario,
     // para garantizar espacio por otron n bytes. [...]
     func (b *Buffer) Grow(n int) {
       if b.buf == nil {
         b.buf = b.initial[:0] // use preallocated space initially
       }
       if len(b.buf)+n > cap(b.buf) {
         buf := make([]byte, b.Len(), 2*cap(b.buf) + n)
         copy(buf, b.buf)
         b.buf = buf
       }
     }
   < src..

#    The third benefit of encapsulation, and in many cases the most important, is
#    that it prevents clients from setting an object’s variables
#    arbitrarily. Because the object’s variables can be set only by functions in
#    the same package, the author of that package can ensure that all those
#    functions maintain the object’s internal invariants. For example, the
#    @c(Counter) type below permits clients to increment the counter or to reset
#    it to zero, but not to set it to some arbitrary value:
   El tercer beneficio de la encapsulacion, y en muchos casos el mas importante,
   es que impide que los clientes establezcan arbitrariamente las variables de
   un objeto. Debido a que las variables del objeto solo pueden ser definidas
   por funciones en el mismo paquete, el autor de ese paquete puede garantizar
   que todas esas funciones mantengan las invariantes internas del objeto. Por
   ejemplo, el tipo @c(Counter) continuacion permite a los clientes incrementar
   el contador o reestablecerlo a cero, pero no ponerlo en un valor arbitrario:

#    ..src > go
#      type Counter struct { n int }
#
#      func (c *Counter) N() int     { return c.n }
#      func (c *Counter) Increment() { c.n++ }
#      func (c *Counter) Reset()     { c.n = 0 }
#    < src..
   ..src > go
     type Counter struct { n int }

     func (c *Counter) N() int     { return c.n }
     func (c *Counter) Increment() { c.n++ }
     func (c *Counter) Reset()     { c.n = 0 }
   < src..

#    Functions that merely access or modify internal values of a type, such as the
#    methods of the @c(Logger) type from @c(log) package, below, are called
#    @e(getters) and @e(setters). However, when naming a getter method, we usually
#    omit the @c(Get) prefix. This preference for brevity extends to all methods,
#    not just field accessors, and to other redundant prefixes as well, such as
#    @c(Fetch), @c(Find), and @c(Lookup).
   Las Funciones que simplemente acceso o modifican los valores internos de un
   tipo, como los metodos del tipo @c(Logger) del paquete @c(log), a
   continuacion, se denominan @e(getters) (optenedores) y @e(setters)
   (definidores). Sin embargo, al nombrar a un metodo getter, por lo general
   omitimos el prefijo @c(Get). Esta preferencia por razones de brevedad se
   extiende a todos los metodos, no solo a los accesores de campo, y para otros
   prefijos redundantes, asi como @c(Fetch), @c(Find), y @c(Lookup).

#    ..src > go
#      package log
#
#      type Logger struct {
#        flags  int
#        prefix string
#        // ...
#      }
#
#      func (l *Logger) Flags() int
#      func (l *Logger) SetFlags(flag int)
#      func (l *Logger) Prefix() string
#      func (l *Logger) SetPrefix(prefix string)
#    < src..
   ..src > go
     package log

     type Logger struct {
       flags  int
       prefix string
       // ...
     }

     func (l *Logger) Flags() int
     func (l *Logger) SetFlags(flag int)
     func (l *Logger) Prefix() string
     func (l *Logger) SetPrefix(prefix string)
   < src..

#    Go style does not forbid exported fields. Of course, once exported, a field
#    cannot be unexported without an incompatible change to the API, so the
#    initial choice should be deliberate and should consider the complexity of the
#    invariants that must be maintained, the likelihood of future changes, and the
#    quantity of client code that would be affected by a change.
   El stilo de Go no prohibe exportar los campos. Por supuesto, una vez
   exportado, un campo no puede ser exportado sin un cambio incompatible a la
   API, por lo que la eleccion inicial debe ser deliberada y debe considerar la
   complejidad de los invariantes que deben mantenerse, la probabilidad de
   cambios futuros y la cantidad del codigo cliente que se veria afectado por un
   cambio.

#    Encapsulation is not always desirable. By revealing its representation as an
#    @c(int64) number of nanoseconds, @c(time.Duration) lets us use all the usual
#    arithmetic and comparison operations with durations, and even to define
#    constants of this type:
   La encapsulacion no siempre es deseable. Al revelar su representacion como un
   numero @c(int64) de nanosegundos, @c(time.Duration) nos permite usar todas
   las operaciones aritmeticas y de comparacion con duraciones habituales, e
   incluso para definir constantes de este tipo:

#    ..src > go
#      const day = 24 * time.Hour
#      fmt.Println(day.Seconds()) // "86400"
#    < src..
   ..src > go
     const day = 24 * time.Hour
     fmt.Println(day.Seconds()) // "86400"
   < src..

#    As another example, contrast @c(IntSet) with the @c(geometry.Path) type from
#    the beginning of this chapter. @c(Path) was defined as a slice type, allowing
#    its clients to construct instances using the slice literal syntax, to iterate
#    over its points using a range loop, and so on, whereas these operations are
#    denied to clients of @c(IntSet).
   Como otro ejemplo, contraste @c(IntSet) con el tipo @c(geometry.Path) al
   principio de este capitulo. @c(Path) se definio como un tipo de slice,
   permitiendo a sus clientes construir instancias utilizando la sintaxis
   literal de slice, para iterar sobre sus puntos usando un bucle de rango, y
   asi sucesivamente, mientras que estas operaciones se le niegan a los clientes
   de @c(IntSet).

#    Here’s the crucial difference: @c(geometry.Path) is intrinsically a sequence
#    of points, no more and no less, and we don’t foresee adding new fields to it,
#    so it makes sense for the @c(geometry) package to reveal that @c(Path) is a
#    slice. In contrast, an @c(IntSet) merely happens to be represented as a
#    @c([]uint64) slice. It could have been represented using @c([]uint), or
#    something completely different for sets that are sparse or very small, and it
#    might perhaps benefit from additional features like an extra field to record
#    the number of elements in the set. For these reasons, it makes sense for
#    @c(IntSet) to be opaque.
   Esta es la diferencia fundamental: @c(geometry.Path) es intrinsecamente una
   secuencia de puntos, ni mas ni menos, y no prevemos la adicion de nuevos
   campos a la misma, asi que tiene sentido para el paquete @c(geometry) revelar
   que @c(Path) es un slice. En contraste, un @c(IntSet) simplemente pasa a ser
   representado como un slice @c([]uint64). Podria haber sido representado
   mediante @c([]uint), o algo completamente diferente para los conjuntos que
   son escasos o muy pequeños, y que tal vez podrian beneficiarse de
   caracteristicas adicionales como un campo adicional para registrar el numero
   de elementos en el conjunto. Por estas razones, tiene sentido que @c(IntSet)
   sea opaco.

#    In this chapter, we learned how to associate methods with named types, and
#    how to call those methods. Although methods are crucial to object-oriented
#    programming, they’re only half the picture. To complete it, we need
#    @e(interfaces), the subject of the next chapter.
   En este capitulo, aprendimos como asociar metodos con tipos con nombre y como
   llamar a esos metodos. Aunque los metodos son cruciales para la programacion
   orientada a objetos, son solo la mitad de la imagen. Para completarla,
   necesitamos @e(interfaces), el tema del proximo capitulo.

# * Chapter 7 <> Interfaces
* Capitulo 7 <> Interfaces

#   Interface types express generalizations or abstractions about the behaviors of
#   other types. By generalizing, interfaces let us write functions that are more
#   flexible and adaptable because they are not tied to the details of one
#   particular implementation.
  Los tipos de interfaz expresan generalizaciones o abstracciones sobre los
  comportamientos de otros tipos. Al generalizar, las interfaces nos permiten
  escribir funciones que son mas flexibles y adaptables porque no estan
  vinculadas a los detalles de una implementacion en particular.

#   Many object-oriented languages have some notion of interfaces, but what makes
#   Go’s interfaces so distinctive is that they are @e(satisfied implicitly). In
#   other words, there’s no need to declare all the interfaces that a given
#   concrete type satisfies; simply possessing the necessary methods is
#   enough. This design lets you create new interfaces that are satisfied by
#   existing concrete types without changing the existing types, which is
#   particularly useful for types defined in packages that you don’t control.
  Muchos lenguajes orientados a objetos tienen alguna nocion de interfaces, pero
  lo que hace las interfaces de Go sean tan distintivas es que se @e(satisfacen
  de manera implicita). En otras palabras, no hay necesidad de declarar todas
  las interfaces que satisface un tipo determinado en concreto; Basta con poseer
  los metodos necesarios. Este diseño le permite crear nuevas interfaces que
  sean satisfechas por tipos concretos existentes sin cambiar los tipos
  existentes, lo cual es particularmente util para tipos definidos en paquetes
  que no controla.

#   In this chapter, we’ll start by looking at the basic mechanics of interface
#   types and their values.  Along the way, we’ll study several important
#   interfaces from the standard library. Many Go programs make as much use of
#   standard interfaces as they do of their own ones. Finally, we’ll look at
#   @e(type assertions) (@l(#Section 7.10<>§7.10)) and @e(type switches)
#   (@l(#Section 7.13<>§7.13)) and see how they enable a different kind of
#   generality.
  En este capitulo, comenzaremos examinando la mecanica basica de los tipos de
  interfaz y sus valores. En el camino, estudiaremos varias interfaces
  importantes de la libreria estandar. Muchos programas Go hacen uso intensivo
  de interfaces estandar como lo hacen con sus propios. Por ultimo, examinaremos
  los @e(tipos de aserciones) (@l(#Seccion 7.10<>§7.10)) y @e(switches de tipo)
  (@l(#Seccion 7.13<>§7.13)) y veremos como permiten un tipo diferente de
  generalidad.

# ** Section 7.1 <> Interfaces as Contracts
** Seccion 7.1 <> Interfaces como Contratos

#    All the types we’ve looked at so far have been @e(concrete types). A concrete
#    type specifies the exact representation of its values and exposes the
#    intrinsic operations of that representation, such as arithmetic for numbers,
#    or indexing, @c(append), and @c(range) for slices. A concrete type may also
#    provide additional behaviors through its methods. When you have a value of a
#    concrete type, you know exactly what it @e(is) and what you can @e(do) with
#    it.
   Todos los tipos que hemos visto hasta ahora han sido @e(tipos concretos). Un
   tipo concreto especifica la representacion exacta de sus valores y expone las
   operaciones intrinsecas de esa representacion, como la aritmetica para
   numeros, o indexacion, @c(append), y @c(range) para slices. Un tipo concreto
   tambien puede proporcionar comportamientos adicionales a traves de sus
   metodos. Cuando se tiene un valor de un tipo concreto, usted sabe exactamente
   lo que es y lo que puede hacer con el.

#    There is another kind of type in Go called an @e(interface type). An
#    interface is an @e(abstract type). It doesn’t expose the representation or
#    internal structure of its values, or the set of basic operations they
#    support; it reveals only some of their methods. When you have a value of an
#    interface type, you know nothing about what it @e(is); you know only what it
#    can @e(do), or more precisely, what behaviors are provided by its methods.
   Hay otro tipo en Go llama un @e(tipo de interfaz). Una interfaz es un tipo
   abstracto. No expone la representacion o estructura interna de sus valores,
   ni el conjunto de operaciones basicas que soporta; Revela solo algunos de sus
   metodos. Cuando se tiene un valor de un tipo interfaz, que no saben nada de
   lo que es; solo se sabe lo que puede hacer, o mas exactamente, que
   comportamientos son proporcionados por sus metodos.

#    Throughout the book, we’ve been using two similar functions for string
#    formatting: @c(fmt.Printf), which writes the result to the standard output (a
#    file), and @c(fmt.Sprintf), which returns the result as a @c(string). It
#    would be unfortunate if the hard part, formatting the result, had to be
#    duplicated because of these superficial differences in how the result is
#    used. Thanks to interfaces, it does not. Both of these functions are, in
#    effect, wrappers around a third function, @c(fmt.Fprintf), that is agnostic
#    about what happens to the result it computes:
   A lo largo del libro, hemos estado utilizando dos funciones similares para el
   formateo de cadenas: @c(fmt.Printf), que escribe el resultado a la salida
   estandar (un archivo), y @c(fmt.Sprintf), que devuelve el resultado como un
   @c(string). Seria lamentable que la parte dificil, el formato del resultado,
   tuviera que ser duplicado debido a estas diferencias superficiales en la
   forma en que el resultado se utiliza. Gracias a las interfaces, no lo
   hace. Ambas funciones son, en efecto, envolturas alrededor de una tercer
   funcion, @c(fmt.Fprintf), que es agnostico acerca de lo que ocurre con el
   resultado que calcula:

#    ..src > go
#      package fmt
#
#      func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)
#
#      func Printf(format string, args ...interface{}) (int, error) {
#        return Fprintf(os.Stdout, format, args...)
#      }
#
#      func Sprintf(format string, args ...interface{}) string {
#        var buf bytes.Buffer
#        Fprintf(&buf, format, args...)
#        return buf.String()
#      }
#    < src..
   ..src > go
     package fmt

     func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)

     func Printf(format string, args ...interface{}) (int, error) {
       return Fprintf(os.Stdout, format, args...)
     }

     func Sprintf(format string, args ...interface{}) string {
       var buf bytes.Buffer
       Fprintf(&buf, format, args...)
       return buf.String()
     }
   < src..

#    The @c(F) prefix of @c(Fprintf) stands for @e(file) and indicates that the
#    formatted output should be written to the file provided as the first
#    argument. In the @c(Printf) case, the argument, @c(os.Stdout), is an
#    @c(*os.File). In the @c(Sprintf) case, however, the argument is not a file,
#    though it superficially resembles one: @c(&buf) is a pointer to a memory
#    buffer to which bytes can be written.
   El prefijo @c(F) de @c(Fprintf) significa @e(file) (archivo) e indica que la
   salida formateada se debe escribir en el fichero proporcionado como primer
   argumento. En el caso de @c(Printf), el argumento, @c(os.Stdout), es un
   @c(*os.File). En el caso @c(Sprintf), sin embargo, el argumento no es un
   archivo, aunque se asemeja superficialmente a uno: @c(&buf) es un puntero a
   un bufer de memoria a la que se pueden escribir bytes.

#    The first parameter of @c(Fprintf) is not a file either. It’s an
#    @c(io.Writer), which is an interface type with the following declaration:
   El primer parametro de @c(Fprintf) no es un archivo cualquiera. Es un
   @c(io.Writer), que es un tipo de interfaz con la siguiente declaracion:

#    ..src > go
#      package io
#
#      // Writer is the interface that wraps the basic Write method.
#      type Writer interface {
#        // Write writes len(p) bytes from p to the underlying data stream.
#        // It returns the number of bytes written from p (0 <= n <= len(p))
#        // and any error encountered that caused the write to stop early.
#        // Write must return a non-nil error if it returns n < len(p).
#        // Write must not modify the slice data, even temporarily.
#        //
#        // Implementations must not retain p.
#        Write(p []byte) (n int, err error)
#      }
#    < src..
   ..src > go
     package io

     // Writer es la interfaz que envuelve el metodo de escritura basico.
     type Writer interface {
       // Write escribe len(p) bytes de p en el flujo de datos subyacentes.
       // Devuelve el numero de bytes escritos de p (0 <= n <= len(p))
       // y cualquier error encontrado que causo un paro temprano en la escritura.
       // Write debe regresar un error no-nil si devulve n < len(p).
       // Write no debe modificar los datol del slice, ni siquier temporalmente.
       //
       // Las imprementaciones no deben retener a p.
       Write(p []byte) (n int, err error)
     }
   < src..

#    The @c(io.Writer) interface defines the contract between @c(Fprintf) and its
#    callers. On the one hand, the contract requires that the caller provide a
#    value of a concrete type like @c(*os.File) or @c(*bytes.Buffer) that has a
#    method called @c(Write) with the appropriate signature and behavior.  On the
#    other hand, the contract guarantees that @c(Fprintf) will do its job given
#    any value that satisfies the @c(io.Writer) interface. @c(Fprintf) may not
#    assume that it is writing to a file or to memory, only that it can call
#    @c(Write).
   La interfaz @c(io.Writer) define el contrato entre @c(Fprintf) y sus
   interlocutores. Por un lado, el contrato requiere que el llamador proporcione
   un valor de un tipo concreto como @c(*os.File) o @c(*bytes.Buffer) que tiene
   un metodo denominado @c(Write) con la firma y el comportamiento apropiado.
   Por otra parte, el contrato garantiza que @c(Fprintf) hara su trabajo dando
   cualquier valor que satisfaga la interfaz @c(io.Writer). @c(Fprintf) no puede
   asumir que se esta escribiendo en un archivo o en la memoria, solo que se
   puede llamar a @c(Write).

#    Because @c(fmt.Fprintf) assumes nothing about the representation of the value
#    and relies only on the behaviors guaranteed by the @c(io.Writer) contract, we
#    can safely pass a value of any concrete type that satisfies @c(io.Writer) as
#    the first argument to @c(fmt.Fprintf). This freedom to substitute one type
#    for another that satisfies the same interface is called @e(substitutability),
#    and is a hallmark of object-oriented programming.
   Ya que @c(fmt.Fprintf) no asume nada acerca de la representacion del valor y
   se basa unicamente en los comportamientos garantizados por el contrato
   @c(io.Writer), podemos pasar con seguridad un valor concreto de cualquier
   tipo que satisfaga @c(io.Writer) como primer argumento de
   @c(fmt.Fprintf). Esta libertad para sustituir un tipo por otro que satisface
   la misma interfaz se denomina @e(sustituibilidad), y es una caracteristica de
   la programacion orientada a objetos.

#    Let’s test this out using a new type. The @c(Write) method of the
#    @c(*ByteCounter) type below merely counts the bytes written to it before
#    discarding them. (The conversion is required to make the types of @c[len(p)]
#    and @c(*c) match in the @c(+=) assignment statement.)
   Vamos a probar esto usando un nuevo tipo. A continuacion el metodo @c(Write)
   del tipo @c(*ByteCounter) simplemente cuenta los bytes escritos antes de
   descartarlos. (La conversion se requiere para hacer que los tipos de
   @c[len(p)] y @c(*c) coincidan en la sentencia de asignacion @c(+=).)

#    ..figure > @l(gopl.io/ch7/bytecounter/main.go<>gopl.io/ch7/bytecounter)
   ..figure > @l(gopl.io/ch7/bytecounter/main.go<>gopl.io/ch7/bytecounter)

#      ..src > go
#        type ByteCounter int
#
#        func (c *ByteCounter) Write(p []byte) (int, error) {
#          *c += ByteCounter(len(p)) // convert int to ByteCounter
#          return len(p), nil
#        }
#      < src..
     ..src > go
       type ByteCounter int

       func (c *ByteCounter) Write(p []byte) (int, error) {
         *c += ByteCounter(len(p)) // convert int to ByteCounter
         return len(p), nil
       }
     < src..


#    Since @c(*ByteCounter) satisfies the @c(io.Writer) contract, we can pass it
#    to @c(Fprintf), which does its string formatting oblivious to this change;
#    the @c(ByteCounter) correctly accumulates the length of the result.
   Puesto que @c(*ByteCounter) satisface el contrato @c(io.Writer), podemos
   pasarlo a @c(Fprintf), que hace su formato de cadenas ajeno a este cambio;
   @c(ByteCounter) acumula correctamente la longitud del resultado.

#    ..src > go
#      var c ByteCounter
#      c.Write([]byte("hello"))
#      fmt.Println(c) // "5", = len("hello")
#
#      c = 0 // reset the counter
#      var name = "Dolly"
#      fmt.Fprintf(&c, "hello, %s", name)
#      fmt.Println(c) // "12", = len("hello, Dolly")
#    < src..
   ..src > go
     var c ByteCounter
     c.Write([]byte("hello"))
     fmt.Println(c) // "5", = len("hello")

     c = 0          // reinicia el contador
     var name = "Dolly"
     fmt.Fprintf(&c, "hello, %s", name)
     fmt.Println(c) // "12", = len("hello, Dolly")
   < src..

#    Besides @c(io.Writer), there is another interface of great importance to the
#    @c(fmt) package. @c(Fprintf) and @c(Fprintln) provide a way for types to
#    control how their values are printed. In @l(#Section 2.5), we defined a
#    @c(String) method for the @c(Celsius) type so that temperatures would print
#    as @c("100°C"), and in @l(#Section 6.5) we equipped @c(*IntSet) with a
#    @c(String) method so that sets would be rendered using traditional set
#    notation like @c("{1 2 3}"). Declaring a @c(String) method makes a type
#    satisfy one of the most widely used interfaces of all, @c(fmt.Stringer):
   Ademas de @c(io.Writer), hay otra interfaz de gran importancia para el
   paquete @c(fmt). @c(Fprintf) y @c(Fprintln) proporcionan una forma para que
   los tipos controles como se imprimen sus valores. En la @l(#Seccion 2.5),
   definimos un metodo @c(String) para el tipo @c(Celsius) de modo que las
   temperaturas se impriman como @c("100°C"), y en la @l(#Seccion 6.5) hemos
   equipado a @c(*IntSet) con un metodo @c(String) de modo que los conjuntos
   fueran renderizados utilizando la notacion de conjuntos tradicional como
   @c("{1 2 3}"). La declaracion de un metodo @c(String) hace que un tipo
   satisfaga una de las interfaces mas utilizados de todas, @c(fmt.Stringer):

#    ..src > go
#      package fmt
#
#      // The String method is used to print values passed
#      // as an operand to any format that accepts a string
#      // or to an unformatted printer such as Print.
#      type Stringer interface {
#        String() string
#      }
#    < src..
   ..src > go
     package fmt

     // El metodo String se utiliza para imprimr los valores recividos
     // como un operando de cualquier formato que acepte una cadena
     // o una impresion sin formato como Print.
     type Stringer interface {
       String() string
     }
   < src..

#    We’ll explain how the @c(fmt) package discovers which values satisfy this
#    interface in @l(#Section 7.10).
   Vamos a explicar como el paquete @c(fmt) descubre que valores satisfacen esta
   interfaz en la @l(#Seccion 7.10).

#    @b(Exercise 7.1): Using the ideas from @c(ByteCounter), implement counters
#    for words and for lines.  You will find @c(bufio.ScanWords) useful.
   @b(Ejercicio 7.1): Haciendo uso de las ideas de @c(ByteCounter), implementar
   contadores para lineas y palabras. Puedes encontrar util @c(bufio.ScanWords).

#    @b(Exercise 7.2): Write a function @c(CountingWriter) with the signature
#    below that, given an @c(io.Writer), returns a new @c(Writer) that wraps the
#    original, and a pointer to an @c(int64) variable that at any moment contains
#    the number of bytes written to the new @c(Writer).
   @b(Ejercicio 7.2): Escribir una funcion @c(CountingWriter) con la firma de
   abajo que, pasando un @c(io.Writer), devuelva un nuevo @c(Writer) que
   envuelva el original, y un puntero a una variable @c(int64) que contenga en
   cualquier momento el numero de bytes escritos en el nuevo @c(Writer) .

#    ..src > go
#      func CountingWriter(w io.Writer) (io.Writer, *int64)
#    < src..
   ..src > go
     func CountingWriter(w io.Writer) (io.Writer, *int64)
   < src..

#    @b(Exercise 7.3): Write a @c(String) method for the @c(*tree) type in
#    @c(gopl.io/ch4/treesort) (@l(#Section 4.4<>§4.4)) that reveals the sequence
#    of values in the tree.
   @b(Ejercicio 7.3): Escribir un metodo @c(String) para el tipo @c(*tree) de
   @c(gopl.io/ch4/treesort) (@l(#Seccion 4.4<>§4.4)) que revela la secuencia de
   valores en el arbol.

# ** Section 7.2 <> Interface Types
** Seccion 7.2 <> Tipos de Interfaz

#    An interface type specifies a set of methods that a concrete type must
#    possess to be considered an instance of that interface.
   Un tipo de interfaz especifica un conjunto de metodos que un tipo de concreto
   debe poseer para ser considerado una instancia de esa interfaz.

#    The @c(io.Writer) type is one of the most widely used interfaces because it
#    provides an abstraction of all the types to which bytes can be written, which
#    includes files, memory buffers, network connections, HTTP clients, archivers,
#    hashers, and so on. The @c(io) package defines many other useful interfaces.
#    A @c(Reader) represents any type from which you can read bytes, and a
#    @c(Closer) is any value that you can close, such as a file or a network
#    connection. (By now you’ve probably noticed the naming convention for many of
#    Go’s single-method interfaces.)
   El tipo @c(io.Writer) es una de las interfaces mas utilizados, ya que
   proporciona una abstraccion de todos los tipos a los que se pueden escribir
   bytes, que incluye archivos, buffers de memoria, conexiones de red, clientes
   HTTP, archivadores, hashers, etc. El paquete @c(io) define muchas otras
   interfaces utiles. Un @c(Reader) representa cualquier tipo del que se puede
   leer bytes, y un @c(Closer) es cualquier valor que se puede cerrar, como un
   archivo o una conexion de red. (Por ahora probablemente has notado la
   convencion de nomenclatura para muchas de las interfaces de metodo unico de
   Go).

#    ..src > go
#      package io
#
#      type Reader interface {
#        Read(p []byte) (n int, err error)
#      }
#
#      type Closer interface {
#        Close() error
#      }
#    < src..
   ..src > go
     package io

     type Reader interface {
       Read(p []byte) (n int, err error)
     }

     type Closer interface {
       Close() error
     }
   < src..

#    Looking farther, we find declarations of new interface types as combinations
#    of existing ones.  Here are two examples:
   Mirando mas lejos, encontramos declaraciones de nuevos tipos de interfaz como
   combinaciones de los ya existentes. He aqui dos ejemplos:

#    ..src > go
#      type ReadWriter interface {
#        Reader
#        Writer
#      }
#
#      type ReadWriteCloser interface {
#        Reader
#        Writer
#        Closer
#      }
#    < src..
   ..src > go
     type ReadWriter interface {
       Reader
       Writer
     }

     type ReadWriteCloser interface {
       Reader
       Writer
       Closer
     }
   < src..

#    The syntax used above, which resembles struct embedding, lets us name another
#    interface as a shorthand for writing out all of its methods. This is called
#    @e(embedding) an interface. We could have written @c(io.ReadWriter) without
#    embedding, albeit less succinctly, like this:
   La sintaxis utilizada, se asemeja al enbebido de estructuras, nos permite
   nombrar otra interfaz como una abreviatura para escribir todos sus
   metodos. Esto se conoce denomina como @e(embeber) una interfaz. Podriamos
   haber escrito @c(io.ReadWriter) sin enbeberla, aunque de manera menos
   sucinta, como aqui:

#    ..src > go
#      type ReadWriter interface {
#        Read(p []byte) (n int, err error)
#        Write(p []byte) (n int, err error)
#      }
#    < src..
   ..src > go
     type ReadWriter interface {
       Read(p []byte) (n int, err error)
       Write(p []byte) (n int, err error)
     }
   < src..

#    or even using a mixture of the two styles:
   o incluso utilizando una mezcla de los dos estilos:

#    ..src > go
#      type ReadWriter interface {
#        Read(p []byte) (n int, err error)
#        Writer
#      }
#    < src..
   ..src > go
     type ReadWriter interface {
       Read(p []byte) (n int, err error)
       Writer
     }
   < src..

#    All three declarations have the same effect. The order in which the methods
#    appear is immaterial. All that matters is the set of methods.
   Las tres declaraciones tienen el mismo efecto. El orden en que aparecen los
   metodos es irrelevante. Todo lo que importa es el conjunto de metodos.

#    @b(Exercise 7.4): The @c(strings.NewReader) function returns a value that
#    satisfies the @c(io.Reader) interface (and others) by reading from its
#    argument, a string. Implement a simple version of @c(NewReader) yourself, and
#    use it to make the HTML parser (@l(#Section 5.2<>§5.2)) take input from a
#    string.
   @b(Ejercicio 7.4): La funcion @c(strings.NewReader) devuelve un valor que
   satisface la interfaz @c(io.Reader) (y otras) mediante la lectura de su
   argumento, una cadena. Implementa tu mismo una version simple de
   @c(NewReader), y utilizala para hacer que el analizador de HTML (@l(#Seccion
   5.2<>§5.2)) tome la entrada de una cadena.

#    @b(Exercise 7.5): The @c(LimitReader) function in the @c(io) package accepts
#    an @c(io.Reader) @c(r) and a number of bytes @c(n), and returns another
#    @c(Reader) that reads from @c(r) but reports an end-of-file condition after
#    @c(n) bytes. Implement it.
   @b(Ejercicio 7.5): La funcion @c(LimitReader) en el paquete @c(io) acepta un
   @c(io.Reader) @c(r) y un numero de bytes @c(n), y devuelve otro @c(Reader)
   que lee desde @c(r) pero reporta una condicion de fin de archivo despues de
   @c(n) bytes. Implementalo.

#    ..src > go
#      func LimitReader(r io.Reader, n int64) io.Reader
#    < src..
   ..src > go
     func LimitReader(r io.Reader, n int64) io.Reader
   < src..

# ** Section 7.3 <> Interface Satisfaction
** Seccion 7.3 <> Satisfaccion de la Interfaz

#    A type @e(satisfies) an interface if it possesses all the methods the
#    interface requires. For example, an @c(*os.File) satisfies @c(io.Reader),
#    @c(Writer), @c(Closer), and @c(ReadWriter). A @c( *bytes.Buffer) satisfies
#    @c(Reader), @c(Writer), and @c(ReadWriter), but does not satisfy @c(Closer)
#    because it does not have a @c(Close) method. As a shorthand, Go programmers
#    often say that a concrete type @"(is a) particular interface type, meaning
#    that it satisfies the interface. For example, a @c(*bytes.Buffer) is an
#    @c(io.Writer); an @c(*os.File) is an @c(io.ReadWriter).
   Un tipo satisface una interfaz si posee todos los metodos que la interfaz
   requiere. Por ejemplo, un @c(*os.File) satisface @c(io.Reader), @c(Writer),
   @c(Closer), y @c(ReadWriter). Un @c(*bytes.Buffer) satisface @c(Reader),
   @c(Writer), y @c(ReadWriter), pero no satisfacer @c(Closer), ya que no tiene
   un metodo @c(Close). Como una abreviatura, los programadores de Go a menudo
   dicen que un tipo concreto @"(es un) tipo de interfaz en particular, lo que
   significa que satisface la interfaz. Por ejemplo, un @c(*bytes.Buffer) es un
   @c(io.Writer); un @c(*os.File) es un @c(io.ReadWriter).

#    The assignability rule (@l(#Section 2.4.2<>§2.4.2)) for interfaces is very
#    simple: an expression may be assigned to an interface only if its type
#    satisfies the interface. So:
   La regla de asignabilidad (@l(#Seccion 2.4.2<>§2.4.2)) para interfaces es muy
   simple: una expresion puede ser asignada a una interfaz solo si su tipo se
   ajusta a la interfaz. Asi que:

#    ..src > go
#      var w io.Writer
#      w = os.Stdout           // OK: *os.File has Write method
#      w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method
#      w = time.Second         // compile error: time.Duration lacks Write method
#
#      var rwc io.ReadWriteCloser
#      rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods
#      rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method
#    < src..
   ..src > go
     var w io.Writer
     w = os.Stdout           // OK: *os.File tiene metodo Write
     w = new(bytes.Buffer)   // OK: *bytes.Buffer tiene metodo Write
     w = time.Second         // error de compilacion: time.Duration carece de metodo Write

     var rwc io.ReadWriteCloser
     rwc = os.Stdout         // OK: *os.File tiene metodos Read, Write, Close
     rwc = new(bytes.Buffer) // error de compilacion: *bytes.Buffer carece de metodo Close
   < src..

#    This rule applies even when the right-hand side is itself an interface:
   Esta regla se aplica incluso cuando el lado derecho es en si mismo una
   interfaz:

#    ..src > go
#      w = rwc                 // OK: io.ReadWriteCloser has Write method
#      rwc = w                 // compile error: io.Writer lacks Close method
#    < src..
   ..src > go
     w = rwc                 // OK: io.ReadWriteCloser tiene metodo Write
     rwc = w                 // error de compilacion: io.Writer carece de metodo Close
   < src..

#    Because @c(ReadWriter) and @c(ReadWriteCloser) include all the methods of
#    @c(Writer), any type that satisfies @c(ReadWriter) or @c(ReadWriteCloser)
#    necessarily satisfies @c(Writer).
   Como @c(ReadWriter) y @c(ReadWriteCloser) incluyen todos los metodos de
   @c(Writer), cualquier tipo que satisface @c(ReadWriter) o @c(ReadWriteCloser)
   satisface @c(Writer) necesariamente.

#    Before we go further, we should explain one subtlety in what it means for a
#    type to have a method. Recall from @l(#Section 6.2) that for each named
#    concrete type @c(T), some of its methods have a receiver of type @c(T) itself
#    whereas others require a @c(*T) pointer. Recall also that it is legal to call
#    a @c(*T) method on an argument of type @c(T) so long as the argument is a
#    @e(variable); the compiler implicitly takes its address. But this is mere
#    syntactic sugar: a value of type @c(T) does not possess all the methods that
#    a @c(*T) pointer does, and as a result it might satisfy fewer interfaces.
   Antes de ir mas lejos, debemos explicar una sutileza en lo que significa para
   un tipo tener un metodo. Recuerde de la @l(#Seccion 6.2) que para cada tipo
   concreto llamado @c(T), algunos de sus metodos tienen un receptor de tipo
   @c(T), mientras que otros requieren un puntero @c(*T). Recordemos tambien que
   es legal para llamar a un metodo @c(*T) en un argumento de tipo @c(T),
   siempre y cuando el argumento sea una variable; El compilador toma
   implicitamente su direccion. Pero esto es mero azucar sintactico: un valor de
   tipo @c(T) no posee todos los metodos que tiene un puntero @c(*T), y como
   resultado podria satisfacer menos interfaces.

#    An example will make this clear. The @c(String) method of the @c(IntSet) type
#    from @l(#Section 6.5) requires a pointer receiver, so we cannot call that
#    method on a non-addressable @c(IntSet) value:
   Un ejemplo lo hara claro. El metodo @c(String) del tipo @c(IntSet) de la
   @l(#Seccion 6.5) requiere un receptor puntero, asi que no podemos llamar a
   ese metodo en un valor @c(IntSet) no direccionable:

#    ..src > go
#      type IntSet struct { /* ... */ }
#      func (*IntSet) String() string
#
#      var _ = IntSet{}.String() // compile error: String requires *IntSet receiver
#    < src..
   ..src > go
     type IntSet struct { /* ... */ }
     func (*IntSet) String() string

     var _ = IntSet{}.String() // error de compilacion: String requiere un receptor *intSet
   < src..

#    but we can call it on an @c(IntSet) variable:
   pero podemos decir que es una variables @c(IntSet):

#    ..src > go
#      var s IntSet
#      var _ = s.String() // OK: s is a variable and &s has a String method
#    < src..
   ..src > go
     var s IntSet
     var _ = s.String() // OK: s es una variable y &s tiene el metodo String
   < src..

#    However, since only @c(*IntSet) has a @c(String) method, only @c(*IntSet)
#    satisfies the @c(fmt.Stringer) interface:
   Sin embargo, puesto que solamente @c(*IntSet) tiene un metodo @c(String),
   solamente @c(*IntSet) satisface la interfaz @c(fmt.Stringer):

#    ..src > go
#      var _ fmt.Stringer = &s // OK
#      var _ fmt.Stringer = s  // compile error: IntSet lacks String method
#    < src..
   ..src > go
     var _ fmt.Stringer = &s // OK
     var _ fmt.Stringer = s  // error de compilacion: IntSet carece de metodo String
   < src..

#    @l(#Section 12.8) includes a program that prints the methods of an arbitrary
#    value, and the @$(godoc -analysis=type) tool (@l(#Section 10.7.4<>§10.7.4))
#    displays the methods of each type and the relationship between interfaces and
#    concrete types.
   La @l(#Seccion 12.8) incluye un programa que imprime los metodos de un valor
   arbitrario, y la herramienta @$(godoc -analysis=type) (@l(#Seccion
   10.7.4<>§10.7.4)) muestra los metodos de cada tipo y la relacion entre las
   interfaces y tipos concretos.

#    Like an envelope that wraps and conceals the letter it holds, an interface
#    wraps and conceals the concrete type and value that it holds. Only the
#    methods revealed by the interface type may be called, even if the concrete
#    type has others:
   Como un sobre que envuelve y oculta la carta que contiene, una interfaz
   envuelve y oculta el tipo concreto y el valor que contiene. Solo los metodos
   revelados por el tipo de interfaz pueden ser llamados, incluso si el tipo
   concreto tiene otros:

#    ..src > go
#      os.Stdout.Write([]byte("hello")) // OK: *os.File has Write method
#      os.Stdout.Close()                // OK: *os.File has Close method
#
#      var w io.Writer
#      w = os.Stdout
#      w.Write([]byte("hello")) // OK: io.Writer has Write method
#      w.Close()                // compile error: io.Writer lacks Close method
#    < src..
   ..src > go
     os.Stdout.Write([]byte("hello")) // OK: *os.File tiene el metodo Write
     os.Stdout.Close()                // OK: *os.File tiene el metodo Close

     var w io.Writer
     w = os.Stdout
     w.Write([]byte("hello")) // OK: io.Writer tiene el metodo Write
     w.Close()                // compile error: io.Writer carece del metodo Close
   < src..

#    An interface with more methods, such as @c(io.ReadWriter), tells us more
#    about the values it contains, and places greater demands on the types that
#    implement it, than does an interface with fewer methods such as
#    @c(io.Reader). So what does the type @c(interface{}), which has no methods at
#    all, tell us about the concrete types that satisfy it?
   Una interfaz con mas metodos, como @c(io.ReadWriter), nos dice mas acerca de
   los valores que contiene, y coloca mayores demandas sobre los tipos que la
   implementan, que un interfaz con un menos metodos como @c(io.Reader).
   Entonces, que hace el tipo @c(interface{}), que no tiene ningun metodo en
   absoluto, nos cuenta sobre los tipos concretos que lo satisfacen?

#    That’s right: nothing. This may seem useless, but in fact the type
#    @c(interface{}), which is called the @e(empty interface) type, is
#    indispensable. Because the empty interface type places no demands on the
#    types that satisfy it, we can assign @e(any) value to the empty interface.
   Eso es correcto: nada. Esto puede parecer inutil, pero en realidad el tipo
   @c(interface{}), que se denomina el tipo de @e(interfaz vacia), es
   indispensable. Debido a que el tipo de interfaz vacia no impone exigencias a
   los tipos que lo satisfacen, podemos asignar @e(cualquier) valor a la
   interfaz vacia.

#    ..src > go
#      var any interface{}
#      any = true
#      any = 12.34
#      any = "hello"
#      any = map[string]int{"one": 1}
#      any = new(bytes.Buffer)
#    < src..
   ..src > go
     var any interface{}
     any = true
     any = 12.34
     any = "hello"
     any = map[string]int{"one": 1}
     any = new(bytes.Buffer)
   < src..

#    Although it wasn’t obvious, we’ve been using the empty interface type since
#    the very first example in this book, because it is what allows functions like
#    @c(fmt.Println), or @c(errorf) in @l(#Section 5.7), to accept arguments of
#    any type.
   A pesar de que no ser obvio, hemos utilizando el tipo de interfaz vacia desde
   el primer ejemplo en este libro, porque es lo que permite que funciones como
   @c(fmt.Println), o @c(errorf) en la @l(#Seccion 5.7), acepten argumentos de
   cualquier tipo.

#    Of course, having created an @c(interface{}) value containing a boolean,
#    float, string, map, pointer, or any other type, we can do nothing directly to
#    the value it holds since the interface has no methods. We need a way to get
#    the value back out again. We’ll see how to do that using a @e(type assertion)
#    in @l(#Section 7.10).
   Por supuesto, despues de crear un valor @c(interface{}) que contiene un valor
   booleano, float, string, mapa, puntero, o de cualquier otro tipo, no podemos
   hacer nada directamente con el valor que posee ya que la interfaz no tiene
   metodos. Necesitamos una forma de recuperar el valor nuevamente. Veremos como
   hacerlo utilizando un @e(tipo de asercion) en la @l(#Seccion 7.10).

#    Since interface satisfaction depends only on the methods of the two types
#    involved, there is no need to declare the relationship between a concrete
#    type and the interfaces it satisfies. That said, it is occasionally useful to
#    document and assert the relationship when it is intended but not otherwise
#    enforced by the program. The declaration below asserts at compile time that a
#    value of type @c(*bytes.Buffer) satisfies @c(io.Writer):
   Dado que la satisfaccion de la interfaz depende solo de los metodos de los
   dos tipos implicados, no hay necesidad de declarar la relacion entre un tipo
   concreto y las interfaces que satisface. Dicho esto, ocasionalmente es util
   documentar y afirmar la relacion cuando se pretende, pero no se aplica de
   otro modo por el programa. La declaracion a continuacion afirma en tiempo de
   compilacion que un valor de tipo @c(*bytes.Buffer) satisface @c(io.Writer):

#    ..src > go
#      // *bytes.Buffer must satisfy io.Writer
#      var w io.Writer = new(bytes.Buffer)
#    < src..
   ..src > go
     // *bytes.Buffer debe satirfacer io.Writer
     var w io.Writer = new(bytes.Buffer)
   < src..

#    We needn’t allocate a new variable since any value of type @c(*bytes.Buffer)
#    will do, even @c(nil), which we write as @c[(*bytes.Buffer)(nil)] using an
#    explicit conversion. And since we never intend to refer to @c(w), we can
#    replace it with the blank identifier. Together, these changes give us this
#    more frugal variant:
   No tenemos que asignar una nueva variable, ya que cualquier valor de tipo
   @c(*bytes.Buffer) lo hara, incluso @c(nil), que escribimos como
   @c[(*bytes.Buffer)(nil)] mediante una conversion explicita. Y ya que nunca
   intentamos referirnos a @c(w), podemos sustituirlo por el identificador en
   blanco. Juntos, estos cambios nos dan esta variante mas frugal:

#    ..src > go
#      // *bytes.Buffer must satisfy io.Writer
#      var _ io.Writer = (*bytes.Buffer)(nil)
#    < src..
   ..src > go
     // *bytes.Buffer debe satisfacer io.Writer
     var _ io.Writer = (*bytes.Buffer)(nil)
   < src..

#    Non-empty interface types such as @c(io.Writer) are most often satisfied by a
#    pointer type, particularly when one or more of the interface methods implies
#    some kind of mutation to the receiver, as the @c(Write) method does. A
#    pointer to a struct is an especially common methodbearing type.
   Los tipos de interfaces no-vacios como io.Writer suelen ser satisfechos por
   un tipo de puntero, sobre todo cuando uno o mas de los metodos de interfaz
   implica algun tipo de mutacion en el receptor, como la hace el metodo
   @c(Write). Un puntero a una estructura es un tipo de metodo especialmente comun.

#    But pointer types are by no means the only types that satisfy interfaces, and
#    even interfaces with mutator methods may be satisfied by one of Go’s other
#    reference types. We’ve seen examples of slice types with methods
#    (@c(geometry.Path), @l(#Section 6.1<>§6.1)) and map types with methods
#    (@c(url.Values), @l(#Section 6.2.1<>§6.2.1)), and later we’ll see a function
#    type with methods (@c(http.HandlerFunc), @l(#Section 7.7<>§7.7)). Even basic
#    types may satisfy interfaces; as we saw in @l(#Section 7.4),
#    @c(time.Duration) satisfies @c(fmt.Stringer).
   Pero los tipos de puntero no son de ninguna manera los unicos tipos que
   satisfacen las interfaces, e incluso las interfaces con los metodos mutator
   pueden ser satisfechas por uno de los otros tipos de referencia de Go. Hemos
   visto ejemplos de tipos de slice con metodos (@c(geometry.Path), @l(#Seccion
   6.1<>§6.1)) y tipos de mapas con metodos (@c(url.Values), @l(#Seccion
   6.2.1<>§6.2.1)), y mas adelante veremos un tipo de funcion con metodos
   (@c(http.HandlerFunc), @l(#Seccion 7.7<>§7.7)). Incluso los tipos basicos
   pueden satisfacer interfaces; como vimos en la @l(#Seccion 7.4), @c(time.Duration)
   satisface @c(fmt.Stringer).

#    A concrete type may satisfy many unrelated interfaces. Consider a program
#    that organizes or sells digitized cultural artifacts like music, films, and
#    books. It might define the following set of concrete types:
   Un tipo concreto puede satisfacer muchas interfaces no relacionadas.
   Considere un programa que organiza o vende artefactos culturales
   digitalizados como musica, peliculas y libros. Podria definir el siguiente
   conjunto de tipos concretos:

#    ..pre >
#      Album
#      Book
#      Movie
#      Magazine
#      Podcast
#      TVEpisode
#      Track
   ..pre >
     Album
     Book
     Movie
     Magazine
     Podcast
     TVEpisode
     Track

#    We can express each abstraction of interest as an interface. Some properties
#    are common to all artifacts, such as a title, a creation date, and a list of
#    creators (authors or artists).
   Podemos expresar cada abstraccion de interes como una interfaz. Algunas
   propiedades son comunes a todos los artefactos, como un titulo, una fecha de
   creacion y una lista de creadores (autores o artistas).

#    ..src > go
#      type Artifact interface {
#        Title() string
#        Creators() []string
#        Created() time.Time
#      }
#    < src..
   ..src > go
     type Artifact interface {
       Title() string
       Creators() []string
       Created() time.Time
     }
   < src..

#    Other properties are restricted to certain types of artifacts. Properties of
#    the printed word are relevant only to books and magazines, whereas only
#    movies and TV episodes have a screen resolution.
   Otras propiedades estan restringidas a ciertos tipos de artefactos. Las
   propiedades de @c(printed_word) solo son relevantes para libros y revistas,
   mientras que solo las peliculas y episodios de television tienen una
   resolucion de pantalla.

#    ..src > go
#      type Text interface {
#        Pages() int
#        Words() int
#        PageSize() int
#      }
#
#      type Audio interface {
#        Stream() (io.ReadCloser, error)
#        RunningTime() time.Duration
#        Format() string // e.g., "MP3", "WAV"
#      }
#
#      type Video interface {
#        Stream() (io.ReadCloser, error)
#        RunningTime() time.Duration
#        Format() string // e.g., "MP4", "WMV"
#        Resolution() (x, y int)
#      }
#    < src..
   ..src > go
     type Text interface {
       Pages() int
       Words() int
       PageSize() int
     }

     type Audio interface {
       Stream() (io.ReadCloser, error)
       RunningTime() time.Duration
       Format() string // e.g., "MP3", "WAV"
     }

     type Video interface {
       Stream() (io.ReadCloser, error)
       RunningTime() time.Duration
       Format() string // e.g., "MP4", "WMV"
       Resolution() (x, y int)
     }
   < src..

#    These interfaces are but one useful way to group related concrete types
#    together and express the facets they share in common. We may discover other
#    groupings later. For example, if we find we need to handle @c(Audio) and
#    @c(Video) items in the same way, we can define a @c(Streamer) interface to
#    represent their common aspects without changing any existing type
#    declarations.
   Estas interfaces no son sino una forma util de agrupar tipos concretos
   relacionados y expresar las facetas que comparten en comun. Podemos descubrir
   otras agrupaciones mas tarde. Por ejemplo, si descubrimos que necesitamos
   manejar elementos de @c(Audio) y @c(Video) de la misma manera, podemos
   definir una interfaz @c(Streamer) para representar sus aspectos comunes sin
   cambiar ninguna declaracion de tipos existentes.

#    ..src > go
#      type Streamer interface {
#        Stream() (io.ReadCloser, error)
#        RunningTime() time.Duration
#        Format() string
#      }
#    < src..
   ..src > go
     type Streamer interface {
       Stream() (io.ReadCloser, error)
       RunningTime() time.Duration
       Format() string
     }
   < src..

#    Each grouping of concrete types based on their shared behaviors can be
#    expressed as an interface type. Unlike class-based languages, in which the
#    set of interfaces satisfied by a class is explicit, in Go we can define new
#    abstractions or groupings of interest when we need them, without modifying
#    the declaration of the concrete type. This is particularly useful when the
#    concrete type comes from a package written by a different author. Of course,
#    there do need to be underlying commonalities in the concrete types.
   Cada agrupacion de tipos concretos basados ​​en sus comportamientos compartidos
   puede expresarse como un tipo de interfaz. A diferencia de los lenguajes
   basados ​​en clases, en los que el conjunto de interfaces satisfecho por una
   clase es explicito, en Go podemos definir nuevas abstracciones o agrupaciones
   de interes cuando las necesitamos, sin modificar la declaracion del tipo
   concreto. Esto es particularmente util cuando el tipo concreto proviene de un
   paquete escrito por un autor diferente. Por supuesto, es necesario que haya
   puntos comunes subyacentes en los tipos concretos.

# ** Section 7.4 <> Parsing Flags with @c(flag.Value)
** Seccion 7.4 <> Analizar Banderas con @c(flag.Value)

#    In this section, we’ll see how another standard interface, @c(flag.Value),
#    helps us define new notations for command-line flags. Consider the program
#    below, which sleeps for a specified period of time.
   En esta seccion, vamos a ver como otro interfaz estandar, @c(flag.Value), nos
   ayuda a definir nuevas notaciones de opciones de linea de comandos. Considere
   el programa a continuacion, que duerme durante un periodo de tiempo
   especificado.

#    ..figure > @l(gopl.io/ch7/sleep/sleep.go<>gopl.io/ch7/sleep)
   ..figure > @l(gopl.io/ch7/sleep/sleep.go<>gopl.io/ch7/sleep)

#      ..src > go
#        var period = flag.Duration("period", 1*time.Second, "sleep period")
#
#        func main() {
#          flag.Parse()
#          fmt.Printf("Sleeping for %v...", *period)
#          time.Sleep(*period)
#          fmt.Println()
#        }
#      < src..
     ..src > go
       var period = flag.Duration("period", 1*time.Second, "sleep period")

       func main() {
         flag.Parse()
         fmt.Printf("Sleeping for %v...", *period)
         time.Sleep(*period)
         fmt.Println()
       }
     < src..


#    Before it goes to sleep it prints the time period. The @c(fmt) package calls
#    the @c(time.Duration)’s @c(String) method to print the period not as a number
#    of nanoseconds, but in a user-friendly notation:
   Antes de que se vaya a dormir imprime el periodo de tiempo. El paquete
   @c(fmt) llama al metodo @c(String) de @c(time.Duration) para imprimir el
   periodo no como un numero de nanosegundos, sino en una notacion facil de
   usar:

#    ..src > sh
#      $ go build gopl.io/ch7/sleep
#      $ ./sleep
#      Sleeping for 1s...
#    < src..
   ..src > sh
     $ go build gopl.io/ch7/sleep
     $ ./sleep
     Sleeping for 1s...
   < src..

#    By default, the sleep period is one second, but it can be controlled through
#    the @c(-period) command-line flag. The @c(flag.Duration) function creates a
#    flag variable of type @c(time.Duration) and allows the user to specify the
#    duration in a variety of user-friendly formats, including the same notation
#    printed by the @c(String) method. This symmetry of design leads to a nice
#    user interface.
   Por defecto, el periodo de sueño es de un segundo, pero se puede controlar a
   traves de la bandera de linea de comandos @c(-period). La funcion
   @c(flag.Duration) crea una variable de tipo bandera @c(time.Duration) y
   permite al usuario especificar la duracion en una variedad de formatos
   faciles de usar, incluyendo la misma notacion que imprime el metodo
   @c(String). Esta simetria de diseño conduce a una interfaz de usuario
   agradable.

#    ..src > sh
#      $ ./sleep -period 50ms
#      Sleeping for 50ms...
#      $ ./sleep -period 2m30s
#      Sleeping for 2m30s...
#      $ ./sleep -period 1.5h
#      Sleeping for 1h30m0s...
#      $ ./sleep -period "1 day"
#      invalid value "1 day" for flag -period: time: invalid duration 1 day
#    < src..
   ..src > sh
     $ ./sleep -period 50ms
     Sleeping for 50ms...
     $ ./sleep -period 2m30s
     Sleeping for 2m30s...
     $ ./sleep -period 1.5h
     Sleeping for 1h30m0s...
     $ ./sleep -period "1 day"
     invalid value "1 day" for flag -period: time: invalid duration 1 day
   < src..

#    Because duration-valued flags are so useful, this feature is built into the
#    @c(flag) package, but it’s easy to define new flag notations for our own data
#    types. We need only define a type that satisfies the @c(flag.Value)
#    interface, whose declaration is below:
   Debido a que las banderas de valor de duracion son tan utiles, esta
   caracteristica esta integrada en el paquete @c(flag), pero es facil de
   definir nuevas notaciones bandera para nuestros propios tipos de datos. Solo
   necesitamos definir un tipo que satisfaga la interfaz @c(flag.Value), cuya
   declaracion es la siguiente:

#    ..src > go
#      package flag
#
#      // Value is the interface to the value stored in a flag.
#      type Value interface {
#        String() string
#        Set(string) error
#      }
#    < src..
   ..src > go
     package flag

     // Value es la interfaz con el valor almacenado en un indicador.
     type Value interface {
       String() string
       Set(string) error
     }
   < src..

#    The @c(String) method formats the flag’s value for use in command-line help
#    messages; thus every @c(flag.Value) is also a @c(fmt.Stringer). The @c(Set)
#    method parses its string argument and updates the flag value. In effect, the
#    @c(Set) method is the inverse of the @c(String) method, and it is good
#    practice for them to use the same notation.
   El metodo @c(String) formatea el valor de la bandera para su uso en los
   mensajes de ayuda de linea de comandos; Asi, cada @c(flag.Value) es tambien
   un @c(fmt.Stringer). El metodo @c(Set) analiza su argumento de cadena y
   actualiza el valor del indicador. En efecto, el metodo @c(Set) es el inverso
   del metodo @c(String), y es una buena practica para que puedan utilizar la
   misma notacion.

#    Let’s define a @c(celsiusFlag) type that allows a temperature to be specified
#    in Celsius, or in Fahrenheit with an appropriate conversion. Notice that
#    @c(celsiusFlag) embeds a @c(Celsius) (@l(#Section 2.5<>§2.5)), thereby
#    getting a @c(String) method for free. To satisfy @c(flag.Value), we need only
#    declare the @c(Set) method:
   Vamos a definir un tipo @c(celsiusFlag) que permite una temperatura que se
   especifica en @c(Celsius) o en @c(Fahrenheit) con una conversion
   apropiada. Observe que @c(celsiusFlag) incorpora un@c(Celsius) (@l(#Seccion
   2.5<>§2.5)), consiguiendo asi un metodo @c(String) de forma gratuita. Para
   satisfacer @c(flag.Value), solo tenemos que declarar el metodo @c(Set):

#    ..figure > @l(gopl.io/ch7/tempconv/tempconv.go<>gopl.io/ch7/tempconv)
   ..figure > @l(gopl.io/ch7/tempconv/tempconv.go<>gopl.io/ch7/tempconv)

#      ..src > go
#        // *celsiusFlag satisfies the flag.Value interface.
#        type celsiusFlag struct{ Celsius }
#
#        func (f *celsiusFlag) Set(s string) error {
#          var unit string
#          var value float64
#          fmt.Sscanf(s, "%f%s", &value, &unit) // no error check needed
#          switch unit {
#          case "C", "°C":
#            f.Celsius = Celsius(value)
#            return nil
#          case "F", "°F":
#            f.Celsius = FToC(Fahrenheit(value))
#            return nil
#          }
#          return fmt.Errorf("invalid temperature %q", s)
#        }
#      < src..
     ..src > go
       // *celsiusFlag satisface la interfaz flag.Value.
       type celsiusFlag struct{ Celsius }

       func (f *celsiusFlag) Set(s string) error {
         var unit string
         var value float64
         fmt.Sscanf(s, "%f%s", &value, &unit) // no es necesario comprobar el error
         switch unit {
         case "C", "°C":
           f.Celsius = Celsius(value)
           return nil
         case "F", "°F":
           f.Celsius = FToC(Fahrenheit(value))
           return nil
         }
         return fmt.Errorf("invalid temperature %q", s)
       }
     < src..


#    The call to @c(fmt.Sscanf) parses a floating-point number (@c[value]) and a
#    string (@c[unit]) from the input @c(s). Although one must usually check
#    @c(Sscanf)’s error result, in this case we don’t need to because if there was
#    a problem, no switch case will match.
   La llamada a @c(fmt.Sscanf) analiza un numero de coma flotante (@c[value]) y
   una cadena (@c[unit]) de la entrada @c(s). Aunque por lo general se debe
   comprobar el resultado error de @c(Sscanf), en este caso, no lo necesitamos
   porque si habia un problema, ningun caso coincidira con el @c(swich).

#    The @c(CelsiusFlag) function below wraps it all up. To the caller, it returns
#    a pointer to the @c(Celsius) field embedded within the @c(celsiusFlag)
#    variable @c(f). The @c(Celsius) field is the variable that will be updated by
#    the @c(Set) method during flags processing. The call to @c(Var) adds the flag
#    to the application’s set of command-line flags, the global variable
#    @c(flag.CommandLine).  Programs with unusually complex command-line
#    interfaces may have several variables of this type. The call to @c(Var)
#    assigns a @c(*celsiusFlag) argument to a @c(flag.Value) parameter, causing
#    the compiler to check that @c(*celsiusFlag) has the necessary methods.
   La funcion @c(CelsiusFlag) a continuacion de lo envuelve todo. Al llamador,
   devuelve un puntero al campo @c(Celsius) enbebido dentro de la variable @c(f)
   de @c(celsiusFlag). El campo @c(Celsius) es la variable que sera actualizada
   por el metodo @c(Set) durante el procesamiento de banderas. La llamada a
   @c(Var) agrega la bandera al conjunto de banderas de linea de comando, la
   variable global @c(flag.CommandLine). Los programas con interfaces de linea
   de comandos inusualmente complejos pueden tener varias variables de este
   tipo. La llamada a @c(Var) asigna un argumento @c(*celsiusFlag) a un
   parametro @c(flag.Value), haciendo que el compilador compruebe que
   @c(*celsiusFlag) tiene los metodos necesarios.

#    ..src > go
#      // CelsiusFlag defines a Celsius flag with the specified name,
#      // default value, and usage, and returns the address of the flag variable.
#      // The flag argument must have a quantity and a unit, e.g., "100C".
#      func CelsiusFlag(name string, value Celsius, usage string) *Celsius {
#        f := celsiusFlag{value}
#        flag.CommandLine.Var(&f, name, usage)
#        return &f.Celsius
#      }
#    < src..
   ..src > go
     // CelsiusFlag define una bandera Celsius con el nombre especificado,
     // valor predeterminado, y uso, y devuelve la direccion de la variable flag.
     // El argumento flag debe tener una cantidad y una unidad, por ejemplo, "100C".
     func CelsiusFlag(name string, value Celsius, usage string) *Celsius {
       f := celsiusFlag{value}
       flag.CommandLine.Var(&f, name, usage)
       return &f.Celsius
     }
   < src..

#    Now we can start using the new flag in our programs:
   Ahora podemos empezar a usar la nueva bandera en nuestros programas:

#    ..figure > @l(gopl.io/ch7/tempflag/tempflag.go<>gopl.io/ch7/tempflag)
   ..figure > @l(gopl.io/ch7/tempflag/tempflag.go<>gopl.io/ch7/tempflag)

#      ..src > go
#        var temp = tempconv.CelsiusFlag("temp", 20.0, "the temperature")
#
#        func main() {
#          flag.Parse()
#          fmt.Println(*temp)
#        }
#      < src..

     ..src > go
       var temp = tempconv.CelsiusFlag("temp", 20.0, "the temperature")

       func main() {
         flag.Parse()
         fmt.Println(*temp)
       }
     < src..


#    Here’s a typical session:
   Aqui hay una sesion tipica:

#    ..src > sh
#      $ go build gopl.io/ch7/tempflag
#      $ ./tempflag
#      20°C
#      $ ./tempflag -temp -18C
#      -18°C
#      $ ./tempflag -temp 212°F
#      100°C
#      $ ./tempflag -temp 273.15K
#      invalid value "273.15K" for flag -temp: invalid temperature "273.15K"
#      Usage of ./tempflag:
#        -temp value
#              the temperature (default 20°C)
#      $ ./tempflag -help
#      Usage of ./tempflag:
#        -temp value
#              the temperature (default 20°C)
#    < src..
   ..src > sh
     $ go build gopl.io/ch7/tempflag
     $ ./tempflag
     20°C
     $ ./tempflag -temp -18C
     -18°C
     $ ./tempflag -temp 212°F
     100°C
     $ ./tempflag -temp 273.15K
     invalid value "273.15K" for flag -temp: invalid temperature "273.15K"
     Usage of ./tempflag:
       -temp value
             the temperature (default 20°C)
     $ ./tempflag -help
     Usage of ./tempflag:
       -temp value
             the temperature (default 20°C)
   < src..


#    @b(Exercise 7.6): Add support for Kelvin temperatures to @c(tempflag).
   @b(Ejercicio 7.6): Añadir soporte para temperaturas Kelvin a @c(tempflag).

#    @b(Exercise 7.7): Explain why the help message contains @c(°C) when the
#    default value of @c(20.0) does not.
   @b(Ejercicio 7.7): Explicar por que el mensaje de ayuda contiene @c(°C)
   cuando el valor por defecto de @c(20.0) no.

# ** Section 7.5 <> Interface Values
** Seccion 7.5 <> Valores de Interfaz

#    Conceptually, a value of an interface type, or @e(interface value), has two
#    components, a concrete type and a value of that type. These are called the
#    interface’s @e(dynamic type) and @e(dynamic value).
   Conceptualmente, un valor de un tipo de interfaz, o el valor de la interfaz,
   tiene dos componentes, un tipo concreto y un valor de ese tipo. Estos se
   llaman @e(tipo dinamico) de la interfaz y el @e(valor dinamico).

#    For a statically typed language like Go, types are a compile-time concept, so
#    a type is not a value. In our conceptual model, a set of values called
#    @e(type descriptors) provide information about each type, such as its name
#    and methods. In an interface value, the type component is represented by the
#    appropriate type descriptor.
   Para un lenguaje de tipo estatico como Go, los tipos son un concepto de
   compilacion, por lo que un tipo no es un valor. En nuestro modelo conceptual,
   un conjunto de valores denominados @e(descriptores de tipo) proporcionan
   informacion sobre cada tipo, como su nombre y metodos. En un valor de
   interfaz, el componente de tipo esta representado por el descriptor de tipo
   apropiado.

#    In the four statements below, the variable @c(w) takes on three different
#    values. (The initial and final values are the same.)
   En las siguientes cuatro declaraciones, la variable @c(w) toma tres valores
   diferentes. (Los valores inicial y final son los mismos.)

#    ..src > go
#      var w io.Writer
#      w = os.Stdout
#      w = new(bytes.Buffer)
#      w = nil
#    < src..
   ..src > go
     var w io.Writer
     w = os.Stdout
     w = new(bytes.Buffer)
     w = nil
   < src..

#    Let’s take a closer look at the value and dynamic behavior of @c(w) after
#    each statement. The first statement declares @c(w):
   Echemos un vistazo mas de cerca el valor y el comportamiento dinamico de
   @c(w) despues de cada declaracion. La primera sentencia declara a @c(w):

#    ..src > go
#      var w io.Writer
#    < src..
   ..src > go
     var w io.Writer
   < src..

#    In Go, variables are always initialized to a well-defined value, and
#    interfaces are no exception.  The zero value for an interface has both its
#    type and value components set to @c(nil) (Figure 7.1).
   En Go, las variables siempre se inicializan en un valor bien definido, y las
   interfaces no son la excepcion. El valor cero para una interfaz tiene ambos
   componentes de tipo y valor establecidos en @c(nil) (Figura 7.1).

#    ..figure > Figure 7.1. A nil interface value.
   ..figure > Figura 7.1. Una interfaz de valor nil.

#      ..art >
#              w
#              ┏━━━━━━━━━━━━┓
#         type ┃    nil     ┃
#              ┣━━━━━━━━━━━━┫
#        value ┃    nil     ┃
#              ┗━━━━━━━━━━━━┛
#      < art..
     ..art >
              w
              ┏━━━━━━━━━━━━┓
        tipo  ┃    nil     ┃
              ┣━━━━━━━━━━━━┫
       valor  ┃    nil     ┃
              ┗━━━━━━━━━━━━┛
     < art..

#    An interface value is described as nil or non-nil based on its dynamic type,
#    so this is a nil interface value. You can test whether an interface value is
#    nil using @c(w == nil) or @c(w != nil).  Calling any method of a nil
#    interface value causes a panic:
   Un valor de interfaz se describe como @c(nil) o no @c(nil) basado en su tipo
   dinamico, por lo que este es un valor de interfaz nil. Puede probar si un
   valor de interfaz es nil usando @c(w == nil) o @c(w != nil). Llamar a
   cualquier metodo de un valor de interfaz nil causa un panico:

#    ..src > go
#      w.Write([]byte("hello")) // panic: nil pointer dereference
#    < src..
   ..src > go
     w.Write([]byte("hello")) // panico: desreferencia de puntero nil
   < src..

#    The second statement assigns a value of type @c(*os.File) to @c(w):
   La segunda instruccion asigna un valor de tipo @c(*os.File) a @c(w):

#    ..src > go
#      w = os.Stdout
#    < src..
   ..src > go
     w = os.Stdout
   < src..

#    This assignment involves an implicit conversion from a concrete type to an
#    interface type, and is equivalent to the explicit conversion
#    @c[io.Writer(os.Stdout)]. A conversion of this kind, whether explicit or
#    implicit, captures the type and the value of its operand. The interface
#    value’s dynamic type is set to the type descriptor for the pointer type
#    @c(*os.File), and its dynamic value holds a copy of @c(os.Stdout), which is a
#    pointer to the @c(os.File) variable representing the standard output of the
#    process (Figure 7.2).
   Esta asignacion implica una conversion implicita de un tipo concreto para un
   tipo de interfaz, y es equivalente a la conversion explicita
   @c[io.Writer(os.Stdout)]. Una conversion de este tipo, ya sea explicita o
   implicita, captura el tipo y el valor de su operando. Tipo dinamico del valor
   de la interfaz se establece en el descriptor de tipo para el tipo de puntero
   @c(*os.File), y su valor dinamico contiene una copia de @c(os.Stdout), que es
   un puntero a la variable @c(os.File) que representa la salida estandar del
   proceso (Figura 7.2).

#    ..figure > Figure 7.2. An interface value containing an @c(*os.File) pointer.
   ..figure > Figura 7.2. Un valor de interfaz contiene un puntero @c(*os.File).

#      ..img  > img/Figure-7.2.jpg
     ..img  > img/Figure-7.2.jpg


#    Calling the @c(Write) method on an interface value containing an @c(*os.File)
#    pointer causes the @c[(*os.File).Write] method to be called. The call prints
#    @c("hello").
   Llamar al metodo @c(Write) en un valor de interfaz que contiene un puntero
   @c(*os.File) hace que se llama al metodo @c[(*os.File).Write]. La llamada
   imprime @c("hello").

#    ..src > go
#      w.Write([]byte("hello")) // "hello"
#    < src..
   ..src > go
     w.Write([]byte("hello")) // "hello"
   < src..

#    In general, we cannot know at compile time what the dynamic type of an
#    interface value will be, so a call through an interface must use @e(dynamic
#    dispatch). Instead of a direct call, the compiler must generate code to
#    obtain the address of the method named @c(Write) from the type descriptor,
#    then make an indirect call to that address. The receiver argument for the
#    call is a copy of the interface’s dynamic value, @c(os.Stdout). The effect is
#    as if we had made this call directly:
   En general, no podemos saber en tiempo de compilacion cual sera el tipo
   dinamico de un valor interfaz, por lo que una llamada a traves de una
   interfaz debe utilizar el @e(envio dinamico). En lugar de una llamada
   directa, el compilador debe generar codigo para obtener la direccion del
   metodo con nombre @c(Write) desde el descriptor de tipos, y luego, realizar
   una llamada indirecta a esa direccion. El argumento del receptor de la
   llamada es una copia del valor dinamico de la interfaz, @c(os.Stdout). El
   efecto es como si hubieramos hecho esta llamada directamente:

#    ..src > go
#      os.Stdout.Write([]byte("hello")) // "hello"
#    < src..
   ..src > go
     os.Stdout.Write([]byte("hello")) // "hello"
   < src..

#    The third statement assigns a value of type @c(*bytes.Buffer) to the
#    interface value:
   La tercera instruccion asigna un valor de tipo @c(*bytes.Buffer) al valor de
   la interfaz:

#    ..src > go
#      w = new(bytes.Buffer)
#    < src..
   ..src > go
     w = new(bytes.Buffer)
   < src..

#    The dynamic type is now @c(*bytes.Buffer) and the dynamic value is a pointer
#    to the newly allocated buffer (Figure 7.3).
   El tipo dinamico es ahora @c(*bytes.Buffer) y el valor dinamico es un puntero
   a al buffer recien asignado (Figura 7.3).

#    ..figure > Figure 7.3. An interface value containing a @c(*bytes.Buffer) pointer.
   ..figure > Figura 7.3. Un valor de interfaz que contiene un puntero @c(*bytes.Buffer)..

#      ..img  > img/Figure-7.3.jpg
     ..img  > img/Figure-7.3.jpg


#    A call to the @c(Write) method uses the same mechanism as before:
   Una llamada al metodo @c(Write) utiliza el mismo mecanismo que antes:

#    ..src > go
#      w.Write([]byte("hello")) // writes "hello" to the bytes.Buffer
#    < src..
   ..src > go
     w.Write([]byte("hello")) // escribe "hello" en bytes.Buffer
   < src..

#    This time, the type descriptor is @c(*bytes.Buffer), so the
#    @c[(*bytes.Buffer).Write] method is called, with the address of the buffer as
#    the value of the receiver parameter. The call appends @c("hello") to the
#    buffer.
   Esta vez, el tipo de descriptor es @c(*bytes.Buffer), por lo que se llama al
   metodo @c[(*bytes.Buffer).Write] con la direccion del buffer como el valor
   del parametro de receptor. La llamada agrega @c("hello") al buffer.

#    Finally, the fourth statement assigns @c(nil) to the interface value:
   Por ultimo, la cuarta instruccion asigna @c(nil) al valor de la interfaz:

#    ..src > go
#      w = nil
#    < src..
   ..src > go
     w = nil
   < src..

#    This resets both its components to @c(nil), restoring @c(w) to the same state
#    as when it was declared, which was shown in Figure 7.1.
   Esto restablece sus dos componentes a @c(nil), restaurando @c(w) al mismo
   estado que cuando fue declarado, que se muestra en la Figura 7.1.

#    An interface value can hold arbitrarily large dynamic values. For example,
#    the @c(time.Time) type, which represents an instant in time, is a struct type
#    with several unexported fields. If we create an interface value from it,
   Un valor de interfaz puede contener valores dinamicos arbitrariamente
   grandes. Por ejemplo, el tipo @c(time.Time), que representa un instante en el
   tiempo, es un tipo struct con varios campos no exportadas. Si creamos un
   valor de interfaz de ella,

#    ..src > go
#      var x interface{} = time.Now()
#    < src..
   ..src > go
     var x interface{} = time.Now()
   < src..

#    the result might look like Figure 7.4. Conceptually, the dynamic value always
#    fits inside the interface value, no matter how large its type. (This is only
#    a conceptual model; a realistic implementation is quite different.)
   El resultado podria ser similar al de la Figura 7.4. Conceptualmente, el
   valor dinamico siempre se ajusta dentro del valor de la interfaz, no importa
   cuan grande sea su tipo. (Esto es solo un modelo conceptual, una
   implementacion realista es muy diferente.)

#    ..figure > Figure 7.4. An interface value holding a @c(time.Time) struct.
   ..figure > Figura 7.4. Un valor de interfaz que contiene una estructura @c(time.Time).

#      ..img  > img/Figure-7.4.jpg
     ..img  > img/Figure-7.4.jpg


#    Interface values may be compared using @c(==) and @c(!=). Two interface
#    values are equal if both are nil, or if their dynamic types are identical and
#    their dynamic values are equal according to the usual behavior of @c(==) for
#    that type. Because interface values are comparable, they may be used as the
#    keys of a map or as the operand of a switch statement.
   Los valores de interfaz se pueden comparar usando @c(==) y @c(!=). Dos
   valores de la interfaz son iguales si ambos son nil, o si sus tipos dinamicos
   son identicos y sus valores dinamicos son iguales de acuerdo con el
   comportamiento usual de @c(==) para ese tipo. Dado que los valores de
   interfaz son comparables, pueden utilizarse como las claves de un mapa o como
   el operando de una instruccion @c(switch).

#    However, if two interface values are compared and have the same dynamic type,
#    but that type is not comparable (a slice, for instance), then the comparison
#    fails with a panic:
   Sin embargo, si se comparan dos valores de interfaz y tienen el mismo tipo
   dinamico, pero ese tipo no es comparable (por ejemplo, un slice), entonces la
   comparacion falla con un panico:

#    ..src > go
#      var x interface{} = []int{1, 2, 3}
#      fmt.Println(x == x) // panic: comparing uncomparable type []int
#    < src..
   ..src > go
     var x interface{} = []int{1, 2, 3}
     fmt.Println(x == x) // panico: comparacion de tipo incompatible []int
   < src..

#    In this respect, interface types are unusual. Other types are either safely
#    comparable (like basic types and pointers) or not comparable at all (like
#    slices, maps, and functions), but when comparing interface values or
#    aggregate types that contain interface values, we must be aware of the
#    potential for a panic. A similar risk exists when using interfaces as map
#    keys or switch operands. Only compare interface values if you are certain
#    that they contain dynamic values of comparable types.
   En este sentido, los tipos de interfaz son inusuales. Otros tipos son
   comparables de forma segura (como tipos basicos y punteros) o no son
   comparables en absoluto (como slices, mapas y funciones), pero cuando se
   comparan valores de interfaz o tipos agregados que contienen valores de
   interfaz, debemos estar conscientes del potencial de una panico. Un riesgo
   similar existe cuando se utilizan interfaces como claves de mapa u operandos
   de conmutador. Solo compare valores de interfaz si esta seguro de que
   contienen valores dinamicos de tipos comparables.

#    When handling errors, or during debugging, it is often helpful to report the
#    dynamic type of an interface value. For that, we use the @c(fmt) package’s
#    @c(%T) verb:
   Cuando se manejan errores o durante la depuracion, a menudo es util informar
   el tipo dinamico de un valor de interfaz. Para ello, utilizamos el verbo
   @c(%T) del paquete @c(fmt):

#    ..src > go
#      var w io.Writer
#      fmt.Printf("%T\n", w) // "<nil>"
#
#      w = os.Stdout
#      fmt.Printf("%T\n", w) // "*os.File"
#
#      w = new(bytes.Buffer)
#      fmt.Printf("%T\n", w) // "*bytes.Buffer"
#    < src..
   ..src > go
     var w io.Writer
     fmt.Printf("%T\n", w) // "<nil>"

     w = os.Stdout
     fmt.Printf("%T\n", w) // "*os.File"

     w = new(bytes.Buffer)
     fmt.Printf("%T\n", w) // "*bytes.Buffer"
   < src..

#    Internally, @c(fmt) uses reflection to obtain the name of the interface’s
#    dynamic type. We’ll look at reflection in @l(#Chapter 12).
   Internamente, @c(fmt) utiliza la reflexion para obtener el nombre del tipo
   dinamico de la interfaz. Veremos la reflexion en el @l(#Capitulo 12).

# *** Section 7.5.1 <> Caveat: An Interface Containing a Nil Pointer Is Non-Nil
*** Seccion 7.5.1 <> Advertencia: Una interfaz que Contiene un Puntero Nil es No-Nil

#     A nil interface value, which contains no value at all, is not the same as an
#     interface value containing a pointer that happens to be nil. This subtle
#     distinction creates a trap into which every Go programmer has stumbled.
    Un valor de interfaz nil, que no contiene ningun valor, no es el mismo que
    un valor de interfaz que contiene un puntero que pasa a ser nil. Esta sutil
    distincion crea una trampa en la que cada programador de Go se ha tropezado.

#     Consider the program below. With @c(debug) set to @c(true), the main
#     function collects the output of the function @c(f) in a @c(bytes.Buffer).
    Considere el programa a continuacion. Con @c(debug) establecido en @c(true), la
    funcion @c(main) recoge la salida de la funcion @c(f) en un @c(bytes.Buffer).

#     ..src > go
#       const debug = true
#
#       func main() {
#         var buf *bytes.Buffer
#         if debug {
#           buf = new(bytes.Buffer) // enable collection of output
#         }
#         f(buf)                    // NOTE: subtly incorrect!
#         if debug {
#           // ...use buf...
#         }
#       }
#
#       // If out is non-nil, output will be written to it.
#       func f(out io.Writer) {
#         // ...do something...
#         if out != nil {
#           out.Write([]byte("done!\n"))
#         }
#       }
#     < src..
    ..src > go
      const debug = true

      func main() {
        var buf *bytes.Buffer
        if debug {
          buf = new(bytes.Buffer) // Habilitar la recopilacion de la salida
        }
        f(buf)                    // NOTA: sutilmente incorrecto!
        if debug {
          // ...use buf...
        }
      }

      // Si out no es nil, la salida se escribe en este.
      func f(out io.Writer) {
        // ...hacer algo...
        if out != nil {
          out.Write([]byte("done!\n"))
        }
      }
    < src..

#     We might expect that changing @c(debug) to @c(false) would disable the
#     collection of the output, but in fact it causes the program to panic during
#     the @c(out.Write) call:
    Podriamos esperar que el cambio de @c(debug) a @c(false) podria desactivar
    la recoleccion de la salida, pero en realidad hace que el programa entre en
    panico durante la llamada @c(out.Write):

#     ..src > go
#       if out != nil {
#         out.Write([]byte("done!\n")) // panic: nil pointer dereference
#       }
#     < src..
    ..src > go
      if out != nil {
        out.Write([]byte("done!\n")) // panico: desreferencia de puntero nil
      }
    < src..

#     When @c(main) calls @c(f), it assigns a nil pointer of type
#     @c(*bytes.Buffer) to the @c(out) parameter, so the dynamic value of @c(out)
#     is @c(nil). However, its dynamic type is @c(*bytes.Buffer), meaning that
#     @c(out) is a non-nil interface containing a nil pointer value (Figure 7.5),
#     so the defensive check @c(out != nil) is still true.
    Cuando @c(main) llamada a @c(f), asigna un puntero nil del tipo
    @c(*bytes.Buffer) al parametro @c(out), por lo que el valor dinamico de
    @c(out) es @c(nil). Sin embargo, su tipo dinamico es @c(*bytes.Buffer), lo
    que significa que @c(out) es una interfaz no-nil que contiene un valor de
    puntero nulo (Figura 7.5), por lo que la comprobacion defensiva @c(out !=
    nil) sigue siendo verdadero.

#     ..figure > Figure 7.5. A non-nil interface containing a nil pointer.
    ..figure > Figura 7.5. Una interfaz no-nil que contiene un puntero nil.

#       ..art >
#               w
#               ┏━━━━━━━━━━━━━━━━━┓
#          type ┃  *bytes.Buffer  ┃
#               ┣━━━━━━━━━━━━━━━━━┫
#         value ┃       nil       ┃
#               ┗━━━━━━━━━━━━━━━━━┛
#       < art..
      ..art >
              w
              ┏━━━━━━━━━━━━━━━━━┓
         type ┃  *bytes.Buffer  ┃
              ┣━━━━━━━━━━━━━━━━━┫
        value ┃       nil       ┃
              ┗━━━━━━━━━━━━━━━━━┛
      < art..


#     As before, the dynamic dispatch mechanism determines that
#     @c[(*bytes.Buffer).Write] must be called but this time with a receiver value
#     that is nil. For some types, such as @c(*os.File), @c(nil) is a valid
#     receiver (@l(#Section 6.2.1<>§6.2.1)), but @c(*bytes.Buffer) is not among
#     them. The method is called, but it panics as it tries to access the buffer.
    Como antes, el mecanismo de envio dinamico determina que
    @c[(*bytes.Buffer).Write] debe ser llamado pero esta vez con un valor
    receptor que es nil. Para algunos tipos, como @c(*os.File), nil es un
    receptor valido (@l(#Seccion 6.2.1<>§6.2.1)), pero @c(*bytes.Buffer) no esta
    entre ellos. El metodo se llama, pero entra en panico al intentar acceder al
    bufer.

#     The problem is that although a nil @c(*bytes.Buffer) pointer has the methods
#     needed to satisfy the interface, it doesn’t satisfy the @e(behavioral)
#     requirements of the interface. In particular, the call violates the implicit
#     precondition of @c[(*bytes.Buffer).Write] that its receiver is not nil, so
#     assigning the nil pointer to the interface was a mistake. The solution is to
#     change the type of @c(buf) in @c(main) to @c(io.Writer), thereby avoiding
#     the assignment of the dysfunctional value to the interface in the first
#     place:
    El problema es que aunque un puntero @c(*bytes.Buffer) nulo tiene los
    metodos necesarios para satisfacer la interfaz, no satisface los requisitos
    de comportamiento de la interfaz. En particular, la llamada viola la
    condicion implicita de @c[(*bytes.Buffer).Write] de que receptor no sea nil,
    por lo que la asignacion de puntero nulo a la interfaz fue un error. La
    solucion es cambiar el tipo de @c(buf) en @c(main) a @c(io.Writer),
    evitando de ese modo la asignacion del valor disfuncional a la interfaz en
    el primer lugar:

#     ..src > go
#       var buf io.Writer
#       if debug {
#         buf = new(bytes.Buffer) // enable collection of output
#       }
#       f(buf) // OK
#     < src..
    ..src > go
      var buf io.Writer
      if debug {
        buf = new(bytes.Buffer) // Habilitar la recopilacion de la salida
      }
      f(buf) // OK
    < src..

#     Now that we’ve covered the mechanics of interface values, let’s take a look
#     at some more important interfaces from Go’s standard library. In the next
#     three sections, we’ll see how interfaces are used for sorting, web serving,
#     and error handling.
    Ahora que hemos cubierto la mecanica de los valores de interfaz, echemos un
    vistazo a algunas de las interfaces mas importantes de la libreria estandar.
    En las tres siguientes secciones, veremos como se utilizan las interfaces
    para ordenacion, para servir en la web y gestionar errores.

# ** Section 7.6 <> Sorting with @c(sort.Interface)
** Seccion 7.6 <> Ordenacion con @c(sort.Interface)

#    Like string formatting, sorting is a frequently used operation in many
#    programs. Although a minimal Quicksort can be written in about 15 lines, a
#    robust implementation is much longer, and it is not the kind of code we
#    should wish to write anew or copy each time we need it.
   Al igual que el formateo de cadenas, la ordenacion es una operacion
   frecuentemente utilizada en muchos programas. Aunque un Quicksort minimo se
   puede escribir en unas 15 lineas, una implementacion robusta es mucho mas
   larga, y no es el tipo de codigo que deberiamos escribir de nuevo o copiar
   cada vez que lo necesitamos.

#    Fortunately, the @c(sort) package provides in-place sorting of any sequence
#    according to any ordering function. Its design is rather unusual. In many
#    languages, the sorting algorithm is associated with the sequence data type,
#    while the ordering function is associated with the type of the elements. By
#    contrast, Go’s @c(sort.Sort) function assumes nothing about the
#    representation of either the sequence or its elements. Instead, it uses an
#    interface, @c(sort.Interface), to specify the contract between the generic
#    sort algorithm and each sequence type that may be sorted. An implementation
#    of this interface determines both the concrete representation of the
#    sequence, which is often a slice, and the desired ordering of its elements.
   Afortunadamente, el paquete @c(sort) provee in situ la ordenacion de
   cualquier sequencia de acuerdo con cualquier funcion de ordenacion. Su diseño
   es bastante inusual. En muchos lenguajes, el algoritmo de ordenacion esta
   asociado con el tipo de datos de la secuencia, mientras que la funcion de
   ordenacion esta asociada con el tipo de los elementos. Por el contrario, la
   funcion @c(sort.Sort) de Go, no asume nada sobre de la representacion de la
   secuencia o de sus elementos. En su lugar, utiliza una interfaz,
   @c(sort.Interface), para especificar el contrato entre el algoritmo de
   ordenacion generica y cada tipo de secuencia que puede ser ordenada. Una
   implementacion de esta interfaz determina tanto la representacion concreta de
   la secuencia, que es a menudo un slice, y el orden deseado de sus elementos.

#    An in-place sort algorithm needs three things—the length of the sequence, a
#    means of comparing two elements, and a way to swap two elements—so they are
#    the three methods of @c(sort.Interface):
   Un algoritmo de ordenacion in situ necesita tres cosas–la longitud de la
   secuencia, una forma de comparar dos elementos, y una manera de intercambiar
   dos elementos–por lo que son los tres metodos de @c(sort.Interface):

#    ..src > go
#      package sort
#
#      type Interface interface {
#        Len() int
#        Less(i, j int) bool // i, j are indices of sequence elements
#        Swap(i, j int)
#      }
#    < src..
   ..src > go
     package sort

     type Interface interface {
       Len() int
       Less(i, j int) bool // i, j son indices de la sequencia de elementos
       Swap(i, j int)
     }
   < src..

#    To sort any sequence, we need to define a type that implements these three
#    methods, then apply @c(sort.Sort) to an instance of that type. As perhaps the
#    simplest example, consider sorting a slice of strings. The new type
#    @c(StringSlice) and its @c(Len), @c(Less), and @c(Swap) methods are shown
#    below.
   Para ordenar cualquier secuencia, es necesario definir un tipo que implemente
   estos tres metodos, luego, aplicar @c(sort.Sort) a una instancia de ese
   tipo. Como quizas el ejemplo mas simple, considere clasificar un slice de
   cadenas. El nuevo tipo @c(StringSlice) y sus metodos @c(Len), @c(Less), y
   @c(Swap) se muestran a continuacion.

#    ..src > go
#      type StringSlice []string
#
#      func (p StringSlice) Len() int           { return len(p) }
#      func (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }
#      func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
#    < src..
   ..src > go
     type StringSlice []string

     func (p StringSlice) Len() int           { return len(p) }
     func (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }
     func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
   < src..

#    Now we can sort a slice of strings, @c(names), by converting the slice to a
#    @c(StringSlice) like this:
   Ahora podemos ordenar una slice de strings, @c(names), convirtiendo el slice
   a un @c(StringSlice) como aqui:

#    ..src > go
#      sort.Sort(StringSlice(names))
#    < src..
   ..src > go
     sort.Sort(StringSlice(names))
   < src..

#    The conversion yields a slice value with the same length, capacity, and
#    underlying array as @c(names) but with a type that has the three methods
#    required for sorting.
   La conversion produce un valor de slice con la misma longitud, capacidad, y
   arreglo subyacente como @c(names), pero con un tipo que tiene los tres
   metodos necesarios para la clasificacion.

#    Sorting a slice of strings is so common that the @c(sort) package provides
#    the @c(StringSlice) type, as well as a function called @c(Strings) so that
#    the call above can be simplified to @c[sort.Strings(names)].
   Ordenar un slice de strings es tan comun que el paquete sort proporciona el
   tipo @c(StringSlice), asi como una funcion llamada @c(Strings) por lo que la
   llamada anterior se puede simplificar a @c[sort.Strings(names)].

#    The technique here is easily adapted to other sort orders, for instance, to
#    ignore capitalization or special characters. (The Go program that sorts index
#    terms and page numbers for this book does this, with extra logic for Roman
#    numerals.) For more complicated sorting, we use the same idea, but with more
#    complicated data structures or more complicated implementations of the
#    @c(sort.Interface) methods.
   La tecnica aqui se adapta facilmente a otros ordenes de clasificacion, por
   ejemplo, para ignorar mayusculas o caracteres especiales. (El programa Go que
   ordena los terminos del indice y el numero de paginas de este libro hace
   esto, con una logica adicional para los numeros romanos.) Para una ordenacion
   mas complicada, usamos la misma idea, pero con estructuras de datos mas
   complicadas o implementaciones mas complicadas de los metodos
   @c(sort.Interface).

#    Our running example for sorting will be a music playlist, displayed as a
#    table. Each track is a single row, and each column is an attribute of that
#    track, like artist, title, and running time.  Imagine that a graphical user
#    interface presents the table, and that clicking the head of a column causes
#    the playlist to be sorted by that attribute; clicking the same column head
#    again reverses the order. Let’s look at what might happen in response to each
#    click.
   Nuestro ejemplo de ejecucion para la clasificacion sera una lista de
   reproduccion de musica, mostrada como una tabla. Cada pista es una sola fila
   y cada columna es un atributo de esa pista, como artista, titulo y tiempo de
   ejecucion. Imagine que una interfaz grafica de usuario presenta la tabla y
   que al hacer clic en la cabecera de una columna, la lista de reproduccion se
   clasifica por ese atributo; Haciendo clic en la misma columna, vuelve a
   invertir el orden. Echemos un vistazo a lo que podria suceder en respuesta a
   cada clic.

#    The variable @c(tracks) below contains a playlist. (One of the authors
#    apologizes for the other author’s musical tastes.) Each element is indirect,
#    a pointer to a @c(Track). Although the code below would work if we stored the
#    @c(Tracks) directly, the sort function will swap many pairs of elements, so
#    it will run faster if each element is a pointer, which is a single machine
#    word, instead of an entire @c(Track), which might be eight words or more.
   La siguiente variable @c(tracks) contiene una lista de reproduccion. (Uno de
   los autores se disculpa por los gustos musicales del otro autor.) Cada
   elemento es indirecto, un puntero a un @c(Track). Aunque el codigo de abajo
   funcionaria si almacenamos los @c(Tracks) directamente, la funcion de
   clasificacion intercambiara muchos pares de elementos, por lo que se
   ejecutara mas rapido si cada elemento es un puntero, que es una sola palabra
   de la maquina, en lugar de un @c(Track) completo, lo que podrian ser ocho o
   mas palabras.

#    ..figure > @l(gopl.io/ch7/sorting/main.go<>gopl.io/ch7/sorting)
   ..figure > @l(gopl.io/ch7/sorting/main.go<>gopl.io/ch7/sorting)

#      ..src > go
#        type Track struct {
#          Title  string
#          Artist string
#          Album  string
#          Year   int
#          Length time.Duration
#        }
#
#        var tracks = []*Track{
#          {"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")},
#          {"Go", "Moby", "Moby", 1992, length("3m37s")},
#          {"Go Ahead", "Alicia Keys", "As I Am", 2007, length("4m36s")},
#          {"Ready 2 Go", "Martin Solveig", "Smash", 2011, length("4m24s")},
#        }
#
#        func length(s string) time.Duration {
#          d, err := time.ParseDuration(s)
#          if err != nil {
#            panic(s)
#          }
#          return d
#        }
#      < src..
     ..src > go
       type Track struct {
         Title  string
         Artist string
         Album  string
         Year   int
         Length time.Duration
       }

       var tracks = []*Track{
         {"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")},
         {"Go", "Moby", "Moby", 1992, length("3m37s")},
         {"Go Ahead", "Alicia Keys", "As I Am", 2007, length("4m36s")},
         {"Ready 2 Go", "Martin Solveig", "Smash", 2011, length("4m24s")},
       }

       func length(s string) time.Duration {
         d, err := time.ParseDuration(s)
         if err != nil {
           panic(s)
         }
         return d
       }
     < src..


#    The @c(printTracks) function prints the playlist as a table. A graphical
#    display would be nicer, but this little routine uses the @c(text/tabwriter)
#    package to produce a table whose columns are neatly aligned and padded as
#    shown below. Observe that @c(*tabwriter.Writer) satisfies @c(io.Writer). It
#    collects each piece of data written to it; its @c(Flush) method formats the
#    entire table and writes it to @c(os.Stdout).
   La funcion @c(printTracks) imprime la lista de reproduccion como una
   tabla. Una pantalla grafica seria mejor, pero esta pequeña rutina utiliza el
   paquete @c(text/tabwriter) para producir una tabla cuyas columnas estan
   perfectamente alineadas y rellenas, como se muestra a continuacion. Observe
   que @c(*tabwriter.Writer) satisface @c(io.Writer). Recoge cada pieza de datos
   escrita en ella; su metodo @c(Flush) da formato a toda la tabla y lo escribe
   en @c(os.Stdout).

#    ..src > go
#      func printTracks(tracks []*Track) {
#        const format = "%v\t%v\t%v\t%v\t%v\t\n"
#        tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0)
#        fmt.Fprintf(tw, format, "Title", "Artist", "Album", "Year", "Length")
#        fmt.Fprintf(tw, format, "-----", "------", "-----", "----", "------")
#        for _, t := range tracks {
#          fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)
#        }
#        tw.Flush() // calculate column widths and print table
#      }
#    < src..
   ..src > go
     func printTracks(tracks []*Track) {
       const format = "%v\t%v\t%v\t%v\t%v\t\n"
       tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0)
       fmt.Fprintf(tw, format, "Title", "Artist", "Album", "Year", "Length")
       fmt.Fprintf(tw, format, "-----", "------", "-----", "----", "------")
       for _, t := range tracks {
         fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)
       }
       tw.Flush() // calculate column widths and print table
     }
   < src..

#    To sort the playlist by the @c(Artist) field, we define a new slice type with
#    the necessary @c(Len), @c(Less), and @c(Swap) methods, analogous to what we
#    did for @c(StringSlice).
   Para ordenar la lista de reproduccion por el campo @c(Artist), definimos un
   nuevo tipo de slice con los necesarios metodos @c(Len), @c(Less), y @c(Swap),
   analogos a lo que hicimos para @c(StringSlice).

#    ..src > go
#      type byArtist []*Track
#      func (x byArtist) Len() int           { return len(x) }
#      func (x byArtist) Less(i, j int) bool { return x[i].Artist < x[j].Artist }
#      func (x byArtist) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
#    < src..
   ..src > go
     type byArtist []*Track
     func (x byArtist) Len() int           { return len(x) }
     func (x byArtist) Less(i, j int) bool { return x[i].Artist < x[j].Artist }
     func (x byArtist) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
   < src..

#    To call the generic sort routine, we must first convert @c(tracks) to the new
#    type, @c(byArtist), that defines the order:
   Para llamar a la rutina de ordenacion generica, primero debemos convertir
   @c(tracks) al nuevo tipo, @c(byArtist), que define el orden:

#    ..src > go
#      sort.Sort(byArtist(tracks))
#    < src..
   ..src > go
     sort.Sort(byArtist(tracks))
   < src..

#    After sorting the slice by artist, the output from @c(printTracks) is
   Despues de ordenar el slice por artista, la salida de @c(printTracks) es

#    ..pre >
#      Title       Artist          Album              Year  Length
#      -----       ------          -----              ----  ------
#      Go Ahead    Alicia Keys     As I Am            2007  4m36s
#      Go          Delilah         From the Roots Up  2012  3m38s
#      Ready 2 Go  Martin Solveig  Smash              2011  4m24s
#      Go          Moby            Moby               1992  3m37s
#    < pre..
   ..pre >
     Title       Artist          Album              Year  Length
     -----       ------          -----              ----  ------
     Go Ahead    Alicia Keys     As I Am            2007  4m36s
     Go          Delilah         From the Roots Up  2012  3m38s
     Ready 2 Go  Martin Solveig  Smash              2011  4m24s
     Go          Moby            Moby               1992  3m37s
   < pre..


#    If the user requests @"(sort by artist) a second time, we’ll sort the tracks
#    in reverse. We needn’t define a new type @c(byReverseArtist) with an inverted
#    @c(Less) method, however, since the @c(sort) package provides a @c(Reverse)
#    function that transforms any sort order to its inverse.
   Si el usuario solicita @"(ordenar por artista) una segunda vez, vamos a
   resolver los tracks en orden inverso. No tenemos que definir un nuevo tipo
   @c(byReverseArtist) con un metodo @c(Less) invertido, ya que el paquete
   @c(sort) proporciona una funcion @c(Reverse) que transforma cualquier orden a
   su inversa.

#    ..src > go
#      sort.Sort(sort.Reverse(byArtist(tracks)))
#    < src..
   ..src > go
     sort.Sort(sort.Reverse(byArtist(tracks)))
   < src..

#    After reverse-sorting the slice by artist, the output from printTracks is
   Despues de la ordenacin inversa del slice por artista, la salida de
   @c(printTracks) es

#    ..pre >
#      Title       Artist          Album              Year  Length
#      -----       ------          -----              ----  ------
#      Go          Moby            Moby               1992  3m37s
#      Ready 2 Go  Martin Solveig  Smash              2011  4m24s
#      Go          Delilah         From the Roots Up  2012  3m38s
#      Go Ahead    Alicia Keys     As I Am            2007  4m36s
#    < pre..
   ..pre >
     Title       Artist          Album              Year  Length
     -----       ------          -----              ----  ------
     Go          Moby            Moby               1992  3m37s
     Ready 2 Go  Martin Solveig  Smash              2011  4m24s
     Go          Delilah         From the Roots Up  2012  3m38s
     Go Ahead    Alicia Keys     As I Am            2007  4m36s
   < pre..


#    The @c(sort.Reverse) function deserves a closer look since it uses
#    composition (@l(#Section 6.3<>§6.3)), which is an important idea. The
#    @c(sort) package defines an unexported type @c(reverse), which is a struct
#    that embeds a @c(sort.Interface). The @c(Less) method for @c(reverse) calls
#    the @c(Less) method of the embedded @c(sort.Interface) value, but with the
#    indices flipped, reversing the order of the sort results.
   La funcion @c(sort.Reverse) merece un vistazo mas de cerca, ya que utiliza la
   composicion (@l(#Seccion 6.3<>§6.3)), que es una idea importante. El paquete
   @c(sort) define un tipo no exportado @c(reverse), que es una estructura que
   enbebe un @c(sort.Interface). El metodo @c(Less) de @c(reverse) llama al
   @c(Less) del varol enbebido @c(sort.Interface), pero con los indices
   invertidos, invirtiendo el orden de los resultados.

#    ..src > go
#      package sort
#
#      type reverse struct{ Interface } // that is, sort.Interface
#
#      func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }
#
#      func Reverse(data Interface) Interface { return reverse{data} }
#    < src..
   ..src > go
     package sort

     type reverse struct{ Interface } // that is, sort.Interface

     func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }

     func Reverse(data Interface) Interface { return reverse{data} }
   < src..

#    @c(Len) and @c(Swap), the other two methods of @c(reverse), are implicitly
#    provided by the original @c(sort.Interface) value because it is an embedded
#    field. The exported function @c(Reverse) returns an instance of the
#    @c(reverse) type that contains the original @c(sort.Interface) value.
   @c(Len) y @c(Swap), los otros dos metodos de @c(reverse), son proporcionados
   implicitamente por el valor original @c(sort.Interface) porque es un campo
   enbebido. La funcion exportada @c(Reverse) devuelve una instancia del tipo
   @c(reverse) que contiene el valor original @c(sort.Interface).

#    To sort by a different column, we must define a new type, such as @c(byYear):
   Para ordenar por una columna diferente, hay que definir un nuevo tipo, como
   @c(byYear):

#    ..src > go
#      type byYear []*Track
#
#      func (x byYear) Len() int           { return len(x) }
#      func (x byYear) Less(i, j int) bool { return x[i].Year < x[j].Year }
#      func (x byYear) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
#    < src..
   ..src > go
     type byYear []*Track

     func (x byYear) Len() int           { return len(x) }
     func (x byYear) Less(i, j int) bool { return x[i].Year < x[j].Year }
     func (x byYear) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
   < src..

#    After sorting @c(tracks) by year using @c[sort.Sort(byYear(tracks))],
#    @c(printTracks) shows a chronological listing:
   Despues de ordenamos los @c(tracks) por año usando
   @c[sort.Sort(byYear(tracks))], @c(printTracks) muestra una lista cronologica:

#    ..pre >
#      Title       Artist          Album              Year  Length
#      -----       ------          -----              ----  ------
#      Go          Moby            Moby               1992  3m37s
#      Go Ahead    Alicia Keys     As I Am            2007  4m36s
#      Ready 2 Go  Martin Solveig  Smash              2011  4m24s
#      Go          Delilah         From the Roots Up  2012  3m38s
#    < pre..
   ..pre >
     Title       Artist          Album              Year  Length
     -----       ------          -----              ----  ------
     Go          Moby            Moby               1992  3m37s
     Go Ahead    Alicia Keys     As I Am            2007  4m36s
     Ready 2 Go  Martin Solveig  Smash              2011  4m24s
     Go          Delilah         From the Roots Up  2012  3m38s
   < pre..

#    For every slice element type and every ordering function we need, we declare
#    a new implementation of @c(sort.Interface). As you can see, the @c(Len) and
#    @c(Swap) methods have identical definitions for all slice types. In the next
#    example, the concrete type @c(customSort) combines a slice with a function,
#    letting us define a new sort order by writing only the comparison function.
#    Incidentally, the concrete types that implement @c(sort.Interface) are not
#    always slices; @c(customSort) is a struct type.
   Para cada tipo de slice y cada funcion de ordenacion necesitamos, declarar
   una nueva implementacion de @c(sort.Interface). Como se puede ver, los
   metodos @c(Len) y @c(Swap) tienen definiciones identicas para todos los tipos
   de slice. En el siguiente ejemplo, el tipo concreto @c(customSort) combina un
   slice con una funcion, permitiendo definir un nuevo orden de clasificacion
   escribiendo unicamente la funcion de comparacion. Por cierto, los tipos
   concretos que implementan @c(sort.Interface) no siempre son slices;
   @c(customSort) es un tipo struct.

#    ..src > go
#      type customSort struct {
#        t    []*Track
#        less func(x, y *Track) bool
#      }
#
#      func (x customSort) Len() int           { return len(x.t) }
#      func (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) }
#      func (x customSort) Swap(i, j int)      { x.t[i], x.t[j] = x.t[j], x.t[i] }
#    < src..
   ..src > go
     type customSort struct {
       t    []*Track
       less func(x, y *Track) bool
     }

     func (x customSort) Len() int           { return len(x.t) }
     func (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) }
     func (x customSort) Swap(i, j int)      { x.t[i], x.t[j] = x.t[j], x.t[i] }
   < src..

#    Let’s define a multi-tier ordering function whose primary sort key is the
#    @c(Title), whose secondary key is the @c(Year), and whose tertiary key is the
#    running time, @c(Length). Here’s the call to @c(Sort) using an anonymous
#    ordering function:
   Vamos a definir una funcion de ordenamiento de multiples niveles cuya clave
   de ordenacion principal es @c(Title), cuya clave secundaria es @c(Year), y
   cuya clave terciaria es el tiempo de ejecucion, @c(Length). Aqui esta la
   llamada a @c(Sort) usando una funcion de ordenacion anonima:

#    ..src > go
#      sort.Sort(customSort{tracks, func(x, y *Track) bool {
#        if x.Title != y.Title {
#          return x.Title < y.Title
#        }
#        if x.Year != y.Year {
#          return x.Year < y.Year
#        }
#        if x.Length != y.Length {
#          return x.Length < y.Length
#        }
#        return false
#      }})
#    < src..
   ..src > go
     sort.Sort(customSort{tracks, func(x, y *Track) bool {
       if x.Title != y.Title {
         return x.Title < y.Title
       }
       if x.Year != y.Year {
         return x.Year < y.Year
       }
       if x.Length != y.Length {
         return x.Length < y.Length
       }
       return false
     }})
   < src..

#    And here’s the result. Notice that the tie between the two tracks titled
#    @"(Go) is broken in favor of the older one.
   Y aqui esta el resultado. Observe que el empate entre las dos pistas
   tituladas @"(Go) se rompe en favor de la mas antigua.

#    ..pre >
#      Title       Artist          Album              Year  Length
#      -----       ------          -----              ----  ------
#      Go          Moby            Moby               1992  3m37s
#      Go          Delilah         From the Roots Up  2012  3m38s
#      Go Ahead    Alicia Keys     As I Am            2007  4m36s
#      Ready 2 Go  Martin Solveig  Smash              2011  4m24s
#    < pre..
   ..pre >
     Title       Artist          Album              Year  Length
     -----       ------          -----              ----  ------
     Go          Moby            Moby               1992  3m37s
     Go          Delilah         From the Roots Up  2012  3m38s
     Go Ahead    Alicia Keys     As I Am            2007  4m36s
     Ready 2 Go  Martin Solveig  Smash              2011  4m24s
   < pre..

#    Although sorting a sequence of length @m(n) requires @m[O(n log n)]
#    comparison operations, testing whether a sequence is already sorted requires
#    at most @m(n-1) comparisons. The @c(IsSorted) function from the @c(sort)
#    package checks this for us. Like @c(sort.Sort), it abstracts both the
#    sequence and its ordering function using @c(sort.Interface), but it never
#    calls the @c(Swap) method: This code demonstrates the @c(IntsAreSorted) and
#    @c(Ints) functions and the @c(IntSlice) type:
   Aunque la clasificacion de una secuencia de longitud @m(n) requiere @m[O(n
   log n)] operaciones de comparacion, probar si una secuencia ya esta ordenada
   requiere al menos @m(n-1) comparaciones. La funcion @c(IsSorted) del paquete
   @c(sort) comprueba esto para nosotros. Al igual que @c(sort.Sort), abstrae
   tanto la secuencia y su funcion de ordenacion utilizando @c(sort.Interface),
   pero nunca llama al metodo @c(Swap): Este codigo muestra las funciones
   @c(IntsAreSorted) y @c(Ints) y el tipo @c(IntSlice):

#    ..src > go
#      values := []int{3, 1, 4, 1}
#      fmt.Println(sort.IntsAreSorted(values)) // "false"
#      sort.Ints(values)
#      fmt.Println(values)                     // "[1 1 3 4]"
#      fmt.Println(sort.IntsAreSorted(values)) // "true"
#      sort.Sort(sort.Reverse(sort.IntSlice(values)))
#      fmt.Println(values)                     // "[4 3 1 1]"
#      fmt.Println(sort.IntsAreSorted(values)) // "false"
#    < src..
   ..src > go
     values := []int{3, 1, 4, 1}
     fmt.Println(sort.IntsAreSorted(values)) // "false"
     sort.Ints(values)
     fmt.Println(values)                     // "[1 1 3 4]"
     fmt.Println(sort.IntsAreSorted(values)) // "true"
     sort.Sort(sort.Reverse(sort.IntSlice(values)))
     fmt.Println(values)                     // "[4 3 1 1]"
     fmt.Println(sort.IntsAreSorted(values)) // "false"
   < src..


#    For convenience, the @c(sort) package provides versions of its functions and
#    types specialized for @c([]int), @c([]string), and @c([]float64) using their
#    natural orderings. For other types, such as @c([]int64) or @c([]uint), we’re
#    on our own, though the path is short.
   Por conveniencia, el paquete @c(sort) proporciona versiones de sus funciones
   y tipos especializados para c([]int), @c([]string), y @c([]float64) usando
   sus ordenamientos naturales. Para otros tipos, como @c([]int64) o @c([]uint),
   estamos por nuestra cuenta, aunque el camino es corto.

#    @b(Exercise 7.8): Many GUIs provide a table widget with a stateful multi-tier
#    sort: the primary sort key is the most recently clicked column head, the
#    secondary sort key is the second-most recently clicked column head, and so
#    on. Define an implementation of @c(sort.Interface) for use by such a
#    table. Compare that approach with repeated sorting using @c(sort.Stable).
   @b(Ejercicio 7.8): Muchas interfaces graficas de usuario proporcionan un
   widget de tabla con ordenacion de multiple nivel: la clave de ordenacion
   principal es la primer columna, la segunda clae de ordenacion es la segunda
   columna, y asi sucesivamente. Defina una implementacion de @c(sort.Interface)
   para utilizar con dicha tabla. Compare este enfoque con repetidos
   ordenamientos utilizando @c(sort.Stable).

#    @b(Exercise 7.9): Use the @c(html/template) package (@l(#Section 4.6<>§4.6))
#    to replace @c(printTracks) with a function that displays the tracks as an
#    HTML table. Use the solution to the previous exercise to arrange that each
#    click on a column head makes an HTTP request to sort the table.
   @b(Ejercicio 7.9): Utilice el paquete @c(html/template) (@l(#Seccion
   4.6<>§4.6)) para reemplazar @c(printTracks) con una funcion que muestre los
   tracks como una tabla HTML. Utilice la solucion del ejercicio anterior para
   organizar que cada clic en un encabezado de columna haga una solicitud HTTP
   para ordenar la tabla.

#    @b(Exercise 7.10): The @c(sort.Interface) type can be adapted to other
#    uses. Write a function @c[IsPalindrome(s sort.Interface) bool] that reports
#    whether the sequence @c(s) is a palindrome, in other words, reversing the
#    sequence would not change it. Assume that the elements at indices @c(i) and
#    @c(j) are equal if @c[!s.Less(i, j) && !s.Less(j, i)].
   @b(Ejercicio 7.10): El tipo @c(sort.Interface) se puede adaptar a otros
   usos. Escriba una funcion @c[IsPalindrome(s sort.Interface) bool] que informe
   si la secuencia @c(s) es un palindromo, es decir, la inversion de la
   secuencia no lo cambiaria. Suponga que los elementos en los indices @c(i) y
   @c(j) son iguales si @c[!s.Less(i, j) && !s.Less(j, i)].

# ** Section 7.7 <> The @c(http.Handler) Interface
** Seccion 7.7 <> La Interfaz @c(http.Handler)

#    In @l(#Chapter 1), we saw a glimpse of how to use the @c(net/http) package to
#    implement web clients (@l(#Section 1.5<>§1.5)) and servers (@l(#Section
#    1.7<>§1.7)). In this section, we’ll look more closely at the server API,
#    whose foundation is the @c(http.Handler) interface:
   En el @l(#Capitulo 1), vimos una idea de como utilizar el paquete
   @c(net/http) para implementar clientes web (@l(#Seccion 1.5<>§1.5)) y
   servidores (@l(#Seccion 1.7<>§1.7)). En esta seccion, vamos a ver mas de
   cerca la API del servidor, cuyo fundamento es la interfaz @c(http.Handler):

#    ..figure > @c(net/http)
   ..figure > @c(net/http)

#      ..src > go
#        package http
#
#        type Handler interface {
#          ServeHTTP(w ResponseWriter, r *Request)
#        }
#
#        func ListenAndServe(address string, h Handler) error
#      < src..
     ..src > go
       package http

       type Handler interface {
         ServeHTTP(w ResponseWriter, r *Request)
       }

       func ListenAndServe(address string, h Handler) error
     < src..

#    The @c(ListenAndServe) function requires a server address, such as
#    @c("localhost:8000"), and an instance of the @c(Handler) interface to which
#    all requests should be dispatched. It runs forever, or until the server fails
#    (or fails to start) with an error, always non-nil, which it returns.
   La función @c(ListenAndServe) requiere una dirección de servidor, como
   @c("localhost:8000"), y una instancia de la interfaz @c(Handler) a la que
   todas las solicitudes deben enviarse. Se ejecuta para siempre, o hasta que el
   servidor falla (o no se inicia) con un error, que siempre devuelve no-nil.

#    Imagine an e-commerce site with a database mapping the items for sale to
#    their prices in dollars. The program below shows the simplest imaginable
#    implementation. It models the inventory as a map type, @c(database), to which
#    we’ve attached a @c(ServeHTTP) method so that it satisfies the
#    @c(http.Handler) interface. The handler ranges over the map and prints the
#    items.
   Imagine un sitio de comercio electronico con una base de datos de los
   articulos a la venta con sus precios en dolares. El siguiente programa
   muestra la implementacion imaginable mas sencilla. Modelos del inventario
   como un tipo de mapa, @c(database), a la que ha adjuntado un metodo
   @c(ServeHTTP) para que satisfaga la interfaz @c(http.Handler). El controlador
   se extiende sobre el mapa e imprime los elementos.

#    ..figure > @l(gopl.io/ch7/http1/main.go<>gopl.io/ch7/http1)
   ..figure > @l(gopl.io/ch7/http1/main.go<>gopl.io/ch7/http1)

#      ..src > go
#        func main() {
#          db := database{"shoes": 50, "socks": 5}
#          log.Fatal(http.ListenAndServe("localhost:8000", db))
#        }
#
#        type dollars float32
#
#        func (d dollars) String() string { return fmt.Sprintf("$%.2f", d) }
#
#        type database map[string]dollars
#
#        func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
#          for item, price := range db {
#            fmt.Fprintf(w, "%s: %s\n", item, price)
#          }
#        }
#      < src..
     ..src > go
       func main() {
         db := database{"shoes": 50, "socks": 5}
         log.Fatal(http.ListenAndServe("localhost:8000", db))
       }

       type dollars float32

       func (d dollars) String() string { return fmt.Sprintf("$%.2f", d) }

       type database map[string]dollars

       func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
         for item, price := range db {
           fmt.Fprintf(w, "%s: %s\n", item, price)
         }
       }
     < src..


#    If we start the server,
   Si iniciamos el servidor,

#    ..src > sh
#      $ go build gopl.io/ch7/http1
#      $ ./http1 &
#    < src..
   ..src > sh
     $ go build gopl.io/ch7/http1
     $ ./http1 &
   < src..

#    then connect to it with the @$(fetch) program from @l(#Section 1.5) (or a web
#    browser if you prefer), we get the following output:
   luego conectamos con el con el programa @$(fetch) de la @l(#Seccion 1.5) (o
   con un navegador web, si lo prefiere), obtenemos el siguiente resultado:

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://localhost:8000
#      shoes: $50.00
#      socks: $5.00
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://localhost:8000
     shoes: $50.00
     socks: $5.00
   < src..

#    So far, the server can only list its entire inventory and will do this for
#    every request, regardless of URL. A more realistic server defines multiple
#    different URLs, each triggering a different behavior. Let’s call the existing
#    one @c(/list) and add another one called @c(/price) that reports the price of
#    a single item, specified as a request parameter like @c(/price?item=socks).
   Hasta ahora, el servidor solo puede enumerar su inventario completo y lo hara
   para cada solicitud, independientemente de la URL. Un servidor mas realista
   define varias URL diferentes, cada una desencadenando un comportamiento
   diferente. Vamos a llamar al comportamiento existente @c(/list) y añadamos
   otra que se llame @c(/price) que informa el precio de un solo articulo,
   especificado como un parametro de la peticion, por ejemplo @c(/price?item=socks).

#    ..figure > @l(gopl.io/ch7/http2/main.go<>gopl.io/ch7/http2)
   ..figure > @l(gopl.io/ch7/http2/main.go<>gopl.io/ch7/http2)

#      ..src > go
#        func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
#          switch req.URL.Path {
#          case "/list":
#            for item, price := range db {
#              fmt.Fprintf(w, "%s: %s\n", item, price)
#            }
#          case "/price":
#            item := req.URL.Query().Get("item")
#            price, ok := db[item]
#            if !ok {
#              w.WriteHeader(http.StatusNotFound) // 404
#              fmt.Fprintf(w, "no such item: %q\n", item)
#              return
#            }
#            fmt.Fprintf(w, "%s\n", price)
#          default:
#            w.WriteHeader(http.StatusNotFound)  // 404
#            fmt.Fprintf(w, "no such page: %s\n", req.URL)
#          }
#        }
#      < src..
     ..src > go
       func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
         switch req.URL.Path {
         case "/list":
           for item, price := range db {
             fmt.Fprintf(w, "%s: %s\n", item, price)
           }
         case "/price":
           item := req.URL.Query().Get("item")
           price, ok := db[item]
           if !ok {
             w.WriteHeader(http.StatusNotFound) // 404
             fmt.Fprintf(w, "no such item: %q\n", item)
             return
           }
           fmt.Fprintf(w, "%s\n", price)
         default:
           w.WriteHeader(http.StatusNotFound)  // 404
           fmt.Fprintf(w, "no such page: %s\n", req.URL)
         }
       }
     < src..


#    Now the handler decides what logic to execute based on the path component of
#    the URL, @c(req.URL.Path). If the handler doesn’t recognize the path, it
#    reports an HTTP error to the client by calling
#    @c[w.WriteHeader(http.StatusNotFound)]; this must be done before writing any
#    text to @c(w). (Incidentally, @c(http.ResponseWriter) is another interface.
#    It augments @c(io.Writer) with methods for sending HTTP response headers.)
#    Equivalently, we could use the @c(http.Error) utility function:
   Ahora el controlador decide que logica hay que usar basado en el componente
   de la ruta de la URL, @c(req.URL.Path). Si el controlador no reconoce la
   ruta, se informa de un error HTTP al cliente llamando a
   @c[w.WriteHeader(http.StatusNotFound)]; esto debe hacerse antes de escribir
   cualquier texto a @c(w). (Por cierto, @c[http.ResponseWriter] es otra
   interfaz. aumenta a @c(io.Writer) con metodos para enviar cabeceras de
   respuesta HTTP.) De manera equivalente, podriamos utilizar la funcion de
   utilidad @c(http.Error):

#    ..src > go
#      msg := fmt.Sprintf("no such page: %s\n", req.URL)
#      http.Error(w, msg, http.StatusNotFound) // 404
#    < src..
   ..src > go
     msg := fmt.Sprintf("no such page: %s\n", req.URL)
     http.Error(w, msg, http.StatusNotFound) // 404
   < src..

#    The case for @c(/price) calls the URL’s @c(Query) method to parse the HTTP
#    request parameters as a map, or more precisely, a multimap of type
#    @c(url.Values) (@l(#Section 6.2.1<>§6.2.1)) from the @c(net/url) package. It
#    then finds the first @c(item) parameter and looks up its price. If the item
#    wasn’t found, it reports an error.
   El argumento @c(/price) llama al metodo @c(Query) de la URL para analizar los
   parametros de la peticion HTTP como un mapa, o mas precisamente, un mapa
   multiple de tipo @c(url.Values) (@l(#Seccion 6.2.1<>§6.2.1)) del paquete
   @c(net/url). A continuacion, busca el primer parametro @c(item) y mira su
   precio. Si no se encontro el elemento, informa de un error.

#    Here’s an example session with the new server:
   He aqui una sesion de ejemplo con el nuevo servidor:

#    ..src > sh
#      $ go build gopl.io/ch7/http2
#      $ go build gopl.io/ch1/fetch
#      $ ./http2 &
#      $ ./fetch http://localhost:8000/list
#      shoes: $50.00
#      socks: $5.00
#      $ ./fetch http://localhost:8000/price?item=socks
#      $5.00
#      $ ./fetch http://localhost:8000/price?item=shoes
#      $50.00
#      $ ./fetch http://localhost:8000/price?item=hat
#      no such item: "hat"
#      $ ./fetch http://localhost:8000/help
#      no such page: /help
#    < src..
   ..src > sh
     $ go build gopl.io/ch7/http2
     $ go build gopl.io/ch1/fetch
     $ ./http2 &
     $ ./fetch http://localhost:8000/list
     shoes: $50.00
     socks: $5.00
     $ ./fetch http://localhost:8000/price?item=socks
     $5.00
     $ ./fetch http://localhost:8000/price?item=shoes
     $50.00
     $ ./fetch http://localhost:8000/price?item=hat
     no such item: "hat"
     $ ./fetch http://localhost:8000/help
     no such page: /help
   < src..

#    Obviously we could keep adding cases to @c(ServeHTTP), but in a realistic
#    application, it’s convenient to define the logic for each case in a separate
#    function or method. Furthermore, related URLs may need similar logic; several
#    image files may have URLs of the form @c(/images/*.png), for instance. For
#    these reasons, @c(net/http) provides @c(ServeMux), a @e(request multiplexer),
#    to simplify the association between URLs and handlers. A @c(ServeMux)
#    aggregates a collection of @c(http.Handlers) into a single @c(http.Handler).
#    Again, we see that different types satisfying the same interface are
#    @e(substitutable): the web server can dispatch requests to any
#    @c(http.Handler), regardless of which concrete type is behind it.
   Obviamente podriamos seguir añadiendo casos a @c(ServeHTTP), pero en una
   aplicacion real, es conveniente definir la logica para cada caso en una
   funcion o un metodo independiente. Ademas, las URL relacionadas pueden
   necesitar una logica similar; varios archivos de imagen pueden tener URLs de
   tipo @c(/images/*.png), por ejemplo. Por estas razones, @c(net/http)
   proporciona @c(ServeMux), una solicitud multiplexor, para simplificar la
   asociacion entre las direcciones URL y manipuladores. @c(ServeMux) agrega una
   coleccion de @c(http.Handlers) en un solo @c(http.Handler). Una vez mas,
   vemos que los diferentes tipos que satisfacen la misma interfaz son
   @e(sustituibles): el servidor web es capaz de consultar a cualquier
   @c(http.Handler), independientemente del tipo concreto esta detras de el.

#    For a more complex application, several @c(ServeMuxes) may be composed to
#    handle more intricate dispatching requirements. Go doesn’t have a canonical
#    web framework analogous to Ruby’s Rails or Python’s Django. This is not to
#    say that such frameworks don’t exist, but the building blocks in Go’s
#    standard library are flexible enough that frameworks are often unnecessary.
#    Furthermore, although frameworks are convenient in the early phases of a
#    project, their additional complexity can make longer-term maintenance harder.
   Para una aplicacion mas compleja, varios @c(ServeMuxes) pueden estar
   compuestos para manejar requerimientos de secuenciacion mas intrincados. Go
   no tiene un framework web canonico analogo a Rails de Ruby o a Django de
   Python. Esto no quiere decir que tales frameworks no existan, pero los
   bloques de construccion en la libreria estandar de Go son lo suficientemente
   flexibles como para que los frameworks sean a menudo innecesarios. Ademas,
   aunque los frameworks son convenientes en las primeras fases de un proyecto,
   su complejidad adicional puede hacer que el mantenimiento a largo plazo sea
   mas dificil.

#    In the program below, we create a @c(ServeMux) and use it to associate the
#    URLs with the corresponding handlers for the @c(/list) and @c(/price)
#    operations, which have been split into separate methods. We then use the
#    @c(ServeMux) as the main handler in the call to @c(ListenAndServe).
   En el siguiente programa, creamos un @c(ServeMux) y lo usamos para asociar
   las direcciones URL con los controladores correspondientes para las
   operaciones @c(/list) y @c(/price,) que se han dividido en metodos
   separados. A continuacion, utilizamos @c(ServeMux) como el controlador
   principal en la llamada a @c(ListenAndServe).

#    ..figure > @l(gopl.io/ch7/http3/main.go<>gopl.io/ch7/http3)
   ..figure > @l(gopl.io/ch7/http3/main.go<>gopl.io/ch7/http3)

#      ..src > go
#        func main() {
#          db := database{"shoes": 50, "socks": 5}
#          mux := http.NewServeMux()
#          mux.Handle("/list", http.HandlerFunc(db.list))
#          mux.Handle("/price", http.HandlerFunc(db.price))
#          log.Fatal(http.ListenAndServe("localhost:8000", mux))
#        }
#
#        type database map[string]dollars
#
#        func (db database) list(w http.ResponseWriter, req *http.Request) {
#          for item, price := range db {
#            fmt.Fprintf(w, "%s: %s\n", item, price)
#          }
#        }
#
#        func (db database) price(w http.ResponseWriter, req *http.Request) {
#          item := req.URL.Query().Get("item")
#          price, ok := db[item]
#          if !ok {
#            w.WriteHeader(http.StatusNotFound) // 404
#            fmt.Fprintf(w, "no such item: %q\n", item)
#            return
#          }
#          fmt.Fprintf(w, "%s\n", price)
#        }
#      < src..
     ..src > go
       func main() {
         db := database{"shoes": 50, "socks": 5}
         mux := http.NewServeMux()
         mux.Handle("/list", http.HandlerFunc(db.list))
         mux.Handle("/price", http.HandlerFunc(db.price))
         log.Fatal(http.ListenAndServe("localhost:8000", mux))
       }

       type database map[string]dollars

       func (db database) list(w http.ResponseWriter, req *http.Request) {
         for item, price := range db {
           fmt.Fprintf(w, "%s: %s\n", item, price)
         }
       }

       func (db database) price(w http.ResponseWriter, req *http.Request) {
         item := req.URL.Query().Get("item")
         price, ok := db[item]
         if !ok {
           w.WriteHeader(http.StatusNotFound) // 404
           fmt.Fprintf(w, "no such item: %q\n", item)
           return
         }
         fmt.Fprintf(w, "%s\n", price)
       }
     < src..


#    Let’s focus on the two calls to @c(mux.Handle) that register the handlers. In
#    the first one, @c(db.list) is a method value (@l(#Section 6.4<>§6.4)), that
#    is, a value of type
   Centremonos en las dos llamadas a @c(mux.Handle) que registran los
   manejadores. En la primera, @c(db.list) es un valor de metodo (@l(#Seccion
   6.4<>§6.4)), es decir, un valor de tipo

#    ..src > go
#      func(w http.ResponseWriter, req *http.Request)
#    < src..
   ..src > go
     func(w http.ResponseWriter, req *http.Request)
   < src..

#    that, when called, invokes the @c(database.list) method with the receiver
#    value @c(db). So @c(db.list) is a function that implements handler-like
#    behavior, but since it has no methods, it doesn’t satisfy the
#    @c(http.Handler) interface and can’t be passed directly to @c(mux.Handle).
   que, cuando se llama, invoca el metodo @c(database.list) con el valor
   receptor @c(db). Asi que @c(db.list) es una funcion que implementa el
   comportamiento manipulador, pero ya que no tiene metodos, no satisface la
   interfaz @c(http.Handler) y no se puede pasar directamente a @c(mux.Handle).

#    The expression @c[http.HandlerFunc(db.list)] is a conversion, not a function
#    call, since @c(http.HandlerFunc) is a type. It has the following definition:
   La expresion @c[http.HandlerFunc(db.list)] es una conversion, no una llamada
   de funcion, ya que @c(http.HandlerFunc) es un tipo. Tiene la siguiente
   definicion:

#    ..figure > @c(net/http)
   ..figure > @c(net/http)

#      ..src > go
#        package http
#
#        type HandlerFunc func(w ResponseWriter, r *Request)
#
#        func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
#          f(w, r)
#        }
#      < src..
     ..src > go
       package http

       type HandlerFunc func(w ResponseWriter, r *Request)

       func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
         f(w, r)
       }
     < src..


#    @c(HandlerFunc) demonstrates some unusual features of Go’s interface
#    mechanism. It is a function type that has methods and satisfies an interface,
#    @c(http.Handler). The behavior of its @c(ServeHTTP) method is to call the
#    underlying function. @c(HandlerFunc) is thus an adapter that lets a function
#    value satisfy an interface, where the function and the interface’s sole
#    method have the same signature. In effect, this trick lets a single type such
#    as @c(database) satisfy the @c(http.Handler) interface several different
#    ways: once through its @c(list) method, once through its @c(price) method,
#    and so on.
   @c(HandlerFunc) demuestra algunas caracteristicas inusuales del mecanismo de
   interfaz de Go. Es un tipo de funcion que tiene metodos y satisface una
   interfaz, @c(http.Handler). El comportamiento de su @c(ServeHTTP) metodo es
   llamar a la funcion subyacente. @c(HandlerFunc) es, por tanto, un adaptador
   que permite que un valor de funcion de satisfaga una interfaz, donde la
   funcion y el unico metodo de la interfaz tienen la misma firma. En efecto,
   este truco permite que un solo tipo, como @c(database) cumpla con la interfaz
   @c(http.Handler) de varias maneras: una vez a traves de su @c(list) metodo,
   una vez que a traves de su metodo @c(price), y asi sucesivamente.

#    Because registering a handler this way is so common, @c(ServeMux) has a
#    convenience method called @c(HandleFunc) that does it for us, so we can
#    simplify the handler registration code to this:
   Debido a que el registro de un manejador de esta manera es tan comun,
   @c(ServeMux) tiene un metodo de conveniencia llamado @c(HandleFunc) que lo
   hace por nosotros, por lo que podemos simplificar el codigo de registro del
   manejador a esto:

#    ..figure > @l(gopl.io/ch7/http3a/main.go<>gopl.io/ch7/http3a)
   ..figure > @l(gopl.io/ch7/http3a/main.go<>gopl.io/ch7/http3a)

#      ..src > go
#        mux.HandleFunc("/list", db.list)
#        mux.HandleFunc("/price", db.price)
#      < src..
     ..src > go
       mux.HandleFunc("/list", db.list)
       mux.HandleFunc("/price", db.price)
     < src..


#    It’s easy to see from the code above how one would construct a program in
#    which there are two different web servers, listening on different ports,
#    defining different URLs, and dispatching to different handlers. We would just
#    construct another @c(ServeMux) and make another call to @c(ListenAndServe),
#    perhaps concurrently. But in most programs, one web server is plenty. Also,
#    it’s typical to define HTTP handlers across many files of an application, and
#    it would be a nuisance if they all had to be explicitly registered with the
#    application’s @c(ServeMux) instance.
   Es facil ver desde el codigo anterior como uno podria construir un programa
   en el que hay dos servidores web diferentes, escuchando en diferentes
   puertos, definiendo diferentes URL y enviando a diferentes
   manejadores. Simplemente construiriamos otro ServeMux y hariamos otra llamada
   a @c(ListenAndServe), tal vez al mismo tiempo. Pero en la mayoria de los
   programas, un servidor web es suficiente. Ademas, es tipico definir
   manejadores HTTP a traves de muchos archivos de una aplicacion, y seria una
   molestia si todos tuvieran que ser registrados de manera explicita con la
   instancia de la aplicacion @c(ServeMux).

#    So, for convenience, @c(net/http) provides a global @c(ServeMux) instance
#    called @c(DefaultServeMux) and package-level functions called @c(http.Handle) and
#    @c(http.HandleFunc). To use @c(DefaultServeMux) as the server’s main handler, we
#    needn’t pass it to @c(ListenAndServe); @c(nil) will do.
   Asi que, por conveniencia, @c(net/http) proporciona unna instancia global
   @c(ServeMux) llamada @c(DefaultServeMux) y funciones a nivel de paquete
   llamadas @c(http.Handle) y @c(http.HandleFunc). Para utilizar
   @c(DefaultServeMux) como manejador principal del servidor, no es necesario
   pasarlo a @c(ListenAndServe); @c(nil) lo hara.

#    The server’s main function can then be simplified to
   La funcion principal del servidor se puede simplificar a

#    ..figure > @l(gopl.io/ch7/http4/main.go<>gopl.io/ch7/http4)
   ..figure > @l(gopl.io/ch7/http4/main.go<>gopl.io/ch7/http4)

#      ..src > go
#        func main() {
#          db := database{"shoes": 50, "socks": 5}
#          http.HandleFunc("/list", db.list)
#          http.HandleFunc("/price", db.price)
#          log.Fatal(http.ListenAndServe("localhost:8000", nil))
#        }
#      < src..
     ..src > go
       func main() {
         db := database{"shoes": 50, "socks": 5}
         http.HandleFunc("/list", db.list)
         http.HandleFunc("/price", db.price)
         log.Fatal(http.ListenAndServe("localhost:8000", nil))
       }
     < src..


#    Finally, an important reminder: as we mentioned in @l(#Section 1.7), the web
#    server invokes each handler in a new goroutine, so handlers must take
#    precautions such as @e(locking) when accessing variables that other
#    goroutines, including other requests to the same handler, may be
#    accessing. We’ll talk about concurrency in the next two chapters.
   Por ultimo, un recordatorio importante: como mencionamos en la @l(#Seccion
   1.7), el servidor web invoca cada manejador en una nueva goroutine, por lo
   que los manipuladores deben tomar precauciones como el @e(bloqueo) al acceder
   a variables de otras gorutinas, incluyendo otras solicitudes al mismo
   manejador. Hablaremos de concurrencia en los proximos dos capitulos.

#    @b(Exercise 7.11): Add additional handlers so that clients can create, read,
#    update, and delete database entries. For example, a request of the form
#    @c(/update?item=socks&price=6) will update the price of an item in the
#    inventory and report an error if the item does not exist or if the price is
#    invalid. (Warning: this change introduces concurrent variable updates.)
   @b(Ejercicio 7.11) Agregar manejadores adicionales para que los clientes
   pueden crear, leer, actualizar y eliminar entradas de @c(database). Por
   ejemplo, una solicitud con formato @c(/update?item=socks&price=6) actualizara
   el precio de un articulo en el inventario e informar un error si el elemento
   no existe o si el precio no es valido. (Advertencia: este cambio introduce
   actualizacion de variables concurrentes.)

#    @b(Exercise 7.12): Change the handler for @c(/list) to print its output as an
#    HTML table, not text.  You may find the @c(html/template) package
#    (@l(#Section 4.6<>§4.6)) useful.
   @b(Ejercicio 7.12): Cambiar el manejador de @c(/list) para imprimir su salida
   como una tabla HTML, no como texto. Puede que el paquete @c(html/template)
   (@l(#Seccion 4.6<>§4.6)) sea util.

# ** Section 7.8 <> The @c(error) Interface
** Seccion 7.8 <> La Interfaz @c(error)

#    Since the beginning of this book, we’ve been using and creating values of the
#    mysterious predeclared @c(error) type without explaining what it really
#    is. In fact, it’s just an interface type with a single method that returns an
#    error message:
   Desde el comienzo de este libro, hemos estado usando y creando valores del
   misterioso tipo predeclarado @c(error) sin explicar lo que realmente es. De
   hecho, es solo un tipo de interfaz con un unico metodo que devuelve un
   mensaje de error:

#    ..src > go
#      type error interface {
#        Error() string
#      }
#    < src..
   ..src > go
     type error interface {
       Error() string
     }
   < src..

#    The simplest way to create an @c(error) is by calling @c(errors.New), which
#    returns a new @c(error) for a given error message. The entire @c(errors)
#    package is only four lines long:
   La forma mas sencilla de crear un @c(error) es llamando a @c(errors.New,) que
   devuelve un nuevo @c(error) para un mensaje de error dado. Todo el paquete
   @c(errors) solo son cuatro lineas:

#    ..src > go
#      package errors
#
#      func New(text string) error { return &errorString{text} }
#
#      type errorString struct { text string }
#
#      func (e *errorString) Error() string { return e.text }
#    < src..
   ..src > go
     package errors

     func New(text string) error { return &errorString{text} }

     type errorString struct { text string }

     func (e *errorString) Error() string { return e.text }
   < src..

#    The underlying type of @c(errorString) is a struct, not a string, to protect
#    its representation from inadvertent (or premeditated) updates. And the reason
#    that the pointer type @c(*errorString), not @c(errorString) alone, satisfies
#    the @c(error) interface is so that every call to @c(New) allocates a distinct
#    @c(error) instance that is equal to no other. We would not want a
#    distinguished error such as @c(io.EOF) to compare equal to one that merely
#    happened to have the same message.
   El tipo subyacente de @c(errorString) es una estructura, no una cadena, para
   proteger su representacion de cambios involuntarios (o premeditados). Y la
   razon de que el tipo de puntero sea @c(*errorString), no es solo
   @c(errorString), para satisfacer la interfaz @c(error) es para que cada
   llamada a @c(New) asigne una instancia de error distinta que no es igual a
   ninguna otra. No queremos que un error distinguido como @c(io.EOF) sea igual
   a o uno que simplemente contien el mismo mensaje.

#    ..src > go
#      fmt.Println(errors.New("EOF") == errors.New("EOF")) // "false"
#    < src..
   ..src > go
     fmt.Println(errors.New("EOF") == errors.New("EOF")) // "false"
   < src..

#    Calls to @c(errors.New) are relatively infrequent because there’s a
#    convenient wrapper function, @c(fmt.Errorf), that does string formatting
#    too. We used it several times in @l(#Chapter 5).
   Las llamadas a @c(errors.New) son relativamente poco frecuentes porque hay
   una funcion de envoltura conveniente, @c(fmt.Errorf), que tambien hace
   formateo de cadenas. Lo usamos varias veces en el @l(#Capitulo 5).

#    ..src > go
#      package fmt
#
#      import "errors"
#
#      func Errorf(format string, args ...interface{}) error {
#        return errors.New(Sprintf(format, args...))
#      }
#    < src..
   ..src > go
     package fmt

     import "errors"

     func Errorf(format string, args ...interface{}) error {
       return errors.New(Sprintf(format, args...))
     }
   < src..

#    Although @c(*errorString) may be the simplest type of @c(error), it is far
#    from the only one. For example, the @c(syscall) package provides Go’s
#    low-level system call API. On many platforms, it defines a numeric type
#    @c(Errno) that satisfies @c(error), and on Unix platforms, @c(Errno)’s
#    @c(Error) method does a lookup in a table of strings, as shown below :
   Aunque @c(*errorString) puede ser el tipo mas sencillo de @c(error), esta
   lejos de ser el unico. Por ejemplo, el paquete @c(syscall) proporciona la API
   de llamadas a bajo nivel de Go. En muchas plataformas, define un tipo
   numerico @c(Errno) que satisface @c(error), y en plataformas Unix, el metodo
   @c(Errno) de @c(Error) realiza una busqueda en una tabla de cadenas, como se
   muestra a continuacion:

#    ..src > go
#      package syscall
#
#      type Errno uintptr // operating system error code
#
#      var errors = [...]string{
#        1: "operation not permitted",   // EPERM
#        2: "no such file or directory", // ENOENT
#        3: "no such process",           // ESRCH
#        // ...
#      }
#
#      func (e Errno) Error() string {
#        if 0 <= int(e) && int(e) < len(errors) {
#          return errors[e]
#        }
#        return fmt.Sprintf("errno %d", e)
#      }
#    < src..
   ..src > go
     package syscall

     type Errno uintptr // codigos de error del sistema operativo

     var errors = [...]string{
       1: "operation not permitted",   // EPERM
       2: "no such file or directory", // ENOENT
       3: "no such process",           // ESRCH
       // ...
     }

     func (e Errno) Error() string {
       if 0 <= int(e) && int(e) < len(errors) {
         return errors[e]
       }
       return fmt.Sprintf("errno %d", e)
     }
   < src..

#    The following statement creates an interface value holding the @c(Errno)
#    value 2, signifying the POSIX @c(ENOENT) condition:
   La siguiente sentencia crea un valor de interfaz que contiene el valor
   @c(Errno) 2, que significa la condicion POSIX @c(ENOENT):

#    ..src > go
#      var err error = syscall.Errno(2)
#      fmt.Println(err.Error()) // "no such file or directory"
#      fmt.Println(err)         // "no such file or directory"
#    < src..
   ..src > go
     var err error = syscall.Errno(2)
     fmt.Println(err.Error()) // "el fichero o directorio no existe"
     fmt.Println(err)         // "el fichero o directorio no existe"
   < src..

#    The value of @c(err) is shown graphically in Figure 7.6.
   El valor de @c(err) se muestra graficamente en la Figura 7.6.

#    ..figure > Figure 7.6. An interface value holding a @c(syscall.Errno)
#      integer.
   ..figure > Figura 7.6. Un valor de interfaz que contiene un entero @c(syscall.Errno).

#      ..art >
#              err
#              ┏━━━━━━━━━━━━━━━━━┓
#         type ┃  syscall.Errno  ┃
#              ┣━━━━━━━━━━━━━━━━━┫
#        value ┃        2        ┃
#              ┗━━━━━━━━━━━━━━━━━┛
#      < art..
     ..art >
             err
             ┏━━━━━━━━━━━━━━━━━┓
        tipo ┃  syscall.Errno  ┃
             ┣━━━━━━━━━━━━━━━━━┫
       valor ┃        2        ┃
             ┗━━━━━━━━━━━━━━━━━┛
     < art..


#    @c(Errno) is an efficient representation of system call errors drawn from a
#    finite set, and it satisfies the standard @c(error) interface. We’ll see
#    other types that satisfy this interface in @l(#Section 7.11).
   @c(Errno) es una representacion eficiente de los errores de llamada del
   sistema extraidos de un conjunto finito, y satisface la interfaz estandar
   @c(error). Veremos otros tipos que satisfacen esta interfaz en la @l(#Seccion
   7.11).

# ** Section 7.9 <> Example: Expression Evaluator
** Seccion 7.9 <> Ejemplo: Evaluador de Expresiones

#    In this section, we’ll build an evaluator for simple arithmetic
#    expressions. We’ll use an interface, @c(Expr), to represent any expression in
#    this language. For now, this interface needs no methods, but we’ll add some
#    later.
   En esta seccion, crearemos un evaluador para expresiones aritmeticas
   simples. Vamos a utilizar una interfaz, @c(Expr), para representar cualquier
   expresion en este lenguaje. Por ahora, esta interfaz no necesita metodos,
   pero agregaremos algunos mas tarde.

#    ..src > go
#      // An Expr is an arithmetic expression.
#      type Expr interface{}
#    < src..
   ..src > go
     // Un Expr es una expresion aritmetica.
     type Expr interface{}
   < src..

#    Our expression language consists of floating-point literals; the binary
#    operators @c(+), @c(-), @c(*), and @c(/); the unary operators @c(-x) and
#    @c(+x); function calls @c[pow(x,y)], @c[sin(x)], and @c[sqrt(x)]; variables
#    such as @c(x) and @c(pi); and of course parentheses and standard operator
#    precedence. All values are of type @c(float64). Here are some example
#    expressions:
   Nuestro lenguaje de expresiones consiste en literales de punto flotante; los
   operadores binarios @c(+), @c(-), @c(*) y @c(/); los operadores unarios
   @c(-x) y @c(+x); llamadas de funcion @c[pow(x,y)], @c[sin(x)], y @c[sqrt(x)];
   variables como @c(x) y @c(pi); Y por supuesto los parentesis y la precedencia
   estandar de operadores. Todos los valores son del tipo @c(float64). Aqui hay
   algunas expresiones de ejemplo:

#    ..src > go
#      sqrt(A / pi)
#      pow(x, 3) + pow(y, 3)
#      (F - 32) * 5 / 9
#    < src..
   ..src > go
     sqrt(A / pi)
     pow(x, 3) + pow(y, 3)
     (F - 32) * 5 / 9
   < src..

#    The five concrete types below represent particular kinds of expression. A
#    @c(Var) represents a reference to a variable. (We’ll soon see why it is
#    exported.) A @c(literal) represents a floatingpoint constant. The @c(unary)
#    and @c(binary) types represent operator expressions with one or two operands,
#    which can be any kind of @c(Expr). A @c(call) represents a function call;
#    we’ll restrict its @c(fn) field to @c(pow), @c(sin), or @c(sqrt).
   Los cinco tipos concretos de abajo representan tipos particulares de
   expresiones. un @c(Var) representa una referencia a una variable. (Pronto
   veremos por que se exporta.) Un @c(literal) representa una constante de coma
   flotante. Los tipos @c(unary) y @c(binary) representan expresiones de
   operador con uno o dos operandos, que pueden ser cualquier tipo de
   @c(Expr). Un @c(call) es una llamada de funcion; restringiremos este campo
   @c(fn) a @c(pow), @c(sin), o @c(sqrt).

#    ..figure > @l(gopl.io/ch7/eval/ast.go<>gopl.io/ch7/eval)
   ..figure > @l(gopl.io/ch7/eval/ast.go<>gopl.io/ch7/eval)

#      ..src > go
#        // A Var identifies a variable, e.g., x.
#        type Var string
#
#        // A literal is a numeric constant, e.g., 3.141.
#        type literal float64
#
#        // A unary represents a unary operator expression, e.g., -x.
#        type unary struct {
#          op rune // one of '+', '-'
#          x  Expr
#        }
#
#        // A binary represents a binary operator expression, e.g., x+y.
#        type binary struct {
#          op   rune // one of '+', '-', '*', '/'
#          x, y Expr
#        }
#
#        // A call represents a function call expression, e.g., sin(x).
#        type call struct {
#          fn   string // one of "pow", "sin", "sqrt"
#          args []Expr
#        }
#      < src..
     ..src > go
       // Un Var identifica una variable, por ejemplo, x.
       type Var string

       // Un literal es un numero constante, por ejemplo, 3.141.
       type literal float64

       // Un unary representa una expresion de operador unario, por ejemplo, -x.
       type unary struct {
         op rune // one of '+', '-'
         x  Expr
       }

       // Un binary representa una expresion de operador binario, por ejemplo, x+y.
       type binary struct {
         op   rune // one of '+', '-', '*', '/'
         x, y Expr
       }

       // Un call representa una expresion de llamada a funcion, por ejemplo, sin(x).
       type call struct {
         fn   string // uno de "pow", "sin", "sqrt"
         args []Expr
       }
     < src..


#    To evaluate an expression containing variables, we’ll need an @e(environment)
#    that maps variable names to values:
   Para evaluar una expresion que contiene variables, necesitaremos un entorno
   que asigne nombres de variables a valores:

#    ..src > go
#      type Env map[Var]float64
#    < src..
   ..src > go
     type Env map[Var]float64
   < src..

#    We’ll also need each kind of expression to define an @c(Eval) method that
#    returns the expression’s value in a given environment. Since every expression
#    must provide this method, we add it to the @c(Expr) interface. The package
#    exports only the types @c(Expr), @c(Env), and @c(Var); clients can use the
#    evaluator without access to the other expression types.
   Tambien necesitaremos cada tipo de expresion para definir un metodo @c(Eval)
   que devuelva el valor de la expresion en un entorno determinado. Puesto que
   cada expresion debe proporcionar este metodo, lo añadimos a la interfaz
   @c(Expr). El paquete exporta unicamente los tipos @c(Expr), @c(Env), y
   @c(Var); Los clientes pueden utilizar el evaluador sin acceso a los otros
   tipos de expresion.

#    ..src > go
#      type Expr interface {
#        // Eval returns the value of this Expr in the environment env.
#        Eval(env Env) float64
#      }
#    < src..
   ..src > go
     type Expr interface {
       // Eval devuelve el valor de este Expr en el entorno env.
       Eval(env Env) float64
     }
   < src..

#    The concrete @c(Eval) methods are shown below. The method for @c(Var)
#    performs an environment lookup, which returns zero if the variable is not
#    defined, and the method for @c(literal) simply returns the literal value.
   Los metodos concretos de @c(Eval) se muestran a continuacion. El metodo de
   @c(Var) realiza una busqueda de entorno, que devuelve cero si la variable no
   esta definida, y el metodo de @c(literal) simplemente devuelve el valor
   literal.

#    ..src > go
#      func (v Var) Eval(env Env) float64 {
#        return env[v]
#      }
#
#      func (l literal) Eval(_ Env) float64 {
#        return float64(l)
#      }
#    < src..
   ..src > go
     func (v Var) Eval(env Env) float64 {
       return env[v]
     }

     func (l literal) Eval(_ Env) float64 {
       return float64(l)
     }
   < src..

#    The @c(Eval) methods for @c(unary) and @c(binary) recursively evaluate their
#    operands, then apply the operation @c(op) to them. We don’t consider
#    divisions by zero or infinity to be errors, since they produce a result,
#    albeit non-finite. Finally, the method for @c(call) evaluates the arguments
#    to the @c(pow), @c(sin), or @c(sqrt) function, then calls the corresponding
#    function in the @c(math) package.
   Los metodos @c(Eval) de @c(unary) y @c(binary) evaluan de forma recursiva sus
   operandos, luego aplican la operacion @c(op) a ellos. No consideramos
   divisiones por cero o infinito como errores, ya que producen un resultado, no
   finito. Finalmente, el metodo de @c(call) evalua los argumentos de la funcion
   @c(pow), @c(sin), o @c(sqrt), y luego llama a la funcion correspondiente en
   el paquete @c(math).

#    ..src > go
#      func (u unary) Eval(env Env) float64 {
#        switch u.op {
#        case '+':
#          return +u.x.Eval(env)
#        case '-':
#          return -u.x.Eval(env)
#        }
#        panic(fmt.Sprintf("unsupported unary operator: %q", u.op))
#      }
#
#      func (b binary) Eval(env Env) float64 {
#        switch b.op {
#        case '+':
#          return b.x.Eval(env) + b.y.Eval(env)
#        case '-':
#          return b.x.Eval(env) - b.y.Eval(env)
#        case '*':
#          return b.x.Eval(env) * b.y.Eval(env)
#        case '/':
#          return b.x.Eval(env) / b.y.Eval(env)
#        }
#        panic(fmt.Sprintf("unsupported binary operator: %q", b.op))
#      }
#
#      func (c call) Eval(env Env) float64 {
#        switch c.fn {
#        case "pow":
#          return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env))
#        case "sin":
#          return math.Sin(c.args[0].Eval(env))
#        case "sqrt":
#          return math.Sqrt(c.args[0].Eval(env))
#        }
#        panic(fmt.Sprintf("unsupported function call: %s", c.fn))
#      }
#    < src..
   ..src > go
     func (u unary) Eval(env Env) float64 {
       switch u.op {
       case '+':
         return +u.x.Eval(env)
       case '-':
         return -u.x.Eval(env)
       }
       panic(fmt.Sprintf("unsupported unary operator: %q", u.op))
     }

     func (b binary) Eval(env Env) float64 {
       switch b.op {
       case '+':
         return b.x.Eval(env) + b.y.Eval(env)
       case '-':
         return b.x.Eval(env) - b.y.Eval(env)
       case '*':
         return b.x.Eval(env) * b.y.Eval(env)
       case '/':
         return b.x.Eval(env) / b.y.Eval(env)
       }
       panic(fmt.Sprintf("unsupported binary operator: %q", b.op))
     }

     func (c call) Eval(env Env) float64 {
       switch c.fn {
       case "pow":
         return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env))
       case "sin":
         return math.Sin(c.args[0].Eval(env))
       case "sqrt":
         return math.Sqrt(c.args[0].Eval(env))
       }
       panic(fmt.Sprintf("unsupported function call: %s", c.fn))
     }
   < src..

#    Several of these methods can fail. For example, a @c(call) expression could
#    have an unknown function or the wrong number of arguments. It’s also possible
#    to construct a @c(unary) or @c(binary) expression with an invalid operator
#    such as @c(!) or @c(<) (although the @c(Parse) function mentioned below will
#    never do this). These errors cause @c(Eval) to panic. Other errors, like
#    evaluating a @c(Var) not present in the environment, merely cause @c(Eval) to
#    return the wrong result. All of these errors could be detected by inspecting
#    the @c(Expr) before evaluating it. That will be the job of the @c(Check)
#    method, which we will show soon, but first let’s test @c(Eval).
   Varios de estos metodos pueden fallar. Por ejemplo, una expresion @c(call)
   podria tener una funcion desconocida o el numero incorrecto de argumentos.
   Tambien es posible construir una expresion @c(unary) o @c(binary) con un
   operador no valido como @c(!) o @c(<) (aunque la funcion @c(Parse) mencionada
   a continuacion nunca hara esto). Estos errores hacen que @c(Eval) entre en
   panico. Otros errores, la evaluacion de un @c(Var) no presente en el entorno,
   simplemente hacen que @c(Eval) devuelva el resultado incorrecto. Todos estos
   errores podrian ser detectados por la inspeccion de @c(Expr) antes de su
   evaluacion. Ese sera el trabajo del metodo @c(Check), que mostraremos pronto,
   pero primero vamos a probar @c(Eval).

#    The @c(TestEval) function below is a test of the evaluator. It uses the
#    @c(testing) package, which we’ll explain in @l(#Chapter 11), but for now it’s
#    enough to know that calling @c(t.Errorf) reports an error. The function loops
#    over a table of inputs that defines three expressions and different
#    environments for each one. The first expression computes the radius of a
#    circle given its area @c(A), the second computes the sum of the cubes of two
#    variables @c(x) and @c(y), and the third converts a Fahrenheit temperature
#    @c(F) to @c(Celsius).
   La funcion @c(TestEval) a continuacion, es una prueba del evaluador. Utiliza
   el paquete @c(testing), que explicaremos en el @l(#Capitulo 11), pero por
   ahora es suficiente saber que llamar a @c(t.Errorf) informa de un error. La
   funcion recorre una tabla de entradas que define tres expresiones y entornos
   diferentes para cada una. La primer expresion calcula el radio de un circulo
   dada su area @c(A), la segunda calcula la suma de los cubos de dos variables
   @c(x) e @c(y), y la tercera convierte una temperatura @c(Fahrenheit) de @c(F)
   a @c(Celsius).

#    ..src > go
#      func TestEval(t *testing.T) {
#        tests := []struct {
#          expr string
#          env  Env
#          want string
#        }{
#          {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},
#          {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},
#          {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},
#          {"5 / 9 * (F - 32)", Env{"F": -40}, "-40"},
#          {"5 / 9 * (F - 32)", Env{"F": 32}, "0"},
#          {"5 / 9 * (F - 32)", Env{"F": 212}, "100"},
#        }
#        var prevExpr string
#        for _, test := range tests {
#          // Print expr only when it changes.
#          if test.expr != prevExpr {
#            fmt.Printf("\n%s\n", test.expr)
#            prevExpr = test.expr
#          }
#          expr, err := Parse(test.expr)
#          if err != nil {
#            t.Error(err) // parse error
#            continue
#          }
#          got := fmt.Sprintf("%.6g", expr.Eval(test.env))
#          fmt.Printf("\t%v => %s\n", test.env, got)
#          if got != test.want {
#            t.Errorf("%s.Eval() in %s = %q, want %q\n",
#              test.expr, test.env, got, test.want)
#          }
#        }
#      }
#    < src..
   ..src > go
     func TestEval(t *testing.T) {
       tests := []struct {
         expr string
         env  Env
         want string
       }{
         {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},
         {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},
         {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},
         {"5 / 9 * (F - 32)", Env{"F": -40}, "-40"},
         {"5 / 9 * (F - 32)", Env{"F": 32}, "0"},
         {"5 / 9 * (F - 32)", Env{"F": 212}, "100"},
       }
       var prevExpr string
       for _, test := range tests {
         // Imprime expr solo cuando hay cambios.
         if test.expr != prevExpr {
           fmt.Printf("\n%s\n", test.expr)
           prevExpr = test.expr
         }
         expr, err := Parse(test.expr)
         if err != nil {
           t.Error(err) // analiza error
           continue
         }
         got := fmt.Sprintf("%.6g", expr.Eval(test.env))
         fmt.Printf("\t%v => %s\n", test.env, got)
         if got != test.want {
           t.Errorf("%s.Eval() in %s = %q, want %q\n",
             test.expr, test.env, got, test.want)
         }
       }
     }
   < src..

#    For each entry in the table, the test parses the expression, evaluates it in
#    the environment, and prints the result. We don’t have space to show the
#    @c(Parse) function here, but you’ll find it if you download the package using
#    @$(go get).
   Para cada entrada en la tabla, la prueba analiza la expresion, la evalua en
   el entorno e imprime el resultado. No tenemos espacio para mostrar la funcion
   @c(Parse) aqui, pero lo encontrara si se descarga el paquete usando @$(go
   get).

#    The @$(go test) command (@l(#Section 11.1<>§11.1)) runs a package’s tests:
   El comando @$(go test) (@l(#Seccion 11.1<>§11.1)) ejecuta las pruebas de un
   paquete:

#    ..src > sh
#      $ go test -v gopl.io/ch7/eval
#    < src..
   ..src > sh
     $ go test -v gopl.io/ch7/eval
   < src..

#    The @c(-v) flag lets us see the printed output of the test, which is normally
#    suppressed for a successful test like this one. Here is the output of the
#    test’s @c(fmt.Printf) statements:
   La bandera @c(-v) nos permite ver la salida impresa de la prueba, que
   normalmente se suprime para una prueba exitosa como esta. Aqui esta la salida
   de la prueba de las sentencias @c(fmt.Printf):

#    ..src > sh
#      sqrt(A / pi)
#          map[A:87616 pi:3.141592653589793] => 167
#
#      pow(x, 3) + pow(y, 3)
#          map[x:12 y:1] => 1729
#          map[x:9 y:10] => 1729
#
#      5 / 9 * (F - 32)
#          map[F:-40] => -40
#          map[F:32] => 0
#          map[F:212] => 100
#    < src..
   ..src > sh
     sqrt(A / pi)
         map[A:87616 pi:3.141592653589793] => 167

     pow(x, 3) + pow(y, 3)
         map[x:12 y:1] => 1729
         map[x:9 y:10] => 1729

     5 / 9 * (F - 32)
         map[F:-40] => -40
         map[F:32] => 0
         map[F:212] => 100
   < src..

#    Fortunately the inputs so far have all been well formed, but our luck is
#    unlikely to last. Even in interpreted languages, it is common to check the
#    syntax for @e(static) errors, that is, mistakes that can be detected without
#    running the program. By separating the static checks from the dynamic ones,
#    we can detect errors sooner and perform many checks only once instead of each
#    time an expression is evaluated.
   Afortunadamente hasta ahora los datos de entrada han sido bien formados, pero
   es poco probable que dure nuestra suerte. Incluso en los lenguajes
   interpretados, es comun comprobar la sintaxis de errores @e(estaticos), es
   decir, errores que pueden ser detectados sin ejecutar el programa. Al separar
   los controles estaticos de los dinamicos, podemos detectar errores antes y
   realizar muchas verificaciones solo una vez en lugar de cada vez que se
   evalua una expresion.

#    Let’s add another method to the @c(Expr) interface. The @c(Check) method
#    checks for static errors in an expression syntax tree. We’ll explain its
#    @c(vars) parameter in a moment.
   Vamos a añadir otro metodo a la interfaz @c(Expr). El metodo @c(Check)
   comprueba si hay errores estaticos en un arbol de sintaxis de
   expresiones. Vamos a explicar su parametro @c(vars) en un momento.

#    ..src > go
#      type Expr interface {
#        Eval(env Env) float64
#        // Check reports errors in this Expr and adds its Vars to the set.
#        Check(vars map[Var]bool) error
#      }
#    < src..
   ..src > go
     type Expr interface {
       Eval(env Env) float64
       // Check informa errores en este Expr y agrega sus Vars al conjunto.
       Check(vars map[Var]bool) error
     }
   < src..

#    The concrete @c(Check) methods are shown below. Evaluation of @c(literal) and
#    @c(Var) cannot fail, so the @c(Check) methods for these types return
#    @c(nil). The methods for @c(unary) and @c(binary) first check that the
#    operator is valid, then recursively check the operands. Similarly, the method
#    for @c(call) first checks that the function is known and has the right number
#    of arguments, then recursively checks each argument.
   El metodo concreto @c(Check) se muestran a continuacion. La evaluacion de
   @c(literal) y @c(Var) no puede fallar, por lo que los metodos @c(Check) para
   estos tipos devuelven @c(nil). Los metodos para @c(unary) y @c(binary)
   primera verifican que el operador es valido, luego comprueban recursivamente
   los operandos. Del mismo modo, el metodo para de @c(call) comprueba primero
   que la funcion se conoce y tiene el numero correcto de argumentos, entonces,
   de forma recursiva comprueba cada argumento.

#    ..src > go
#      func (v Var) Check(vars map[Var]bool) error {
#        vars[v] = true
#        return nil
#      }
#
#      func (literal) Check(vars map[Var]bool) error {
#        return nil
#      }
#
#      func (u unary) Check(vars map[Var]bool) error {
#        if !strings.ContainsRune("+-", u.op) {
#          return fmt.Errorf("unexpected unary op %q", u.op)
#        }
#        return u.x.Check(vars)
#      }
#
#      func (b binary) Check(vars map[Var]bool) error {
#        if !strings.ContainsRune("+-*/", b.op) {
#          return fmt.Errorf("unexpected binary op %q", b.op)
#        }
#        if err := b.x.Check(vars); err != nil {
#          return err
#        }
#        return b.y.Check(vars)
#      }
#
#      func (c call) Check(vars map[Var]bool) error {
#        arity, ok := numParams[c.fn]
#        if !ok {
#          return fmt.Errorf("unknown function %q", c.fn)
#        }
#        if len(c.args) != arity {
#          return fmt.Errorf("call to %s has %d args, want %d",
#            c.fn, len(c.args), arity)
#        }
#        for _, arg := range c.args {
#          if err := arg.Check(vars); err != nil {
#            return err
#          }
#        }
#        return nil
#      }
#
#      var numParams = map[string]int{"pow": 2, "sin": 1, "sqrt": 1}
#    < src..
   ..src > go
     func (v Var) Check(vars map[Var]bool) error {
       vars[v] = true
       return nil
     }

     func (literal) Check(vars map[Var]bool) error {
       return nil
     }

     func (u unary) Check(vars map[Var]bool) error {
       if !strings.ContainsRune("+-", u.op) {
         return fmt.Errorf("unexpected unary op %q", u.op)
       }
       return u.x.Check(vars)
     }

     func (b binary) Check(vars map[Var]bool) error {
       if !strings.ContainsRune("+-*/", b.op) {
         return fmt.Errorf("unexpected binary op %q", b.op)
       }
       if err := b.x.Check(vars); err != nil {
         return err
       }
       return b.y.Check(vars)
     }

     func (c call) Check(vars map[Var]bool) error {
       arity, ok := numParams[c.fn]
       if !ok {
         return fmt.Errorf("unknown function %q", c.fn)
       }
       if len(c.args) != arity {
         return fmt.Errorf("call to %s has %d args, want %d",
           c.fn, len(c.args), arity)
       }
       for _, arg := range c.args {
         if err := arg.Check(vars); err != nil {
           return err
         }
       }
       return nil
     }

     var numParams = map[string]int{"pow": 2, "sin": 1, "sqrt": 1}
   < src..

#    We’ve listed a selection of flawed inputs and the errors they elicit, in two
#    groups. The @c(Parse) function (not shown) reports syntax errors and the
#    @c(Check) function reports semantic errors.
   Hemos listado una seleccion de entradas defectuosas y los errores que
   provocan, en dos grupos. La funcion @c(Parse) (no se muestra) informa de
   errores de sintaxis y la funcion @c(Check) de informes de errores semanticos.

#    ..pre >
#      x % 2             unexpected '%'
#      math.Pi           unexpected '.'
#      !true             unexpected '!'
#      "hello"           unexpected '"'
#
#      log(10)           unknown function "log"
#      sqrt(1, 2)        call to sqrt has 2 args, want 1
#    < pre..
   ..pre >
     x % 2             unexpected '%'
     math.Pi           unexpected '.'
     !true             unexpected '!'
     "hello"           unexpected '"'

     log(10)           unknown function "log"
     sqrt(1, 2)        call to sqrt has 2 args, want 1
   < pre..

#    @c(Check)’s argument, a set of @c(Vars), accumulates the set of variable
#    names found within the expression. Each of these variables must be present in
#    the environment for evaluation to succeed. This set is logically the
#    @e(result) of the call to @c(Check), but because the method is recursive, it
#    is more convenient for @c(Check) to populate a set passed as a parameter. The
#    client must provide an empty set in the initial call.
   El argumento de @c(Check), un conjunto de @c(Vars), acumula el conjunto de
   nombres de variables que se encuentran dentro de la expresion. Cada una de
   estas variables debe estar presente en el entorno para que la evaluacion
   tenga exito. Este conjunto es, logicamente, el @e(resultado) de la llamar a
   @c(Check), pero debido a que el metodo es recursivo, es mas conveniente para
   @c(Check) llenar el conjunto pasandolo como parametro. El cliente debe
   proporcionar un conjunto vacio en la llamada inicial.

#    In @l(#Section 3.2), we plotted a function @c[f(x,y)] that was fixed at
#    compile time. Now that we can parse, check, and evaluate expressions in
#    strings, we can build a web application that receives an expression at run
#    time from the client and plots the surface of that function. We can use the
#    @c(vars) set to check that the expression is a function of only two
#    variables, @c(x) and @c(y)—three, actually, since we’ll provide @c(r), the
#    radius, as a convenience. And we’ll use the @c(Check) method to reject
#    ill-formed expressions before evaluation begins so that we don’t repeat those
#    checks during the 40,000 evaluations (100×100 cells, each with four corners)
#    of the function that follow.
   En la @l(#Seccion 3.2), se represento una funcion @c[f(x,y)] que se establece
   en tiempo de compilacion. Ahora que podemos analizar, comprobar y evaluar
   expresiones en cadenas, podemos construir una aplicacion web que recibe una
   expresion en tiempo de ejecucion del cliente y traza la superficie de esa
   funcion. Podemos utilizar los @c(vars) establecidos para comprobar que la
   expresion es una funcion de dos variables, @c(x) e @c(y)–tres, en realidad,
   ya que proporcionamos @c(r), el radio, como una conveniencia. Y usaremos el
   metodo @c(Check) para rechazar expresiones mal formadas antes de que comience
   la evaluacion, de mono que no repitamos esas verificaciones durante las
   40.000 evaluaciones (100×100 celulas, cada una con cuatro esquinas) de la
   funcion que le sigue.

#    The @c(parseAndCheck) function combines these parsing and checking steps:
   La funcion @c(parseAndCheck) combina estos pasos de analisis y comprobacion:

#    ..figure > @l(gopl.io/ch7/surface/surface.go<>gopl.io/ch7/surface)
   ..figure > @l(gopl.io/ch7/surface/surface.go<>gopl.io/ch7/surface)

#      ..src > go
#        import "gopl.io/ch7/eval"
#
#        func parseAndCheck(s string) (eval.Expr, error) {
#          if s == "" {
#            return nil, fmt.Errorf("empty expression")
#          }
#          expr, err := eval.Parse(s)
#          if err != nil {
#            return nil, err
#          }
#          vars := make(map[eval.Var]bool)
#          if err := expr.Check(vars); err != nil {
#            return nil, err
#          }
#          for v := range vars {
#            if v != "x" && v != "y" && v != "r" {
#              return nil, fmt.Errorf("undefined variable: %s", v)
#            }
#          }
#          return expr, nil
#        }
#      < src..
     ..src > go
       import "gopl.io/ch7/eval"

       func parseAndCheck(s string) (eval.Expr, error) {
         if s == "" {
           return nil, fmt.Errorf("empty expression")
         }
         expr, err := eval.Parse(s)
         if err != nil {
           return nil, err
         }
         vars := make(map[eval.Var]bool)
         if err := expr.Check(vars); err != nil {
           return nil, err
         }
         for v := range vars {
           if v != "x" && v != "y" && v != "r" {
             return nil, fmt.Errorf("undefined variable: %s", v)
           }
         }
         return expr, nil
       }
     < src..


#    To make this a web application, all we need is the @c(plot) function below,
#    which has the familiar signature of an @c(http.HandlerFunc):
   Para hacer de esto una aplicacion web, todo lo que necesitamos es la siguiente
   funcion @c(plot), que tiene la firma familiar de un @c(http.HandlerFunc):

#    ..src > go
#      func plot(w http.ResponseWriter, r *http.Request) {
#        r.ParseForm()
#        expr, err := parseAndCheck(r.Form.Get("expr"))
#        if err != nil {
#          http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)
#          return
#        }
#        w.Header().Set("Content-Type", "image/svg+xml")
#        surface(w, func(x, y float64) float64 {
#          r := math.Hypot(x, y) // distance from (0,0)
#          return expr.Eval(eval.Env{"x": x, "y": y, "r": r})
#        })
#      }
#    < src..
   ..src > go
     func plot(w http.ResponseWriter, r *http.Request) {
       r.ParseForm()
       expr, err := parseAndCheck(r.Form.Get("expr"))
       if err != nil {
         http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)
         return
       }
       w.Header().Set("Content-Type", "image/svg+xml")
       surface(w, func(x, y float64) float64 {
         r := math.Hypot(x, y) // distance from (0,0)
         return expr.Eval(eval.Env{"x": x, "y": y, "r": r})
       })
     }
   < src..

#    The @c(plot) function parses and checks the expression specified in the HTTP
#    request and uses it to create an anonymous function of two variables. The
#    anonymous function has the same signature as the fixed function @c(f) from
#    the original surface-plotting program, but it evaluates the user-supplied
#    expression. The environment defines @c(x), @c(y), and the radius
#    @c(r). Finally, @c(plot) calls @c(surface), which is just the @c(main)
#    function from @c(gopl.io/ch3/surface), modified to take the function to plot
#    and the output @c(io.Writer) as parameters, instead of using the fixed
#    function @c(f) and @c(os.Stdout). Figure 7.7 shows three surfaces produced by
#    the program.
   La funcion @c(plot) analiza y comprueba la expresion especificada en la
   peticion HTTP y la utiliza para crear una funcion anonima de dos
   variables. La funcion anonima tiene la misma firma que la funcion fija @c(f)
   del programa de trazado de la superficie original, pero evalua la expresion
   proporcionada por el usuario. El entorno define @c(x), @c(y), y el radio
   @c(r). Finalmente, @c(plot) llama a @c(surface), que es solo la funcion
   @c(main) de @c(gopl.io/ch3/surface), modificado para tomar la funcion de
   trazar y la salida de @c(io.Writer) como parametros, en lugar de utilizar la
   funcion fija @c(f) y @c(os.Stdout). La Figura 7.7 muestra tres superficies
   producidas por el programa.

#    ..figure > Figure 7.7. The surfaces of three functions: (a)
#      @c[sin(-x)*pow(1.5,-r)]; (b) @c[pow(2,sin(y))*pow(2,sin(x))/12]; (c)
#      @c[sin(x*y/10)/10].
   ..figure > Figura 7.7. Las superficies de tres funciones: (a)
     @c[sin(-x)*pow(1.5,-r)]; (b) @c[pow(2,sin(y))*pow(2,sin(x))/12]; (c)
     @c[sin(x*y/10)/10].

#      ..img  > img/Figure-7.7.a.jpg
     ..img  > img/Figure-7.7.a.jpg

#      ..img  > img/Figure-7.7.b.jpg
     ..img  > img/Figure-7.7.b.jpg

#      ..img  > img/Figure-7.7.c.jpg
     ..img  > img/Figure-7.7.c.jpg


#    @b(Exercise 7.13): Add a @c(String) method to @c(Expr) to pretty-print the
#    syntax tree. Check that the results, when parsed again, yield an equivalent
#    tree.
   @b(Ejercicio 7.13): Agregue una metodo @c(String) a @c(Expr) para imprimir el
   arbol de sintaxis. Compruebe que los resultados, cuando se analiza de nuevo,
   producen un arbol equivalente.

#    @b(Exercise 7.14): Define a new concrete type that satisfies the @c(Expr)
#    interface and provides a new operation such as computing the minimum value of
#    its operands. Since the @c(Parse) function does not create instances of this
#    new type, to use it you will need to construct a syntax tree directly (or
#    extend the parser).
   @b(Ejercicio 7.14): Definir un nuevo tipo concreto que satisfaga la interfaz
   @c(Expr) y ofrece una nueva operacion como calcular el valor minimo de sus
   operandos. Ya que la funcion @c(Parse) no crea instancias de este nuevo tipo,
   para usarlo necesitara construir un arbol de sintaxis directamente (o
   extender el analizador).

#    @b(Exercise 7.15): Write a program that reads a single expression from the
#    standard input, prompts the user to provide values for any variables, then
#    evaluates the expression in the resulting environment. Handle all errors
#    gracefully.
   @b(Ejercicio 7.15): Escriba un programa que lee una sola expresion de la
   entrada estandar, solicita al usuario que proporcione valores para las
   variables, y luego  evalue la expresion en el medio ambiente
   resultante. Maneje todos los errores con gracia.

#    @b(Exercise 7.16): Write a web-based calculator program.
   @b(Ejercicio 7.16): Escribia un programa de calculadora basado en la web.

# ** Section 7.10 <> Type Assertions
** Seccion 7.10 <> Afirmacion de Tipo

#    A @e(type assertion) is an operation applied to an interface
#    value. Syntactically, it looks like @c[x.(T)], where @c(x) is an expression
#    of an interface type and @c(T) is a type, called the @"(asserted) type. A
#    type assertion checks that the dynamic type of its operand matches the
#    asserted type.
   Una @e(afirmacion de tipo) es una operacion aplicada a un valor de interfaz.
   Sintacticamente, se ve como @c[x.(T)], donde @c(x) es una expresion de un
   tipo de interfaz y @c[T] es un tipo, denominado el tipo @"(afirmado). Una
   afirmacion de tipo comprueba que el tipo dinamico de su operando coincide con
   el tipo declarado.

#    There are two possibilities. First, if the asserted type @c(T) is a concrete
#    type, then the type assertion checks whether @c(x)’s dynamic type is
#    @e(identical to) @c(T). If this check succeeds, the result of the type
#    assertion is @c(x)’s dynamic value, whose type is of course @c(T). In other
#    words, a type assertion to a concrete type extracts the concrete value from
#    its operand. If the check fails, then the operation panics. For example:
   Hay dos posibilidades. En primer lugar, si el tipo afirmado @c(T) es un tipo
   concreto, entonces la asercion de tipo comprueba si el tipo dinamico @c(x) es
   @e(identico a) @c(T). Si esta comprobacion tiene exito, el resultado de la
   afirmacion tipo es el valor dinamico @c(x), cuyo tipo es, por supuesto,
   @c(T). En otras palabras, una afirmacion de tipo a un tipo concreto extrae el
   valor concreto de su operando. Si la comprobacion falla, entonces la
   operacion entra en panico. Por ejemplo:

#    ..src > go
#      var w io.Writer
#      w = os.Stdout
#      f := w.(*os.File)      // success: f == os.Stdout
#      c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
#    < src..
   ..src > go
     var w io.Writer
     w = os.Stdout
     f := w.(*os.File)      // exito: f == os.Stdout
     c := w.(*bytes.Buffer) // panico: interfaz contiene *os.File, no *bytes.Buffer
   < src..

#    Second, if instead the asserted type @c(T) is an interface type, then the
#    type assertion checks whether @c(x)’s dynamic type @e(satisfies) @c(T). If
#    this check succeeds, the dynamic value is not extracted; the result is still
#    an interface value with the same type and value components, but the result
#    has the interface type @c(T). In other words, a type assertion to an
#    interface type changes the type of the expression, making a different (and
#    usually larger) set of methods accessible, but it preserves the dynamic type
#    and value components inside the interface value.
   En segundo lugar, si en lugar del tipo afirmado @c(T) es un tipo de interfaz,
   entonces, la afirmacion de tipo comprueba si el tipo dinamico @c(x)
   @e(satisface) a @c(T). Si esta comprobacion tiene exito, el valor dinamico no
   se extrae; el resultado sigue siendo un valor de interfaz con el mismo y
   varol de componentes, pero el resultado tiene el tipo de interfaz @c(T). En
   otras palabras, una asercion de tipo a un tipo de interfaz cambia el tipo de
   la expresion, haciendo accesible un conjunto de metodos diferente (y
   generalmente mas grande), pero conserva los componentes dinamicos de tipo y
   valor dentro del valor de la interfaz.

#    After the first type assertion below, both @c(w) and @c(rw) hold
#    @c(os.Stdout) so each has a dynamic type of @c(*os.File), but @c(w), an
#    @c(io.Writer), exposes only the file’s @c(Write) method, whereas @c(rw)
#    exposes its @c(Read) method too.
   Despues de la afirmacion del primer tipo a continuacion, tanto @c(w) y @c(rw)
   contienen @c(os.Stdout) por lo que cada uno tiene un tipo dinamico de
   @c(*os.File), pero @c(w), un @c(io.Writer), expone solo el metodo @c(Write)
   del archivo, mientras que @c(rw) expone tambien su metodo @c(Read).

#    ..src > go
#      var w io.Writer
#      w = os.Stdout
#      rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
#
#      w = new(ByteCounter)
#      rw = w.(io.ReadWriter)  // panic: *ByteCounter has no Read method
#    < src..
   ..src > go
     var w io.Writer
     w = os.Stdout
     rw := w.(io.ReadWriter) // exito: *os.File tiene tanto Read como Write

     w = new(ByteCounter)
     rw = w.(io.ReadWriter)  // panico: *ByteCounter no tiene metodo Read
   < src..

#    No matter what type was asserted, if the operand is a nil interface value,
#    the type assertion fails. A type assertion to a less restrictive interface
#    type (one with fewer methods) is rarely needed, as it behaves just like an
#    assignment, except in the nil case.
   No importa que tipo se afirmo, si el operando es un valor de interfaz nil, la
   afirmacion de tipo falla. Rara vez se necesita una asercion de tipo a un tipo
   de interfaz menos restrictivo (uno con menos metodos), ya que se comporta
   como una asignacion, excepto en el caso nulo.

#    ..src > go
#      w = rw             // io.ReadWriter is assignable to io.Writer
#      w = rw.(io.Writer) // fails only if rw == nil
#    < src..
   ..src > go
     w = rw             // io.ReadWriter es asignable a io.Writer
     w = rw.(io.Writer) // falla solo si rw == nil
   < src..

#    Often we’re not sure of the dynamic type of an interface value, and we’d like
#    to test whether it is some particular type. If the type assertion appears in
#    an assignment in which two results are expected, such as the following
#    declarations, the operation does not panic on failure but instead returns an
#    additional second result, a boolean indicating success:
   A menudo no estamos seguros del tipo dinamico de un valor de interfaz, y nos
   gustaria probar si es algun tipo particular. Si la afirmacion de tipo aparece
   en una asignacion en la que se esperan dos resultados, como las siguientes
   declaraciones, la operacion no entra en panico cuando se produce un error,
   sino que devuelve un segundo resultado adicional, un booleano que indica
   exito:

#    ..src > go
#      var w io.Writer = os.Stdout
#      f, ok := w.(*os.File)      // success: ok, f == os.Stdout
#      b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil
#    < src..
   ..src > go
     var w io.Writer = os.Stdout
     f, ok := w.(*os.File)      // exito: ok, f == os.Stdout
     b, ok := w.(*bytes.Buffer) // fallo: !ok, b == nil
   < src..

#    The second result is conventionally assigned to a variable named @c(ok). If
#    the operation failed, @c(ok) is false, and the first result is equal to the
#    zero value of the asserted type, which in this example is a nil
#    @c(*bytes.Buffer).
   El segundo resultado es asignado convencionalmente a una variable llamada
   @c(ok). Si la operacion ha fallado, @c(ok) es falso, y el primer resultado es
   igual al valor cero del tipo afirmado, que en este ejemplo es nil
   @c(*bytes.Buffer).

#    The @c(ok) result is often immediately used to decide what to do next. The
#    extended form of the if statement makes this quite compact:
   El resultado @c(ok) a menudo se utiliza de inmediato para decidir que hacer a
   continuacion. La forma extendida de la sentencia @c(if) hace esto muy compacto:

#    ..src > go
#      if f, ok := w.(*os.File); ok {
#        // ...use f...
#      }
#    < src..
   ..src > go
     if f, ok := w.(*os.File); ok {
       // ...use f...
     }
   < src..

#    When the operand of a type assertion is a variable, rather than invent
#    another name for the new local variable, you’ll sometimes see the original
#    name reused, shadowing the original, like this:
   Cuando el operando de una afirmacion de tipo es una variable, en lugar de
   inventar otro nombre para la nueva variable local, a veces vera el nombre
   original reutilizado, ocultando el original, asi:

#    ..src > go
#      if w, ok := w.(*os.File); ok {
#        // ...use w...
#      }
#    < src..
   ..src > go
     if w, ok := w.(*os.File); ok {
       // ...utilizar w...
     }
   < src..

# ** Section 7.11 <> Discriminating Errors with Type Assertions
** Seccion 7.11 <> Discriminacion de Errores con Afirmaciones de Tipo

#    Consider the set of errors returned by file operations in the @c(os)
#    package. I/O can fail for any number of reasons, but three kinds of failure
#    often must be handled differently: file already exists (for create
#    operations), file not found (for read operations), and permission denied. The
#    @c(os) package provides these three helper functions to classify the failure
#    indicated by a given @c(error) value:
   Consideremos el conjunto de errores devueltos por las operaciones de archivos
   en el paquete @c(os). Las E/S pueden fallar por varias razones, pero tres
   tipos de fallos a menudo deben manejarse de manera diferente: el archivo ya
   existe (para las operaciones de creacion), el archivo no se encuentra (para
   operaciones de lectura) y el permiso esta denegado. El paquete @c(os)
   proporciona estas tres funciones de ayuda para clasificar el fallo indicado
   por un determinado valor @c(error):

#    ..src > go
#      package os
#
#      func IsExist(err error) bool
#      func IsNotExist(err error) bool
#      func IsPermission(err error) bool
#    < src..
   ..src > go
     package os

     func IsExist(err error) bool
     func IsNotExist(err error) bool
     func IsPermission(err error) bool
   < src..

#    A naïve implementation of one of these predicates might check that the error
#    message contains a certain substring,
   Una implementacion naïve de uno de estos predicados podria comprobar que el
   mensaje de error contenga una cierta subcadena,

#    ..src > go
#      func IsNotExist(err error) bool {
#        // NOTE: not robust!
#        return strings.Contains(err.Error(), "file does not exist")
#      }
#    < src..
   ..src > go
     func IsNotExist(err error) bool {
       // NOTA: no es robusto!
       return strings.Contains(err.Error(), "file does not exist")
     }
   < src..

#    but because the logic for handling I/O errors can vary from one platform to
#    another, this approach is not robust and the same failure may be reported
#    with a variety of different error messages. Checking for substrings of error
#    messages may be useful during testing to ensure that functions fail in the
#    expected manner, but it’s inadequate for production code.
   Pero debido a que la logica para manejar los errores de E/S puede variar de
   una plataforma a otra, este enfoque no es robusto y el mismo fallo puede ser
   reportado con una variedad de diferentes mensajes de error. La comprobacion
   de subcadenas de mensajes de error puede ser util durante la prueba para
   asegurarse de que las funciones fallan de la manera esperada, pero es
   inadecuado para el codigo en produccion.

#    A more reliable approach is to represent structured error values using a
#    dedicated type. The os package defines a type called @c(PathError) to
#    describe failures involving an operation on a file path, like @c(Open) or
#    @c(Delete), and a variant called @c(LinkError) to describe failures of
#    operations involving two file paths, like @c(Symlink) and @c(Rename). Here’s
#    @c(os.PathError):
   Un enfoque mas confiable es representar valores de error estructurados
   utilizando un tipo especifico. El paquete OS define un tipo llamado
   @c(PathError) para describir las fallas que implican una operacion en una
   ruta de archivo, como @c(Open) o @c(Delete), y una variante llamada
   @c(LinkError) para describir los frallos de las operaciones que implican dos
   rutas de archivos, como @c(Symlink) y @c(Rename). Aqui esta @c(os.PathError):

#    ..src > go
#      package os
#
#      // PathError records an error and the operation and file path that caused it.
#      type PathError struct {
#        Op   string
#        Path string
#        Err  error
#      }
#
#      func (e *PathError) Error() string {
#        return e.Op + " " + e.Path + ": " + e.Err.Error()
#      }
#    < src..
   ..src > go
     package os

     // PathError registra un error y la operacion y ruta de archivo que lo causo.
     type PathError struct {
       Op   string
       Path string
       Err  error
     }

     func (e *PathError) Error() string {
       return e.Op + " " + e.Path + ": " + e.Err.Error()
     }
   < src..

#    Most clients are oblivious to @c(PathError) and deal with all errors in a
#    uniform way by calling their @c(Error) methods. Although @c(PathError)’s
#    @c(Error) method forms a message by simply concatenating the fields,
#    @c(PathError)’s structure preserves the underlying components of the error.
#    Clients that need to distinguish one kind of failure from another can use a
#    type assertion to detect the specific type of the error; the specific type
#    provides more detail than a simple string.
   La mayoria de los clientes no son conscientes de @c(PathError) y el manejo
   con todos los errores de una manera uniforme llamando a sus metodos de
   @c(Error). Aunque el metodo @c(Error) de @c(PathError) forma un mensaje
   simplemente concatenando los campos, la estructura de @c(PathError) conserva
   los componentes subyacentes del error. Los clientes que necesitan distinguir
   un tipo de fallo de otro pueden usar una afirmacion de tipo para detectar el
   tipo especifico del error; el tipo especifico proporciona mas detalle que una
   simple cadena.

#    ..src > go
#      _, err := os.Open("/no/such/file")
#      fmt.Println(err) // "open /no/such/file: No such file or directory"
#      fmt.Printf("%#v\n", err)
#      // Output:
#      // &os.PathError{Op:"open", Path:"/no/such/file", Err:0x2}
#    < src..
   ..src > go
     _, err := os.Open("/no/such/file")
     fmt.Println(err) // "open /no/such/file: No such file or directory"
     fmt.Printf("%#v\n", err)
     // Salida:
     // &os.PathError{Op:"open", Path:"/no/such/file", Err:0x2}
   < src..

#    That’s how the three helper functions work. For example, @c(IsNotExist),
#    shown below, reports whether an error is equal to @c(syscall.ENOENT)
#    (@l(#Section 7.8<>§7.8)) or to the distinguished error @c(os.ErrNotExist)
#    (see @c(io.EOF) in @l(#Section 5.4.2<>§5.4.2)), or is a @c(*PathError) whose
#    underlying error is one of those two.
   Asi funcionan las tres funciones auxiliares. Por ejemplo, @c(IsNotExist), que
   se muestra a continuacion, informa si un error es igual a @c(syscall.ENOENT)
   (@l(#Seccion 7.8<>§7.8)) o al error distinguido @c(os.ErrNotExist) (vea
   @c(io.EOF) en la @l(#Seccion 5.4.2<>§5.4.2)), o es un @c(*PathError) cuyo
   error subyacente es uno de esos dos.

#    ..src > go
#      import (
#        "errors"
#        "syscall"
#      )
#
#      var ErrNotExist = errors.New("file does not exist")
#
#      // IsNotExist returns a boolean indicating whether the error is known to
#      // report that a file or directory does not exist. It is satisfied by
#      // ErrNotExist as well as some syscall errors.
#      func IsNotExist(err error) bool {
#        if pe, ok := err.(*PathError); ok {
#          err = pe.Err
#        }
#        return err == syscall.ENOENT || err == ErrNotExist
#      }
#    < src..
   ..src > go
     import (
       "errors"
       "syscall"
     )

     var ErrNotExist = errors.New("file does not exist")

     // IsNotExist regresa un booleano que indica si se conoce el error
     // informa que no existe un archivo o directorio. Se satisface por
     // ErrNotExist asi como algunos errores syscall.
     func IsNotExist(err error) bool {
       if pe, ok := err.(*PathError); ok {
         err = pe.Err
       }
       return err == syscall.ENOENT || err == ErrNotExist
     }
   < src..

#    And here it is in action:
   Y aqui esta en accion:

#    ..src > go
#      _, err := os.Open("/no/such/file")
#      fmt.Println(os.IsNotExist(err)) // "true"
#    < src..
   ..src > go
     _, err := os.Open("/no/such/file")
     fmt.Println(os.IsNotExist(err)) // "true"
   < src..

#    Of course, @c(PathError)’s structure is lost if the error message is combined
#    into a larger string, for instance by a call to @c(fmt.Errorf). Error
#    discrimination must usually be done immediately after the failing operation,
#    before an error is propagated to the caller.
   Por supuesto, la estructura @c(PathError) se pierde pierde si el mensaje de
   error se combina en una cadena mas grande, por ejemplo, mediante una llamada
   a @c(fmt.Errorf). La discriminacion de errores se debe hacer generalmente
   inmediatamente despues de la operacion fallida, antes de que un error se
   propague al llamador.

# ** Section 7.12 <> Querying Behaviors with Interface Type Assertions
** Seccion 7.12 <> Consultar Comportamientos con Afirmaciones de Tipo de Interfaz

#    The logic below is similar to the part of the @c(net/http) web server
#    responsible for writing HTTP header fields such as @c("Content-type:
#    text/html"). The @c(io.Writer) @c(w) represents the HTTP response; the
#    bytes written to it are ultimately sent to someone’s web browser.
   La siguiente logica es similar a la parte del servidor web @c(net/http)
   responsable de escribir campos de cabecera HTTP como @c("Content-type:
   text/html"). El @c(io.Writer) @c(w) representa la respuesta HTTP; Los bytes
   escritos en el, se envian en ultima instancia a algun navegador web.

#    ..src > go
#      func writeHeader(w io.Writer, contentType string) error {
#        if _, err := w.Write([]byte("Content-Type: ")); err != nil {
#          return err
#        }
#        if _, err := w.Write([]byte(contentType)); err != nil {
#          return err
#        }
#        // ...
#      }
#    < src..
   ..src > go
     func writeHeader(w io.Writer, contentType string) error {
       if _, err := w.Write([]byte("Content-Type: ")); err != nil {
         return err
       }
       if _, err := w.Write([]byte(contentType)); err != nil {
         return err
       }
       // ...
     }
   < src..

#    Because the @c(Write) method requires a byte slice, and the value we wish to
#    write is a string, a @c{[]byte(...)} conversion is required. This conversion
#    allocates memor y and makes a copy, but the copy is thrown away almost
#    immediately after. Let’s pretend that this is a core part of the web server
#    and that our profiling has revealed that this memory allocation is slowing it
#    down. Can we avoid allocating memory here?
   Debido a que el metodo @c(Write) requiere una slice de bytes, y el valor que
   desea escribir es una cadena, se requiere una conversion @c{[]byte(...)}.
   Esta conversion asigna memoria y hace una copia, pero la copia se tira casi
   inmediatamente despues. Vamos a pretender que esta es una parte fundamental
   del servidor web y que nuestro perfil ha revelado que esta asignacion de
   memoria se esta ralentizando. ¿Podemos evitar asignar memoria aqui?

#    The @c(io.Writer) interface tells us only one fact about the concrete type
#    that @c(w) holds: that bytes may be written to it. If we look behind the
#    curtains of the @c(net/http) package, we see that the dynamic type that @c(w)
#    holds in this program also has a @c(WriteString) method that allows strings
#    to be efficiently written to it, avoiding the need to allocate a temporary
#    copy. (This may seem like a shot in the dark, but a number of important types
#    that satisfy @c(io.Writer) also have a @c(WriteString) method, including
#    @c(*bytes.Buffer), @c(*os.File) and @c(*bufio.Writer).)
   La interfaz @c(io.Writer) nos informa solo un hecho sobre el tipo concreto
   que @c(w) almacena: que los bytes se pueden escribir en el. Si miramos detras
   de cortinas del paquete @c(net/http), vemos que el tipo dinamico que @c(w)
   tiene en este programa tambien tiene un metodo @c(WriteString) que permite
   que las cadenas sean escritas eficientemente, evitando la necesidad de
   asignar una copia temporal. (Esto puede parecer un disparo en la oscuridad,
   pero una serie de tipos importantes que satisfacen @c(io.Writer) tambien
   tienen un metodo @c(WriteString), incluyendo @c(*bytes.Buffer), @c(*os.File)
   y @c(*bufio.Writer)).

#    We cannot assume that an arbitrary @c(io.Writer) @c(w) also has the
#    @c(WriteString) method. But we can define a new interface that has just this
#    method and use a type assertion to test whether the dynamic type of @c(w)
#    satisfies this new interface.
   No podemos asumir que un @c(w) @c(io.Writer) arbitrario tambien tiene el
   metodo @c(WriteString). Pero podemos definir una nueva interfaz que tiene
   solo este metodo y utilizar una afirmacion de tipo para probar si el tipo
   dinamico de @c(w) satisface esta nueva interfaz.

#    ..src > go
#      // writeString writes s to w.
#      // If w has a WriteString method, it is invoked instead of w.Write.
#      func writeString(w io.Writer, s string) (n int, err error) {
#        type stringWriter interface {
#          WriteString(string) (n int, err error)
#        }
#        if sw, ok := w.(stringWriter); ok {
#          return sw.WriteString(s) // avoid a copy
#        }
#        return w.Write([]byte(s)) // allocate temporary copy
#      }
#
#      func writeHeader(w io.Writer, contentType string) error {
#        if _, err := writeString(w, "Content-Type: "); err != nil {
#          return err
#        }
#        if _, err := writeString(w, contentType); err != nil {
#          return err
#        }
#        // ...
#      }
#    < src..
   ..src > go
     // writeString escribe s a w.
     // Si w tiene un metodo WriteString, se invoca en lugar de w.Write.
     func writeString(w io.Writer, s string) (n int, err error) {
       type stringWriter interface {
         WriteString(string) (n int, err error)
       }
       if sw, ok := w.(stringWriter); ok {
         return sw.WriteString(s) // evitar copia
       }
       return w.Write([]byte(s)) // almacena una copia temporal
     }

     func writeHeader(w io.Writer, contentType string) error {
       if _, err := writeString(w, "Content-Type: "); err != nil {
         return err
       }
       if _, err := writeString(w, contentType); err != nil {
         return err
       }
       // ...
     }
   < src..

#    To avoid repeating ourselves, we’ve moved the check into the utility function
#    @c(writeString), but it is so useful that the standard library provides it as
#    @c(io.WriteString). It is the recommended way to write a string to an
#    @c(io.Writer).
   Para evitar repetirnos a nosotros mismos, hemos movido la comprobacion a la
   funcion de utilidad @c(writeString), pero es tan util que la libreria
   estandar la proporciona como @c(io.WriteString). Es la forma recomendada de
   escribir una cadena a un @c(io.Writer).

#    What’s curious in this example is that there is no standard interface that
#    defines the @c(WriteString) method and specifies its required
#    behavior. Furthermore, whether or not a concrete type satisfies the
#    @c(stringWriter) interface is determined only by its methods, not by any
#    declared relationship between it and the interface type. What this means is
#    that the technique above relies on the assumption that @e(if) a type
#    satisfies the interface below, @e(then) @c[WriteString(s)] must have the same
#    effect as @c{Write([]byte(s))}.
   Lo curioso en este ejemplo es que no existe una interfaz estandar que defina
   el metodo @c(WriteString) y especifique su comportamiento requerido. Ademas,
   si un tipo concreto satisface o no la interfaz @c(stringWriter) se determina
   solo por sus metodos, y no por ninguna relacion declarada entre el y el tipo
   de interfaz. Lo que esto significa es que la tecnica anterior se basa en la
   suposicion de que @e(si) un tipo satisface la interfaz de abajo, @e(entonces)
   @c[WriteString(s)] debe tener el mismo efecto que @c{Write([]byte(s))}.

#    ..src > go
#      interface {
#        io.Writer
#        WriteString(s string) (n int, err error)
#      }
#    < src..
   ..src > go
     interface {
       io.Writer
       WriteString(s string) (n int, err error)
     }
   < src..

#    Although @c(io.WriteString) documents its assumption, few functions that call
#    it are likely to document that they too make the same assumption. Defining a
#    method of a particular type is taken as an implicit assent for a certain
#    behavioral contract. Newcomers to Go, especially those from a background in
#    strongly typed languages, may find this lack of explicit intention
#    unsettling, but it is rarely a problem in practice. With the exception of the
#    empty interface @c(interface{}), interface types are seldom satisfied by
#    unintended coincidence.
   Aunque @c(io.WriteString) documenta su suposicion, pocas funciones que la
   llaman probablemente documenten que estas tambien hacen el mismo
   supuesto. Definir un metodo de un tipo particular se toma como un
   asentimiento implicito para un determinado contrato de comportamiento. Los
   recien llegados a Go, especialmente aquellos de un fondo en lenguajes
   fuertemente tipados, pueden encontrar esta falta de intencion explicita
   inquietante, pero rara vez es un problema en la practica. Con la excepcion de
   la interfaz vacia @c(interface{}), los tipos de interfaz rara vez son
   satisfechas por coincidencia involuntaria.

#    The @c(writeString) function above uses a type assertion to see whether a
#    value of a general interface type also satisfies a more specific interface
#    type, and if so, it uses the behaviors of the specific interface. This
#    technique can be put to good use whether or not the queried interface is
#    standard like @c(io.ReadWriter) or user-defined like @c(stringWriter).
   La anterior funcion @c(writeString) utiliza una afirmacion de tipo para ver
   si un valor de un tipo de interfaz general tambien satisface un tipo de
   interfaz mas especifico, y de ser asi, se utiliza el comportamiento de la
   interfaz especifica. Esta tecnica se puede poner en uso, sea o no la interfaz
   a consultar estandar como @c(io.ReadWriter) o definida por el usuario como
   @c(stringWriter).

#    It’s also how @c(fmt.Fprintf) distinguishes values that satisfy @c(error) or
#    @c(fmt.Stringer) from all other values. Within @c(fmt.Fprintf), there is a
#    step that converts a single operand to a string, something like this:
   Tambien es como @c(fmt.Fprintf) distingue valores que satisfacen @c(error) o
   @c(fmt.Stringer) de todos los demas valores. Dentro de @c(fmt.Fprintf), hay
   un paso que convierte un unico operando en una cadena, algo asi:

#    ..src > go
#      package fmt
#
#      func formatOneValue(x interface{}) string {
#        if err, ok := x.(error); ok {
#          return err.Error()
#        }
#        if str, ok := x.(Stringer); ok {
#          return str.String()
#        }
#        // ...all other types...
#      }
#    < src..
   ..src > go
     package fmt

     func formatOneValue(x interface{}) string {
       if err, ok := x.(error); ok {
         return err.Error()
       }
       if str, ok := x.(Stringer); ok {
         return str.String()
       }
       // ...all other types...
     }
   < src..

#    If @c(x) satisfies either of the two interfaces, that determines the
#    formatting of the value. If not, the default case handles all other types
#    more or less uniformly using reflection; we’ll find out how in @l(#Chapter
#    12).
   Si @c(x) satisface cualquiera de las dos interfaces, eso determina el formato
   del valor. Si no, el caso por defecto maneja todos los demas tipos mas o
   menos uniformemente usando la reflexion; vamos a averiguar como en el
   @l(#Capitulo 12).

#    Again, this makes the assumption that any type with a @c(String) method
#    satisfies the behavioral contract of @c(fmt.Stringer), which is to return a
#    string suitable for printing.
   De nuevo, esto hace la suposicion de que cualquier tipo con un metodo
   @c(String) satisface el contrato de comportamiento de @c(fmt.Stringer), que
   es devolver una cadena adecuada para la impresion.

# ** Section 7.13 <> Type Switches
** Seccion 7.13 <> Switches de Tipo

#    Interfaces are used in two distinct styles. In the first style, exemplified
#    by @c(io.Reader), @c(io.Writer), @c(fmt.Stringer), @c(sort.Interface),
#    @c(http.Handler), and @c(error), an interface’s methods express the
#    similarities of the concrete types that satisfy the interface but hide the
#    representation details and intrinsic operations of those concrete types. The
#    emphasis is on the methods, not on the concrete types.
   Las interfaces se utilizan en dos estilos distintos. En el primer estilo,
   ejemplificado por @c(io.Reader), @c(io.Writer), @c(fmt.Stringer),
   @c(sort.Interface), @c(http.Handler) y @c(error), los metodos de una interfaz
   expresan las similitudes de los tipos concretos que satisfacen la interfaz,
   pero ocultan los detalles de representacion y operaciones intrinsecas de esos
   tipos concretos. El enfasis esta en los metodos, no en los tipos concretos.

#    The second style exploits the ability of an interface value to hold values of
#    a variety of concrete types and considers the interface to be the @e(union)
#    of those types. Type assertions are used to discriminate among these types
#    dynamically and treat each case differently. In this style, the emphasis is
#    on the concrete types that satisfy the interface, not on the interface’s
#    methods (if indeed it has any), and there is no hiding of information. We’ll
#    describe interfaces used this way as @e(discriminated unions).
   El segundo estilo explota la capacidad de un valor interfaz para contener
   valores de una variedad de tipos concretos y considera que la interfaz es la
   @e(union) de esos tipos. Las afirmaciones de tipo se utilizan para
   discriminar entre estos tipos dinamicamente y tratar cada caso de manera
   diferente. En este estilo, el enfasis esta en los tipos concretos que
   satisfacen la interfaz, no en los metodos de la interfaz (si de hecho tiene
   alguno), y no se oculta la informacion. Vamos a describir interfaces
   utilizadas de esta manera como los @e(uniones discriminadas).

#    If you’re familiar with object-oriented programming, you may recognize these
#    two styles as @e(subtype polymorphism) and @e(ad hoc polymorphism), but you
#    needn’t remember those terms. For the remainder of this chapter, we’ll
#    present examples of the second style.
   Si esta familiarizado con la programacion orientada a objetos, es posible
   reconocer estos dos estilos como @e(polimorfismo de subtipos) y el
   @e(polimorfismo ad hoc), pero no necesita recordar esos terminos. Para el
   resto de este capitulo, presentaremos ejemplos del segundo estilo.

#    Go’s API for querying an SQL database, like those of other languages, lets us
#    cleanly separate the fixed part of a query from the variable parts. An
#    example client might look like this:
   La API de Go para consultar una base de datos SQL, como las de otros
   lenguajes, nos permite separar de forma clara la parte fija de una consulta
   de las partes variables. Un ejemplo de cliente podria tener este aspecto:

#    ..src > go
#      import "database/sql"
#
#      func listTracks(db sql.DB, artist string, minYear, maxYear int) {
#        result, err := db.Exec(
#          "SELECT * FROM tracks WHERE artist = ? AND ? <= year AND year <= ?",
#          artist, minYear, maxYear)
#        // ...
#      }
#    < src..
   ..src > go
     import "database/sql"

     func listTracks(db sql.DB, artist string, minYear, maxYear int) {
       result, err := db.Exec(
         "SELECT * FROM tracks WHERE artist = ? AND ? <= year AND year <= ?",
         artist, minYear, maxYear)
       // ...
     }
   < src..

#    The @c(Exec) method replaces each @c('?') in the query string with an SQL
#    literal denoting the corresponding argument value, which may be a boolean, a
#    number, a string, or @c(nil). Constructing queries this way helps avoid SQL
#    injection attacks, in which an adversary takes control of the query by
#    exploiting improper quotation of input data. Within @c(Exec), we might find a
#    function like the one below, which converts each argument value to its
#    literal SQL notation.
   El metodo @c(Exec) reemplaza cada @c('?') en la cadena de consulta con un
   literal SQL que denota el valor del argumento correspondiente, que puede ser
   un valor booleano, un numero, una cadena, o @c(nil). La construccion de
   consultas de esta manera ayuda a evitar ataques de inyeccion SQL, en el que
   un adversario toma el control de la consulta mediante la explotacion de una
   cita incorrecta de datos de entrada. Dentro de @c(Exec), podriamos encontrar
   una funcion como la siguiente, que convierte cada valor de argumento para su
   notacion SQL.

#    ..src > go
#      func sqlQuote(x interface{}) string {
#        if x == nil {
#          return "NULL"
#        } else if _, ok := x.(int); ok {
#          return fmt.Sprintf("%d", x)
#        } else if _, ok := x.(uint); ok {
#          return fmt.Sprintf("%d", x)
#        } else if b, ok := x.(bool); ok {
#          if b {
#            return "TRUE"
#          }
#          return "FALSE"
#        } else if s, ok := x.(string); ok {
#          return sqlQuoteString(s) // (not shown)
#        } else {
#          panic(fmt.Sprintf("unexpected type %T: %v", x, x))
#        }
#      }
#    < src..
   ..src > go
     func sqlQuote(x interface{}) string {
       if x == nil {
         return "NULL"
       } else if _, ok := x.(int); ok {
         return fmt.Sprintf("%d", x)
       } else if _, ok := x.(uint); ok {
         return fmt.Sprintf("%d", x)
       } else if b, ok := x.(bool); ok {
         if b {
           return "TRUE"
         }
         return "FALSE"
       } else if s, ok := x.(string); ok {
         return sqlQuoteString(s) // (no se muestra)
       } else {
         panic(fmt.Sprintf("unexpected type %T: %v", x, x))
       }
     }
   < src..

#    A @c(switch) statement simplifies an @c(if)-@c(else) chain that performs a
#    series of value equality tests.  An analogous @e(type switch) statement
#    simplifies an @c(if)-@c(else) chain of type assertions.
   Una sentencia @c(switch) simplifica una cadena @c(if)-@c(else) que realiza
   una serie de pruebas de igualdad de valor. De forma analoga una sentencia
   @c(switch de tipos) simplifica una cadena @c(if)-@c(else) de afirmaciones de
   tipo.

#    In its simplest form, a type switch looks like an ordinary switch statement
#    in which the operand is @c[x.(type)]—that’s literally the keyword
#    @c(type)—and each case has one or more types. A type switch enables a
#    multi-way branch based on the interface value’s dynamic type. The @c(nil)
#    case matches if @c(x == nil), and the @c(default) case matches if no other
#    case does. A type switch for @c(sqlQuote) would have these cases:
   En su forma mas simple, un switch de tipos se parece a una sentencia switch
   ordinaria en la que el operando es @c[x.(type)]–esto es, literalmente, la
   palabra clave @c(type)–y cada caso tiene uno o mas tipos. Un conmutador de
   tipo habilita una ramificacion multidireccional basada en el tipo dinamico
   del valor de la interfaz. El caso @c(nil) coincide si @c(x == nil), y el caso
   @c(default) coincide si lo hace ningun otro caso. Un switch de tipos para
   @c(sqlQuote) tendria estos casos:

#    ..src > go
#      switch x.(type) {
#      case nil:       // ...
#      case int, uint: // ...
#      case bool:      // ...
#      case string:    // ...
#      default:        // ...
#      }
#    < src..
   ..src > go
     switch x.(type) {
     case nil:       // ...
     case int, uint: // ...
     case bool:      // ...
     case string:    // ...
     default:        // ...
     }
   < src..

#    As with an ordinary switch statement (@l(#Section 1.8<>§1.8)), cases are
#    considered in order and, when a match is found, the case’s body is
#    executed. Case order becomes significant when one or more case types are
#    interfaces, since then there is a possibility of two cases matching. The
#    position of the @c(default) case relative to the others is immaterial. No
#    @c(fallthrough) is allowed.
   Al igual que con una sentencia @c(switch) ordinaria (@l(#Seccion 1.8<>§1.8)),
   los casos se consideran en orden y, cuando se encuentra una coincidencia, se
   ejecuta el cuerpo del caso. El orden de los casos se vuelve significativo
   cuando uno o mas tipos de casos son interfaces, ya que entonces existe la
   posibilidad de que dos casos coincidan. La posicion del caso @c(default) en
   relacion con los demas es irrelevante. no esta permitido @c(fallthrough).

#    Notice that in the original function, the logic for the @c(bool) and
#    @c(string) cases needs access to the value extracted by the type
#    assertion. Since this is typical, the type switch statement has an extended
#    form that binds the extracted value to a new variable within each case:
   Observe que en la funcion original, la logica de los casos @c(bool) y
   @c(string) necesita acceso al valor extraido por la afirmacion tipo. Dado que
   esto es tipico, la instruccion switch de tipo tiene una forma extendida que
   enlaza el valor extraido con una nueva variable dentro de cada caso:

#    ..src > go
#      switch x := x.(type) { /* ... */ }
#    < src..
   ..src > go
     switch x := x.(type) { /* ... */ }
   < src..

#    Here we’ve called the new variables @c(x) too; as with type assertions, reuse
#    of variable names is common. Like a @c(switch) statement, a type switch
#    implicitly creates a lexical block, so the declaration of the new variable
#    called @c(x) does not conflict with a variable @c(x) in an outer block. Each
#    @c(case) also implicitly creates a separate lexical block.
   Aqui hemos llamado las nuevas variables @c(x) tambien; Como con las
   aserciones de tipo, la reutilizacion de nombres de variables es comun. Al
   igual que una instruccion @c(switch), un switch de tipo crea implicitamente
   un bloque lexico, por lo que la declaracion de la nueva variable llamada
   @c(x) no entra en conflicto con una variable @c(x) en un bloque externo. Cada
   @c(case) tambien crea implicitamente un bloque lexico independiente.

#    Rewriting @c(sqlQuote) to use the extended form of type switch makes it
#    significantly clearer:
   Reescribiendo @c(sqlQuote) para utilizar la forma extendida de un switch de
   tipo lo hace significativamente mas claro:

#    ..src > go
#      func sqlQuote(x interface{}) string {
#        switch x := x.(type) {
#        case nil:
#          return "NULL"
#        case int, uint:
#          return fmt.Sprintf("%d", x) // x has type interface{} here.
#        case bool:
#          if x {
#            return "TRUE"
#          }
#          return "FALSE"
#        case string:
#          return sqlQuoteString(x) // (not shown)
#        default:
#          panic(fmt.Sprintf("unexpected type %T: %v", x, x))
#        }
#      }
#    < src..
   ..src > go
     func sqlQuote(x interface{}) string {
       switch x := x.(type) {
       case nil:
         return "NULL"
       case int, uint:
         return fmt.Sprintf("%d", x) // aqui x tiene tipo interface{}.
       case bool:
         if x {
           return "TRUE"
         }
         return "FALSE"
       case string:
         return sqlQuoteString(x) // (no se muestra)
       default:
         panic(fmt.Sprintf("unexpected type %T: %v", x, x))
       }
     }
   < src..

#    In this version, within the block of each single-type case, the variable
#    @c(x) has the same type as the case. For instance, @c(x) has type @c(bool)
#    within the @c(bool) case and @c(string) within the @c(string) case. In all
#    other cases, @c(x) has the (interface) type of the @c(switch) operand, which
#    is @c(interface{}) in this example. When the same action is required for
#    multiple cases, like @c(int) and @c(uint), the type switch makes it easy to
#    combine them.
   En esta version, dentro del bloque de cada caso de tipo unico, la variable
   @c(x) tiene el mismo tipo que el caso. Por ejemplo, @c(x) tiene tipo @c(bool)
   dentro del caso @c(bool) y @c(string) dentro del caso @c(string). En todos
   los demas casos, @c(x) tiene el tipo (interfaz) del @c(switch) operante, que
   es @c(interface{}) en este ejemplo. Cuando se requiere la misma accion para
   varios casos, como @c(int) y @c(uint), el switch de tipo hace que sea facil
   combinarlos.

#    Although @c(sqlQuote) accepts an argument of any type, the function runs to
#    completion only if the argument’s type matches one of the cases in the type
#    switch; otherwise it panics with an @"(unexpected type) message. Although the
#    type of @c(x) is @c(interface{}), we consider it a @e(discriminated union) of
#    @c(int), @c(uint), @c(bool), @c(string), and @c(nil).
   Aunque @c(sqlQuote) acepta un argumento de cualquier tipo, la funcion solo se
   ejecuta si el tipo del argumento coincide con uno de los casos en el switch
   de tipo; de lo contrario, entra en panico con un mensaje de @"(tipo
   inesperado). Aunque el tipo de @c(x) es @c(interface{}), lo consideramos una
   union discriminada de @c(int), @c(uint), @c(bool), @c(string), y @c(nil).

# ** Section 7.14 <> Example: Token-Based XML Decoding
** Seccion 7.14 <> Ejemplo: Decodificacion XML Basada en Token

#    @l(#Section 4.5) showed how to decode JSON documents into Go data structures
#    with the @c(Marshal) and @c(Unmarshal) functions from the @c(encoding/json)
#    package. The @c(encoding/xml) package provides a similar API. This approach
#    is convenient when we want to construct a representation of the document
#    tree, but that’s unnecessary for many programs. The @c(encoding/xml) package
#    also provides a lower-level @e(token-based) API for decoding XML. In the
#    token-based style, the parser consumes the input and produces a stream of
#    tokens, primarily of four kinds—@c(StartElement), @c(EndElement),
#    @c(CharData), and @c(Comment)—each being a concrete type in the
#    @c(encoding/xml) package. Each call to @c[(*xml.Decoder).Token] returns a
#    token.
   La @l(#Seccion 4.5) mostro como decodificar documentos JSON en estructuras de
   datos Go con las funciones @c(Marshal) y @c(Unmarshal) del paquete
   @c(encoding/json). El paquete @c(encoding/xml) proporciona una API similar.
   Este enfoque es conveniente cuando queremos construir una representacion del
   arbol de documentos, pero eso es innecesario para muchos programas. El
   paquete @c(encoding/xml) tambien proporciona una API de bajo nivel @e(basada
   en tokens) para decodificar XML. En el estilo basada en tokens, el analizador
   consume la entrada y produce un flujo de tokens, principalmente de cuatro
   tipos–@c(StartElement), @c(EndElement), @c(CharData), y @c(Comment)–cada uno
   de los cuales es un tipo concreto en el paquete @c(encoding/xml). Cada
   llamada a @c[(*xml.Decoder).Token] devuelve un token.

#    The relevant parts of the API are shown here:
   Las partes relevantes de la API se muestran aqui:

#    ..figure > @c(encoding/xml)
   ..figure > @c(encoding/xml)

#      ..src > go
#        package xml
#
#        type Name struct {
#          Local string // e.g., "Title" or "id"
#        }
#
#        type Attr struct { // e.g., name="value"
#          Name Name
#          Value string
#        }
#
#        // A Token includes StartElement, EndElement, CharData,
#        // and Comment, plus a few esoteric types (not shown).
#        type Token interface{}
#        type StartElement struct { // e.g., <name>
#          Name Name
#          Attr []Attr
#        }
#        type EndElement struct { Name Name } // e.g., </name>
#        type CharData []byte                 // e.g., <p>CharData</p>
#        type Comment []byte                  // e.g., <!-- Comment -->
#
#        type Decoder struct{ /* ... */ }
#
#        func NewDecoder(io.Reader) *Decoder
#        func (*Decoder) Token() (Token, error) // returns next Token in sequence
#      < src..
     ..src > go
       package xml

       type Name struct {
         Local string     // por ejemplo, "Title" o "id"
       }

       type Attr struct { // por ejemplo, name="value"
         Name Name
         Value string
       }

       // Un Token incluye StartElement, EndElement, CharData,
       // y Comment, mas algunos tipos esotericos (no mostrados).
       type Token interface{}
       type StartElement struct { // por ejemplo, <name>
         Name Name
         Attr []Attr
       }
       type EndElement struct { Name Name } // por ejemplo, </name>
       type CharData []byte                 // por ejemplo, <p>CharData</p>
       type Comment []byte                  // por ejemplo, <!-- Comment -->

       type Decoder struct{ /* ... */ }

       func NewDecoder(io.Reader) *Decoder
       func (*Decoder) Token() (Token, error) // regresa el sigiente token en la sequencia
     < src..

#    The @c(Token) interface, which has no methods, is also an example of a
#    discriminated union. The purpose of a traditional interface like
#    @c(io.Reader) is to hide details of the concrete types that satisfy it so
#    that new implementations can be created; each concrete type is treated
#    uniformly.  By contrast, the set of concrete types that satisfy a
#    discriminated union is fixed by the design and exposed, not
#    hidden. Discriminated union types have few methods; functions that operate on
#    them are expressed as a set of cases using a type switch, with different
#    logic in each case.
   La interfaz @c(Token), que no tiene metodos, es tambien un ejemplo de una
   union discriminada. El proposito de una interfaz tradicional como
   @c(io.Reader) es ocultar los detalles de los tipos concretos que lo
   satisfagan para que se puedan crear las nuevas implementaciones; cada tipo
   concreto es tratado uniformemente. Por el contrario, el conjunto de tipos
   concretos que satisfacen una union discriminada es fijada por el diseño y
   expuesto, no ocultado. Los tipos de union discriminados tienen pocos metodos;
   las funciones que actuan sobre ellas se expresan como un conjunto de casos
   utilizando un switch de tipo, con logica diferente en cada caso.

#    The @c(xmlselect) program below extracts and prints the text found beneath
#    certain elements in an XML document tree. Using the API above, it can do its
#    job in a single pass over the input without ever materializing the tree.
   El programa @$(xmlselect) a continuacion, extrae e imprime el texto encontrado
   bajo de ciertos elementos en un arbol de documentos XML. Usando la API
   anterior, puede hacer su trabajo en un solo paso sobre la entrada sin
   materializar el arbol.

#    ..figure > @l(gopl.io/ch7/xmlselect/main.go<>gopl.io/ch7/xmlselect)
   ..figure > @l(gopl.io/ch7/xmlselect/main.go<>gopl.io/ch7/xmlselect)

#      ..src > go
#        // Xmlselect prints the text of selected elements of an XML document.
#        package main
#
#        import (
#          "encoding/xml"
#          "fmt"
#          "io"
#          "os"
#          "strings"
#        )
#
#        func main() {
#          dec := xml.NewDecoder(os.Stdin)
#          var stack []string // stack of element names
#          for {
#            tok, err := dec.Token()
#            if err == io.EOF {
#              break
#            } else if err != nil {
#              fmt.Fprintf(os.Stderr, "xmlselect: %v\n", err)
#              os.Exit(1)
#            }
#            switch tok := tok.(type) {
#            case xml.StartElement:
#              stack = append(stack, tok.Name.Local) // push
#            case xml.EndElement:
#              stack = stack[:len(stack)-1] // pop
#            case xml.CharData:
#              if containsAll(stack, os.Args[1:]) {
#                fmt.Printf("%s: %s\n", strings.Join(stack, " "), tok)
#              }
#            }
#          }
#        }
#
#        // containsAll reports whether x contains the elements of y, in order.
#        func containsAll(x, y []string) bool {
#          for len(y) <= len(x) {
#            if len(y) == 0 {
#              return true
#            }
#            if x[0] == y[0] {
#              y = y[1:]
#            }
#            x = x[1:]
#          }
#          return false
#        }
#      < src..
     ..src > go
       // Xmlselect imprime el texto de los elemenos seleccionados de un documento XML.
       package main

       import (
         "encoding/xml"
         "fmt"
         "io"
         "os"
         "strings"
       )

       func main() {
         dec := xml.NewDecoder(os.Stdin)
         var stack []string // stack de nombres de elementos
         for {
           tok, err := dec.Token()
           if err == io.EOF {
             break
           } else if err != nil {
             fmt.Fprintf(os.Stderr, "xmlselect: %v\n", err)
             os.Exit(1)
           }
           switch tok := tok.(type) {
           case xml.StartElement:
             stack = append(stack, tok.Name.Local) // push
           case xml.EndElement:
             stack = stack[:len(stack)-1] // pop
           case xml.CharData:
             if containsAll(stack, os.Args[1:]) {
               fmt.Printf("%s: %s\n", strings.Join(stack, " "), tok)
             }
           }
         }
       }

       // containsAll informa si x contiene los elementos de y, en orden.
       func containsAll(x, y []string) bool {
         for len(y) <= len(x) {
           if len(y) == 0 {
             return true
           }
           if x[0] == y[0] {
             y = y[1:]
           }
           x = x[1:]
         }
         return false
       }
     < src..


#    Each time the loop in @c(main) encounters a @c(StartElement), it pushes the
#    element’s name onto a stack, and for each @c(EndElement) it pops the name
#    from the stack. The API guarantees that the sequence of @c(StartElement) and
#    @c(EndElement) tokens will be properly matched, even in illformed
#    documents. @c(Comments) are ignored. When @c(xmlselect) encounters a
#    @c(CharData), it prints the text only if the stack contains all the elements
#    named by the command-line arguments, in order.
   Cada vez que el bucle en @c(main) encuentra un @c(StartElement), empuja el
   nombre del elemento en una pila, y para cada @c(EndElement) saca el nombre de
   la pila. La API garantiza que la secuencia de tokens de @c(StartElement) y
   @c(EndElement) se correspondan correctamente, incluso en documentos con
   formato incorrecto. Los @c(Comments) se ignoran. Cuando @c(xmlselect)
   encuentra un @c(CharData), imprime el texto solo si la pila contiene todos
   los elementos nombrados por los argumentos de linea de comandos, en orden.

#    The command below prints the text of any @c(h2) elements appearing beneath
#    two levels of @c(div) elements. Its input is the XML specification, itself an
#    XML document.
   El siguiente comando imprime el texto de cualquier elemento @c(h2) que
   aparezca debajo de dos niveles de elementos @c(div). Su entrada es la
   especificacion XML, en un documento XML.

#    ..src > sh
#      $ go build gopl.io/ch1/fetch
#      $ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 |
#          ./xmlselect div div h2
#      html body div div h2: 1 Introduction
#      html body div div h2: 2 Documents
#      html body div div h2: 3 Logical Structures
#      html body div div h2: 4 Physical Structures
#      html body div div h2: 5 Conformance
#      html body div div h2: 6 Notation
#      html body div div h2: A References
#      html body div div h2: B Definitions for Character Normalization
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch1/fetch
     $ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 |
         ./xmlselect div div h2
     html body div div h2: 1 Introduction
     html body div div h2: 2 Documents
     html body div div h2: 3 Logical Structures
     html body div div h2: 4 Physical Structures
     html body div div h2: 5 Conformance
     html body div div h2: 6 Notation
     html body div div h2: A References
     html body div div h2: B Definitions for Character Normalization
     ...
   < src..

#    @b(Exercise 7.17): Extend @$(xmlselect) so that elements may be selected not
#    just by name, but by their attributes too, in the manner of CSS, so that, for
#    instance, an element like @c(<div id="page" class="wide">) could be selected
#    by a matching @c(id) or @c(class) as well as its name.
   @b(Ejercicio 7.17): Extiende @$(xmlselect) para que los elementos puedan ser
   seleccionados no solo por su nombre, sino tambien por sus atributos, a la
   manera de CSS, de modo que, por ejemplo, un elemento como @c(<div id="page"
   class="wide">) podria ser seleccionado encontrando su @c(id) o @c(class),
   asi como su nombre.

#    @b(Exercise 7.18): Using the token-based decoder API, write a program that
#    will read an arbitrary XML document and construct a tree of generic nodes
#    that represents it. Nodes are of two kinds: @c(CharData) nodes represent text
#    strings, and @c(Element) nodes represent named elements and their
#    attributes. Each element node has a slice of child nodes.
   @b(Ejercicio 7.18): Utilizando el API decodificador basado en token, escribir
   un programa que lea un documento XML arbitrario y construya un arbol de nodos
   genericos que lo represente. Los nodos son de dos tipos: los nodos
   @c(CharData) representan cadenas de texto, y los nodos @c(Element)
   representan elementos con nombre y atributos. Cada nodo de elemento tiene un
   slice de nodos secundarios.

#    You may find the following declarations helpful.
   Puede que las siguientes declaraciones sean utiles.

#    ..src > go
#      import "encoding/xml"
#
#      type Node interface{} // CharData or *Element
#
#      type CharData string
#
#      type Element struct {
#        Type     xml.Name
#        Attr     []xml.Attr
#        Children []Node
#      }
#    < src..
   ..src > go
     import "encoding/xml"

     type Node interface{} // CharData or *Element

     type CharData string

     type Element struct {
       Type     xml.Name
       Attr     []xml.Attr
       Children []Node
     }
   < src..

# ** Section 7.15 <> A Few Words of Advice
** Seccion 7.15 <> Algunos Consejos

#    When designing a new package, novice Go programmers often start by creating a
#    set of interfaces and only later define the concrete types that satisfy
#    them. This approach results in many interfaces, each of which has only a
#    single implementation. Don’t do that. Such interfaces are unnecessary
#    abstractions; they also have a run-time cost. You can restrict which methods
#    of a type or fields of a struct are visible outside a package using the
#    export mechanism (@l(#Section 6.6<>§6.6)).  Interfaces are only needed when
#    there are two or more concrete types that must be dealt with in a uniform
#    way.
   Al diseñar un nuevo paquete, los programadores novatos en Go a menudo
   comienzan creando un conjunto de interfaces y solo mas tarde definen los
   tipos concretos que los satisfacen. Este enfoque resulta en muchas
   interfaces, cada una de las cuales tiene una sola implementacion. No lo
   hagas. Tales interfaces son abstracciones innecesarias; Tambien tienen un
   costo de tiempo de ejecucion. Puede restringir que metodos de un tipo o
   campos de una estructura son visibles fuera de un paquete utilizando el
   mecanismo de exportacion (@l(#Seccion 6.6<>§6.6)). Las interfaces solo son
   necesarias cuando hay dos o mas tipos concretos que deben tratarse de manera
   uniforme.

#    We make an exception to this rule when an interface is satisfied by a single
#    concrete type but that type cannot live in the same package as the interface
#    because of its dependencies. In that case, an interface is a good way to
#    decouple two packages.
   Hacemos una excepcion a esta regla cuando una interfaz es satisfecha por un
   solo tipo concreto pero ese tipo no puede vivir en el mismo paquete que la
   interfaz debido a sus dependencias. En ese caso, una interfaz es una buena
   manera de desacoplar dos paquetes.

#    Because interfaces are used in Go only when they are satisfied by two or more
#    types, they necessarily abstract away from the details of any particular
#    implementation. The result is smaller interfaces with fewer, simpler methods,
#    often just one as with @c(io.Writer) or @c(fmt.Stringer). Small interfaces
#    are easier to satisfy when new types come along. A good rule of thumb for
#    interface design is @e(ask only for what you need).
   Debido a que las interfaces se usan en Go solo cuando estan satisfechas por
   dos o mas tipos, necesariamente se abstraen de los detalles de cualquier
   implementacion en particular. El resultado es interfaces mas pequeños con
   pocos, metodos mas simples, a menudo, solo como uno con @c(io.Writer) o
   @c(fmt.Stringer). Las interfaces pequeñas son mas faciles de satisfacer
   cuando aparecen nuevos tipos. Una buena regla de oro para el diseño de
   interfaces es @e(pedir solo lo que necesitas).

#    This concludes our tour of methods and interfaces. Go has great support for
#    the objectoriented style of programming, but this does not mean you need to
#    use it exclusively. Not everything need be an object; standalone functions
#    have their place, as do unencapsulated data types. Observe that together, the
#    examples in the first five chapters of this book call no more than two dozen
#    methods, like @c(input.Scan), as opposed to ordinary function calls like
#    @c(fmt.Printf).
   Esto concluye nuestro recorrido de metodos e interfaces. Go tiene un gran
   soporte para el estilo de programacion orientado a objetos, pero esto no
   significa que necesite usarlo exclusivamente. No todo debe ser un objeto; Las
   funciones independientes tienen su lugar, al igual que los tipos de datos no
   encapsulados. Observe que, en conjunto, los ejemplos en los primeros cinco
   capitulos de este libro llaman no mas de dos docenas de metodos, como
   @c(input.Scan), a diferencia de las llamadas de funcion ordinaria como
   @c(fmt.Printf).

# * Chapter 8 <> Goroutines and Channels
* Capitulo 8 <> Gorutinas y Canales

#   Concurrent programming, the expression of a program as a composition of
#   several autonomous activities, has never been more important than it is
#   today. Web servers handle requests for thousands of clients at once. Tablet
#   and phone apps render animations in the user interface while simultaneously
#   performing computation and network requests in the background. Even
#   traditional batch problems—read some data, compute, write some output—use
#   concurrency to hide the latency of I/O operations and to exploit a modern
#   computer’s many processors, which every year grow in number but not in speed.
  La programación concurrente, la expresión de un programa como una composición
  de varias actividades autónomas, nunca ha sido tan importante como lo es hoy
  en día. Los servidores Web gestionan solicitudes para miles de clientes a la
  vez. Las aplicaciones de tabletas y teléfonos generan animaciones en la
  interfaz de usuario al tiempo que realizan simultáneamente solicitudes de
  cálculo y de red en segundo plano. Incluso los problemas tradicionales de
  lotes–leer algunos datos, calcular, escribir algo–utilizan concurrencia para
  ocultar la latencia de operaciones E/S y para explotar los procesadores de una
  computadora moderna, que cada año crecen en número pero no en velocidad.

#   Go enables two styles of concurrent programming. This chapter presents
#   goroutines and channels, which support @e(communicating sequential processes)
#   or @A(CSP), a model of concurrency in which values are passed between
#   independent activities (goroutines) but variables are for the most part
#   confined to a single activity. @l(#Chapter 9) covers some aspects of the more
#   traditional model of @e(shared memory multithreading), which will be familiar
#   if you’ve used threads in other mainstream languages. @l(#Chapter 9) also
#   points out some important hazards and pitfalls of concurrent programming that
#   we won’t delve into in this chapter.
  Go permite dos estilos de programación concurrente. Este capítulo presenta las
  goroutines y canales que soportan @e(procesos secuenciales comunicantes) o
  @A(CSP), un modelo de concurrencia en el cual los valores se pasan entre
  actividades independientes (goroutines) pero las variables están en su mayor
  parte confinadas a una sola actividad. El @l(#Capítulo 9) cubre algunos
  aspectos del modelo más tradicional de memoria compartida multihilo, que será
  familiar si ha utilizado hilos en otros lenguajes populares. El
  @l(#Capítulo 9) también señala algunos peligros y trampas importantes de la
  programación concurrente que no profundizaremos en este capítulo.

#   Even though Go’s support for concurrency is one of its great strengths,
#   reasoning about concurrent programs is inherently harder than about sequential
#   ones, and intuitions acquired from sequential programming may at times lead us
#   astray. If this is your first encounter with concurrency, we recommend
#   spending a little extra time thinking about the examples in these two
#   chapters.
  A pesar de que el soporte de Go para la concurrencia es una de sus grandes
  fortalezas, el razonamiento sobre los programas concurrentes es
  intrínsecamente más difícil que los secuenciales, y las intuiciones adquiridas
  a partir de la programación secuencial pueden a veces desviarnos. Si este es
  tu primer encuentro con la concurrencia, recomendamos dedicar un poco más de
  tiempo para pensar en los ejemplos de estos dos capítulos.

# ** Section 8.1 <> Goroutines
** Seccion 8.1 <> Gorutinas

#    In Go, each concurrently executing activity is called a @e(goroutine).
#    Consider a program that has two functions, one that does some computation and
#    one that writes some output, and assume that neither function calls the
#    other. A sequential program may call one function and then call the other,
#    but in a @e(concurrent) program with two or more goroutines, calls to
#    @e(both) functions can be active at the same time. We’ll see such a program
#    in a moment.
   En Go, cada actividad que se ejecuta simultáneamente se denomina
   @e(gorutina). Considere un programa que tiene dos funciones, una que hace
   algún cálculo y otra que escribe alguna salida, y asume que ninguna de las
   dos funciones llama a la otra. Un programa secuencial puede llamar a una
   función y luego llamar a la otra, pero en un programa @e(concurrente) con dos
   o más gorutinas, las llamadas a @e(ambas) funciones pueden estar activas al
   mismo tiempo. Veremos tal programa en un momento.

#    If you have used operating system threads or threads in other languages, then
#    you can assume for now that a goroutine is similar to a thread, and you’ll be
#    able to write correct programs. The differences between threads and
#    goroutines are essentially quantitative, not qualitative, and will be
#    described in @l(#Section 9.8).
   Si ha utilizado subprocesos o subprocesos del sistema operativo en otros
   lenguajes, puede suponer que una gorutina es similar a un subproceso y que
   podrá escribir programas correctos. Las diferencias entre hilos y gorutinas
   son esencialmente cuantitativas, no cualitativas, y serán descritas en la
   @l(#Sección 9.8).

#    When a program starts, its only goroutine is the one that calls the @c(main)
#    function, so we call it the @e(main goroutine). New goroutines are created by
#    the @c(go) statement. Syntactically, a @c(go) statement is an ordinary function
#    or method call prefixed by the keyword @c(go). A @c(go) statement causes the
#    function to be called in a newly created goroutine. The @c(go) statement
#    itself completes immediately:
   Cuando un programa inicia, su única goroutine es el que a llama la función
   @c(main), así que la llamamos la @e(gorutina principal). Las nuevos gorutinas
   son creados por la declaración @c(go). Sintácticamente, una sentencia @c(go)
   es una función ordinaria o un llamado a un método prefijado por la palabra
   clave @c(go). Una sentencia @c(go) hace que la función sea llamada en una
   gorutina recién creada. La sentencia @c(go) en si misma se completa
   inmediatamente:

#    ..src > go
#      f()    // call f(); wait for it to return
#      go f() // create a new goroutine that calls f(); don't wait
#    < src..
   ..src > go
     f()    // llamar a f(); Espera el retorno
     go f() // crea una nueva gorutina que llama a f(); no espera
   < src..

#    In the example below, the main goroutine computes the 45th Fibonacci
#    number. Since it uses the terribly inefficient recursive algorithm, it runs
#    for an appreciable time, during which we’d like to provide the user with a
#    visual indication that the program is still running, by displaying an
#    animated textual @"(spinner.)
   En el ejemplo a continuación, la gorutina principal calcula el 45 número de
   Fibonacci. Dado que utiliza un algoritmo recursivo terriblemente ineficiente,
   se ejecuta durante un tiempo apreciable, durante el cual nos gustaría
   proporcionar al usuario una indicación visual de que el programa sigue en
   ejecución, mediante la visualización de un texto animado @"(spinner).

#    ..figure > @l(gopl.io/ch8/spinner/main.go<>gopl.io/ch8/spinner)
   ..figure > @l(gopl.io/ch8/spinner/main.go<>gopl.io/ch8/spinner)

#      ..src > go
#        func main() {
#          go spinner(100 * time.Millisecond)
#          const n = 45
#          fibN := fib(n) // slow
#          fmt.Printf("\rFibonacci(%d) = %d\n", n, fibN)
#        }
#
#        func spinner(delay time.Duration) {
#          for {
#            for _, r := range `-\|/` {
#              fmt.Printf("\r%c", r)
#              time.Sleep(delay)
#            }
#          }
#        }
#
#        func fib(x int) int {
#          if x < 2 {
#            return x
#          }
#          return fib(x-1) + fib(x-2)
#        }
#      < src..
     ..src > go
       func main() {
         go spinner(100 * time.Millisecond)
         const n = 45
         fibN := fib(n) // lento
         fmt.Printf("\rFibonacci(%d) = %d\n", n, fibN)
       }

       func spinner(delay time.Duration) {
         for {
           for _, r := range `-\|/` {
             fmt.Printf("\r%c", r)
             time.Sleep(delay)
           }
         }
       }

       func fib(x int) int {
         if x < 2 {
           return x
         }
         return fib(x-1) + fib(x-2)
       }
     < src..


#    After several seconds of animation, the @c[fib(45)] call returns and the
#    @c(main) function prints its result:
   Después de varios segundos de animación, la llamada @c[fib(45)] regresa y la
   función @c(main) imprime su resultado:

#    ..pre >
#      Fibonacci(45) = 1134903170
   ..pre >
     Fibonacci(45) = 1134903170


#    The @c(main) function then returns. When this happens, all goroutines are
#    abruptly terminated and the program exits. Other than by returning from
#    @c(main) or exiting the program, there is no programmatic way for one
#    goroutine to stop another, but as we will see later, there are ways to
#    communicate with a goroutine to request that it stop itself.
   Luego regresa la función @c(main) principal. Cuando esto sucede, todas las
   gorutinas terminan abruptamente y el programa sale. Aparte de regresar de
   @c(main) o salir del programa, no hay ninguna forma programática para que una
   goroutine detenga a otra, pero como veremos más adelante, hay maneras de
   comunicarse con una gorutina para pedirle que se detenga.

#    Notice how the program is expressed as the composition of two autonomous
#    activities, spinning and Fibonacci computation. Each is written as a separate
#    function but both make progress concurrently.
   Observe cómo el promaga se expresa como la composición de dos actividades
   autónomas, @c(spinning) y el cálculo de Fibonacci. Cada uno se escribe como
   una función separada pero ambos hacen progreso simultáneamente.

# ** Section 8.2 <> Example: Concurrent Clock Server
** Seccion 8.2 <> Ejemplo: Servidor de Reloj Concurrente

#    Networking is a natural domain in which to use concurrency since servers
#    typically handle many connections from their clients at once, each client
#    being essentially independent of the others. In this section, we’ll introduce
#    the @c(net) package, which provides the components for building networked
#    client and server programs that communicate over TCP, UDP, or Unix domain
#    sockets. The @c(net/http) package we’ve been using since @l(#Chapter 1) is
#    built on top of functions from the @c(net) package.
   El trabajo en red es un dominio natural en el que se utiliza la concurrecia,
   ya que los servidores suelen manejar muchas conexiones de sus clientes a la
   vez, cada cliente es esencialmente independiente de los demás. En esta
   sección, presentaremos el paquete @c(net), que proporciona los componentes
   para construir programas de cliente y servidor en red que se comunican a
   través de TCP, UDP o sockets de dominio Unix. El paquete @c(net/http) que
   hemos estado utilizando desde el @l(#Capitulo 1) se construye en la parte
   superior de las funciones del paquete @c(net).

#    Our first example is a sequential clock server that writes the current time
#    to the client once per second:
   Nuestro primer ejemplo es un servidor de reloj secuencial que escribe el
   tiempo actual al cliente una vez por segundo:

#    ..figure > @l(gopl.io/ch8/clock1/clock.go<>gopl.io/ch8/clock1)
   ..figure > @l(gopl.io/ch8/clock1/clock.go<>gopl.io/ch8/clock1)

#      ..src > go
#        // Clock1 is a TCP server that periodically writes the time.
#        package main
#
#        import (
#          "io"
#          "log"
#          "net"
#          "time"
#        )
#
#        func main() {
#          listener, err := net.Listen("tcp", "localhost:8000")
#          if err != nil {
#            log.Fatal(err)
#          }
#          for {
#            conn, err := listener.Accept()
#            if err != nil {
#              log.Print(err) // e.g., connection aborted
#              continue
#            }
#            handleConn(conn) // handle one connection at a time
#          }
#        }
#
#        func handleConn(c net.Conn) {
#          defer c.Close()
#          for {
#            _, err := io.WriteString(c, time.Now().Format("15:04:05\n"))
#            if err != nil {
#              return // e.g., client disconnected
#            }
#            time.Sleep(1 * time.Second)
#          }
#        }
#      < src..
     ..src > go
       // Clock1 es un servidor TCP que escribe periodicamente la hora.
       package main

       import (
         "io"
         "log"
         "net"
         "time"
       )

       func main() {
         listener, err := net.Listen("tcp", "localhost:8000")
         if err != nil {
           log.Fatal(err)
         }
         for {
           conn, err := listener.Accept()
           if err != nil {
             log.Print(err) // e.g., coneccion abortada
             continue
           }
           handleConn(conn) // maneja una coneccion a la vez
         }
       }

       func handleConn(c net.Conn) {
         defer c.Close()
         for {
           _, err := io.WriteString(c, time.Now().Format("15:04:05\n"))
           if err != nil {
             return // e.g., cliente desconectado
           }
           time.Sleep(1 * time.Second)
         }
       }
     < src..


#    The @c(Listen) function creates a @c(net.Listener), an object that listens
#    for incoming connections on a network port, in this case TCP port
#    @c(localhost:8000). The listener’s @c(Accept) method blocks until an incoming
#    connection request is made, then returns a @c(net.Conn) object representing
#    the connection.
   La función @c(Listen) crea un @c(net.Listener), un objeto que escucha las
   conexiones entrantes en un puerto de red, en este caso el puerto TCP
   @c(localhost:8000). El método @c(Accept) del oyente se bloquea hasta que se
   realiza una petición de conexión entrante, y luego devuelve un objeto
   @c(net.Conn) que representa la conexión.

#    The @c(handleConn) function handles one complete client connection. In a
#    loop, it writes the current time, @c[time.Now()], to the client. Since
#    @c(net.Conn) satisfies the @c(io.Writer) interface, we can write directly to
#    it. The loop ends when the write fails, most likely because the client has
#    disconnected, at which point @c(handleConn) closes its side of the connection
#    using a deferred call to @c(Close) and goes back to waiting for another
#    connection request.
   La función @c(handleConn) maneja una conexión completa del cliente. En un
   bucle, escribe el tiempo actual, @c[time.Now()], al cliente. Ya que
   @c(net.Conn) satisface la interfaz @c(io.Writer), podemos escribir en el
   directamente. El bucle termina cuando falla la escritura, lo más probable es
   porque el cliente se haya desconectado, momento en el que @c(handleConn)
   cierra su lado de la conexión usando una llamada diferida a @c(Close) y
   vuelve a esperar otra solicitud de conexión.

#    The @c(time.Time.Format) method provides a way to format date and time
#    information by example. Its argument is a template indicating how to format a
#    reference time, specifically @c(Mon Jan 2 03:04:05PM 2006 UTC-0700). The
#    reference time has eight components (day of the week, month, day of the
#    month, and so on). Any collection of them can appear in the @c(Format) string
#    in any order and in a number of formats; the selected components of the date
#    and time will be displayed in the selected formats. Here we are just using
#    the hour, minute, and second of the time. The @c(time) package defines
#    templates for many standard time formats, such as @c(time.RFC1123). The same
#    mechanism is used in reverse when parsing a time using @c(time.Parse).
   El método @c(time.Time.Format) proporciona una forma de dar formato a la
   información de fecha y hora por ejemplo. Su argumento es una plantilla que
   indica la forma de dar formato a un tiempo de referencia, específicamente
   @c(Mon Jan 2 03:04:05PM 2006 UTC-0700). El tiempo de referencia tiene ocho
   componentes (día de la semana, mes, día del mes, etc.). Cualquier colección
   de ellos puede aparecer en la cadena @c(Format) en cualquier orden y en
   varios formatos; Los componentes seleccionados de la fecha y la hora se
   mostrarán en los formatos seleccionados. Aquí estamos usando la hora, minuto
   y segundo del tiempo. El paquete @c(time) define plantillas para muchos
   formatos de hora estándar, como @c(time.RFC1123). El mismo mecanismo se
   utiliza a la inversa al analizar un tiempo usando @c(time.Parse).

#    To connect to the server, we’ll need a client program such as @$(nc)
#    (@"(netcat)), a standard utility program for manipulating network
#    connections:
   Para conectarse al servidor, necesitaremos un programa cliente como @$(nc)
   (@"(netcat)), un programa de utilidad estándar para manipular conexiones de
   red:

#    ..src > sh
#      $ go build gopl.io/ch8/clock1
#      $ ./clock1 &
#      $ nc localhost 8000
#      13:58:54
#      13:58:55
#      13:58:56
#      13:58:57
#      ^C
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/clock1
     $ ./clock1 &
     $ nc localhost 8000
     13:58:54
     13:58:55
     13:58:56
     13:58:57
     ^C
   < src..

#    The client displays the time sent by the server each second until we
#    interrupt the client with Control-C, which on Unix systems is echoed as
#    @c(^C) by the shell. If @$(nc) or @$(netcat) is not installed on your system,
#    you can use @$(telnet) or this simple Go version of @$(netcat) that uses
#    @c(net.Dial) to connect to a TCP server:
   El cliente muestra el tiempo enviado por el servidor cada segundo hasta que
   interrumpimos el cliente con Control-C, que en los sistemas Unix se hace eco
   como @c(^C) por el shell. Si @$(nc) o netcat no está instalado en su sistema,
   puede usar @$(telnet) o esta versión simple de @$(netcat) que utiliza
   @c(net.Dial) para conectarse a un servidor TCP:

#    ..figure > @l(gopl.io/ch8/netcat1/netcat.go<>gopl.io/ch8/netcat1)
   ..figure > @l(gopl.io/ch8/netcat1/netcat.go<>gopl.io/ch8/netcat1)

#      ..src > go
#        // Netcat1 is a read-only TCP client.
#        package main
#
#        import (
#          "io"
#          "log"
#          "net"
#          "os"
#        )
#
#        func main() {
#          conn, err := net.Dial("tcp", "localhost:8000")
#          if err != nil {
#            log.Fatal(err)
#          }
#          defer conn.Close()
#          mustCopy(os.Stdout, conn)
#        }
#
#        func mustCopy(dst io.Writer, src io.Reader) {
#          if _, err := io.Copy(dst, src); err != nil {
#            log.Fatal(err)
#          }
#        }
#      < src..
     ..src > go
       // Netcat1 es un cliente TCP de solo lectura.
       package main

       import (
         "io"
         "log"
         "net"
         "os"
       )

       func main() {
         conn, err := net.Dial("tcp", "localhost:8000")
         if err != nil {
           log.Fatal(err)
         }
         defer conn.Close()
         mustCopy(os.Stdout, conn)
       }

       func mustCopy(dst io.Writer, src io.Reader) {
         if _, err := io.Copy(dst, src); err != nil {
           log.Fatal(err)
         }
       }
     < src..


#    This program reads data from the connection and writes it to the standard
#    output until an end-of-file condition or an error occurs. The @c(mustCopy)
#    function is a utility used in several examples in this section. Let’s run two
#    clients at the same time on different terminals, one shown to the left and
#    one to the right:
   Este programa lee datos de la conexión y los escribe en la salida estándar
   hasta que se produce una condición de fin de archivo o un error. La función
   @c(mustCopy) es una utilidad utilizada en varios ejemplos en esta sección. Vamos
   a correr dos clientes al mismo tiempo en diferentes terminales, una mostrada
   a la izquierda y otra a la derecha:

#    ..cols >
   ..cols >

#      ..src > sh
#        $ go build gopl.io/ch8/netcat1
#        $ ./netcat1
#        13:58:54
#        13:58:55
#        13:58:56
#        ^C
#      < src..
     ..src > sh
       $ go build gopl.io/ch8/netcat1
       $ ./netcat1
       13:58:54
       13:58:55
       13:58:56
       ^C
     < src..

#      ..src > sh
#        $ killall clock1
#      < src..
     ..src > sh
       $ killall clock1
     < src..

#      ::
     ::

#      ..src > sh
#        $ ./netcat1
#
#        13:58:57
#        13:58:58
#        13:58:59
#        ^C
#      < src..
     ..src > sh
       $ ./netcat1

       13:58:57
       13:58:58
       13:58:59
       ^C
     < src..


#    The @$(killall) command is a Unix utility that kills all processes with the
#    given name.
   El comando @$(killall) es una utilidad Unix que elimina todos los procesos
   con el nombre dado.

#    The second client must wait until the first client is finished because the
#    server is @e(sequential); it deals with only one client at a time. Just one
#    small change is needed to make the server concurrent: adding the @c(go)
#    keyword to the call to @c(handleConn) causes each call to run in its own
#    goroutine.
   El segundo cliente debe esperar hasta que finalice el primer cliente porque
   el servidor es secuencial; Sólo se maneja un cliente a la vez. Sólo se
   necesita un pequeño cambio para hacer que el servidor sea concurrente:
   agregar la palabra clave @c(go) a la llamada a @c(handleConn) hace que cada llamada
   se ejecute en su propia goroutine.

#    ..figure > @l(gopl.io/ch8/clock2/clock.go<>gopl.io/ch8/clock2)
   ..figure > @l(gopl.io/ch8/clock2/clock.go<>gopl.io/ch8/clock2)

#      ..src > go
#        for {
#          conn, err := listener.Accept()
#          if err != nil {
#            log.Print(err) // e.g., connection aborted
#            continue
#          }
#          go handleConn(conn) // handle connections concurrently
#        }
#      < src..
     ..src > go
       for {
         conn, err := listener.Accept()
         if err != nil {
           log.Print(err) // e.g., connection aborted
           continue
         }
         go handleConn(conn) // handle connections concurrently
       }
     < src..


#    Now, multiple clients can receive the time at once:
   Ahora, varios clientes pueden recivir el tiempo a la vez:

#    ..cols >
   ..cols >

#      ..src > sh
#        $ go build gopl.io/ch8/clock2
#        $ ./clock2 &
#        $ go build gopl.io/ch8/netcat1
#        $ ./netcat1
#        14:02:54
#        14:02:55
#        14:02:56
#        14:02:57
#        14:02:58
#        14:02:59
#        14:03:00
#        14:03:01
#        ^C
#      < src..
     ..src > sh
       $ go build gopl.io/ch8/clock2
       $ ./clock2 &
       $ go build gopl.io/ch8/netcat1
       $ ./netcat1
       14:02:54
       14:02:55
       14:02:56
       14:02:57
       14:02:58
       14:02:59
       14:03:00
       14:03:01
       ^C
     < src..

#      ..src > sh
#        $ killall clock1
#      < src..
     ..src > sh
       $ killall clock1
     < src..

#      ::
     ::

#      ..src > sh
#        $ ./netcat1
#        14:02:55
#        14:02:56
#        ^C
#      < src..
     ..src > sh
       $ ./netcat1
       14:02:55
       14:02:56
       ^C
     < src..

#      ..src > sh
#        $ ./netcat1
#        14:03:00
#        14:03:01
#        14:03:02
#        ^C
#      < src..
     ..src > sh
       $ ./netcat1
       14:03:00
       14:03:01
       14:03:02
       ^C
     < src..


#    @b(Exercise 8.1): Modify @$(clock2) to accept a port number, and write a
#    program, @$(clockwall), that acts as a client of several clock servers at
#    once, reading the times from each one and displaying the results in a table,
#    akin to the wall of clocks seen in some business offices. If you have access
#    to geographically distributed computers, run instances remotely ; otherwise
#    run local instances on different ports with fake time zones.
   @b(Ejercicio 8.1): Modificar @$(clock2) para aceptar un número de puerto y
   escribir un programa, @$(clockwall), que actúe como cliente de varios
   servidores de reloj a la vez, leyendo los tiempos de cada uno y mostrando los
   resultados en una tabla, similar a la pared de los relojes que se ven en
   algunas oficinas de negocios. Si tiene acceso a equipos distribuidos
   geográficamente, ejecute instancias de forma remota; De lo contrario, ejecute
   instancias locales en diferentes puertos con zonas horarias falsas.

#    ..src > sh
#      $ TZ=US/Eastern    ./clock2 -port 8010 &
#      $ TZ=Asia/Tokyo    ./clock2 -port 8020 &
#      $ TZ=Europe/London ./clock2 -port 8030 &
#      $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030
#    < src..
   ..src > sh
     $ TZ=US/Eastern    ./clock2 -port 8010 &
     $ TZ=Asia/Tokyo    ./clock2 -port 8020 &
     $ TZ=Europe/London ./clock2 -port 8030 &
     $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030
   < src..


#    @b(Exercise 8.2): Implement a concurrent File Transfer Protocol (FTP)
#    server. The server should interpret commands from each client such as @$(cd) to
#    change directory, @$(ls) to list a directory, @$(get) to send the contents of
#    a file, and @c(close) to close the connection. You can use the standard
#    @$(ftp) command as the client, or write your own.
   @b(Ejercicio 8.2): Implementar un servidor de transferencia de archivos
   simultáneo (FTP). El servidor debe interpretar los comandos de cada cliente
   como @$(cd) para cambiar el directorio, @$(ls) para listar un directorio,
   @$(get) para enviar el contenido de un archivo y @$(close) para cerrar la
   conexión. Puede utilizar el comando @$(ftp) estándar como cliente o escribir
   el suyo.

# ** Section 8.3 <> Example: Concurrent Echo Server
** Seccion 8.3 <> Ejemplo: Servidor Echo Concurrente

#    The clock server used one goroutine per connection. In this section, we’ll
#    build an echo server that uses multiple goroutines per connection. Most echo
#    servers merely write whatever they read, which can be done with this trivial
#    version of @c(handleConn):
   El servidor de reloj utiliza una gorutina por conexión. En esta sección,
   crearemos un servidor de eco que utiliza múltiples gorutinas por conexión.
   La mayoría de los servidores de eco simplemente escriben lo que lean, lo que
   se puede hacer con esta trivial versión de @c(handleConn):

#    ..src > go
#      func handleConn(c net.Conn) {
#        io.Copy(c, c) // NOTE: ignoring errors
#        c.Close()
#      }
#    < src..
   ..src > go
     func handleConn(c net.Conn) {
       io.Copy(c, c) // NOTA: Ignorando errores
       c.Close()
     }
   < src..

#    A more interesting echo server might simulate the reverberations of a real
#    echo, with the response loud at first (@c("HELLO!")), then moderate
#    (@c("Hello!"))  after a delay, then quiet (@c("hello!")) before fading to
#    nothing, as in this version of @c(handleConn):
   Un servidor de eco más interesante podría simular las reverberaciones de un
   eco real, con la respuesta fuerte al principio (@c("HELLO!")), Luego moderado
   (@c("¡Hello!")) después de un retraso, luego callado (@c("¡hola!") como en
   esta versión de @c(handleConn):

#    ..figure > @l(gopl.io/ch8/reverb1/reverb.go<>gopl.io/ch8/reverb1)
   ..figure > @l(gopl.io/ch8/reverb1/reverb.go<>gopl.io/ch8/reverb1)

#      ..src > go
#        func echo(c net.Conn, shout string, delay time.Duration) {
#          fmt.Fprintln(c, "\t", strings.ToUpper(shout))
#          time.Sleep(delay)
#          fmt.Fprintln(c, "\t", shout)
#          time.Sleep(delay)
#          fmt.Fprintln(c, "\t", strings.ToLower(shout))
#        }
#
#        func handleConn(c net.Conn) {
#          input := bufio.NewScanner(c)
#          for input.Scan() {
#            echo(c, input.Text(), 1*time.Second)
#          }
#          // NOTE: ignoring potential errors from input.Err()
#          c.Close()
#        }
#      < src..
     ..src > go
       func echo(c net.Conn, shout string, delay time.Duration) {
         fmt.Fprintln(c, "\t", strings.ToUpper(shout))
         time.Sleep(delay)
         fmt.Fprintln(c, "\t", shout)
         time.Sleep(delay)
         fmt.Fprintln(c, "\t", strings.ToLower(shout))
       }

       func handleConn(c net.Conn) {
         input := bufio.NewScanner(c)
         for input.Scan() {
           echo(c, input.Text(), 1*time.Second)
         }
         // NOTE: ignoring potential errors from input.Err()
         c.Close()
       }
     < src..


#    We’ll need to upgrade our client program so that it sends terminal input to
#    the server while also copying the server response to the output, which
#    presents another opportunity to use concurrency:
   Necesitaremos actualizar nuestro programa cliente para que envíe la entrada
   del terminal al servidor mientras copia la respuesta del servidor a la
   salida, lo que presenta otra oportunidad de utilizar la concurrencia:

#    ..figure > @l(gopl.io/ch8/netcat2/netcat.go<>gopl.io/ch8/netcat2)
   ..figure > @l(gopl.io/ch8/netcat2/netcat.go<>gopl.io/ch8/netcat2)

#      ..src > go
#        func main() {
#          conn, err := net.Dial("tcp", "localhost:8000")
#          if err != nil {
#            log.Fatal(err)
#          }
#          defer conn.Close()
#          go mustCopy(os.Stdout, conn)
#          mustCopy(conn, os.Stdin)
#        }
#      < src..
     ..src > go
       func main() {
         conn, err := net.Dial("tcp", "localhost:8000")
         if err != nil {
           log.Fatal(err)
         }
         defer conn.Close()
         go mustCopy(os.Stdout, conn)
         mustCopy(conn, os.Stdin)
       }
     < src..


#    While the main goroutine reads the standard input and sends it to the server,
#    a second goroutine reads and prints the server’s response. When the main
#    goroutine encounters the end of the input, for example, after the user types
#    Control-D (@c(^D)) at the terminal (or the equivalent Control-Z on Microsoft
#    Windows), the program stops, even if the other goroutine still has work to
#    do. (We’ll see how to make the program wait for both sides to finish once
#    we’ve introduced channels in @l(#Section 8.4.1).)
   Mientras la gorutina principal lee la entrada estándar y la envía al
   servidor, una segunda gorutina lee e imprime la respuesta del servidor.
   Cuando la gorutina principal encuentra el final de la entrada, por ejemplo,
   después de que el usuario teclee Control-D (@c(^D)) en el terminal (o el
   equivalente Control-Z en Microsoft Windows), el programa se detiene, incluso
   si el otra gorutina aun tiene trabajo que hacer. (Veremos cómo hacer que el
   programa espere a que ambos lados terminen una vez que hayamos introducido
   los canales en @l(#Sección 8.4.1).)

#    In the session below, the client’s input is left-aligned and the server’s
#    responses are indented.  The client shouts at the echo server three times:
   En la siguiente sesión, la entrada del cliente está alineada a la izquierda y
   las respuestas del servidor tienen indentacion. El cliente grita en el
   servidor de eco tres veces:

#    ..src > sh
#      $ go build gopl.io/ch8/reverb1
#      $ ./reverb1 &
#      $ go build gopl.io/ch8/netcat2
#      $ ./netcat2
#      Hello?
#          HELLO?
#          Hello?
#          hello?
#      Is there anybody there?
#          IS THERE ANYBODY THERE?
#      Yooo-hooo!
#          Is there anybody there?
#          is there anybody there?
#          YOOO-HOOO!
#          Yooo-hooo!
#          yooo-hooo!
#      ^D
#      $ killall reverb1
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/reverb1
     $ ./reverb1 &
     $ go build gopl.io/ch8/netcat2
     $ ./netcat2
     Hello?
         HELLO?
         Hello?
         hello?
     Is there anybody there?
         IS THERE ANYBODY THERE?
     Yooo-hooo!
         Is there anybody there?
         is there anybody there?
         YOOO-HOOO!
         Yooo-hooo!
         yooo-hooo!
     ^D
     $ killall reverb1
   < src..

#    Notice that the third shout from the client is not dealt with until the
#    second shout has petered out, which is not very realistic. A real echo would
#    consist of the @e(composition) of the three independent shouts. To simulate it,
#    we’ll need more goroutines. Again, all we need to do is add the @c(go) keyword,
#    this time to the call to @c(echo)
   Tenga en cuenta que el tercer grito del cliente no se maneja hasta que el
   segundo grito se ha agotado, lo que no es muy realista. Un eco real
   consistiría en la @e(composición) de los tres gritos independientes. Para
   simularlo, necesitaremos más goroutines. Una vez más, todo lo que tenemos que
   hacer es añadir la palabra clave @c(go), esta vez a la llamada a @c(eco)

#    ..figure > @l(gopl.io/ch8/reverb2/reverb.go<>gopl.io/ch8/reverb2)
   ..figure > @l(gopl.io/ch8/reverb2/reverb.go<>gopl.io/ch8/reverb2)

#      ..src > go
#        func handleConn(c net.Conn) {
#          input := bufio.NewScanner(c)
#          for input.Scan() {
#            go echo(c, input.Text(), 1*time.Second)
#          }
#          // NOTE: ignoring potential errors from input.Err()
#          c.Close()
#        }
#      < src..
     ..src > go
       func handleConn(c net.Conn) {
         input := bufio.NewScanner(c)
         for input.Scan() {
           go echo(c, input.Text(), 1*time.Second)
         }
         // NOTA: Ignorando errores potenciales de input.Err()
         c.Close()
       }
     < src..


#    The arguments to the function started by @c(go) are evaluated when the @c(go)
#    statement itself is executed; thus @c[input.Text()] is evaluated in the main
#    goroutine.  Now the echoes are concurrent and overlap in time:
   Los argumentos a la función iniciada por @c(go) se evalúan cuando se ejecuta
   la instrucción @c(go); Así @c[input.Text()] se evalúa en la gorutina
   principal. Ahora los ecos son simultáneos y se superponen en el tiempo:

#    ..src > sh
#      $ go build gopl.io/ch8/reverb2
#      $ ./reverb2 &
#      $ ./netcat2
#      Is there anybody there?
#          IS THERE ANYBODY THERE?
#
#      Yooo-hooo!
#          Is there anybody there?
#          YOOO-HOOO!
#          is there anybody there?
#          Yooo-hooo!
#          yooo-hooo!
#      ^D
#      $ killall reverb2
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/reverb2
     $ ./reverb2 &
     $ ./netcat2
     Is there anybody there?
         IS THERE ANYBODY THERE?

     Yooo-hooo!
         Is there anybody there?
         YOOO-HOOO!
         is there anybody there?
         Yooo-hooo!
         yooo-hooo!
     ^D
     $ killall reverb2
   < src..

#    All that was required to make the server use concurrency, not just to handle
#    connections from multiple clients but even within a single connection, was
#    the insertion of two @c(go) keywords.
   Todo lo que se requería para hacer que el servidor utilizara la
   concurrencia, no sólo para manejar las conexiones de varios clientes, sino
   incluso dentro de una sola conexión, era la inserción de dos palabras clave.

#    However in adding these keywords, we had to consider carefully that it is
#    safe to call methods of @c(net.Conn) concurrently, which is not true for most
#    types. We’ll discuss the crucial concept of @e(concurrency safety) in the
#    next chapter.
   Sin embargo, al agregar estas palabras clave, tuvimos que considerar
   cuidadosamente que métodos de @c(net.Conn) es seguro llamar simultáneamente,
   lo cual no es cierto para la mayoría de los tipos. Discutiremos el concepto
   crucial de la seguridad de la concurrencia en el próximo capítulo.

# ** Section 8.4 <> Channels
** Seccion 8.4 <> Canales

#    If goroutines are the activities of a concurrent Go program, @e(channels) are
#    the connections between them. A channel is a communication mechanism that
#    lets one goroutine send values to another goroutine. Each channel is a
#    conduit for values of a particular type, called the channel’s @e(element
#    type). The type of a channel whose elements have type @c(int) is written
#    @c(chan int).
   Si las gorutinas son las actividades concurrentes de un programa Go, los
   @e(canales) son las conexiones entre ellas. Un canal es un mecanismo de
   comunicacion que permite a un gorutina enviar valores a otra gorutina. Cada
   canal es un conducto para los valores de un tipo particular, llamado canal de
   @e(tipo canal). El tipo de un canal cuyos elementos tienen tipo @c(int) se
   escribe @c(chan int).

#    To create a channel, we use the built-in @c(make) function:
   Para crear un canal, se utiliza la funcion nativa @c(make):

#    ..src > go
#      ch := make(chan int) // ch has type 'chan int'
#    < src..
   ..src > go
     ch := make(chan int) // ch tiene tipo 'chan int'
   < src..

#    As with maps, a channel is a @e(reference) to the data structure created by
#    @c(make). When we copy a channel or pass one as an argument to a function, we
#    are copying a reference, so caller and callee refer to the same data
#    structure. As with other reference types, the zero value of a channel is
#    @c(nil).
   Al igual que con los mapas, un canal es una referencia a la estructura de
   datos creada por @c(make). Cuando copiamos un canal o pasamos uno como
   argumento a una funcion, estamos copiando una referencia, de modo que el
   llamador y el receptor llaman a la misma estructura de datos. Como con otros
   tipos de referencia, el valor cero de un canal es @c(nil).

#    Two channels of the same type may be compared using @c(==). The comparison is
#    true if both are references to the same channel data structure. A channel may
#    also be compared to @c(nil).
   Dos canales del mismo tipo pueden compararse usando @c(==). La comparacion es
   verdadera si ambas son referencias a la misma estructura de datos de canal.
   Un canal puede tambien ser comparado con @c(nil).

#    A channel has two principal operations, @e(send) and @e(receive),
#    collectively known as @e(communications). A send statement transmits a value
#    from one goroutine, through the channel, to another goroutine executing a
#    corresponding receive expression. Both operations are written using the
#    @c(<-) operator. In a send statement, the @c(<-) separates the channel and
#    value operands. In a receive expression, @c(<-) precedes the channel
#    operand. A receive expression whose result is not used is a valid statement.
   Un canal tiene dos operaciones principales, @e(enviar) y @e(recibir),
   conocidas colectivamente como @e(comunicaciones). Una sentencia de envio
   transmite un valor de una gorutina, a traves del canal, a otra gorutina
   ejecutando una expresion de recepcion correspondiente. Ambas operaciones se
   escriben utilizando el operador @c(<-). En una declaracion de envio, el
   @c(<-) separa los operandos de canal y de valor. En una expresion de
   recepcion, @c(<-) precede al operando del canal. Una expresion de recepcion
   cuyo resultado no se utiliza es una sentencia valida.

#    ..src > go
#      ch <- x  // a send statement
#
#      x = <-ch // a receive expression in an assignment statement
#      <-ch     // a receive statement; result is discarded
#    < src..
   ..src > go
     ch <- x  // una sentencia de envio

     x = <-ch // una sentencia de recepcion en una instruccion de asignacion
     <-ch     // una sentencia de recepcion; el resultado se descarta
   < src..

#    Channels support a third operation, @e(close), which sets a flag indicating
#    that no more values will ever be sent on this channel; subsequent attempts to
#    send will panic. Receive operations on a closed channel yield the values that
#    have been sent until no more values are left; any receive operations
#    thereafter complete immediately and yield the zero value of the channel’s
#    element type.
   Los canales soportan una tercera operacion, @e(cierre), que establece una
   bandera que indica que no se eviaran mas valores en este canal; los intentos
   subsiguientes de envio seran panico. Las operaciones de recepcion en un
   canal cerrado generan los valores que se han enviado hasta que no quedan mas
   valores; Cualquier operacion de recepcion se completa inmediatamente y
   produce el valor cero del tipo de elemento del canal.

#    To close a channel, we call the built-in @c(close) function:
   Para cerrar un canal, que llamamos la funcion nativa @c(close):

#    ..src > go
#      close(ch)
#    < src..
   ..src > go
     close(ch)
   < src..

#    A channel created with a simple call to @c(make) is called an @e(unbuffered)
#    channel, but @c(make) accepts an optional second argument, an integer called
#    the channel’s @e(capacity). If the capacity is nonzero, @c(make) creates a
#    @e(buffered) channel.
   Un canal creado con una simple llamada a @c(make) se denomina un canal @e(sin
   bufer), pero @c(make) acepta un segundo argumento opcional, un entero llamado
   la @e(capacidad) del canal. Si la capacidad es distinta de cero, @c(make)
   crea un canal @e(con bufer).

#    ..src > go
#      ch = make(chan int)    // unbuffered channel
#      ch = make(chan int, 0) // unbuffered channel
#      ch = make(chan int, 3) // buffered channel with capacity 3
#    < src..
   ..src > go
     ch = make(chan int)    // canal sin bufer
     ch = make(chan int, 0) // canal sin bufer
     ch = make(chan int, 3) // canal cor bufer con capacidad 3
   < src..

#    We’ll look at unbuffered channels first and buffered channels in @l(#Section
#    8.4.4).
   Veremos primero los canales sin bufer y canales con buffer en la @l(#Seccion
   8.4.4).

# *** Section 8.4.1 <> Unbuffered Channels
*** Seccion 8.4.1 <> Canales sin Buffer

#     A send operation on an unbuffered channel blocks the sending goroutine until
#     another goroutine executes a corresponding receive on the same channel, at
#     which point the value is transmitted and both goroutines may
#     continue. Conversely, if the receive operation was attempted first, the
#     receiving goroutine is blocked until another goroutine performs a send on
#     the same channel.
    Una operacion de envio en un canal sin bufer, bloquea la gorutina enviada
    hasta que otra gorutina ejecute una recepcion correspondiente en el mismo
    canal, momento en el que se transmite el valor y ambas gorutinas pueden
    continuar. Por el contrario, si la operacion de recepcion se intento en
    primer lugar, la gorutina de recepcion se bloquea hasta que otra gorutina
    realice un envio en el mismo canal.

#     Communication over an unbuffered channel causes the sending and receiving
#     goroutines to @e(synchronize). Because of this, unbuffered channels are
#     sometimes called @e(synchronous) channels.  When a value is sent on an
#     unbuffered channel, the receipt of the value @e(happens before) the
#     reawakening of the sending goroutine.
    La comunicacion a traves de un canal sin bufer hace que las gorutinas de
    envio y recepcion se sincronicen. Debido a esto, los canales sin bufer a
    veces se llaman canales sincronos. Cuando se envia un valor en un canal sin
    bufer, la recepcion del valor @e(ocurre antes) del re-despertar de la
    gorutina enviada.

#     In discussions of concurrency, when we say @e(x happens before y), we don’t
#     mean merely that @e(x) occurs earlier in time than @e(y); we mean that it is
#     guaranteed to do so and that all its prior effects, such as updates to
#     variables, are complete and that you may rely on them.
    En discusiones de concurrencia, cuando decimos @e(x sucede antes de y), no
    queremos decir simplemente que @e(x) ocurre antes en el tiempo que @e(y);
    queremos decir que esta garantizado para hacerlo y que todos sus efectos
    anteriores, como actualizaciones a las variables, estan completos y que
    usted puede confiar en ellos.

#     When @e(x) neither happens before @e(y) nor after @e(y), we say that @e(x is
#     concurrent with y). This doesn’t mean that @e(x) and @e(y) are necessarily
#     simultaneous, merely that we cannot assume anything about their ordering. As
#     we’ll see in the next chapter, it’s necessary to order certain events during
#     the program’s execution to avoid the problems that arise when two goroutines
#     access the same variable concurrently.
    Cuando @e(x) no ocurre antes de @e(y) ni despues @e(y), decimos que @e(x es
    concurrente con y). Esto no significa que @e(x) e @e(y) son necesariamente
    simultaneas, simplemente que no podemos asumir nada acerca de su ordenacion.
    Como veremos en el siguiente capitulo, es necesario ordenar ciertos eventos
    durante la ejecucion del programa para evitar los problemas que surgen
    cuando dos gorutinas acceden simultaneamente a la misma variable.

#     The client program in @l(#Section 8.3) copies input to the server in its
#     main goroutine, so the client program terminates as soon as the input stream
#     closes, even if the background goroutine is still working. To make the
#     program wait for the background goroutine to complete before exiting, we use
#     a channel to synchronize the two goroutines:
    El programa cliente en la @l(#Seccion 8.3) copia la entrada al servidor en
    su gorutina principal, por lo que el programa cliente termina tan pronto
    como la corriente de entrada se cierra, incluso si la gorutina de fondo
    continua trabajando. Para hacer que el programa espere a que la gorutina de
    fondo se complete antes de salir, usamos un canal para sincronizar las dos
    gorutinas:

#     ..figure > @l(gopl.io/ch8/netcat3/netcat.go<>gopl.io/ch8/netcat3)
    ..figure > @l(gopl.io/ch8/netcat3/netcat.go<>gopl.io/ch8/netcat3)

#       ..src > go
#         func main() {
#           conn, err := net.Dial("tcp", "localhost:8000")
#           if err != nil {
#             log.Fatal(err)
#           }
#           done := make(chan struct{})
#           go func() {
#             io.Copy(os.Stdout, conn) // NOTE: ignoring errors
#             log.Println("done")
#             done <- struct{}{} // signal the main goroutine
#           }()
#           mustCopy(conn, os.Stdin)
#           conn.Close()
#           <-done // wait for background goroutine to finish
#         }
#       < src..
      ..src > go
        func main() {
          conn, err := net.Dial("tcp", "localhost:8000")
          if err != nil {
            log.Fatal(err)
          }
          done := make(chan struct{})
          go func() {
            io.Copy(os.Stdout, conn) // NOTA: ignorando errores
            log.Println("done")
            done <- struct{}{}       // señala la gorutina principal
          }()
          mustCopy(conn, os.Stdin)
          conn.Close()
          <-done // espera a que la gorutina de fondo termine
        }
      < src..


#     When the user closes the standard input stream, @c(mustCopy) returns and the
#     main goroutine calls @c[conn.Close()], closing both halves of the network
#     connection. Closing the write half of the connection causes the server to
#     see an end-of-file condition. Closing the read half causes the background
#     goroutine’s call to @c(io.Copy) to return a @"(read from closed connection)
#     error, which is why we’ve removed the error logging; Exercise 8.3 suggests a
#     better solution. (Notice that the @c(go) statement calls a literal function,
#     a common construction.)
    Cuando el usuario cierra el flujo de entrada estandar, @c(mustCopy) regresa
    y la gorutina principal llama a @c[conn.Close()], cerrando las dos mitades
    de la conexion de red. Cerrar la mitad de escritura de la conexion hace que
    el servidor vea una condicion de fin de archivo. Cerrar la mitad de leectura
    hace que la gorutina de fondo llame a @c(io.Copy) para devolver @"(error de
    lectura por conexion cerrada), por lo que hemos eliminado el registro de
    errores; El ejercicio 8.3 sugiere una mejor solucion. (Observe que la
    sentencia go llama a una funcion literal, una construccion comun.)

#     Before it returns, the background goroutine logs a message, then sends a
#     value on the @c(done) channel. The main goroutine waits until it has
#     received this value before returning. As a result, the program always logs
#     the @c("done") message before exiting.
    Antes de que regrese, la gorutina de fondo registra un mensaje, luego envia
    un valor en el canal @c(done). La gorutina principal espera hasta que haya
    recibido este valor antes de volver. Como resultado, el programa siempre
    registra el mensaje @"(done) antes de salir.

#     Messages sent over channels have two important aspects. Each message has a
#     value, but sometimes the fact of communication and the moment at which it
#     occurs are just as important. We call messages @e(events) when we wish to
#     stress this aspect. When the event carries no additional information, that
#     is, its sole purpose is synchronization, we’ll emphasize this by using a
#     channel whose element type is @c(struct{}), though it’s common to use a
#     channel of @c(bool) or @c(int) for the same purpose since @c(done <- 1) is
#     shorter than @c(done <- struct{}{}).
    Los mensajes enviados a traves de canales tienen dos aspectos importantes.
    Cada mensaje tiene un valor, pero a veces el hecho de la comunicacion y el
    momento en que ocurre son igualmente importantes. Llamamos a los mensajes
    @e(eventos) cuando se quiere hacer hincapie en este aspecto. Cuando el
    evento no contiene informacion adicional, es decir, su unico proposito es la
    sincronizacion, vamos a enfatizar esto mediante el uso de un canal cuyo tipo
    de elemento es @c(struct{}), aunque es comun el uso de un canal de @c(bool)
    o @c(int) para el mismo proposito, ya @c(done <- 1) es mas corto que @c(done
    <- struct{}{}).

#     @b(Exercise 8.3): In @$(netcat3), the interface value @c(conn) has the
#     concrete type @c(*net.TCPConn), which represents a TCP connection. A TCP
#     connection consists of two halves that may be closed independently using
#     its @c(CloseRead) and @c(CloseWrite) methods. Modify the main goroutine of
#     @$(netcat3) to close only the write half of the connection so that the
#     program will continue to print the final echoes from the @$(reverb1)
#     server even after the standard input has been closed.  (Doing this for the
#     @$(reverb2) server is harder; see Exercise 8.4.)
    @b(Ejercicio 8.3): En @$(netcat3), el valor de interfaz @c(conn) tiene el
    tipo concreto @c(*net.TCPConn), lo que representa una conexion TCP. Una
    conexion TCP se compone de dos mitades que pueden ser cerradas de forma
    independiente utilizando sus metedos @c(CloseRead) y
    @c(CloseWrite). Modifica la gorutina principal de @$(netcat3) para cerrar
    solo la mitad de escritura de la conexion para que el programa continue
    imprimiendo los ultimos ecos del servidor @$(reverb1) incluso despues de que
    la entrada estandar ha sido cerrada. (Hacer esto para el servidor
    @$(reverb2) es mas dificil; Consulte el Ejercicio 8.4.)

# *** Section 8.4.2 <> Pipelines
*** Seccion 8.4.2 <> Tuberias

#     Channels can be used to connect goroutines together so that the output of
#     one is the input to another. This is called a @e(pipeline). The program below
#     consists of three goroutines connected by two channels, as shown
#     schematically in Figure 8.1.
    Los canales se pueden utilizar para conectar gorutinas a la vez, de modo que
    la salida de una sea la entrada a otra. Esto se llama una tuberia. El
    programa siguiente consta de tres gorutas conectadas por dos canales, como
    se muestra esquematicamente en la Figura 8.1.

#     ..figure > Figure 8.1. A three-stage pipeline.
    ..figure > Figura 8.1. Una tuberia de tres etapas.

#       ..img  > img/Figure-8.1.jpg
      ..img  > img/Figure-8.1.jpg


#     The first goroutine, @e(counter), generates the integers 0, 1, 2, ..., and
#     sends them over a channel to the second goroutine, @e(squarer), which
#     receives each value, squares it, and sends the result over another channel
#     to the third goroutine, @e(printer), which receives the squared values and
#     prints them. For clarity of this example, we have intentionally chosen very
#     simple functions, though of course they are too computationally trivial to
#     warrant their own goroutines in a realistic program.
    La primer gorutina, @e(counter), genera los numeros enteros 0, 1, 2, ..., y
    los envia sobre un canal a la segunda gorutina, @e(squarer), que recibe
    cada valor, optiene su cuadrado, y envia el resultado a traves de otro canal a
    la tercer gorutina, @e(printer), que recibe los valores al cuadrado y los
    imprime. Para mayor claridad de este ejemplo, hemos elegido intencionalmente
    funciones muy simples, aunque por supuesto son demasiado computacionalmente
    triviales para justificar sus propias gorutinas en un programa realista.

#     ..figure > @l(gopl.io/ch8/pipeline1/main.go<>gopl.io/ch8/pipeline1)
    ..figure > @l(gopl.io/ch8/pipeline1/main.go<>gopl.io/ch8/pipeline1)

#       ..src > go
#         func main() {
#           naturals := make(chan int)
#           squares := make(chan int)
#
#           // Counter
#           go func() {
#             for x := 0; ; x++ {
#               naturals <- x
#             }
#           }()
#
#           // Squarer
#           go func() {
#             for {
#               x := <-naturals
#               squares <- x * x
#             }
#           }()
#
#           // Printer (in main goroutine)
#           for {
#             fmt.Println(<-squares)
#           }
#         }
#       < src..
      ..src > go
        func main() {
          naturals := make(chan int)
          squares := make(chan int)

          // Counter
          go func() {
            for x := 0; ; x++ {
              naturals <- x
            }
          }()

          // Squarer
          go func() {
            for {
              x := <-naturals
              squares <- x * x
            }
          }()

          // Printer (in main goroutine)
          for {
            fmt.Println(<-squares)
          }
        }
      < src..


#     As you might expect, the program prints the infinite series of squares 0, 1,
#     4, 9, and so on.  Pipelines like this may be found in long-running server
#     programs where channels are used for lifelong communication between
#     goroutines containing infinite loops. But what if we want to send only a
#     finite number of values through the pipeline?
    Como es de esperar, el programa imprime la serie infinita de cuadrados 0, 1,
    4, 9 y asi sucesivamente. Pipelines como este se pueden encontrar en los
    programas de servidor de larga duracion donde los canales se utilizan para
    la comunicacion a lo largo de la vida entre gorutinas que contienen bucles
    infinitos. Pero ¿y si queremos enviar solo un numero finito de valores a
    traves de la tuberia?

#     If the sender knows that no further values will ever be sent on a channel,
#     it is useful to communicate this fact to the receiver goroutines so that
#     they can stop waiting. This is accomplished by @e(closing) the channel using
#     the built-in @c(close) function:
    Si el remitente sabe que nunca se enviaran valores adicionales en un canal,
    es util comunicar este hecho a las gorutinas receptor para que puedan dejar
    de esperar. Esto se logra cerrando el cierre utilizando la funcion nativa
    @c(close):

#     ..src > go
#       close(naturals)
#     < src..
    ..src > go
      close(naturals)
    < src..

#     After a channel has been closed, any further send operations on it will
#     panic. After the closed channel has been @e(drained), that is, after the
#     last sent element has been received, all subsequent receive operations will
#     proceed without blocking but will yield a zero value. Closing the
#     @c(naturals) channel above would cause the squarer’s loop to spin as it
#     receives a never-ending stream of zero values, and to send these zeros to
#     the printer.
    Despues de que se haya cerrado un canal, cualquier otra operacion de envio
    se pondra en panico. Despues de que el canal cerrado ha sido drenado, es
    decir, despues de que el ultimo elemento enviado ha sido recibido, todas las
    operaciones subsigientes de recepcion se llevaran a cabo si bloqueo, pero
    daran un valor cero. Cerrar el canal @c(naturals) haria que el bucle de
    cuadrados girara mientras recive un flujo interminable de valores cero que
    recibe un flujo interminable de valores cero, y enviar estos ceros a la
    impresora.

#     There is no way to test directly whether a channel has been closed, but
#     there is a variant of the receive operation that produces two results: the
#     received channel element, plus a boolean value, conventionally called
#     @c(ok), which is @c(true) for a successful receive and @c(false) for a
#     receive on a closed and drained channel. Using this feature, we can modify
#     the squarer’s loop to stop when the @c(naturals) channel is drained and
#     close the @c(squares) channel in turn.
    No hay manera de probar directamente si un canal ha sido cerrado, pero hay
    una variante de la operacion de recepcion que produce dos resultados: el
    elemento de canal recibido, ademas de un valor booleano, convencionalmente
    llamado @c(ok), que es @c(true) para una recepcion exitosa y @c(false) para
    una recepcion en un canal cerrado y drenado. Usando esta caracteristica,
    podemos modificar el bucle de @c(squares) para parar cuando el canal
    @c(naturals) se drene y cerrar el canal @c(squares) a su vez.

#     ..src > go
#       // Squarer
#       go func() {
#         for {
#           x, ok := <-naturals
#           if !ok {
#             break // channel was closed and drained
#           }
#           squares <- x * x
#         }
#         close(squares)
#       }()
#     < src..
    ..src > go
      // Squarer
      go func() {
        for {
          x, ok := <-naturals
          if !ok {
            break // el canal estaba cerrado y drenado
          }
          squares <- x * x
        }
        close(squares)
      }()
    < src..

#     Because the syntax above is clumsy and this pattern is common, the language
#     lets us use a @c(range) loop to iterate over channels too. This is a more
#     convenient syntax for receiving all the values sent on a channel and
#     terminating the loop after the last one.
    Debido a que la sintaxis anterior es torpe y este patron es comun, el
    lenguaje nos permite utilizar un bucle @c(range) para iterar a traves de
    canales tambien. Esta es una sintaxis mas conveniente para recibir todos los
    valores enviados en un canal y finalizar el bucle despues del ultimo.

#     In the pipeline below, when the counter goroutine finishes its loop after
#     100 elements, it closes the @c(naturals) channel, causing the squarer to
#     finish its loop and close the @c(squares) channel.  (In a more complex
#     program, it might make sense for the counter and squarer functions to defer
#     the calls to @c(close) at the outset.) Finally, the main goroutine finishes
#     its loop and the program exits.
    En la tuberia de abajo, cuando la gorutina @c(counter) termina su bucle
    despues de 100 elementos, se cierra el canal @c(naturals), haciendo que
    @c(squarer) termine su bucle y cerrar el canal @c(squares). (En un programa
    mas complejo, podria tener sentido para el contador y las funciones de
    @c(squarer) con llamadas diferidas a @c(close) desde el principio.) Por
    ultimo, la gorutina principal termina su bucle y el programa se cierra.

#     ..figure > @l(gopl.io/ch8/pipeline2/main.go<>gopl.io/ch8/pipeline2)
    ..figure > @l(gopl.io/ch8/pipeline2/main.go<>gopl.io/ch8/pipeline2)

#       ..src > go
#         func main() {
#           naturals := make(chan int)
#           squares := make(chan int)
#
#           // Counter
#           go func() {
#             for x := 0; x < 100; x++ {
#               naturals <- x
#             }
#             close(naturals)
#           }()
#
#           // Squarer
#           go func() {
#             for x := range naturals {
#               squares <- x * x
#             }
#             close(squares)
#           }()
#
#           // Printer (in main goroutine)
#           for x := range squares {
#             fmt.Println(x)
#           }
#         }
#       < src..
      ..src > go
        func main() {
          naturals := make(chan int)
          squares := make(chan int)

          // Counter
          go func() {
            for x := 0; x < 100; x++ {
              naturals <- x
            }
            close(naturals)
          }()

          // Squarer
          go func() {
            for x := range naturals {
              squares <- x * x
            }
            close(squares)
          }()

          // Printer (in main goroutine)
          for x := range squares {
            fmt.Println(x)
          }
        }
      < src..


#     You needn’t close every channel when you’ve finished with it. It’s only
#     necessary to close a channel when it is important to tell the receiving
#     goroutines that all data have been sent. A channel that the garbage
#     collector determines to be unreachable will have its resources reclaimed
#     whether or not it is closed. (Don’t confuse this with the close operation
#     for open files. It @e(is) important to call the @c(Close) method on every
#     file when you’ve finished with it.)
    No es necesario cerrar cada canal cuando haya terminado con el. Solo es
    necesario cerrar un canal cuando es importante decir a los receptores que
    todos los datos han sido enviados. Un canal que el recolector de basura
    determine que no puede ser alcanzado tendra sus recursos recuperados,
    independientemente de si esta o no cerrado. (No hay que confundir esto con
    la operacion de cierre de los archivos abiertos. Es importante llamar al
    metodo @c(Close) en todos los archivos cuando haya terminado con ellos.)

#     Attempting to close an already-closed channel causes a panic, as does
#     closing a nil channel.  Closing channels has another use as a broadcast
#     mechanism, which we’ll cover in @l(#Section 8.9).
    Intentar cerrar un canal ya cerrado provoca un panico, al igual que el
    cierre de un canal nil. El cierre de los canales tiene otro uso como un
    mecanismo de difusion, que cubriremos en la @l(#Seccion 8.9).

# *** Section 8.4.3 <> Unidirectional Channel Types
*** Seccion 8.4.3 <> Tipos de Canal Unidireccional

#     As programs grow, it is natural to break up large functions into smaller
#     pieces. Our previous example used three goroutines, communicating over two
#     channels, which were local variables of @c(main). The program naturally
#     divides into three functions:
    A medida que los programas crecen, es natural dividir grandes funciones en
    piezas mas pequeñas. Nuestro ejemplo anterior utiliza tres gorutinas,
    comunicandoce a traves de dos canales, que eran variables locales de
    @c(main). El programa se divide naturalmente en tres funciones:

#     ..src > go
#       func counter(out chan int)
#       func squarer(out, in chan int)
#       func printer(in chan int)
#     < src..
    ..src > go
      func counter(out chan int)
      func squarer(out, in chan int)
      func printer(in chan int)
    < src..

#     The @c(squarer) function, sitting in the middle of the pipeline, takes two
#     parameters, the input channel and the output channel. Both have the same
#     type, but their intended uses are opposite: @c(in) is only to be received
#     from, and @c(out) is only to be sent to. The names @c(in) and @c(out) convey
#     this intention, but still, nothing prevents @c(squarer) from sending to
#     @c(in) or receiving from @c(out).
    La funcion @c(squarer), situada en el centro de la tuberia, toma dos
    parametros, el canal de entrada y el canal de salida. Ambos tienen el mismo
    tipo, pero sus usos previstos son opuestas: @c(in) es solo para ser recibida
    desde, y @c(out) es solo para enviar a. Los nombres @c(in) y @c(out)
    transmiten esta intencion, pero aun asi, nada impide que @c(squarer) enviar
    enviar a @c(in) o recibir desde @c(out).

#     This arrangement is typical. When a channel is supplied as a function
#     parameter, it is nearly always with the intent that it be used exclusively
#     for sending or exclusively for receiving.
    Esta disposicion es tipica. Cuando un canal se suministra como un parametro
    de funcion, es casi siempre con la intencion de que se utilice
    exclusivamente para enviar o exclusivamente para recibir.

#     To document this intent and prevent misuse, the Go type system provides
#     @e(unidirectional) channel types that expose only one or the other of the
#     send and receive operations. The type @c(chan<- int), a @e(send-only)
#     channel of int, allows sends but not receives. Conversely, the type
#     @c(<-chan int, a @e(receive-only) channel of @c(int), allows receives but
#     not sends. (The position of the @c(<-) arrow relative to the @c(chan)
#     keyword is a mnemonic.) Violations of this discipline are detected at
#     compile time.
    Para documentar esta intencion y evitar el mal uso, el sistema de tipos Go
    proporciano tipos de canale @e(unidireccionales) que exponen solo una u otra
    de las operaciones de envio y recepcion. El tipo @c(chan<- int), un canal
    @e(solo de envio) de @c(int), permite envio pero no recepcion. Por el
    contrario, el tipo @c(<-chan int), @c(<-chan int) un canal solo de recepcion
    de @c(int), permite recivir pero enviar. (La posicion de la flecha @c(<-) en
    relacion con la palabra clave @c(chan) es un mnemonico. Las infracciones de
    esta disciplina se detectan en tiempo de compilacion.

#     Since the @c(close) operation asserts that no more sends will occur on a
#     channel, only the sending goroutine is in a position to call it, and for
#     this reason it is a compile-time error to attempt to close a receive-only
#     channel.
    Dado que la operacion @c(close) asegura que no se produciran mas envios en
    un canal, solo el envio de gorutina esta en una posicion llamarlo, y por
    esta razon es un error en tiempo de compilacion intentar cerrar un canal
    solo de recepcion.

#     Here’s the squaring pipeline once more, this time with unidirectional
#     channel types:
    Esta es la tuberia de @c(squaring) una vez mas, esta vez con canales
    unidireccionales:

#     ..figure > @l(gopl.io/ch8/pipeline3/main.go<>gopl.io/ch8/pipeline3)
    ..figure > @l(gopl.io/ch8/pipeline3/main.go<>gopl.io/ch8/pipeline3)

#       ..src > go
#         func counter(out chan<- int) {
#           for x := 0; x < 100; x++ {
#             out <- x
#           }
#           close(out)
#         }
#
#         func squarer(out chan<- int, in <-chan int) {
#           for v := range in {
#             out <- v * v
#           }
#           close(out)
#         }
#
#         func printer(in <-chan int) {
#           for v := range in {
#             fmt.Println(v)
#           }
#         }
#
#         func main() {
#           naturals := make(chan int)
#           squares := make(chan int)
#
#           go counter(naturals)
#           go squarer(squares, naturals)
#           printer(squares)
#         }
#       < src..
      ..src > go
        func counter(out chan<- int) {
          for x := 0; x < 100; x++ {
            out <- x
          }
          close(out)
        }

        func squarer(out chan<- int, in <-chan int) {
          for v := range in {
            out <- v * v
          }
          close(out)
        }

        func printer(in <-chan int) {
          for v := range in {
            fmt.Println(v)
          }
        }

        func main() {
          naturals := make(chan int)
          squares := make(chan int)

          go counter(naturals)
          go squarer(squares, naturals)
          printer(squares)
        }
      < src..


#     The call @c[counter(naturals)] implicitly converts @c(naturals), a value of
#     type @c(chan int), to the type of the parameter, @c(chan<- int). The
#     @c[printer(squares)] call does a similar implicit conversion to @c(<-chan
#     int). Conversions from bidirectional to unidirectional channel types are
#     permitted in any assignment. There is no going back, however: once you have
#     a value of a unidirectional type such as @c(chan<- int), there is no way to
#     obtain from it a value of type @c(chan int) that refers to the same channel
#     data structure.
    La llamada @c[counter(naturals)] convierte implicitamente @c(naturals), en
    un valor de tipo @c(chan int), con el tipo del parametro, @c(chan<- int). La
    llamada @c[printer(squares)] hace una conversion implicita a @c(<-chan int).
    Las conversiones de tipos de canal bidireccionales a unidireccionales se
    permiten en cualquier asignacion. Sin embargo, no hay vuelta atras: una vez
    que tenga un valor de un tipo unidireccional como @c(chan<- int), no hay
    forma de obtener de el un valor de tipo @c(chan int) que se refiera a la
    misma estructura de datos del canal..

# *** Section 8.4.4 <> Buffered Channels
*** Seccion 8.4.4 <> Buffered Channels

#     A buffered channel has a queue of elements. The queue’s maximum size is
#     determined when it is created, by the capacity argument to @c(make). The
#     statement below creates a buffered channel capable of holding three
#     @c(string) values. Figure 8.2 is a graphical representation of @c(ch) and
#     the channel to which it refers.
    un canal almacenado en bufer tiene una cola de elementos. El tamaño maximo
    de la cola se determina cuando se crea, por el argumento de capacidad de
    @c(make). La declaracion siguiente crea un canal de buffer capaz de mantener
    tres valores @c(string). La Figura 8.2 es una representacion grafica de
    @c(ch) y el canal al que se refiere.

#     ..src > go
#       ch = make(chan string, 3)
#     < src..
    ..src > go
      ch = make(chan string, 3)
    < src..

#     ..figure > Figure 8.2. An empty buffered channel.
    ..figure > Figura 8.2. Un canal de buffer vacio.

#       ..img  > img/Figure-8.2.jpg
      ..img  > img/Figure-8.2.jpg


#     A send operation on a buffered channel inserts an element at the back of the
#     queue, and a receive operation removes an element from the front. If the
#     channel is full, the send operation blocks its goroutine until space is made
#     available by another goroutine’s receive. Conversely, if the channel is
#     empty, a receive operation blocks until a value is sent by another
#     goroutine.
    Una operacion de envio en un canal de buffer inserta un elemento
    en la parte posterior de la cola, y una operacion de recepcion elimina un
    elemento del frente. Si el canal esta lleno, la operacion de envio bloquea
    su canal hasta que el espacio sea puesto a disposicion por otro receptor de
    gorutina. Por el contrario, si el canal esta vacio, una operacion de
    recepcion se bloquea hasta que un valor es enviado por otro canal.

#     We can send up to three values on this channel without the goroutine
#     blocking:
    Podemos enviar hasta tres valores en este canal sin bloquear la gorutina:

#     ..src > go
#       ch <- "A"
#       ch <- "B"
#       ch <- "C"
#     < src..
    ..src > go
      ch <- "A"
      ch <- "B"
      ch <- "C"
    < src..

#     At this point, the channel is full (Figure 8.3), and a fourth send statement
#     would block.
    En este punto, el canal esta lleno (Figura 8.3), y una cuarta sentencia de
    envio lo bloquearia.

#     ..figure > Figure 8.3. A full buffered channel.
    ..figure > Figura 8.3. Un canal completo con bufer.

#       ..img  > img/Figure-8.3.jpg
      ..img  > img/Figure-8.3.jpg

#     If we receive one value,
    Si recibimos un valor,

#     ..src > go
#       fmt.Println(<-ch) // "A"
#     < src..
    ..src > go
      fmt.Println(<-ch) // "A"
    < src..

#     the channel is neither full nor empty (Figure 8.4), so either a send
#     operation or a receive operation could proceed without blocking. In this
#     way, the channel’s buffer decouples the sending and receiving goroutines.
    El canal no esta lleno ni vacio (Figura 8.4), de modo que una operacion de
    envio o de recepcion podria continuar sin bloquear. De esta manera, el bufer
    del canal desacopla los canales de envio y recepcion de gorutinas.

#     ..figure > Figure 8.4. A partially full buffered channel.
    ..figure > Figura 8.4. Un canal parcialmente almacenado en buffer.

#       ..img  > img/Figure-8.3.jpg
      ..img  > img/Figure-8.3.jpg

#     In the unlikely event that a program needs to know the channel’s buffer
#     capacity, it can be obtained by calling the built-in @c(cap) function:
    En el caso improbable de que un programa necesita saber la capacidad de
    buffer del canal, se puede obtener llamando a la funcion nawiva @c(cap):

#     ..src > go
#       fmt.Println(cap(ch)) // "3"
#     < src..
    ..src > go
      fmt.Println(cap(ch)) // "3"
    < src..

#     When applied to a channel, the built-in @c(len) function returns the number
#     of elements currently buffered. Since in a concurrent program this
#     information is likely to be stale as soon as it is retrieved, its value is
#     limited, but it could conceivably be useful during fault diagnosis or
#     performance optimization.
    Cuando se aplica a un canal, la funcion nativa @c(len) devuelve el numero de
    elementos actualmente almacenados en el buffer. Ya que en un programa
    concurrente esta informacion es probable que sea obsoleta tan pronto como se
    recupera, su valor es limitado, pero podria ser util durante el diagnostico
    de fallos u optimizacion de rendimiento.

#     ..src > go
#       fmt.Println(len(ch)) // "2"
#     < src..
    ..src > go
      fmt.Println(len(ch)) // "2"
    < src..

#     After two more receive operations the channel is empty again, and a fourth
#     would block:
    Despues de dos operaciones de recepcion mas, el canal esta vacio de nuevo, y
    un cuarto podria bloquearlo:

#     ..src > go
#       fmt.Println(<-ch) // "B"
#       fmt.Println(<-ch) // "C"
#     < src..
    ..src > go
      fmt.Println(<-ch) // "B"
      fmt.Println(<-ch) // "C"
    < src..

#     In this example, the send and receive operations were all performed by the
#     same goroutine, but in real programs they are usually executed by different
#     goroutines. Novices are sometimes tempted to use buffered channels within a
#     single goroutine as a queue, lured by their pleasingly simple syntax, but
#     this is a mistake. Channels are deeply connected to goroutine scheduling,
#     and without another goroutine receiving from the channel, a sender—and
#     perhaps the whole program—risks becoming blocked forever. If all you need is
#     a simple queue, make one using a slice.
    En este ejemplo, las operaciones de envio y recepcion fueron todas
    realizadas por la misma gorutina, pero en programas reales generalmente son
    ejecutadas por gorutinas diferentes. Los principiantes a veces se sienten
    tentados a usar canales de buffer dentro de una unica gorutina como una
    cola, atraidos por su sintaxis agradablemente sencilla, pero esto es un
    error. Los canales estan profundamente conectados con la programacion de las
    gorutas, y sin que otra gorutina que recibe del canal, un remitente –y tal
    vez todo el programa–corre el riesgo de quedar bloqueado para siempre. Si
    todo lo que necesita es una simple cola, haga una utilizando un slice.

#     The example below shows an application of a buffered channel. It makes
#     parallel requests to three @c(mirrors), that is, equivalent but
#     geographically distributed servers. It sends their responses over a buffered
#     channel, then receives and returns only the first response, which is the
#     quickest one to arrive. Thus @c(mirroredQuery) returns a result even before
#     the two slower servers have responded. (Incidentally, it’s quite normal for
#     several goroutines to send values to the same channel concurrently, as in
#     this example, or to receive from the same channel.)
    El siguiente ejemplo muestra una aplicacion de un canal con bufer. Se
    realiza solicitudes paralelas a tres @c(mirrors), es decir, servidores
    equivalente pero geograficamente distribuidos. Envia sus respuestas a traves
    de un canal con bufer, luego recibe y devuelve solo la primer respuesta,
    que es la mas rapida en llegar. Por lo tanto @c(mirroredQuery) devuelve un
    resultado incluso antes de que los dos servidores mas lentos han
    respondido. (Por cierto, es normal que varias gorutinas envien valores al
    mismo canal de forma concurrente, como en este ejemplo, o para recibir del
    mismo canal).

#     ..src > go
#       func mirroredQuery() string {
#         responses := make(chan string, 3)
#         go func() { responses <- request("asia.gopl.io") }()
#         go func() { responses <- request("europe.gopl.io") }()
#         go func() { responses <- request("americas.gopl.io") }()
#         return <-responses // return the quickest response
#       }
#
#       func request(hostname string) (response string) { /* ... */ }
#     < src..
    ..src > go
      func mirroredQuery() string {
        responses := make(chan string, 3)
        go func() { responses <- request("asia.gopl.io") }()
        go func() { responses <- request("europe.gopl.io") }()
        go func() { responses <- request("americas.gopl.io") }()
        return <-responses // devuelve la respuesta mas rapida
      }

      func request(hostname string) (response string) { /* ... */ }
    < src..

#     Had we used an unbuffered channel, the two slower goroutines would have
#     gotten stuck trying to send their responses on a channel from which no
#     goroutine will ever receive. This situation, called a @e(goroutine leak),
#     would be a bug. Unlike garbage variables, leaked goroutines are not
#     automatically collected, so it is important to make sure that goroutines
#     terminate themselves when no longer needed.
    Si hubieramos utilizado un canal sin bufer, las dos gorutinas mas lentos se
    habrian atascado tratando de enviar sus respuestas en un canal del cual
    ninguna gorutina jamas recibira. Esta situacion, denominada una @e(fuga de
    gorutina), seria un error. A diferencia de las variables basura, las
    gorutinas filtradas no se recogen automaticamente, por lo que es importante
    asegurarse de que las gorutinas terminan cuando ya no se necesitan.

#     The choice between unbuffered and buffered channels, and the choice of a
#     buffered channel’s capacity, may both affect the correctness of a
#     program. Unbuffered channels give stronger synchronization guarantees
#     because every send operation is synchronized with its corresponding receive;
#     with buffered channels, these operations are decoupled. Also, when we know
#     an upper bound on the number of values that will be sent on a channel, it’s
#     not unusual to create a buffered channel of that size and perform all the
#     sends before the first value is received. Failure to allocate sufficient
#     buffer capacity would cause the program to deadlock.
    La eleccion entre canales con o sin bufer, y la eleccion de la capacidad de
    un canal con bufer, pueden afectar a la correccion de un programa. Los
    canales sin bufer proporcionan mayores garantias de sincronizacion porque
    cada operacion de envio se sincroniza con su recepcion correspondiente; Con
    canales con buffer, estas operaciones se desacoplan. Ademas, cuando
    conocemos un limite superior en el numero de valores que se enviaran en un
    canal, no es inusual crear un canal con buffer de ese tamaño y realizar
    todos los envios antes de que se reciba el primer valor. Si no se asigna
    suficiente capacidad de buffer, el programa se bloqueara.

#     Channel buffering may also affect program performance. Imagine three cooks
#     in a cake shop, one baking, one icing, and one inscribing each cake before
#     passing it on to the next cook in the assembly line. In a kitchen with
#     little space, each cook that has finished a cake must wait for the next cook
#     to become ready to accept it; this rendezvous is analogous to communication
#     over an unbuffered channel.
    Los canales con buffer tambien puede afectar el rendimiento del programa.
    Imaginese tres cocineros en una pasteleria, una horno, y un frigorifico y
    otra decorando cada pastel antes de pasarlo al siguiente cocinero en la
    linea de montaje. En una cocina con poco espacio, cada cocinero que ha
    terminado un pastel debe esperar a que el cocinero siguiente este listo para
    aceptarlo; Esta cita es analoga a la comunicacion a traves de un canal sin
    bufer.

#     If there is space for one cake between each cook, a cook may place a
#     finished cake there and immediately start work on the next; this is
#     analogous to a buffered channel with capacity 1. So long as the cooks work
#     at about the same rate on average, most of these handovers proceed quickly,
#     smoothing out transient differences in their respective rates. More space
#     between cooks—larger buffers—can smooth out bigger transient variations in
#     their rates without stalling the assembly line, such as happens when one
#     cook takes a short break, then later rushes to catch up.
    Si hay espacio para un pastel entre cada cocinero, un cocinero puede colocar
    un pastel terminado alli e inmediatamente comenzar a trabajar en el
    siguiente; Esto es analogo a un canal con buffer con capacidad 1. Mientras
    los cocineros trabajen aproximadamente a la misma velocidad en promedio, la
    mayoria de estos traspasos proceden rapidamente, suavizando las diferencias
    transitorias en sus respectivas velocidades. Mas espacio entre los
    cocineros–buffers mas grandes–puede suavizar las variaciones transitorias
    mas grandes en sus tarifas sin parar la linea de ensamblaje, tal como sucede
    cuando un cocinero toma una pequeño descanso, luego se apresura para
    alcanzar a los demas.

#     On the other hand, if an earlier stage of the assembly line is consistently
#     faster than the following stage, the buffer between them will spend most of
#     its time full. Conversely, if the later stage is faster, the buffer will
#     usually be empty. A buffer provides no benefit in this case.
    Por otro lado, si una etapa anterior de la linea de montaje es
    consistentemente mas rapida que la siguiente etapa, el buffer entre ellos
    pasara la mayor parte de su tiempo lleno. Por el contrario, si la etapa
    posterior es mas rapida, el bufer estara normalmente vacio. Un buffer no
    proporciona ningun beneficio en este caso.

#     The assembly line metaphor is a useful one for channels and goroutines. For
#     example, if the second stage is more elaborate, a single cook may not be
#     able to keep up with the supply from the first cook or meet the demand from
#     the third. To solve the problem, we could hire another cook to help the
#     second, performing the same task but working independently. This is
#     analogous to creating another goroutine communicating over the same
#     channels.
    La metafora de la linea de montaje es util para los canales y gorutinas. Por
    ejemplo, si la segunda etapa es mas elaborada, un solo cocinero puede no ser
    capaz de mantenerse al dia con el suministro del primer cocinero o
    satisfacer la demanda del tercero. Para resolver el problema, podriamos
    contratar a otro cocinero para ayudar al segundo, realizando la misma tarea
    pero trabajando independientemente. Esto es analogo a crear otra gorutina
    que se comunica sobre los mismos canales.

#     We don’t have space to show it here, but the @c(gopl.io/ch8/cake) package
#     simulates this cake shop, with several parameters you can vary. It includes
#     benchmarks (@l(#Section 11.4<>§11.4)) for a few of the scenarios described
#     above.
    No tenemos espacio para mostralo aqui, pero el paquete @c(gopl.io/ch8/cake)
    simula esta pasteleria, con varios parametros que se pueden variar. Incluye
    comparativas (@l(#Seccion 11.4<>§11.4)) para algunos de los escenarios
    descritos anteriormente.

# ** Section 8.5 <> Looping in Parallel
** Seccion 8.5 <> Bucle en Paralelo

#    In this section, we’ll explore some common concurrency patterns for executing
#    all the iterations of a loop in parallel. We’ll consider the problem of
#    producing thumbnail-size images from a set of full-size ones. The
#    @c(gopl.io/ch8/thumbnail) package provides an @c(ImageFile) function that can
#    scale a single image. We won’t show its implementation but it can be
#    downloaded from @l(http://www.gopl.io/<>gopl.io).
   En esta seccion, exploraremos algunos patrones de concurrencia comunes para
   ejecutar todas las iteraciones de un bucle en paralelo. Consideraremos el
   problema de producir imagenes en miniatura de un conjunto de imagenes de
   tamaño completo. El paquete @c(gopl.io/ch8/thumbnail) proporciona un funcion
   @c(ImageFile) que puede escalar una sola imagen. No vamos a mostrar su
   implementacion, pero se puede descargar desde @l(http://www.gopl.io/<>gopl.io).

#    ..figure > @l(gopl.io/ch8/thumbnail/thumbnail_test.go<>gopl.io/ch8/thumbnail)
   ..figure > @l(gopl.io/ch8/thumbnail/thumbnail_test.go<>gopl.io/ch8/thumbnail)

#      ..src > go
#        // ImageFile reads an image from infile and writes
#        // a thumbnail-size version of it in the same directory.
#        // It returns the generated file name, e.g. "foo.thumb.jpeg".
#        func ImageFile(infile string) (string, error)
#      < src..
     ..src > go
       // ImageFile lee una imagen de infile y escribe
       // una version en miniatura de la misma en el mismo directorio.
       // Devuelve el nombre del archivo generado, por ejemplo. "foo.thumb.jpeg".
       func ImageFile(infile string) (string, error)
     < src..


#    The program below loops over a list of image file names and produces a
#    thumbnail for each one:
   El siguiente programa realiza un bucle sobre una lista de nombres de archivo
   de imagen y produce una miniatura para cada uno:

#    ..figure > @l(gopl.io/ch8/thumbnail/thumbnail_test.go<>gopl.io/ch8/thumbnail)
   ..figure > @l(gopl.io/ch8/thumbnail/thumbnail_test.go<>gopl.io/ch8/thumbnail)

#      ..src > go
#        // makeThumbnails makes thumbnails of the specified files.
#        func makeThumbnails(filenames []string) {
#          for _, f := range filenames {
#            if _, err := thumbnail.ImageFile(f); err != nil {
#              log.Println(err)
#            }
#          }
#        }
#      < src..
     ..src > go
       // makeThumbnails crea miniaturas de los archivos especificados.
       func makeThumbnails(filenames []string) {
         for _, f := range filenames {
           if _, err := thumbnail.ImageFile(f); err != nil {
             log.Println(err)
           }
         }
       }
     < src..


#    Obviously the order in which we process the files doesn’t matter, since each
#    scaling operation is independent of all the others. Problems like this that
#    consist entirely of subproblems that are completely independent of each other
#    are described as @e(embarrassingly parallel). Embarrassingly parallel
#    problems are the easiest kind to implement concurrently and enjoy performance
#    that scales linearly with the amount of parallelism.
   Obviamente, el orden en que procesamos los archivos no importa, ya que cada
   operacion de escalado es independiente de todas los demas. Problemas como
   este que consisten enteramente de subproblemas que son completamente
   independientes entre si se describen como @e(vergonzosamente paralelos).  Los
   problemas vergonzosamente paralelos son el tipo mas facil para implementar
   concurrencia y disfrutar de un rendimiento que linealmente escala con la
   cantidad de paralelismo.

#    Let’s execute all these operations in parallel, thereby hiding the latency of
#    the file I/O and using multiple CPUs for the image-scaling computations. Our
#    first attempt at a concurrent version just adds a @c(go) keyword. We’ll
#    ignore errors for now and address them later.
   Vamos a ejecutar todas estas operaciones en paralelo, ocultando asi la
   latencia de la E/S de archivos y el uso de varias CPU para los calculos de
   escalado de imagen. Nuestro primer intento de una version concurrente solo
   añade una palabras clave @c(go). Ignoraremos los errores por ahora y los
   abordaremos mas adelante.

#    ..src > go
#      // NOTE: incorrect!
#      func makeThumbnails2(filenames []string) {
#        for _, f := range filenames {
#          go thumbnail.ImageFile(f) // NOTE: ignoring errors
#        }
#      }
#    < src..
   ..src > go
     // NOTA: incorrecto!
     func makeThumbnails2(filenames []string) {
       for _, f := range filenames {
         go thumbnail.ImageFile(f) // NOTA: ignorando errores
       }
     }
   < src..

#    This version runs really fast—too fast, in fact, since it takes less time
#    than the original, even when the slice of file names contains only a single
#    element. If there’s no parallelism, how can the concurrent version possibly
#    run faster? The answer is that @c(makeThumbnails) returns before it has
#    finished doing what it was supposed to do. It starts all the goroutines, one
#    per file name, but doesn’t wait for them to finish.
   Esta version se ejecuta realmente rapido–demasiado rapido, de hecho, tarda
   menos tiempo que el original, incluso cuando la porcion de nombres de archivo
   contiene solo un elemento. Si no hay paralelismo, ¿como puede la version
   concurrente posiblemente correr mas rapido? La respuesta es que
   @c(makeThumbnails) regresa antes de que haya terminado de hacer lo que tenia
   que hacer. Comienza todas las gorutinas, una por cada nombre de archivo, pero
   no espera a que terminen.

#    There is no direct way to wait until a goroutine has finished, but we can
#    change the inner goroutine to report its completion to the outer goroutine by
#    sending an event on a shared channel. Since we know that there are exactly
#    @c[len(filenames)] inner goroutines, the outer goroutine need only count that
#    many events before it returns:
   No hay manera directa de esperar hasta que una gorutina haya terminado, pero
   podemos cambiar la gorutina interior para reportar su terminacion a la gorutina
   exterior enviando un acontecimiento en un canal compartido. Dado que sabemos
   que hay exactamente @c[len(filenames)] gorutinas interiores, la gorutina exterior
   solo necesita contar estos eventos antes de que regresar:

#    ..src > go
#      // makeThumbnails3 makes thumbnails of the specified files in parallel.
#      func makeThumbnails3(filenames []string) {
#        ch := make(chan struct{})
#        for _, f := range filenames {
#          go func(f string) {
#            thumbnail.ImageFile(f) // NOTE: ignoring errors
#            ch <- struct{}{}
#          }(f)
#        }
#
#        // Wait for goroutines to complete.
#        for range filenames {
#          <-ch
#        }
#      }
#    < src..
   ..src > go
     // makeThumbnails3 crea miniaturas de los archivos especificados en paralelo.
     func makeThumbnails3(filenames []string) {
       ch := make(chan struct{})
       for _, f := range filenames {
         go func(f string) {
           thumbnail.ImageFile(f) // NOTA: ignorando errores
           ch <- struct{}{}
         }(f)
       }

       // Esperar a que los gourutines terminen
       for range filenames {
         <-ch
       }
     }
   < src..

#    Notice that we passed the value of @c(f) as an explicit argument to the
#    literal function instead of using the declaration of @c(f) from the enclosing
#    @c(for) loop:
   Notese que pasamos el valor de f como argumento explicito a la funcion
   literal en lugar de utilizar la declaracion de @c(f) envolviendo el bucle
   @c(for):

#    ..src > go
#      for _, f := range filenames {
#        go func() {
#          thumbnail.ImageFile(f) // NOTE: incorrect!
#          // ...
#        }()
#      }
#    < src..
   ..src > go
     for _, f := range filenames {
       go func() {
         thumbnail.ImageFile(f) // NOTA: incorrecto!
         // ...
       }()
     }
   < src..

#    Recall the problem of loop variable capture inside an anonymous function,
#    described in @l(#Section 5.6.1). Above, the single variable @c(f) is shared
#    by all the anonymous function values and updated by successive loop
#    iterations. By the time the new goroutines start executing the literal
#    function, the @c(for) loop may have updated @c(f) and started another
#    iteration or (more likely) finished entirely, so when these goroutines read
#    the value of @c(f), they all observe it to have the value of the final
#    element of the slice. By adding an explicit parameter, we ensure that we use
#    the value of @c(f) that is current when the @c(go) statement is executed.
   Recordemos que el problema de la capturar la variable del bucle dentro de una
   funcion anonima, se describe en la @l(#Seccion 5.6.1). Arriba, la unica
   variable @c(f) es compartida por todos los valores de la funcion anonima y
   actualizado por sucesivas iteraciones del bucle. Por el momento las nuevas
   gorutinas comenzar a ejecutar la funcion literal, el bucle @c(for) puede
   tener actualizada @c(f) e iniciar otra iteracion o (mas probablemente)
   terminado en su totalidad, por lo que cuando estas gorutinas leen el valor de
   @c(f), todas ellas observan tener el valor del elemento final del
   slice. Mediante la adicion de un parametro explicito, nos aseguramos de que
   se utiliza el valor de @c(f) actual cuando se ejecuta la sentencia @c(go).

#    What if we want to return values from each worker goroutine to the main one?
#    If the call to @c(thumbnail.ImageFile) fails to create a file, it returns an
#    error. The next version of @c(makeThumbnails) returns the first error it
#    receives from any of the scaling operations:
   ¿Que pasa si queremos devolver los valores de cada trabajador a la principal?
   Si la llamada a @c(thumbnail.ImageFile) no puede crear un archivo, se devuelve un
   error. La proxima version de @c(makeThumbnails) devuelve el primer error que
   recibe de cualquiera de las operaciones de escalado:

#    ..src > go
#      // makeThumbnails4 makes thumbnails for the specified files in parallel.
#      // It returns an error if any step failed.
#      func makeThumbnails4(filenames []string) error {
#        errors := make(chan error)
#        for _, f := range filenames {
#          go func(f string) {
#            _, err := thumbnail.ImageFile(f)
#            errors <- err
#          }(f)
#        }
#
#        for range filenames {
#          if err := <-errors; err != nil {
#            return err // NOTE: incorrect: goroutine leak!
#          }
#        }
#
#        return nil
#      }
#    < src..
   ..src > go
     // makeThumbnails4 crea miniaturas de los archivos especificados en paralelo.
     // Devuelve un error si ocurrio alguno.
     func makeThumbnails4(filenames []string) error {
       errors := make(chan error)
       for _, f := range filenames {
         go func(f string) {
           _, err := thumbnail.ImageFile(f)
           errors <- err
         }(f)
       }

       for range filenames {
         if err := <-errors; err != nil {
           return err // NOTA: incorrecto: fuga de gorutina!
         }
       }

       return nil
     }
   < src..

#    This function has a subtle bug. When it encounters the first non-nil error,
#    it returns the error to the caller, leaving no goroutine draining the
#    @c(errors) channel. Each remaining worker goroutine will block forever when
#    it tries to send a value on that channel, and will never terminate. This
#    situation, a goroutine leak (@l(#Section 8.4.4<>§8.4.4)), may cause the whole
#    program to get stuck or to run out of memory.
   Esta funcion tiene un error sutil. Cuando encuentra el primer error no nil,
   se devuelve el error al llamador, sin dejar drenado la gorutina de canal
   @c(errors). Cada gorutina trabajador restante se bloqueara para siempre
   cuando intente enviar un valor en ese canal, y nunca terminara. Esta
   situacion, una fuga de gorutina (@l(#Seccion 8.4.4<>§8.4.4)), puede hacer que
   todo el programa se atasque o se quede sin memoria.

#    The simplest solution is to use a buffered channel with sufficient capacity
#    that no worker goroutine will block when it sends a message. (An alternative
#    solution is to create another goroutine to drain the channel while the main
#    goroutine returns the first error without delay.)
   La solucion mas sencilla es utilizar un canal con capacidad suficiente que
   ningun trabajador bloqueara cuando envie un mensaje. (Una solucion
   alternativa es crear otro canal para drenar el canal, mientras que la
   gorutina principal devuelve el primer error sin demora).

#    The next version of @c(makeThumbnails) uses a buffered channel to return the
#    names of the generated image files along with any errors.
   La siguiente version de @c(makeThumbnails) utiliza un canal tamponada para devolver
   los nombres de los archivos de imagen generados junto con cualquier error.

#    ..src > go
#      // makeThumbnails5 makes thumbnails for the specified files in parallel.
#      // It returns the generated file names in an arbitrary order,
#      // or an error if any step failed.
#      func makeThumbnails5(filenames []string) (thumbfiles []string, err error) {
#        type item struct {
#          thumbfile string
#          err       error
#        }
#
#        ch := make(chan item, len(filenames))
#        for _, f := range filenames {
#          go func(f string) {
#            var it item
#            it.thumbfile, it.err = thumbnail.ImageFile(f)
#            ch <- it
#          }(f)
#        }
#
#        for range filenames {
#          it := <-ch
#          if it.err != nil {
#            return nil, it.err
#          }
#          thumbfiles = append(thumbfiles, it.thumbfile)
#        }
#
#        return thumbfiles, nil
#      }
#    < src..
   ..src > go
     // makeThumbnails5 crea miniaturas de los archivos especificados en paralelo.
     // Devuelve los errores de archivo generados en un orden arbitrario,
     // o un error si algun paso falla.
     func makeThumbnails5(filenames []string) (thumbfiles []string, err error) {
       type item struct {
         thumbfile string
         err       error
       }

       ch := make(chan item, len(filenames))
       for _, f := range filenames {
         go func(f string) {
           var it item
           it.thumbfile, it.err = thumbnail.ImageFile(f)
           ch <- it
         }(f)
       }

       for range filenames {
         it := <-ch
         if it.err != nil {
           return nil, it.err
         }
         thumbfiles = append(thumbfiles, it.thumbfile)
       }

       return thumbfiles, nil
     }
   < src..

#    Our final version of @c(makeThumbnails), below, returns the total number of
#    bytes occupied by the new files. Unlike the previous versions, however, it
#    receives the file names not as a slice but over a channel of strings, so we
#    cannot predict the number of loop iterations.
   Nuestra version final de @c(makeThumbnails), a continuacion, devuelve el
   numero total de bytes ocupados por los nuevos archivos. A diferencia de las
   versiones anteriores, sin embargo, recibe los nombres de archivo no como un
   slice sino a traves de un canal de cadenas, por lo que no podemos predecir el
   numero de iteraciones del bucle.

#    To know when the last goroutine has finished (which may not be the last one
#    to start), we need to increment a counter before each goroutine starts and
#    decrement it as each goroutine finishes. This demands a special kind of
#    counter, one that can be safely manipulated from multiple goroutines and that
#    provides a way to wait until it becomes zero. This counter type is known as
#    @c(sync.WaitGroup), and the code below shows how to use it:
   Para saber cuando ha terminado la ultima gorutina (que puede no ser el ultimo
   en comenzar), necesitamos incrementar un contador antes de que cada gorutina
   comience y decrementarlo cuando cada gorutina termine. Esto exige un tipo
   especial de contador, que se puede manipular con seguridad desde multiples
   gorutinas y que proporciona una manera de esperar hasta que se convierte en
   cero. Este tipo de contador se conoce como @c(sync.WaitGroup), y el codigo
   siguiente muestra como usarlo:

#    ..src > go
#      // makeThumbnails6 makes thumbnails for each file received from the channel.
#      // It returns the number of bytes occupied by the files it creates.
#      func makeThumbnails6(filenames <-chan string) int64 {
#        sizes := make(chan int64)
#        var wg sync.WaitGroup // number of working goroutines
#        for f := range filenames {
#          wg.Add(1)
#          // worker
#          go func(f string) {
#            defer wg.Done()
#            thumb, err := thumbnail.ImageFile(f)
#            if err != nil {
#              log.Println(err)
#              return
#            }
#            info, _ := os.Stat(thumb) // OK to ignore error
#            sizes <- info.Size()
#          }(f)
#        }
#
#        // closer
#        go func() {
#          wg.Wait()
#          close(sizes)
#        }()
#
#        var total int64
#        for size := range sizes {
#          total += size
#        }
#
#        return total
#      }
#    < src..
   ..src > go
     // makeThumbnails6 crea miniaturas de los archivos especificados en paralelo.
     // Devuelve el numero de bytes ocupados por los archives que crea.
     func makeThumbnails6(filenames <-chan string) int64 {
       sizes := make(chan int64)
       var wg sync.WaitGroup // numero de gorutinas de trabajo
       for f := range filenames {
         wg.Add(1)
         // trabajador
         go func(f string) {
           defer wg.Done()
           thumb, err := thumbnail.ImageFile(f)
           if err != nil {
             log.Println(err)
             return
           }
           info, _ := os.Stat(thumb) // OK para ignorar el error
           sizes <- info.Size()
         }(f)
       }

       // closer
       go func() {
         wg.Wait()
         close(sizes)
       }()

       var total int64
       for size := range sizes {
         total += size
       }

       return total
     }
   < src..

#    Note the asymmetry in the @c(Add) and @c(Done) methods. @c(Add), which
#    increments the counter, must be called before the worker goroutine starts,
#    not within it; otherwise we would not be sure that the @c(Add) @e(happens
#    before) the @"(closer) goroutine calls @c(Wait). Also, @c(Add) takes a
#    parameter, but @c(Done) does not; it’s equivalent to @c[Add(-1)]. We use
#    @c(defer) to ensure that the counter is decremented even in the error case. The
#    structure of the code above is a common and idiomatic pattern for looping in
#    parallel when we don’t know the number of iterations.
   Observe la asimetria en los metodos @c(Add) y @c(Done). @c(Add), que
   incrementa el contador, debe ser llamado antes de que el trabajador empiece
   la gorutina, no dentro de ella; de lo contrario no estariamos seguros de que
   el @c(Add) @e(ocurre antes) antes de que la gorutina @"(close) llame a
   @c(Wait). Ademas, @c(Add) toma un parametro, pero @c(Done) no; que es
   equivalente a @c[Add(-1)]. Utilizamos @c(defer) para asegurar que el contador
   se decrementa incluso en el caso de error. La estructura del codigo anterior
   es un patron comun e idiomatico para realizar bucle en paralelo cuando no
   conocemos el numero de iteraciones.

#    The @c(sizes) channel carries each file size back to the main goroutine,
#    which receives them using a @c(range) loop and computes the sum. Observe how
#    we create a closer goroutine that waits for the workers to finish before
#    closing the @c(sizes) channel. These two operations, wait and close, must be
#    concurrent with the loop over @c(sizes). Consider the alternatives: if the
#    wait operation were placed in the main goroutine before the loop, it would
#    never end, and if placed after the loop, it would be unreachable since with
#    nothing closing the channel, the loop would never terminate.
   El canal @c(sizes) lleva cada tamaño de archivo de nuevo a la gorutina
   principal, que recibe de ellos usando un range de bucle y calcula la suma.
   Observamos como creamos un gorutina mas cerca que espera a los trabajadores
   para terminar antes de cerrar el canal @c(sizes). Estas dos operaciones,
   @"(wait) y @"(close), deben ser concurrentes con el bucle sobre @c(sizes).
   Consideremos las alternativas: si la operacion de espera se coloca en la
   goruta principal antes del bucle, nunca terminaria, y si se colocaba despues
   del bucle, seria inalcanzable ya que sin nada cerrando el canal, el bucle
   nunca terminaria.

#    Figure 8.5 illustrates the sequence of events in the @c(makeThumbnails6)
#    function. The vertical lines represent goroutines. The thin segments indicate
#    sleep, the thick segments activity. The diagonal arrows indicate events that
#    synchronize one goroutine with another. Time flows down. Notice how the main
#    goroutine spends most of its time in the @c(range) loop asleep, waiting for a
#    worker to send a value or the closer to close the channel.
   La Figura 8.5 ilustra la secuencia de eventos en la funcion
   @c(makeThumbnails6). Las lineas verticales representan gorutinas. Los
   segmentos delgados indican el sueño, los segmentos gruesos actividad. Las
   flechas diagonales indican eventos que sincronizan una gorutina con otra. El
   tiempo fluye hacia abajo. Notese como la gorutina principal pasa la mayor
   parte de su tiempo en el range de bucle dormido, esperando a que un
   trabajador para enviar un valor o el mas cerca para cerrar el canal.

#    ..figure > Figure 8.5. The sequence of events in @c(makeThumbnails6).
   ..figure > Figura 8.5. La secuencia de eventos en @c(makeThumbnails6).

#      ..img  > img/Figure-8.5.jpg
     ..img  > img/Figure-8.5.jpg


#    @b(Exercise 8.4): Modify the @$(reverb2) server to use a @c(sync.WaitGroup)
#    per connection to count the number of active @c(echo) goroutines. When it
#    falls to zero, close the write half of the TCP connection as described in
#    Exercise 8.3. Verify that your modified @$(netcat3) client from that exercise
#    waits for the final echoes of multiple concurrent shouts, even after the
#    standard input has been closed.
   @b(Ejercicio 8.4): Modificar el servidor @$(reverb2) para utilizar un
   @c(sync.WaitGroup) por conexion para contar el numero de gorutinas @c(echo)
   activas. Cuando cae a cero, cierre la mitad de escritura de la conexion TCP
   como se describe en el Ejercicio 8.3. Compruebe que su cliente @$(netcat3)
   modificado de ese ejercicio espera los ecos finales de varios gritos
   simultaneos, incluso despues de la entrada estandar ha sido cerrada.

#    @b(Exercise 8.5): Take an existing CPU-bound sequential program, such as the
#    Mandelbrot program of @l(#Section 3.3) or the 3-D surface computation of
#    @l(#Section 3.2), and execute its main loop in parallel using channels for
#    communication. How much faster does it run on a multiprocessor machine? What
#    is the optimal number of goroutines to use?
   @b(Ejercicio 8.5): Tome un programa secuencial CPU dependiente existente, tal
   como el programa de Mandelbrot de la @l(#Seccion 3.3) o el calculo de
   superficie 3-D de la @l(#Seccion 3.2), y ejecutar su bucle principal
   utilizando canales paralelos para la comunicacion. ¿Cuanto mas rapido se
   ejecuta en una maquina multiprocesador? ¿Cual es el numero optimo de
   gorutinas a usar?

# ** Section 8.6 <> Example: Concurrent Web Crawler
** Seccion 8.6 <> Ejemplo: Rastreador Web Concurrente

#    In @l(#Section 5.6), we made a simple web crawler that explored the link
#    graph of the web in breadth-first order. In this section, we’ll make it
#    concurrent so that independent calls to @c(crawl) can exploit the I/O
#    parallelism available in the web. The @c(crawl) function remains exactly as
#    it was in @c(gopl.io/ch5/findlinks3):
   En la @l(#Seccion 5.6), hicimos un simple rastreador web que exploro el
   grafico de enlace de la web con primer onden de amplitud. En esta seccion, lo
   haremos concurrente para que las llamadas independientes a @c(crawl) puedan
   explotar el paralelismo de E/S disponible en la web. la funcion @c(crawl)
   sigue siendo exactamente como lo fue en @c(gopl.io/ch5/findlinks3):

#    ..figure > @l(gopl.io/ch8/crawl1/findlinks.go<>gopl.io/ch8/crawl1)
   ..figure > @l(gopl.io/ch8/crawl1/findlinks.go<>gopl.io/ch8/crawl1)

#      ..src > go
#        func crawl(url string) []string {
#          fmt.Println(url)
#          list, err := links.Extract(url)
#          if err != nil {
#            log.Print(err)
#          }
#          return list
#        }
#      < src..
     ..src > go
       func crawl(url string) []string {
         fmt.Println(url)
         list, err := links.Extract(url)
         if err != nil {
           log.Print(err)
         }
         return list
       }
     < src..


#    The main function resembles @c(breadthFirst) (@l(#Section 5.6<>§5.6)). As
#    before, a worklist records the queue of items that need processing, each item
#    being a list of URLs to crawl, but this time, instead of representing the
#    queue using a slice, we use a channel. Each call to @c(crawl) occurs in its
#    own goroutine and sends the links it discovers back to the worklist.
   La funcion principal se asemeja a @c(breadthFirst) (@l(#Seccion 5.6<>§5.6)).
   Como antes, una lista de trabajo registra la cola de elementos que necesitan
   procesamiento, cada elemento que es una lista de URL para rastrear, pero esta
   vez, en lugar de representar la cola utilizando un slice, usamos un
   canal. Cada llamada al @c(crawl) se produce en su propia gorutina y envia los
   enlaces que descubre de nuevo a la lista de trabajo.

#    ..src > go
#      func main() {
#        worklist := make(chan []string)
#
#        // Start with the command-line arguments.
#        go func() { worklist <- os.Args[1:] }()
#
#        // Crawl the web concurrently.
#        seen := make(map[string]bool)
#        for list := range worklist {
#          for _, link := range list {
#            if !seen[link] {
#              seen[link] = true
#              go func(link string) {
#                worklist <- crawl(link)
#              }(link)
#            }
#          }
#        }
#      }
#    < src..
   ..src > go
     func main() {
       worklist := make(chan []string)

       // Comiencza con los argumentos de la linea de comandos.
       go func() { worklist <- os.Args[1:] }()

       // Rastrea la red concurrentemente.
       seen := make(map[string]bool)
       for list := range worklist {
         for _, link := range list {
           if !seen[link] {
             seen[link] = true
             go func(link string) {
               worklist <- crawl(link)
             }(link)
           }
         }
       }
     }
   < src..

#    Notice that the crawl goroutine takes @c(link) as an explicit parameter to
#    avoid the problem of loop variable capture we first saw in @l(#Section
#    5.6.1). Also notice that the initial send of the command-line arguments to
#    the worklist must run in its own goroutine to avoid @e(deadlock), a stuck
#    situation in which both the main goroutine and a crawler goroutine attempt to
#    send to each other while neither is receiving. An alternative solution would
#    be to use a buffered channel.
   Observe que la gouritina de rastreo toma @c(link) como un parametro explicito
   para evitar el problema de captura de variables de bucle que vimos por
   primera vez en la @l(#Seccion 5.6.1). Observe tambien que el envio inicial de
   los argumentos de linea de comandos a la lista de trabajo debe ejecutarse en
   su propia gorutina para evitar un @e(punto muerto), una situacion en la cual
   tanto la gorutina principal y como la gorutina de rastreo intentan enviarse
   el uno al otro mientran que ninguno esta recibiendo. Una solucion alternativa
   seria utilizar un canal con buffer.

#    The crawler is now highly concurrent and prints a storm of URLs, but it has
#    two problems.  The first problem manifests itself as error messages in the
#    log after a few seconds of operation:
   El rastreador ahora es altamente concurrente e imprime una tormenta de
   direcciones URL, pero tiene dos problemas. El primer problema se manifiesta
   como mensajes de error en el registro despues de unos segundos de operacion:

#    ..src > sh
#      $ go build gopl.io/ch8/crawl1
#      $ ./crawl1 http://gopl.io/
#      http://gopl.io/
#      https://golang.org/help/
#
#      https://golang.org/doc/
#      https://golang.org/blog/
#      ...
#      2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
#      2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files
#      ...
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/crawl1
     $ ./crawl1 http://gopl.io/
     http://gopl.io/
     https://golang.org/help/

     https://golang.org/doc/
     https://golang.org/blog/
     ...
     2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
     2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files
     ...
   < src..

#    The initial error message is a surprising report of a DNS lookup failure for
#    a reliable domain.  The subsequent error message reveals the cause: the
#    program created so many network connections at once that it exceeded the
#    per-process limit on the number of open files, causing operations such as DNS
#    lookups and calls to @c(net.Dial) to start failing.
   El mensaje inicial de error es un informe sorprendente de un fallo de
   busqueda de DNS para un dominio confiable. El mensaje de error siguiente
   revela la causa: el programa a creado tantas conexiones de red a la vez que
   se supero el limite por proceso en el numero de archivos abiertos, haciendo
   que operaciones como las busquedas de DNS y la llama a @c(net.Dial) empiecen
   a fallar.

#    The program is @e(too) parallel. Unbounded parallelism is rarely a good idea
#    since there is always a limiting factor in the system, such as the number of
#    CPU cores for compute-bound workloads, the number of spindles and heads for
#    local disk I/O operations, the bandwidth of the network for streaming
#    downloads, or the serving capacity of a web service. The solution is to limit
#    the number of parallel uses of the resource to match the level of parallelism
#    that is available. A simple way to do that in our example is to ensure that
#    no more than @e(n) calls to @c(links.Extract) are active at once, where @e(n)
#    is comfortably less than the file descriptor limit—20, say. This is analogous
#    to the way a doorman at a crowded nightclub admits a guest only when some
#    other guest leaves.
   El programa es demasiado paralelo. El paralelismo ilimitado rara vez es una
   buena idea ya que siempre hay un factor limitante en el sistema, como el
   numero de nucleos de CPU para cargas de trabajo de calculo, el numero de
   husos y cabeceras para operaciones de E/S de disco local, el ancho de banda
   de la red para descargas de streaming, o la capacidad de servicio de un
   servicio web. La solucion es limitar el numero de usos paralelos del recurso
   para que coincida con el nivel de paralelismo que esta disponible. Una manera
   sencilla de hacerlo en nuestro ejemplo es asegurarse de que no hay mas de
   @e(n) llamadas a @c(links.Extract) activas a la vez, donde @e(n) esta
   comodamente inferior que el descriptor de ficheros limite–20 por
   ejemplo. Esto es analogo a la manera en que un portero en un club nocturno
   atestado admite a un huesped solamente cuando algun otro huesped sale.

#    We can limit parallelism using a buffered channel of capacity @e(n) to model
#    a concurrency primitive called a @e(counting semaphore). Conceptually, each
#    of the @e(n) vacant slots in the channel buffer represents a token entitling
#    the holder to proceed. Sending a value into the channel acquires a token, and
#    receiving a value from the channel releases a token, creating a new vacant
#    slot. This ensures that at most @e(n) sends can occur without an intervening
#    receive.  (Although it might be more intuitive to treat @e(filled) slots in
#    the channel buffer as tokens, using vacant slots avoids the need to fill the
#    channel buffer after creating it.) Since the channel element type is not
#    important, we’ll use @e(struct{}), which has size zero.
   Podemos limitar el paralelismo utilizando un canal con buffer de capacidad
   @e(n) para modelar una concurrencia primitiva denominada @e(semaforo contador).

   Conceptualmente, cada una de las @e(n) ranuras vacantes en el buffer del
   canal representa una señal que autoriza al titular a proceder. Enviar un
   valor al canal adquiere un token, y recibir un valor del canal libera un
   token, creando una nueva ranura vacante. Esto asegura que a la mayoria de los
   @e(n) envios puedan producirse sin una recepcion intermedia. (Aunque podria
   ser mas intuitivo tratar las ranuras @e(ocupadas) en canal con bufer como
   tokens, utilizando ranuras vacias evita la necesidad de llenar el buffer.)
   Dado que el tipo de elemento de canal no es importante, vamos a utilizar
   @c(struct{}), Que tiene el tamaño cero.

#    Let’s rewrite the @c(crawl) function so that the call to @e(links.Extract) is
#    bracketed by operations to acquire and release a token, thus ensuring that at
#    most 20 calls to it are active at one time.  It’s good practice to keep the
#    semaphore operations as close as possible to the I/O operation they regulate.
   Vamos a reescribir la funcion @c(crawl) para que la llamada a
   @c(links.Extract) se encuentre entre corchetes por las operaciones de
   adquirir y liberar un token, asegurando asi que a lo sumo 20 llamadas activas
   al mismo tiempo. Es una buena practica mantener las operaciones de semaforo
   lo mas cerca posible de la operacion de E/S que regulan.

#    ..figure > @l(gopl.io/ch8/crawl2/findlinks.go<>gopl.io/ch8/crawl2)
   ..figure > @l(gopl.io/ch8/crawl2/findlinks.go<>gopl.io/ch8/crawl2)

#      ..src > go
#        // tokens is a counting semaphore used to
#        // enforce a limit of 20 concurrent requests.
#        var tokens = make(chan struct{}, 20)
#
#        func crawl(url string) []string {
#          fmt.Println(url)
#          tokens <- struct{}{} // acquire a token
#          list, err := links.Extract(url)
#          <-tokens // release the token
#
#          if err != nil {
#            log.Print(err)
#          }
#          return list
#        }
#      < src..
     ..src > go
       // tokens es un semaforo de conteo usado para
       // imponer un limite de 20 petiones concurrentes.
       var tokens = make(chan struct{}, 20)

       func crawl(url string) []string {
         fmt.Println(url)
         tokens <- struct{}{} // aquirir un token
         list, err := links.Extract(url)
         <-tokens             // liberar el token

         if err != nil {
           log.Print(err)
         }
         return list
       }
     < src..


#    The second problem is that the program never terminates, even when it has
#    discovered all the links reachable from the initial URLs. (Of course, you’re
#    unlikely to notice this problem unless you choose the initial URLs carefully
#    or implement the depth-limiting feature of Exercise 8.6.)  For the program to
#    terminate, we need to break out of the main loop when the worklist is empty
#    @e(and) no crawl goroutines are active.
   El segundo problema es que el programa nunca termina, incluso cuando ha
   descubierto todos los enlaces accesibles desde las URLs iniciales. (Por
   supuesto, es poco probable que note este problema a menos que elija las URL
   inicialmente o implemente la caracteristica de limitacion de profundidad del
   Ejercicio 8.6). Para que el programa termine, necesitamos romper el bucle
   principal cuando la lista de trabajo este @e(y) no existan gorutinas de
   rastreo activas.

#    ..src > go
#      func main() {
#        worklist := make(chan []string)
#        var n int // number of pending sends to worklist
#
#        // Start with the command-line arguments.
#        n++
#        go func() { worklist <- os.Args[1:] }()
#
#        // Crawl the web concurrently.
#        seen := make(map[string]bool)
#        for ; n > 0; n-- {
#          list := <-worklist
#          for _, link := range list {
#            if !seen[link] {
#              seen[link] = true
#              n++
#              go func(link string) {
#                worklist <- crawl(link)
#              }(link)
#            }
#          }
#        }
#      }
#    < src..
   ..src > go
     func main() {
       worklist := make(chan []string)
       var n int // numero de envios pendientes a la lista de trabajo

       // Start with the command-line arguments.
       n++
       go func() { worklist <- os.Args[1:] }()

       // Rastradeor web concurrente.
       seen := make(map[string]bool)
       for ; n > 0; n-- {
         list := <-worklist
         for _, link := range list {
           if !seen[link] {
             seen[link] = true
             n++
             go func(link string) {
               worklist <- crawl(link)
             }(link)
           }
         }
       }
     }
   < src..

#    In this version, the counter @c(n) keeps track of the number of sends to the
#    worklist that are yet to occur. Each time we know that an item needs to be
#    sent to the worklist, we increment @c(n), once before we send the initial
#    command-line arguments, and again each time we start a crawler goroutine. The
#    main loop terminates when @c(n) falls to zero, since there is no more work to
#    be done.
   En esta version, el contador @c(n) mantiene un registro del numero de envios
   a la lista de trabajo que aun esta por ocurrir. Cada vez que sabemos que un
   elemento necesita ser enviado a la lista de trabajo, incrementamos @c(n), una
   vez antes de enviar los argumentos iniciales de linea de comandos, y de nuevo
   cada vez que se inicie una gorutina rastreador. El bucle principal termina
   cuando @c(n) cae a cero, ya que no hay mas trabajo por hacer.

#    Now the concurrent crawler runs about 20 times faster than the breadth-first
#    crawler from @l(#Section 5.6), without errors, and terminates correctly if it
#    should complete its task.
   Ahora el rastreador concurrente se ejecuta aproximadamente 20 veces mas
   rapido que el rastreador primero con primer orden de amplitud de la
   @l(#Seccion 5.6), sin errores, y termina correctamente si se debe completar
   su tarea.

#    The program below shows an alternative solution to the problem of excessive
#    concurrency.  This version uses the original crawl function that has no
#    counting semaphore, but calls it from one of 20 long-lived crawler
#    goroutines, thus ensuring that at most 20 HTTP requests are active
#    concurrently.
   El siguiente programa muestra una solucion alternativa al problema de la
   concurrencia excesiva. Esta version utiliza la funcion de rastreo original
   que no tiene semaforo de conteo, sino que la llama desde una de las 20
   rutinas de rastreo de larga duracion, garantizando asi que al menos 20
   solicitudes HTTP esten activas simultaneamente.

#    ..figure > @l(gopl.io/ch8/crawl3/findlinks.go<>gopl.io/ch8/crawl3)
   ..figure > @l(gopl.io/ch8/crawl3/findlinks.go<>gopl.io/ch8/crawl3)

#      ..src > go
#        func main() {
#          worklist := make(chan []string)  // lists of URLs, may have duplicates
#          unseenLinks := make(chan string) // de-duplicated URLs
#
#          // Add command-line arguments to worklist.
#          go func() { worklist <- os.Args[1:] }()
#
#          // Create 20 crawler goroutines to fetch each unseen link.
#          for i := 0; i < 20; i++ {
#            go func() {
#              for link := range unseenLinks {
#                foundLinks := crawl(link)
#                go func() { worklist <- foundLinks }()
#              }
#            }()
#          }
#
#          // The main goroutine de-duplicates worklist items
#          // and sends the unseen ones to the crawlers.
#          seen := make(map[string]bool)
#          for list := range worklist {
#            for _, link := range list {
#              if !seen[link] {
#                seen[link] = true
#                unseenLinks <- link
#              }
#            }
#          }
#        }
#      < src..
     ..src > go
       func main() {
         worklist := make(chan []string)  // lista de URLs, puede tener duplicados
         unseenLinks := make(chan string) // URLs desduplicadas

         // Agrega argumentos de linea de comandos a la lista de trabajo.
         go func() { worklist <- os.Args[1:] }()

         // Crea 20 gorutinas de rastreo para buscar cada enlace no visto.
         for i := 0; i < 20; i++ {
           go func() {
             for link := range unseenLinks {
               foundLinks := crawl(link)
               go func() { worklist <- foundLinks }()
             }
           }()
         }

         // La gorutina principal desduplica los elementos de la lista de trabajo
         // y envia los no vistos a los rastreadores.
         seen := make(map[string]bool)
         for list := range worklist {
           for _, link := range list {
             if !seen[link] {
               seen[link] = true
               unseenLinks <- link
             }
           }
         }
       }
     < src..


#    The crawler goroutines are all fed by the same channel, @c(unseenLinks). The
#    main goroutine is responsible for de-duplicating items it receives from the
#    worklist, and then sending each unseen one over the @c(unseenLinks) channel
#    to a crawler goroutine.
   Las gorutinas de rastreo son todas alimentadas por el mismo canal,
   @c(unseenLinks).  la gorutina principal es responsable de deduplicar los
   elementos que recibe de la lista de trabajo, y luego enviar cada enlace no
   visto sobre el canal @c(unseenLinks) a un gorutina rastreador.

#    The @c(seen) map is @e(confined) within the main goroutine; that is, it can
#    be accessed only by that goroutine. Like other forms of information hiding,
#    confinement helps us reason about the correctness of a program. For example,
#    local variables cannot be mentioned by name from outside the function in
#    which they are declared; variables that do not escape (@l(#Section
#    2.3.4<>§2.3.4)) from a function cannot be accessed from outside that
#    function; and encapsulated fields of an object cannot be accessed except by
#    the methods of that object. In all cases, information hiding helps to limit
#    unintended interactions between parts of the program.
   El mapa @c(seen) esta @e(confinado) dentro de la gorutina principal; Es
   decir, solo puede ser accedido por ese gorutina. Al igual que otras formas de
   ocultar la informacion, el confinamiento nos ayuda a razonar sobre la
   correccion de un programa. Por ejemplo, las variables locales no pueden
   mencionarse por su nombre fuera de la funcion en la que se declaran;
   variables que no escapan (@l(#Seccion 2.3.4<>§2.3.4)) de una funcion no se
   puede acceder desde fuera de esa funcion; Y los campos encapsulados de un
   objeto no se puede acceder excepto por los metodos de ese objeto. En todos
   los casos, la ocultacion de la informacion ayuda a limitar las interacciones
   no deseadas entre partes del programa.

#    Links found by @c(crawl) are sent to the worklist from a dedicated goroutine
#    to avoid deadlock.
   Los enlaces encontrados por @c(crawl) se envian a la lista de trabajo desde
   una gorutina dedicada para evitar un punto muerto.

#    To save space, we have not addressed the problem of termination in this
#    example.
   Para ahorrar espacio, no hemos abordado el problema de la terminacion en este
   ejemplo.

#    @b(Exercise 8.6): Add depth-limiting to the concurrent crawler. That is, if
#    the user sets @c(-depth=3), then only URLs reachable by at most three links
#    will be fetched.
   @b(Ejercicio 8.6): Añadir limite de profundidad al rastreador concurrente.
   Es decir, si el usuario establece @c(-depth=3), entonces solo se obtendran
   las URL accesibles como un maximo de tres enlaces.

#    @b(Exercise 8.7): Write a concurrent program that creates a local mirror of a
#    web site, fetching each reachable page and writing it to a directory on the
#    local disk. Only pages within the original domain (for instance,
#    @l(https://golang.org<>golang.org)) should be fetched. URLs within mirrored
#    pages should be altered as needed so that they refer to the mirrored page,
#    not the original.
   @b(Ejercicio 8.7): Escribir un programa concurrente que cree un espejo local
   de un sitio web, obteniendo cada pagina accesible y escribiendola en un
   directorio en el disco local. Solo se deben buscar las paginas dentro del
   dominio original (por ejemplo, @l(https://golang.org<>golang.org)). Las URL
   de las paginas reflejadas deben modificarse segun sea necesario para que se
   refieran a la pagina reflejada, no al original.

# ** Section 8.7 <> Multiplexing with @c(select)
** Seccion 8.7 <> Multiplexacion con @c(select)

#    The program below does the countdown for a rocket launch. The @c(time.Tick)
#    function returns a channel on which it sends events periodically, acting like
#    a metronome. The value of each event is a timestamp, but it is rarely as
#    interesting as the fact of its delivery.
   El programa a continuacion realiza la cuenta atras para un lanzamiento de
   cohetes. la funcion @c(time.Tick) devuelve un canal en el que se envia
   eventos periodicamente, actuando como un metronomo. El valor de cada evento
   es una marca de tiempo, pero rara vez es tan interesante como el hecho de su
   entrega.

#    ..figure > @l(gopl.io/ch8/countdown1/countdown.go<>gopl.io/ch8/countdown1)
   ..figure > @l(gopl.io/ch8/countdown1/countdown.go<>gopl.io/ch8/countdown1)

#      ..src > go
#        func main() {
#          fmt.Println("Commencing countdown.")
#          tick := time.Tick(1 * time.Second)
#          for countdown := 10; countdown > 0; countdown-- {
#            fmt.Println(countdown)
#            <-tick
#          }
#          launch()
#        }
#      < src..
     ..src > go
       func main() {
         fmt.Println("Commencing countdown.")
         tick := time.Tick(1 * time.Second)
         for countdown := 10; countdown > 0; countdown-- {
           fmt.Println(countdown)
           <-tick
         }
         launch()
       }
     < src..


#    Now let’s add the ability to abort the launch sequence by pressing the return
#    key during the countdown. First, we start a goroutine that tries to read a
#    single byte from the standard input and, if it succeeds, sends a value on a
#    channel called @c(abort).
   Ahora vamos a añadir la capacidad de abortar la secuencia de lanzamiento
   presionando la tecla de retorno durante la cuenta atras. En primer lugar,
   empezamos un gorutina que intenta leer un solo byte de la entrada estandar y,
   si tiene exito, envia un valor en un canal llamado @c(abort).

#    ..figure > @l(gopl.io/ch8/countdown2/countdown.go<>gopl.io/ch8/countdown2)
   ..figure > @l(gopl.io/ch8/countdown2/countdown.go<>gopl.io/ch8/countdown2)

#      ..src > go
#        abort := make(chan struct{})
#        go func() {
#          os.Stdin.Read(make([]byte, 1)) // read a single byte
#          abort <- struct{}{}
#        }()
#      < src..
     ..src > go
       abort := make(chan struct{})
       go func() {
         os.Stdin.Read(make([]byte, 1)) // lee un solo byte
         abort <- struct{}{}
       }()
     < src..


#    Now each iteration of the countdown loop needs to wait for an event to arrive
#    on one of the two channels: the ticker channel if everything is fine
#    (@"(nominal) in NASA jargon) or an abort event if there was an @"(anomaly.)
#    We can’t just receive from each channel because whichever operation we try
#    first will block until completion. We need to @c(multiplex) these operations,
#    and to do that, we need a @e(select statement).
   Ahora cada iteracion del bucle de cuenta atras tiene que esperar a que un
   evento llegue a uno de los dos canales: el canal tinker si todo esta bien
   (@"(nominal) en la jerga de la NASA) o un evento de aborto si hubo una
   anomalia. No podemos recibir solo de cada canal porque cualquiera de las
   operaciones que intentamos primero bloqueara hasta su finalizacion.
   Necesitamos multiplexar estas operaciones, y para ello, necesitamos una
   (sentencia de selecion).

#    ..src > go
#      select {
#      case <-ch1:
#        // ...
#      case x := <-ch2:
#        // ...use x...
#      case ch3 <- y:
#        // ...
#      default:
#        // ...
#      }
#    < src..
   ..src > go
     select {
     case <-ch1:
       // ...
     case x := <-ch2:
       // ...use x...
     case ch3 <- y:
       // ...
     default:
       // ...
     }
   < src..

#    The general form of a select statement is shown above. Like a switch
#    statement, it has a number of cases and an optional @c(default). Each case
#    specifies a @e(communication) (a send or receive operation on some channel)
#    and an associated block of statements. A receive expression may appear on its
#    own, as in the first case, or within a short variable declaration, as in the
#    second case; the second form lets you refer to the received value.
   La forma general de una sentencia @c(select) se muestra arriba. Al igual que
   una sentencia @c(switch), tiene un numero de casos y una opcion
   @c(default). Cada caso especifica una comunicacion (un envio o recepcion en
   el algun canal) y un bloque asociado de los estados. Una expresion de
   recepcion puede aparecer por si misma, como en el primer caso, o dentro de
   una declaracion de variable compacta, como en el segundo caso; La segunda
   forma le permite referirse al valor recibido.

#    A @c(select) waits until a communication for some case is ready to
#    proceed. It then performs that communication and executes the case’s
#    associated statements; the other communications do not happen. A @c(select)
#    with no cases, @c(select{}), waits forever.
   Un @c(select) espera hasta que una comunicacion por algun caso esta lista
   para proceder. A continuacion, realiza esa comunicacion y ejecuta las
   declaraciones asociadas del caso; Las otras comunicaciones no suceden. Un
   @c(select) sin casos, @c(select{}), espera por siempre.

#    Let’s return to our rocket launch program. The @c(time.After) function
#    immediately returns a channel, and starts a new goroutine that sends a single
#    value on that channel after the specified time. The select statement below
#    waits until the first of two events arrives, either an abort event or the
#    event indicating that 10 seconds have elapsed. If 10 seconds go by with no
#    abort, the launch proceeds.
   Volvamos a nuestro programa de lanzamiento de cohetes. la funcion
   @c(time.After) devuelve inmediatamente un canal, e inicia una nueva gorutina
   que envia un unico valor en ese canal despues del tiempo especificado. La
   instruccion de seleccion a continuacion espera hasta que llegue el primero de
   dos eventos, ya sea un evento de anulacion o el evento que indica que han
   transcurrido 10 segundos. Si pasan 10 segundos sin abortar, el lanzamiento
   continua.

#    ..src > go
#      func main() {
#        // ...create abort channel...
#
#        fmt.Println("Commencing countdown. Press return to abort.")
#        select {
#        case <-time.After(10 * time.Second):
#          // Do nothing.
#        case <-abort:
#          fmt.Println("Launch aborted!")
#          return
#        }
#        launch()
#      }
#    < src..
   ..src > go
     func main() {
       // ...crear canal abort...

       fmt.Println("Commencing countdown. Press return to abort.")
       select {
       case <-time.After(10 * time.Second):
         // no hacer nada.
       case <-abort:
         fmt.Println("Launch aborted!")
         return
       }
       launch()
     }
   < src..

#    The example below is more subtle. The channel @c(ch), whose buffer size is 1,
#    is alternately empty then full, so only one of the cases can proceed, either
#    the send when @c(i) is even, or the receive when @c(i) is odd. It always
#    prints @c(0 2 4 6 8).
   El siguiente ejemplo es mas sutil. El canal @c(ch), cuyo bufer es de tamaño
   1, esta alternativamente vacio y luego lleno, por lo que solo uno de los
   casos puede proceder, ya sea enviando cuando @e(i) es par, o bien recibiendo
   cuando @c(i) es impar. Siempre imprime @c(0 2 4 6 8).

#    ..src > go
#      ch := make(chan int, 1)
#      for i := 0; i < 10; i++ {
#        select {
#        case x := <-ch:
#          fmt.Println(x) // "0" "2" "4" "6" "8"
#        case ch <- i:
#        }
#      }
#    < src..
   ..src > go
     ch := make(chan int, 1)
     for i := 0; i < 10; i++ {
       select {
       case x := <-ch:
         fmt.Println(x) // "0" "2" "4" "6" "8"
       case ch <- i:
       }
     }
   < src..

#    If multiple cases are ready, @c(select) picks one at random, which ensures
#    that every channel has an equal chance of being selected. Increasing the
#    buffer size of the previous example makes its output nondeterministic,
#    because when the buffer is neither full nor empty, the select statement
#    figuratively tosses a coin.
   Si varios casos estan listos, @c(select) toma uno al azar, lo que asegura que
   cada canal tiene la misma probabilidad de ser seleccionado. Aumentar el
   tamaño del bufer del ejemplo anterior hace que su salida no sea determinista,
   porque cuando el bufer no esta lleno ni vacio, la sentencia @c(select) en
   sentido figurado arroja una moneda.

#    Let’s make our launch program print the countdown. The select statement below
#    causes each iteration of the loop to wait up to 1 second for an abort, but no
#    longer.
   Hagamos que nuestro programa de lanzamiento imprima la cuenta regresiva. La
   siguiente instruccion @c(select) hace que cada iteracion del bucle espere
   hasta 1 segundo para un aborto, pero no mas.

#    ..figure > @l(gopl.io/ch8/countdown3/countdown.go<>gopl.io/ch8/countdown3)
   ..figure > @l(gopl.io/ch8/countdown3/countdown.go<>gopl.io/ch8/countdown3)

#      ..src > go
#        func main() {
#          // ...create abort channel...
#
#          fmt.Println("Commencing countdown.  Press return to abort.")
#          tick := time.Tick(1 * time.Second)
#          for countdown := 10; countdown > 0; countdown-- {
#            fmt.Println(countdown)
#            select {
#            case <-tick:
#              // Do nothing.
#            case <-abort:
#              fmt.Println("Launch aborted!")
#              return
#            }
#          }
#          launch()
#        }
#      < src..
     ..src > go
       func main() {
         // ...crear canal abort...

         fmt.Println("Commencing countdown.  Press return to abort.")
         tick := time.Tick(1 * time.Second)
         for countdown := 10; countdown > 0; countdown-- {
           fmt.Println(countdown)
           select {
           case <-tick:
             // no hacer nada.
           case <-abort:
             fmt.Println("Launch aborted!")
             return
           }
         }
         launch()
       }
     < src..


#    The @c(time.Tick) function behaves as if it creates a goroutine that calls
#    @c(time.Sleep) in a loop, sending an event each time it wakes up. When the
#    countdown function above returns, it stops receiving events from @c(tick),
#    but the ticker goroutine is still there, trying in vain to send on a channel
#    from which no goroutine is receiving—a @e(goroutine leak) (@l(#Section
#    8.4.4<>§8.4.4)).
   la funcion @c(time.Tick) se comporta como si se crea un gorutina que llama a
   @c(time.Sleep) en un bucle, enviando un evento cada vez que se despierta.
   Cuando la funcion de cuenta atras regresa, se detiene la recepcion de eventos
   de @c(tick), pero la gorutina ticker sigue  alli, tratando en vano de
   enviar en un canal desde el que no esta recibiendo gorutina–una fuga de gorutina
   (@l(#Seccion 8.4.4<>§8.4.4)).

#    The @c(Tick) function is convenient, but it’s appropriate only when the ticks
#    will be needed throughout the lifetime of the application. Otherwise, we
#    should use this pattern:
   la funcion @c(Tick) es conveniente, pero es apropiada solo cuando se
   necesitan los ticks durante todo el tiempo de vida de la aplicacion. De lo
   contrario, deberiamos usar este patron:

#    ..src > go
#      ticker := time.NewTicker(1 * time.Second)
#
#      <-ticker.C    // receive from the ticker's channel
#
#      ticker.Stop() // cause the ticker's goroutine to terminate
#    < src..
   ..src > go
     ticker := time.NewTicker(1 * time.Second)

     <-ticker.C    // recibir desde el canal tiker

     ticker.Stop() // hace que la gorutina tiker termine
   < src..

#    Sometimes we want to try to send or receive on a channel but avoid blocking
#    if the channel is not ready—a @e(non-blocking) communication. A select
#    statement can do that too. A @c(select) may have a @e(default), which
#    specifies what to do when none of the other communications can proceed
#    immediately.
   A veces queremos intentar enviar o recibir en un canal, pero evitando el
   bloqueo si el canal no esta listo–una comunicacion @e(no bloqueante). Una
   sentencia @c(select) puede hacer eso tambien. Un @c(select) pueden tener un
   caso @c(default) que especifica que hacer cuando ninguna de las otras
   comunicaciones puede proceder de inmediato.

#    The select statement below receives a value from the @c(abort) channel if
#    there is one to receive; otherwise it does nothing. This is a non-blocking
#    receive operation; doing it repeatedly is called @e(polling) a channel.
   La instruccion @c(select) a continuacion recibe un valor del canal @c(abort)
   si hay uno para recibir; De lo contrario no hace nada. Se trata de una
   operacion de recepcion no bloqueante; haciendolo repetidamente se denomina un
   canal de @e(sondeo).

#    ..src > go
#      select {
#      case <-abort:
#        fmt.Printf("Launch aborted!\n")
#        return
#      default:
#        // do nothing
#      }
#    < src..
   ..src > go
     select {
     case <-abort:
       fmt.Printf("Launch aborted!\n")
       return
     default:
       // no hacer nada
     }
   < src..

#    The zero value for a channel is @c(nil). Perhaps surprisingly, nil channels
#    are sometimes useful.  Because send and receive operations on a nil channel
#    block forever, a case in a select statement whose channel is nil is never
#    selected. This lets us use @c(nil) to enable or disable cases that correspond
#    to features like handling timeouts or cancellation, responding to other input
#    events, or emitting output. We’ll see an example in the next section.
   El valor cero para un canal es @c(nil). Tal vez sorprendentemente, los
   canales nil a veces son utiles. Debido a que las operaciones de envio y
   recepcion en un bloque de canal nil, nunca se selecciona un caso en una
   sentencia @c(select) cuyo canal es @c(nil). Esto nos permite utilizar @c(nil)
   para activar o desactivar los casos que corresponden a caracteristicas como
   el manejo de tiempos de espera o cancelacion, en respuesta a otros eventos de
   entrada o de salida que emite. Veremos un ejemplo en la siguiente seccion.

#    @b(Exercise 8.8): Using a select statement, add a timeout to the echo server
#    from @l(#Section 8.3) so that it disconnects any client that shouts nothing
#    within 10 seconds.
   @b(Ejercicio 8.8): Utilizando una instruccion @c(select), agregue un tiempo
   de espera al servidor de eco de la @l(#Seccion 8.3) para que se desconecte
   cualquier cliente que no grite nada en 10 segundos.

# ** Section 8.8 <> Example: Concurrent Directory Traversal
** Seccion 8.8 <> Ejemplo: Trayecto de Directorio Concurrente

#    In this section, we’ll build a program that reports the disk usage of one or
#    more directories specified on the command line, like the Unix @$(du)
#    command. Most of its work is done by the @c(walkDir) function below, which
#    enumerates the entries of the directory @c(dir) using the @c(dirents) helper
#    function.
   En esta seccion, vamos a construir un programa que informa del uso de disco
   de uno o mas directorios especificados en la linea de comandos, como el
   comando Unix @$(du). La mayor parte de su trabajo es realizado por la funcion
   @c(walkDir) a continuacion, que enumera las entradas del directorio @c(dir)
   utilizando la funcion auxiliar @c(dirents).

#    ..figure > @l(gopl.io/ch8/du1/main.go<>gopl.io/ch8/du1)
   ..figure > @l(gopl.io/ch8/du1/main.go<>gopl.io/ch8/du1)

#      ..src > go
#        // walkDir recursively walks the file tree rooted at dir
#        // and sends the size of each found file on fileSizes.
#        func walkDir(dir string, fileSizes chan<- int64) {
#          for _, entry := range dirents(dir) {
#            if entry.IsDir() {
#              subdir := filepath.Join(dir, entry.Name())
#              walkDir(subdir, fileSizes)
#            } else {
#              fileSizes <- entry.Size()
#            }
#          }
#        }
#
#        // dirents returns the entries of directory dir.
#        func dirents(dir string) []os.FileInfo {
#          entries, err := ioutil.ReadDir(dir)
#          if err != nil {
#            fmt.Fprintf(os.Stderr, "du1: %v\n", err)
#            return nil
#          }
#          return entries
#        }
#      < src..
     ..src > go
       // walkDir camina recursivamente el arbol de archivos raiz en dir
       // y envia el tamaño de cada archivo encontrado en fileSize.
       func walkDir(dir string, fileSizes chan<- int64) {
         for _, entry := range dirents(dir) {
           if entry.IsDir() {
             subdir := filepath.Join(dir, entry.Name())
             walkDir(subdir, fileSizes)
           } else {
             fileSizes <- entry.Size()
           }
         }
       }

       // dirents devuelve las entradas del directorio dir.
       func dirents(dir string) []os.FileInfo {
         entries, err := ioutil.ReadDir(dir)
         if err != nil {
           fmt.Fprintf(os.Stderr, "du1: %v\n", err)
           return nil
         }
         return entries
       }
     < src..


#    The @c(ioutil.ReadDir) function returns a slice of @c(os.FileInfo)—the same
#    information that a call to @c(os.Stat) returns for a single file. For each
#    subdirectory, @c(walkDir) recursively calls itself, and for each file,
#    @c(walkDir) sends a message on the @c(fileSizes) channel. The message is the
#    size of the file in bytes.
   la funcion @c(ioutil.ReadDir) devuelve una slice de @c(os.FileInfo)–la misma
   informacion que una llamada a @c(os.Stat) regresa para un solo archivo. Para
   cada subdirectorio, @c(walkDir) se llama a si misma recursivamente, y para
   cada archivo, @c(walkDir) envia un mensaje en el canal @c(fileSizes). El
   mensaje es el tamaño del archivo en bytes.

#    The main function, shown below, uses two goroutines. The background goroutine
#    calls @c(walkDir) for each directory  specified on the command line and
#    finally closes the @c(fileSizes) channel. The main goroutine computes the sum
#    of the file sizes it receives from the channel and finally prints the total.
   La funcion principal, que se muestra a continuacion, utiliza dos gorutinas.
   La gorutina de fondo se llama @c(walkDir) por cada directorio especificado en
   la linea de comandos y finalmente cierra el canal @c(fileSizes). la gorutina
   principal calcula la suma de los tamaños del archivo que recibe del canal y
   finalmente imprime el total.

#    ..src > go
#      // The du1 command computes the disk usage of the files in a directory.
#      package main
#
#      import (
#        "flag"
#        "fmt"
#        "io/ioutil"
#        "os"
#        "path/filepath"
#      )
#
#      func main() {
#        // Determine the initial directories.
#        flag.Parse()
#        roots := flag.Args()
#        if len(roots) == 0 {
#          roots = []string{"."}
#        }
#
#        // Traverse the file tree.
#        fileSizes := make(chan int64)
#        go func() {
#          for _, root := range roots {
#            walkDir(root, fileSizes)
#          }
#          close(fileSizes)
#        }()
#
#        // Print the results.
#        var nfiles, nbytes int64
#        for size := range fileSizes {
#          nfiles++
#          nbytes += size
#        }
#        printDiskUsage(nfiles, nbytes)
#      }
#
#      func printDiskUsage(nfiles, nbytes int64) {
#        fmt.Printf("%d files %.1f GB\n", nfiles, float64(nbytes)/1e9)
#      }
#    < src..
   ..src > go
     // El comando du1 calcula el uso de disco de los archivos en el directorio.
     package main

     import (
       "flag"
       "fmt"
       "io/ioutil"
       "os"
       "path/filepath"
     )

     func main() {
       // Determina los directorios iniciales.
       flag.Parse()
       roots := flag.Args()
       if len(roots) == 0 {
         roots = []string{"."}
       }

       // Recorre el arbol de archivos.
       fileSizes := make(chan int64)
       go func() {
         for _, root := range roots {
           walkDir(root, fileSizes)
         }
         close(fileSizes)
       }()

       // Imprime los reslutados.
       var nfiles, nbytes int64
       for size := range fileSizes {
         nfiles++
         nbytes += size
       }
       printDiskUsage(nfiles, nbytes)
     }

     func printDiskUsage(nfiles, nbytes int64) {
       fmt.Printf("%d files %.1f GB\n", nfiles, float64(nbytes)/1e9)
     }
   < src..

#    This program pauses for a long while before printing its result:
   Este programa hace una pausa durante mucho tiempo antes de imprimir su
   resultado:

#    ..src > sh
#      $ go build gopl.io/ch8/du1
#      $ ./du1 $HOME /usr /bin /etc
#      213201 files 62.7 GB
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/du1
     $ ./du1 $HOME /usr /bin /etc
     213201 files 62.7 GB
   < src..

#    The program would be nicer if it kept us informed of its progress. However,
#    simply moving the @c(printDiskUsage) call into the loop would cause it to
#    print thousands of lines of output.
   El programa seria mas agradable si nos mantiene informados de su
   progreso. Sin embargo, simplemente moviendo el llamada a @c(printDiskUsage)
   en el bucle, lo haria que imprimir miles de lineas de salida.

#    The variant of @$(du) below prints the totals periodically, but only if the
#    @c(-v) flag is specified since not all users will want to see progress
#    messages. The background goroutine that loops over @c(roots) remains
#    unchanged. The main goroutine now uses a ticker to generate events every
#    500ms, and a select statement to wait for either a file size message, in
#    which case it updates the totals, or a tick event, in which case it prints
#    the current totals. If the @c(-v) flag is not specified, the @c(tick) channel
#    remains nil, and its case in the @c(select) is effectively disabled.
   La variante de @$(du) a continuacion, imprime los totales de forma periodica,
   pero solo si se especifica la bandera @c(-v) ya que no todos los usuarios
   querra ver mensajes de progreso. la gorutina de fondo que se repite sobre
   @c(roots) se mantiene sin cambios. la gorutina principal ahora utiliza un
   @c(ticker) para generar acontecimientos cada 500ms, y una declaracion
   @c(select) para esperar un mensaje del tamaño del archivo, en cuyo caso
   actualiza el total, o un evento tick, en cuyo caso imprime el total
   actual. Si no se especifica la bandera @c(-v), el canal @c(tick) sigue siendo
   nil, y en efecto se desactiva en su caso en el @c(select).

#    ..figure > @l(gopl.io/ch8/du2/main.go<>gopl.io/ch8/du2)
   ..figure > @l(gopl.io/ch8/du2/main.go<>gopl.io/ch8/du2)

#      ..src > go
#        var verbose = flag.Bool("v", false, "show verbose progress messages")
#
#        func main() {
#          // ...start background goroutine...
#
#          // Print the results periodically.
#          var tick <-chan time.Time
#          if *verbose {
#            tick = time.Tick(500 * time.Millisecond)
#          }
#          var nfiles, nbytes int64
#        loop:
#          for {
#            select {
#            case size, ok := <-fileSizes:
#              if !ok {
#                break loop // fileSizes was closed
#              }
#              nfiles++
#              nbytes += size
#            case <-tick:
#              printDiskUsage(nfiles, nbytes)
#            }
#          }
#          printDiskUsage(nfiles, nbytes) // final totals
#        }
#      < src..
     ..src > go
       var verbose = flag.Bool("v", false, "show verbose progress messages")

       func main() {
         // ...inicia gorutina de fondo...

         // Imprime el resultado periodicamente.
         var tick <-chan time.Time
         if *verbose {
           tick = time.Tick(500 * time.Millisecond)
         }
         var nfiles, nbytes int64
       loop:
         for {
           select {
           case size, ok := <-fileSizes:
             if !ok {
               break loop // fileSizes es cerrado
             }
             nfiles++
             nbytes += size
           case <-tick:
             printDiskUsage(nfiles, nbytes)
           }
         }
         printDiskUsage(nfiles, nbytes) // total final
       }
     < src..


#    Since the program no longer uses a @c(range) loop, the first @c(select) case
#    must explicitly test whether the @c(fileSizes) channel has been closed, using
#    the two-result form of receive operation. If the channel has been closed, the
#    program breaks out of the loop. The labeled @c(break) statement breaks
#    out of both the @c(select) and the @c(for) loop; an unlabeled @c(break) would
#    break out of only the @c(select), causing the loop to begin the next
#    iteration.
   Dado que el programa ya no utiliza una bucle @c(range), el primer caso
   @c(select) debe probar explicitamente si el canal @c(fileSizes) se ha
   cerrado, utilizando la forma de dos resultado de recepcion de operacion. Si
   el canal se ha cerrado, el programa rompe fuera del bucle. Las sentencia
   @c(break) rompe la etiqueta tanto en @c(selec) y el bucle @c(for); una
   marcada @c(break) no etiquetada saldria solo fera de @c(select), haciendo que
   el bucle comience la siguiente iteracion.

#    The program now gives us a leisurely stream of updates:
   El programa ahora nos da un flujo de actualizaciones:

#    ..src > sh
#      $ go build gopl.io/ch8/du2
#      $ ./du2 -v $HOME /usr /bin /etc
#      28608 files 8.3 GB
#      54147 files 10.3 GB
#      93591 files 15.1 GB
#      127169 files 52.9 GB
#      175931 files 62.2 GB
#      213201 files 62.7 GB
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/du2
     $ ./du2 -v $HOME /usr /bin /etc
     28608 files 8.3 GB
     54147 files 10.3 GB
     93591 files 15.1 GB
     127169 files 52.9 GB
     175931 files 62.2 GB
     213201 files 62.7 GB
   < src..

#    However, it still takes too long to finish. There’s no reason why all the
#    calls to @c(walkDir) can’t be done concurrently, thereby exploiting
#    parallelism in the disk system. The third version of @$(du), below, creates a
#    new goroutine for each call to @c(walkDir). It uses a @c(sync.WaitGroup)
#    (@l(#Section 8.5<>§8.5)) to count the number of calls to @c(walkDir) that are
#    still active, and a closer goroutine to close the @c(fileSizes) channel when
#    the counter drops to zero.
   Sin embargo, todavia toma demasiado tiempo para terminar. No hay ninguna
   razon por la cual todas las llamadas a @c(walkDir) no se pueden hacer al
   mismo tiempo, explotando de esta manera el paralelismo en el disco del
   sistema. La tercera version de @$(du), a continuacion, crea una nueva
   gorutina para cada llamada a @c(walkDir). Se utiliza un @c(sync.WaitGroup)
   (@l(#Seccion 8.5<>§8.5)) para contar el numero de llamadas a @c(walkDir) que
   aun estan activas, y una gorutina mas cerca para cerrar el canal
   @c(fileSizes) cuando el contador llega a cero.

#    ..figure > @l(gopl.io/ch8/du3/main.go<>gopl.io/ch8/du3)
   ..figure > @l(gopl.io/ch8/du3/main.go<>gopl.io/ch8/du3)

#      ..src > go
#        func main() {
#          // ...determine roots...
#
#          // Traverse each root of the file tree in parallel.
#          fileSizes := make(chan int64)
#          var n sync.WaitGroup
#          for _, root := range roots {
#            n.Add(1)
#            go walkDir(root, &n, fileSizes)
#          }
#          go func() {
#            n.Wait()
#            close(fileSizes)
#          }()
#          // ...select loop...
#        }
#
#        func walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {
#          defer n.Done()
#          for _, entry := range dirents(dir) {
#            if entry.IsDir() {
#              n.Add(1)
#              subdir := filepath.Join(dir, entry.Name())
#              go walkDir(subdir, n, fileSizes)
#            } else {
#              fileSizes <- entry.Size()
#            }
#          }
#        }
#      < src..
     ..src > go
       func main() {
         // ...determina roots...

         // Recorre cada raiz del arbol de archivos en paralelo.
         fileSizes := make(chan int64)
         var n sync.WaitGroup
         for _, root := range roots {
           n.Add(1)
           go walkDir(root, &n, fileSizes)
         }
         go func() {
           n.Wait()
           close(fileSizes)
         }()
         // ...bucle select...
       }

       func walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {
         defer n.Done()
         for _, entry := range dirents(dir) {
           if entry.IsDir() {
             n.Add(1)
             subdir := filepath.Join(dir, entry.Name())
             go walkDir(subdir, n, fileSizes)
           } else {
             fileSizes <- entry.Size()
           }
         }
       }
     < src..


#    Since this program creates many thousands of goroutines at its peak, we have
#    to change @c(dirents) to use a counting semaphore to prevent it from opening too
#    many files at once, just as we did for the web crawler in @l(#Section 8.6):
   Ya que este programa crea miles de gorutinas en su apogeo, tenemos que
   cambiar @c(dirents) para utilizar un semaforo contador para evitar que se
   abran demasiados archivos a la vez, tal como lo hicimos para el rastreador web
   en la @l(#Seccion 8.6):

#    ..src > go
#      // sema is a counting semaphore for limiting concurrency in dirents.
#      var sema = make(chan struct{}, 20)
#
#      // dirents returns the entries of directory dir.
#      func dirents(dir string) []os.FileInfo {
#        sema <- struct{}{}
#        // acquire token
#        defer func() { <-sema }() // release token
#        // ...
#    < src..
   ..src > go
     // sema es un semaforo de conteo para limitar la concurrencia en dirents
     var sema = make(chan struct{}, 20)

     // dirents devuelve las entradas de directorio dir
     func dirents(dir string) []os.FileInfo {
       sema <- struct{}{}
       // adquirir token
       defer func() { <-sema }() // liberar token
       // ...
   < src..

#    This version runs several times faster than the previous one, though there is
#    a lot of variability from system to system.
   Esta version se ejecuta varias veces mas rapido que la anterior, aunque hay
   mucha variabilidad de sistema a sistema.

#    @b(Exercise 8.9): Write a version of @$(du) that computes and periodically
#    displays separate totals for each of the @c(root) directories.
   @b(Ejercicio 8.9): Escribir una version de @$(du) que calcule y muestre
   periodicamente totales separados para cada una de los directorios @c(root).

# ** Section 8.9 <> Cancellation
** Seccion 8.9 <> Cancelacion

#    Sometimes we need to instruct a goroutine to stop what it is doing, for
#    example, in a web server performing a computation on behalf of a client that
#    has disconnected.
   A veces necesitamos instruir a una gorutina para que detenga lo que esta
   haciendo, por ejemplo, en un servidor web que realiza un calculo en nombre de
   un cliente que se ha desconectado.

#    There is no way for one goroutine to terminate another directly, since that
#    would leave all its shared variables in undefined states. In the rocket
#    launch program (@l(#Section 8.7<>§8.7)) we sent a single value on a channel
#    named @c(abort), which the countdown goroutine interpreted as a request to
#    stop itself. But what if we need to cancel two goroutines, or an arbitrary
#    number?
   No hay manera de que una gorutina termine directamente a otra, ya que dejaria
   todas sus variables compartidas en estados indefinidos. En el programa de
   lanzamiento de cohetes (@l(#Seccion 8.7<>§8.7)) enviamos un solo valor en un
   canal llamado @c(abort), que la gorutina de cuenta regresiva interpreto como
   una peticion para detenerse. Pero ¿y si necesitamos cancelar dos gorutinas, o
   un numero arbitrario?

#    One possibility might be to send as many events on the @c(abort) channel as
#    there are goroutines to cancel. If some of the goroutines have already
#    terminated themselves, however, our count will be too large, and our sends
#    will get stuck. On the other hand, if those goroutines have spawned other
#    goroutines, our count will be too small, and some goroutines will remain
#    unaware of the cancellation. In general, it’s hard to know how many
#    goroutines are working on our behalf at any given moment. Moreover, when a
#    goroutine receives a value from the @c(abort) channel, it consumes that value so
#    that other goroutines won’t see it. For cancellation, what we need is a
#    reliable mechanism to @e(broadcast) an event over a channel so that many
#    goroutines can see it @e(as) it occurs and can later see that it @e(has)
#    occurred.
   Una posibilidad podria ser la de enviar tantos eventos en el canal @c(abort)
   como gorutinas haya que cancelar. Sin embargo, si algunas de las gorutinas ya
   se han terminado, nuestra cuenta sera demasiado grande, y nuestros envios
   quedaran atascados. Por otra parte, si esas gorutinas han generado otros
   gorutinas, nuestra cuenta sera demasiado pequeña, y algunas gorutinas
   permaneceran inconscientes de la cancelacion. En general, es dificil saber
   cuantos gorutinas estan trabajando en nuestro nombre en un momento
   dado. Ademas, cuando un gorutina recibe un valor del canal @c(abort), consume
   ese valor para que otros gorutinas no lo vean. Para la cancelacion, lo que
   necesitamos es un mecanismo fiable para @e(transmitir) un evento sobre un
   canal de modo que muchos gorutinas puedan verlo @e(tal) como ocurre y ver mas
   tarde que @e(ha) ocurrido.

#    Recall that after a channel has been closed and drained of all sent values,
#    subsequent receive operations proceed immediately, yielding zero values. We
#    can exploit this to create a broadcast mechanism: don’t send a value on the
#    channel, close it.
   Recuerde que despues de que un canal ha sido cerrado y drenado de todos los
   valores enviados, las operaciones de recepcion posteriores proceden
   inmediatamente, dando valores cero. Podemos explotar esto para crear un
   mecanismo de difusion: no enviar un valor en el canal, cerrarlo.

#    We can add cancellation to the @$(du) program from the previous section with
#    a few simple changes. First, we create a cancellation channel on which no
#    values are ever sent, but whose closure indicates that it is time for the
#    program to stop what it is doing. We also define a utility function,
#    @c(cancelled), that checks or @e(polls) the cancellation state at the instant
#    it is called.
   Podemos agregar la cancelacion al programa @$(du) de la seccion anterior con
   algunos cambios simples. En primer lugar, creamos un canal de cancelacion en
   el que no se envian valores, pero cuyo cierre indica que es hora de que el
   programa detenga lo que esta haciendo. Tambien definimos una funcion de
   utilidad, @c(cancelled), que verifica o sondea el estado de cancelacion en el
   instante en que se llama.

#    ..figure > @l(gopl.io/ch8/du4/main.go<>gopl.io/ch8/du4)
   ..figure > @l(gopl.io/ch8/du4/main.go<>gopl.io/ch8/du4)

#      ..src > go
#        var done = make(chan struct{})
#
#        func cancelled() bool {
#          select {
#          case <-done:
#            return true
#          default:
#            return false
#          }
#        }
#      < src..
     ..src > go
       var done = make(chan struct{})

       func cancelled() bool {
         select {
         case <-done:
           return true
         default:
           return false
         }
       }
     < src..


#    Next, we create a goroutine that will read from the standard input, which is
#    typically connected to the terminal. As soon as any input is read (for
#    instance, the user presses the return key), this goroutine broadcasts the
#    cancellation by closing the @c(done) channel.
   A continuacion, creamos una gorutina que leera desde la entrada estandar, que
   normalmente esta conectada al terminal. Tan pronto como se lee cualquier
   entrada (por ejemplo, el usuario pulsa la tecla de retorno), este gorutina
   difunde la cancelacion cerrando el canal @c(done).

#    ..src > go
#      // Cancel traversal when input is detected.
#      go func() {
#        os.Stdin.Read(make([]byte, 1)) // read a single byte
#        close(done)
#      }()
#    < src..
   ..src > go
     // cancelar el recorrido cuando se detecta entrada
     go func() {
       os.Stdin.Read(make([]byte, 1)) // lee un solo byte
       close(done)
     }()
   < src..

#    Now we need to make our goroutines respond to the cancellation. In the main
#    goroutine, we add a third case to the select statement that tries to receive
#    from the @c(done) channel. The function returns if this case is ever selected,
#    but before it returns it must first drain the @c(fileSizes) channel,
#    discarding all values until the channel is closed. It does this to ensure
#    that any active calls to @c(walkDir) can run to completion without getting
#    stuck sending to @c(fileSizes).
   Ahora necesitamos hacer que nuestras gorutinas respondan a la cancelacion. En
   la gorutina principal, se añade un tercer caso a la instruccion @c(select)
   que trata de recibir desde el canal @c(done). La funcion regresa si se
   selecciona este caso, pero antes de regresar debe drenar el canal
   @c(fileSizes), descartando todos los valores hasta que el canal esta
   cerrado. Esto se hace para asegurar que todas las llamadas activas a
   @c(walkDir) puedan correr hasta el final sin quedar atascado enviando a
   @c(fileSizes).

#    ..src > go
#      for {
#        select {
#        case <-done:
#          // Drain fileSizes to allow existing goroutines to finish.
#          for range fileSizes {
#            // Do nothing.
#          }
#          return
#        case size, ok := <-fileSizes:
#          // ...
#        }
#      }
#    < src..
   ..src > go
     for {
       select {
       case <-done:
         // Drenar fileSizes para permitir que las gorutinas existentes terminen.
         for range fileSizes {
           // no hacer nada.
         }
         return
       case size, ok := <-fileSizes:
         // ...
       }
     }
   < src..

#    The @c(walkDir) goroutine polls the cancellation status when it begins, and
#    returns without doing anything if the status is set. This turns all
#    goroutines created after cancellation into no-ops:
   La gorutina @c(walkDir) escruta el estado de cancelacion cuando empieza y
   regresa sin hacer nada si se establece el estado. Esto convierte todas
   las gorutinas creadas despues de la cancelacion en no-ops:

#    ..src > go
#      func walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {
#        defer n.Done()
#        if cancelled() {
#          return
#        }
#        for _, entry := range dirents(dir) {
#          // ...
#        }
#      }
#    < src..
   ..src > go
     func walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {
       defer n.Done()
       if cancelled() {
         return
       }
       for _, entry := range dirents(dir) {
         // ...
       }
     }
   < src..

#    It might be profitable to poll the cancellation status again within @c(walkDir)’s
#    loop, to avoid creating goroutines after the cancellation event. Cancellation
#    involves a trade-off; a quicker response often requires more intrusive
#    changes to program logic. Ensuring that no expensive operations ever occur
#    after the cancellation event may require updating many places in your code,
#    but often most of the benefit can be obtained by checking for cancellation in
#    a few important places.
   Puede ser que sea rentable sondear el estado de cancelacion de nuevo dentro
   del bucle @c(walkDir), para evitar la creacion gorutinas despues del evento
   de cancelacion. La cancelacion implica un trade-off; Una respuesta mas rapida
   a menudo requiere cambios mas intrusivos a la logica del programa. Asegurarse
   de que ninguna operacion costosa ocurre despues del evento de cancelacion
   puede requerir la actualizacion de muchos lugares en su codigo, pero a menudo
   la mayoria del beneficio se puede obtener comprobando la cancelacion en
   algunos lugares importantes.

#    A little profiling of this program revealed that the bottleneck was the
#    acquisition of a semaphore token in @c(dirents). The @c(select) below makes
#    this operation cancellable and reduces the typical cancellation latency of
#    the program from hundreds of milliseconds to tens:
   Un poco de perfilado de este programa revelo que el cuello de botella es la
   adquisicion de un token de semaforos en @c(dirents). El @c(select) a
   continuacion hace que esta operacion sea cancelable y reduce la latencia
   tipica del programa de cientos a decenas de milisegundos:

#    ..src > go
#      func dirents(dir string) []os.FileInfo {
#        select {
#        case sema <- struct{}{}: // acquire token
#        case <-done:
#          return nil // cancelled
#        }
#        defer func() { <-sema }() // release token
#
#        // ...read directory...
#      }
#    < src..
   ..src > go
     func dirents(dir string) []os.FileInfo {
       select {
       case sema <- struct{}{}:  // aquirir token
       case <-done:
         return nil // cancelled
       }
       defer func() { <-sema }() // liberar token

       // ...leer directorio...
     }
   < src..

#    Now, when cancellation occurs, all the background goroutines quickly stop and
#    the @c(main) function returns. Of course, when @c(main) returns, a program
#    exits, so it can be hard to tell a main function that cleans up after itself
#    from one that does not. There’s a handy trick we can use during testing: if
#    instead of returning from @c(main) in the event of cancellation, we execute a
#    call to @c(panic), then the runtime will dump the stack of every goroutine in
#    the program. If the main goroutine is the only one left, then it has cleaned
#    up after itself. But if other goroutines remain, they may not have been
#    properly cancelled, or perhaps they have been cancelled but the cancellation
#    takes time; a little investigation may be worthwhile. The panic dump often
#    contains sufficient information to distinguish these cases.
   Ahora, cuando se produce la cancelacion, todas las gorutinas de fondo se
   detienen rapidamente y la funcion @c(main) regresa. Por supuesto, cuando
   @c(main) regresa, un programa sale, por lo que puede ser dificil distinguir
   una funcion principal que limpia despues de si mismo de una que no lo
   hace. Hay un truco muy util que podemos utilizar durante las pruebas: si en
   lugar de regresar de @c(main) en caso de cancelacion, llevamos a cabo una
   llamada a @c(panic), entonces en tiempo de ejecucion se volcara la pila de
   cada gorutina en el programa. Si la gorutina principal es la unica que queda,
   sera limpiada despues a si misma. Pero si otros gorutinas permanecen, pueden
   no haber sido canceladas correctamente, o quizas se han cancelado pero la
   cancelacion toma tiempo; Una pequeña investigacion puede valer la pena. El
   volcado de un panico a menudo contiene informacion suficiente para distinguir
   estos casos.

#    @b(Exercise 8.10): HTTP requests may be cancelled by closing the optional
#    @c(Cancel) channel in the @c(http.Request) struct. Modify the web crawler of
#    @l(#Section 8.6) to support cancellation.
   @b(Ejercicio 8.10): Las peticiones HTTP pueden cancelarce cerrando el canal
   opcional @c(Cancel) en la estructura @c(http.Request). Modificar el
   rastreador web de la @l(#Seccion 8.6) para admitir la cancelacion.

#    Hint: the @c(http.Get) convenience function does not give you an opportunity
#    to customize a @c(Request). Instead, create the request using
#    @c(http.NewRequest), set its @c(Cancel) field, then perform the request by
#    calling @c[http.DefaultClient.Do(req)].
   Sugerencia: la conveniente funcion @c(http.Get) no le brinda la oportunidad
   de personalizar una @c(Request). En su lugar, cree la solicitud utilizando
   @c(http.NewRequest), establezca su campo @c(Cancel) y, a continuacion, realice la
   solicitud llamando a @c[http.DefaultClient.Do(req)].

#    @b(Exercise 8.11): Following the approach of @c(mirroredQuery) in @l(#Section
#    8.4.4), implement a variant of @$(fetch) that requests several URLs
#    concurrently. As soon as the first response arrives, cancel the other
#    requests.
   @b(Ejercicio 8.11): Siguiendo el enfoque de @c(mirroredQuery) en la
   @l(#Seccion 8.4.4), impremente una variante de @$(fetch) que solicite varias
   direcciones URL al mismo tiempo. Tan pronto como llegue la primera respuesta,
   cancele las otras solicitudes.

# ** Section 8.10 <> Example: Chat Server
** Seccion 8.10 <> Ejemplo: Server de Chat

#    We’ll finish this chapter with a chat server that lets several users
#    broadcast textual messages to each other. There are four kinds of goroutine
#    in this program. There is one instance apiece of the @c(main) and
#    @c(broadcaster) goroutines, and for each client connection there is one
#    @c(handleConn) and one @c(clientWriter) goroutine. The broadcaster is a good
#    illustration of how @c(select) is used, since it has to respond to three
#    different kinds of messages.
   Terminaremos este capitulo con un servidor de chat que permite a varios
   usuarios difundir mensajes de texto entre si. Hay cuatro tipos de gorutina en
   este programa. Hay una instancia por cada gorutina @c(main) y
   @c(broadcaster), y para cada conexion de cliente hay una gorutina
   @c(handleConn) y @c(clientWriter). El emisor un buen ejemplo de como se
   utiliza @c(select), ya que tiene que responder a tres diferentes tipos de
   mensajes.

#    The job of the main goroutine, shown below, is to listen for and accept
#    incoming network connections from clients. For each one, it creates a new
#    @c(handleConn) goroutine, just as in the concurrent echo server we saw at the
#    start of this chapter.
   El trabajo de la gorutina principal, demostrado abajo, es escuchar y aceptar
   conexiones entrantes de la red de clientes. Para cada uno, crea una nueva
   gorutina @c(handleConn), al igual que en el servidor eco concurrente que
   vimos al principio de este capitulo.

#    ..figure > @l(gopl.io/ch8/chat/chat.go<>gopl.io/ch8/chat)
   ..figure > @l(gopl.io/ch8/chat/chat.go<>gopl.io/ch8/chat)

#      ..src > go
#        func main() {
#          listener, err := net.Listen("tcp", "localhost:8000")
#          if err != nil {
#            log.Fatal(err)
#          }
#
#          go broadcaster()
#          for {
#            conn, err := listener.Accept()
#            if err != nil {
#              log.Print(err)
#              continue
#            }
#            go handleConn(conn)
#          }
#        }
#      < src..
     ..src > go
       func main() {
         listener, err := net.Listen("tcp", "localhost:8000")
         if err != nil {
           log.Fatal(err)
         }

         go broadcaster()
         for {
           conn, err := listener.Accept()
           if err != nil {
             log.Print(err)
             continue
           }
           go handleConn(conn)
         }
       }
     < src..


#    Next is the broadcaster. Its local variable @c(clients) records the current
#    set of connected clients.  The only information recorded about each client is
#    the identity of its outgoing message channel, about which more later.
   A continuacion esta el emisor. Sus variable local @c(clients) registra el
   conjunto actual de los clientes conectados. La unica informacion registrada
   sobre cada cliente es la identidad de su canal de mensajes salientes, sobre
   el cual mas tarde.

#    ..src > go
#      type client chan<- string // an outgoing message channel
#
#      var (
#        entering = make(chan client)
#        leaving = make(chan client)
#        messages = make(chan string) // all incoming client messages
#      )
#
#      func broadcaster() {
#        clients := make(map[client]bool) // all connected clients
#        for {
#          select {
#          case msg := <-messages:
#            // Broadcast incoming message to all
#            // clients' outgoing message channels.
#            for cli := range clients {
#              cli <- msg
#            }
#          case cli := <-entering:
#            clients[cli] = true
#          case cli := <-leaving:
#            delete(clients, cli)
#            close(cli)
#          }
#        }
#      }
#    < src..
   ..src > go
     type client chan<- string          // un canal de mensajes salientes

     var (
       entering = make(chan client)
       leaving = make(chan client)
       messages = make(chan string)     // todos los mensajes de los clientes entrantes
     )

     func broadcaster() {
       clients := make(map[client]bool) // todos los clientes conectados
       for {
         select {
         case msg := <-messages:
           // Difusion de mensajes entrantes a todos
           // Canales de mensajes salientes de los clientes.
           for cli := range clients {
             cli <- msg
           }
         case cli := <-entering:
           clients[cli] = true
         case cli := <-leaving:
           delete(clients, cli)
           close(cli)
         }
       }
     }
   < src..

#    The broadcaster listens on the global @c(entering) and @c(leaving) channels
#    for announcements of arriving and departing @c(clients). When it receives one
#    of these events, it updates the clients set, and if the event was a
#    departure, it closes the client’s outgoing message channel. The broadcaster
#    also listens for events on the global @c(messages) channel, to which each
#    client sends all its incoming messages. When the broadcaster receives one of
#    these events, it broadcasts the message to every connected client.
   La emisora escucha los canales globales @c(entering) y @c(leaving) para
   anuncios la llegada y salida de @c(clients). Cuando recibe uno de estos
   eventos, actualiza el conjunto de clientes, y si el evento fue una salida,
   cierra el canal de mensajes de salida del cliente. La emisora tambien escucha
   los eventos globales en el canal @c(messages), a la que cada cliente envia
   todos sus mensajes entrantes. Cuando el emisor recibe uno de estos eventos,
   transmite el mensaje a cada cliente conectado.

#    Now let’s look at the per-client goroutines. The @c(handleConn) function
#    creates a new outgoing message channel for its client and announces the
#    arrival of this client to the broadcaster over the @c(entering) channel. Then
#    it reads every line of text from the client, sending each line to the
#    broadcaster over the global incoming message channel, prefixing each message
#    with the identity of its sender. Once there is nothing more to read from the
#    client, @c(handleConn) announces the departure of the client over the
#    @c(leaving) channel and closes the connection.
   Ahora echemos un vistazo a las gorutinas por cliente. La funcion
   @c(handleConn) crea un nuevo canal de mensaje de salida para su cliente y
   anuncia la llegada de este cliente a la emisora atravez del canal
   @c(entering). A continuacion, lee cada linea de texto del cliente, enviando
   cada linea a la emisora ​​a traves del canal de mensajes entrantes global,
   prefijando cada mensaje con la identidad de su remitente. Una vez que no hay
   nada mas que leer desde el cliente, @c(handleConn) anuncia la salida del
   cliente a traves del canal @c(leaving) y cierra la conexion.

#    ..src > go
#      func handleConn(conn net.Conn) {
#        ch := make(chan string) // outgoing client messages
#        go clientWriter(conn, ch)
#
#        who := conn.RemoteAddr().String()
#        ch <- "You are " + who
#        messages <- who + " has arrived"
#        entering <- ch
#
#        input := bufio.NewScanner(conn)
#        for input.Scan() {
#          messages <- who + ": " + input.Text()
#        }
#        // NOTE: ignoring potential errors from input.Err()
#
#        leaving <- ch
#        messages <- who + " has left"
#        conn.Close()
#      }
#
#      func clientWriter(conn net.Conn, ch <-chan string) {
#        for msg := range ch {
#          fmt.Fprintln(conn, msg) // NOTE: ignoring network errors
#        }
#      }
#    < src..
   ..src > go
     func handleConn(conn net.Conn) {
       ch := make(chan string) // mensajes salientes del cliente
       go clientWriter(conn, ch)

       who := conn.RemoteAddr().String()
       ch <- "You are " + who
       messages <- who + " has arrived"
       entering <- ch

       input := bufio.NewScanner(conn)
       for input.Scan() {
         messages <- who + ": " + input.Text()
       }
       // NOTA: ignorando errores potenciales de input.Err()

       leaving <- ch
       messages <- who + " has left"
       conn.Close()
     }

     func clientWriter(conn net.Conn, ch <-chan string) {
       for msg := range ch {
         fmt.Fprintln(conn, msg) // NOTA: ignorando errores de red
       }
     }
   < src..

#    In addition, @c(handleConn) creates a @c(clientWriter) goroutine for each
#    client that receives messages broadcast to the client’s outgoing message
#    channel and writes them to the client’s network connection. The client
#    writer’s loop terminates when the broadcaster closes the channel after
#    receiving a @c(leaving) notification.
   Ademas, @c(handleConn) crea una gorutina @c(clientWriter) para cada cliente
   que recibe los mensajes difundidos al canal de mensaje de salida del cliente
   y los escribe en la conexion de red del cliente. El bucle del criente
   escritor termina cuando el difusor cierra el canal despues de recibir una
   notificacion de salida (@c(leaving)).

#    The display below shows the server in action with two clients in separate
#    windows on the same computer, using @c(netcat) to chat:
   La pantalla muestra el servidor en accion con dos clientes en ventanas
   separadas en el mismo equipo, utilizando @c(netcat) para charlar:

#    ..src > sh
#      $ go build gopl.io/ch8/chat
#      $ go build gopl.io/ch8/netcat3
#    < src..
   ..src > sh
     $ go build gopl.io/ch8/chat
     $ go build gopl.io/ch8/netcat3
   < src..

#    ..cols >
   ..cols >

#      ..src > sh
#        $ ./chat &
#        $ ./netcat3
#        You are 127.0.0.1:64208
#        127.0.0.1:64211 has arrived
#        Hi!
#        127.0.0.1:64208: Hi!
#
#        127.0.0.1:64211: Hi yourself.
#        ^C
#      < src..
     ..src > sh
       $ ./chat &
       $ ./netcat3
       You are 127.0.0.1:64208
       127.0.0.1:64211 has arrived
       Hi!
       127.0.0.1:64208: Hi!

       127.0.0.1:64211: Hi yourself.
       ^C
     < src..

#      ..src > sh
#        $ ./netcat3
#        You are 127.0.0.1:64216
#
#        127.0.0.1:64211: Welcome.
#
#        127.0.0.1:64211 has left
#      < src..
     ..src > sh
       $ ./netcat3
       You are 127.0.0.1:64216

       127.0.0.1:64211: Welcome.

       127.0.0.1:64211 has left
     < src..

#      ::
     ::

#      ..src > sh
#        $ ./netcat3
#        You are 127.0.0.1:64211
#        127.0.0.1:64208: Hi!
#        Hi yourself.
#        127.0.0.1:64211: Hi yourself.
#
#        127.0.0.1:64208 has left
#
#        127.0.0.1:64216 has arrived
#        Welcome.
#        127.0.0.1:64211: Welcome.
#        ^C
#      < src..
     ..src > sh
       $ ./netcat3
       You are 127.0.0.1:64211
       127.0.0.1:64208: Hi!
       Hi yourself.
       127.0.0.1:64211: Hi yourself.

       127.0.0.1:64208 has left

       127.0.0.1:64216 has arrived
       Welcome.
       127.0.0.1:64211: Welcome.
       ^C
     < src..


#    While hosting a chat session for @m(n) clients, this program runs @m(2n+2)
#    concurrently communicating goroutines, yet it needs no explicit locking
#    operations (@l(#Section 9.2<>§9.2)). The @c(clients) map is confined to a
#    single goroutine, the broadcaster, so it cannot be accessed concurrently. The
#    only variables that are shared by multiple goroutines are channels and
#    instances of @c(net.Conn), both of which are @e(concurrency safe). We’ll talk
#    more about confinement, concurrency safety, and the implications of sharing
#    variables across goroutines in the next chapter.
   Al hospedar una sesion de chat para @m(n) clientes, este programa ejecuta
   @m(2n+2) gorutinas al mismo tiempo que se comunican, sin embargo, no necesita
   operaciones de bloqueo explicitas (@l(#Seccion 9.2<>§9.2)). El mapa
   @c(clients) se limita a solo una gorutina, el emisor, por lo que no se puede
   acceder al mismo tiempo. Las unicas variables que son compartidos por
   gorutinas multiples son canales e instancias de @c(net.Conn), ambos
   concurrentemente seguros. Hablaremos mas sobre el confinamiento, la seguridad
   de la concurrencia y las implicaciones de compartir las variables a traves de
   gorutinas en el proximo capitulo.

#    @b(Exercise 8.12): Make the broadcaster announce the current set of clients
#    to each new arrival.  This requires that the @c(clients) set and the
#    @c(entering) and leaving channels record the client name too.
   @b(Ejercicio 8.12): Hacer que el emisor anuncia el conjunto actual de
   clientes para cada nueva llegada. Esto requiere que los clientes establecidos
   (@c(clients)) y los canales de entrada (@c(entering) y salida registren
   tambien el nombre del cliente.

#    @b(Exercise 8.13): Make the chat server disconnect idle clients, such as
#    those that have sent no messages in the last five minutes. Hint: calling
#    @c[conn.Close()] in another goroutine unblocks active @c(Read) calls such as
#    the one done by @c[input.Scan()].
   @b(Ejercicio 8.13): Hacer que el servidor de chat desconecte clientes
   inactivos, como los que no han enviado ningun mensaje en los ultimos cinco
   minutos. Sugerencia: llamar a @c[conn.Close()] en otra gorutina desbloquea
   las llamadas activas @c(Read) como la realizada por @c[input.Scan()].

#    @b(Exercise 8.14): Change the chat server’s network protocol so that each
#    client provides its name on entering. Use that name instead of the network
#    address when prefixing each message with its sender’s identity.
   @b(Ejercicio 8.14): Cambiar el protocolo de red del servidor de chat para que
   cada cliente proporcione su nombre al entrar. Utilice ese nombre en lugar de
   la direccion de red cuando prefija cada mensaje con la identidad de su
   remitente.

#    @b(Exercise 8.15): Failure of any client program to read data in a timely
#    manner ultimately causes all clients to get stuck. Modify the broadcaster to
#    skip a message rather than wait if a client writer is not ready to accept
#    it. Alternatively, add buffering to each client’s outgoing message channel so
#    that most messages are not dropped; the broadcaster should use a non-blocking
#    send to this channel.
   @b(Ejercicio 8.15): El fallo de cualquier programa cliente para leer datos de
   manera oportuna en ultima instancia, hace que todos los clientes queden
   atascados. Modifique el emisor ​​para omitir un mensaje en lugar de esperar si
   un escritor de cliente no esta listo para aceptarlo. Como alternativa,
   agregue un bufer en el canal de mensajes saliente de cada cliente para que la
   mayoria de los mensajes no se descarten; El emisor debe utilizar un envio sin
   bloqueo a este canal.

# * Chapter 9 <> Concurrency with Shared Variables
* Capitulo 9 <> Concurrencia con Variables Compartidas

#   In the previous chapter, we presented several programs that use goroutines and
#   channels to express concurrency in a direct and natural way. However, in doing
#   so, we glossed over a number of important and subtle issues that programmers
#   must bear in mind when writing concurrent code.
  En el capitulo anterior presentamos varios programas que utilizan gorutinas y
  canales para expresar la concurrencia de forma directa y natural. Sin embargo,
  al hacerlo, pasamos revista a una serie de cuestiones importantes y sutiles
  que los programadores deben tener en cuenta al escribir codigo concurrente.

#   In this chapter, we’ll take a closer look at the mechanics of concurrency. In
#   particular, we’ll point out some of the problems associated with sharing
#   variables among multiple goroutines, the analytical techniques for recognizing
#   those problems, and the patterns for solving them.  Finally, we’ll explain
#   some of the technical differences between goroutines and operating system
#   threads.
  En este capitulo, examinaremos mas de cerca la mecanica de la concurrencia. En
  particular, señalaremos algunos de los problemas asociados con el intercambio
  de variables entre multiples gorutinas, las tecnicas analiticas para reconocer
  esos problemas y los patrones para resolverlos. Finalmente, explicaremos
  algunas de las diferencias tecnicas entre gorutinas y los hilos del sistema
  operativo.

# ** Section 9.1 <> Race Conditions
** Seccion 9.1 <> Condiciones de Carrera

#    In a sequential program, that is, a program with only one goroutine, the
#    steps of the program happen in the familiar execution order determined by the
#    program logic. For instance, in a sequence of statements, the first one
#    happens before the second one, and so on. In a program with two or more
#    goroutines, the steps within each goroutine happen in the familiar order, but
#    in general we don’t know whether an event @e(x) in one goroutine happens
#    before an event @e(y) in another goroutine, or happens after it, or is
#    simultaneous with it. When we cannot confidently say that one event
#    @e(happens before) the other, then the events @e(x) and @e(y) are
#    @e(concurrent).
   En un programa secuencial, es decir, un programa con solo una gorutina, los
   pasos del programa ocurren en el orden de ejecucion familiar determinado por
   la logica del programa. Por ejemplo, en una secuencia de declaraciones, la
   primera sucede antes de la segunda, y asi sucesivamente. En un programa con
   dos o mas gorutinas, los pasos dentro de cada gorutina suceden en el orden
   familiar, pero, en general, no sabemos si un evento @e(x) en una gorutina
   sucede antes de un evento @e(y) en otra gorutina, o pasa despues de ella, o
   es simultaneo con ella. Cuando no podemos decir con confianza que un evento
   @e(ocurre antes) que el otro, entonces los eventos de @e(x) y @e(y) son
   @e(concurrentes).

#    Consider a function that works correctly in a sequential program. That
#    function is @e(concurrency-safe) if it continues to work correctly even when
#    called concurrently, that is, from two or more goroutines with no additional
#    synchronization. We can generalize this notion to a set of collaborating
#    functions, such as the methods and operations of a particular type. A type is
#    concurrency-safe if all its accessible methods and operations are
#    concurrency-safe.
   Considere una funcion que funcione correctamente en un programa secuencial.
   Esa funcion es @e(segura para la concurrencia) seguira trabajando
   correctamente incluso cuando se llame concurrentemente, es decir, a partir de
   dos o mas gorutinas sin sincronizacion adicional. Podemos generalizar esta
   nocion a un conjunto de funciones en colaboracion, como los metodos y
   operaciones de un tipo particular. Un tipo es seguro para la concurrencia si
   todos sus metodos y operaciones accesibles son seguros para la simultaneidad.

#    We can make a program concurrency-safe without making every concrete type in
#    that program concurrency-safe. Indeed, concurrency-safe types are the
#    exception rather than the rule, so you should access a variable concurrently
#    only if the documentation for its type says that this is safe. We avoid
#    concurrent access to most variables either by @e(confining) them to a single
#    goroutine or by maintaining a higher-level invariant of @e(mutual
#    exclusion). We’ll explain these terms in this chapter.
   Podemos hacer un programa seguro para la concurrencia sin hacer que cada tipo
   concreto en el programa sea seguro para la concurrencia. De hecho, los tipos
   concurrentemente seguros simultaneidad son la excepcion en lugar de la regla,
   por lo que debe acceder a una variable simultaneamente solo si la
   documentacion de su tipo indica que esto es seguro. Evitamos el acceso
   concurrente a la mayoria de las variables, ya sea mediante su
   @e(confinamiento) a una sola gorutina o manteniendo una invariante de mas
   alto nivel de exclusion mutua. Explicaremos estos terminos en este capitulo.

#    In contrast, exported package-level functions @e(are) generally expected to be
#    concurrency-safe.  Since package-level variables cannot be confined to a
#    single goroutine, functions that modify them must enforce mutual exclusion.
   En contarste, se espera que las funciones a nivel de paquete @e(sean)
   compatibles con la concurrencia. Ya que las variables de nivel de paquete no
   pueden limitarse a una sola gorutina, las funciones que las modifican deben
   imponer la exclusion mutua.

#    There are many reasons a function might not work when called concurrently,
#    including deadlock, livelock, and resource starvation. We don’t have space to
#    discuss all of them, so we’ll focus on the most important one, the @e(race
#    condition).
   Existen muchas razones por las que una funcion puede no funcionar cuando se
   llama concurrentement, incluyendo el punto muerto, el bloqueo vivo y la
   inanicion de recursos. No tenemos espacio para discutir todos ellos, por lo
   que nos centraremos en la mas importante, la @e(condicion de carrera).

#    A race condition is a situation in which the program does not give the
#    correct result for some interleavings of the operations of multiple
#    goroutines. Race conditions are pernicious because they may remain latent in
#    a program and appear infrequently, perhaps only under heavy load or when
#    using certain compilers, platforms, or architectures. This makes them hard to
#    reproduce and diagnose.
   Una condicion de carrera es una situacion en la que el programa no da el
   resultado correcto para algunas intercalaciones de las operaciones de
   multiples gorutinas. Las condiciones de carrera son perniciosas porque pueden
   permanecer latentes en un programa y aparecen con poca frecuencia, quizas
   solo bajo carga pesada o cuando se utilizan ciertos compiladores, plataformas
   o arquitecturas. Esto los hace dificiles de reproducir y diagnosticar.

#    It is traditional to explain the seriousness of race conditions through the
#    metaphor of financial loss, so we’ll consider a simple bank account program.
   Es tradicional para explicar la gravedad de las condiciones de la carrera a
   traves de la metafora de la perdida financiera, por lo que vamos a considerar
   un programa de cuenta bancaria simple.

#    ..src > go
#      // Package bank implements a bank with only one account.
#      package bank
#
#      var balance int
#
#      func Deposit(amount int) { balance = balance + amount }
#
#      func Balance() int { return balance }
#    < src..
   ..src > go
     // El paquete bank implementa un banco con solo una cuenta.
     package bank

     var balance int

     func Deposit(amount int) { balance = balance + amount }

     func Balance() int { return balance }
   < src..

#    (We could have written the body of the @c(Deposit) function as @c(balance +=
#    amount), which is equivalent, but the longer form will simplify the
#    explanation.)
   (Podriamos haber escrito el cuerpo de la funcion @c(Deposit) como @c(balance
   += amount), lo que es equivalente, pero la forma mas larga simplificara la
   explicacion.)

#    For a program this trivial, we can see at a glance that any sequence of calls
#    to @c(Deposit) and @c(Balance) will give the right answer, that is,
#    @c(Balance) will report the sum of all amounts previously deposited. However,
#    if we call these functions not in a sequence but concurrently, @c(Balance) is
#    no longer guaranteed to give the right answer. Consider the following two
#    goroutines, which represent two transactions on a joint bank account:
   Para este programa trivial, podemos ver a simple vista que cualquier
   secuencia de llamadas a @c(Deposit) y @c(Balance) dara la respuesta correcta,
   es decir, @c(Balance) reportara la suma de todas las cantidades depositadas
   previamente. Sin embargo, si llamamos a estas funciones no en una secuencia,
   sino al mismo tiempo, no se garantiza que @c(Balance) de la respuesta
   correcta. Considere las dos siguientes gorutinas, que representan dos
   transacciones en una cuenta bancaria conjunta:

#    ..src > go
#      // Alice:
#      go func() {
#        bank.Deposit(200)                // A1
#        fmt.Println("=", bank.Balance()) // A2
#      }()
#
#      // Bob:
#      go bank.Deposit(100)               // B
#    < src..
   ..src > go
     // Alice:
     go func() {
       bank.Deposit(200)                // A1
       fmt.Println("=", bank.Balance()) // A2
     }()

     // Bob:
     go bank.Deposit(100)               // B
   < src..

#    Alice deposits $200, then checks her balance, while Bob deposits $100. Since
#    the steps @c(A1) and @c(A2) occur concurrently with @c(B), we cannot predict
#    the order in which they happen. Intuitively, it might seem that there are
#    only three possible orderings, which we’ll call @"(Alice first,) @"(Bob
#    first,) and @"(Alice/Bob/Alice.) The following table shows the value of the
#    balance variable after each step. The quoted strings represent the printed
#    balance slips.
   Alice deposita $200, luego comprueba su balance, mientras que Bob deposita
   $100. Dado que los pasos @c(A1) y @c(A2) se producen simultaneamente con @c(B), no
   podemos predecir el orden en que se producen. Intuitivamente, podria parecer
   que solo hay tres posibles ordenaciones, que llamaremos a @"(Alicia primero),
   a @"(Bob primero), y @"(Alice/Bob/Alice). La siguiente tabla muestra el
   valor de la variable de balance despues de cada paso. Las cadenas entre
   comillas representan los resbalones impresos.

#    ..pre >
#      Alice first             Bob first          Alice/Bob/Alice
#                0                     0                        0
#        A1    200             B     100                A1    200
#        A2 "= 200"            A1    300                B     300
#        B     300             A2 "= 300"               A2 "= 300"
   ..pre >
     Alice primero           Bob primero          Alice/Bob/Alice
                 0                     0                        0
         A1    200             B     100                A1    200
         A2 "= 200"            A1    300                B     300
         B     300             A2 "= 300"               A2 "= 300"


#    In all cases the final balance is $300. The only variation is whether Alice’s
#    balance slip includes Bob’s transaction or not, but the customers are
#    satisfied either way.
   En todos los casos el balance es de $300. La unica variacion es si el balance
   de Alice incluye la transaccion de Bob o no, pero los clientes estan
   satisfechos de cualquier manera.

#    But this intuition is wrong. There is a fourth possible outcome, in which
#    Bob’s deposit occurs in the middle of Alice’s deposit, after the balance has
#    been read (@c(balance + amount)) but before it has been updated (@c(balance =
#    ...)), causing Bob’s transaction to disappear. This is because Alice’s
#    deposit operation @c(A1) is really a sequence of two operations, a read and a
#    write; call them @c(A1r) and @c(A1w). Here’s the problematic interleaving:
   Pero esta intuicion es incorrecta. Hay una cuarto resultado posible, en el
   que el deposito de Bob se produce en medio de deposito de Alice, despues de
   que el equilibrio se ha leido (@c(balance + amount)), pero antes de que haya
   sido actualizada (@c(balance = ...)), haciendo que la transaccion de Bob
   desaparezca. Esto se debe a que la operacion de deposito de Alice @c(A1) es
   realmente una secuencia de dos operaciones, una lectura y una escritura;
   llamarlos @c(A1r) y @c(A1w). Aqui esta la intercalacion problematica:

#    ..pre >
#      Data race
#               0
#      A1r      0          ... = balance + amount
#      B      100
#      A1w    200          balance = ...
#      A2  "= 200"
   ..pre >
     Data race
              0
     A1r      0          ... = balance + amount
     B      100
     A1w    200          balance = ...
     A2  "= 200"


#    After @c(A1r), the expression @c(balance + amount) evaluates to 200, so this
#    is the value written during @c(A1w), despite the intervening deposit. The
#    final balance is only $200. The bank is $100 richer at Bob’s expense.
   Despues de @c(A1r), la expresion @c(balance + amount) se evalua a 200, por lo
   que este es el valor escrito durante @c(A1w), a pesar del deposito
   intermedio. El saldo final es de solo $200. El banco es $100 mas rico a
   expensas de Bob.

#    This program contains a particular kind of race condition called a @c(data
#    race). A data race occurs whenever two goroutines access the same variable
#    concurrently and at least one of the accesses is a write.
   Este programa contiene un determinado tipo de condicion de carrera llamado
   @c(carrera de datos). Una carrera de datos ocurre cuando dos gorutinas
   acceden simultaneamente a la misma variable y al menos uno de los accesos es
   una escritura.

#    Things get even messier if the data race involves a variable of a type that
#    is larger than a single machine word, such as an interface, a string, or a
#    slice. This code updates @c(x) concurrently to two slices of different
#    lengths:
   Las cosas se ponen aun mas desordenadas si la carrera de datos implica una
   variable de un tipo que es mas grande que una sola palabra de maquina, como
   una interfaz, una cadena o un slice. Este codigo actualiza @c(x)
   concurrentemente a dos slices de diferentes longitudes:

#    ..src > go
#      var x []int
#      go func() { x = make([]int, 10) }()
#      go func() { x = make([]int, 1000000) }()
#      x[999999] = 1 // NOTE: undefined behavior; memory corruption possible!
#    < src..
   ..src > go
     var x []int
     go func() { x = make([]int, 10) }()
     go func() { x = make([]int, 1000000) }()
     x[999999] = 1 // NOTA: comportamiento no definido; posible corrupcion de memoria!
   < src..

#    The value of @c(x) in the final statement is not defined; it could be nil, or
#    a slice of length 10, or a slice of length 1,000,000. But recall that there
#    are three parts to a slice: the pointer, the length, and the capacity. If the
#    pointer comes from the first call to make and the length comes from the
#    second, @c(x) would be a chimera, a slice whose nominal length is 1,000,000
#    but whose underlying array has only 10 elements. In this eventuality, storing
#    to element 999,999 would clobber an arbitrary faraway memory location, with
#    consequences that are impossible to predict and hard to debug and
#    localize. This semantic minefield is called @e(undefined behavior) and is
#    well known to C programmers; fortunately it is rarely as troublesome in Go as
#    in C.
   El valor de @c(x) en la declaracion final no esta definido; Podria ser nil, o
   un slice de longitud 10, o un slice de longitud 1,000,000. Pero recuerda que
   hay tres partes en un slice: el puntero, la longitud y la capacidad. Si el
   puntero viene de la primera llamada a realizar y la duracion viene de la
   segunda, @c(x) sera una quimera, un slice cuya longitud nominal es de
   1,000,000, pero cuya matriz subyacente tiene solo 10 elementos. En esta
   eventualidad, el almacenamiento en el elemento 999.999 bloquearia una
   ubicacion de memoria aleatoria arbitraria, con consecuencias imposibles de
   predecir y dificiles de depurar y localizar. Este campo de minas semantica se
   llama un @e(comportamiento indefinido) y es bien conocido por los
   programadores de C; Afortunadamente rara vez es tan problematico en Go como
   en C.

#    Even the notion that a concurrent program is an interleaving of several
#    sequential programs is a false intuition. As we’ll see in @l(#Section 9.4),
#    data races may have even stranger outcomes.  Many programmers—even some very
#    clever ones—will occasionally offer justifications for known data races in
#    their programs: @"(the cost of mutual exclusion is too high,) @"(this logic
#    is only for logging,) @"(I don’t mind if I drop some messages,) and so
#    on. The absence of problems on a given compiler and platform may give them
#    false confidence. A good rule of thumb is that @e(there is no such thing as a
#    benign data race). So how do we avoid data races in our programs?
   Incluso la nocion de que un programa concurrente es una intercalacion de
   varios programas secuenciales es una falsa intuicion. Como veremos en la
   @l(#Seccion 9.4), las carreras de datos pueden tener resultados aun mas
   extrañas. Muchos programadores–incluso algunos muy inteligentes–en ocasiones
   ofrecen justificaciones para carreras de datos conocidos en sus programas:
   @"(el costo de la exclusion mutua es demasiado alto), @"(esta logica es solo
   para el registro), @"(no me importa si dejo caer algunos mensajes), y asi
   sucesivamente. La ausencia de problemas en un compilador y una plataforma
   dados puede darles una falsa confianza. Una buena regla general es que no hay
   tal cosa como una carrera de datos benigna. Entonces, ¿como evitamos las
   carreras de datos en nuestros programas?

#    We’ll repeat the definition, since it is so important: A data race occurs
#    whenever two goroutines access the same variable concurrently and at least
#    one of the accesses is a write. It follows from this definition that there
#    are three ways to avoid a data race.
   Vamos a repetir la definicion, ya que es tan importante: Una carrera de datos se
   produce cuando dos gorutinas acceder a la misma variable al mismo tiempo y al
   menos uno de los accesos es una escritura. De esta definicion se deduce que
   hay tres maneras de evitar una carrera de datos.

#    The first way is not to write the variable. Consider the map below, which is
#    lazily populated as each key is requested for the first time. If @c(Icon) is
#    called sequentially, the program works fine, but if @c(Icon) is called
#    concurrently, there is a data race accessing the map.
   La primera manera es no escribir la variable. Considere el siguiente mapa,
   que es poblado perezosamente, ya que cada clave se solicita por primera
   vez. Si @c(Icon) se llama secuencialmente, el programa funciona bien, pero si
   @c(Icon) se llama al mismo tiempo, hay una carrera de datos accediendo al
   mapa.

#    ..src > go
#      var icons = make(map[string]image.Image)
#
#      func loadIcon(name string) image.Image
#
#      // NOTE: not concurrency-safe!
#      func Icon(name string) image.Image {
#        icon, ok := icons[name]
#        if !ok {
#          icon = loadIcon(name)
#          icons[name] = icon
#        }
#        return icon
#      }
#    < src..
   ..src > go
     var icons = make(map[string]image.Image)

     func loadIcon(name string) image.Image

     // NOTA: no es seguro para la concurrencia!
     func Icon(name string) image.Image {
       icon, ok := icons[name]
       if !ok {
         icon = loadIcon(name)
         icons[name] = icon
       }
       return icon
     }
   < src..

#    If instead we initialize the map with all necessary entries before creating
#    additional goroutines and never modify it again, then any number of
#    goroutines may safely call @c(Icon) concurrently since each only reads the
#    map.
   Si en lugar de eso inicializamos el mapa con todas las entradas necesarias
   antes de crear gorutinas adicionales y nunca lo modificamos de nuevo,
   entonces cualquier numero de gorutinas puede llamar de forma segura a
   @c(Icon) simultaneamente puesto que cada uno solo lee el mapa.

#    ..src > go
#      var icons = map[string]image.Image{
#        "spades.png":   loadIcon("spades.png"),
#        "hearts.png":   loadIcon("hearts.png"),
#        "diamonds.png": loadIcon("diamonds.png"),
#        "clubs.png":    loadIcon("clubs.png"),
#      }
#
#      // Concurrency-safe.
#      func Icon(name string) image.Image { return icons[name] }
#    < src..
   ..src > go
     var icons = map[string]image.Image{
       "spades.png":   loadIcon("spades.png"),
       "hearts.png":   loadIcon("hearts.png"),
       "diamonds.png": loadIcon("diamonds.png"),
       "clubs.png":    loadIcon("clubs.png"),
     }

     // Seguro para la concurrencia.
     func Icon(name string) image.Image { return icons[name] }
   < src..

#    In the example above, the @c(icons) variable is assigned during package
#    initialization, which @e(happens before) the program’s main function starts
#    running. Once initialized, @c(icons) is never modified. Data structures that
#    are never modified or are immutable are inherently concurrency-safe and need
#    no synchronization. But obviously we can’t use this approach if updates are
#    essential, as with a bank account.
   En el ejemplo anterior, la variable @c(icons) se asigna durante la
   inicializacion del paquete, lo que ocurre antes de que comience la funcion
   principal del programa. Una vez inicializado, @c(icons) no se modifica. Las
   estructuras de datos que nunca se modifican o son inmutables son
   intrinsecamente seguras y no necesitan sincronizacion. Pero, obviamente, no
   podemos utilizar este enfoque si las actualizaciones son esenciales, como con
   una cuenta bancaria.

#    The second way to avoid a data race is to avoid accessing the variable from
#    multiple goroutines. This is the approach taken by many of the programs in
#    the previous chapter. For example, the main goroutine in the concurrent web
#    crawler (@l(#Section 8.6<>§8.6)) is the sole goroutine that accesses the
#    @c(seen) map, and the @c(broadcaster) goroutine in the chat server
#    (@l(#Section 8.10<>§8.10)) is the only goroutine that accesses the
#    @c(clients) map. These variables are @e(confined) to a single goroutine.
   La segunda forma de evitar una carrera de datos es evitar el acceso a la
   variable desde multiples gorutinas. Este es el enfoque adoptado por muchos de
   los programas del capitulo anterior. Por ejemplo, la gorutina principal en el
   rastreador web concurrente (@l(#Seccion 8.6<>§8.6)) es la unica gorutina que
   tiene acceso a el mapa @c(seen) y la gorutina @c(broadcaster) en el servidor
   de chat (@l(#Seccion 8.10<>§8.10)) es la unica gorutina que accede al mapa
   @c(clients). Estas variables se limitan a una sola gorutina.

#    Since other goroutines cannot access the variable directly, they must use a
#    channel to send the confining goroutine a request to query or update the
#    variable. This is what is meant by the Go mantra @"(Do not communicate by
#    sharing memory; instead, share memory by communicating.) A goroutine that
#    brokers access to a confined variable using channel requests is called a
#    @e(monitor goroutine) for that variable. For example, the @c(broadcaster)
#    goroutine monitors access to the @c(clients) map.
   Ya que otras gorutinas no pueden acceder a la variable directamente, deben
   usar un canal para enviar al gorutina de confinamiento una solicitud para
   consultar o actualizar la variable. Esto es lo que se quiere decir con el
   mantra Go @"(No se comunique compartiendo memoria; en su lugar, comparta la
   memoria mediante la comunicacion). Una gorutina por la que los corredores
   acceden a una variable confinada usando solicitudes de canal se denomina
   @e(gorutina monitor) para esa variable. Por ejemplo, la gorutina
   @c(broadcaster) monitorea el acceso al mapa de clientes.

#    Here’s the bank example rewritten with the @c(balance) variable confined to a
#    monitor goroutine called @c(teller):
   Aqui esta el ejemplo del banco reescrito con la variable @c(balance)
   confinada a una gorutina monitor llamada @c(teller):

#    ..figure > @l(gopl.io/ch9/bank1/bank.go<>gopl.io/ch9/bank1)
   ..figure > @l(gopl.io/ch9/bank1/bank.go<>gopl.io/ch9/bank1)

#      ..src > go
#        // Package bank provides a concurrency-safe bank with one account.
#        package bank
#
#        var deposits = make(chan int) // send amount to deposit
#        var balances = make(chan int) // receive balance
#
#        func Deposit(amount int) { deposits <- amount }
#        func Balance() int       { return <-balances }
#
#        func teller() {
#          var balance int // balance is confined to teller goroutine
#          for {
#            select {
#            case amount := <-deposits:
#              balance += amount
#            case balances <- balance:
#            }
#          }
#        }
#
#        func init() {
#          go teller() // start the monitor goroutine
#        }
#      < src..
     ..src > go
       // El paquete bank seguro para la concurrencia con solo una cuenta.
       package bank

       var deposits = make(chan int) // enviar la cantidad a depositar
       var balances = make(chan int) // recive el balance

       func Deposit(amount int) { deposits <- amount }
       func Balance() int       { return <-balances }

       func teller() {
         var balance int // balance esta confinado a la gorutina teller
         for {
           select {
           case amount := <-deposits:
             balance += amount
           case balances <- balance:
           }
         }
       }

       func init() {
         go teller() // inicia la gorutina momitor
       }
     < src..


#    Even when a variable cannot be confined to a single goroutine for its entire
#    lifetime, confinement may still be a solution to the problem of concurrent
#    access. For example, it’s common to share a variable between goroutines in a
#    pipeline by passing its address from one stage to the next over a channel. If
#    each stage of the pipeline refrains from accessing the variable after sending
#    it to the next stage, then all accesses to the variable are sequential. In
#    effect, the variable is confined to one stage of the pipeline, then confined
#    to the next, and so on. This discipline is sometimes called @e(serial
#    confinement).
   Incluso cuando una variable no puede ser confinada a una sola gorutina
   durante toda su vida, el confinamiento todavia puede ser una solucion al
   problema del acceso concurrente. Por ejemplo, es comun compartir una variable
   entre gorutinas en una tuberia, pasando su direccion de una etapa a la
   siguiente a traves de un canal. Si cada etapa de la tuberia se abstiene de
   acceder a la variable despues de enviarla a la siguiente etapa, entonces
   todos los accesos a la variable son secuenciales. En efecto, la variable esta
   confinada a una etapa de la tuberia, luego confinada a la siguiente, y asi
   sucesivamente. Esta disciplina es a veces llamado el @e(confinamiento en serie).

#    In the example below, @c(Cakes) are serially confined, first to the @c(baker)
#    goroutine, then to the @c(icer) goroutine:
   En el siguiente ejemplo, @c(Cakes) se confina en serie, primero a la gorutina
   @c(baker), despues, a la gorutina @c(icer):

#    ..src > go
#      type Cake struct{ state string }
#
#      func baker(cooked chan<- *Cake) {
#        for {
#          cake := new(Cake)
#          cake.state = "cooked"
#          cooked <- cake // baker never touches this cake again
#        }
#      }
#
#      func icer(iced chan<- *Cake, cooked <-chan *Cake) {
#        for cake := range cooked {
#          cake.state = "iced"
#          iced <- cake   // icer never touches this cake again
#        }
#      }
#    < src..
   ..src > go
     type Cake struct{ state string }

     func baker(cooked chan<- *Cake) {
       for {
         cake := new(Cake)
         cake.state = "cooked"
         cooked <- cake // baker nunca toca este pastel de nuevo
       }
     }

     func icer(iced chan<- *Cake, cooked <-chan *Cake) {
       for cake := range cooked {
         cake.state = "iced"
         iced <- cake   // icer nunca toca este pastel de nuevo
       }
     }
   < src..

#    The third way to avoid a data race is to allow many goroutines to access the
#    variable, but only one at a time. This approach is known as @e(mutual
#    exclusion) and is the subject of the next section.
   La tercera manera de evitar una carrera de datos es permitir que muchas
   gorutinas accedan a la variable, pero solo una a la vez. Este enfoque se
   conoce como @e(exclusion mutua) y es el objeto de la siguiente seccion.

#    @b(Exercise 9.1): Add a function @c[Withdraw(amount int) bool] to the
#    @c(gopl.io/ch9/bank1) program. The result should indicate whether the
#    transaction succeeded or failed due to insufficient funds. The message sent
#    to the monitor goroutine must contain both the amount to withdraw and a new
#    channel over which the monitor goroutine can send the boolean result back to
#    @c(Withdraw).
   @b(Ejercicio 9.1): Añadir una funcion @c[Withdraw(amount int) bool] al
   programa @c(gopl.io/ch9/bank1). El resultado debe indicar si la transaccion
   tuvo exito o fracaso debido a fondos insuficientes. El mensaje enviado a la
   gorutina monitor debe contener tanto la cantidad a retirar y un nuevo canal
   por el cual la gorutina monitor puede enviar el resultado booleano de nuevo a
   @c(Withdraw).

# ** Section 9.2 <> Mutual Exclusion: @c(sync.Mutex)
** Seccion 9.2 <> Exclusion mutua: @c(sync.Mutex)

#    In @l(#Section 8.6), we used a buffered channel as a @e(counting semaphore)
#    to ensure that no more than 20 goroutines made simultaneous HTTP
#    requests. With the same idea, we can use a channel of capacity 1 to ensure
#    that at most one goroutine accesses a shared variable at a time.  A semaphore
#    that counts only to 1 is called a @e(binary semaphore).
   En la @l(#Seccion 8.6), se utilizo un canal con buffer como un @e(semaforo
   contador) para asegurar que no mas de 20 gorutinas hacen peticiones HTTP
   simultaneas. Con la misma idea, podemos usar un canal de capacidad 1 para
   asegurar que a lo sumo una gorutina acceda a una variable compartida a la
   vez. Un semaforo que cuenta solamente a 1 se denomina @e(semaforo binario).

#    ..figure > @l(gopl.io/ch9/bank2/bank.go<>gopl.io/ch9/bank2)
   ..figure > @l(gopl.io/ch9/bank2/bank.go<>gopl.io/ch9/bank2)

#      ..src > go
#        var (
#          sema    = make(chan struct{}, 1) // a binary semaphore guarding balance
#          balance int
#        )
#
#        func Deposit(amount int) {
#          sema <- struct{}{} // acquire token
#          balance = balance + amount
#          <-sema // release token
#        }
#
#        func Balance() int {
#          sema <- struct{}{} // acquire token
#          b := balance
#          <-sema // release token
#          return b
#        }
#      < src..
     ..src > go
       var (
         sema    = make(chan struct{}, 1) //  un semaforo binario custodia balance
         balance int
       )

       func Deposit(amount int) {
         sema <- struct{}{} // aquirir token
         balance = balance + amount
         <-sema             // liberar token
       }

       func Balance() int {
         sema <- struct{}{} // aquirir token
         b := balance
         <-sema             // liberar token
         return b
       }
     < src..


#    This pattern of @e(mutual exclusion) is so useful that it is supported
#    directly by the @e(Mutex) type from the @c(sync) package. Its @c(Lock) method
#    acquires the token (called a @e(lock)) and its @c(Unlock) method releases it:
   Este patron de @e(exclusion mutua) es tan util que esta soportado
   directamente por el tipo de objeto @c(mutex) del paquete @c(sync). Su metodo
   @c(Lock) adquiere el token (llamado @e(bloqueo)) y su metodo @c(Unlock) lo
   libera:

#    ..figure > @l(gopl.io/ch9/bank3/bank.go<>gopl.io/ch9/bank3)
   ..figure > @l(gopl.io/ch9/bank3/bank.go<>gopl.io/ch9/bank3)

#      ..src > go
#        import "sync"
#
#        var (
#          mu      sync.Mutex // guards balance
#          balance int
#        )
#
#        func Deposit(amount int) {
#          mu.Lock()
#          balance = balance + amount
#          mu.Unlock()
#        }
#
#        func Balance() int {
#          mu.Lock()
#          b := balance
#          mu.Unlock()
#          return b
#        }
#      < src..
     ..src > go
       import "sync"

       var (
         mu      sync.Mutex // custodia balance
         balance int
       )

       func Deposit(amount int) {
         mu.Lock()
         balance = balance + amount
         mu.Unlock()
       }

       func Balance() int {
         mu.Lock()
         b := balance
         mu.Unlock()
         return b
       }
     < src..


#    Each time a goroutine accesses the variables of the bank (just @c(balance)
#    here), it must call the mutex’s @c(Lock) method to acquire an exclusive
#    lock. If some other goroutine has acquired the lock, this operation will
#    block until the other goroutine calls @c(Unlock) and the lock becomes
#    available again. The mutex @e(guards) the shared variables. By convention,
#    the variables guarded by a mutex are declared immediately after the
#    declaration of the mutex itself. If you deviate from this, be sure to
#    document it.
   Cada vez que una gorutina accede a las variables del banco (aqui solo
   @c(balance)), debe llamar a la metodo @c(Lock) de mutex para adquirir un
   bloqueo exclusivo. Si alguna otra gorutina ha adquirido el bloqueo, esta
   operacion se bloqueara hasta que la otra gorutina llame a @c(Unlock) y el
   bloqueo vuelva a estar disponible. La exclusion mutua @e(custodia) las
   variables compartidas. Por convencion, las variables custodiadas por un mutex
   se declaran inmediatamente despues de la declaracion del propio mutex. Si se
   desvia de esto, asegurese de documentarlo.

#    The region of code between @c(Lock) and @c(Unlock) in which a goroutine is
#    free to read and modify the shared variables is called a @e(critical
#    section). The lock holder’s call to @c(Unlock) @e(happens before) any other
#    goroutine can acquire the lock for itself. It is essential that the goroutine
#    release the lock once it is finished, on all paths through the function,
#    including error paths.
   La region de codigo entre @c(Lock) y @c(Unlock) en la que un gorutina es
   libre de leer y modificar las variables compartidas se denomina @e(seccion
   critica). Llama a @c(Unlock) de parte del poseeodor del bloqueo @e(ocurrira
   antes) de que cualquier otra gorutina pueda adquirir el bloqueo para si. Es
   esencial que la gorutina libire el bloqueo una vez que haya terminado, en
   toda las rutas a traves de la funcion, incluyendo rutas de error.

#    The bank program above exemplifies a common concurrency pattern. A set of
#    exported functions encapsulates one or more variables so that the only way to
#    access the variables is through these functions (or methods, for the
#    variables of an object). Each function acquires a mutex lock at the beginning
#    and releases it at the end, thereby ensuring that the shared variables are
#    not accessed concurrently. This arrangement of functions, mutex lock, and
#    variables is called a @e(monitor). (This older use of the word @"(monitor)
#    inspired the term @"(monitor goroutine.) Both uses share the meaning of a
#    broker that ensures variables are accessed sequentially.)
   El programa bancario anterior ejemplifica un patron de concurrencia comun. Un
   conjunto de funciones exportadas encapsula una o mas variables de manera que
   la unica forma de acceder a las variables es a traves de estas funciones (o
   metodos, para las variables de un objeto). Cada funcion adquiere un bloqueo
   mutex al principio y lo libera al final, asegurando asi que las variables
   compartidas no se acceden simultaneamente. Esta disposicion de las funciones
   de bloqueo, mutex y variables se denomina @e(monitor). (Este uso anterior de
   la palabra del monitor inspiro el termino @"(gorutina monitor). Ambos usos
   comparten el significado de un agente que asegura el acceso sequencial a las
   variables.)

#    Since the critical sections in the @c(Deposit) and @c(Balance) functions are
#    so short—a single line, no branching—calling @c(Unlock) at the end is
#    straightforward. In more complex critical sections, especially those in which
#    errors must be dealt with by returning early, it can be hard to tell that
#    calls to @c(Lock) and @c(Unlock) are strictly paired on all paths. Go’s
#    @c(defer) statement comes to the rescue: by deferring a call to @c(Unlock),
#    the critical section implicitly extends to the end of the current function,
#    freeing us from having to remember to insert @c(Unlock) calls in one or more
#    places far from the call to @c(Lock).
   Dado que las secciones criticas en las funciones @c(Deposit) y @c(Balance)
   son tan cortas–una sola linea, ninguna ramificacion–llamar a @c(Unlock) al
   final es sencillo. En las secciones criticas mas complejas, especialmente
   aquellas en los que los errores deben resolverse regregando antes, puede ser
   dificil saber que las llamadas a @c(Lock) y @c(Unlock) estan estrictamente
   emparejado en todas las rutas. La declaracion @c(defer) de Go viene al
   rescate: al diferir una llamada a @c(Unlock), la seccion critica se extiende
   implicitamente al final de la funcion actual, liberandonos de tener que
   insertar una llamada @c(Unlock) en uno o mas lugares lejos de la llamada a
   @c(Lock).

#    ..src > go
#      func Balance() int {
#        mu.Lock()
#        defer mu.Unlock()
#        return balance
#      }
#    < src..
   ..src > go
     func Balance() int {
       mu.Lock()
       defer mu.Unlock()
       return balance
     }
   < src..

#    In the example above, the @c(Unlock) executes @e(after) the return statement
#    has read the value of @c(balance), so the @c(Balance) function is
#    concurrency-safe. As a bonus, we no longer need the local variable @c(b).
   En el ejemplo anterior, @c(Unlock) se ejecuta @e(despues) de que la
   instruccion de retorno ha leido el valor de @c(balance), por lo que la
   funcion @c(Balance) es segura para la concurrencia. Como beneficio adicional,
   ya no necesitamos la variable local @c(b).

#    Furthermore, a deferred @c(Unlock) will run even if the critical section
#    panics, which may be important in programs that make use of @c(recover)
#    (@l(#Section 5.10<>§5.10)). A @c(defer) is marginally more expensive than an
#    explicit call to @c(Unlock), but not enough to justify less clear code. As
#    always with concurrent programs, favor clarity and resist premature
#    optimization. Where possible, use @c(defer) and let critical sections extend
#    to the end of a function.
   Por otra parte, un @c(Unlock) diferido funcionara incluso si la seccion
   critica entra en panico, lo que puede ser importante en los programas que
   hacen uso de @c(recover) (@l(#Seccion 5.10<>§5.10)). Un @c(defer) es
   ligeramente mas caro que una llamada explicita a @c(Unlock), pero no lo
   suficiente para justificar codigo de menos claro. En programas concurrentes,
   siempre favoresca la claridad y resista la optimizacion prematura. Siempre
   que sea posible, utilice @c(defer) y dejar que las secciones criticas se
   extienden hasta el final de una funcion.

#    Consider the @c(Withdraw) function below. On success, it reduces the balance
#    by the specified amount and returns @c(true). But if the account holds
#    insufficient funds for the transaction, @c(Withdraw) restores the balance and
#    returns @c(false).
   Considere la funcion @c(Withdraw) a continuacion. En caso de exito, reduce el
   balance en la cantidad especificada y devuelve @c(true). Pero si la cuenta
   tiene fondos suficientes para la transaccion, @c(Withdraw) restaura el
   balance y devuelve @c(false).

#    ..src > go
#      // NOTE: not atomic!
#      func Withdraw(amount int) bool {
#        Deposit(-amount)
#        if Balance() < 0 {
#          Deposit(amount)
#          return false // insufficient funds
#        }
#        return true
#      }
#    < src..
   ..src > go
     // NOTA: no atomico!
     func Withdraw(amount int) bool {
       Deposit(-amount)
       if Balance() < 0 {
         Deposit(amount)
         return false // fondos insuficientes
       }
       return true
     }
   < src..

#    This function eventually gives the correct result, but it has a nasty side
#    effect. When an excessive withdrawal is attempted, the balance transiently
#    dips below zero. This may cause a concurrent withdrawal for a modest sum to
#    be spuriously rejected. So if Bob tries to buy a sports car, Alice can’t pay
#    for her morning coffee. The problem is that Withdraw is not @e(atomic): it
#    consists of a sequence of three separate operations, each of which acquires
#    and then releases the mutex lock, but nothing locks the whole sequence.
   Esta funcion finalmente da el resultado correcto, pero tiene un efecto
   secundario desagradable. Cuando se intenta una retiro excesivo, el balance
   transitoriamente se sumerge por debajo de cero. Esto puede causar una
   retirada simultanea de una suma modesta que se rechazara espuriosamente. Asi
   que si Bob trata de comprar un coche deportivo, Alice no puede pagar por su
   cafe de la mañana. El problema es que @c(Withdraw) no es @e(atomico):
   consiste en una secuencia de tres operaciones separadas, cada una de las
   cuales adquiere y luego libera el bloqueo de exclusion mutua, pero nada
   bloquea toda la secuencia.

#    Ideally, @c(Withdraw) should acquire the mutex lock once around the whole
#    operation. However, this attempt won’t work:
   Idealmente, @c(Withdraw) debe adquirir el bloqueo mutex una vez alrededor de
   toda la operacion. Sin embargo, este intento no funcionara:

#    ..src > go
#      // NOTE: incorrect!
#      func Withdraw(amount int) bool {
#        mu.Lock()
#        defer mu.Unlock()
#        Deposit(-amount)
#        if Balance() < 0 {
#          Deposit(amount)
#          return false // insufficient funds
#        }
#        return true
#      }
#    < src..
   ..src > go
     // NOTA: incorrecto!
     func Withdraw(amount int) bool {
       mu.Lock()
       defer mu.Unlock()
       Deposit(-amount)
       if Balance() < 0 {
         Deposit(amount)
         return false // fondos insuficientes
       }
       return true
     }
   < src..

#    @c(Deposit) tries to acquire the mutex lock a second time by calling
#    @c[mu.Lock()], but because mutex locks are not @e(re-entrant)—it’s not
#    possible to lock a mutex that’s already locked—this leads to a deadlock where
#    nothing can proceed, and @c(Withdraw) blocks forever.
   @c(Deposit) intenta adquirir el bloqueo mutex una segunda vez llamando a
   @c[mu.Lock()], pero debido a que los bloqueos de exclusion mutua no son
   @e(reentrantes)–No es posible bloquear un mutex que ya esta bloqueado–esto
   lleva a un punto muerto en el que nada puede proceder, y @c(Withdraw) se
   bloqua para siempre.

#    There is a good reason Go’s mutexes are not re-entrant. The purpose of a
#    mutex is to ensure that certain invariants of the shared variables are
#    maintained at critical points during program execution. One of the invariants
#    is @"(no goroutine is accessing the shared variables,) but there may be
#    additional invariants specific to the data structures that the mutex
#    guards. When a goroutine acquires a mutex lock, it may assume that the
#    invariants hold. While it holds the lock, it may update the shared variables
#    so that the invariants are temporarily violated.  However, when it releases
#    the lock, it must guarantee that order has been restored and the invariants
#    hold once again. Although a re-entrant mutex would ensure that no other
#    goroutines are accessing the shared variables, it cannot protect the
#    additional invariants of those variables.
   Hay una buena razon para que los mutex de Go no vuelvan a entrar. El
   proposito de un mutex es asegurar que ciertos invariantes de las variables
   compartidas se mantengan en puntos criticos durante la ejecucion del
   programa. Una de las invariantes es que la @"(gorutina no esta accediendo a
   las variables compartidas), pero puede haber invariantes adicionales
   especificas a las estructuras de datos que custodia el mutex. Cuando una
   gorutina adquiere un bloqueo mutex, puede suponer que los invariantes se
   mantienen. Mientras mantiene el bloqueo, puede actualizar las variables
   compartidas para que los invariantes se violen temporalmente. Sin embargo,
   cuando se libera el bloqueo, debe garantizar que el orden ha sido restaurado
   y mantiene los invariantes una vez mas. Aunque un mutex reentrante aseguraria
   que ninguna otra parte acceda a las variables compartidas, no puede proteger
   las invariantes adicionales de esas variables.

#    A common solution is to divide a function such as @c(Deposit) into two: an
#    unexported function, @c(deposit), that assumes the lock is already held and
#    does the real work, and an exported function @c(Deposit) that acquires the
#    lock before calling @c(deposit). We can then express @c(Withdraw) in terms of
#    @c(deposit) like this:
   Una solucion comun es dividir una funcion como @c(Deposit) en dos: una
   funcion no exportada, @c(deposit), que asume que el bloqueo ya se retiene y
   hace el trabajo real, y una funcion exportada @c(Deposit) que adquiere el
   bloqueo antes de llamar a @c(deposit). Podemos expresar @c(Withdraw) en
   terminos de @c(deposit) de la siguiente manera:

#    ..src > go
#      func Withdraw(amount int) bool {
#        mu.Lock()
#        defer mu.Unlock()
#        deposit(-amount)
#        if balance < 0 {
#          deposit(amount)
#          return false // insufficient funds
#        }
#        return true
#      }
#
#      func Deposit(amount int) {
#        mu.Lock()
#        defer mu.Unlock()
#        deposit(amount)
#      }
#
#      func Balance() int {
#        mu.Lock()
#        defer mu.Unlock()
#        return balance
#      }
#
#      // This function requires that the lock be held.
#      func deposit(amount int) { balance += amount }
#    < src..
   ..src > go
     func Withdraw(amount int) bool {
       mu.Lock()
       defer mu.Unlock()
       deposit(-amount)
       if balance < 0 {
         deposit(amount)
         return false // fondos insuficientes
       }
       return true
     }

     func Deposit(amount int) {
       mu.Lock()
       defer mu.Unlock()
       deposit(amount)
     }

     func Balance() int {
       mu.Lock()
       defer mu.Unlock()
       return balance
     }

     // Esta funcion requiere que se mantenga el bloqueo.
     func deposit(amount int) { balance += amount }
   < src..

#    Of course, the @c(deposit) function shown here is so trivial that a realistic
#    @c(Withdraw) function wouldn’t bother calling it, but nonetheless it
#    illustrates the principle.
   Por supuesto, la funcion @c(deposit) mostrada aqui es tan trivial que una
   funcion @c(Withdraw) realista no se molestaria en llamarla, no obstante,
   ilustra el principio.

#    Encapsulation (@l(#Section 6.6<>§6.6)), by reducing unexpected interactions
#    in a program, helps us maintain data structure invariants. For the same
#    reason, encapsulation also helps us maintain concurrency invariants. When you
#    use a mutex, make sure that both it and the variables it guards are not
#    exported, whether they are package-level variables or the fields of a struct.
   La encapsulacion (@l(#Seccion 6.6<>§6.6)), mediante la reduccion de las
   interacciones inesperadas en un programa, nos ayuda a mantener la estructura
   de datos invariantes. Por la misma razon, la encapsulacion tambien nos ayuda
   a mantener invariantes concurrentes. Cuando utilice un mutex, asegurese de
   que tanto el como las variables que protege no se exportan, ya sean variables
   a nivel de paquete o campos de una estructura.

# ** Section 9.3 <> Read/Write Mutexes: @c(sync.RWMutex)
** Seccion 9.3 <> Mutex de Lectura/Escritura: @c(sync.RWMutex)

#    In a fit of anxiety after seeing his $100 deposit vanish without a trace, Bob
#    writes a program to check his bank balance hundreds of times a second. He
#    runs it at home, at work, and on his phone. The bank notices that the
#    increased traffic is delaying deposits and withdrawals, because all the
#    @c(Balance) requests run sequentially, holding the lock exclusively and
#    temporarily preventing other goroutines from running.
   En un ataque de ansiedad despues de ver su deposito de $100 desaparecer sin
   dejar rastro, Bob escribe un programa para comprobar su saldo bancario
   cientos de veces por segundo. El lo ejecuta en casa, en el trabajo, y en su
   telefono. El banco se da cuenta de que el aumento del trafico esta retrasando
   los depositos y retiros, porque todas las peticiones de @c(Balance) se
   ejecutan secuencialmente, manteniendo el bloqueo exclusivo, inpidiendo
   temporalmente otras gorutinas se ejecute.

#    Since the @c(Balance) function only needs to @e(read) the state of the
#    variable, it would in fact be safe for multiple @c(Balance) calls to run
#    concurrently, so long as no @c(Deposit) or @c(Withdraw) call is running. In
#    this scenario we need a special kind of lock that allows read-only operations
#    to proceed in parallel with each other, but write operations to have fully
#    exclusive access. This lock is called a @e(multiple readers, single writer)
#    lock, and in Go it’s provided by @c(sync.RWMutex):
   Dado que la funcion @c(Balance) solo tiene que leer el estado de la variable,
   de echo, seria seguro que multiples llamadas @c(Balance) se ejecuten
   concurrentemente, siempre y cuando no se ejecute ninguna llamada a
   @c(Deposit) o @c(Withdraw). En este escenario necesitamos un tipo especial de
   bloqueo que permita que las operaciones de solo lectura se realicen en
   paralelo entre si, pero que las operaciones de escritura tengan acceso
   totalmente exclusivo. Este bloqueo se denomina @e(lectores multiples,
   escritor unico), y en Go es proporcionado por @c(sync.RWMutex):

#    ..src > go
#      var mu sync.RWMutex
#      var balance int
#
#      func Balance() int {
#        mu.RLock() // readers lock
#        defer mu.RUnlock()
#        return balance
#      }
#    < src..
   ..src > go
     var mu sync.RWMutex
     var balance int

     func Balance() int {
       mu.RLock() // bloqueo de lectores
       defer mu.RUnlock()
       return balance
     }
   < src..

#    The @c(Balance) function now calls the @c(RLock) and @c(RUnlock) methods to
#    acquire and release a @e(readers) or @e(shared) lock. The @c(Deposit)
#    function, which is unchanged, calls the @c(mu.Lock) and @c(mu.Unlock) methods
#    to acquire and release a @e(writer or exclusive) lock.
   La funcion @c(Balance) ahora llama a los metodos @c(RLock) y @c(RUnlock) para
   adquirir y liberar a @e(lectores) o bloqueo @e(compartido). la funcion
   @c(Deposit), queda sin cambios, llama a los metodos @c(mu.Lock) y
   @c(mu.Unlock) para adquirir y liberar un @e(escritor o bloqueo) exclusivo.

#    After this change, most of Bob’s @c(Balance) requests run in parallel with
#    each other and finish more quickly. The lock is available for more of the
#    time, and @c(Deposit) requests can proceed in a timely manner.
   Despues de este cambio, la mayor parte de peticion @c(Balance) de Bob se
   ejecutan en paralelo entre si y terminar mas rapidamente. El bloqueo esta
   disponible la mayoria del tiempo, y las solicitudes @c(Deposit) puede
   proceder de manera oportuna.

#    @c(RLock) can be used only if there are no writes to shared variables in the
#    critical section. In general, we should not assume that @e(logically)
#    read-only functions or methods don’t also update some variables. For example,
#    a method that appears to be a simple accessor might also increment an
#    internal usage counter, or update a cache so that repeat calls are faster. If
#    in doubt, use an exclusive @c(Lock).
   RLock solo se puede utilizar si no hay escritura en variables compartidas en
   la seccion critica. En general, no debemos suponer que la funciones de solo
   lectura @e(logicamente) no actualizan algunas variables. Por ejemplo, un
   metodo que parece ser un simple accesorio tambien puede incrementar un
   contador de uso interno o actualizar un cache para que las llamadas repetidas
   sean mas rapidas. En caso de duda, utilice un @c(Lock) exclusivo .

#    It’s only profitable to use an @c(RWMutex) when most of the goroutines that
#    acquire the lock are readers, and the lock is under @e(contention), that is,
#    goroutines routinely have to wait to acquire it. An @c(RWMutex) requires more
#    complex internal bookkeeping, making it slower than a regular mutex for
#    uncontended locks.
   Solo es rentable utilizar @c(RWMutex) cuando la mayoria de las gorutinas que
   adquieren el bloqueo son lectores, y el bloqueo esta bajo @e(contencion), es
   decir, las gorutinas rutinariamente tienen que esperar para adquirirla. Un
   @c(RWMutex) requiere contabilidad interna mas compleja, por lo que es mas
   lento que un mutex regular para bloqueos sin contencion.

# ** Section 9.4 <> Memory Synchronization
** Seccion 9.4 <> Sincronizacion de Memoria

#    You may wonder why the @c(Balance) method needs mutual exclusion, either
#    channel-based or mutex-based. After all, unlike @c(Deposit), it consists only
#    of a single operation, so there is no danger of another goroutine executing
#    @"(in the middle) of it. There are two reasons we need a mutex. The first is
#    that it’s equally important that @c(Balance) not execute in the middle of
#    some other operation like @c(Withdraw). The second (and more subtle) reason
#    is that synchronization is about more than just the order of execution of
#    multiple goroutines; synchronization also affects memory.
   Usted puede preguntarse por que el metodo @c(Balance) necesita exclusion
   mutua, ya sea basada en canales o basada en mutex. Despues de todo, a
   diferencia de @c(Deposit), que consiste solo en una sola operacion, por lo
   que no hay peligro de otra gorutina se ejecute @"(en medio) de la misma. Hay
   dos razones por las que necesitamos un mutex. La primera es que es igualmente
   importante que @c(Balance) no se ejecute en medio de alguna otra operacion
   como @c(Withdraw). La segunda (y mas sutil) razon es que la sincronizacion es
   mas que solo el orden de ejecucion de multiples gorutinas; La sincronizacion
   tambien afecta a la memoria.

#    In a modern computer there may be dozens of processors, each with its own
#    local cache of the main memory. For efficiency, writes to memory are buffered
#    within each processor and flushed out to main memory only when
#    necessary. They may even be committed to main memory in a different order
#    than they were written by the writing goroutine. Synchronization primitives
#    like channel communications and mutex operations cause the processor to flush
#    out and commit all its accumulated writes so that the effects of goroutine
#    execution up to that point are guaranteed to be visible to goroutines running
#    on other processors.
   En una computadora moderna puede haber decenas de procesadores, cada uno con
   su propia cache local de memoria principal. Por razones de eficiencia, las
   escrituras en memoria se almacenan en el buffer de cada procesador y se
   descargan en la memoria principal solo cuando es necesario. Incluso pueden
   estar comprometidos con la memoria principal en un orden diferente de lo que
   fueron escritos por la gorutina de escritura. Las primitivas de
   sincronizacion como las comunicaciones de canal y las operaciones de mutex
   hacen que el procesador descargue y comprometa todas sus escrituras
   acumuladas de modo que los efectos de la ejecucion de gorutina hasta ese
   punto esten garantizados para ser visibles para gorutinas que se ejecutan en
   otros procesadores.

#    Consider the possible outputs of the following snippet of code:
   Considere las posibles salidas del siguiente fragmento de codigo:

#    ..src > go
#      var x, y int
#      go func() {
#        x = 1
#        // A1
#        fmt.Print("y:", y, " ") // A2
#      }()
#      go func() {
#        y = 1
#        // B1
#        fmt.Print("x:", x, " ") // B2
#      }()
#    < src..
   ..src > go
     var x, y int
     go func() {
       x = 1
       // A1
       fmt.Print("y:", y, " ") // A2
     }()
     go func() {
       y = 1
       // B1
       fmt.Print("x:", x, " ") // B2
     }()
   < src..

#    Since these two goroutines are concurrent and access shared variables without
#    mutual exclusion, there is a data race, so we should not be surprised that
#    the program is not deterministic. We might expect it to print any one of
#    these four results, which correspond to intuitive interleavings of the
#    labeled statements of the program:
   Dado que estas dos gorutinas son concurrentes y acceden a variables
   compartidas sin exclusion mutua, existe una carrera de datos, por lo que no debe
   sorprendernos que el programa no sea determinista. Podemos esperar que
   imprima cualquiera de estos cuatro resultados, que corresponden a
   intercalaciones intuitivas de las declaraciones etiquetadas del programa:

#    ..pre >
#      y:0 x:1
#      x:0 y:1
#      x:1 y:1
#      y:1 x:1
   ..pre >
     y:0 x:1
     x:0 y:1
     x:1 y:1
     y:1 x:1

#    The fourth line could be explained by the sequence
#    @c(A1),@c(B1),@c(A2),@c(B2) or by @c(B1),@c(A1),@c(A2),@c(B2), for
#    example. However, these two outcomes might come as a surprise:
   La cuarta linea podria explicarse por la secuencia @c(A1), @c(B1), @c(A2),
   @c(B2) o por @c(B1), @c(A1), @c(A2), @c(B2), por ejemplo. Sin embargo, estos dos
   resultados podrian ser una sorpresa:

#    ..pre >
#      x:0 y:0
#      y:0 x:0
   ..pre >
     x:0 y:0
     y:0 x:0

#    but depending on the compiler, CPU, and many other factors, they can happen
#    too. What possible interleaving of the four statements could explain them?
   Pero dependiendo del compilador, la CPU, y muchos otros factores, pueden
   suceder tambien. ¿Que posible intercalacion de los cuatro enunciados podria
   explicarlos?

#    Within a single goroutine, the effects of each statement are guaranteed to
#    occur in the order of execution; goroutines are @e(sequentially
#    consistent). But in the absence of explicit synchronization using a channel
#    or mutex, there is no guarantee that events are seen in the same order by all
#    goroutines. Although goroutine A must observe the effect of the write @c(x
#    = 1) before it reads the value of @c(y), it does not necessarily observe the
#    write to @c(y) done by goroutine B, so A may print a @e(stale) value of @c(y).
   Dentro de una sola gorutina, los efectos de cada declaracion se garantizan
   para ocurrir en el orden de la ejecucion; las gorutinas son
   @e(secuencialmente consistentes). Pero en ausencia de sincronizacion
   explicita utilizando un canal o mutex, no hay garantia de que los eventos
   sean vistos en el mismo orden por todas las gorutinas. Aunque la gorutina A
   debe observar el efecto de la escritura @c(x = 1) antes de que se lea el
   valor de @c(y), no necesariamente observar la escritura a @c(y) realizada por
   la gorutina B, por lo que A puede imprimir un valor obsoleto de @c(y).

#    It is tempting to try to understand concurrency as if it corresponds to
#    @e(some) interleaving of the statements of each goroutine, but as the example
#    above shows, this is not how a modern compiler or CPU works. Because the
#    assignment and the @c(Print) refer to different variables, a compiler may
#    conclude that the order of the two statements cannot affect the result, and
#    swap them. If the two goroutines execute on different CPUs, each with its own
#    cache, writes by one goroutine are not visible to the other goroutine’s
#    @c(Print) until the caches are synchronized with main memory.
   Es tentador tratar de entender la concurrencia como si se correspondiera a
   @e(alguna) intercalacion de los estados de cada gorutina, pero como muestra
   el ejemplo anterior, no es asi como un compilador o una CPU moderna. Debido a
   que la asignacion y @c(Print) se refieren a diferentes variables, un
   compilador puede concluir que el orden de las dos declaraciones no puede
   afectar el resultado, e intercambiarlos. Si las dos gorutinas se ejecutan en
   diferentes CPUs, cada uno con su propia memoria cache, las escrituras de una
   gorutina no son visibles para el @c(Print) de la otra gorutina hasta que las
   caches se sincronizan con la memoria principal.

#    All these concurrency problems can be avoided by the consistent use of
#    simple, established patterns. Where possible, confine variables to a single
#    goroutine; for all other variables, use mutual exclusion.
   Todos estos problemas de concurrencia pueden ser evitados por el uso
   consistente de patrones simples y establecidos. Siempre que sea posible,
   limite las variables a una unica gorutina; Para todas las demas variables,
   utilice la exclusion mutua.

# ** Section 9.5 <> Lazy Initialization: @c(sync.Once)
** Seccion 9.5 <> Inicializacion Perezosa: @c(sync.Once)

#    It is good practice to defer an expensive initialization step until the
#    moment it is needed. Initializing a variable up front increases the start-up
#    latency of a program and is unnecessary if execution doesn’t always reach the
#    part of the program that uses that variable. Let’s return to the @c(icons)
#    variable we saw earlier in the chapter:
   Es una buena practica diferir un costoso paso de inicializacion hasta el
   momento en que se necesita. Inicializar una variable de antemano aumenta la
   latencia de inicio de un programa y es innecesario si la ejecucion no siempre
   alcanza la parte del programa que utiliza esa variable. Volvamos a la
   variable @c(icons) que vimos en el capitulo anterior:

#    ..src > go
#      var icons map[string]image.Image
#    < src..
   ..src > go
     var icons map[string]image.Image
   < src..

#    This version of @c(Icon) uses @e(lazy initialization):
   Esta version de @c(Icon) utiliza @e(inicializacion perezosa):

#    ..src > go
#      func loadIcons() {
#        icons = map[string]image.Image{
#          "spades.png":   loadIcon("spades.png"),
#          "hearts.png":   loadIcon("hearts.png"),
#          "diamonds.png": loadIcon("diamonds.png"),
#          "clubs.png":    loadIcon("clubs.png"),
#        }
#      }
#
#      // NOTE: not concurrency-safe!
#      func Icon(name string) image.Image {
#        if icons == nil {
#          loadIcons() // one-time initialization
#        }
#        return icons[name]
#      }
#    < src..
   ..src > go
     func loadIcons() {
       icons = map[string]image.Image{
         "spades.png":   loadIcon("spades.png"),
         "hearts.png":   loadIcon("hearts.png"),
         "diamonds.png": loadIcon("diamonds.png"),
         "clubs.png":    loadIcon("clubs.png"),
       }
     }

     // NOTA: no es concurrentemente seguro!
     func Icon(name string) image.Image {
       if icons == nil {
         loadIcons() // inicializacion unica
       }
       return icons[name]
     }
   < src..

#    For a variable accessed by only a single goroutine, we can use the pattern
#    above, but this pattern is not safe if @c(Icon) is called concurrently. Like
#    the bank’s original @c(Deposit) function, @c(Icon) consists of multiple
#    steps: it tests whether @c(icons) is nil, then it loads the icons, then it
#    updates @c(icons) to a non-nil value. Intuition might suggest that the worst
#    possible outcome of the race condition above is that the @c(loadIcons)
#    function is called several times. While the first goroutine is busy loading
#    the icons, another goroutine entering @c(Icon) would find the variable still
#    equal to @c(nil), and would also call @c(loadIcons).
   Para una variable accedida por solo una gorutina, podemos usar el patron
   anterior, pero este patron no es seguro si @c(Icon) se llama concurrentemente.

   Al igual la funcion original @c(Deposit) del banco, @c(Icon) consta de varios
   pasos: Comprueba si @c(icons) es nil, entonces carga los iconos, luego, carga
   @c(icons) a un valor no nil. La intuicion podria sugerir que el peor
   resultado posible de la condicion de carrera anterior es que la funcion
   @c(loadIcons) se llame varias veces. Mientras que la primera gorutina esta
   ocupada cargando los iconos, otra gorutina que entre a @c(Icon) encontraria
   que la variable sigue siendo igual a @c(nil), y podria tambien llamar a
   @c(loadIcons).

#    But this intuition is also wrong. (We hope that by now you are developing a
#    new intuition about concurrency, that intuitions about concurrency are not to
#    be trusted!) Recall the discussion of memory from @l(#Section 9.4). In the
#    absence of explicit synchronization, the compiler and CPU are free to reorder
#    accesses to memory in any number of ways, so long as the behavior of each
#    goroutine is sequentially consistent. One possible reordering of the
#    statements of @c(loadIcons) is shown below. It stores the empty map in the
#    @c(icons) variable before populating it:
   Pero esta intuicion tambien es incorrecta. (Esperamos que a estas alturas
   esta desarrollando una nueva intuicion sobre la concurrencia, que no deba
   confiar en las intuiciones sobre la concurrencia!) Recordemos la discusion de
   la memoria de la @l(#Seccion 9.4). En ausencia de sincronizacion explicita,
   el compilador y la CPU son libres de reordenar los accesos a la memoria en
   cualquier numero de maneras, siempre y cuando el comportamiento de cada
   gorutina sea consistente secuencialmente. Una posible reordenacion de las
   declaraciones de @c(loadIcons) se muestra a continuacion. Se almacena el mapa
   vacio en la variable @c(icons) antes de poblarlo:

#    ..src > go
#      func loadIcons() {
#        icons = make(map[string]image.Image)
#        icons["spades.png"] = loadIcon("spades.png")
#        icons["hearts.png"] = loadIcon("hearts.png")
#        icons["diamonds.png"] = loadIcon("diamonds.png")
#        icons["clubs.png"] = loadIcon("clubs.png")
#      }
#    < src..
   ..src > go
     func loadIcons() {
       icons = make(map[string]image.Image)
       icons["spades.png"] = loadIcon("spades.png")
       icons["hearts.png"] = loadIcon("hearts.png")
       icons["diamonds.png"] = loadIcon("diamonds.png")
       icons["clubs.png"] = loadIcon("clubs.png")
     }
   < src..

#    Consequently, a goroutine finding @c(icons) to be non-nil may not assume that
#    the initialization of the variable is complete.
   En consecuencia, un gorutina que encuentre a @c(icons) siendo no-nil no puede
   asumir que la inicializacion de la variable esta completa.

#    The simplest correct way to ensure that all goroutines observe the effects of
#    @c(loadIcons) is to synchronize them using a mutex:
   La forma mas sencilla de garantizar que todas las gorutinas observan los
   efectos de @c(loadIcons) es sincronizarlos utilizando un mutex:

#    ..src > go
#      var mu sync.Mutex // guards icons
#      var icons map[string]image.Image
#
#      // Concurrency-safe.
#      func Icon(name string) image.Image {
#        mu.Lock()
#        defer mu.Unlock()
#        if icons == nil {
#          loadIcons()
#        }
#        return icons[name]
#      }
#    < src..
   ..src > go
     var mu sync.Mutex // guards icons
     var icons map[string]image.Image

     // concurrentemente seguro.
     func Icon(name string) image.Image {
       mu.Lock()
       defer mu.Unlock()
       if icons == nil {
         loadIcons()
       }
       return icons[name]
     }
   < src..

#    However, the cost of enforcing mutually exclusive access to @c(icons) is that
#    two goroutines cannot access the variable concurrently, even once the
#    variable has been safely initialized and will never be modified again. This
#    suggests a multiple-readers lock:
   Sin embargo, el costo de aplicar el acceso mutuamente excluyente a @c(icons)
   es que dos gorutinas no pueden acceder a la variable al mismo tiempo, incluso
   una vez que la variable se ha inicializado de forma segura y nunca sera
   modificada de nuevo. Esto sugiere un bloqueo de lectores multiples:

#    ..src > go
#      var mu sync.RWMutex // guards icons
#      var icons map[string]image.Image
#
#      // Concurrency-safe.
#      func Icon(name string) image.Image {
#        mu.RLock()
#        if icons != nil {
#          icon := icons[name]
#          mu.RUnlock()
#          return icon
#        }
#        mu.RUnlock()
#
#        // acquire an exclusive lock
#        mu.Lock()
#        if icons == nil { // NOTE: must recheck for nil
#          loadIcons()
#        }
#        icon := icons[name]
#        mu.Unlock()
#        return icon
#      }
#    < src..
   ..src > go
     var mu sync.RWMutex // custodia icons
     var icons map[string]image.Image

     // concurrentemente seguro.
     func Icon(name string) image.Image {
       mu.RLock()
       if icons != nil {
         icon := icons[name]
         mu.RUnlock()
         return icon
       }
       mu.RUnlock()

       // adquiere un bloqueo exclusivo
       mu.Lock()
       if icons == nil { // NOTA: debe volver a comprobar por nil
         loadIcons()
       }
       icon := icons[name]
       mu.Unlock()
       return icon
     }
   < src..

#    There are now two critical sections. The goroutine first acquires a reader
#    lock, consults the map, then releases the lock. If an entry was found (the
#    common case), it is returned. If no entry was found, the goroutine acquires a
#    writer lock. There is no way to upgrade a shared lock to an exclusive one
#    without first releasing the shared lock, so we must recheck the @c(icons)
#    variable in case another goroutine already initialized it in the interim.
   Ahora hay dos secciones criticas. la primer gorutina adquiere un bloqueo de
   lectura, consulta el mapa, despues libera el bloqueo. Si se encontro una
   entrada (el caso comun), se devuelve. Si no se encontro ninguna entrada, la
   gorutina adquiere un bloqueo de escritura. No hay manera de actualizar un
   bloqueo compartido a un exclusiva sin liberar primero el bloqueo compartido,
   por lo que debemos volver a comprobar la variable @c(icons) en caso de que
   otra gorutina ya la haya inicializado en el interin.

#    The pattern above gives us greater concurrency but is complex and thus
#    error-prone.  Fortunately, the @c(sync) package provides a specialized
#    solution to the problem of one-time initialization: @c(sync.Once).
#    Conceptually, a @c(Once) consists of a mutex and a boolean variable that
#    records whether initialization has taken place; the mutex guards both the
#    boolean and the client’s data structures. The sole method, Do, accepts the
#    initialization function as its argument. Let’s use @c(Once) to simplify the
#    @c(Icon) function:
   El patron anterior nos da mayor concurrencia, pero es complejo y, por tanto,
   propenso a errores. Afortunadamente, el paquete @c(sync) proporciona una
   solucion especializada para el problema de la inicializacion unica:
   @c(sync.Once). Conceptualmente, un @c(Once) se compone de un mutex y una
   variable booleana que registra si la inicializacion ha tenido lugar; El mutex
   protege tanto las estructuras de datos booleanas como las del cliente. El
   unico metodo, @c(Do), acepta la funcion de inicializacion como su argumento.
   Vamos utilizar @c(Once) para simplificar la funcion @c(Icon):

#    ..src > go
#      var loadIconsOnce sync.Once
#      var icons map[string]image.Image
#
#      // Concurrency-safe.
#      func Icon(name string) image.Image {
#        loadIconsOnce.Do(loadIcons)
#        return icons[name]
#      }
#    < src..
   ..src > go
     var loadIconsOnce sync.Once
     var icons map[string]image.Image

     // concurrentemente seguro.
     func Icon(name string) image.Image {
       loadIconsOnce.Do(loadIcons)
       return icons[name]
     }
   < src..

#    Each call to @c[Do(loadIcons)] locks the mutex and checks the boolean
#    variable. In the first call, in which the variable is false, Do calls
#    @c(loadIcons) and sets the variable to true. Subsequent calls do nothing, but
#    the mutex synchronization ensures that the effects of @c(loadIcons) on memory
#    (specifically, @c(icons)) become visible to all goroutines. Using
#    @c(sync.Once) in this way, we can avoid sharing variables with other
#    goroutines until they have been properly constructed.
   Cada llamada a @c[Do(loadIcons)] bloquea el mutex y comprueba la variable
   booleana. En la primer llamada, en la que la variable es falsa, @c(Do) llama
   a @c(loadIcons) y la variable se establece a verdadero. Las llamadas
   posteriores no hacen nada, pero la sincronizacion de exclusion mutua asegura
   que los efectos de @c(loadIcons) sobre la memoria (en concreto, @c(icons)) se
   hacen visibles a todas las gorutinas. Usando @c(sync.Once) de esta manera,
   podemos evitar compartir las variables con otras gorutinas hasta que se han
   construido correctamente.

#    @b(Exercise 9.2): Rewrite the @c(PopCount) example from @l(#Section 2.6.2) so
#    that it initializes the lookup table using @c(sync.Once) the first time it is
#    needed. (Realistically, the cost of synchronization would be prohibitive for
#    a small and highly optimized function like @c(PopCount).)
   @b(Ejercicio 9.2): Vuelva a escribir el ejemplo @c(PopCount) de la
   @l(#Seccion 2.6.2) de manera que inicialice la tabla de consulta utilizando
   @c(sync.Once) la primera vez que sea necesario. (Siendo realistas, el costo
   de la sincronizacion seria prohibitivo para una pequeña y altamente
   optimizado funcion como @c(PopCount).)

# ** Section 9.6 <> The Race Detector
** Seccion 9.6 <> El Detector de Carreras

#    Even with the greatest of care, it’s all too easy to make concurrency
#    mistakes. Fortunately, the Go runtime and toolchain are equipped with a
#    sophisticated and easy-to-use dynamic analysis tool, the @e(race detector).
   Incluso con el mayor cuidado, es demasiado facil crear errores de
   concurrencia. Afortunadamente, el runtime y herramientas de Go esta equipado
   con una herramienta sofisticada y facil de usar de analisis dinamico, el
   @e(detector de carrera).

#    Just add the @c(-race) flag to your @$(go build), @$(go run), or @$(go test)
#    command. This causes the compiler to build a modified version of your
#    application or test with additional instrumentation that effectively records
#    all accesses to shared variables that occurred during execution, along with
#    the identity of the goroutine that read or wrote the variable. In addition,
#    the modified program records all synchronization events, such as @c(go)
#    statements, channel operations, and calls to @c[(*sync.Mutex).Lock],
#    @c[(*sync.WaitGroup).Wait], and so on. (The complete set of synchronization
#    events is specified by the @e(The Go Memory Model) document that accompanies
#    the language specification.)
   Simplemente agregue la bandera @c(-race) al comando @$(go build), @$(go run)
   o @$(go test). Esto hace que el compilador construya una version modificada
   de su aplicacion o pruebe con instrumentacion adicional que registre
   efectivamente todos los accesos a variables compartidas que ocurrieron
   durante la ejecucion, junto con la identidad de la gorutina que leyo o
   escribio la variable. Ademas, el programa modificado registra todos los
   eventos de sincronizacion, por ejemplo, declaraciones @c(go), operaciones de
   canal, y llamadas a @c[(*sync.Mutex).Lock], @c[(*sync.WaitGroup).Wait],
   etc. (El conjunto completo de eventos de sincronizacion se especifica en el
   documento @e(The Go Memory Model) que acompaña a la especificacion del
   lenguaje.)

#    The race detector studies this stream of events, looking for cases in which
#    one goroutine reads or writes a shared variable that was most recently
#    written by a different goroutine without an intervening synchronization
#    operation. This indicates a concurrent access to the shared variable, and
#    thus a data race. The tool prints a report that includes the identity of the
#    variable, and the stacks of active function calls in the reading goroutine
#    and the writing goroutine. This is usually sufficient to pinpoint the
#    problem. @l(#Section 9.7) contains an example of the race detector in action.
   El detector de carreras estudia esta corriente de eventos, buscando casos en
   los que una gorutina lee o escribe una variable compartida que fue escrita
   recientemente por una gorutina diferente sin una operacion de sincronizacion
   intermedia. Esto indica un acceso simultaneo a la variable compartida y, por
   tanto, una carrera de datos. La herramienta imprime un informe que incluye la
   identidad de la variable y las pilas de las llamadas de funcion activas en la
   seccion de lectura y la nota de escritura. Esto suele ser suficiente para
   identificar el problema. Seccion 9.7 contiene un ejemplo del detector de
   carrera en accion.

#    The race detector reports all data races that were actually
#    executed. However, it can only detect race conditions that occur during a
#    run; it cannot prove that none will ever occur. For best results, make sure
#    that your tests exercise your packages using concurrency.
   El detector de carreras informa todas las carreras de datos que se ejecutaron
   realmente. Sin embargo, solo puede detectar las condiciones de carrera que se
   producen durante una carrera; No puede demostrar que nunca ocurrira ninguna.
   Para obtener los mejores resultados, asegurese de que sus pruebas utilizan
   sus paquetes concurrentemente.

#    Due to extra bookkeeping, a program built with race detection needs more time
#    and memory to run, but the overhead is tolerable even for many production
#    jobs. For infrequently occurring race conditions, letting the race detector
#    do its job can save hours or days of debugging.
   Debido a la contabilidad adicional, un programa construido con la deteccion
   de la raza necesita mas tiempo y memoria para funcionar, pero la sobrecarga
   es tolerable incluso para muchos trabajos en produccion. Para condiciones de
   carrera poco frecuentes, dejar que el detector de carrera haga su trabajo
   puede ahorrar horas o dias de depuracion.

# ** Section 9.7 <> Example: Concurrent Non-Blocking Cache
** Seccion 9.7 <> Ejemplo: Cache Concurrente Sin Bloqueo

#    In this section, we’ll build a @e(concurrent non-blocking cache), an
#    abstraction that solves a problem that arises often in real-world concurrent
#    programs but is not well addressed by existing libraries. This is the problem
#    of @e(memoizing) a function, that is, caching the result of a function so
#    that it need be computed only once. Our solution will be concurrency-safe and
#    will avoid the contention associated with designs based on a single lock for
#    the whole cache.
   En esta seccion, vamos a construir una @e(memoria cache concurrente sin
   bloqueo), una abstraccion que resuelve un problema que se presenta con
   frecuencia en programas concurrentes del mundo real, pero no esta bien
   dirigido por las bibliotecas existentes. Este es el problema de @e(momorizar)
   una funcion, es decir, poner en cache el resultado de una funcion de modo que
   tiene que ser calculada solamente una vez. Nuestra solucion sera segura para
   la concurrencia y evitara la contencion asociada con diseños basados ​​en un
   bloqueo unico para toda la memoria cache.

#    We’ll use the @c(httpGetBody) function below as an example of the type of
#    function we might want to memoize. It makes an HTTP GET request and reads the
#    request body. Calls to this function are relatively expensive, so we’d like
#    to avoid repeating them unnecessarily.
   Usaremos la funcion @c(httpGetBody) a continuacion como ejemplo del tipo de
   funcion que podriamos desear memorizar. Hace una peticion HTTP GET y lee el
   cuerpo de la solicitud. Las llamadas a esta funcion son relativamente caras,
   por lo que nos gustaria evitar repetirlas innecesariamente.

#    ..src > go
#      func httpGetBody(url string) (interface{}, error) {
#        resp, err := http.Get(url)
#        if err != nil {
#          return nil, err
#        }
#        defer resp.Body.Close()
#        return ioutil.ReadAll(resp.Body)
#      }
#    < src..
   ..src > go
     func httpGetBody(url string) (interface{}, error) {
       resp, err := http.Get(url)
       if err != nil {
         return nil, err
       }
       defer resp.Body.Close()
       return ioutil.ReadAll(resp.Body)
     }
   < src..

#    The final line hides a minor subtlety. @c(ReadAll) returns two results, a
#    @c([]byte) and an @c(error), but since these are assignable to the declared
#    result types of @c(httpGetBody)—@c(interface{}) and @c(error),
#    respectively—we can return the result of the call without further ado. We
#    chose this return type for @c(httpGetBody) so that it conforms to the type of
#    functions that our cache is designed to memoize.
   La linea final esconde una sutileza menor. @c(ReadAll) devuelve dos
   resultados, @c([]byte) y un @c(error), pero ya que estos son asignables a
   los tipos de resultados declarados de @c(httpGetBody)–@c(interface{}) y
   @c(error), respectivamente–podemos devolver el resultado de la llamada sin
   mas preambulos. Hemos Elegimos este tipo retorno para @c(httpGetBody) para
   que se ajuste al tipo de funciones que nuestra memoria cache esta diseñado
   para memorizar.

#    Here’s the first draft of the cache:
   Aqui esta el primer borrador de la cache:

#    ..figure > @l(gopl.io/ch9/memo1/memo.go<>gopl.io/ch9/memo1)
   ..figure > @l(gopl.io/ch9/memo1/memo.go<>gopl.io/ch9/memo1)

#      ..src > go
#        // Package memo provides a concurrency-unsafe
#        // memoization of a function of type Func.
#        package memo
#
#        // A Memo caches the results of calling a Func.
#        type Memo struct {
#          f     Func
#          cache map[string]result
#        }
#
#        // Func is the type of the function to memoize.
#        type Func func(key string) (interface{}, error)
#
#        type result struct {
#          value interface{}
#          err   error
#        }
#
#        func New(f Func) *Memo {
#          return &Memo{f: f, cache: make(map[string]result)}
#        }
#
#        // NOTE: not concurrency-safe!
#        func (memo *Memo) Get(key string) (interface{}, error) {
#          res, ok := memo.cache[key]
#          if !ok {
#            res.value, res.err = memo.f(key)
#            memo.cache[key] = res
#          }
#          return res.value, res.err
#        }
#      < src..
     ..src > go
       // El paquete memo proporciona concurrencia segura.
       // momoizacion de una funcion de tipo Func.
       package memo

       // Un Memo almacena en cache los resultados de lamar a Func
       type Memo struct {
         f     Func
         cache map[string]result
       }

       // Func es el tipo de la funcion a memorizar.
       type Func func(key string) (interface{}, error)

       type result struct {
         value interface{}
         err   error
       }

       func New(f Func) *Memo {
         return &Memo{f: f, cache: make(map[string]result)}
       }

       // NOTA: no es seguro concurrentemente!
       func (memo *Memo) Get(key string) (interface{}, error) {
         res, ok := memo.cache[key]
         if !ok {
           res.value, res.err = memo.f(key)
           memo.cache[key] = res
         }
         return res.value, res.err
       }
     < src..


#    A @c(Memo) instance holds the function @c(f) to memoize, of type @c(Func),
#    and the cache, which is a mapping from strings to @c(results). Each
#    @c(result) is simply the pair of results returned by a call to @c(f)—a value
#    and an error. We’ll show several variations of @c(Memo) as the design
#    progresses, but all will share these basic aspects.
   Una instancia de @c(Memo) almacena la funcion @c(f) a memorizar, de tipo
   @c(Func), y la memoria cache, que es una correspondencia de strings a
   @c(results). Cada @c(result) es simplemente el par de resultados devueltos
   por una llamada a @c(f)–un valor y un error. Vamos a mostrar algunas
   variaciones de @c(Memo) a medida que avanza el diseño, pero todos compartiran
   estos aspectos basicos.

#    An example of how to use @c(Memo) appears below. For each element in a stream
#    of incoming URLs, we call @c(Get), logging the latency of the call and the
#    amount of data it returns:
   A continuacion se muestra un ejemplo de como utilizar @c(Memo). Para cada
   elemento en una corriente de URLs entrantes, llamamos a @c(Get), registrando
   la latencia de la llamada y la cantidad de datos que devuelve:

#    ..src > go
#      m := memo.New(httpGetBody)
#      for url := range incomingURLs() {
#        start := time.Now()
#        value, err := m.Get(url)
#        if err != nil {
#          log.Print(err)
#        }
#        fmt.Printf("%s, %s, %d bytes\n",
#          url, time.Since(start), len(value.([]byte)))
#      }
#    < src..
   ..src > go
     m := memo.New(httpGetBody)
     for url := range incomingURLs() {
       start := time.Now()
       value, err := m.Get(url)
       if err != nil {
         log.Print(err)
       }
       fmt.Printf("%s, %s, %d bytes\n",
         url, time.Since(start), len(value.([]byte)))
     }
   < src..

#    We can use the @c(testing) package (the topic of @l(#Chapter 11)) to
#    systematically investigate the effect of memoization. From the test output
#    below, we see that the URL stream contains duplicates, and that although the
#    first call to @c[(*Memo).Get] for each URL takes hundreds of milliseconds,
#    the second request returns the same amount of data in under a millisecond.
   Podemos utilizar el paquete @c(testing) (el tema del @l(#Capitulo 11)) para
   investigar sistematicamente el efecto de memorizacion. A partir de la salida
   de la prueba a continuacion, vemos que la corriente URL contiene duplicados,
   y que aunque la primer llamada a @c[(*Memo).Get] para cada URL toma cientos
   de milisegundos, la segunda peticion devuelve la misma cantidad de datos en
   menos de un milisegundo.

#    ..src > sh
#      $ go test -v gopl.io/ch9/memo1
#      === RUN   Test
#      https://golang.org, 175.026418ms, 7537 bytes
#      https://godoc.org, 172.686825ms, 6878 bytes
#      https://play.golang.org, 115.762377ms, 5767 bytes
#      http://gopl.io, 749.887242ms, 2856 bytes
#      https://golang.org, 721ns, 7537 bytes
#      https://godoc.org, 152ns, 6878 bytes
#      https://play.golang.org, 205ns, 5767 bytes
#      http://gopl.io, 326ns, 2856 bytes
#      --- PASS: Test (1.21s)
#      PASS
#      ok gopl.io/ch9/memo1   1.257s
#    < src..
   ..src > sh
     $ go test -v gopl.io/ch9/memo1
     === RUN   Test
     https://golang.org, 175.026418ms, 7537 bytes
     https://godoc.org, 172.686825ms, 6878 bytes
     https://play.golang.org, 115.762377ms, 5767 bytes
     http://gopl.io, 749.887242ms, 2856 bytes
     https://golang.org, 721ns, 7537 bytes
     https://godoc.org, 152ns, 6878 bytes
     https://play.golang.org, 205ns, 5767 bytes
     http://gopl.io, 326ns, 2856 bytes
     --- PASS: Test (1.21s)
     PASS
     ok gopl.io/ch9/memo1   1.257s
   < src..

#    This test executes all calls to @c(Get) sequentially.
   Esta prueba ejecuta todas las llamadas a @c(Get) secuencialmente.

#    Since HTTP requests are a great opportunity for parallelism, let’s change the
#    test so that it makes all requests concurrently. The test uses a
#    @c(sync.WaitGroup) to wait until the last request is complete before
#    returning.
   Dado que las solicitudes HTTP son una gran oportunidad para el paralelismo,
   cambiemos la prueba para que realice todas las solicitudes
   simultaneamente. La prueba utiliza un @c(sync.WaitGroup) que esperar hasta la
   ultima solicitud se ha completada antes de regresar.

#    ..src > go
#      m := memo.New(httpGetBody)
#      var n sync.WaitGroup
#      for url := range incomingURLs() {
#        n.Add(1)
#        go func(url string) {
#          start := time.Now()
#          value, err := m.Get(url)
#          if err != nil {
#            log.Print(err)
#          }
#          fmt.Printf("%s, %s, %d bytes\n",
#            url, time.Since(start), len(value.([]byte)))
#          n.Done()
#        }(url)
#      }
#      n.Wait()
#    < src..
   ..src > go
     m := memo.New(httpGetBody)
     var n sync.WaitGroup
     for url := range incomingURLs() {
       n.Add(1)
       go func(url string) {
         start := time.Now()
         value, err := m.Get(url)
         if err != nil {
           log.Print(err)
         }
         fmt.Printf("%s, %s, %d bytes\n",
           url, time.Since(start), len(value.([]byte)))
         n.Done()
       }(url)
     }
     n.Wait()
   < src..

#    The test runs much faster, but unfortunately it is unlikely to work correctly
#    all the time. We may notice unexpected cache misses, or cache hits that
#    return incorrect values, or even crashes.
   La prueba se ejecuta mucho mas rapido, pero por desgracia es poco probable
   que funcione correctamente todo el tiempo. Podemos notar fallos inesperados
   de cache, o resultados de cache que devuelven valores incorrectos, o incluso
   se bloquea.

#    Worse, it is likely to work correctly @e(some) of the time, so we may not
#    even notice that it has a problem. But if we run it with the @c(-race) flag,
#    the race detector (@l(#Section 9.6<>§9.6)) often prints a report such as this
#    one:
   Peor aun, es probable que funcione correctamente @e(algunas) de las veces,
   por lo que ni siquiera se puede notar que tiene un problema. Pero si
   ejecutamos con la bandera @c(-race), el detector de carrera (@l(#Seccion
   9.6<>§9.6)) a menudo imprime un informe como este:

#    ..src > sh
#      $ go test -run=TestConcurrent -race -v gopl.io/ch9/memo1
#      === RUN   TestConcurrent
#      ...
#      WARNING: DATA RACE
#      Write by goroutine 36:
#        runtime.mapassign1()
#            ~/go/src/runtime/hashmap.go:411 +0x0
#        gopl.io/ch9/memo1.(*Memo).Get()
#            ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
#      Previous write by goroutine 35:
#        runtime.mapassign1()
#            ~/go/src/runtime/hashmap.go:411 +0x0
#        gopl.io/ch9/memo1.(*Memo).Get()
#            ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
#      ...
#      Found 1 data race(s)
#      FAIL    gopl.io/ch9/memo1   2.393s
#    < src..
   ..src > sh
     $ go test -run=TestConcurrent -race -v gopl.io/ch9/memo1
     === RUN   TestConcurrent
     ...
     WARNING: DATA RACE
     Write by goroutine 36:
       runtime.mapassign1()
           ~/go/src/runtime/hashmap.go:411 +0x0
       gopl.io/ch9/memo1.(*Memo).Get()
           ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
     Previous write by goroutine 35:
       runtime.mapassign1()
           ~/go/src/runtime/hashmap.go:411 +0x0
       gopl.io/ch9/memo1.(*Memo).Get()
           ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205
     ...
     Found 1 data race(s)
     FAIL    gopl.io/ch9/memo1   2.393s
   < src..

#    The reference to @c(memo.go:32) tells us that two goroutines have updated the
#    @c(cache) map without any intervening synchronization. @c(Get) is not
#    concurrency-safe: it has a data race.
   La referencia a @c(memo.go:32) nos dice que dos goroutines han actualizado el
   mapa @c(cache) sin ninguna sincronizacion intermedia. @c(Get) no es
   concurrentemente segura: tiene una carrera de datos.

#    ..src n=28 > go
#      func (memo *Memo) Get(key string) (interface{}, error) {
#        res, ok := memo.cache[key]
#        if !ok {
#          res.value, res.err = memo.f(key)
#          memo.cache[key] = res
#        }
#        return res.value, res.err
#      }
#    < src..
   ..src n(28) > go
     func (memo *Memo) Get(key string) (interface{}, error) {
       res, ok := memo.cache[key]
       if !ok {
         res.value, res.err = memo.f(key)
         memo.cache[key] = res
       }
       return res.value, res.err
     }
   < src..

#    The simplest way to make the cache concurrency-safe is to use monitor-based
#    synchronization. All we need to do is add a mutex to the @c(Memo), acquire
#    the mutex lock at the start of @c(Get), and release it before @c(Get)
#    returns, so that the two @c(cache) operations occur within the critical
#    section:
   La manera mas sencilla de hacer que la cache sea concurrentemente segura es
   utilizar sincronizacion basada en monitor. Todo lo que tenemos que hacer es
   añadir un mutex a @c(Memo), adquirir el bloqueo de exclusion mutua en el
   inicio de @c(Get) y liberarlo despues de su regreso, de modo que las dos
   operaciones @c(cache) ocurran dentro de la seccion critica:

#    ..figure > @l(gopl.io/ch9/memo2/memo.go<>gopl.io/ch9/memo2)
   ..figure > @l(gopl.io/ch9/memo2/memo.go<>gopl.io/ch9/memo2)

#      ..src > go
#        type Memo struct {
#          f     Func
#          mu    sync.Mutex // guards cache
#          cache map[string]result
#        }
#
#        // Get is concurrency-safe.
#        func (memo *Memo) Get(key string) (value interface{}, err error) {
#          memo.mu.Lock()
#          res, ok := memo.cache[key]
#          if !ok {
#            res.value, res.err = memo.f(key)
#            memo.cache[key] = res
#          }
#          memo.mu.Unlock()
#          return res.value, res.err
#        }
#      < src..
     ..src > go
       type Memo struct {
         f     Func
         mu    sync.Mutex // custodia a cache
         cache map[string]result
       }

       // Get es concurrentemente segura.
       func (memo *Memo) Get(key string) (value interface{}, err error) {
         memo.mu.Lock()
         res, ok := memo.cache[key]
         if !ok {
           res.value, res.err = memo.f(key)
           memo.cache[key] = res
         }
         memo.mu.Unlock()
         return res.value, res.err
       }
     < src..


#    Now the race detector is silent, even when running the tests
#    concurrently. Unfortunately this change to @c(Memo) reverses our earlier
#    performance gains. By holding the lock for the duration of each call to
#    @c(f), @c(Get) serializes all the I/O operations we intended to
#    parallelize. What we need is a @e(non-blocking) cache, one that does not
#    serialize calls to the function it memoizes.
   Ahora el detector de carreras esta en silencio, incluso cuando se ejecutan
   las pruebas concurrentemente. Desafortunadamente este cambio a @c(Memo)
   invierte nuestras mejoras de rendimiento anteriores. Al mantener el bloquo
   durante la duracion de cada llamada a @c(f), @c(Get) serializa todas las
   operaciones de E/S que pretendiamos poner en paralelo. Lo que necesitamos es
   una cache @e(sin bloqueo), una que no serialice las llamadas a la funcion que
   memoizes.

#    In the next implementation of @c(Get), below, the calling goroutine acquires
#    the lock twice: once for the lookup, and then a second time for the update if
#    the lookup returned nothing. In between, other goroutines are free to use the
#    cache.
   En la proxima implementacion de @c(Get), a continuacion, la llamada gorutina adquiere
   el bloqueo  dos veces: una vez para la busqueda, y luego una segunda vez
   para la actualizacion si la busqueda devuelve nada. En el medio, otras
   gorutinas son libres de usar la memoria cache.

#    ..figure > @l(gopl.io/ch9/memo3/memo.go<>gopl.io/ch9/memo3)
   ..figure > @l(gopl.io/ch9/memo3/memo.go<>gopl.io/ch9/memo3)

#      ..src > go
#        func (memo *Memo) Get(key string) (value interface{}, err error) {
#          memo.mu.Lock()
#          res, ok := memo.cache[key]
#          memo.mu.Unlock()
#          if !ok {
#            res.value, res.err = memo.f(key)
#
#            // Between the two critical sections, several goroutines
#            // may race to compute f(key) and update the map.
#            memo.mu.Lock()
#            memo.cache[key] = res
#            memo.mu.Unlock()
#          }
#          return res.value, res.err
#        }
#      < src..
     ..src > go
       func (memo *Memo) Get(key string) (value interface{}, err error) {
         memo.mu.Lock()
         res, ok := memo.cache[key]
         memo.mu.Unlock()
         if !ok {
           res.value, res.err = memo.f(key)

           // Entre las dos secciones criticas, varias gorutinas
           // pueden correr para calcular f(key) y actualizar el mapa.
           memo.mu.Lock()
           memo.cache[key] = res
           memo.mu.Unlock()
         }
         return res.value, res.err
       }
     < src..


#    The performance improves again, but now we notice that some URLs are being
#    fetched twice.  This happens when two or more goroutines call @c(Get) for the
#    same URL at about the same time.  Both consult the cache, find no value
#    there, and then call the slow function @c(f). Then both of them update the
#    map with the result they obtained. One of the results is overwritten by the
#    other.
   El rendimiento mejora de nuevo, pero ahora observamos que algunas URL se
   estan recuperando dos veces. Esto ocurre cuando dos o mas gorutinas llaman a
   @c(Get) para la misma URL o casi al mismo tiempo. Ambos consultar la memoria
   cache, no encontran ningun valor, y luego llama a la funcion lenta @c(f).
   Luego ambos actualizan el mapa con el resultado que obtuvieron. Uno de los
   resultados es sobrescrito por el otro.

#    Ideally we’d like to avoid this redundant work. This feature is sometimes
#    called @e(duplicate suppression). In the version of @c(Memo) below, each map
#    element is a pointer to an @c(entry) struct.  Each @c(entry) contains the
#    memoized result of a call to the function @c(f), as before, but it
#    additionally contains a channel called @c(ready). Just after the @c(entry)’s
#    @c(result) has been set, this channel will be closed, to @e(broadcast)
#    (@l(#Section 8.9<>§8.9)) to any other goroutines that it is now safe for them
#    to read the result from the entry.
   Idealmente, nos gustaria evitar este trabajo redundante. Esta caracteristica
   a veces se denomina @e(supresion de duplicados). En la version de @c(Memo) a
   continuacion, cada elemento del mapa es un puntero a una estructura
   @c(entry). Cada @c(entry) contiene el resultado memorizado de una llamada a
   la funcion @c(f), como antes, pero, ademas, contiene un canal llamado
   @c(ready). Justo despues de establecer @c(result) con @c(entry), este canal
   se cerrara, a @e(emitir) (@l(#Seccion 8.9<>§8.9)) a cualquier otra gorutina
   que ahora es seguro para ellos leer el resultado de la entrada.

#    ..figure > @l(gopl.io/ch9/memo4/memo.go<>gopl.io/ch9/memo4)
   ..figure > @l(gopl.io/ch9/memo4/memo.go<>gopl.io/ch9/memo4)

#      ..src > go
#        type entry struct {
#          res   result
#          ready chan struct{} // closed when res is ready
#        }
#
#        func New(f Func) *Memo {
#          return &Memo{f: f, cache: make(map[string]*entry)}
#        }
#
#        type Memo struct {
#          f     Func
#          mu    sync.Mutex // guards cache
#          cache map[string]*entry
#        }
#
#        func (memo *Memo) Get(key string) (value interface{}, err error) {
#          memo.mu.Lock()
#          e := memo.cache[key]
#          if e == nil {
#            // This is the first request for this key.
#            // This goroutine becomes responsible for computing
#            // the value and broadcasting the ready condition.
#            e = &entry{ready: make(chan struct{})}
#            memo.cache[key] = e
#            memo.mu.Unlock()
#
#            e.res.value, e.res.err = memo.f(key)
#
#            close(e.ready) // broadcast ready condition
#          } else {
#            // This is a repeat request for this key.
#            memo.mu.Unlock()
#
#            <-e.ready // wait for ready condition
#          }
#          return e.res.value, e.res.err
#        }
#      < src..
     ..src > go
       type entry struct {
         res   result
         ready chan struct{} // cerrado cuando res esta listo
       }

       func New(f Func) *Memo {
         return &Memo{f: f, cache: make(map[string]*entry)}
       }

       type Memo struct {
         f     Func
         mu    sync.Mutex // guards cache
         cache map[string]*entry
       }

       func (memo *Memo) Get(key string) (value interface{}, err error) {
         memo.mu.Lock()
         e := memo.cache[key]
         if e == nil {
           // Esta es la primer solicitud de esta clave.
           // Esta gorutina se hare rosponsable de calcular
           // el valor  y transmitir la condicion de ready.
           e = &entry{ready: make(chan struct{})}
           memo.cache[key] = e
           memo.mu.Unlock()

           e.res.value, e.res.err = memo.f(key)

           close(e.ready) // condicion de transmicion lista
         } else {
           // This is a repeat request for this key.
           memo.mu.Unlock()

           <-e.ready      // esperar condicion de ready
         }
         return e.res.value, e.res.err
       }
     < src..


#    A call to @c(Get) now involves acquiring the mutex lock that guards the
#    @c(cache) map, looking in the map for a pointer to an existing @c(entry),
#    allocating and inserting a new @c(entry) if none was found, then releasing
#    the lock. If there was an existing @c(entry), its value is not necessarily
#    ready yet—another goroutine could still be calling the slow function @c(f)—so
#    the calling goroutine must wait for the @c(entry)’s @"(ready) condition before it
#    reads the @c(entry)’s @c(result). It does this by reading a value from the
#    @c(ready) channel, since this operation blocks until the channel is closed.
   Una llamada a @c(Get) ahora implica la adquisicion del bloqueo mutex que
   custodia el mapa @c(cache), buscando en el mapa un puntero a una @c(entry)
   existente, asignando e insertando una nueva @c(entry) si no se encontro
   ninguna, y luego liberando el bloqueo. Si habia una @c(entry) existente, su
   valor no esta necesariamente listo aun–otra gorutina podria estar llamando a
   la funcion lenta @c(f)–por lo que la gorutina que llama debe esperar la
   condicion @"(ready) de @c(entry) antes de leer el @c(entry) de
   @c(result). Esto se hace leyendo un valor del canal @c(ready), ya que esto
   bloquea la operacion hasta que el canal esta cerrado.

#    If there was no existing @c(entry), then by inserting a new @"(not ready)
#    @c(entry) into the map, the current goroutine becomes responsible for
#    invoking the slow function, updating the @c(entry), and broadcasting the
#    readiness of the new @c(entry) to any other goroutines that might (by then)
#    be waiting for it.
   Si no hay una @c(entry) existente, a continuacion, insenta una nueva
   @c(entry) @"(no listo) en el mapa, la gorutina actual se hace responsable de
   la invocacion de la funcion lenta, actualizacion @c(entry), y trasmitiendo la
   disponibilidad de la nueva @c(entry) a cualquier otra gorutina que podria
   (para entonces) estar esperando.

#    Notice that the variables @c(e.res.value) and @c(e.res.err) in the @c(entry)
#    are shared among multiple goroutines. The goroutine that creates the
#    @c(entry) sets their values, and other goroutines read their values once the
#    @"(ready) condition has been broadcast. Despite being accessed by multiple
#    goroutines, no mutex lock is necessary. The closing of the @c(ready) channel
#    @e(happens before) any other goroutine receives the broadcast event, so the
#    write to those variables in the first goroutine @e(happens before) they are
#    read by subsequent goroutines. There is no data race.
   Observe que las variables @c(e.res.value) y @c(e.res.err) en @c(entry) se
   comparten entre varias gorutinas. la gorutina que crea @c(entry) establece
   sus valores, y otras gorutinas leer sus valores una vez que la condicion
   @"(ready) ha sido transmitida. A pesar de ser accedido por multiples
   gorutinas, no es necesario el bloqueo mutex. El cierre del canal @c(ready)
   @e(sucede antes) de cualquier otra gorutina reciba el evento de transmision,
   por lo que la escritura a esas variables en la primer gorutina @e(sucede
   antes) de que sean leidos por gorutinas posteriores. No hay carrera de datos.

#    Our concurrent, duplicate-suppressing, non-blocking cache is complete.
   Nuestra cache concurrente, que suprime duplicados y no bloquea, esta
   completa.

#    The implementation of @c(Memo) above uses a mutex to guard a map variable
#    that is shared by each goroutine that calls @c(Get). It’s interesting to
#    contrast this design with an alternative one in which the map variable is
#    confined to a @e(monitor goroutine) to which callers of @c(Get) must send a
#    message.
   La implementacion de @c(Memo) anterior utiliza un mutex para custodiar una
   variable de un mapa que es compartida por cada gorutina que llame a
   @c(Get). Es interesante contrastar este diseño con uno alternativo en el que
   la variable de mapa se confina a una @e(gorutina monitor) a la que los
   llamantes de @c(Get) deben enviar un mensaje.

#    The declarations of @c(Func), @c(result), and @c(entry) remain as before:
   Las declaraciones de @c(Func), @c(result), y @c(entry) se mantienen como
   antes:

#    ..src > go
#      // Func is the type of the function to memoize.
#      type Func func(key string) (interface{}, error)
#
#      // A result is the result of calling a Func.
#      type result struct {
#        value interface{}
#        err   error
#      }
#
#      type entry struct {
#        res   result
#        ready chan struct{} // closed when res is ready
#      }
#    < src..
   ..src > go
     // Func es el tipo de la funcion a memorizar.
     type Func func(key string) (interface{}, error)

     // Un result es el resultado de llamar a un Func
     type result struct {
       value interface{}
       err   error
     }

     type entry struct {
       res   result
       ready chan struct{} // cerrado cuando res esta listo
     }
   < src..

#    However, the @c(Memo) type now consists of a channel, @c(requests), through
#    which the caller of @c(Get) communicates with the monitor goroutine. The
#    element type of the channel is a @c(request).  Using this structure, the
#    caller of @c(Get) sends the monitor goroutine both the key, that is, the
#    argument to the memoized function, and another channel, @c(response), over
#    which the result should be sent back when it becomes available. This channel
#    will carry only a single value.
   Sin embargo, el typo @c(Memo) ahora consiste en un canal, @c(requests), a
   traves del cual el llamador de @c(Get) se comunica con la gorutina
   monitor. El tipo de elemento del canal es un @c(request). Con este esquema el
   llamador de @c(Get) envia a la gorutina monitor la clave, es decir, el
   argumento de la funcion a memorizar, y otro canal, @c(response), sobre el
   cual el resultado debe ser enviado de vuelta cuando este disponible. Este
   canal llevara un solo valor.

#    ..figure > @l(gopl.io/ch9/memo5/memo.go<>gopl.io/ch9/memo5)
   ..figure > @l(gopl.io/ch9/memo5/memo.go<>gopl.io/ch9/memo5)

#      ..src > go
#        // A request is a message requesting that the Func be applied to key.
#        type request struct {
#          key      string
#          response chan<- result // the client wants a single result
#        }
#
#        type Memo struct{ requests chan request }
#
#        // New returns a memoization of f.  Clients must subsequently call Close.
#        func New(f Func) *Memo {
#          memo := &Memo{requests: make(chan request)}
#          go memo.server(f)
#          return memo
#        }
#
#        func (memo *Memo) Get(key string) (interface{}, error) {
#          response := make(chan result)
#          memo.requests <- request{key, response}
#          res := <-response
#          return res.value, res.err
#        }
#
#        func (memo *Memo) Close() { close(memo.requests) }
#      < src..
     ..src > go
       // Un request es un mensaje solicitado para que Func aplique la clave
       type request struct {
         key      string
         response chan<- result // el cliente quiere un solo resultado
       }

       type Memo struct{ requests chan request }

       // New regresa una memorizacion de f. Los clientes deben llamar posteriormente a Close.
       func New(f Func) *Memo {
         memo := &Memo{requests: make(chan request)}
         go memo.server(f)
         return memo
       }

       func (memo *Memo) Get(key string) (interface{}, error) {
         response := make(chan result)
         memo.requests <- request{key, response}
         res := <-response
         return res.value, res.err
       }

       func (memo *Memo) Close() { close(memo.requests) }
     < src..


#    The @c(Get) method, above, creates a response channel, puts it in the
#    request, sends it to the monitor goroutine, then immediately receives from
#    it.
   El metodo @c(Get), arriba, crea un canal de respuesta, lo pone en la
   solicitud, lo envia a la gorutina monitor, despues recibe inmediatamente de
   esta.

#    The @c(cache) variable is confined to the monitor goroutine
#    @c[(*Memo).server], shown below. The monitor reads requests in a loop until
#    the request channel is closed by the @c(Close) method. For each request, it
#    consults the cache, creating and inserting a new @c(entry) if none was found.
   La @c(cache) variable se confina a la gorutina monitor @c[(*Memo).server],
   que se muestra a continuacion. El monitor lee las peticiones en un bucle
   hasta que el canal de solicitud es cierra mediente el metodo @c(Close). Para
   cada solicitud, consulta la cache, creando e insertando una nueva @c(entry)
   si no se encontro ninguna.

#    ..src > go
#      func (memo *Memo) server(f Func) {
#        cache := make(map[string]*entry)
#        for req := range memo.requests {
#          e := cache[req.key]
#          if e == nil {
#            // This is the first request for this key.
#            e = &entry{ready: make(chan struct{})}
#            cache[req.key] = e
#            go e.call(f, req.key) // call f(key)
#          }
#          go e.deliver(req.response)
#        }
#      }
#
#      func (e *entry) call(f Func, key string) {
#        // Evaluate the function.
#        e.res.value, e.res.err = f(key)
#        // Broadcast the ready condition.
#        close(e.ready)
#      }
#
#      func (e *entry) deliver(response chan<- result) {
#        // Wait for the ready condition.
#        <-e.ready
#        // Send the result to the client.
#        response <- e.res
#      }
#    < src..
   ..src > go
     func (memo *Memo) server(f Func) {
       cache := make(map[string]*entry)
       for req := range memo.requests {
         e := cache[req.key]
         if e == nil {
           // Esta es la primer solicitud para esta clave
           e = &entry{ready: make(chan struct{})}
           cache[req.key] = e
           go e.call(f, req.key) // llama a f(key)
         }
         go e.deliver(req.response)
       }
     }

     func (e *entry) call(f Func, key string) {
       // Evalua la funcion.
       e.res.value, e.res.err = f(key)
       // Transmite la condicion ready.
       close(e.ready)
     }

     func (e *entry) deliver(response chan<- result) {
       // Espera por la condicion ready.
       <-e.ready
       // Envia el resultado al cliente.
       response <- e.res
     }
   < src..

#    In a similar manner to the mutex-based version, the first request for a given
#    key becomes responsible for calling the function @c(f) on that key, storing
#    the result in the @c(entry), and broadcasting the readiness of the @c(entry)
#    by closing the @c(ready) channel. This is done by @c[(*entry).call].
   De manera similar a la version basada en mutex, la primer solicitud de una
   clave dada se convierte en responsable de llamar a la funcion @c(f) de esa
   clave, almacenar el resultado en @c(entry), y la difundir la disponibilidad
   de @c(entry) al cerrar el canal @c(ready). Esto se hace mediante
   @c[(*entry).call].

#    A subsequent request for the same key finds the existing @c(entry) in the
#    map, waits for the result to become ready, and sends the result through the
#    response channel to the client goroutine that called @c(Get). This is done by
#    @c[(*entry).deliver]. The @c(call) and @c(deliver) methods must be called in
#    their own goroutines to ensure that the monitor goroutine does not stop
#    processing new requests.
   Una solicitud posterior para la misma clave se encuentra el @c(entry)
   existente en el mapa, espera a que el resultado este listo, y envia el
   resultado a traves del canal de respuesta a la gorutina cliente que llama a
   @c(Get). Esto se hace mediante @c[(*entry).deliver]. Los metodos @c(call) y
   @c(deliver) deben ser llamados en sus propias gorutinas para asegurar que el
   monitor de gorutina no detiene el procesamiento de nuevas solicitudes.

#    This example shows that it’s possible to build many concurrent structures
#    using either of the two approaches—shared variables and locks, or
#    communicating sequential processes— without excessive complexity.
   Este ejemplo muestra que es posible construir muchas estructuras simultaneas
   utilizando cualquiera de los dos enfoques–variables compartidas y bloqueos,
   o comunicacion de procesos secuenciales–sin excesiva complejidad.

#    It’s not always obvious which approach is preferable in a given situation,
#    but it’s worth knowing how they correspond. Sometimes switching from one
#    approach to the other can make your code simpler.
   No siempre es obvio que enfoque es preferible en una situacion dada, pero
   vale la pena saber como se corresponden. A veces, cambiar de un enfoque a
   otro puede hacer que su codigo sea mas sencillo.

#    @b(Exercise 9.3): Extend the Func type and the @c[(*Memo).Get] method so that
#    callers may provide an optional @c(done) channel through which they can cancel
#    the operation (@l(#Section 8.9<>§8.9)). The results of a cancelled @c(Func)
#    call should not be cached.
   @b(Ejercicio 9.3): Extender el tipo @c(Func) y el metodo @c[(*Memo).Get] para
   que los llamantes puedan proporcionar un canal @c(done) opcional a traves del
   cual se puede cancelar la operacion (@l(#Seccion 8.9<>§8.9)). Los resultados
   de una @c(Func) cancelada no deben almacenarse en cache.

# ** Section 9.8 <> Goroutines and Threads
** Seccion 9.8 <> Gorutinas e Hilos

#    In the previous chapter we said that the difference between goroutines and
#    operating system (OS) threads could be ignored until later. Although the
#    differences between them are essentially quantitative, a big enough
#    quantitative difference becomes a qualitative one, and so it is with
#    goroutines and threads. The time has now come to distinguish them.
   En el capitulo anterior dijimos que la diferencia entre gorutinas e hilos del
   sistema operativo (OS) ser podrian ignorar hasta mas tarde. Aunque las
   diferencias entre ellas son esencialmente cuantitativas, una diferencia
   cuantitativa lo suficientemente grande se convierte en una cualitativa, y lo
   mismo sucede con las gorutinas y los hilos. Ha llegado el momento de
   distinguirlos.

# *** Section 9.8.1 <> Growable Stacks
*** Seccion 9.8.1 <> Pilas Expandibles

#     Each OS thread has a fixed-size block of memory (often as large as 2MB) for
#     its @e(stack), the work area where it saves the local variables of function
#     calls that are in progress or temporarily suspended while another function
#     is called. This fixed-size stack is simultaneously too much and too
#     little. A 2MB stack would be a huge waste of memory for a little goroutine,
#     such as one that merely waits for a @c(WaitGroup) then closes a
#     channel. It’s not uncommon for a Go program to create hundreds of thousands
#     of goroutines at one time, which would be impossible with stacks this
#     large. Yet despite their size, fixed-size stacks are not always big enough
#     for the most complex and deeply recursive of functions. Changing the fixed
#     size can improve space efficiency and allow more threads to be created, or
#     it can enable more deeply recursive functions, but it cannot do both.
    Cada hilo del Sistema Operativo tiene un bloque de tamaño fijo de memoria (a
    menudo tan grande como 2 MB) para su pila, el area de trabajo donde se
    guarda las variables locales de las llamadas a funciones que estan en curso
    o suspendidos temporalmente mientras que otra funcion se llama. Esta pila de
    tamaño fijo es simultaneamente demasiado y muy poco. Una pila de 2MB seria
    una enorme desperdicio de memoria para una pequeña gorutina, como una que
    simplemente espera un @c(WaitGroup) y luego cierra un canal. No es raro que
    un programa Go cree cientos de miles de gorutinas al mismo tiempo, lo que
    seria imposible con pilas tan grandes. Sin embargo, a pesar de su tamaño,
    las pilas de tamaño fijo no siempre son lo suficientemente grandes para las
    funciones mas complejas y profundamente recursivas. Cambiar el tamaño fijo
    puede mejorar la eficiencia del espacio y permitir que se creen mas
    subprocesos, o puede permitir funciones mas profundamente recursivas, pero
    no puede hacer ambas cosas.

#     In contrast, a goroutine starts life with a small stack, typically 2KB. A
#     goroutine’s stack, like the stack of an OS thread, holds the local variables
#     of active and suspended function calls, but unlike an OS thread, a
#     goroutine’s stack is not fixed; it grows and shrinks as needed. The size
#     limit for a goroutine stack may be as much as 1GB, orders of magnitude
#     larger than a typical fixed-size thread stack, though of course few
#     goroutines use that much.
    En contraste, un gorutina comienza su vida con una pequeña pila, tipicamente
    2KB. La pila de una gorutina, como la pila de un subproceso de sistema
    operativo, contiene las variables locales de las llamadas de funcion activas
    y suspendidas, pero a diferencia de un subproceso de sistema operativo, la
    pila de una gorutina no es fija; Crece y se encoge segun sea necesario. El
    limite de tamaño para una pila de gorutina puede ser tanto como 1 GB, varios
    ordenes de magnitud mas grande que la pila de un hilo de tamaño fijo, aunque
    por supuesto algunas gorutinas utilizan mucho.

#     @b(Exercise 9.4): Construct a pipeline that connects an arbitrary number of
#     goroutines with channels. What is the maximum number of pipeline stages you
#     can create without running out of memory? How long does a value take to
#     transit the entire pipeline?
    @b(Ejercicio 9.4): Construir una tuberia que conecta un numero arbitrario de
    gorutinas con canales. ¿Cual es el numero maximo de etapas de canalizacion
    que puede crear sin quedarse sin memoria? ¿Cuanto tarda un valor en
    transitar por toda la tuberia?

# *** Section 9.8.2 <> Goroutine Scheduling
*** Seccion 9.8.2 <> Planificacion de Gorutina

#     OS threads are scheduled by the OS kernel. Every few milliseconds, a
#     hardware timer interrupts the processor, which causes a kernel function
#     called the @e(scheduler) to be invoked. This function suspends the currently
#     executing thread and saves its registers in memory, looks over the list of
#     threads and decides which one should run next, restores that thread’s
#     registers from memory, then resumes the execution of that thread. Because OS
#     threads are scheduled by the kernel, passing control from one thread to
#     another requires a full @e(context switch), that is, saving the state of one
#     user thread to memory, restoring the state of another, and updating the
#     scheduler’s data structures. This operation is slow, due to its poor
#     locality and the number of memory accesses required, and has historically
#     only gotten worse as the number of CPU cycles required to access memory has
#     increased.
    Los subprocesos del sistema operativo estan programados por el kernel del
    sistema operativo. Cada pocos milisegundos, un temporizador de hardware
    interrumpe el procesador, lo que hace que se invoque una funcion del nucleo
    llamada el @e(planificador). Esta funcion suspende el subproceso actualmente
    en ejecucion y guarda sus registros en la memoria, revisa la lista de
    subprocesos y decide cual deberia ejecutar a continuacion, restaura los
    registros de ese subproceso de la memoria y reanuda la ejecucion de ese
    subproceso. Debido a que los hilos del SO estan programadas por el nucleo,
    pasar el control de un hilo a otro requiere un @e(cambio de contexto)
    completo, es decir, guardar el estado del hilo de un usuario en memoria,
    restaurando el estado de otro, y actualizar las estructuras de datos del
    planificador. Esta operacion es lenta, debido a su pobre localidad y el
    numero de accesos de memoria requeridos, e historicamente solo ha empeorado
    a medida que aumenta el numero de ciclos de CPU requeridos para acceder a la
    memoria.

#     The Go runtime contains its own scheduler that uses a technique known as
#     @e(m:n scheduling), because it multiplexes (or schedules) @e(m) goroutines
#     on @e(n) OS threads. The job of the Go scheduler is analogous to that of the
#     kernel scheduler, but it is concerned only with the goroutines of a single
#     Go program.
    El runtime de Go contiene su propio planificador que utiliza una tecnica
    conocida como @e(planificacion m:n), ya que multiplexa (o planifica) @e(m)
    gorutinas en @m(n) hilos del SO. El trabajo del planificador Go es analogo
    al del planificador del nucleo, pero solo se refiere a las gorutinas de un
    solo programa Go.

#     Unlike the operating system’s thread scheduler, the Go scheduler is not
#     invoked periodically by a hardware timer, but implicitly by certain Go
#     language constructs. For example, when a goroutine calls @c(time.Sleep) or
#     blocks in a channel or mutex operation, the scheduler puts it to sleep and
#     runs another goroutine until it is time to wake the first one up. Because it
#     doesn’t need a switch to kernel context, rescheduling a goroutine is much
#     cheaper than rescheduling a thread.
    A diferencia del planificador de hilos del sistema operativo, el programador
    Go no se invoca periodicamente por un temporizador de hardware, sino
    implicitamente por ciertas construcciones en lenguaje Go. Por ejemplo,
    cuando una gorutina llama a @c(time.Sleep) o bloquea en una operacion de
    canal o mutex, el planificador la pone a dormir y se ejecuta otra gorutina
    hasta que es hora de despertar el primero. Debido a que no necesita un
    cambio al contexto del kernel, la reprogramacion de una gorutina es mucho
    mas barata que la reprogramacion de un hilo.

#     @b(Exercise 9.5): Write a program with two goroutines that send messages
#     back and forth over two unbuffered channels in ping-pong fashion. How many
#     communications per second can the program sustain?
    @b(Ejercicio 9.5): Escribir un programa con dos gorutinas que envien
    mensajes de ida y vuelta sobre dos canales sin bufer en modo
    ping-pong. ¿Cuantas comunicaciones por segundo puede mantener el programa?

# *** Section 9.8.3 <> GOMAXPROCS
*** Seccion 9.8.3 <> @c(GOMAXPROCS)

#     The Go scheduler uses a parameter called @c(GOMAXPROCS) to determine how
#     many OS threads may be actively executing Go code simultaneously. Its
#     default value is the number of CPUs on the machine, so on a machine with 8
#     CPUs, the scheduler will schedule Go code on up to 8 OS threads at
#     once. (@c(GOMAXPROCS) is the @m(n) in @m(m:n) scheduling.) Goroutines that
#     are sleeping or blocked in a communication do not need a thread at
#     all. Goroutines that are blocked in I/O or other system calls or are calling
#     non-Go functions, do need an OS thread, but @c(GOMAXPROCS) need not account
#     for them.
    El planificador Go utiliza un parametro llamado @c(GOMAXPROCS) para
    determinar cuantos hilos del OS puede estar ejecutando activamente en
    ejecucion el codigo Go al mismo tiempo. Su valor predeterminado es el numero
    de CPUs en la maquina, por lo que en una maquina con 8 CPUs, el planificador
    programara el codigo Go en hasta 8 hilos del SO a la vez. (@c(GOMAXPROCS) es
    la @e(n) en la planificacion @e(m:n)). Las Gorutinas que estan durmiendo o
    bloqueadas en una comunicacion no necesitan un hilo en absoluto. Las
    Gorutinas que estan bloqueando llamadas E/S u otro tipo llamadas al sistema
    o llamadas a funciones no Go, no necesita un hilo del SO, por lo que
    @c(GOMAXPROCS) no tienen por que dar cuenta de ellas.

#     You can explicitly control this parameter using the @c(GOMAXPROCS)
#     environment variable or the @c(runtime.GOMAXPROCS) function. We can see the
#     effect of @c(GOMAXPROCS) on this little program, which prints an endless
#     stream of zeros and ones:
    Puede controlar de forma explicita este parametro mediante la variable de
    entorno @c(GOMAXPROCS) o la funcion @c(runtime.GOMAXPROCS). Podemos ver el
    efecto de @c(GOMAXPROCS) en este pequeño programa, que imprime un flijo sin
    fin de unos y ceros:

#     ..src > go
#       for {
#         go fmt.Print(0)
#         fmt.Print(1)
#       }
#     < src..
    ..src > go
      for {
        go fmt.Print(0)
        fmt.Print(1)
      }
    < src..

#     ..src > sh
#       $ GOMAXPROCS=1 go run hacker-cliche.go
#       111111111111111111110000000000000000000011111...
#       $ GOMAXPROCS=2 go run hacker-cliche.go
#       010101010101010101011001100101011010010100110...
#     < src..
    ..src > sh
      $ GOMAXPROCS=1 go run hacker-cliche.go
      111111111111111111110000000000000000000011111...
      $ GOMAXPROCS=2 go run hacker-cliche.go
      010101010101010101011001100101011010010100110...
    < src..

#     In the first run, at most one goroutine was executed at a time. Initially,
#     it was the main goroutine, which prints ones. After a period of time, the Go
#     scheduler put it to sleep and woke up the goroutine that prints zeros,
#     giving it a turn to run on the OS thread. In the second run, there were two
#     OS threads available, so both goroutines ran simultaneously, printing digits
#     at about the same rate. We must stress that many factors are involved in
#     goroutine scheduling, and the runtime is constantly evolving, so your
#     results may differ from the ones above.
    En la primera ejecucion, al menos una gorutina fue ejecutada a la
    vez. Inicialmente, era la gorutina principal, que imprime unos. Despues de
    un periodo de tiempo, el programador de Go lo puso a dormir y desperto la
    gorutina que imprime ceros, dandole un giro para correr en el hilo del
    SO. En la segunda ejecucion, habia dos subprocesos de sistema operativo
    disponibles, por lo que ambos gorutinas se ejecutaron simultaneamente,
    imprimiendo digitos en la misma tasa. Debemos destacar que muchos factores
    estan involucrados en la programacion de gorutinas, y el tiempo de ejecucion
    esta en constante evolucion, por lo que sus resultados pueden diferir de los
    anteriores.

#     @b(Exercise 9.6): Measure how the performance of a compute-bound parallel
#     program (see Exercise 8.5) varies with @c(GOMAXPROCS). What is the optimal
#     value on your computer? How many CPUs does your computer have?
    @b(Ejercicio 9.6): Medir como varia el desempeño de un programa paralelo
    ligado a calculo (vease el Ejercicio 8.5) con @c(GOMAXPROCS). ¿Cual es el
    valor optimo en su computadora? ¿Cuantas CPU tiene su computadora?

# *** Section 9.8.4 <> Goroutines Have No Identity
*** Seccion 9.8.4 <> Las Gorutinas No Tienen Identidad

#     In most operating systems and programming languages that support
#     multithreading, the current thread has a distinct identity that can be
#     easily obtained as an ordinary value, typically an integer or pointer. This
#     makes it easy to build an abstraction called @e(thread-local storage), which
#     is essentially a global map keyed by thread identity, so that each thread
#     can store and retrieve values independent of other threads.
    En la mayoria de los sistemas operativos y lenguajes de programacion que
    admiten multihilo, el subproceso actual tiene una identidad distinta que se
    puede obtener facilmente como un valor ordinario, normalmente un entero o
    puntero. Esto hace que sea facil de construir una abstraccion denominada
    @e(almacenamiento local de hilos), que es esencialmente un mapa global con
    clave de identidad de hilos, de modo que cada hilo puede almacenar y
    recuperar valores independientes de los otros hilos.

#     Goroutines have no notion of identity that is accessible to the
#     programmer. This is by design, since thread-local storage tends to be
#     abused. For example, in a web server implemented in a language with
#     thread-local storage, it’s common for many functions to find information
#     about the HTTP request on whose behalf they are currently working by looking
#     in that storage.  However, just as with programs that rely excessively on
#     global variables, this can lead to an unhealthy @"(action at a distance) in
#     which the behavior of a function is not determined by its arguments alone,
#     but by the identity of the thread in which it runs. Consequently, if the
#     identity of the thread should change—some worker threads are enlisted to
#     help, say—the function misbehaves mysteriously.
    Las gorutinas no tienen ninguna nocion de la identidad que es accesible al
    programador. Esto es por diseño, ya que el almacenamiento local de hilos
    tiende a ser abusado. Por ejemplo, en un servidor web implementado en un
    lenguaje con almacenamiento local de hilos, es comun que muchas funciones
    busquen informacion sobre la solicitud HTTP en cuyo nombre estan trabajando
    actualmente buscando en ese almacenamiento. Sin embargo, al igual que con
    los programas que dependen excesivamente de las variables globales, esto
    puede conducir a una @"(accion a distancia) malsana en la que el
    comportamiento de una funcion no esta determinado unicamente por sus
    argumentos, sino por la identidad del hilo en el que se ejecuta. Por lo
    tanto, si la identidad del hilo debe cambiar–algunos hilos de trabajo se
    alistan para ayudar, a–la funcion se comporta de forma misteriosa.

#     Go encourages a simpler style of programming in which parameters that affect
#     the behavior of a function are explicit. Not only does this make programs
#     easier to read, but it lets us freely assign subtasks of a given function to
#     many different goroutines without worrying about their identity.
    Go fomenta un estilo de programacion mas simple en el que los parametros que
    afectan al comportamiento de una funcion son explicitos. Esto no solo hace
    que los programas sean mas faciles de leer, sino que nos permite asignar
    libremente subtareas de una funcion dada a muchas gorutinas diferentes sin
    preocuparnos por su identidad.

#     You’ve now learned about all the language features you need for writing Go
#     programs. In the next two chapters, we’ll step back to look at some of the
#     practices and tools that support programming in the large: how to structure
#     a project as a set of packages, and how to obtain, build, test, benchmark,
#     profile, document, and share those packages.
    Ahora ha aprendido sobre todas las caracteristicas del lenguje que necesita
    para escribir programas Go. En los proximos dos capitulos, retrocederemos
    para ver algunas de las practicas y herramientas que soportan la
    programacion en general: como estructurar un proyecto como un conjunto de
    paquetes, y como obtener, construir, probar, evaluar, evaluar, documentar, y
    compartir esos paquetes.

# * Chapter 10 <> Packages and the Go Tool
* Capitulo 10 <> Paquetes y la Herramienta Go

#   A modest-size program today might contain 10,000 functions. Yet its author
#   need think about only a few of them and design even fewer, because the vast
#   majority were written by others and made available for reuse through
#   @e(packages).
  A dia de hoy un programa de tamaño modesto podria contener 10.000 funciones.
  Sin embargo, su autor tiene que pensar en solo unas pocas de ellas y el
  diseñar aun menos, porque la gran mayoria fueron escritas por otros y puestas
  a disposicion para su reutilizacion a traves de paquetes.

#   Go comes with over 100 standard packages that provide the foundations for most
#   applications.  The Go community, a thriving ecosystem of package design,
#   sharing, reuse, and improvement, has published many more, and you can find a
#   searchable index of them at @l(http://godoc.org).  In this chapter, we’ll show
#   how to use existing packages and create new ones.
  Go incluye mas de 100 paquetes estandar que proporcionan las bases para la
  mayoria de las aplicaciones. La comunidad Go, con un prospero ecosistema para
  diseñar, compartir, reutilizar y mejorar paquetes ha publicado muchos mas, y
  usted puede encontrar un indice de busqueda en @l(http://godoc.org). En este
  capitulo, mostraremos como utilizar los paquetes existentes y crear otros
  nuevos.

#   Go also comes with the @$(go) tool, a sophisticated but simple-to-use command
#   for managing workspaces of Go packages. Since the beginning of the book, we’ve
#   been showing how to use the @$(go) tool to download, build, and run example
#   programs. In this chapter, we’ll look at the tool’s underlying concepts and
#   tour more of its capabilities, which include printing documentation and
#   querying metadata about the packages in the workspace. In the next chapter
#   we’ll explore its testing features.
  Go tambien viene con la herramienta @$(go), un comando sofisticado pero facil
  de usar para gestionar los espacios de trabajo de los paquetes de Go. Desde el
  comienzo del libro, hemos estado mostrando como utilizar la herramienta @$(go)
  para descargar, compilar y ejecutar programas de ejemplo. En este capitulo,
  vamos a ver los conceptos subyacentes de la herramienta y daremos un paseo por
  sus capacidades, que incluyen la impresion de documentacion y la consulta de
  metadatos sobre los paquetes en el espacio de trabajo. En el siguiente
  capitulo vamos a explorar sus caracteristicas para realizar pruebas.

# ** Section 10.1 <> Introduction
** Seccion 10.1 <> Introduccion

#    The purpose of any package system is to make the design and maintenance of
#    large programs practical by grouping related features together into units
#    that can be easily understood and changed, independent of the other packages
#    of the program. This @e(modularity) allows packages to be shared and reused
#    by different projects, distributed within an organization, or made available
#    to the wider world.
   El proposito de cualquier sistema de paquetes es hacer que el diseño y
   mantenimiento de programas grandes sea practico, agrupando las
   caracteristicas relacionadas en unidades que puedan ser facilmente
   comprendidas y cambiadas, independientemente de los otros paquetes del
   programa. Esta @e(modularidad) permite que los paquetes sean compartidos y
   reutilizados por diferentes proyectos, distribuidos dentro de una
   organizacion, o puestos a disposicion del resto del mundo.

#    Each package defines a distinct name space that encloses its
#    identifiers. Each name is associated with a particular package, letting us
#    choose short, clear names for the types, functions, and so on that we use
#    most often, without creating conflicts with other parts of the program.
   Cada paquete define un espacio de nombre distinto que incluye sus
   identificadores. Cada nombre esta asociado con un paquete en particular, lo
   que nos permite elegir nombres cortos y claros para los tipos, funciones,
   etc., que usamos con mas frecuencia, sin crear conflictos con otras partes
   del programa.

#    Packages also provide @e(encapsulation) by controlling which names are
#    visible or exported outside the package. Restricting the visibility of
#    package members hides the helper functions and types behind the package’s
#    API, allowing the package maintainer to change the implementation with
#    confidence that no code outside the package will be affected. Restricting
#    visibility also hides variables so that clients can access and update them
#    only through exported functions that preserve internal invariants or enforce
#    mutual exclusion in a concurrent program.
   Los paquetes tambien proporcionan @e(encapsulacion) controlando que nombres
   son visibles o exportados fuera del paquete. La restriccion de la visibilidad
   de los miembros del paquete oculta las funciones y tipos de ayuda, de la API
   del paquete, lo que permite al responsable del paquete cambiar la
   implementacion con la confianza de que ningun codigo fuera del paquete se
   vera afectado. Restringir la visibilidad tambien oculta las variables para
   que los clientes puedan acceder y actualizarlas solo mediante funciones
   exportadas que preserven las invariantes internas o impongan la exclusion
   mutua en un programa concurrente.

#    When we change a file, we must recompile the file’s package and potentially
#    all the packages that depend on it. Go compilation is notably faster than
#    most other compiled languages, even when building from scratch. There are
#    three main reasons for the compiler’s speed. First, all imports must be
#    explicitly listed at the beginning of each source file, so the compiler does
#    not have to read and process an entire file to determine its
#    dependencies. Second, the dependencies of a package form a directed acyclic
#    graph, and because there are no cycles, packages can be compiled separately
#    and perhaps in parallel. Finally, the object file for a compiled Go package
#    records export information not just for the package itself, but for its
#    dependencies too.  When compiling a package, the compiler must read one
#    object file for each import but need not look beyond these files.
   Cuando cambiamos un archivo, debemos recompilar el paquete del archivo y
   potencialmente todos los paquetes que dependen de el. La compilacion de Go es
   notablemente mas rapida que la mayoria de los otros lenguajes compilados,
   incluso cuando se construye desde cero. Hay tres razones principales para la
   velocidad del compilador. En primer lugar, todas las importaciones deben
   estar listadas explicitamente al principio de cada archivo de origen, por lo
   que el compilador no tiene que leer y procesar un archivo completo para
   determinar sus dependencias. En segundo lugar, las dependencias de un paquete
   forman un grafo aciclico dirigido, y debido a que no hay ciclos, los paquetes
   pueden ser compilados por separado y tal vez en paralelo. Finalmente, el
   archivo de objeto de un paquete compilado Go registra informacion de
   exportacion no solo para el propio paquete, sino tambien para sus
   dependencias. Al compilar un paquete, el compilador debe leer un archivo de
   objeto para cada importacion pero no necesita mirar mas alla de estos
   archivos.

# ** Section 10.2 <> Import Paths
** Seccion 10.2 <> Rutas de Importacion

#    Each package is identified by a unique string called its @e(import
#    path). Import paths are the strings that appear in @c(import) declarations.
   Cada paquete esta identificado por una cadena unica denominada su @e(ruta de
   importacion). Las rutas de importacion son las cadenas que aparecen en las
   declaraciones @c(import).

#    ..src > go
#      import (
#        "fmt"
#        "math/rand"
#        "encoding/json"
#
#        "golang.org/x/net/html"
#
#        "github.com/go-sql-driver/mysql"
#      )
#    < src..
   ..src > go
     import (
       "fmt"
       "math/rand"
       "encoding/json"

       "golang.org/x/net/html"

       "github.com/go-sql-driver/mysql"
     )
   < src..

#    As we mentioned in @l(#Section 2.6.1), the Go language specification doesn’t
#    define the meaning of these strings or how to determine a package’s import
#    path, but leaves these issues to the tools. In this chapter, we’ll take a
#    detailed look at how the @$(go) tool interprets them, since that’s what the
#    majority of Go programmers use for building, testing, and so on. Other tools
#    do exist, though. For example, Go programmers using Google’s internal
#    multi-language build system follow different rules for naming and locating
#    packages, specifying tests, and so on, that more closely match the
#    conventions of that system.
   Como mencionamos en la @l(#Seccion 2.6.1), la especificacion del lenguaje Go
   no define el significado de estas cadenas o como determinar ruta de
   importacion de un paquete, sino que deja estas cuestiones a las herramientas.
   En este capitulo, analizaremos con detalle como interpreta la herramienta
   @$(go), ya que eso es lo que la mayoria de los programadores de Go utilizan
   para construir, probar, etc. Sin embargo, existen otras herramientas. Por
   ejemplo, los programadores de Go que utilizan el sistema de compilacion
   multilenguaje interno de Google siguen reglas diferentes para nombrar y
   localizar paquetes, especificar pruebas y demas, que se ajusten mas a las
   convenciones de ese sistema.

#    For packages you intend to share or publish, import paths should be globally
#    unique. To avoid conflicts, the import paths of all packages other than those
#    from the standard library should start with the Internet domain name of the
#    organization that owns or hosts the package; this also makes it possible to
#    find packages. For example, the declaration above imports an HTML parser
#    maintained by the Go team and a popular third-party MySQL database driver.
   Para los paquetes que desea compartir o publicar, las vias de acceso de
   importacion deben ser unicas a nivel global. Para evitar conflictos, las
   rutas de importacion de todos los paquetes distintos de los de la biblioteca
   estandar deben comenzar con el nombre de dominio de Internet de la
   organizacion que posee o aloja el paquete; Esto tambien hace posible
   encontrar paquetes. Por ejemplo, la declaracion anterior importa un
   analizador HTML mantenido por el equipo Go y un popular controlador de base
   de datos MySQL de terceros.

# ** Section 10.3 <> The Package Declaration
** Seccion 10.3 <> La Declaracion @c(package)

#    A @c(package) declaration is required at the start of every Go source
#    file. Its main purpose is to determine the default identifier for that
#    package (called the @e(package name)) when it is imported by another package.
   En Go se requiere una declaracion @c(package) al inicio de cada archivo
   fuente. Su proposito principal es determinar el identificador por defecto
   para ese paquete (denominado el @e(nombre del paquete)) cuando se importa por
   otro paquete.

#    For example, every file of the @c(math/rand) package starts with @c(package
#    rand), so when you import this package, you can access its members as
#    @c(rand.Int), @c(rand.Float64), and so on.
   Por ejemplo, todos los archivos del paquete @c(math/rand) comienza con
   @c(package rand), por lo que al importar este paquete, puede acceder a sus
   miembros como @c(rand.Int), @c(rand.Float64), etc.

#    ..src > go
#      package main
#
#      import (
#        "fmt"
#        "math/rand"
#      )
#
#      func main() {
#        fmt.Println(rand.Int())
#      }
#    < src..
   ..src > go
     package main

     import (
       "fmt"
       "math/rand"
     )

     func main() {
       fmt.Println(rand.Int())
     }
   < src..

#    Conventionally, the package name is the last segment of the import path, and
#    as a result, two packages may have the same name even though their import
#    paths necessarily differ. For example, the packages whose import paths are
#    @c(math/rand) and @c(crypto/rand) both have the name @c(rand). We’ll see how
#    to use both in the same program in a moment.
   Convencionalmente, el nombre del paquete es el ultimo segmento de la ruta de
   importacion y, como resultado, dos paquetes pueden tener el mismo nombre
   aunque sus rutas de importacion difieran necesariamente. Por ejemplo, los
   paquetes cuyas rutas de importacion son @c(math/rand) y @c(crypto/rand)
   tienen el nombre @c(rand). Veremos como usar ambos en el mismo programa en un
   momento.

#    There are three major exceptions to the @"(last segment) convention. The
#    first is that a package defining a command (an executable Go program) always
#    has the name @c(main), regardless of the package’s import path. This is a
#    signal to @$(go build) (@l(#Section 10.7.3<>§10.7.3)) that it must invoke the
#    linker to make an executable file.
   Hay tres excepciones principales a la convencion del @"(ultimo segmento). La
   primera es que un paquete que define un comando (un programa ejecutable Go)
   siempre tiene el nombre @c(main), independientemente de la ruta de
   importacion del paquete. Esta es una señal para @$(go build) (@l(#Seccion
   10.7.3<>§10.7.3)) que debe invocar el enlazador para crear un archivo
   ejecutable.

#    The second exception is that some files in the directory may have the suffix
#    @c(_test) on their package name if the file name ends with @c(_test.go). Such
#    a directory may define @e(two) packages: the usual one, plus another one
#    called an @e(external test package). The @c(_test) suffix signals to @$(go
#    test) that it must build both packages, and it indicates which files belong
#    to each package.  External test packages are used to avoid cycles in the
#    import graph arising from dependencies of the test; they are covered in more
#    detail in @l(#Section 11.2.4).
   La segunda excepcion es que algunos archivos en el directorio pueden tener el
   sufijo @c(_test) en su nombre de paquete si el nombre del archivo termina con
   @c(_test.go). Un directorio de este tipo puede definir dos paquetes: el
   habitual, ademas de otro denominado @e(paquete de prueba externa). El sufijo
   @c(_test) indica a @$(go test) que debe construir ambos paquetes, e indica
   que archivos pertenecen a cada paquete. Los paquetes de prueba externos se
   utilizan para evitar ciclos en el grafico de importacion que surgen de las
   dependencias de la prueba; se cubren con mas detalle en la @l(#Seccion
   11.2.4).

#    The third exception is that some tools for dependency management append
#    version number suffixes to package import paths, such as
#    @c("gopkg.in/yaml.v2"). The package name excludes the suffix, so in this case
#    it would be just @c(yaml).
   La tercera excepcion es que algunas herramientas para la gestion de
   dependencias añaden sufijos del numero de version a rutas de importacion,
   como @c("gopkg.in/yaml.v2"). El nombre del paquete excluye el sufijo, por lo
   que en este caso seria simplemente @c(yaml).

# ** Section 10.4 <> Import Declarations
** Seccion 10.4 <> Declaraciones Import

#    A Go source file may contain zero or more @c(import) declarations immediately
#    after the @c(package) declaration and before the first non-import
#    declaration. Each import declaration may specify the import path of a single
#    package, or multiple packages in a parenthesized list. The two forms below
#    are equivalent but the second form is more common.
   Un archivo de codigo Go puede contener cero o mas declaraciones @c(import)
   inmediatamente despues de la declaracion @c(package) y antes de la primera
   declaracion de no importacion. Cada declaracion de importacion puede
   especificar la ruta de importacion de un unico paquete o varios paquetes en
   una lista entre parentesis. Las dos formas a continuacion son equivalentes
   pero la segunda forma es mas comun.

#    ..src > go
#      import "fmt"
#      import "os"
#
#      import (
#        "fmt"
#        "os"
#      )
#    < src..
   ..src > go
     import "fmt"
     import "os"

     import (
       "fmt"
       "os"
     )
   < src..

#    Imported packages may be grouped by introducing blank lines; such groupings
#    usually indicate different domains. The order is not significant, but by
#    convention the lines of each group are sorted alphabetically. (Both @$(gofmt)
#    and @$(goimports) will group and sort for you.)
   Los paquetes importados pueden agruparse introduciendo lineas en blanco;
   Tales grupos suelen indicar diferentes dominios. El orden no es
   significativo, pero por convencion las lineas de cada grupo se ordenan
   alfabeticamente. (Tanto @$(gofmt) como @$(goimports) las agruparan y
   ordenaran por usted.)

#    ..src > go
#      import (
#        "fmt"
#        "html/template"
#        "os"
#
#        "golang.org/x/net/html"
#        "golang.org/x/net/ipv4"
#      )
#    < src..
   ..src > go
     import (
       "fmt"
       "html/template"
       "os"

       "golang.org/x/net/html"
       "golang.org/x/net/ipv4"
     )
   < src..

#    If we need to import two packages whose names are the same, like
#    @c(math/rand) and @c(crypto/rand), into a third package, the import
#    declaration must specify an alternative name for at least one of them to
#    avoid a conflict. This is called a @e(renaming import).
   Si tenemos que importar dos paquetes cuyos nombres son los mismos, como
   @c(math/rand) y @c(crypto/rand), en un tercer paquete, la declaracion de
   importacion debe especificar un nombre alternativo para al menos uno de ellos
   para evitar un conflicto. Esto se denomina @e(renombrar la importacion).

#    ..src > go
#      import (
#        "crypto/rand"
#        mrand "math/rand" // alternative name mrand avoids conflict
#      )
#    < src..
   ..src > go
     import (
       "crypto/rand"
       mrand "math/rand" // alternative name mrand avoids conflict
     )
   < src..

#    The alternative name affects only the importing file. Other files, even ones
#    in the same package, may import the package using its default name, or a
#    different name.
   El nombre alternativo solo afecta al archivo de importacion. Otros archivos,
   incluso los del mismo paquete, pueden importar el paquete usando su nombre
   predeterminado o un nombre diferente.

#    A renaming import may be useful even when there is no conflict. If the name
#    of the imported package is unwieldy, as is sometimes the case for
#    automatically generated code, an abbreviated name may be more convenient. The
#    same short name should be used consistently to avoid confusion. Choosing an
#    alternative name can help avoid conflicts with common local variable
#    names. For example, in a file with many local variables named @c(path), we
#    might import the standard @c("path") package as @c(pathpkg).
   Renombrar una importacion ser util incluso cuando no hay conflicto. Si el
   nombre del paquete importado es dificil de manejar, como ocurre a veces con
   el codigo generado automaticamente, es posible que el nombre abreviado sea
   mas conveniente. El mismo nombre abreviado debe ser usado consistentemente
   para evitar confusiones. La eleccion de un nombre alternativo puede ayudar a
   evitar conflictos con nombres de variables locales comunes. Por ejemplo, en
   un archivo con muchas variables locales llamado @c(path), podriamos importar
   el paquete estandar @c("path") como @c(pathpkg).

#    Each import declaration establishes a dependency from the current package to
#    the imported package. The @$(go build) tool reports an error if these
#    dependencies form a cycle.
   Cada declaracion de importacion establece una dependencia del paquete actual
   al paquete importado. La herramienta @$(go build) informara un error si estas
   dependencias forman un ciclo.

# ** Section 10.5 <> Blank Imports
** Seccion 10.5 <> Importaciones En Blanco

#    It is an error to import a package into a file but not refer to the name it
#    defines within that file.  However, on occasion we must import a package
#    merely for the side effects of doing so: evaluation of the initializer
#    expressions of its package-level variables and execution of its @c(init)
#    functions (@l(#Section 2.6.2<>§2.6.2)). To suppress the @"(unused import)
#    error we would otherwise encounter, we must use a renaming import in which
#    the alternative name is @c(_), the blank identifier. As usual, the blank
#    identifier can never be referenced.
   Es un error importar un paquete en un archivo pero no hacer referencia al
   nombre que define, dentro de ese archivo. Sin embargo, en ocasiones hay que
   importar un paquete solo por los efectos secundarios de hacerlo: evaluacion
   de las expresiones de inicializador de sus variables y ejecucion de sus
   funciones @c(init) a nivel de paquete (@l(#Seccion 2.6.2<>§2.6.2)). Para
   suprimir el error de @"(importacion no utilizada) que encontrariamos de otra
   manera, debemos utilizar una importacion de cambio de nombre en la que el
   nombre alternativo sea @c(_), el identificador en blanco. Como de costumbre,
   el identificador en blanco nunca puede ser referenciado.

#    ..src > go
#      import _ "image/png" // register PNG decoder
#    < src..
   ..src > go
     import _ "image/png" // registra decodificador PNG
   < src..

#    This is known as a @e(blank import). It is most often used to implement a
#    compile-time mechanism whereby the main program can enable optional features
#    by blank-importing additional packages. First we’ll see how to use it, then
#    we’ll see how it works.
   Esto se conoce como una @e(importacion en blanco). Se utiliza con mayor
   frecuencia para implementar un mecanismo de tiempo de compilacion mediante el
   cual el programa principal puede habilitar caracteristicas opcionales
   mediante la importacion en blanco de paquetes adicionales. Primero veremos
   como usarlo, luego veremos como funciona.

#    The standard library’s @c(image) package exports a @c(Decode) function that
#    reads bytes from an @c(io.Reader), figures out which image format was used to
#    encode the data, invokes the appropriate decoder, then returns the resulting
#    @c(image.Image). Using @c(image.Decode), it’s easy to build a simple image
#    converter that reads an image in one format and writes it out in another:
   De la biblioteca estandar el paquete @c(image) exporta una funcion @c(Decode)
   que lee bytes desde un @c(io.Reader), se da cuenta de que el formato de
   imagen se utiliza para codificar los datos, invoca el decodificador
   apropiado, a continuacion, devuelve la resultante @c(image.Image). Usando
   @c(image.Decode), es facil construir un convertidor de imagenes simple que
   lee una imagen en un formato y lo escribe en otro:

#    ..figure > @l(gopl.io/ch10/jpeg/main.go<>gopl.io/ch10/jpeg)
   ..figure > @l(gopl.io/ch10/jpeg/main.go<>gopl.io/ch10/jpeg)

#      ..src > go
#        // The jpeg command reads a PNG image from the standard input
#        // and writes it as a JPEG image to the standard output.
#        package main
#
#        import (
#          "fmt"
#          "image"
#          "image/jpeg"
#          _ "image/png" // register PNG decoder
#          "io"
#          "os"
#        )
#
#        func main() {
#          if err := toJPEG(os.Stdin, os.Stdout); err != nil {
#            fmt.Fprintf(os.Stderr, "jpeg: %v\n", err)
#            os.Exit(1)
#          }
#        }
#
#        func toJPEG(in io.Reader, out io.Writer) error {
#          img, kind, err := image.Decode(in)
#          if err != nil {
#            return err
#          }
#          fmt.Fprintln(os.Stderr, "Input format =", kind)
#          return jpeg.Encode(out, img, &jpeg.Options{Quality: 95})
#        }
#      < src..
     ..src > go
       // El comando jpeg lee una imagen PNG de la entrada estandar
       // y lo escribe como una imagen JPEG en la salida estandar.
       package main

       import (
         "fmt"
         "image"
         "image/jpeg"
         _ "image/png" // registra decodificador PNG
         "io"
         "os"
       )

       func main() {
         if err := toJPEG(os.Stdin, os.Stdout); err != nil {
           fmt.Fprintf(os.Stderr, "jpeg: %v\n", err)
           os.Exit(1)
         }
       }

       func toJPEG(in io.Reader, out io.Writer) error {
         img, kind, err := image.Decode(in)
         if err != nil {
           return err
         }
         fmt.Fprintln(os.Stderr, "Input format =", kind)
         return jpeg.Encode(out, img, &jpeg.Options{Quality: 95})
       }
     < src..


#    If we feed the output of @c(gopl.io/ch3/mandelbrot) (@l(#Section 3.3<>§3.3))
#    to the converter program, it detects the PNG input format and writes a JPEG
#    version of Figure 3.3.
   Si alimentamos con la salida de @c(gopl.io/ch3/mandelbrot) (@l(#Seccion
   3.3<>§3.3)) al programa convertidor, detecta el formato de entrada PNG y
   escribe una version JPEG de la Figura 3.3.

#    ..src > sh
#      $ go build gopl.io/ch3/mandelbrot
#      $ go build gopl.io/ch10/jpeg
#      $ ./mandelbrot | ./jpeg >mandelbrot.jpg
#      Input format = png
#    < src..
   ..src > sh
     $ go build gopl.io/ch3/mandelbrot
     $ go build gopl.io/ch10/jpeg
     $ ./mandelbrot | ./jpeg >mandelbrot.jpg
     Input format = png
   < src..

#    Notice the blank import of @c(image/png). Without that line, the program
#    compiles and links as usual but can no longer recognize or decode input in
#    PNG format:
   Observe la importacion en blanco de @c(image/png). Sin esa linea, el programa
   compila y vincula como de costumbre, pero ya no puede reconocer o decodificar
   la entrada en formato PNG:

#    ..src > sh
#      $ go build gopl.io/ch10/jpeg
#      $ ./mandelbrot | ./jpeg >mandelbrot.jpg
#      jpeg: image: unknown format
#    < src..
   ..src > sh
     $ go build gopl.io/ch10/jpeg
     $ ./mandelbrot | ./jpeg >mandelbrot.jpg
     jpeg: image: unknown format
   < src..

#    Here’s how it works. The standard library provides decoders for GIF, PNG, and
#    JPEG, and users may provide others, but to keep executables small, decoders
#    are not included in an application unless explicitly requested. The
#    @c(image.Decode) function consults a table of supported formats. Each entry
#    in the table specifies four things: the name of the format; a string that is
#    a prefix of all images encoded this way, used to detect the encoding; a
#    function @c(Decode) that decodes an encoded image; and another function
#    @c(DecodeConfig) that decodes only the image metadata, such as its size and
#    color space. An entry is added to the table by calling
#    @c(image.RegisterFormat), typically from within the package initializer of
#    the supporting package for each format, like this one in @c(image/png):
   Asi es como funciona. La biblioteca estandar ofrece descodificadores para
   GIF, PNG y JPEG, y los usuarios pueden proporcionar otros, pero para mantener
   pequeños ejecutables, los decodificadores no se incluyen en una aplicacion a
   menos que se solicite explicitamente. la funcion @c(image.Decode) consulta
   una tabla de formatos soportados. Cada entrada en la tabla especifica cuatro
   cosas: el nombre del formato; Una cadena que es un prefijo de todas las
   imagenes codificadas de esta manera, utilizadas para detectar la
   codificacion; una funcion @c(Decode) que decodifica una imagen codificada; y
   otra funcion @c(DecodeConfig) que decodifica solo los metadatos de la imagen,
   como su tamaño y espacio de color. Se añade una entrada a la tabla llamando a
   @c(image.RegisterFormat), normalmente desde destro del paquete inicializador
   del paquete de soporte para cada formato, como este en @c(image/png) :

#    ..src > go
#      package png // image/png
#
#      func Decode(r io.Reader) (image.Image, error)
#      func DecodeConfig(r io.Reader) (image.Config, error)
#
#      func init() {
#        const pngHeader = "\x89PNG\r\n\x1a\n"
#        image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
#      }
#    < src..
   ..src > go
     package png // image/png

     func Decode(r io.Reader) (image.Image, error)
     func DecodeConfig(r io.Reader) (image.Config, error)

     func init() {
       const pngHeader = "\x89PNG\r\n\x1a\n"
       image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
     }
   < src..

#    The effect is that an application need only blank-import the package for the
#    format it needs to make the @c(image.Decode) function able to decode it.
   El efecto es que una aplicacion solo necesita importar el paquete en blanco
   para el formato que necesita para hacer a la funcion @c(image.Decode) capaz
   de decodificarlo.

#    The @c(database/sql) package uses a similar mechanism to let users install
#    just the database drivers they need. For example:
   El paquete @c(database/sql) utiliza un mecanismo similar para permitir a los
   usuarios instalar solo los controladores de base de datos que necesita. Por
   ejemplo:

#    ..src > go
#      import (
#        "database/mysql"
#        _ "github.com/lib/pq"                // enable support for Postgres
#        _ "github.com/go-sql-driver/mysql"   // enable support for MySQL
#      )
#
#      db, err = sql.Open("postgres", dbname) // OK
#      db, err = sql.Open("mysql", dbname)    // OK
#      db, err = sql.Open("sqlite3", dbname)  // returns error: unknown driver "sqlite3"
#    < src..
   ..src > go
     import (
       "database/mysql"
       _ "github.com/lib/pq"                // habilitira el soporte para Postgres
       _ "github.com/go-sql-driver/mysql"   // habilitira el soporte para MySQL
     )

     db, err = sql.Open("postgres", dbname) // OK
     db, err = sql.Open("mysql", dbname)    // OK
     db, err = sql.Open("sqlite3", dbname)  // devuelve error: controlador desconocido "sqlite3"
   < src..

#    @b(Exercise 10.1): Extend the @$(jpeg) program so that it converts any
#    supported input format to any output format, using @c(image.Decode) to detect
#    the input format and a flag to select the output format.
   @b(Ejercicio 10.1): Extender el programa @$(jpeg) para que convierte
   cualquier formato de entrada compatible con cualquier formato de salida,
   utilizando @c(image.Decode) para detectar el formato de entrada y una bandera
   para seleccionar el formato de salida.

#    @b(Exercise 10.2): Define a generic archive file-reading function capable of
#    reading ZIP files (@c(archive/zip)) and POSIX tar files (@c(archive/tar)).
#    Use a registration mechanism similar to the one described above so that
#    support for each file format can be plugged in using blank imports.
   @b(Ejercicio 10.2): Definir una funcion generica lectura de archivos capaz de
   leer archivos ZIP (@c(archive/zip)) y archivos tar POSIX (@c(archive/tar)).
   Utilice un mecanismo de registro similar al descrito anteriormente para que
   el soporte para cada formato de archivo se pueda conectar usando
   importaciones en blanco.

# ** Section 10.6 <> Packages and Naming
** Seccion 10.6 <> Paquetes y Nombres

#    In this section, we’ll offer some advice on how to follow Go’s distinctive
#    conventions for naming packages and their members.
   En esta seccion, ofreceremos algunos consejos sobre como seguir las
   distintivas convenciones de Go para nombrar paquetes y sus miembros.

#    When creating a package, keep its name short, but not so short as to be
#    cryptic. The most frequently used packages in the standard library are named
#    @c(bufio), @c(bytes), @c(flag), @c(fmt), @c(http), @c(io), @c(json), @c(os),
#    @c(sort), @c(sync), and @c(time).
   Al crear un paquete, mantenga su nombre corto, pero no tan corto como para
   ser criptico. Los paquetes mas utilizados en la biblioteca estandar se
   nombran @c(bufio), @c(bytes), @c(flag), @c(fmt), @c(http), @c(io), @c(json),
   @c(os), @c(sort), @c(sync) y @c(time).

#    Be descriptive and unambiguous where possible. For example, don’t name a
#    utility package @c(util) when a name such as @c(imageutil) or @c(ioutil) is
#    specific yet still concise. Avoid choosing package names that are commonly
#    used for related local variables, or you may compel the package’s clients to
#    use renaming imports, as with the @c(path) package.
   Sea descriptivo y sin ambigüedades donde sea posible. Por ejemplo, no nombre
   un paquete de utilidades @c(util) cuando un nombre como @c(imageutil) o
   @c(ioutil) es especifico y aun asi conciso. No se debe elegir nombres de los
   paquetes que se utilizan comunmente para las variables locales relacionados,
   o puede obligar a los clientes del paquete a renombrar las importaciones, al
   igual que con el paquete @c(path).

#    Package names usually take the singular form. The standard packages
#    @c(bytes), @c(errors), and @c(strings) use the plural to avoid hiding the
#    corresponding predeclared types and, in the case of @c(go/types), to avoid
#    conflict with a keyword.
   Los nombres de los paquetes usualmente toman la forma singular. Los paquetes
   estandar @c(bytes), @c(errors) y @c(strings) utilizan el plural para evitar
   ocultar los tipos predeclarados correspondientes y, en el caso de
   @c(go/types), para evitar conflictos con una palabra clave.

#    Avoid package names that already have other connotations. For example, we
#    originally used the name @c(temp) for the temperature conversion package in
#    @l(#Section 2.5), but that didn’t last long. It was a terrible idea because
#    @"(temp) is an almost universal synonym for @"(temporary.) We went through a
#    brief period with the name @c(temperature), but that was too long and didn’t
#    say what the package did. In the end, it became @c(tempconv), which is
#    shorter and parallel with @c(strconv).
   Evite nombres de paquetes que ya tengan otras connotaciones. Por ejemplo, se
   utilizamos originalmente el nombre @c(temp) para el paquete de conversion de
   temperatura en la @l(#Seccion 2.5), pero eso no duro mucho tiempo. Era una
   idea terrible, porque @"(temp) es un sinonimo casi universal de
   @"(temporal). Pasamos de un breve periodo con el nombre @c(temperature), pero
   que era demasiado largo y no decia lo que hace el paquete. Al final, se
   convirtio en @c(tempconv), que es mas corto y paralelo con @c(strconv) .

#    Now let’s turn to the naming of package members. Since each reference to a
#    member of another package uses a qualified identifier such as
#    @c(fmt.Println), the burden of describing the package member is borne equally
#    by the package name and the member name. We need not mention the concept of
#    formatting in @c(Println) because the package name @c(fmt) does that
#    already. When designing a package, consider how the two parts of a qualified
#    identifier work together, not the member name alone. Here are some
#    characteristic examples:
   Ahora pasemos a la nomenclatura de los miembros del paquete. Puesto que cada
   referencia a un miembro de otro paquete utiliza un identificador calificado
   como @c(fmt.Println), la carga de describir el elemento del paquete es
   soportado igualmente por el nombre del paquete y el nombre del miembro. No
   tenemos que mencionar el concepto de formateo en @c(Println) debido a que el
   nombre del paquete @c(fmt) ya hace eso. Al diseñar un paquete, considere como
   funcionan las dos partes de un identificador cualificado, no solo el nombre
   del miembro. Estos son algunos ejemplos caracteristicos:

#    ..pre >
#      bytes.Equal     flag.Int     http.Get     json.Marshal
   ..pre >
     bytes.Equal     flag.Int     http.Get     json.Marshal

#    We can identify some common naming patterns. The @c(strings) package provides
#    a number of independent functions for manipulating strings:
   Podemos identificar algunos patrones de denominacion comunes. El paquete
   @c(strings) proporciona una serie de funciones para manipular cadenas
   independientes:

#    ..src > go
#      package strings
#
#      func Index(needle, haystack string) int
#
#      type Replacer struct{ /* ... */ }
#      func NewReplacer(oldnew ...string) *Replacer
#
#      type Reader struct{ /* ... */ }
#      func NewReader(s string) *Reader
#    < src..
   ..src > go
     package strings

     func Index(needle, haystack string) int

     type Replacer struct{ /* ... */ }
     func NewReplacer(oldnew ...string) *Replacer

     type Reader struct{ /* ... */ }
     func NewReader(s string) *Reader
   < src..

#    The word @c(string) does not appear in any of their names. Clients refer to
#    them as @c(strings.Index), @c(strings.Replacer), and so on.
   La palabra @c(string) no aparece en ninguno de sus nombres. Los clientes se
   refieren a ellos como @c(strings.Index), @c(strings.Replacer), y asi
   sucesivamente.

#    Other packages that we might describe as @e(single-type packages), such as
#    @c(html/template) and @c(math/rand), expose one principal data type plus its
#    methods, and often a New function to create instances.
   Otros paquetes que podriamos describir como paquetes de un solo tipo, como
   @c(html/template) y @c(math/rand), exponen un tipo de datos principal mas sus
   metodos, y con frecuencia una nueva funcion para crear instancias.

#    ..src > go
#      package rand // "math/rand"
#
#      type Rand struct{ /* ... */ }
#      func New(source Source) *Rand
#    < src..
   ..src > go
     package rand // "math/rand"

     type Rand struct{ /* ... */ }
     func New(source Source) *Rand
   < src..

#    This can lead to repetition, as in @c(template.Template) or @c(rand.Rand),
#    which is why the names of these kinds of packages are often especially short.
   Esto puede conducir a la repeticion, como en @c(template.Template) o
   @c(rand.Rand), por lo que los nombres de estos tipos de paquetes suelen ser
   especialmente cortos.

#    At the other extreme, there are packages like @c(net/http) that have a lot of
#    names without a lot of structure, because they perform a complicated
#    task. Despite having over twenty types and many more functions, the package’s
#    most important members have the simplest names: @c(Get), @c(Post),
#    @c(Handle), @c(Error), @c(Client), @c(Server).
   En el otro extremo, hay paquetes como @c(net/http) que tienen una gran
   cantidad de nombres sin mucha estructura, ya que desempeñan una tarea
   complicada. A pesar de tener mas de veinte tipos y muchas mas funciones, los
   miembros mas importantes del paquete tienen los nombres mas simples: @c(Get),
   @c(Post), @c(Handle), @c(Error), @c(Client), @c(Server).

# ** Section 10.7 <> The Go Tool
** Seccion 10.7 <> La Herramienta Go

#    The rest of this chapter concerns the @$(go) tool, which is used for
#    downloading, querying, formatting, building, testing, and installing packages
#    of Go code.
   El resto de este capitulo se refiere a la herramienta @$(go), que se utiliza
   para descargar, consultar, formatear, crear, probar e instalar paquetes de
   codigo Go.

#    The @$(go) tool combines the features of a diverse set of tools into one
#    command set. It is a package manager (analogous to @$(apt) or @$(rpm)) that answers
#    queries about its inventory of packages, computes their dependencies, and
#    downloads them from remote version-control systems. It is a build system that
#    computes file dependencies and invokes compilers, assemblers, and linkers,
#    although it is intentionally less complete than the standard Unix
#    @$(make). And it is a test driver, as we will see in @l(#Chapter 11).
   La herramienta @$(go) combina las caracteristicas de un conjunto diverso de
   herramientas en un conjunto de comandos. Es un gestor de paquetes (analogo a
   @$(apt) o @$(rpm)) que responde a consultas sobre su inventario de paquetes,
   calcula sus dependencias y las descarga desde sistemas de control de
   versiones remotos. Es un sistema de construccion que calcula las dependencias
   de archivos e invoca compiladores, ensambladores, enlazadores, aunque es
   intencionalmente menos completo que el @$(make) estandar de Unix. Y es un
   operador de pruebas, como veremos en el @l(#Capitulo 11).

#    Its command-line interface uses the @"(Swiss army knife) style, with over a
#    dozen subcommands, some of which we have already seen, like @c(get), @c(run),
#    @c(build), and @c(fmt). You can run @$(go help) to see the index of its
#    built-in documentation, but for reference, we’ve listed the most commonly
#    used commands below:
   Su interfaz de linea de comandos utiliza el estilo @"(navaja suiza), con mas
   de una docena de subcomandos, algunos de los cuales ya hemos visto, como
   @c(get), @c(run), @c(build) y @c(fmt). Puede ejecutar @$(go help) a ver el
   indice de la documentacion incorporada, pero como referencia, hemos realizado
   una lista de los comandos mas utilizados a continuacion:

#    ..src > sh
#      $ go
#      ...
#          build       compile packages and dependencies
#          clean       remove object files
#          doc         show documentation for package or symbol
#          env         print Go environment information
#          fix         run go tool fix on packages
#          fmt         run gofmt on package sources
#          generate    generate Go files by processing source
#          get         download and install packages and dependencies
#          install     compile and install packages and dependencies
#          list        list packages
#          run         compile and run Go program
#          test        test packages
#          tool        run specified go tool
#          version     print Go version
#          vet         run go tool vet on packages
#
#      Use "go help [command]" for more information about a command.
#      ...
#    < src..
   ..src > sh
     $ go
     ...
         build       compile packages and dependencies
         clean       remove object files
         doc         show documentation for package or symbol
         env         print Go environment information
         fix         run go tool fix on packages
         fmt         run gofmt on package sources
         generate    generate Go files by processing source
         get         download and install packages and dependencies
         install     compile and install packages and dependencies
         list        list packages
         run         compile and run Go program
         test        test packages
         tool        run specified go tool
         version     print Go version
         vet         run go tool vet on packages

     Use "go help [command]" for more information about a command.
     ...
   < src..

#    To keep the need for configuration to a minimum, the @$(go) tool relies
#    heavily on conventions. For example, given the name of a Go source file, the
#    tool can find its enclosing package, because each directory contains a single
#    package and the import path of a package corresponds to the directory
#    hierarchy in the workspace. Given the import path of a package, the tool can
#    find the corresponding directory in which it stores object files. It can also
#    find the URL of the server that hosts the source code repository.
   Para mantener la necesidad de configuracion al minimo, la herramienta @$(go)
   se basa en gran medida en las convenciones. Por ejemplo, dado el nombre de un
   archivo fuente Go, la herramienta puede encontrar su paquete que lo contiene,
   ya que cada directorio contiene un unico paquete y la ruta de importacion de
   un paquete corresponde a la jerarquia de directorios en el espacio de
   trabajo. Dada la ruta de importacion de un paquete, la herramienta puede
   encontrar el directorio correspondiente en el que almacena los archivos de
   objeto. Tambien puede encontrar la direccion URL del servidor que aloja el
   repositorio de codigo fuente.

# *** Section 10.7.1 <> Workspace Organization
*** Seccion 10.7.1 <> Organizacion del Espacio de Trabajo

#     The only configuration most users ever need is the @c(GOPATH) environment
#     variable, which specifies the root of the workspace. When switching to a
#     different workspace, users update the value of @c(GOPATH). For instance, we
#     set @c(GOPATH) to @c($HOME/gobook) while working on this book:
    La unica configuracion de la mayoria de los usuarios necesitan es la
    variable de entorno @c(GOPATH), que especifica la raiz del espacio de
    trabajo. Cuando se cambia a otro espacio de trabajo, los usuarios actualizan
    el valor de @c(GOPATH). Por ejemplo, mientras trabajamos en este libro
    establecemos @c(GOPATH) a @c($HOME/gobook):

#     ..src > sh
#       $ export GOPATH=$HOME/gobook
#       $ go get gopl.io/...
#     < src..
    ..src > sh
      $ export GOPATH=$HOME/gobook
      $ go get gopl.io/...
    < src..

#     After you download all the programs for this book using the command above,
#     your workspace will contain a hierarchy like this one:
    Despues de descargar todos los programas de este libro utilizando el comando
    anterior, su espacio de trabajo contendra una jerarquia como esta:

#     ..pre >
#       GOPATH/
#             src/
#                 gopl.io/
#                         .git/
#                         ch1/
#                             helloworld/
#                                        main.go
#                             dup/
#                                 main.go
#                             ...
#                 golang.org/x/net/
#                                 .git/
#                                 html/
#                                     parse.go
#                                     node.go
#                                     ...
#             bin/
#                 helloworld
#                 dup
#             pkg/
#                 darwin_amd64/
#                 ...
#     < pre..
    ..pre >
      GOPATH/
            src/
                gopl.io/
                        .git/
                        ch1/
                            helloworld/
                                       main.go
                            dup/
                                main.go
                            ...
                golang.org/x/net/
                                .git/
                                html/
                                    parse.go
                                    node.go
                                    ...
            bin/
                helloworld
                dup
            pkg/
                darwin_amd64/
                ...
    < pre..

#     @c(GOPATH) has three subdirectories. The src subdirectory holds source
#     code. Each package resides in a directory whose name relative to
#     @c($GOPATH/src) is the package’s import path, such as
#     @c(gopl.io/ch1/helloworld). Observe that a single @c(GOPATH) workspace
#     contains multiple version-control repositories beneath @f(src), such as
#     @c(gopl.io) or @c(golang.org). The @f(pkg) subdirectory is where the build
#     tools store compiled packages, and the @f(bin) subdirectory holds executable
#     programs like @$(helloworld).
    @c(GOPATH) tiene tres subdirectorios. El subdirectorio @f(src) contiene el
    codigo fuente. Cada paquete reside en un directorio cuyo nombre en relacion
    con @c($GOPATH/src) es ruta de importacion del paquete, como
    @c(gopl.io/ch1/helloworld). Observe que un solo espacio de trabajo
    @c(GOPATH) contiene multiples repositorios de control de version debajo
    @f(src), como @c(gopl.io) o @c(golang.org). El subdirectorio @f(pkg) es
    donde las h herramientas de construccion almacenan paquetes compilados, y el
    subdirectorio @f(bin) contiene los programas ejecutables como @$(helloworld).

#     A second environment variable, @c(GOROOT), specifies the root directory of
#     the Go distribution, which provides all the packages of the standard
#     library. The directory structure beneath @c(GOROOT) resembles that of
#     @c(GOPATH), so, for example, the source files of the @c(fmt) package reside
#     in the @f($GOROOT/src/fmt) directory. Users never need to set @c(GOROOT)
#     since, by default, the @$(go) tool will use the location where it was installed.
    Una segunda variable de entorno, @$(GOROOT), especifica el directorio raiz
    de la distribucion Go, que ofrece todos los paquetes de la biblioteca
    estandar. La estructura de directorios debajo de @c(GOROOT) asemeja a la de
    @c(GOPATH), por lo que, por ejemplo, los archivos de origen del paquete
    @c(fmt) residen en el directorio @c($GOROOT/src/fmt). Los usuarios no
    necesitan configurar @c(GOROOT) ya que, por defecto, la herramienta de
    @$(go) utilizara la ubicacion donde se instalo.

#     The @$(go env) command prints the effective values of the environment
#     variables relevant to the toolchain, including the default values for the
#     missing ones. @c(GOOS) specifies the target operating system (for example,
#     @c(android), @c(linux), @c(darwin), or @c(windows)) and @c(GOARCH) specifies
#     the target processor architecture, such as @c(amd64), @c(386), or
#     @c(arm). Although @c(GOPATH) is the only variable you must set, the others
#     occasionally appear in our explanations.
    El comando @$(go env) imprime los valores efectivos de las variables de
    entorno correspondientes a la cadena de herramientas, incluidos los valores
    por defecto para los que faltan. @c(GOOS) especifica el sistema operativo de
    destino (por ejemplo, @c(android), @c(linux), @c(darwin), o @c(windows)) y
    @c(GOARCH) especifica la arquitectura de procesador objetivo, como
    @c(amd64), @c(386), o @c(arm). Aunque @c(GOPATH) es la unica variable que
    debe establecer, los demas de vez en cuando aparecen en nuestras
    explicaciones.

#     ..src > sh
#       $ go env
#       GOPATH="/home/gopher/gobook"
#       GOROOT="/usr/local/go"
#       GOARCH="amd64"
#       GOOS="darwin"
#     < src..
    ..src > sh
      $ go env
      GOPATH="/home/gopher/gobook"
      GOROOT="/usr/local/go"
      GOARCH="amd64"
      GOOS="darwin"
    < src..

# *** Section 10.7.2 <> Downloading Packages
*** Seccion 10.7.2 <> Descargando paquetes

#     When using the @$(go) tool, a package’s import path indicates not only where
#     to find it in the local workspace, but where to find it on the Internet so
#     that @$(go get) can retrieve and update it.
    Cuando se utiliza la herramienta @$(go), ruta de importacion de un paquete
    indica no solo donde encontrarlo en el espacio de trabajo local, sino donde
    encontrarlo en Internet para que @$(go get) pueda recuperarlo y
    actualizarlo.

#     The @$(go get) command can download a single package or an entire subtree or
#     repository using the @c(...) notation, as in the previous section. The tool
#     also computes and downloads all the dependencies of the initial packages,
#     which is why the @c(golang.org/x/net/html) package appeared in the workspace
#     in the previous example.
    El comando @$(go get) puede descargar un solo paquete o todo un subarbol o
    repositorio usando la notacion @c(...), como en la seccion anterior. La
    herramienta tambien calcula y descarga todas las dependencias de los
    paquetes iniciales, como el paquete @c(golang.org/x/net/html) que aparecio
    en el espacio de trabajo en el ejemplo anterior.

#     Once @$(go get) has downloaded the packages, it builds them and then
#     @e(installs) the libraries and commands. We’ll look at the details in the
#     next section, but an example will show how straightforward the process
#     is. The first command below gets the @$(golint) tool, which checks for
#     common style problems in Go source code. The second command runs @$(golint)
#     on @c(gopl.io/ch2/popcount) from @l(#Section 2.6.2). It helpfully reports
#     that we have forgotten to write a doc comment for the package:
    Una vez que @$(go get) ha descargado los paquetes, los construye y luego
    instala las librerias y comandos. Veremos los detalles en la siguiente
    seccion, pero un ejemplo mostrara lo sencillo que es el proceso. El primer
    comando a continuacion optiene la herramienta @$(golint), que comprueba si
    hay problemas de estilo comunes en codigo fuente Go. El segundo comando
    ejecuta @$(golint) en @c(gopl.io/ch2/popcount) de la @l(#Seccion 2.6.2). Es
    util que nos informe que hemos olvidado escribir un comentario de
    documentacion para el paquete:

#     ..src > sh
#       $ go get github.com/golang/lint/golint
#       $ $GOPATH/bin/golint gopl.io/ch2/popcount
#       src/gopl.io/ch2/popcount/main.go:1:1:
#         package comment should be of the form "Package popcount ..."
#     < src..
    ..src > sh
      $ go get github.com/golang/lint/golint
      $ $GOPATH/bin/golint gopl.io/ch2/popcount
      src/gopl.io/ch2/popcount/main.go:1:1:
        package comment should be of the form "Package popcount ..."
    < src..

#     The @$(go get) command has support for popular code-hosting sites like
#     GitHub, Bitbucket, and Launchpad and can make the appropriate requests to
#     their version-control systems. For less well-known sites, you may have to
#     indicate which version-control protocol to use in the import path, such as
#     Git or Mercurial. Run @$(go help importpath) for the details.
    El comando @$(go get) tiene soporte para los sitios de alojamiento de codigo
    populares como GitHub, Bitbucket y Launchpad y puede hacer las solicitudes
    apropiadas en sus sistemas de control de versiones. Para sitios menos
    conocidos, es posible que deba indicar que protocolo de control de versiones
    debe utilizar en la ruta de importacion, como Git o Mercurial. Ejecuta @$(go
    help importpath) para los detalles.

#     The directories that @$(go get) creates are true clients of the remote
#     repository, not just copies of the files, so you can use version-control
#     commands to see a diff of local edits you’ve made or to update to a
#     different revision. For example, the @f(golang.org/x/net) directory is a Git
#     client:
    Los directorios que @$(go get) crea son verdaderos clientes del repositorio
    remoto, no solo copias de los archivos, por lo que puede utilizar los
    comandos de control de versiones para ver un diff de ediciones locales que
    ha realizado o para actualizar a una revision diferente. Por ejemplo, el
    directorio @f(golang.org/x/net) es un cliente de Git:

#     ..src > sh
#       $ cd $GOPATH/src/golang.org/x/net
#       $ git remote -v
#       origin  https://go.googlesource.com/net (fetch)
#       origin  https://go.googlesource.com/net (push)
#     < src..
    ..src > sh
      $ cd $GOPATH/src/golang.org/x/net
      $ git remote -v
      origin  https://go.googlesource.com/net (fetch)
      origin  https://go.googlesource.com/net (push)
    < src..

#     Notice that the apparent domain name in the package’s import path,
#     @c(https://golang.org<>golang.org), differs from the actual domain name of
#     the Git server, @c(https://go.googlesource.com/<>go.googlesource.com). This
#     is a feature of the go tool that lets packages use a custom domain name in
#     their import path while being hosted by a generic service such as
#     @l(https://googlesource.com) or @l(https://github.com). HTML pages beneath
#     @l(https://golang.org/x/net/html) include the metadata shown below, which
#     redirects the @$(go) tool to the Git repository at the actual hosting site:
    Observe que el nombre de dominio en ruta de importacion del paquete,
    @c(golang.org), difiere del nombre de dominio real del servidor Git,
    @c(go.googlesource.com). Esta es una caracteristica de la herramienta Go que
    permite que lo paquetes usen un nombre de dominio personalizado en su ruta
    de importacion al ser alojados por un servicio generico como
    @l(https://googlesource.com) o @l(https://github.com). Paginas HTML debajo
    de @l(https://golang.org/x/net/html) incluyen los metadatos que se muestran
    a continuacion, que redirecciona la herramienta @$(go) al repositorio Git en
    el lugar del alojamiento actual:

#     ..src > sh
#       $ go build gopl.io/ch1/fetch
#       $ ./fetch https://golang.org/x/net/html | grep go-import
#       <meta name="go-import"
#             content="golang.org/x/net git https://go.googlesource.com/net">
#     < src..
    ..src > sh
      $ go build gopl.io/ch1/fetch
      $ ./fetch https://golang.org/x/net/html | grep go-import
      <meta name="go-import"
            content="golang.org/x/net git https://go.googlesource.com/net">
    < src..

#     If you specify the @c(-u) flag, @$(go get) will ensure that all packages it
#     visits, including dependencies, are updated to their latest version before
#     being built and installed. Without that flag, packages that already exist
#     locally will not be updated.
    Si especifica la bandera @c(-u), @$(go get) se asegurara de que todos los
    paquetes que visita, incluidas las dependencias, se actualizan a su ultima
    version antes de ser construido e instalado. Sin ese indicador, los paquetes
    que ya existen localmente no se actualizaran.

#     The @$(go get -u) command generally retrieves the latest version of each
#     package, which is convenient when you’re getting started but may be
#     inappropriate for deployed projects, where precise control of dependencies
#     is critical for release hygiene. The usual solution to this problem is to
#     @e(vendor) the code, that is, to make a persistent local copy of all the
#     necessary dependencies, and to update this copy carefully and
#     deliberately. Prior to Go 1.5, this required changing those packages’ import
#     paths, so our copy of @c(golang.org/x/net/html) would become
#     @c(gopl.io/vendor/golang.org/x/net/html). More recent versions of the go
#     tool support vendoring directly, though we don’t have space to show the
#     details here. See @e(Vendor Directories) in the output of the @$(go help
#     gopath) command.
    El comando @$(go get -u) recupera generalmente la ultima version de cada
    paquete, lo cual es conveniente cuando se inicia, pero puede ser inadecuado
    para proyectos desplegados, donde el control preciso de dependencias es
    critico para la higiene de la liberacion. La solucion habitual a este
    problema es el @e(proveedor) del codigo, es decir, hacer una copia local
    persistente de todas las dependencias necesarias, para actualizar esta copia
    cuidadosa y deliberadamente. Antes de Go 1.5, esto requiere cambiar las
    rutas de importacion esos paquetes, por lo que nuestra copia de
    @c(golang.org/x/net/html) se convertiria en
    @c(gopl.io/vendor/golang.org/x/net/html). Las versiones mas recientes de la
    herramienta soportan directorios de proveedores directamente, aunque no
    tenemos espacio para mostrar los detalles aqui. Vea @e(Directorios de
    Proveedores) en la salida del comando @$(go help gopath).

#     @b(Exercise 10.3): Using @$(fetch http://gopl.io/ch1/helloworld?go-get=1),
#     find out which service hosts the code samples for this book. (HTTP requests
#     from @$(go get) include the @c(go-get) parameter so that servers can distinguish
#     them from ordinary browser requests.)
    @b(Ejercicio 10.3): Utilizando @$(fetch http://gopl.io/ch1/helloworld?go-get=1),
    averigüe que servicio alberga los ejemplos de codigo para este libro.  (Las
    peticiones HTTP de @$(go get) incluyen el parametro @c(go-get) para que los
    servidores pueden distinguirlos de las solicitudes del navegador comun.)

# *** Section 10.7.3 <> Building Packages
*** Seccion 10.7.3 <> Construccion de Paquetes

#     The @$(go build) command compiles each argument package. If the package is a
#     library, the result is discarded; this merely checks that the package is
#     free of compile errors. If the package is named @c(main), @$(go build)
#     invokes the linker to create an executable in the current directory; the
#     name of the executable is taken from the last segment of the package’s
#     import path.
    El comando @$(go build) compila cada argumento de paquete. Si el paquete es
    una libreria, el resultado se descarta; Esto simplemente comprueba que el
    paquete esta libre de errores de compilacion. Si el paquete se llama
    @c(main), @$(go build) invoca el enlazador para crear un archivo ejecutable
    en el directorio actual; El nombre del ejecutable se toma del ultimo
    segmento de la ruta de importacion del paquete.

#     Since each directory contains one package, each executable program, or
#     @e(command) in Unix terminology, requires its own directory. These
#     directories are sometimes children of a directory named @c(cmd), such as the
#     @c(golang.org/x/tools/cmd/godoc) command which serves Go package
#     documentation through a web interface (@l(#Section 10.7.4<>§10.7.4)).
    Dado que cada directorio contiene un solo paquete, cada programa ejecutable,
    o @e(comando) en la terminologia Unix, requiere su propio directorio. Estos
    directorios son a veces los hijos de un directorio denominado @c(cmd), como
    el comando @c(golang.org/x/tools/cmd/godoc) que sirve la documentacion del
    paquete Go a traves de una interfaz web (@l(#Seccion 10.7.4<>§10.7.4)).

#     Packages may be specified by their import paths, as we saw above, or by a
#     relative directory name, which must start with a @c(.) or @c(..) segment
#     even if this would not ordinarily be required.  If no argument is provided,
#     the current directory is assumed. Thus the following commands build the same
#     package, though each writes the executable to the directory in which @$(go
#     build) is run:
    Los paquetes pueden especificarse por sus rutas de importacion, como hemos
    visto anteriormente, o por un nombre de directorio relativo, que debe
    comenzar con un @c(.) o @c(..) aun si ordinariamente no se requere. Si no se
    proporciona ningun argumento, se supone el directorio actual. Por lo tanto
    los siguientes comandos construyen el mismo paquete, aunque cada uno escribe
    el ejecutable en el directorio en el que @$(go build) se ejecuta:

#     ..src > sh
#       $ cd $GOPATH/src/gopl.io/ch1/helloworld
#       $ go build
#     < src..
    ..src > sh
      $ cd $GOPATH/src/gopl.io/ch1/helloworld
      $ go build
    < src..

#     and:
y:

#     ..src > sh
#       $ cd anywhere
#       $ go build gopl.io/ch1/helloworld
#     < src..
    ..src > sh
      $ cd anywhere
      $ go build gopl.io/ch1/helloworld
    < src..

#     and:
y:

#     ..src > sh
#       $ cd $GOPATH
#       $ go build ./src/gopl.io/ch1/helloworld
#     < src..
    ..src > sh
      $ cd $GOPATH
      $ go build ./src/gopl.io/ch1/helloworld
    < src..

#     but not:
pero no:

#     ..src > sh
#       $ cd $GOPATH
#       $ go build src/gopl.io/ch1/helloworld
#       Error: cannot find package "src/gopl.io/ch1/helloworld".
#     < src..
    ..src > sh
      $ cd $GOPATH
      $ go build src/gopl.io/ch1/helloworld
      Error: cannot find package "src/gopl.io/ch1/helloworld".
    < src..

#     Packages may also be specified as a list of file names, though this tends to
#     be used only for small programs and one-off experiments. If the package name
#     is @c(main), the executable name comes from the basename of the first @f(.go)
#     file.
    Los paquetes tambien se pueden especificar como una lista de nombres de
    archivo, aunque esto tiende a utilizarse solo para programas pequeños y
    experimentos puntuales. Si el nombre del paquete es @c(main), el nombre del
    ejecutable viene del nombre base del primer archivo @f(.go).

#     ..src > sh
#       $ cat quoteargs.go
#       package main
#
#       import (
#         "fmt"
#         "os"
#       )
#
#       func main() {
#         fmt.Printf("%q\n", os.Args[1:])
#       }
#       $ go build quoteargs.go
#       $ ./quoteargs one "two three" four\ five
#       ["one" "two three" "four five"]
#     < src..
    ..src > sh
      $ cat quoteargs.go
      package main

      import (
        "fmt"
        "os"
      )

      func main() {
        fmt.Printf("%q\n", os.Args[1:])
      }
      $ go build quoteargs.go
      $ ./quoteargs one "two three" four\ five
      ["one" "two three" "four five"]
    < src..

#     Particularly for throwaway programs like this one, we want to run the
#     executable as soon as we’ve built it. The @$(go run) command combines these
#     two steps:
    Especialmente para programas descartables como este, queremos ejecutar el
    archivo ejecutable tan pronto como lo hayamos construido. El comando @$(go
    run) combina estos dos pasos:

#     ..src > sh
#       $ go run quoteargs.go one "two three" four\ five
#       ["one" "two three" "four five"]
#     < src..
    ..src > sh
      $ go run quoteargs.go one "two three" four\ five
      ["one" "two three" "four five"]
    < src..

#     The first argument that doesn’t end in @f(.go) is assumed to be the
#     beginning of the list of arguments to the Go executable.
    El primer argumento que no termina en @f(.go) se asume como el principio de
    la lista de argumentos para el ejecutable de Go.

#     By default, the @$(go build) command builds the requested package and all
#     its dependencies, then throws away all the compiled code except the final
#     executable, if any. Both the dependency analysis and the compilation are
#     surprisingly fast, but as projects grow to dozens of packages and hundreds
#     of thousands of lines of code, the time to recompile dependencies can become
#     noticeable, potentially several seconds, even when those dependencies
#     haven’t changed at all.
    Por defecto, el comando @$(go build) construye el paquete solicitado y todas
    sus dependencias, y luego tira a la basura todo el codigo compilado, excepto
    el ejecutable final, si lo hubiera. Tanto el analisis de dependencias como
    la compilacion son sorprendentemente rapidos, pero a medida que los
    proyectos crecen hasta decenas de paquetes y cientos de miles de lineas de
    codigo, el tiempo para recompilar las dependencias puede llegar a ser
    notable, potencialmente varios segundos, incluso cuando no todas las
    dependencias han cambiado.

#     The @$(go install) command is very similar to @$(go build), except that it
#     saves the compiled code for each package and command instead of throwing it
#     away. Compiled packages are saved beneath the @f($GOPATH/pkg) directory
#     corresponding to the @f(src) directory in which the source resides, and
#     command executables are saved in the @f($GOPATH/bin) directory. (Many users
#     put @f($GOPATH/bin) on their executable search path.) Thereafter, @$(go
#     build) and @$(go install) do not run the compiler for those packages and
#     commands if they have not changed, making subsequent builds much faster. For
#     convenience, @$(go build -i) installs the packages that are dependencies of
#     the build target.
    El comando @$(go install) es muy similar a @$(go build), excepto que guarda
    el codigo compilado para cada paquete y comando en lugar de tirarlo a la
    basura. Los paquetes compilados se guardan bajo el directorio
    @f($GOPATH/pkg) correspondiente al directorio @f(src) en el que reside el
    codigo fuente y los ejecutables de comando se guardan en el directorio
    @f($GOPATH/bin). (Muchos usuarios agregar @f($GOPATH/bin) en su ruta de
    busqueda ejecutable.) A partir de entonces, @$(go build) y @$(go install) no
    ejecutan el compilador para esos paquetes y comandos si no han cambiado,
    haciendo las compilaciones posteriores mucho mas rapido. Por cenveniencia,
    @$(go build -i) instala los paquetes que son dependencias del objetivo a
    compilar.

#     Since compiled packages vary by platform and architecture, @$(go install)
#     saves them beneath a subdirectory whose name incorporates the values of the
#     @c(GOOS) and @c(GOARCH) environment variables. For example, on a Mac the
#     @c(golang.org/x/net/html) package is compiled and installed in the file
#     @f(golang.org/x/net/html.a) under @f($GOPATH/pkg/darwin_amd64).
    Dado que los paquetes compilados varian segun la plataforma y la
    arquitectura, @$(go install) los guarda debajo de un subdirectorio cuyo
    nombre incorpora los valores de las variables de entorno @c(GOOS) y
    @c(GOARCH). Por ejemplo, en un Mac el paquete @c(golang.org/x/net/html) se
    compila e instala en el archivo @f(golang.org/x/net/html.a) bajo
    @f($GOPATH/pkg/darwin_amd64).

#     It is straightforward to @e(cross-compile) a Go program, that is, to build
#     an executable intended for a different operating system or CPU. Just set the
#     @c(GOOS) or @c(GOARCH) variables during the build.  The @$(cross) program
#     prints the operating system and architecture for which it was built:
    Es facil aplicar @e(compilacion cruzada) a un programa Go, es decir,
    construir un ejecutable destinado a un sistema operativo diferente o
    CPU. Solo hay que establecer las variables @c(GOOS) o @c(GOARCH) durante la
    construccion. El programa @$(cross) imprime el sistema operativo y la
    arquitectura para la que fue construido:

#     ..figure > @l(gopl.io/ch10/cross/main.go<>gopl.io/ch10/cross)
    ..figure > @l(gopl.io/ch10/cross/main.go<>gopl.io/ch10/cross)

#       ..src > go
#         func main() {
#           fmt.Println(runtime.GOOS, runtime.GOARCH)
#         }
#       < src..
      ..src > go
        func main() {
          fmt.Println(runtime.GOOS, runtime.GOARCH)
        }
      < src..


#     The following commands produce 64-bit and 32-bit executables respectively:
    Los comandos siguientes producen ejecutables de 64 bits y 32 bits,
    respectivamente:

#     ..src > sh
#       $ go build gopl.io/ch10/cross
#       $ ./cross
#       darwin amd64
#       $ GOARCH=386 go build gopl.io/ch10/cross
#       $ ./cross
#       darwin 386
#     < src..
    ..src > sh
      $ go build gopl.io/ch10/cross
      $ ./cross
      darwin amd64
      $ GOARCH=386 go build gopl.io/ch10/cross
      $ ./cross
      darwin 386
    < src..

#     Some packages may need to compile different versions of the code for certain
#     platforms or processors, to deal with low-level portability issues or to
#     provide optimized versions of important routines, for instance. If a file
#     name includes an operating system or processor architecture name like
#     @f(net_linux.go) or @f(asm_amd64.s), then the @$(go) tool will compile the
#     file only when building for that target. Special comments called @e(build
#     tags) give more fine-grained control. For example, if a file contains this
#     comment:
    Algunos paquetes pueden necesitar compilar versiones diferentes del codigo
    para ciertas plataformas o procesadores, para tratar problemas de
    portabilidad de bajo nivel o para proporcionar versiones optimizadas de
    rutinas importantes, por ejemplo. Si un nombre de archivo incluye un sistema
    operativo o arquitectura de procesador, como @f(net_linux.go) o
    @f(asm_amd64.s), la herramienta @$(go) compilara el archivo solo cuando se
    construye para ese objetivo. Comentarios especiales llamadas @e(etiquetas de
    compilacion) ofrecen un control mas detallado. Por ejemplo, si un archivo
    contiene este comentario:

#     ..src > go
#       // +build linux darwin
#     < src..
    ..src > go
      // +build linux darwin
    < src..

#     before the package declaration (and its doc comment), @$(go build) will
#     compile it only when building for Linux or Mac OS X, and this comment says
#     never to compile the file:
    antes de la declaracion del paquete (y su comentario de documentacion),
    @$(go build) compilara solo cuando se compile para Linux o Mac OS X, y este
    comentario indica nunca compilar el archivo:

#     ..src > go
#       // +build ignore
#     < src..
    ..src > go
      // +build ignore
    < src..

#     For more details, see the @e(Build Constraints) section of the @c(go/build)
#     package’s documentation:
    Para mas detalles, consulte la seccion @e(Build Constraints) de la
    documentacion del paquete @c(go/build):

#     ..src > sh
#       $ go doc go/build
#     < src..
    ..src > sh
      $ go doc go/build
    < src..

# *** Section 10.7.4 <> Documenting Packages
*** Seccion 10.7.4 <> Documentacion de Paquetes

#     Go style strongly encourages good documentation of package APIs. Each
#     declaration of an exported package member and the package declaration itself
#     should be immediately preceded by a comment explaining its purpose and
#     usage.
    El estilo Go anima fuertemente la buena documentacion de las API del
    paquete. Cada declaracion de un miembro del paquete exportado y la propia
    declaracion del paquete deben ir precedidas inmediatamente de un comentario
    que explique su proposito y uso.

#     Go @e(doc comments) are always complete sentences, and the first sentence is
#     usually a summary that starts with the name being declared. Function
#     parameters and other identifiers are mentioned without quotation or
#     markup. For example, here’s the doc comment for @c(fmt.Fprintf):
    Los @e(comentarios de documentacion) de Go siempre son oraciones completas,
    y la primera frase es por lo general un resumen que se inicia con el nombre
    que se declaro. Los parametros de funcion y otros identificadores se
    mencionan sin citacion o marcado. Por ejemplo, aqui esta el comentario de
    documentacion para @c(fmt.Fprintf):

#     ..src > go
#       // Fprintf formats according to a format specifier and writes to w.
#       // It returns the number of bytes written and any write error encountered.
#       func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)
#     < src..
    ..src > go
      // Fprintf formateo de acuerdo con un especificador de formato y escriben w.
      // Devuelve el numero de bytes escritos y cualquier error de escritura encontrado.
      func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)
    < src..

#     The details of @c(Fprintf)’s formatting are explained in a doc comment
#     associated with the @c(fmt) package itself. A comment immediately preceding
#     a @c(package) declaration is considered the doc comment for the package as a
#     whole. There must be only one, though it may appear in any file. Longer
#     package comments may warrant a file of their own; @c(fmt)’s is over 300
#     lines.  This file is usually called @f(doc.go).
    Los detalles del formateo de @c(Fprintf) se explican en un comentario de
    documentacion asociado al paquete @c(fmt) en si. Un comentario que precede
    inmediatamente a una declaracion @c(package) se considera el comentario de
    documentacion para el paquete en su conjunto. Solo debe haber uno, aunque
    pueda aparecer en cualquier archivo. Los comentarios de paquetes mas largos
    pueden justificar un archivo propio; @c(fmt) tiene mas de 300 lineas. Este
    archivo normalmente se llama @f(doc.go) .

#     Good documentation need not be extensive, and documentation is no substitute
#     for simplicity.  Indeed, Go’s conventions favor brevity and simplicity in
#     documentation as in all things, since documentation, like code, requires
#     maintenance too. Many declarations can be explained in one well-worded
#     sentence, and if the behavior is truly obvious, no comment is needed.
#     Throughout the book, as space permits, we’ve preceded many declarations by
#     doc comments, but you will find better examples as you browse the standard
#     library. Two tools can help you do that.
    Una buena documentacion no necesita ser extensa, y la documentacion no es un
    sustituto de la sencillez. De hecho, las convenciones de Go favorecen la
    brevedad y simplicidad en la documentacion como en todas las cosas, ya que
    la documentacion, como el codigo, tambien requiere mantenimiento. Muchas
    declaraciones se pueden explicar en una oracion bien redactada, y si el
    comportamiento es realmente obvio, no necesita comentarse. A lo largo del
    libro, a medida que el espacio lo permite, hemos precedido a muchas
    declaraciones por comentarios de documentacion, pero encontraremos mejores
    ejemplos buscando en la biblioteca estandar. Dos herramientas pueden
    ayudarte a hacer eso.

#     The @$(go doc) tool prints the declaration and doc comment of the entity
#     specified on the command line, which may be a package:
    La herramienta @$(go doc) imprime la declaracion y el comentario de
    documentacion de la entidad especificada en la linea de comandos, que puede
    ser un paquete:

#     ..src > sh
#       $ go doc time
#       package time // import "time"
#
#       Package time provides functionality for measuring and displaying time.
#
#       const Nanosecond Duration = 1 ...
#       func After(d Duration) <-chan Time
#       func Sleep(d Duration)
#       func Since(t Time) Duration
#       func Now() Time
#       type Duration int64
#       type Time struct { ... }
#       ...many more...
#     < src..
    ..src > sh
      $ go doc time
      package time // import "time"

      Package time provides functionality for measuring and displaying time.

      const Nanosecond Duration = 1 ...
      func After(d Duration) <-chan Time
      func Sleep(d Duration)
      func Since(t Time) Duration
      func Now() Time
      type Duration int64
      type Time struct { ... }
      ...many more...
    < src..

#     or a package member:
    O un miembro del paquete:

#     ..src > sh
#       $ go doc time.Since
#       func Since(t Time) Duration
#
#           Since returns the time elapsed since t.
#           It is shorthand for time.Now().Sub(t).
#     < src..
    ..src > sh
      $ go doc time.Since
      func Since(t Time) Duration

          Since returns the time elapsed since t.
          It is shorthand for time.Now().Sub(t).
    < src..

#     or a method:
    O un metodo:

#     ..src > sh
#       $ go doc time.Duration.Seconds
#       func (d Duration) Seconds() float64
#
#           Seconds returns the duration as a floating-point number of seconds.
#     < src..
    ..src > sh
      $ go doc time.Duration.Seconds
      func (d Duration) Seconds() float64

          Seconds returns the duration as a floating-point number of seconds.
    < src..

#     The tool does not need complete import paths or correct identifier
#     case. This command prints the documentation of @c[(*json.Decoder).Decode]
#     from the @c(encoding/json) package:
    La herramienta no necesita rutas de importacion completas o casos de
    identificador exactos. Este comando imprime la documentacion de
    @c[(*json.Decoder).Decode] del paquete @c(encoding/json):

#     ..src > sh
#       $ go doc json.decode
#       func (dec *Decoder) Decode(v interface{}) error
#
#           Decode reads the next JSON-encoded value from its input and stores
#           it in the value pointed to by v.
#     < src..
    ..src > sh
      $ go doc json.decode
      func (dec *Decoder) Decode(v interface{}) error

          Decode reads the next JSON-encoded value from its input and stores
          it in the value pointed to by v.
    < src..

#     The second tool, confusingly named @$(godoc), serves cross-linked HTML pages
#     that provide the same information as @$(go doc) and much more. The @$(godoc)
#     server at @l(https://golang.org/pkg) covers the standard library. Figure
#     10.1 shows the documentation for the @c(time) package, and in @l(#Section 11.6)
#     we’ll see @$(godoc)’s interactive display of example programs. The @$(godoc)
#     server at @l(https://godoc.org) has a searchable index of thousands of
#     open-source packages.
    La segunda herramienta, confusamente nombrada @$(godoc), sirve paginas HTML
    a entrecruzadas que proporcionan la misma informacion que @$(go doc) y mucho
    mas. El servidor @$(godoc) en @l(https://golang.org/pkg) cubre la biblioteca
    estandar. La Figura 10.1 muestra la documentacion del paquete @c(time), y en
    la @l(#Seccion 11.6) veremos la pantalla interactiva de @$(godoc) de
    programas de ejemplo. El servidor @$(godoc) en @l(https://godoc.org) tiene
    un indice de busqueda de miles de paquetes de codigo abierto.

#     You can also run an instance of @$(godoc) in your workspace if you want to
#     browse your own packages. Visit @l(http://localhost:8000/pkg) in your
#     browser while running this command:
    Tambien puede ejecutar una instancia de @$(godoc) en su espacio de trabajo
    si desea navegar por sus propios paquetes. Visite
    @l(http://localhost:8000/pkg) en su navegador mientras se ejecuta este
    comando:

#     ..src > sh
#       $ godoc -http :8000
#     < src..
    ..src > sh
      $ godoc -http :8000
    < src..

#     Its @c(-analysis=type) and @c(-analysis=pointer) flags augment the
#     documentation and the source code with the results of advanced static
#     analysis.
    Sus banderas @c(-analysis=type) y @c(-analysis=pointer) aumentan la
    documentacion y el codigo fuente con resultados del analisis estatico
    avanzado.

# *** Section 10.7.5 <> Internal Packages
*** Seccion 10.7.5 <> Paquetes Internos

#     The package is the most important mechanism for encapsulation in Go
#     programs. Unexported identifiers are visible only within the same package,
#     and exported identifiers are visible to the world.
    El paquete es el mecanismo mas importante para la encapsulacion en programas
    Go. Los identificadores sin exportacion son visibles solo dentro del mismo
    paquete, y los identificadores exportados son visibles para el mundo.

#     Sometimes, though, a middle ground would be helpful, a way to define
#     identifiers that are visible to a small set of trusted packages, but not to
#     everyone. For example, when we’re breaking up a large package into more
#     manageable parts, we may not want to reveal the interfaces between those
#     parts to other packages. Or we may want to share utility functions across
#     several packages of a project without exposing them more widely. Or perhaps
#     we just want to experiment with a new package without prematurely committing
#     to its API, by putting it @"(on probation) with a limited set of clients.
    A veces, sin embargo, camino medio seria util, una forma de definir
    identificadores que son visibles para un pequeño conjunto de paquetes de
    confianza, pero no para todos. Por ejemplo, cuando estamos dividiendo un
    paquete grande en partes mas manejables, es posible que no deseemos revelar
    las interfaces entre esas partes a otros paquetes. O quizas queramos
    compartir funciones de utilidad entre varios paquetes de un proyecto sin
    exponerlos mas ampliamente. O tal vez solo queremos experimentar con un
    nuevo paquete sin comprometerse prematuramente con su API, poniendolo @"(a
    prueba) con un conjunto limitado de clientes.

#     ..figure > Figure 10.1. The @c(time) package in @$(godoc).
    ..figure > Figura 10.1. El paquete @c(time) en @$(godoc).

#       ..img  > img/Figure-10.1.jpg
      ..img  > img/Figure-10.1.jpg

#     To address these needs, the @$(go build) tool treats a package specially if
#     its import path contains a path segment named @c(internal). Such packages
#     are called @e(internal packages). An internal package may be imported only
#     by another package that is inside the tree rooted at the parent of the
#     @c(internal) directory. For example, given the packages below,
#     @c(net/http/internal/chunked) can be imported from @c(net/http/httputil) or
#     @c(net/http), but not from @c(net/url). However, @c(net/url) may import
#     @c(net/http/httputil).
    Para hacer frente a estas necesidades, la herramienta @$(go build) maneja de
    un paquete de forma especial si su ruta de importacion contiene un segmento
    de ruta denominado @c(interno). Dichos paquetes se denominan @e(paquetes
    internos). Un paquete interno puede ser importadas por otro paquete que esta
    dentro del arbol raiz en el paquete del directorio @c(internal). Por
    ejemplo, los paquetes a continuacion, @c(net/http/internal/chunked) pueden
    ser importados de @c(net/http/httputil) o @c(net/http), pero no de
    @c(net/url) . Sin embargo, @c(net/url) puede importar @c(net/http/httputil).

#     ..pre >
#       net/http
#       net/http/internal/chunked
#       net/http/httputil
#       net/url
    ..pre >
      net/http
      net/http/internal/chunked
      net/http/httputil
      net/url

# *** Section 10.7.6 <> Querying Packages
*** Seccion 10.7.6 <> Consultando Paquetes

#     The @$(go list) tool reports information about available packages. In its
#     simplest form, @$(go list) tests whether a package is present in the
#     workspace and prints its import path if so:
    La herramienta @$(go list) reporta informacion sobre los paquetes
    disponibles. En su forma mas simple, @$(go list) comprueba si un paquete
    esta presente en el espacio de trabajo e imprime su ruta de importacion si
    es asi:

#     ..src > sh
#       $ go list github.com/go-sql-driver/mysql
#       github.com/go-sql-driver/mysql
#     < src..
    ..src > sh
      $ go list github.com/go-sql-driver/mysql
      github.com/go-sql-driver/mysql
    < src..

#     An argument to @$(go list) may contain the @"(@c(...)) wildcard, which
#     matches any substring of a package’s import path. We can use it to enumerate
#     all the packages within a Go workspace:
    Un argumento para @$(go list) puede contener el comodin @"(@c(...)), que
    coincide con cualquier subcadena de ruta de importacion de un paquete.
    Podemos usarlo para enumerar todos los paquetes dentro de un espacio de
    trabajo Go:

#     ..src > sh
#       $ go list ...
#       archive/tar
#       archive/zip
#       bufio
#       bytes
#       cmd/addr2line
#       cmd/api
#       ...many more...
#     < src..
    ..src > sh
      $ go list ...
      archive/tar
      archive/zip
      bufio
      bytes
      cmd/addr2line
      cmd/api
      ...many more...
    < src..

#     or within a specific subtree:
    O dentro de un subarbol especifico:

#     ..src > sh
#       $ go list gopl.io/ch3/...
#       gopl.io/ch3/basename1
#       gopl.io/ch3/basename2
#       gopl.io/ch3/comma
#       gopl.io/ch3/mandelbrot
#       gopl.io/ch3/netflag
#       gopl.io/ch3/printints
#       gopl.io/ch3/surface
#     < src..
    ..src > sh
      $ go list gopl.io/ch3/...
      gopl.io/ch3/basename1
      gopl.io/ch3/basename2
      gopl.io/ch3/comma
      gopl.io/ch3/mandelbrot
      gopl.io/ch3/netflag
      gopl.io/ch3/printints
      gopl.io/ch3/surface
    < src..

#     or related to a particular topic:
    O relacionados con un tema particular:

#     ..src > sh
#       $ go list ...xml...
#       encoding/xml
#       gopl.io/ch7/xmlselect
#     < src..
    ..src > sh
      $ go list ...xml...
      encoding/xml
      gopl.io/ch7/xmlselect
    < src..

#     The @$(go list) command obtains the complete metadata for each package, not
#     just the import path, and makes this information available to users or other
#     tools in a variety of formats. The @c(-json) flag causes @$(go list) to
#     print the entire record of each package in JSON format:
    El comando @$(go list) obtiene los metadatos completos de cada paquete, no
    solo la ruta de importacion, y pone esta informacion a disposicion de los
    usuarios u otras herramientas en una variedad de formatos. La bandera
    @c(-json) proboca que @$(go list) imprima el registro completo de cada
    paquete en formato JSON:

#     ..src > sh
#       $ go list -json hash
#       {
#           "Dir": "/home/gopher/go/src/hash",
#           "ImportPath": "hash",
#           "Name": "hash",
#           "Doc": "Package hash provides interfaces for hash functions.",
#           "Target": "/home/gopher/go/pkg/darwin_amd64/hash.a",
#           "Goroot": true,
#           "Standard": true,
#           "Root": "/home/gopher/go",
#           "GoFiles": [
#                  "hash.go"
#           ],
#           "Imports": [
#               "io"
#           ],
#           "Deps": [
#               "errors",
#               "io",
#               "runtime",
#               "sync",
#               "sync/atomic",
#               "unsafe"
#           ]
#       }
#     < src..
    ..src > sh
      $ go list -json hash
      {
          "Dir": "/home/gopher/go/src/hash",
          "ImportPath": "hash",
          "Name": "hash",
          "Doc": "Package hash provides interfaces for hash functions.",
          "Target": "/home/gopher/go/pkg/darwin_amd64/hash.a",
          "Goroot": true,
          "Standard": true,
          "Root": "/home/gopher/go",
          "GoFiles": [
                 "hash.go"
          ],
          "Imports": [
              "io"
          ],
          "Deps": [
              "errors",
              "io",
              "runtime",
              "sync",
              "sync/atomic",
              "unsafe"
          ]
      }
    < src..

#     The @c(-f) flag lets users customize the output format using the template
#     language of package @c(text/template) (@l(#Section 4.6<>§4.6)). This command
#     prints the transitive dependencies of the @c(strconv) package, separated by
#     spaces:
    La bandera @c(-f) permite a los usuarios personalizar el formato de salida
    utilizando el lenguaje de la plantilla del paquete de @c(text/template)
    (@l(#Seccion 4.6<>§4.6)). Este comando imprime las dependencias transitivas
    del paquete @c(strconv), separados por espacios:

#     ..src > sh
#       $ go list -f '{{join .Deps " "}}' strconv
#       errors math runtime unicode/utf8 unsafe
#     < src..
    ..src > sh
      $ go list -f '{{join .Deps " "}}' strconv
      errors math runtime unicode/utf8 unsafe
    < src..

#     and this command prints the direct imports of each package in the
#     @c(compress) subtree of the standard library:
    y el comando muestra las importaciones directas de cada paquete en el
    subarbol @c(compress) de la biblioteca estandar:

#     ..src > sh
#       $ go list -f '{{.ImportPath}} -> {{join .Imports " "}}' compress/...
#       compress/bzip2 -> bufio io sort
#       compress/flate -> bufio fmt io math sort strconv
#       compress/gzip -> bufio compress/flate errors fmt hash hash/crc32 io time
#       compress/lzw -> bufio errors fmt io
#       compress/zlib -> bufio compress/flate errors fmt hash hash/adler32 io
#     < src..
    ..src > sh
      $ go list -f '{{.ImportPath}} -> {{join .Imports " "}}' compress/...
      compress/bzip2 -> bufio io sort
      compress/flate -> bufio fmt io math sort strconv
      compress/gzip -> bufio compress/flate errors fmt hash hash/crc32 io time
      compress/lzw -> bufio errors fmt io
      compress/zlib -> bufio compress/flate errors fmt hash hash/adler32 io
    < src..

#     The @$(go list) command is useful for both one-off interactive queries and
#     for build and test automation scripts. We’ll use it again in @l(#Section
#     11.2.4). For more information, including the set of available fields and
#     their meaning, see the output of @$(go help list).
    El comando @$(go list) es util tanto para consultas interactivas puntuales y
    para scripts de construccion y automatizacion de pruebas. Lo volveremos a
    utilizar en la @l(#Seccion 11.2.4). Para obtener mas informacion, incluyendo
    el conjunto de campos disponibles y su significado, ver la salida de la
    @$(go help list).

#     In this chapter, we’ve explained all the important subcommands of the @$(go)
#     tool—except one. In the next chapter, we’ll see how the @$(go test) command
#     is used for testing Go programs.
    En este capitulo, hemos explicado todos los subcomandos importantes de la
    herramientas @$(go) excepto uno. En el siguiente capitulo, veremos como se
    utiliza el comando @$(go test) para probar programas Go.

#     @b(Exercise 10.4): Construct a tool that reports the set of all packages in
#     the workspace that transitively depend on the packages specified by the
#     arguments. Hint: you will need to run @$(go list) twice, once for the
#     initial packages and once for all packages. You may want to parse its JSON
#     output using the @$(encoding/json) package (@l(#Section 4.5<>§4.5)).
    @b(Ejercicio 10.4): Construir una herramienta que reporte el conjunto de
    todos los paquetes en el espacio de trabajo que dependen de forma transitiva
    de los paquetes especificados por los argumentos. Sugerencia: tendra que ejecutar
    @$(go list) dos veces, una para los paquetes iniciales y una vez para todos los
    paquetes. Es posible que desee analizar su salida JSON utilizando el paquete
    @c(encoding/json) (@l(#Seccion 4.5<>§4.5)).

# * Chapter 11 <> Testing
* Capitulo 11 <> Pruebas

#   Maurice Wilkes, the developer of EDSAC, the first stored-program computer, had
#   a startling insight while climbing the stairs of his laboratory in 1949. In
#   @e(Memoirs of a Computer Pioneer), he recalled, @"(The realization came over me
#   with full force that a good part of the remainder of my life was going to be
#   spent in finding errors in my own programs.) Surely every programmer of a
#   stored-program computer since then can sympathize with Wilkes, though perhaps
#   not without some bemusement at his naïvete about the difficulties of software
#   construction.
  Maurice Wilkes, el desarrollador de EDSAC, el primer computador con programa
  almacenado, tevo una vision sorprendente mientras subia las escaleras de su
  laboratorio en 1949. En @e(Memoirs of a Computer Pioneer), recordo, @"(La
  realizacion se me vino con toda la fuerza que una buena Parte del resto de mi
  vida iba a ser gastada en encontrar errores en mis propios programas.)
  Seguramente cada programador de una computadora con programas almacenados
  desde entonces puede simpatizar con Wilkes, aunque tal vez no sin algo de
  desconcierto en su ingenuidad sobre las dificultades de la construccion de
  software.

#   Programs today are far larger and more complex than in Wilkes’s time, of
#   course, and a great deal of effort has been spent on techniques to make this
#   complexity manageable. Two techniques in particular stand out for their
#   effectiveness. The first is routine peer review of programs before they are
#   deployed. The second, the subject of this chapter, is testing.
  Los programas de hoy son mucho mas grandes y complejos que en el tiempo de
  Wilkes, por supuesto, y se ha dedicado mucho esfuerzo a tecnicas para hacer
  que esta complejidad sea manejable. Dos tecnicas en particular destacan por su
  eficacia. La primera es la revision por pares de los programas antes de que se
  desplieguen. El segundo, el tema de este capitulo, son las pruebas.

#   Testing, by which we implicitly mean @e(automated) testing, is the practice of
#   writing small programs that check that the code under test (the @e(production)
#   code) behaves as expected for certain inputs, which are usually either
#   carefully chosen to exercise certain features or randomized to ensure broad
#   coverage.
  Las pruebas, que implican implicitamente pruebas @e(automatizadas), es la
  practica de escribir pequeños programas que comprobar que el codigo bajo
  prueba (el codigo de @e(produccion)) se comporta como se esperaba para ciertas
  entradas, que suelen ser cuidadosamente elegidas para ejercer ciertas
  funciones o al azar para asegurar amplia cobertura.

#   The field of software testing is enormous. The task of testing occupies all
#   programmers some of the time and some programmers all of the time. The
#   literature on testing includes thousands of printed books and millions of
#   words of blog posts. In every mainstream programming language, there are
#   dozens of software packages intended for test construction, some with a great
#   deal of theory, and the field seems to attract more than a few prophets with
#   cult-like followings. It is almost enough to convince programmers that to
#   write effective tests they must acquire a whole new set of skills.
  El campo de las pruebas de software es enorme. La tarea del testeo ocupa a
  todos los programadores en parte del tiempo y algunos programadores todo el
  tiempo. La literatura sobre las pruebas incluye miles de libros impresos y
  millones de palabras publicadas en el blogs. En todos los lenguajes de
  programacion, hay docenas de paquetes de software destinados a la construccion
  de pruebas, algunos con una gran cantidad de teoria, y el campo parece atraer
  a mas de unos pocos profetas con seguimientos de culto. Es casi suficiente
  para convencer a los programadores de que para escribir pruebas efectivas
  deben adquirir un nuevo conjunto de habilidades.

#   Go’s approach to testing can seem rather low-tech in comparison. It relies on
#   one command, @$(go test), and a set of conventions for writing test functions
#   that @$(go test) can run. The comparatively lightweight mechanism is effective
#   for pure testing, and it extends naturally to benchmarks and systematic
#   examples for documentation.
  La aproximacion de Go a las pruebas puede parecer de baja tecnologia en
  comparacion. Se basa en un solo comando, @$(go test), y un conjunto de
  convenciones para escribir funciones de prueba que @$(go test) puede
  ejecutar. El mecanismo relativamente ligero es efectivo para pruebas puras, y
  se extiende naturalmente a puntos de referencia y ejemplos sistematicos para
  la documentacion.

#   In practice, writing test code is not much different from writing the original
#   program itself.  We write short functions that focus on one part of the
#   task. We have to be careful of boundary conditions, think about data
#   structures, and reason about what results a computation should produce from
#   suitable inputs. But this is the same process as writing ordinary Go code; it
#   needn’t require new notations, conventions, and tools.
  En la practica, escribir codigo de prueba no es muy diferente de escribir el
  programa original en si. Escribimos funciones cortas que se centran en una
  parte de la tarea. Debemos tener cuidado con las condiciones de los limites,
  pensar en las estructuras de datos y razonar sobre los resultados que un
  calculo debe producir a partir de entradas adecuadas. Pero este es el mismo
  proceso que escribir codigo Go ordinario; No requiere nuevas anotaciones,
  convenciones o herramientas.

# ** Section 11.1 <> The @$(go test) Tool
** Seccion 11.1 <> La Herramienta @$(go test)

#    The @$(go test) subcommand is a test driver for Go packages that are
#    organized according to certain conventions. In a package directory, files
#    whose names end with @f(_test.go) are not part of the package ordinarily
#    built by @$(go build) but are a part of it when built by @$(go test).
   El subcomando @$(go test) es un controlador de pruebas para paquetes Go que
   se organizan de acuerdo con ciertas convenciones. En un directorio de
   paquetes, los archivos cuyos nombres terminan con @f(_test.go) no son parte
   del paquete normalmente construido por @$(go build) sino que son una parte de
   el cuando se construyen mediante @$(go test).

#    Within @f(*_test.go) files, three kinds of functions are treated specially :
#    tests, benchmarks, and examples. A @e(test function), which is a function
#    whose name begins with @c(Test), exercises some program logic for correct
#    behavior; @$(go test) calls the test function and reports the result, which
#    is either @c(PASS) or @c(FAIL). A @e(benchmark function) has a name beginning
#    with @c(Benchmark) and measures the performance of some operation; @$(go
#    test) reports the mean execution time of the operation. And an @e(example
#    function), whose name starts with @c(Example), provides machine-checked
#    documentation. We will cover tests in detail in @l(#Section 11.2), benchmarks
#    in @l(#Section 11.4), and examples in @l(#Section 11.6).
   Dentro de archivos @f(*_test.go), tres tipos de funciones se tratan de forma
   especial: pruebas, benchmarks, y ejemplos. Una @e(funcion de prueba), es una
   funcion cuyo nombre comienza con @c(Test), ejerce cierta logica del programa
   para el comportamiento correcto; @$(go test) llama a la funcion de prueba e
   informa del resultado, que es @c(PASS) o @c(FAIL). Una funcion de benchmark
   tiene un nombre que comienza con @c(Benchmark) y mide el rendimiento de una
   operacion; @$(go test) informes el tiempo de ejecucion medio de la
   operacion. Y una funcion de ejemplo, cuyo nombre empieza por @c(Example),
   proporciona documentacion revisada por la maquina. Vamos a cubrir las pruebas
   en detalle en la @l(#Seccion 11.2), los benchmarks en la @l(#Seccion 11.4), y
   los ejemplos en la @l(#Seccion 11.6).

#    The @$(go test) tool scans the @f(*_test.go) files for these special
#    functions, generates a temporary @c(main) package that calls them all in the
#    proper way, builds and runs it, reports the results, and then cleans up.
   La heramienta @$(go test) examina los archivos @f(*_test.go) para estas
   funciones especiales, genera un paquete @c(main) temporal que llama a todas
   de la manera correcta, compila y ejecuta, informa de los resultados, y luego
   se limpia.

# ** Section 11.2 <> @c(Test) Functions
** Seccion 11.2 <> Funciones @c(Test)

#    Each test file must import the @c(testing) package. Test functions have the
#    following signature:
   Cada archivo de prueba debe importar el paquete @c(testing). Las funciones de
   prueba tienen la siguiente firma:

#    ..src > go
#      func TestName(t *testing.T) {
#        // ...
#      }
#    < src..
   ..src > go
     func TestNormbre(t *testing.T) {
       // ...
     }
   < src..

#    Test function names must begin with @c(Test); the optional suffix @e(Name)
#    must begin with a capital letter:
   Los nombres de las funciones de prueba deben comenzar con @c(Test); el sufijo
   opcional @e(Nombre) debe comenzar con una letra mayuscula:

#    ..src > go
#      func TestSin(t *testing.T) { /* ... */ }
#      func TestCos(t *testing.T) { /* ... */ }
#      func TestLog(t *testing.T) { /* ... */ }
#    < src..
   ..src > go
     func TestSin(t *testing.T) { /* ... */ }
     func TestCos(t *testing.T) { /* ... */ }
     func TestLog(t *testing.T) { /* ... */ }
   < src..

#    The @c(t) parameter provides methods for reporting test failures and logging
#    additional information. Let’s define an example package
#    @c(gopl.io/ch11/word1), containing a single function @c(IsPalindrome) that
#    reports whether a string reads the same forward and backward. (This
#    implementation tests every byte twice if the string is a palindrome; we’ll
#    come back to that shortly.)
   El parametro @c(t) proporciona metodos para informar fallos de las pruebas y
   registrar informacion adicional. Vamos a definir un paquete de ejemplo
   @c(gopl.io/ch11/word1), que contiene una sola funcion @c(IsPalindrome) que
   informa de si una cadena se lee igual hacia adelante y hacia atras. (Esta
   implementacion prueba cada byte dos veces si la cadena es un palindromo,
   volveremos a esto en breve).

#    ..figure > @l(gopl.io/ch11/word1/word.go<>gopl.io/ch11/word1)
   ..figure > @l(gopl.io/ch11/word1/word.go<>gopl.io/ch11/word1)

#      ..src > go
#        // Package word provides utilities for word games.
#        package word
#
#        // IsPalindrome reports whether s reads the same forward and backward.
#        // (Our first attempt.)
#        func IsPalindrome(s string) bool {
#          for i := range s {
#            if s[i] != s[len(s)-1-i] {
#              return false
#            }
#          }
#          return true
#        }
#      < src..
     ..src > go
       // El paquete word proporciona utilidades para juegos de palabras.
       package word

       // IsPalindrome informa si s se lee igual hacia adelante y hacia atras.
       // (Nuestro primer intento.)
       func IsPalindrome(s string) bool {
         for i := range s {
           if s[i] != s[len(s)-1-i] {
             return false
           }
         }
         return true
       }
     < src..


#    In the same directory, the file @f(word_test.go) contains two test functions
#    named @c(TestPalindrome) and @c(TestNonPalindrome). Each checks that
#    @c(IsPalindrome) gives the right answer for a single input and reports
#    failures using @c(t.Error):
   En el mismo directorio, el archive @f(word_test.go) contiene dos funciones de
   prueba con nombre @c(TestPalindrome) y @c(TestNonPalindrome). Cada uno
   comprueba que @c(IsPalindrome) da la respuesta correcta para una entrada
   unica e informa fallos utilizando @c(t.Error):

#    ..src > go
#      package word
#
#      import "testing"
#
#      func TestPalindrome(t *testing.T) {
#        if !IsPalindrome("detartrated") {
#          t.Error(`IsPalindrome("detartrated") = false`)
#        }
#        if !IsPalindrome("kayak") {
#          t.Error(`IsPalindrome("kayak") = false`)
#        }
#      }
#
#      func TestNonPalindrome(t *testing.T) {
#        if IsPalindrome("palindrome") {
#          t.Error(`IsPalindrome("palindrome") = true`)
#        }
#      }
#    < src..
   ..src > go
     package word

     import "testing"

     func TestPalindrome(t *testing.T) {
       if !IsPalindrome("detartrated") {
         t.Error(`IsPalindrome("detartrated") = false`)
       }
       if !IsPalindrome("kayak") {
         t.Error(`IsPalindrome("kayak") = false`)
       }
     }

     func TestNonPalindrome(t *testing.T) {
       if IsPalindrome("palindrome") {
         t.Error(`IsPalindrome("palindrome") = true`)
       }
     }
   < src..

#    A @$(go test) (or @$(go build)) command with no package arguments operates on
#    the package in the current directory. We can build and run the tests with the
#    following command.
   Una comando @$(go test) (o @$(go build)) sin argumentos de paquete opera
   sobre el paquete en el directorio actual. Podemos construir y ejecutar las
   pruebas con el siguiente comando.

#    ..src > sh
#      $ cd $GOPATH/src/gopl.io/ch11/word1
#      $ go test
#      ok   gopl.io/ch11/word1 0.008s
#    < src..
   ..src > sh
     $ cd $GOPATH/src/gopl.io/ch11/word1
     $ go test
     ok   gopl.io/ch11/word1 0.008s
   < src..

#    Satisfied, we ship the program, but no sooner have the launch party guests
#    departed than the bug reports start to arrive. A French user named Noelle Eve
#    Elleon complains that @c(IsPalindrome) doesn’t recognize @"(été.) Another,
#    from Central America, is disappointed that it rejects @"(A man, a plan, a
#    canal: Panama.) These specific and small bug reports naturally lend
#    themselves to new test cases.
   Satisfecho, enviamos el programa, pero no antes de que los invitados de la
   fiesta envien los informes de error iniciales. Un usuario frances llamado
   Noelle Eva Elleon se queja de que IsPalindrome no reconoce @"(été). Otro, de
   Centroamerica, se siente decepcionado al rechazar @"(A man, a plan, a canal:
   Panama). Estos informes de errores especificos y pequeños naturalmente se
   prestan a nuevos casos de prueba.

#    ..src > go
#      func TestFrenchPalindrome(t *testing.T) {
#        if !IsPalindrome("été") {
#          t.Error(`IsPalindrome("été") = false`)
#        }
#      }
#      func TestCanalPalindrome(t *testing.T) {
#        input := "A man, a plan, a canal: Panama"
#        if !IsPalindrome(input) {
#          t.Errorf(`IsPalindrome(%q) = false`, input)
#        }
#      }
#    < src..
   ..src > go
     func TestFrenchPalindrome(t *testing.T) {
       if !IsPalindrome("été") {
         t.Error(`IsPalindrome("été") = false`)
       }
     }
     func TestCanalPalindrome(t *testing.T) {
       input := "A man, a plan, a canal: Panama"
       if !IsPalindrome(input) {
         t.Errorf(`IsPalindrome(%q) = false`, input)
       }
     }
   < src..

#    To avoid writing the long input string twice, we use @c(Errorf), which
#    provides formatting like @c(Printf).
   Para evitar la langa cadena de entrada dos veces, utilizamos @c(Errorf), que
   proporciona formato, como @c(Printf).

#    When the two new tests have been added, the @$(go test) command fails with
#    informative error messages.
   Cuando se han añadido las dos nuevas pruebas, el comando @$(go test) falla
   con mensajes informativos de error.

#    ..src > sh
#      $ go test
#      --- FAIL: TestFrenchPalindrome (0.00s)
#          word_test.go:28: IsPalindrome("été") = false
#      --- FAIL: TestCanalPalindrome (0.00s)
#          word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
#      FAIL
#      FAIL    gopl.io/ch11/word1 0.014s
#    < src..
   ..src > sh
     $ go test
     --- FAIL: TestFrenchPalindrome (0.00s)
         word_test.go:28: IsPalindrome("été") = false
     --- FAIL: TestCanalPalindrome (0.00s)
         word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
     FAIL
     FAIL    gopl.io/ch11/word1 0.014s
   < src..

#    It’s good practice to write the test first and observe that it triggers the
#    same failure described by the user’s bug report. Only then can we be
#    confident that whatever fix we come up with addresses the right problem.
   Es recomendable escribir la prueba primero y observar que desencadena el
   mismo fallo descrito por el informe de error del usuario. Solo entonces
   podremos estar seguros de que cualquier solucion que hagamos concierne al
   problema correcto.

#    As a bonus, running @$(go test) is usually quicker than manually going
#    through the steps described in the bug report, allowing us to iterate more
#    rapidly. If the test suite contains many slow tests, we may make even faster
#    progress if we’re selective about which ones we run.
   Como beneficio adicional, ejecutar @$(go test) generalmente es mas rapido que
   manualmente por los pasos descritos en el informe de errores, lo que nos
   permite iterar mas rapidamente. Si la suite de pruebas contiene muchas
   pruebas lentas, podemos hacer un progreso aun mas rapido si somos selectivos
   sobre cuales corremos.

#    The @c(-v) flag prints the name and execution time of each test in the
#    package:
   La bandera @c(-v) imprime el nombre y el tiempo de ejecucion de cada prueba
   en el paquete:

#    ..src > sh
#      $ go test -v
#      === RUN TestPalindrome
#      --- PASS: TestPalindrome (0.00s)
#      === RUN TestNonPalindrome
#      --- PASS: TestNonPalindrome (0.00s)
#      === RUN TestFrenchPalindrome
#      --- FAIL: TestFrenchPalindrome (0.00s)
#      word_test.go:28: IsPalindrome("ete") = false
#      === RUN TestCanalPalindrome
#      --- FAIL: TestCanalPalindrome (0.00s)
#      word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
#      FAIL
#      exit status 1
#      FAIL    gopl.io/ch11/word1 0.017s
#    < src..
   ..src > sh
     $ go test -v
     === RUN TestPalindrome
     --- PASS: TestPalindrome (0.00s)
     === RUN TestNonPalindrome
     --- PASS: TestNonPalindrome (0.00s)
     === RUN TestFrenchPalindrome
     --- FAIL: TestFrenchPalindrome (0.00s)
     word_test.go:28: IsPalindrome("ete") = false
     === RUN TestCanalPalindrome
     --- FAIL: TestCanalPalindrome (0.00s)
     word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
     FAIL
     exit status 1
     FAIL    gopl.io/ch11/word1 0.017s
   < src..

#    and the @c(-run) flag, whose argument is a regular expression, causes @$(go
#    test) to run only those tests whose function name matches the pattern:
   y la bandera @c(-run), cuyo argumento es una expresion regular, hace que
   @$(go test) ejecute solo aquellas pruebas cuyo nombre de funcion coincide con
   el patron:

#    ..src > sh
#      $ go test -v -run="French|Canal"
#      === RUN TestFrenchPalindrome
#      --- FAIL: TestFrenchPalindrome (0.00s)
#      word_test.go:28: IsPalindrome("ete") = false
#      === RUN TestCanalPalindrome
#      --- FAIL: TestCanalPalindrome (0.00s)
#      word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
#      FAIL
#      exit status 1
#      FAIL    gopl.io/ch11/word1 0.014s
#    < src..
   ..src > sh
     $ go test -v -run="French|Canal"
     === RUN TestFrenchPalindrome
     --- FAIL: TestFrenchPalindrome (0.00s)
     word_test.go:28: IsPalindrome("ete") = false
     === RUN TestCanalPalindrome
     --- FAIL: TestCanalPalindrome (0.00s)
     word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
     FAIL
     exit status 1
     FAIL    gopl.io/ch11/word1 0.014s
   < src..

#    Of course, once we’ve gotten the selected tests to pass, we should invoke
#    @$(go test) with no flags to run the entire test suite one last time before
#    we commit the change.
   Por supuesto, una vez que hemos conseguido que las pruebas seleccionadas
   pasen, debemos invocar a @$(go test) sin banderas para ejecutar el conjunto
   de pruebas entero una ultima vez antes de que confirme el cambio.

#    Now our task is to fix the bugs. A quick investigation reveals the cause of
#    the first bug to be @c(IsPalindrome)’s use of byte sequences, not rune
#    sequences, so that non-ASCII characters such as the @c(é) in @c("été")
#    confuse it. The second bug arises from not ignoring spaces, punctuation, and
#    letter case.
   Ahora nuestra tarea es arreglar los errores. Una rapida investigacion revela
   la causa del primer fallo en @c(IsPalindrome) esta en utilizar secuencias de
   bytes, no secuencias de runas, por lo que los caracteres no ASCII, como la
   @c(é) en @c("été") lo confunden. El segundo error surge de no ignorar entre
   mayusculas y minusculas, los espacios y signos de puntuacion.

#    Chastened, we rewrite the function more carefully:
   reescribimos la funcion con mas cuidado:

#    ..figure > @l(gopl.io/ch11/word2/word.go<>gopl.io/ch11/word2)
   ..figure > @l(gopl.io/ch11/word2/word.go<>gopl.io/ch11/word2)

#      ..src > go
#        // Package word provides utilities for word games.
#        package word
#
#        import "unicode"
#
#        // IsPalindrome reports whether s reads the same forward and backward.
#        // Letter case is ignored, as are non-letters.
#        func IsPalindrome(s string) bool {
#          var letters []rune
#          for _, r := range s {
#            if unicode.IsLetter(r) {
#              letters = append(letters, unicode.ToLower(r))
#            }
#          }
#          for i := range letters {
#            if letters[i] != letters[len(letters)-1-i] {
#              return false
#            }
#          }
#          return true
#        }
#      < src..
     ..src > go
       // El paquete word proporciona utilidades para juegos de palabras.
       package word

       import "unicode"

       // IsPalindrome informa si s se lee igual hacia adelante y hacia atras.
       // Se ignora entre mayusculas y minusculas, al igual que las no-letras.
       func IsPalindrome(s string) bool {
         var letters []rune
         for _, r := range s {
           if unicode.IsLetter(r) {
             letters = append(letters, unicode.ToLower(r))
           }
         }
         for i := range letters {
           if letters[i] != letters[len(letters)-1-i] {
             return false
           }
         }
         return true
       }
     < src..


#    We also write a more comprehensive set of test cases that combines all the
#    previous ones and a number of new ones into a table.
   Tambien escribimos un conjunto mas completo de casos de prueba que combina
   todas las anteriores y una nueva serie en una tabla.

#    ..src > go
#      func TestIsPalindrome(t *testing.T) {
#        var tests = []struct {
#          input string
#          want  bool
#        }{
#          {"", true},
#          {"a", true},
#          {"aa", true},
#          {"ab", false},
#          {"kayak", true},
#          {"detartrated", true},
#          {"A man, a plan, a canal: Panama", true},
#          {"Evil I did dwell; lewd did I live.", true},
#          {"Able was I ere I saw Elba", true},
#          {"ete", true},
#          {"Et se resservir, ivresse reste.", true},
#          {"palindrome", false}, // non-palindrome
#          {"desserts", false},   // semi-palindrome
#        }
#        for _, test := range tests {
#          if got := IsPalindrome(test.input); got != test.want {
#            t.Errorf("IsPalindrome(%q) = %v", test.input, got)
#          }
#        }
#      }
#    < src..
   ..src > go
     func TestIsPalindrome(t *testing.T) {
       var tests = []struct {
         input string
         want  bool
       }{
         {"", true},
         {"a", true},
         {"aa", true},
         {"ab", false},
         {"kayak", true},
         {"detartrated", true},
         {"A man, a plan, a canal: Panama", true},
         {"Evil I did dwell; lewd did I live.", true},
         {"Able was I ere I saw Elba", true},
         {"ete", true},
         {"Et se resservir, ivresse reste.", true},
         {"palindrome", false}, // no-palindromo
         {"desserts", false},   // semi-palindromo
       }
       for _, test := range tests {
         if got := IsPalindrome(test.input); got != test.want {
           t.Errorf("IsPalindrome(%q) = %v", test.input, got)
         }
       }
     }
   < src..

#    Our new tests pass:
   Nuestras nuevas pruebas pasan:

#    ..src > sh
#      $ go test gopl.io/ch11/word2
#      ok      gopl.io/ch11/word2        0.015s
#    < src..
   ..src > sh
     $ go test gopl.io/ch11/word2
     ok      gopl.io/ch11/word2        0.015s
   < src..

#    This style of @e(table-driven) testing is very common in Go. It is
#    straightforward to add new table entries as needed, and since the assertion
#    logic is not duplicated, we can invest more effort in producing a good error
#    message.
   Este estilo de la prueba @e(basado en tablas) es muy comun en Go. Es facil
   agregar nuevas entradas de tabla segun sea necesario, y como la logica de
   asercion no se duplica, podemos invertir mas esfuerzo en producir un buen
   mensaje de error.

#    The output of a failing test does @e(not) include the entire stack trace at
#    the moment of the call to @c(t.Errorf). Nor does @c(t.Errorf) cause a panic
#    or stop the execution of the test, unlike assertion failures in many test
#    frameworks for other languages. Tests are independent of each other. If an
#    early entry in the table causes the test to fail, later table entries will
#    still be checked, and thus we may learn about multiple failures during a
#    single run.
   La salida de una prueba erronea @e(no) incluye la traza de la pila entera en
   el momento de la llamada a @c(t.Errorf). @c(t.Errorf) tampoco provoca un
   panico o detiene la ejecucion de la prueba, a diferencia de muchos errores de
   asercion en frameworks de prueba para otros lenguajes. Las pruebas son
   independientes entre si. Si una entrada temprana en la tabla hace que la
   prueba falle, las entradas de tabla posteriores se aun se comprobaran, y asi
   podemos aprender sobre multiples fallas durante una sola ejecucion.

#    When we really must stop a test function, perhaps because some initialization
#    code failed or to prevent a failure already reported from causing a confusing
#    cascade of others, we use @c(t.Fatal) or @c(t.Fatalf). These must be called
#    from the same goroutine as the @c(Test) function, not from another one
#    created during the test.
   Cuando realmente debemos detener una funcion de prueba, tal vez porque a
   algun codigo de inicializacion fallo o para prevenir un fallo ya reportado
   que proboque una cascada confusa de otros, utilizamos @c(t.Fatal) o
   @c(t.Fatalf). Estos deben ser llamados desde la misma gorutina como la
   funcion @c(Test), no de la otra creada durante la prueba.

#    Test failure messages are usually of the form @c["f(x) = y, want z"], where
#    @c[f(x)] explains the attempted operation and its input, @c(y) is the actual
#    result, and @c(z) the expected result. Where convenient, as in our palindrome
#    example, actual Go syntax is used for the @c[f(x)] part. Displaying @c(x) is
#    particularly important in a table-driven test, since a given assertion is
#    executed many times with different values. Avoid boilerplate and redundant
#    information. When testing a boolean function such as @c(IsPalindrome), omit
#    the want @c(z) part since it adds no information. If @c(x), @c(y), or @c(z)
#    is lengthy, print a concise summar y of the relevant parts instead. The
#    author of a test should strive to help the programmer who must diagnose a
#    test failure.
   Los mensajes de fallo generalmente de la forma @c["f(x) = y, want z"], donde
   @c[f(x)] explica el funcionamiento intentado y su entrada, @c(y) es el
   resultado real, y @c(z) el resultado esperado. Cuando es conveniente, como en
   nuestro ejemplo palindromo, se utiliza la sintaxis actual para la parte
   @c[f(x)]. La visualizacion de @c(x) es particularmente importante en una
   prueba basada en tablas, ya que una afirmacion dada se ejecuta muchas veces
   con diferentes valores. Evite la informacion repetitiva y redundante. Cuando
   se prueba una funcion booleana como @c(IsPalindrome), omita la parte @c(z)
   puesto que no agrega ninguna informacion. Si @c(x), @c(y) o @c(z) es largo,
   en su lugar imprima un resumen relevante de las partes. El autor de una
   prueba debe esforzarse por ayudar al programador que debe diagnosticar un
   fallo de la prueba.

#    @b(Exercise 11.1): Write tests for the @$(charcount) program in @l(#Section 4.3).
   @b(Ejercicio 11.1): escribir pruebas para el programa @$(charcount) en la
   @l(#Seccion 4.3).

#    @b(Exercise 11.2): Write a set of tests for @c(IntSet) (@l(#Section
#    6.5<>§6.5)) that checks that its behavior after each operation is equivalent
#    to a set based on built-in maps. Save your implementation for benchmarking in
#    Exercise 11.7.
   @b(Ejercicio 11.2): Escribir una serie de pruebas para @c(IntSet)
   (@l(#Seccion 6.5<>§6.5)) que comprueba que su comportamiento despues de cada
   operacion es equivalente a un conjunto basado en mapas incorporados. Guarde
   su implementacion para el benchmarking del Ejercicio 11.7.

# *** Section 11.2.1 <> Randomized Testing
*** Seccion 11.2.1 <> Pruebas Aleatorias

#     Table-driven tests are convenient for checking that a function works on
#     inputs carefully selected to exercise interesting cases in the
#     logic. Another approach, @e(randomized testing), explores a broader range of
#     inputs by constructing inputs at random.
    Las pruebas basadas en tablas son convenientes para comprobar que una
    funcion funciona en entradas cuidadosamente seleccionadas para ejercer casos
    interesantes en la logica. Otro enfoque, @e(pruebas al azar), explora una
    gama mas amplia de entradas mediante la construccion de entradas al azar.

#     How do we know what output to expect from our function, given a random
#     input? There are two strategies. The first is to write an alternative
#     implementation of the function that uses a less efficient but simpler and
#     clearer algorithm, and check that both implementations give the same
#     result. The second is to create input values according to a pattern so that
#     we know what output to expect.
    ¿Como sabemos que resultado esperar de nuestra funcion, dada una entrada
    aleatoria? Hay dos estrategias. La primera es escribir una implementacion
    alternativa de la funcion que utiliza un algoritmo menos eficiente pero mas
    sencillo y claro, y comprobar que ambas implementaciones dan el mismo
    resultado. La segunda es crear valores de entrada de acuerdo con un patron
    para que sepamos que salida esperamos.

#     The example below uses the second approach: the @c(randomPalindrome)
#     function generates words that are known to be palindromes by construction.
    El ejemplo siguiente utiliza el segundo enfoque: la funcion
    @c(randomPalindrome) genera palabras que se sabe que son palindromos por
    construccion.

#     ..src > go
#       import "math/rand"
#
#       // randomPalindrome returns a palindrome whose length and contents
#       // are derived from the pseudo-random number generator rng.
#       func randomPalindrome(rng *rand.Rand) string {
#         n := rng.Intn(25) // random length up to 24
#         runes := make([]rune, n)
#         for i := 0; i < (n+1)/2; i++ {
#           r := rune(rng.Intn(0x1000)) // random rune up to '\u0999'
#           runes[i] = r
#           runes[n-1-i] = r
#         }
#         return string(runes)
#       }
#
#       func TestRandomPalindromes(t *testing.T) {
#         // Initialize a pseudo-random number generator.
#         seed := time.Now().UTC().UnixNano()
#         t.Logf("Random seed: %d", seed)
#         rng := rand.New(rand.NewSource(seed))
#
#         for i := 0; i < 1000; i++ {
#           p := randomPalindrome(rng)
#           if !IsPalindrome(p) {
#             t.Errorf("IsPalindrome(%q) = false", p)
#           }
#         }
#       }
#     < src..
    ..src > go
      import "math/rand"

      // randomPalindrome devuelve un palindromo cuya longitud y contenido
      // se derivan del generador de numeros pseudo aleatorios rng.
      func randomPalindrome(rng *rand.Rand) string {
        n := rng.Intn(25) // random length up to 24
        runes := make([]rune, n)
        for i := 0; i < (n+1)/2; i++ {
          r := rune(rng.Intn(0x1000)) // random rune up to '\u0999'
          runes[i] = r
          runes[n-1-i] = r
        }
        return string(runes)
      }

      func TestRandomPalindromes(t *testing.T) {
        // Initialize a pseudo-random number generator.
        seed := time.Now().UTC().UnixNano()
        t.Logf("Random seed: %d", seed)
        rng := rand.New(rand.NewSource(seed))

        for i := 0; i < 1000; i++ {
          p := randomPalindrome(rng)
          if !IsPalindrome(p) {
            t.Errorf("IsPalindrome(%q) = false", p)
          }
        }
      }
    < src..

#     Since randomized tests are nondeterministic, it is critical that the log of
#     the failing test record sufficient information to reproduce the failure. In
#     our example, the input @c(p) to @c(IsPalindrome) tells us all we need to
#     know, but for functions that accept more complex inputs, it may be simpler
#     to log the seed of the pseudo-random number generator (as we do above) than
#     to dump the entire input data structure. Armed with that seed value, we can
#     easily modify the test to replay the failure deterministically.
    Dado que las pruebas aleatorizadas son no deterministas, es fundamental que
    el registro de la prueba de fallo registre informacion suficiente para
    reproducir el fallo. En nuestro ejemplo, la entrada @c(p) para
    @c(IsPalindrome) nos dice todo lo que necesitamos saber, pero para las
    funciones que aceptan entradas mas complejas, puede ser mas sencillo
    registrar la semilla del generador de numeros pseudo-aleatorios (como lo
    hacemos mas arriba) que volcar toda la estructura de datos de
    entrada. Armado con ese valor de semilla, podemos modificar facilmente la
    prueba para reproducir el fracaso de forma determinista.

#     By using the current time as a source of randomness, the test will explore
#     novel inputs each time it is run, over the entire course of its
#     lifetime. This is especially valuable if your project uses an automated
#     system to run all its tests periodically.
    Utilizando la hora actual como una fuente de aleatoriedad, la prueba
    explorara nuevas entradas cada vez que se ejecute, durante todo el curso de
    su vida util. Esto es especialmente valioso si su proyecto utiliza un
    sistema automatizado para ejecutar todas sus pruebas periodicamente.

#     @b(Exercise 11.3): @c(TestRandomPalindromes) only tests palindromes. Write a
#     randomized test that generates and verifies @e(non)-palindromes.
    @b(Ejercicio 11.3): @c(TestRandomPalindromes) solo prueba palindromos.
    Escriba una prueba aleatoria que genere y verifique no-palindromos.

#     @b(Exercise 11.4): Modify @c(randomPalindrome) to exercise
#     @c(IsPalindrome)’s handling of punctuation and spaces.
    @b(Ejercicio 11.4): Modificar @c(randomPalindrome) para probar el manejo de
    puntuacion y espacios de @c(IsPalindrome).

# *** Section 11.2.2 <> Testing a Command
*** Seccion 11.2.2 <> Probar un Comando

#     The @$(go test) tool is useful for testing library packages, but with a
#     little effort we can use it to test commands as well. A package named
#     @c(main) ordinarily produces an executable program, but it can be imported
#     as a library too.
    La heramienta @$(go test) es util para probar paquetes de librerias, pero
    con un poco de esfuerzo lo podemos usar para probar tambien los comandos. Un
    paquete llamado @c(main) normalmente produce un programa ejecutable, pero
    tambien puede ser importado como una libreria.

#     Let’s write a test for the @$(echo) program of @l(#Section 2.3.2). We’ve
#     split the program into two functions: @$(echo) does the real work, while
#     @c(main) parses and reads the flag values and reports any errors returned by
#     @$(echo).
    Vamos a escribir una prueba para el programa @$(echo) de la @l(#Seccion
    2.3.2). Hemos dividido el programa en dos funciones: @c(echo) hace el
    trabajo real, mientras que @c(main) analiza y lee los valores bandera y los
    errores devueltos por @c(echo).

#     ..figure > @l(gopl.io/ch11/echo/echo.go<>gopl.io/ch11/echo)
    ..figure > @l(gopl.io/ch11/echo/echo.go<>gopl.io/ch11/echo)

#       ..src > go
#         // Echo prints its command-line arguments.
#         package main
#
#         import (
#           "flag"
#           "fmt"
#           "io"
#           "os"
#           "strings"
#         )
#
#         var (
#           n = flag.Bool("n", false, "omit trailing newline")
#           s = flag.String("s", " ", "separator")
#         )
#
#         var out io.Writer = os.Stdout // modified during testing
#
#         func main() {
#           flag.Parse()
#           if err := echo(!*n, *s, flag.Args()); err != nil {
#             fmt.Fprintf(os.Stderr, "echo: %v\n", err)
#             os.Exit(1)
#           }
#         }
#
#         func echo(newline bool, sep string, args []string) error {
#           fmt.Fprint(out, strings.Join(args, sep))
#           if newline {
#             fmt.Fprintln(out)
#           }
#           return nil
#         }
#       < src..
      ..src > go
        // Echo imprime sus argumentos de linea de comandos.
        package main

        import (
          "flag"
          "fmt"
          "io"
          "os"
          "strings"
        )

        var (
          n = flag.Bool("n", false, "omit trailing newline")
          s = flag.String("s", " ", "separator")
        )

        var out io.Writer = os.Stdout // modificado durante las pruebas

        func main() {
          flag.Parse()
          if err := echo(!*n, *s, flag.Args()); err != nil {
            fmt.Fprintf(os.Stderr, "echo: %v\n", err)
            os.Exit(1)
          }
        }

        func echo(newline bool, sep string, args []string) error {
          fmt.Fprint(out, strings.Join(args, sep))
          if newline {
            fmt.Fprintln(out)
          }
          return nil
        }
      < src..


#     From the test, we will call @$(echo) with a variety of arguments and flag
#     settings and check that it prints the correct output in each case, so we’ve
#     added parameters to @c(echo) to reduce its dependence on global
#     variables. That said, we’ve also introduced another global variable,
#     @c(out), the @c(io.Writer) to which the result will be written. By having
#     @c(echo) write through this variable, not directly to @c(os.Stdout), the
#     tests can substitute a different @c(Writer) implementation that records what
#     was written for later inspection. Here’s the test, in file @f(echo_test.go):
    A partir de la prueba, llamaremos a @$(echo) con una variedad de argumentos
    y configuraones de parametros bandera y comprobaremos que imprime la salida
    correcta en cada caso, por lo que hemos añadido parametros a @$(echo) para
    reducir su dependencia de las variables globales. Dicho esto, tambien hemos
    introducido otra variable global, @c(out), un @c(io.Writer) al que se
    escribira el resultado. Al tener @c(echo) escritura a traves de esta
    variable, no directamente a @c(os.Stdout), las pruebas pueden sustituir una
    implementacion @c(Writer) diferente que registra lo que se escrito para una
    inspeccion posterior. Aqui esta la prueba, en archivo @c(echo_test.go):

#     ..src > go
#       package main
#       import (
#         "bytes"
#         "fmt"
#         "testing"
#       )
#
#       func TestEcho(t *testing.T) {
#         var tests = []struct {
#           newline bool
#           sep     string
#           args    []string
#           want    string
#         }{
#           {true, "", []string{}, "\n"},
#           {false, "", []string{}, ""},
#           {true, "\t", []string{"one", "two", "three"}, "one\ttwo\tthree\n"},
#           {true, ",", []string{"a", "b", "c"}, "a,b,c\n"},
#           {false, ":", []string{"1", "2", "3"}, "1:2:3"},
#         }
#
#         for _, test := range tests {
#           descr := fmt.Sprintf("echo(%v, %q, %q)",
#             test.newline, test.sep, test.args)
#
#           out = new(bytes.Buffer) // captured output
#           if err := echo(test.newline, test.sep, test.args); err != nil {
#             t.Errorf("%s failed: %v", descr, err)
#             continue
#           }
#           got := out.(*bytes.Buffer).String()
#           if got != test.want {
#             t.Errorf("%s = %q, want %q", descr, got, test.want)
#           }
#         }
#       }
#     < src..
    ..src > go
      package main
      import (
        "bytes"
        "fmt"
        "testing"
      )

      func TestEcho(t *testing.T) {
        var tests = []struct {
          newline bool
          sep     string
          args    []string
          want    string
        }{
          {true, "", []string{}, "\n"},
          {false, "", []string{}, ""},
          {true, "\t", []string{"one", "two", "three"}, "one\ttwo\tthree\n"},
          {true, ",", []string{"a", "b", "c"}, "a,b,c\n"},
          {false, ":", []string{"1", "2", "3"}, "1:2:3"},
        }

        for _, test := range tests {
          descr := fmt.Sprintf("echo(%v, %q, %q)",
            test.newline, test.sep, test.args)

          out = new(bytes.Buffer) // captura la salida
          if err := echo(test.newline, test.sep, test.args); err != nil {
            t.Errorf("%s failed: %v", descr, err)
            continue
          }
          got := out.(*bytes.Buffer).String()
          if got != test.want {
            t.Errorf("%s = %q, want %q", descr, got, test.want)
          }
        }
      }
    < src..

#     Notice that the test code is in the same package as the production
#     code. Although the package name is @c(main) and it defines a @c(main)
#     function, during testing this package acts as a library that exposes the
#     function @c(TestEcho) to the test driver; its @c(main) function is ignored.
    Observe que el codigo de prueba esta en el mismo paquete que el codigo de
    produccion. Aunque el nombre del paquete es @c(main) y define una funcion
    @c(main), durante la prueba, este paquete actua como una libreria que expone
    la funcion @c(TestEcho) al controlador de pruebas; su funcion @c(main) es
    ignorada.

#     By organizing the test as a table, we can easily add new test cases. Let’s
#     see what happens when the test fails, by adding this line to the table:
    Al organizar la prueba como una tabla, podemos agregar facilmente nuevos
    casos de prueba. Veamos que sucede cuando la prueba falla, agregando esta
    linea a la tabla:

#     ..src > go
#       {true, ",", []string{"a", "b", "c"}, "a b c\n"}, // NOTE: wrong expectation!
#     < src..
    ..src > go
      {true, ",", []string{"a", "b", "c"}, "a b c\n"}, // NOTA: expectativa equivocada!
    < src..

#     @$(go test) prints
    @$(go test) imprime

#     ..src > sh
#       $ go test gopl.io/ch11/echo
#       --- FAIL: TestEcho (0.00s)
#           echo_test.go:31: echo(true, ",", ["a" "b" "c"]) = "a,b,c", want "a b c\n"
#       FAIL
#       FAIL    gopl.io/ch11/echo   0.006s
#     < src..
    ..src > sh
      $ go test gopl.io/ch11/echo
      --- FAIL: TestEcho (0.00s)
          echo_test.go:31: echo(true, ",", ["a" "b" "c"]) = "a,b,c", want "a b c\n"
      FAIL
      FAIL    gopl.io/ch11/echo   0.006s
    < src..

#     The error message describes the attempted operation (using Go-like syntax),
#     the actual behavior, and the expected behavior, in that order. With an
#     informative error message such as this, you may have a pretty good idea
#     about the root cause before you’ve even located the source code of the test.
    El mensaje de error describe el intento de operacion (utilizando la sintaxis
    similar a Go), el comportamiento real y el comportamiento esperado, en ese
    orden. Con un mensaje de error informativo como este, es posible que tenga
    una idea bastante buena sobre la causa raiz antes incluso de haber
    localizado el codigo fuente de la prueba.

#     It’s important that code being tested not call @c(log.Fatal) or @c(os.Exit),
#     since these will stop the process in its tracks; calling these functions
#     should be regarded as the exclusive right of @c(main).  If something totally
#     unexpected happens and a function panics, the test driver will recover,
#     though the test will of course be considered a failure. Expected errors such
#     as those resulting from bad user input, missing files, or improper
#     configuration should be reported by returning a non-nil @c(error)
#     value. Fortunately (though unfortunate as an illustration), our @$(echo)
#     example is so simple that it will never return a non-nil error.
    Es importante que el codigo esta probando no llame a @c(log.Fatal) o
    @c(os.Exit), ya que estas detendran el proceso en seco; llamar a estas
    funciones debe ser considerado como derecho exclusivo de @c(main). Si algo
    totalmente inesperado ocurre y una funcion entra en panico, el controlador
    de prueba se recuperara, aunque la prueba, por supuesto, se considerara un
    fallo. Errores previsibles, como los que resultan de mala entrada del
    usuario, archivos que faltan, o una configuracion inadecuada deben ser
    reportados mediante la devolucion de un valor @c(error) no-nil.
    Afortunadamente (aunque desafortunado como una ilustracion), nuestro ejemplo
    @$(echo) es tan simple que nunca volvera un error no-nil.

# *** Section 11.2.3 <> White-Box Testing
*** Seccion 11.2.3 <> Prueba de Caja Blanca

#     One way of categorizing tests is by the level of knowledge they require of
#     the internal workings of the package under test. A @e(black-box) test
#     assumes nothing about the package other than what is exposed by its API and
#     specified by its documentation; the package’s internals are opaque. In
#     contrast, a @e(white-box) test has privileged access to the internal
#     functions and data structures of the package and can make observations and
#     changes that an ordinary client cannot. For example, a white-box test can
#     check that the invariants of the package’s data types are maintained after
#     every operation. (The name @e(white box) is traditional, but @e(clear box)
#     would be more accurate.)
    Una forma de clasificar las pruebas es por el nivel de conocimiento que
    requieren del funcionamiento interno del paquete bajo prueba. Una prueba de
    @e(caja negla) no asume nada distinto sobre el paquete de lo expuesto por su
    API y especificado por su documentacion; Los internos del paquete son
    opacos. En contraste, una prueba de @e(caja blanca) tiene un acceso
    privilegiado a las funciones internas y estructuras de datos del paquete y
    puede hacer observaciones y cambios que un cliente comun no puede. Por
    ejemplo, una prueba de cuadro blanco puede comprobar que las invariantes de
    los tipos de datos del paquete se mantienen despues de cada operacion. (Er
    nombre @e(caja blanca) es tradicional, pero seria mas exacto @e(caja
    transparente)).

#     The two approaches are complementary. Black-box tests are usually more
#     robust, needing fewer updates as the software evolves. They also help the
#     test author empathize with the client of the package and can reveal flaws in
#     the API design. In contrast, white-box tests can provide more detailed
#     coverage of the trickier parts of the implementation.
    Los dos enfoques son complementarios. Las pruebas de caja negra suelen ser
    mas robustas, requiriendo menos actualizaciones a medida que el software
    evoluciona. Tambien ayudan al autor de la prueba a empatizar con el cliente
    del paquete y pueden revelar defectos en el diseño del API. Por el
    contrario, las pruebas de caja blanca pueden proporcionar una cobertura mas
    detallada de las partes mas dificiles de la implementacion.

#     We’ve already seen examples of both kinds. @c(TestIsPalindrome) calls only
#     the exported function @c(IsPalindrome) and is thus a black-box
#     test. @c(TestEcho) calls the @c(echo) function and updates the global variable
#     @c(out), both of which are unexported, making it a white-box test.
    Ya hemos visto ejemplos de ambos tipos. @c(TestIsPalindrome) llama solo a la
    funcion exportada @c(IsPalindrome) y es por lo tanto una prueba de caja
    negra. @c(TestEcho) llama a la funcion @c(echo) y actualiza la variable
    global @c(out), los cuales se dejadan sin exportar, por lo que es una prueba
    de caja blanca.

#     While developing @c(TestEcho), we modified the @c(echo) function to use the
#     package-level variable @c(out) when writing its output, so that the test
#     could replace the standard output with an alternative implementation that
#     records the data for later inspection. Using the same technique, we can
#     replace other parts of the production code with easy-to-test @"(fake)
#     implementations.  The advantage of fake implementations is that they can be
#     simpler to configure, more predictable, more reliable, and easier to
#     observe. They can also avoid undesirable side effects such as updating a
#     production database or charging a credit card.
    Durante el desarrollo de @c(TestEcho), modificamos la funcion @c(echo) para
    utilizar la variable de nivel de paquete @c(out) cuando se escribe su
    salida, por lo que la prueba podria sustituir a la salida estandar con una
    implementacion alternativa que registra los datos para una inspeccion
    posterior. Utilizando la misma tecnica, podemos reemplazar otras partes del
    codigo de produccion con implementaciones @"(falsas) faciles de probar. La
    ventaja de las implementaciones falsas es que pueden ser mas sencillas de
    configurar, mas predecibles, mas fiables y mas faciles de observar. Tambien
    pueden evitar efectos secundarios indeseables, como actualizar una base de
    datos de produccion o cargar una tarjeta de credito.

#     The code below shows the quota-checking logic in a web service that provides
#     networked storage to users. When users exceed 90% of their quota, the system
#     sends them a warning email.
    El siguiente codigo muestra la logica de comprobacion de cuotas en un
    servicio web que proporciona almacenamiento en red a los usuarios. Cuando
    los usuarios superan el 90% de su cuota, el sistema les envia un correo
    electronico de advertencia.

#     ..figure > @l(gopl.io/ch11/storage1/storage.go<>gopl.io/ch11/storage1)
    ..figure > @l(gopl.io/ch11/storage1/storage.go<>gopl.io/ch11/storage1)

#       ..src > go
#         package storage
#
#         import (
#           "fmt"
#           "log"
#           "net/smtp"
#         )
#
#         var usage = make(map[string]int64)
#
#         func bytesInUse(username string) int64 { return usage[username] }
#
#         // Email sender configuration.
#         // NOTE: never put passwords in source code!
#         const sender = "notifications@example.com"
#         const password = "correcthorsebatterystaple"
#         const hostname = "smtp.example.com"
#
#         const template = `Warning: you are using %d bytes of storage,
#         %d%% of your quota.`
#
#         func CheckQuota(username string) {
#           used := bytesInUse(username)
#           const quota = 1000000000 // 1GB
#           percent := 100 * used / quota
#           if percent < 90 {
#             return // OK
#           }
#           msg := fmt.Sprintf(template, used, percent)
#           auth := smtp.PlainAuth("", sender, password, hostname)
#           err := smtp.SendMail(hostname+":587", auth, sender,
#             []string{username}, []byte(msg))
#           if err != nil {
#             log.Printf("smtp.SendMail(%s) failed: %s", username, err)
#           }
#         }
#       < src..
      ..src > go
        package storage

        import (
          "fmt"
          "log"
          "net/smtp"
        )

        var usage = make(map[string]int64)

        func bytesInUse(username string) int64 { return usage[username] }

        // configuracion del remitente del email.
        // NOTA: nunca ponga contraseñas en el codigo fuente!
        const sender = "notifications@example.com"
        const password = "correcthorsebatterystaple"
        const hostname = "smtp.example.com"

        const template = `Warning: you are using %d bytes of storage,
        %d%% of your quota.`

        func CheckQuota(username string) {
          used := bytesInUse(username)
          const quota = 1000000000 // 1GB
          percent := 100 * used / quota
          if percent < 90 {
            return // OK
          }
          msg := fmt.Sprintf(template, used, percent)
          auth := smtp.PlainAuth("", sender, password, hostname)
          err := smtp.SendMail(hostname+":587", auth, sender,
            []string{username}, []byte(msg))
          if err != nil {
            log.Printf("smtp.SendMail(%s) failed: %s", username, err)
          }
        }
      < src..


#     We’d like to test it, but we don’t want the test to send out real email. So
#     we move the email logic into its own function and store that function in an
#     unexported package-level variable, @c(notifyUser).
    Nos gustaria probarlo, pero no queremos que la prueba envie correo
    electronico real. Por lo tanto, movemos la logica de correo electronico a su
    propia funcion y almacenamos esa funcion en una variable de nivel de paquete
    sin exportar, @c(notifyUser).

#     ..figure > @l(gopl.io/ch11/storage2/storage.go<>gopl.io/ch11/storage2)
    ..figure > @l(gopl.io/ch11/storage2/storage.go<>gopl.io/ch11/storage2)

#       ..src > go
#         var notifyUser = func(username, msg string) {
#           auth := smtp.PlainAuth("", sender, password, hostname)
#           err := smtp.SendMail(hostname+":587", auth, sender,
#             []string{username}, []byte(msg))
#           if err != nil {
#             log.Printf("smtp.SendMail(%s) failed: %s", username, err)
#           }
#         }
#
#         func CheckQuota(username string) {
#           used := bytesInUse(username)
#           const quota = 1000000000 // 1GB
#           percent := 100 * used / quota
#           if percent < 90 {
#             return // OK
#           }
#           msg := fmt.Sprintf(template, used, percent)
#           notifyUser(username, msg)
#         }
#       < src..
      ..src > go
        var notifyUser = func(username, msg string) {
          auth := smtp.PlainAuth("", sender, password, hostname)
          err := smtp.SendMail(hostname+":587", auth, sender,
            []string{username}, []byte(msg))
          if err != nil {
            log.Printf("smtp.SendMail(%s) failed: %s", username, err)
          }
        }

        func CheckQuota(username string) {
          used := bytesInUse(username)
          const quota = 1000000000 // 1GB
          percent := 100 * used / quota
          if percent < 90 {
            return // OK
          }
          msg := fmt.Sprintf(template, used, percent)
          notifyUser(username, msg)
        }
      < src..


#     We can now write a test that substitutes a simple fake notification
#     mechanism instead of sending real email. This one records the notified user
#     and the contents of the message.
    Ahora podemos escribir una prueba que sustituye un simple mecanismo de
    notificacion falsa en lugar de enviar correo electronico real. Este registra
    el usuario notificado y el contenido del mensaje.

#     ..src > go
#       package storage
#       import (
#         "strings"
#         "testing"
#       )
#
#       func TestCheckQuotaNotifiesUser(t *testing.T) {
#         var notifiedUser, notifiedMsg string
#         notifyUser = func(user, msg string) {
#           notifiedUser, notifiedMsg = user, msg
#         }
#
#         // ...simulate a 980MB-used condition...
#
#         const user = "joe@example.org"
#         CheckQuota(user)
#         if notifiedUser == "" && notifiedMsg == "" {
#           t.Fatalf("notifyUser not called")
#         }
#         if notifiedUser != user {
#           t.Errorf("wrong user (%s) notified, want %s",
#             notifiedUser, user)
#         }
#         const wantSubstring = "98% of your quota"
#         if !strings.Contains(notifiedMsg, wantSubstring) {
#           t.Errorf("unexpected notification message <<%s>>, "+
#             "want substring %q", notifiedMsg, wantSubstring)
#         }
#       }
#     < src..
    ..src > go
      package storage
      import (
        "strings"
        "testing"
      )

      func TestCheckQuotaNotifiesUser(t *testing.T) {
        var notifiedUser, notifiedMsg string
        notifyUser = func(user, msg string) {
          notifiedUser, notifiedMsg = user, msg
        }

        // ...simular una condicion que utiliza 980MB...

        const user = "joe@example.org"
        CheckQuota(user)
        if notifiedUser == "" && notifiedMsg == "" {
          t.Fatalf("notifyUser not called")
        }
        if notifiedUser != user {
          t.Errorf("wrong user (%s) notified, want %s",
            notifiedUser, user)
        }
        const wantSubstring = "98% of your quota"
        if !strings.Contains(notifiedMsg, wantSubstring) {
          t.Errorf("unexpected notification message <<%s>>, "+
            "want substring %q", notifiedMsg, wantSubstring)
        }
      }
    < src..

#     There’s one problem: after this test function has returned, @c(CheckQuota)
#     no longer works as it should because it’s still using the test’s fake
#     implementation of @c(notifyUsers). (There is always a risk of this kind when
#     updating global variables.) We must modify the test to restore the previous
#     value so that subsequent tests observe no effect, and we must do this on all
#     execution paths, including test failures and panics. This naturally suggests
#     @c(defer).
    Hay un problema: despues de que esta funcion de prueba ha regresado,
    @c(CheckQuota) ya no funciona como deberia, ya que todavia esta usando la
    prueba de falsa implementacion de @c(notifyUsers). Debemos modificar la
    prueba para restaurar el valor anterior para que las pruebas posteriores no
    observen ningun efecto, y debemos hacerlo en todas las rutas de ejecucion,
    incluyendo fallas de prueba y panicos. Naturalmente, esto sugiere un
    @c(defer).

#     ..src > go
#       func TestCheckQuotaNotifiesUser(t *testing.T) {
#         // Save and restore original notifyUser.
#         saved := notifyUser
#         defer func() { notifyUser = saved }()
#
#         // Install the test's fake notifyUser.
#         var notifiedUser, notifiedMsg string
#         notifyUser = func(user, msg string) {
#           notifiedUser, notifiedMsg = user, msg
#         }
#         // ...rest of test...
#       }
#     < src..
    ..src > go
      func TestCheckQuotaNotifiesUser(t *testing.T) {
        // Guardar y restaurar notifiUser original
        saved := notifyUser
        defer func() { notifyUser = saved }()

        // Instala la prueba falsa notifyUser.
        var notifiedUser, notifiedMsg string
        notifyUser = func(user, msg string) {
          notifiedUser, notifiedMsg = user, msg
        }
        // ...resto de la prueba...
      }
    < src..

#     This pattern can be used to temporarily save and restore all kinds of global
#     variables, including command-line flags, debugging options, and performance
#     parameters; to install and remove hooks that cause the production code to
#     call some test code when something interesting happens; and to coax the
#     production code into rare but important states, such as timeouts, errors,
#     and even specific interleavings of concurrent activities.
    Este patron se puede utilizar para guardar y restaurar temporalmente todo
    tipo de variables globales, incluidas banderas de linea de comandos,
    opciones de depuracion y parametros de rendimiento; para instalar y eliminar
    los ganchos que hacen que el codigo de produccion llame al codigo de prueba
    cuando sucede algo interesante; y para codificar el codigo de produccion en
    estados raros pero importantes, como tiempos muertos, errores e incluso
    intercalaciones especificas de actividades concurrentes.

#     Using global variables in this way is safe only because @$(go test) does not
#     normally run multiple tests concurrently.
    El uso de variables globales de esta manera es seguro solo porque @$(go
    test) normalmente no ejecuta pruebas multiples de forma concurrente.

# *** Section 11.2.4 <> External Test Packages
*** Seccion 11.2.4 <> Paquetes de Pruebas Externos

#     Consider the packages @c(net/url), which provides a URL parser, and
#     @c(net/http), which provides a web server and HTTP client library. As we
#     might expect, the higher-level @c(net/http) depends on the lower-level
#     @c(net/url). However, one of the tests in net/url is an example
#     demonstrating the interaction between URLs and the HTTP client library. In
#     other words, a test of the lower-level package imports the higher-level
#     package.
    Considere los paquetes de @c(net/url), que proporciona un analizador de URL,
    y @c(net/http), que proporciona un servidor web y una libreria de cliente
    HTTP. Como es de esperar, el nivel superior de @c(net/http) depende del
    nivel inferior @c(net/url). Sin embargo, una de las pruebas en @c(net/url)
    es un ejemplo que demuestra la interaccion entre las URL y la libreria
    cliente HTTP. En otras palabras, una prueba al paquete de nivel inferior
    importa el paquete de nivel superior.

#     ..figure > Figure 11.1. A test of @c(net/url) depends on @c(net/http).
    ..figure > Figura 11.1. Una prueba de @c(net/url) depende de @c(net/http).

#       ..img  > img/Figure-11.1.jpg
      ..img  > img/Figure-11.1.jpg

#     Declaring this test function in the @c(net/url) package would create a cycle
#     in the package import graph, as depicted by the upwards arrow in Figure
#     11.1, but as we explained in @l(#Section 10.1), the Go specification forbids
#     import cycles.
    Declarar esta funcion de prueba en el paquete @c(net/url) crearia un ciclo
    en el grafico de importacion paquetes, tal como se representa por las flecha
    hacia arriba en la Figura 11.1, pero como se explico en la @l(#Seccion
    10.1), la especificacion Go prohibe los ciclos de importacion.

#     We resolve the problem by declaring the test function in an @e(external test
#     package), that is, in a file in the @c(net/url) directory whose package
#     declaration reads package @c(url_test). The extra suffix @c(_test) is a signal
#     to @$(go test) that it should build an additional package containing just
#     these files and run its tests. It may be helpful to think of this external
#     test package as if it had the import path @c(net/url_test), but it cannot be
#     imported under this or any other name.
    Resolvemos el problema declarando la funcion de prueba en un @e(paquete de
    prueba externo), es decir, en un archivo en el directorio @c(net/url) cuya
    declaracion del paquete lee el paquete @c(url_test). El sufijo adicional
    @c(_test) es una señal para @$(go test) que debe construir un paquete
    adicional que contiene solo estos archivos y ejecutar sus pruebas. Puede ser
    util pensar en este paquete de prueba externo como si tuviera la ruta de
    importacion @c(net/url_test), pero no se pueden importar con este nombre ni
    con ningun otro.

#     Because external tests live in a separate package, they may import helper
#     packages that also depend on the package being tested; an in-package test
#     cannot do this. In terms of the design layers, the external test package is
#     logically higher up than both of the packages it depends upon, as shown in
#     Figure 11.2.
    Debido a que las pruebas externas viven en un paquete separado, pueden
    importar paquetes auxiliares que tambien dependen del paquete que se esta
    probando; Una prueba en el paquete no puede hacer esto. En terminos de las
    capas de diseño, el paquete de pruebas externo es logicamente mas alto que
    los dos paquetes de los que depende, como se muestra en la Figura 11.2.

#     ..figure > Figure 11.2. External test packages break dependency cycles.
    ..figure > Figura 11.2. Los paquetes de prueba externos rompen los ciclos de
      dependencia.

#       ..img  > img/Figure-11.2.jpg
      ..img  > img/Figure-11.2.jpg

#     By avoiding import cycles, external test packages allow tests, especially
#     @e(integration tests) (which test the interaction of several components), to
#     import other packages freely, exactly as an application would.
    Al evitar ciclos de importacion, los paquetes de prueba externos permiter
    que las pruebas, especialmente las @e(pruebas de integracion) (que ponen a
    prueba la interaccion de varios componentes), importen otros paquetes
    libremente, exactamente como haria una aplicacion.

#     We can use the @$(go list) tool to summarize which Go source files in a
#     package directory are production code, in-package tests, and external
#     tests. We’ll use the @c(fmt) package as an example.  @c(GoFiles) is the list
#     of files that contain the production code; these are the files that @$(go
#     build) will include in your application:
    Podemos utilizar la herramienta @$(go list) para resumir que archivos fuente
    en un directorio Go son el codigo de produccion, pruebas en el paquete, y
    pruebas externas. Usaremos el paquete @c(fmt) como ejemplo. GoFiles es la
    lista de los archivos que contienen el codigo de produccion; estos son los
    archivos que @$(go build) incluira en su aplicacion:

#     ..src > sh
#       $ go list -f={{.GoFiles}} fmt
#       [doc.go format.go print.go scan.go]
#     < src..
    ..src > sh
      $ go list -f={{.GoFiles}} fmt
      [doc.go format.go print.go scan.go]
    < src..

#     @c(TestGoFiles) is the list of files that also belong to the @c(fmt)
#     package, but these files, whose names all end in @f(_test.go), are included
#     only when building tests:
    @c(TestGoFiles) es la lista de archivos que tambien pertenecen al paquete
    @c(fmt), pero estos archivos, cuyos nombres terminan en @f(_test.go), se
    incluye solo en la construccion de las pruebas:

#     ..src > sh
#       $ go list -f={{.TestGoFiles}} fmt
#       [export_test.go]
#     < src..
    ..src > sh
      $ go list -f={{.TestGoFiles}} fmt
      [export_test.go]
    < src..

#     The package’s tests would usually reside in these files, though unusually
#     @c(fmt) has none; we’ll explain the purpose of @f(export_test.go) in a
#     moment.
    Las pruebas del paquete por lo general residen en estos archivos, aunque
    inusualmente @c(fmt) no tiene ninguno; vamos a explicar el proposito de
    @c(export_test.go) en un momento.

#     @c(XTestGoFiles) is the list of files that constitute the external test
#     package, @c(fmt_test), so these files must import the @c(fmt) package in
#     order to use it. Again, they are included only during testing:
    @c(XTestGoFiles) es la lista de los archivos que constituyen el paquete de
    prueba externo, @c(fmt_test), por lo que estos archivos debe importar el
    paquete @c(fmt) con el fin de usarlo. Una vez mas, se incluyen solo durante
    las pruebas:

#     ..src > sh
#       $ go list -f={{.XTestGoFiles}} fmt
#       [fmt_test.go scan_test.go stringer_test.go]
#     < src..
    ..src > sh
      $ go list -f={{.XTestGoFiles}} fmt
      [fmt_test.go scan_test.go stringer_test.go]
    < src..

#     Sometimes an external test package may need privileged access to the
#     internals of the package under test, if for example a white-box test must
#     live in a separate package to avoid an import cycle. In such cases, we use a
#     trick: we add declarations to an in-package @f(_test.go) file to expose the
#     necessary internals to the external test. This file thus offers the test a
#     @"(back door) to the package. If the source file exists only for this
#     purpose and contains no tests itself, it is often called @f(export_test.go).
    A veces un paquete de prueba externo puede necesitar acceso privilegiado a
    los internos del paquete bajo prueba, si por ejemplo una prueba de caja
    blanca debe vivir en un paquete separado para evitar un ciclo de
    importacion. En estos casos, se utiliza un truco: agregamos declaraciones a
    un archivo @f(_test.go) del paquete para exponer los componentes internos
    necesarios para la prueba externa. Este archivo ofrece asi una @"(puerta
    trasera) para la prueba del paquete. Si el archivo origen existe solo para
    este proposito y no contiene pruebas en si mismo, se le nombra a menudo
    @f(export_test.go).

#     For example, the implementation of the @c(fmt) package needs the
#     functionality of @c(unicode.IsSpace) as part of @c(fmt.Scanf). To avoid
#     creating an undesirable dependency, @c(fmt) does not import the @c(unicode)
#     package and its large tables of data; instead, it contains a simpler
#     implementation, which it calls @c(isSpace).
    Por ejemplo, la implementacion del paquete @c(fmt) necesita la funcionalidad
    de @c(unicode.IsSpace) como parte de @c(fmt.Scanf). Para evitar la creacion
    de una dependencia indeseable, @c(fmt) no importa el paquete @c(unicode) y
    sus grandes tablas de datos; en cambio, contiene una implementacion mas
    sencilla, a la que llama @c(isSpace).

#     To ensure that the behaviors of @c(fmt.isSpace) and @c(unicode.IsSpace) do
#     not drift apart, @c(fmt) prudently contains a test. It is an external test,
#     and thus it cannot access @c(isSpace) directly, so @c(fmt) opens a back door
#     to it by declaring an exported variable that holds the internal @c(isSpace)
#     function. This is the entirety of the @c(fmt) package’s @f(export_test.go)
#     file.
    Para asegurar que los comportamientos de @c(fmt.isSpace) y
    @c(unicode.IsSpace) no se separan, @c(fmt) prudentemente contiene una
    prueba. Se trata de una prueba externa, y por lo tanto no puede acceder a
    @c(isSpace) directamente, por lo que @c(fmt) abre una puerta trasera
    declarando una variable exportada que contiene la funcion interna
    @c(isSpace). Esta es la totalidad del archivo @f(export_test.go) del paquete
    @c(fmt).

#     ..src > go
#       package fmt
#
#       var IsSpace = isSpace
#     < src..
    ..src > go
      package fmt

      var IsSpace = isSpace
    < src..

#     This test file defines no tests; it just declares the exported symbol
#     @c(fmt.IsSpace) for use by the external test. This trick can also be used
#     whenever an external test needs to use some of the techniques of white-box
#     testing.
    Este archivo de prueba no define pruebas; simplemente declara el simbolo
    exportado @c(fmt.IsSpace) para el uso de la prueba externa. Este truco
    tambien se puede utilizar cada vez que una prueba externa necesita utilizar
    algunas de las tecnicas de prueba de caja blanca.

# *** Section 11.2.5 <> Writing Effective Tests
*** Seccion 11.2.5 <> Escribir Pruebas Efectivas

#     Many newcomers to Go are surprised by the minimalism of Go’s testing
#     framework. Other languages’ frameworks provide mechanisms for identifying
#     test functions (often using reflection or metadata), hooks for performing
#     @"(setup) and @"(teardown) operations before and after the tests run, and
#     libraries of utility functions for asserting common predicates, comparing
#     values, formatting error messages, and aborting a failed test (often using
#     exceptions). Although these mechanisms can make tests very concise, the
#     resulting tests often seem like they are written in a foreign
#     language. Furthermore, although they may report @c(PASS) or @c(FAIL)
#     correctly, their manner may be unfriendly to the unfortunate maintainer,
#     with cryptic failure messages like @c("assert: 0 == 1") or page after page
#     of stack traces.
    Muchos recien llegados a Go se sorprenden por el minimalismo del marco de
    pruebas de Go. los frameworks otros lenguajes proporcionan mecanismos para
    la identificacion de las funciones de prueba (a menudo utilizan la reflexion
    o metadatos), ganchos para realizar operaciones de @"(configuracion) y
    @"(desmontaje) antes y despues de ejecucion de pruebas, y l librerias de
    funciones de utilidad para afirmar predicados comunes, comparar valores,
    formatear mensajes de error, y abortar una prueba fallida (a menudo
    utilizando excepciones). Aunque estos mecanismos pueden hacer las pruebas
    muy concisas, las pruebas resultantes a menudo parecen estar escritas en un
    lenguaje extranjero. Ademas, aunque pueden reportar @c(PASS) o @c(FAIL)
    correctamente, su forma puede ser hostil al infortunado mantenedor, con
    mensajes de error cripticos como @c("assert: 0 == 1") o pagina tras pagina
    de trazas de la pila.

#     Go’s attitude to testing stands in stark contrast. It expects test authors
#     to do most of this work themselves, defining functions to avoid repetition,
#     just as they would for ordinary programs. The process of testing is not one
#     of rote form filling; a test has a user interface too, albeit one whose only
#     users are also its maintainers. A good test does not explode on failure but
#     prints a clear and succinct description of the symptom of the problem, and
#     perhaps other relevant facts about the context. Ideally, the maintainer
#     should not need to read the source code to decipher a test failure. A good
#     test should not give up after one failure but should try to report several
#     errors in a single run, since the pattern of failures may itself be
#     revealing.
    La actitud de Go a la pruebas esta en contraste. Se espera que los autores
    de las pruebas hagan la mayor parte de este trabajo ellos mismos, definiendo
    funciones para evitar la repeticion, tal como lo harian para los programas
    ordinarios. El proceso de prueba no es uno relleno de formatos; una prueba
    tiene una interfaz de usuario tambien, aunque uno cuyos unicos usuarios son
    tambien sus mantenedores. Una buena prueba no explota al fracasar, en su
    lugar imprime una descripcion clara y sucinta del sintoma del problema, y
    ​​tal vez otros hechos relevantes sobre el contexto. Idealmente, el mantenedor
    no deberia necesitar leer el codigo fuente para descifrar un fallo de
    prueba. Una buena prueba no debe abandonar despues de un fallo, debe
    intentar reportar varios errores en una sola ejecucion, ya que el patron de
    fallas puede ser revelador.

#     The assertion function below compares two values, constructs a generic error
#     message, and stops the program. It’s easy to use and it’s correct, but when
#     it fails, the error message is almost useless. It does not solve the hard
#     problem of providing a good user interface.
    La funcion de asercion siguiente compara dos valores, genera un mensaje de
    error generico y detiene el programa. Es facil de usar y es correcta, pero
    cuando falla, el mensaje de error es casi inutil. No resuelve el dificil
    problema de proporcionar una buena interfaz de usuario.

#     ..src > go
#       import (
#         "fmt"
#         "strings"
#         "testing"
#       )
#
#       // A poor assertion function.
#       func assertEqual(x, y int) {
#         if x != y {
#           panic(fmt.Sprintf("%d != %d", x, y))
#         }
#       }
#
#       func TestSplit(t *testing.T) {
#         words := strings.Split("a:b:c", ":")
#         assertEqual(len(words), 3)
#         // ...
#       }
#     < src..
    ..src > go
      import (
        "fmt"
        "strings"
        "testing"
      )

      // Una mala funcion de asercion.
      func assertEqual(x, y int) {
        if x != y {
          panic(fmt.Sprintf("%d != %d", x, y))
        }
      }

      func TestSplit(t *testing.T) {
        words := strings.Split("a:b:c", ":")
        assertEqual(len(words), 3)
        // ...
      }
    < src..

#     In this sense, assertion functions suffer from @e(premature abstraction): by
#     treating the failure of this particular test as a mere difference of two
#     integers, we forfeit the opportunity to provide meaningful context. We can
#     provide a better message by starting from the concrete details, as in the
#     example below. Only once repetitive patterns emerge in a given test suite is
#     it time to introduce abstractions.
    En este sentido, las funciones de asercion sufren de abstraccion prematura:
    al tratar el fracaso de esta prueba en particular como una mera diferencia
    de dos numeros enteros, perdemos la oportunidad de proporcionar un contexto
    significativo. Podemos proporcionar un mejor mensaje a partir de los
    detalles concretos, como en el ejemplo siguiente. Solo una vez que surgen
    patrones repetitivos en una suite de pruebas dada es el momento de
    introducir abstracciones.

#     ..src > go
#       func TestSplit(t *testing.T) {
#         s, sep := "a:b:c", ":"
#         words := strings.Split(s, sep)
#         if got, want := len(words), 3; got != want {
#           t.Errorf("Split(%q, %q) returned %d words, want %d",
#             s, sep, got, want)
#         }
#         // ...
#       }
#     < src..
    ..src > go
      func TestSplit(t *testing.T) {
        s, sep := "a:b:c", ":"
        words := strings.Split(s, sep)
        if got, want := len(words), 3; got != want {
          t.Errorf("Split(%q, %q) returned %d words, want %d",
            s, sep, got, want)
        }
        // ...
      }
    < src..

#     Now the test reports the function that was called, its inputs, and the
#     significance of the result; it explicitly identifies the actual value and
#     the expectation; and it continues to execute even if this assertion should
#     fail. Once we’ve written a test like this, the natural next step is often
#     not to define a function to replace the entire @c(if) statement, but to
#     execute the test in a loop in which @c(s), @c(sep), and @c(want) vary, like
#     the table-driven test of @c(IsPalindrome).
    Ahora la prueba reporta la funcion que se llamo, sus entradas y el
    significado del resultado; Identifica explicitamente el valor actual y la
    expectativa; Y continua ejecutandose incluso si esta afirmacion falla. Una
    vez que hemos escrito una prueba de este tipo, el siguiente paso natural a
    menudo no es definir una funcion para reemplazar toda le sentencia @c(if),
    sino ejecutar la prueba en un bucle en el que varien @c(s), @c(sep), y
    @c(want), como en la prueba basada en tablas de @c(IsPalindrome).

#     The previous example didn’t need any utility functions, but of course that
#     shouldn’t stop us from introducing functions when they help make the code
#     simpler. (We’ll look at one such utility function, @c(reflect.DeepEqual), in
#     @l(#Section 13.3).) The key to a good test is to start by implementing the
#     concrete behavior that you want and only then use functions to simplify the
#     code and eliminate repetition. Best results are rarely obtained by starting
#     with a library of abstract, generic testing functions.
    El ejemplo anterior no necesitaba funciones de utilidad, pero por supuesto
    eso no deberia impedirnos introducir funciones cuando ayudan a simplificar
    el codigo. (Veremos una funcion de utilidad, @c(reflect.DeepEqual), en la
    @l(#Seccion 13.3).) La clave para una buena prueba es empezar por la
    aplicacion de la conducta concreta que desea y solo entonces utilizar las
    funciones para simplificar el codigo y eliminar la repeticion. Los mejores
    resultados rara vez se obtienen comenzando con una libreria de funciones de
    pruebas abstractas y genericas.

#     @b(Exercise 11.5): Extend @c(TestSplit) to use a table of inputs and
#     expected outputs.
    @b(Ejercicio 11.5): Extender @c(TestSplit) para utilizar una tabla de
    entradas y salidas esperadas.

# *** Section 11.2.6 <> Avoiding Brittle Tests
*** Seccion 11.2.6 <> Evitar Pruebas Fragiles

#     An application that often fails when it encounters new but valid inputs is
#     called @e(buggy); a test that spuriously fails when a sound change was made
#     to the program is called @e(brittle). Just as a buggy program frustrates its
#     users, a brittle test exasperates its maintainers. The most brittle tests,
#     which fail for almost any change to the production code, good or bad, are
#     sometimes called @e(change detector) or @e(status quo) tests, and the time
#     spent dealing with them can quickly deplete any benefit they once seemed to
#     provide.
    Una aplicacion que falla a menudo cuando se encuentra con entradas nuevas
    pero validas, se denomina @e(buggy); una prueba que falla falsamente cuando
    se hace un cambio de sonido al programa se denomina @e(fragil). Asi como un
    programa buggy frustra a sus usuarios, una prueba fragil exaspera a sus
    mantenedores. Las pruebas mas fragiles, que fallan por casi cualquier cambio
    en el codigo de produccion, buena o mala, a veces se denominan pruebas de
    @e(detector de cambio) o de @e(status quo), y el tiempo dedicado a tratar
    con ellos puede consumir rapidamente cualquier beneficio que una vez
    parecian ofrecer.

#     When a function under test produces a complex output such as a long string,
#     an elaborate data structure, or a file, it’s tempting to check that the
#     output is exactly equal to some @"(golden) value that was expected when the
#     test was written. But as the program evolves, parts of the output will
#     likely change, probably in good ways, but change nonetheless. And it’s not
#     just the output; functions with complex inputs often break because the input
#     used in a test is no longer valid.
    Cuando una funcion bajo prueba produce una salida compleja, como una cadena
    larga, una estructura de datos elaborada, o un archivo, es tentador
    comprobar que la salida es exactamente igual a algun valor @"(dorado) que se
    esperaba cuando se escribio la prueba. Pero a medida que el programa
    evoluciona, partes de la produccion probablemente cambian, probablemente de
    buenas forma, pero cambien sin embargo. Y no es solo la salida; Las
    funciones con entradas complejas suelen romperse porque la entrada utilizada
    en una prueba ya no es valida.

#     The easiest way to avoid brittle tests is to check only the properties you
#     care about. Test your program’s simpler and more stable interfaces in
#     preference to its internal functions. Be selective in your assertions. Don’t
#     check for exact string matches, for example, but look for relevant
#     substrings that will remain unchanged as the program evolves. It’s often
#     worth writing a substantial function to distill a complex output down to its
#     essence so that assertions will be reliable. Even though that may seem like
#     a lot of up-front effort, it can pay for itself quickly in time that would
#     otherwise be spent fixing spuriously failing tests.
    La manera mas facil de evitar las pruebas fragiles es comprobar solo las
    propiedades que le interesan. Pruebe las interfaces mas sencillas y estables
    de su programa con preferencia a sus funciones internas. Sea selectivo en
    sus afirmaciones. Por ejemplo, no compruebe si hay coincidencias exactas de
    cadenas, pero busque subsecciones relevantes que no cambien a medida que el
    programa evoluciona. A menudo vale la pena escribir una funcion sustancial
    para destilar una salida compleja hasta su esencia para que las afirmaciones
    sean confiables. A pesar de que puede parecer una gran cantidad de esfuerzo
    inicial, puede pagarse por si mismo rapidamente en el tiempo que de otro
    modo se gastaria reparando falsas pruebas de error.

# ** Section 11.3 <> Coverage
** Seccion 11.3 <> Cobertura

#    By its nature, testing is never complete. As the influential computer
#    scientist Edsger Dijkstra put it, @"(Testing shows the presence, not the
#    absence of bugs.) No quantity of tests can ever prove a package free of
#    bugs. At best, they increase our confidence that the package works well in a
#    wide range of important scenarios.
   Por su naturaleza, las pruebas nunca son completas. Como lo dijo el
   influyente cientifico informatico Edsger Dijkstra: @"(Las pruebas muestran lo
   presente, no la ausencia de errores.) Ninguna cantidad de pruebas puede
   probar que un paquete esta libre de errores. En el mejor de los casos,
   aumentan nuestra confianza en que el paquete funciona bien en una amplia gama
   de escenarios importantes.

#    The degree to which a test suite exercises the package under test is called
#    the test’s @e(coverage).  Coverage can’t be quantified directly—the dynamics
#    of all but the most trivial programs are beyond precise measurement—but there
#    are heuristics that can help us direct our testing efforts to where they are
#    more likely to be useful.
   El grado en que una suite de pruebas prueba un paquete que se denomina
   @e(cobertura) de la prueba. La cobertura no se puede cuantificar
   directamente–la dinamica de todos los programas, excepto los mas triviales,
   esta mas alla de la medicion exacta–pero hay heuristicas que pueden ayudarnos
   a dirigir nuestros esfuerzos de pruebas a donde es mas probable que sean
   utiles.

#    @e(Statement coverage) is the simplest and most widely used of these
#    heuristics. The statement coverage of a test suite is the fraction of source
#    statements that are executed at least once during the test. In this section,
#    we’ll use Go’s @$(cover) tool, which is integrated into @c(go test), to measure
#    statement coverage and help identify obvious gaps in the tests.
   La @e(cobertura de sentencias) es la mas simple y mas utilizada de estas
   heuristicas. La cobertura de sentencias de una suite de pruebas es la
   fraccion de sentencias de origen que se ejecutan al menos una vez durante la
   prueba. En esta seccion, vamos a utilizar la herramienta @$(cover) de Go, que
   esta integrada en @$(go test), para medir la cobertura de sentencias y ayudar
   a identificar lagunas evidentes en las pruebas.

#    The code below is a table-driven test for the expression evaluator we built
#    back in @l(#Chapter 7):
   El codigo siguiente es una prueba basada en tablas para el evaluador de
   expresiones que construimos en el @l(#Capitulo 7):

#    ..figure > @l(gopl.io/ch7/eval/coverage_test.go<>gopl.io/ch7/eval)
   ..figure > @l(gopl.io/ch7/eval/coverage_test.go<>gopl.io/ch7/eval)

#      ..src > go
#        func TestCoverage(t *testing.T) {
#          var tests = []struct {
#            input string
#            env   Env
#            want  string // expected error from Parse/Check or result from Eval
#          }{
#            {"x % 2", nil, "unexpected '%'"},
#            {"!true", nil, "unexpected '!'"},
#            {"log(10)", nil, `unknown function "log"`},
#            {"sqrt(1, 2)", nil, "call to sqrt has 2 args, want 1"},
#            {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},
#            {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},
#            {"5 / 9 * (F - 32)", Env{"F": -40}, "-40"},
#          }
#
#          for _, test := range tests {
#            expr, err := Parse(test.input)
#            if err == nil {
#              err = expr.Check(map[Var]bool{})
#            }
#            if err != nil {
#              if err.Error() != test.want {
#                t.Errorf("%s: got %q, want %q", test.input, err, test.want)
#              }
#              continue
#            }
#
#            got := fmt.Sprintf("%.6g", expr.Eval(test.env))
#            if got != test.want {
#              t.Errorf("%s: %v => %s, want %s",
#                test.input, test.env, got, test.want)
#            }
#          }
#        }
#      < src..
     ..src > go
       func TestCoverage(t *testing.T) {
         var tests = []struct {
           input string
           env   Env
           want  string // error esperado de Parse/Check o resultado de Eval
         }{
           {"x % 2", nil, "unexpected '%'"},
           {"!true", nil, "unexpected '!'"},
           {"log(10)", nil, `unknown function "log"`},
           {"sqrt(1, 2)", nil, "call to sqrt has 2 args, want 1"},
           {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},
           {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},
           {"5 / 9 * (F - 32)", Env{"F": -40}, "-40"},
         }

         for _, test := range tests {
           expr, err := Parse(test.input)
           if err == nil {
             err = expr.Check(map[Var]bool{})
           }
           if err != nil {
             if err.Error() != test.want {
               t.Errorf("%s: got %q, want %q", test.input, err, test.want)
             }
             continue
           }

           got := fmt.Sprintf("%.6g", expr.Eval(test.env))
           if got != test.want {
             t.Errorf("%s: %v => %s, want %s",
               test.input, test.env, got, test.want)
           }
         }
       }
     < src..


#    First, let’s check that the test passes:
   En primer lugar, vamos a comprobar que la prueba pasa:

#    ..src > sh
#      $ go test -v -run=Coverage gopl.io/ch7/eval
#      === RUN TestCoverage
#      --- PASS: TestCoverage (0.00s)
#      PASS
#      ok      gopl.io/ch7/eval    0.011s
#    < src..
   ..src > sh
     $ go test -v -run=Coverage gopl.io/ch7/eval
     === RUN TestCoverage
     --- PASS: TestCoverage (0.00s)
     PASS
     ok      gopl.io/ch7/eval    0.011s
   < src..

#    This command displays the usage message of the coverage tool:
   Este comando muestra el mensaje de uso de la herramienta de cobertura:

#    ..src > sh
#      $ go tool cover
#      Usage of 'go tool cover':
#      Given a coverage profile produced by 'go test':
#          go test -coverprofile=c.out
#      Open a web browser displaying annotated source code:
#          go tool cover -html=c.out
#    < src..
   ..src > sh
     $ go tool cover
     Usage of 'go tool cover':
     Given a coverage profile produced by 'go test':
         go test -coverprofile=c.out
     Open a web browser displaying annotated source code:
         go tool cover -html=c.out
   < src..

#    The @$(go tool) command runs one of the executables from the Go
#    toolchain. These programs live in the directory
#    @c($GOROOT/pkg/tool/${GOOS}_${GOARCH}). Thanks to @$(go build), we rarely
#    need to invoke them directly.
   El comando go tool ejecuta uno de los ejecutables de la cadena de
   herramientas Go. Estos programas viven en el directorio
   @c($GOROOT/pkg/tool/${GOOS}_${GOARCH}). Gracias a @$(go build), rara vez es
   necesario invocarlo directamente.

#    Now we run the test with the @c(-coverprofile) flag:
   Ahora corremos la prueba con la bandera @c(-coverprofile):

#    ..src > sh
#      $ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval
#      ok      gopl.io/ch7/eval    0.032s  coverage: 68.5% of statements
#    < src..
   ..src > sh
     $ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval
     ok      gopl.io/ch7/eval    0.032s  coverage: 68.5% of statements
   < src..

#    This flag enables the collection of coverage data by @e(instrumenting) the
#    production code. That is, it modifies a copy of the source code so that
#    before each block of statements is executed, a boolean variable is set, with
#    one variable per block. Just before the modified program exits, it writes the
#    value of each variable to the specified log file @f(c.out) and prints a
#    summary of the fraction of statements that were executed. (If all you need is
#    the summary, use @$(go test -cover).)
   Este indicador permite la recopilacion de datos de cobertura
   @e(instrumentando) el codigo de produccion. Es decir, modifica una copia del
   codigo fuente para que, antes de ejecutar cada bloque de sentencias, se
   establezca una variable booleana, con una variable por bloque. Justo antes de
   salir del programa modificado, se escribe el valor de cada variable en el
   archivo de registro especificado @f(c.out) e imprime un resumen de la
   fraccion de declaraciones que fueron ejecutados. (Si todo lo que necesita es
   el resumen, utilice @$(go test -cover).)

#    If @$(go test) is run with the @c(-covermode=count) flag, the instrumentation
#    for each block increments a counter instead of setting a boolean. The
#    resulting log of execution counts of each block enables quantitative
#    comparisons between @"(hotter) blocks, which are more frequently executed,
#    and @"(colder) ones.
   Si @$(go test) se ejecuta con la bandera @c(-covermode=count), la
   instrumentacion para cada bloque incrementa un contador en lugar de
   establecer un valor booleano. El registro resultante del recuento de
   ejecucion de cada bloque permite comparaciones cuantitativas entre los
   bloques mas @"(calientes), que se ejecutan con mayor frecuencia, y los mas
   @"(frios).

#    Having gathered the data, we run the @$(cover) tool, which processes the log,
#    generates an HTML report, and opens it in a new browser window (Figure 11.3).
   Despues de haber reunido los datos, corremos la herramienta @$(cover), que
   procesa el registro, genera un informe HTML, y lo abre en una nueva ventana
   del navegador (Figura 11.3).

#    ..src > sh
#      $ go tool cover -html=c.out
#    < src..
   ..src > sh
     $ go tool cover -html=c.out
   < src..

#    ..figure > Figure 11.3. A coverage report.
   ..figure > Figura 11.3. Un informe de cobertura.

#      ..img  > img/Figure-11.3.jpg
     ..img  > img/Figure-11.3.jpg

#    Each statement is colored green if it was covered or red if it was not
#    covered. For clarity, we’ve shaded the background of the red text. We can see
#    immediately that none of our inputs exercised the unary operator @c(Eval)
#    method. If we add this new test case to the table and re-run the previous two
#    commands, the unary expression code becomes green:
   Cada declaracion es de color verde si estaba cubierta o rojo si no. Para
   mayor claridad, hemos sombreado el fondo del texto rojo. Podemos ver
   inmediatamente que ninguna de nuestras entradas prueba el operador unario del
   metodo @c(Eval). Si agregamos este nuevo caso de prueba a la tabla y volvemos
   a ejecutar los dos comandos anteriores, el codigo de expresion unario se
   convierte en verde:

#    ..src > go
#      {"-x * -x", eval.Env{"x": 2}, "4"}
#    < src..
   ..src > go
     {"-x * -x", eval.Env{"x": 2}, "4"}
   < src..

#    The two @c(panic) statements remain red, however. This should not be
#    surprising, because these statements are supposed to be unreachable.
   Sin embargo, las dos declaraciones @c(panic) permanecen de color rojo. Esto
   no debe ser sorprendente, porque se supone que estas declaraciones son
   inaccesibles.

#    Achieving 100% statement coverage sounds like a noble goal, but it is not
#    usually feasible in practice, nor is it likely to be a good use of
#    effort. Just because a statement is executed does not mean it is bug-free;
#    statements containing complex expressions must be executed many times with
#    different inputs to cover the interesting cases. Some statements, like the
#    @c(panic) statements above, can never be reached. Others, such as those that
#    handle esoteric errors, are hard to exercise but rarely reached in
#    practice. Testing is fundamentally a pragmatic endeavor, a trade-off between
#    the cost of writing tests and the cost of failures that could have been
#    prevented by tests. Coverage tools can help identify the weakest spots, but
#    devising good test cases demands the same rigorous thinking as programming in
#    general.
   Alcanzar una cobertura del 100% de la declaracion suena como un objetivo
   noble, pero generalmente no es factible en la practica, ni es probable que
   sea un buen uso del esfuerzo. El hecho de que se ejecute una sentencia no
   significa que este libre de errores; Las declaraciones que contienen
   expresiones complejas se deben ejecutar muchas veces con entradas diferentes
   para cubrir los casos interesantes. Algunos estados, como las declaraciones
   @c(panic) anteriores, no pueden ser alcanzados. Otros, como los que manejan
   errores esotericos, son dificiles de probar pero raramente alcanzados en la
   practica. Las pruebas son fundamentalmente un esfuerzo pragmatico, un
   equilibrio entre el costo de escritura de las pruebas y el costo de los
   fallos que podrian haber sido evitados por las pruebas. Las herramientas de
   cobertura pueden ayudar a identificar los puntos mas debiles, pero idear
   buenos casos de prueba requiere el mismo pensamiento riguroso que la
   programacion en general.

# ** Section 11.4 <> @c(Benchmark) Functions
** Seccion 11.4 <> Funciones @c(Benchmark)

#    Benchmarking is the practice of measuring the performance of a program on a
#    fixed workload. In Go, a benchmark function looks like a test function, but
#    with the @c(Benchmark) prefix and a @c(*testing.B) parameter that provides
#    most of the same methods as a @c(*testing.T), plus a few extra related to
#    performance measurement. It also exposes an integer field @c(N), which
#    specifies the number of times to perform the operation being measured.
   Benchmarking es la practica de medir el rendimiento de un programa con una
   carga de trabajo fija. En Go, una funcion de referencia se parece a una
   funcion de prueba, pero con el prefijo @c(Benchmark) y un parametro
   @c(*testing.B) que proporciona la mayor parte de los mismos metodos que un
   @c(*testing.T), ademas algunos adicionales relacionados con la medicion del
   desempeño. Tambien expone un campo entero @c(N), que especifica el numero de
   veces que se realizara la operacion que se esta midiendo.

#    Here’s a benchmark for @c(IsPalindrome) that calls it @c(N) times in a loop.
   Aqui tenemos el benchmark para @c(IsPalindrome) que llama @c(N) veces en un
   bucle.

#    ..src > go
#      import "testing"
#      func BenchmarkIsPalindrome(b *testing.B) {
#        for i := 0; i < b.N; i++ {
#          IsPalindrome("A man, a plan, a canal: Panama")
#        }
#      }
#    < src..
   ..src > go
     import "testing"
     func BenchmarkIsPalindrome(b *testing.B) {
       for i := 0; i < b.N; i++ {
         IsPalindrome("A man, a plan, a canal: Panama")
       }
     }
   < src..

#    We run it with the command below. Unlike tests, by default no benchmarks are
#    run. The argument to the @c(-bench) flag selects which benchmarks to run. It
#    is a regular expression matching the names of @c(Benchmark) functions, with a
#    default value that matches none of them.  The @"(@c(.)) pattern causes it to
#    match all benchmarks in the @c(word) package, but since there’s only one,
#    @c(-bench=IsPalindrome) would have been equivalent.
   Lo ejecutamos con el siguiente comando. A diferencia de las pruebas, los
   benchmarks por defecto no se ejecutan. El argumento @c(-bench) selecciona que
   deben ejecutarso los benchmark. Es una expresion regular que coincide con los
   nombres de las funciones @c(Benchmark), con un valor predeterminado que no
   coincide con ninguno de ellos. El patron @"(@c(.)) hace que coincida con
   todos los benchmark en el paquete @c(word), pero ya que solo hay una,
   @c(-bench=IsPalindrome) habria sido equivalente.

#    ..src > sh
#      $ cd $GOPATH/src/gopl.io/ch11/word2
#      $ go test -bench=.
#      PASS
#      BenchmarkIsPalindrome-8 1000000               1035 ns/op
#      ok      gopl.io/ch11/word2      2.179s
#    < src..
   ..src > sh
     $ cd $GOPATH/src/gopl.io/ch11/word2
     $ go test -bench=.
     PASS
     BenchmarkIsPalindrome-8 1000000               1035 ns/op
     ok      gopl.io/ch11/word2      2.179s
   < src..

#    The benchmark name’s numeric suffix, @c(8) here, indicates the value of
#    @c(GOMAXPROCS), which is important for concurrent benchmarks.
   El Sufijo numerico de benchmark, @c(8) aqui, indica el valor de
   @c(GOMAXPROCS), lo cual es importante para los benchmark concurrentes.

#    The report tells us that each call to @c(IsPalindrome) took about 1.035
#    microseconds, averaged over 1,000,000 runs. Since the benchmark runner
#    initially has no idea how long the operation takes, it makes some initial
#    measurements using small values of @c(N) and then extrapolates to a value
#    large enough for a stable timing measurement to be made.
   El informe nos dice que cada llamada a @c(IsPalindrome) tomo cerca de 1.035
   microsegundos, un promedio de mas de 1.000.000 ejecuciones. Puesto que el
   corredor referencia inicialmente no tiene idea de cuanto tiempo dura la
   operacion, realiza algunas mediciones iniciales utilizando valores pequeños
   de @c(N) y luego extrapola hasta un valor lo suficientemente grande para
   realizar una medicion de temporizacion estable.

#    The reason the loop is implemented by the benchmark function, and not by the
#    calling code in the test driver, is so that the benchmark function has the
#    opportunity to execute any necessary one-time setup code outside the loop
#    without this adding to the measured time of each iteration. If this setup
#    code is still perturbing the results, the @c(testing.B) parameter provides
#    methods to stop, resume, and reset the timer, but these are rarely needed.
   La razon por la que el bucle se implementa por la funcion benchmark, y no por
   el codigo de llamada en el controlador de prueba, es para que la funcion de
   referencia tenga la oportunidad de ejecutar cualquier codigo de configuracion
   de una sola vez fuera del bucle sin que esto se añada al tiempo medido de
   cada iteracion. Si este codigo de configuracion sigue perturbando los
   resultados, el parametro @c(testing.B) proporciona metodos para detener,
   reanudar y reiniciar el temporizador, pero estos rara vez son necesarios.

#    Now that we have a benchmark and tests, it’s easy to try out ideas for making
#    the program faster. Perhaps the most obvious optimization is to make
#    @c(IsPalindrome)’s second loop stop checking at the midpoint, to avoid doing
#    each comparison twice:
   Ahora que tenemos un punto de referencia y pruebas, es facil probar ideas
   para hacer el programa mas rapido. Quizas la optimizacion mas abvia es hacer
   el el bucle de @c(IsPalindrome) detenga la verificacion en el punto medio,
   para evitar hacer cada comparacion dos veces:

#    ..src > go
#      n := len(letters)/2
#      for i := 0; i < n; i++ {
#        if letters[i] != letters[len(letters)-1-i] {
#          return false
#        }
#      }
#      return true
#    < src..
   ..src > go
     n := len(letters)/2
     for i := 0; i < n; i++ {
       if letters[i] != letters[len(letters)-1-i] {
         return false
       }
     }
     return true
   < src..

#    But as is often the case, an obvious optimization doesn’t always yield the
#    expected benefit.  This one delivered a mere 4% improvement in one
#    experiment.
   Pero como suele ser el caso, una optimizacion obvia no siempre da el
   beneficio esperado. Este proporciono una mera mejora del 4% en un
   experimento.

#    ..src > sh
#      $ go test -bench=.
#      PASS
#      BenchmarkIsPalindrome-8 1000000                992 ns/op
#      ok      gopl.io/ch11/word2      2.093s
#    < src..
   ..src > sh
     $ go test -bench=.
     PASS
     BenchmarkIsPalindrome-8 1000000                992 ns/op
     ok      gopl.io/ch11/word2      2.093s
   < src..

#    Another idea is to pre-allocate a sufficiently large array for use by
#    @c(letters), rather than expand it by successive calls to
#    @c(append). Declaring @c(letters) as an array of the right size, like this,
   Otra idea es asignar previamente una gama suficientemente amplia para su uso
   por @c(letters), en lugar de expandirlo mediante llamadas sucesivas a append.
   Declaramos @c(letters) como un arreglo del tamaño adecuado, de esta manera,

#    ..src > go
#      letters := make([]rune, 0, len(s))
#      for _, r := range s {
#        if unicode.IsLetter(r) {
#          letters = append(letters, unicode.ToLower(r))
#        }
#      }
#    < src..
   ..src > go
     letters := make([]rune, 0, len(s))
     for _, r := range s {
       if unicode.IsLetter(r) {
         letters = append(letters, unicode.ToLower(r))
       }
     }
   < src..

#    yields an improvement of nearly 35%, and the benchmark runner now reports the
#    average over 2,000,000 iterations.
   Produce una mejora de casi 35%, y el marcador del benchmark ahora informa el
   promedio de mas de 2.000.000 de iteraciones.

#    ..src > sh
#      $ go test -bench=.
#      PASS
#      BenchmarkIsPalindrome-8 2000000                697 ns/op
#      ok      gopl.io/ch11/word2      1.468s
#    < src..
   ..src > sh
     $ go test -bench=.
     PASS
     BenchmarkIsPalindrome-8 2000000                697 ns/op
     ok      gopl.io/ch11/word2      1.468s
   < src..

#    As this example shows, the fastest program is often the one that makes the
#    fewest memory allocations. The @c(-benchmem) command-line flag will include
#    memory allocation statistics in its report. Here we compare the number of
#    allocations before the optimization:
   Como muestra este ejemplo, el programa mas rapido es a menudo el que hace
   menos asignaciones de memoria. La bandera @c(-benchmem) de linea de comandos,
   incluira estadisticas de asignacion de memoria en su informe. Aqui comparamos
   el numero de asignaciones antes de la optimizacion:

#    ..src > sh
#      $ go test -bench=. -benchmem
#      PASS
#      BenchmarkIsPalindrome    1000000  1026 ns/op    304 B/op  4 allocs/op
#    < src..
   ..src > sh
     $ go test -bench=. -benchmem
     PASS
     BenchmarkIsPalindrome    1000000  1026 ns/op    304 B/op  4 allocs/op
   < src..

#    and after it:
   Y despues de ella:

#    ..src > sh
#      $ go test -bench=. -benchmem
#      PASS
#      BenchmarkIsPalindrome    2000000   807 ns/op    128 B/op  1 allocs/op
#    < src..
   ..src > sh
     $ go test -bench=. -benchmem
     PASS
     BenchmarkIsPalindrome    2000000   807 ns/op    128 B/op  1 allocs/op
   < src..

#    Consolidating the allocations in a single call to @c(make) eliminated 75% of
#    the allocations and halved the quantity of allocated memory.
   La consolidacion de las asignaciones en una sola llamada a make eliminado el
   75% de las asignaciones y reduce a la mitad la cantidad de memoria asignada.

#    Benchmarks like this tell us the absolute time required for a given
#    operation, but in many settings the interesting performance questions are
#    about the @e(relative) timings of two different operations. For example, if a
#    function takes 1ms to process 1,000 elements, how long will it take to
#    process 10,000 or a million? Such comparisons reveal the asymptotic growth of
#    the running time of the function. Another example: what is the best size for
#    an I/O buffer?  Benchmarks of application throughput over a range of sizes
#    can help us choose the smallest buffer that delivers satisfactory
#    performance. A third example: which algorithm performs best for a given job?
#    Benchmarks that evaluate two different algorithms on the same input data can
#    often show the strengths and weaknesses of each one on important or
#    representative workloads.
   Los benchmark de este tipo nos dicen que el tiempo absoluto requerido para
   una operacion dada, pero en muchas configuraciones las preguntas de desempeño
   interesantes estan en los tiempos @e(relativos) de dos operaciones
   diferentes. Por ejemplo, si una funcion toma 1ms para procesar 1,000
   elementos, ¿cuanto tiempo tardara en procesar 10,000 o un millon? Tales
   comparaciones revelan el crecimiento asintotico del tiempo de funcionamiento
   de la funcion. Otro ejemplo: ¿cual es el mejor tamaño para un bufer de E/S?
   Los benchmarks del rendimiento de la aplicacion en un rango de tamaños pueden
   ayudarnos a elegir el buffer mas pequeño que ofrece un rendimiento
   satisfactorio. Un tercer ejemplo: ¿cual algoritmo funciona mejor para un
   trabajo determinado? Los benchmark que evaluan dos algoritmos diferentes en
   los mismos datos de entrada a menudo pueden mostrar las fortalezas y
   debilidades de cada uno en cargas de trabajo importantes o representativas.

#    Comparative benchmarks are just regular code. They typically take the form of
#    a single parameterized function, called from several @c(Benchmark) functions
#    with different values, like this:
   Los benchmarks comparativos son solo codigo regular. Por lo general toman la
   forma de una sola funcion parametrizada, llamada de varias funciones
   @c(Benchmark) con diferentes valores, como esto:

#    ..src > go
#      func benchmark(b *testing.B, size int) { /* ... */ }
#      func Benchmark10(b *testing.B)   { benchmark(b,   10) }
#      func Benchmark100(b *testing.B)  { benchmark(b,  100) }
#      func Benchmark1000(b *testing.B) { benchmark(b, 1000) }
#    < src..
   ..src > go
     func benchmark(b *testing.B, size int) { /* ... */ }
     func Benchmark10(b *testing.B)   { benchmark(b,   10) }
     func Benchmark100(b *testing.B)  { benchmark(b,  100) }
     func Benchmark1000(b *testing.B) { benchmark(b, 1000) }
   < src..

#    The parameter @c(size), which specifies the size of the input, varies across
#    benchmarks but is constant within each benchmark. Resist the temptation to
#    use the parameter @c(b.N) as the input size. Unless you interpret it as an
#    iteration count for a fixed-size input, the results of your benchmark will be
#    meaningless.
   El parametro de @c(size), que especifica el tamaño de la entrada, varia a
   traves de los benchmark, pero es constante dentro de cada punto de
   referencia. Resista la tentacion de utilizar el parametro @c(b.N) como el
   tamaño de entrada. A menos que lo interprete como un recuento de iteracion
   para una entrada de tamaño fijo, los resultados de su benchmark no tendran
   sentido.

#    Patterns revealed by comparative benchmarks are particularly useful during
#    program design, but we don’t throw the benchmarks away when the program is
#    working. As the program evolves, or its input grows, or it is deployed on new
#    operating systems or processors with different characteristics, we can reuse
#    those benchmarks to revisit design decisions.
   Los patrones revelados por los benchmark comparativos son particularmente
   utiles durante el diseño del programa, pero no arrojamos los benchmark cuando
   el programa esta funcionando. A medida que el programa evoluciona, o su
   entrada crece, o se despliega en nuevos sistemas operativos o procesadores
   con caracteristicas diferentes, podemos reutilizar esos benchmark para
   revisar las decisiones de diseño.

#    @b(Exercise 11.6): Write benchmarks to compare the @c(PopCount)
#    implementation in @l(#Section 2.6.2) with your solutions to Exercise 2.4 and
#    Exercise 2.5. At what point does the table-based approach break even?
   @b(Ejercicio 11.6): Escribir benchmark para comparar la implementacion
   @c(PopCount) en la @l(#Seccion 2.6.2) con sus soluciones al Ejercicio 2.4 y
   Ejercicio 2.5. ¿En que punto el enfoque basado en tablas se equilibra?

#    @b(Exercise 11.7): Write benchmarks for @c(Add), @c(UnionWith), and other
#    methods of @c(*IntSet) (@l(#Section 6.5<>§6.5)) using large pseudo-random
#    inputs. How fast can you make these methods run? How does the choice of word
#    size affect performance? How fast is @c(IntSet) compared to a set
#    implementation based on the built-in map type?
   @b(Ejercicio 11.7): Escribir benchmark para @c(Add), @c(UnionWith), y otros
   metodos de @c(*IntSet) (@l(#Seccion 6.5)) utilizando grandes entradas
   pseudoaleatorias. ¿Que tan rapido puede hacer que estos metodos se ejecuten?
   ¿Como afecta la eleccion del tamaño de la palabra al rendimiento? ¿Que tan
   rapido es @c(IntSet) en comparacion con una implementacion de conjunto basado
   en el tipo integrado de mapa?

# ** Section 11.5 <> Profiling
** Seccion 11.5 <> Perfilado

#    Benchmarks are useful for measuring the performance of specific operations,
#    but when we’re trying to make a slow program faster, we often have no idea
#    where to begin. Every programmer knows Donald Knuth’s aphorism about
#    premature optimization, which appeared in @"(Structured Programming with go to
#    Statements) in 1974. Although often misinterpreted to mean performance
#    doesn’t matter, in its original context we can discern a different meaning:
   Los benchmark son utiles para medir el rendimiento de operaciones
   especificas, pero cuando estamos tratando de hacer un programa lento mas
   rapido, a menudo no tenemos idea por donde empezar. Todo programador conoce
   el aforismo de Donald Knuth acerca de la optimizacion prematura, que aparecio
   en @"(Structured Programming with go to Statements) en 1974. Aunque a menudo
   mal interpretado en el sentido de rendimiento, no importa, en su contexto
   original, podemos discernir un significado diferente:

#    ..quote >
   ..quote >
#      There is no doubt that the grail of efficiency leads to abuse. Programmers
#      waste enormous amounts of time thinking about, or worrying about, the speed
#      of noncritical parts of their programs, and these attempts at efficiency
#      actually have a strong negative impact when debugging and maintenance are
#      considered. We @e(should) forget about small efficiencies, say about 97% of
#      the time: premature optimization is the root of all evil.
     No hay duda de que el grial de la eficiencia conduce al abuso. Los
     programadores pierden enormes cantidades de tiempo pensando o preocupandose
     por la velocidad de las partes no criticas de sus programas, y estos
     intentos de eficiencia realmente tienen un fuerte impacto negativo cuando
     se consideran la depuracion y el mantenimiento. @e(Debemos) olvidarnos de
     las pequeñas eficiencias, digamos alrededor del 97% del tiempo: la
     optimizacion prematura es la raiz de todo mal.

#      Yet we should not pass up our opportunities in that critical 3%. A good
#      programmer will not be lulled into complacency by such reasoning, he will
#      be wise to look carefully at the critical code; but only @e(after) that code
#      has been identified. It is often a mistake to make a priori judgments about
#      what parts of a program are really critical, since the universal experience
#      of programmers who have been using measurement tools has been that their
#      intuitive guesses fail.
     Sin embargo, no debemos dejar pasar nuestras oportunidades en ese critico
     3%. Un buen programador no se engañara en complacencia por tal
     razonamiento, el sera sabio mirando cuidadosamente el codigo critico; Pero
     solo @e(despues) de que el codigo se ha identificado. A menudo es un error
     hacer juicios a priori sobre que partes de un programa son realmente
     criticos, ya que la experiencia universal de los programadores que han
     estado utilizando herramientas de medicion ha sido que sus suposiciones
     intuitivas fallan.
#    < quote..
   < quote..

#    When we wish to look carefully at the speed of our programs, the best
#    technique for identifying the critical code is @e(profiling). Profiling is an
#    automated approach to performance measurement based on sampling a number of
#    profile @e(events) during execution, then extrapolating from them during a
#    post-processing step; the resulting statistical summary is called a
#    @e(profile).
   Cuando deseamos prestar atencion a la velocidad de nuestros programas, la
   mejor tecnica para identificar el codigo critico es el @e(perfilado). El
   perfilado es un enfoque automatizado para la medicion del rendimiento basado
   en el muestreo de un numero de @e(eventos) de perfil durante la ejecucion,
   extrapolando luego de ellos durante una etapa de post-procesamiento; el
   resumen estadistico resultante se llama un @e(perfil).

#    Go supports many kinds of profiling, each concerned with a different aspect
#    of performance, but all of them involve recording a sequence of events of
#    interest, each of which has an accompanying stack trace—the stack of function
#    calls active at the moment of the event. The @$(go test) tool has built-in
#    support for several kinds of profiling.
   Go soporta muchos tipos de perfiles, cada uno de ellos relacionado con un
   aspecto diferente del rendimiento, pero todos ellos implican grabar una
   secuencia de eventos de interes, cada uno de los cuales tiene un seguimiento
   de pila que acompaña–la pila de llamadas de funcion activas en el momento del
   evento. La herramienta @$(go test) tiene soporte integrado para varios tipos
   de perfiles.

#    A @e(CPU profile) identifies the functions whose execution requires the most
#    CPU time. The currently running thread on each CPU is interrupted
#    periodically by the operating system every few milliseconds, with each
#    interruption recording one profile event before normal execution resumes.
   Un @e(perfil de CPU) identifica las funciones cuya ejecucion requiere mas
   tiempo de CPU. El subproceso actualmente en ejecucion en cada CPU es
   interrumpido periodicamente por el sistema operativo cada pocos milisegundos,
   con cada interrupcion registrando un evento de perfil antes de que se reanude
   la ejecucion normal.

#    A @e(heap profile) identifies the statements responsible for allocating the
#    most memory. The profiling library samples calls to the internal memory
#    allocation routines so that on average, one profile event is recorded per
#    512KB of allocated memory.
   Un @e(perfil de monticulo) identifica las declaraciones responsables de la
   asignacion de la mayoria de la memoria. La libreria de perfiles muestrea las
   llamadas a las rutinas de asignacion de memoria interna de manera que, en
   promedio, se registra un evento de perfil por cada 512 KB de memoria
   asignada.

#    A @e(blocking profile) identifies the operations responsible for blocking
#    goroutines the longest, such as system calls, channel sends and receives, and
#    acquisitions of locks. The profiling library records an event every time a
#    goroutine is blocked by one of these operations.
   Un @e(perfil de bloqueo) identifica las operaciones responsable del bloqueo
   de las gorutinas mas largas, como las llamadas al sistema, envio y recepcion
   de canales, y adquisiciones de bloqueos. La libreria de perfilado registra un
   evento cada vez que una gorutina es bloqueada por una de estas operaciones.

#    Gathering a profile for code under test is as easy as enabling one of the
#    flags below. Be careful when using more than one flag at a time, however: the
#    machinery for gathering one kind of profile may skew the results of others.
   Recopilar un perfil para el codigo bajo prueba es tan facil como habilitar
   uno de los indicadores a continuacion. Tenga cuidado al usar mas de una
   bandera a la vez, sin embargo: la maquinaria para recoger un tipo de perfil
   puede sesgar los resultados de otros.

#    ..src > sh
#      $ go test -cpuprofile=cpu.out
#      $ go test -blockprofile=block.out
#      $ go test -memprofile=mem.out
#    < src..
   ..src > sh
     $ go test -cpuprofile=cpu.out
     $ go test -blockprofile=block.out
     $ go test -memprofile=mem.out
   < src..

#    It’s easy to add profiling support to non-test programs too, though the
#    details of how we do that vary between short-lived command-line tools and
#    long-running server applications. Profiling is especially useful in
#    long-running applications, so the Go runtime’s profiling features can be
#    enabled under programmer control using the @c(runtime) API.
   Es facil agregar soporte de perfilado a programas que no son de prueba,
   aunque los detalles de como lo hacemos varian entre las herramientas de linea
   de comandos de corta duracion y las aplicaciones de servidor de larga
   ejecucion. El perfilado es especialmente util en aplicaciones de larga
   duracion, por lo que las caracteristicas de generacion de perfiles en tiempo
   de ejecucion de Go pueden habilitarse bajo el control del programador
   utilizando la API @c(runtime).

#    Once we’ve gathered a profile, we need to analyze it using the @$(pprof)
#    tool. This is a standard part of the Go distribution, but since it’s not an
#    everyday tool, it’s accessed indirectly using @$(go tool pprof). It has
#    dozens of features and options, but basic use requires only two arguments,
#    the executable that produced the profile and the profile log.
   Una vez que hemos reunido un perfil, es necesario analizar usando la
   herramienta @$(pprof). Esta es una parte estandar de la distribucion Go, pero
   ya que no es una herramienta de uso diario, se accede indirectamente usando
   @$(go tool pprof). Tiene docenas de caracteristicas y opciones, pero el uso
   basico requiere solo dos argumentos, el ejecutable que produjo el perfil y el
   registro del perfil.

#    To make profiling efficient and to save space, the log does not include
#    function names; instead, functions are identified by their addresses. This
#    means that @$(pprof) needs the executable in order to make sense of the
#    log. Although @$(go test) usually discards the test executable once the test
#    is complete, when profiling is enabled it saves the executable as
#    @f(foo.test), where @c(foo) is the name of the tested package.
   Para que el perfil sea eficiente y para ahorrar espacio, el registro no
   incluye nombres de funciones; En su lugar, las funciones se identifican por
   sus direcciones. Esto significa que @$(pprof) necesita el ejecutable para que
   el registro tenga sentido. Aunque @$(go test) generalmente descarta el
   ejecutable de prueba una vez finalizada la prueba, cuando el perfilado se
   habilita guarda el archivo ejecutable como @f(Foo.test), donde @c(foo) es el
   nombre del paquete de prueba.

#    The commands below show how to gather and display a simple CPU profile. We’ve
#    selected one of the benchmarks from the @c(net/http) package. It is usually
#    better to profile specific benchmarks that have been constructed to be
#    representative of workloads one cares about.  Benchmarking test cases is
#    almost never representative, which is why we disabled them by using the
#    filter @c(-run=NONE).
   Los siguientes comandos muestran como recopilar y mostrar un perfil de CPU
   simple. Hemos seleccionado uno de los benchmark del @c(net/http). Por lo
   general, es mejor hacer un perfil de benchmark especificos que se han
   construido para ser representativos de las cargas de trabajo que a uno le
   preocupan. En los benchmark los casos de prueba casi nunca son
   representativos, es por ello que las desactivo mediante el filtro
   @c(-run=NONE).

#    ..src > sh
#      $ go test -run=NONE -bench=ClientServerParallelTLS64 \
#          -cpuprofile=cpu.log net/http
#      PASS
#      BenchmarkClientServerParallelTLS64-8 1000
#         3141325 ns/op  143010 B/op  1747 allocs/op
#      ok      net/http       3.395s
#
#      $ go tool pprof -text -nodecount=10 ./http.test cpu.log
#      2570ms of 3590ms total (71.59%)
#      Dropped 129 nodes (cum <= 17.95ms)
#      Showing top 10 nodes out of 166 (cum >= 60ms)
#      flat    flat%   sum%     cum   cum%
#      1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree
#      230ms 6.41%   54.60%   250ms  6.96%  crypto/elliptic.p256Diff
#      120ms 3.34%   57.94%   120ms  3.34%  math/big.addMulVVW
#      110ms 3.06%   61.00%   110ms  3.06%  syscall.Syscall
#       90ms 2.51%   63.51%  1130ms 31.48%  crypto/elliptic.p256Square
#       70ms 1.95%   65.46%   120ms  3.34%  runtime.scanobject
#       60ms 1.67%   67.13%   830ms 23.12%  crypto/elliptic.p256Mul
#       60ms 1.67%   68.80%   190ms  5.29%  math/big.nat.montgomery
#       50ms 1.39%   70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry
#       50ms 1.39%   71.59%    60ms  1.67%  crypto/elliptic.p256Sum
#    < src..
   ..src > sh
     $ go test -run=NONE -bench=ClientServerParallelTLS64 \
         -cpuprofile=cpu.log net/http
     PASS
     BenchmarkClientServerParallelTLS64-8 1000
        3141325 ns/op  143010 B/op  1747 allocs/op
     ok      net/http       3.395s

     $ go tool pprof -text -nodecount=10 ./http.test cpu.log
     2570ms of 3590ms total (71.59%)
     Dropped 129 nodes (cum <= 17.95ms)
     Showing top 10 nodes out of 166 (cum >= 60ms)
     flat    flat%   sum%     cum   cum%
     1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree
     230ms 6.41%   54.60%   250ms  6.96%  crypto/elliptic.p256Diff
     120ms 3.34%   57.94%   120ms  3.34%  math/big.addMulVVW
     110ms 3.06%   61.00%   110ms  3.06%  syscall.Syscall
      90ms 2.51%   63.51%  1130ms 31.48%  crypto/elliptic.p256Square
      70ms 1.95%   65.46%   120ms  3.34%  runtime.scanobject
      60ms 1.67%   67.13%   830ms 23.12%  crypto/elliptic.p256Mul
      60ms 1.67%   68.80%   190ms  5.29%  math/big.nat.montgomery
      50ms 1.39%   70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry
      50ms 1.39%   71.59%    60ms  1.67%  crypto/elliptic.p256Sum
   < src..

#    The @c(-text) flag specifies the output format, in this case, a textual table
#    with one row per function, sorted so the @"(hottest) functions—those that
#    consume the most CPU cycles—appear first. The @c(-nodecount=10) flag limits
#    the result to 10 rows. For gross performance problems, this textual format
#    may be enough to pinpoint the cause.
   La bandera @c(-text) especifica el formato de salida, en este caso, una tabla
   textual con una fila por cada funcion, ordenada para que las funciones @"(mas
   activas)–Las que consumen mas ciclos de CPU–aparecescan primero. La bandera
   @c(-nodecount=10) limita el resultado a 10 filas. Para los problemas de
   rendimiento bruto, este formato textual puede ser suficiente para identificar
   la causa.

#    This profile tells us that elliptic-curve cryptography is important to the
#    performance of this particular HTTPS benchmark. By contrast, if a profile is
#    dominated by memory allocation functions from the @c(runtime) package, reducing
#    memory consumption may be a worthwhile optimization.
   Este perfil nos dice que la criptografia de curva eliptica es importante para
   el rendimiento de este benchmark HTTPS en particular. Por el contrario, si un
   perfil esta dominado por funciones de asignacion de memoria desde el paquete
   @c(runtime), reducir el consumo de memoria puede ser una optimizacion que
   vale la pena.

#    For more subtle problems, you may be better off using one of @$(pprof)’s
#    graphical displays. These require GraphViz, which can be downloaded from
#    @l(www.graphviz.org). The @c(-web) flag then renders a directed graph of the
#    functions of the program, annotated by their CPU profile numbers and colored
#    to indicate the hottest functions.
   Para problemas mas sutiles, puede ser mejor usar una de las pantallas
   graficas de @$(pprof). Estas requieren GraphViz, que se puede descargar desde
   @l(www.graphviz.org). La bandera @c(-web) entonces crea un grafico dirigido
   de las funciones del programa, anotadas por sus numeros de perfil de la CPU y
   de colores para indicar las funciones mas calientes.

#    We’ve only scratched the surface of Go’s profiling tools here. To find out
#    more, read the @"(Profiling Go Programs) article on the Go Blog.
   Solo hemos arañado la superficie de las herramientas de perfilado de Go. Para
   obtener mas informacion, lea el articulo @"(Profiling Go Programs) en el Blog
   de Go.

# ** Section 11.6 <> @c(Example) Functions
** Seccion 11.6 <> Funciones @c(Example)

#    The third kind of function treated specially by @$(go test) is an example
#    function, one whose name starts with @c(Example). It has neither parameters nor
#    results. Here’s an example function for @$(IsPalindrome):
   El tercer tipo de funcion tratada especialmente por @$(go test) es una
   funcion de ejemplo, uno cuyo nombre empieza con @c(Example). No tiene
   parametros ni resultados. Aqui un ejemplo para la funcion @c(IsPalindrome):

#    ..src > go
#      func ExampleIsPalindrome() {
#        fmt.Println(IsPalindrome("A man, a plan, a canal: Panama"))
#        fmt.Println(IsPalindrome("palindrome"))
#        // Output:
#        // true
#        // false
#      }
#    < src..
   ..src > go
     func ExampleIsPalindrome() {
       fmt.Println(IsPalindrome("A man, a plan, a canal: Panama"))
       fmt.Println(IsPalindrome("palindrome"))
       // Output:
       // true
       // false
     }
   < src..

#    Example functions serve three purposes. The primary one is documentation: a
#    good example can be a more succinct or intuitive way to convey the behavior
#    of a library function than its prose description, especially when used as a
#    reminder or quick reference. An example can also demonstrate the interaction
#    between several types and functions belonging to one API, whereas prose
#    documentation must always be attached to one place, like a type or function
#    declaration or the package as a whole. And unlike examples within comments,
#    example functions are real Go code, subject to compile-time checking, so they
#    don’t become stale as the code evolves.
   Las funciones de ejemplo sirven para tres propositos. El principal es la
   documentacion: un buen ejemplo puede ser una forma mas sucinta o intuitiva de
   transmitir el comportamiento de una funcion de libreria, que su descripcion
   en prosa, especialmente cuando se usa como recordatorio o referencia
   rapida. Un ejemplo tambien puede demostrar la interaccion entre varios tipos
   y funciones pertenecientes a una API, mientras que la documentacion en prosa
   siempre debe estar unida a un lugar, como una declaracion de tipo o funcion o
   el paquete en su conjunto. Y a diferencia de los ejemplos dentro de los
   comentarios, las funciones de ejemplo son codigo Go real, sujeto a
   comprobacion en tiempo de compilacion, para que no se vuelvan obsoletos a
   medida que el codigo evoluciona.

#    Based on the suffix of the @c(Example) function, the web-based documentation
#    server @$(godoc) associates example functions with the function or package
#    they exemplify, so @c(ExampleIsPalindrome) would be shown with the
#    documentation for the @c(IsPalindrome) function, and an example function
#    called just @c(Example) would be associated with the @c(word) package as a
#    whole.
   Basado en el sufijo @c(Example) de la de funcion, el servidor de
   documentacion basado en la web @$(godoc) asocia funciones ejemplo con la
   funcion o el paquete que ejemplifican, por lo que @c(ExampleIsPalindrome) se
   mostrara con la documentacion para la funcion @c(IsPalindrome), y se asociara
   una funcion de ejemplo llamado simplemente @c(Example) asociado con el
   paquete @c(word) en su conjunto.

#    The second purpose is that examples are executable tests run by @$(go test).
#    If the example function contains a final @c(// Output): comment like the one
#    above, the test driver will execute the function and check that what it
#    printed to its standard output matches the text within the comment.
   El segundo proposito es que los ejemplos son pruebas ejecutables dirigidas
   por @$(go test). Si la funcion de ejemplo contiene un comentario final @c(//
   Output): comentar el de arriba, el controlador de pruebas ejecutara la
   funcion y comprobar que lo que se imprime en la salida estandar coincide con
   el texto dentro de los comentarios.

#    The third purpose of an example is hands-on experimentation. The @$(godoc)
#    server at @c(golang.org) uses the Go Playground to let the user edit and run
#    each example function from within a web browser, as shown in Figure
#    11.4. This is often the fastest way to get a feel for a particular function
#    or language feature.
   El tercer objetivo de un ejemplo es la experimentacion practica. El servidor
   @$(godoc) en @c(golang.org) utiliza la Zona de juegos para permitir al
   usuario editar y ejecutar cada funcion de ejemplo desde un navegador web,
   como se muestra en la Figura 11.4. Esta es a menudo la manera mas rapida de
   conseguir una sensacion para una funcion o caracteristica del lenguaje
   particular.

#    ..figure > Figure 11.4. An interactive example of @c(strings.Join) in @$(godoc).
   ..figure > Figura 11.4. Un ejemplo interactiva de @c(strings.Join) en @$(godoc).

#      ..img  > img/Figure-11.4.jpg
     ..img  > img/Figure-11.4.jpg


#    The final two chapters of the book examine the @c(reflect) and @c(unsafe)
#    packages, which few Go programmers regularly use—and even fewer @e(need) to
#    use. If you haven’t written any substantial Go programs yet, now would be a
#    good time to do that.
   Los dos capitulos finales del libro examinan los paquetes @c(reflect) y
   @c(unsafe), que pocon programadores Go utilizan regularmente–e incluso menos
   @e(necesitan) usarlos. Si aun no ha escrito ningun programa de Go sustancial,
   ahora seria un buen momento para hacerlo.

# * Chapter 12 <> Reflection
* Capitulo 12 <> Reflexion

#   Go provides a mechanism to update variables and inspect their values at run
#   time, to call their methods, and to apply the operations intrinsic to their
#   representation, all without knowing their types at compile time. This
#   mechanism is called @e(reflection). Reflection also lets us treat types
#   themselves as first-class values.
  Go proporciona un mecanismo para actualizar variables e inspeccionar sus
  valores en tiempo de ejecucion, llamar a sus metodos y aplicar las operaciones
  intrinsecas a su representacion, todo sin conocer sus tipos en tiempo de
  compilacion. Este mecanismo se denomina @e(reflexion). La reflexion tambien
  nos permite tratar los propios tipos como valores de primera clase.

#   In this chapter, we’ll explore Go’s reflection features to see how they
#   increase the expressiveness of the language, and in particular how they are
#   crucial to the implementation of two important APIs: string formatting
#   provided by @c(fmt), and protocol encoding provided by packages like
#   @c(encoding/json) and @c(encoding/xml). Reflection is also essential to the
#   template mechanism provided by the @c(text/template) and @c(html/template)
#   packages we saw in @l(#Section 4.6). However, reflection is complex to reason
#   about and not for casual use, so although these packages are implemented using
#   reflection, they do not expose reflection in their own APIs.
  En este capitulo, vamos a explorar las caracteristicas de reflexion de Go para
  ver la forma en que aumentan la expresividad del lenguaje, y en particular la
  forma en que son cruciales para la implementacion de dos APIs importantes: el
  formateo de cadenas proporcionado por @c(fmt), y el protocolo de codificacion
  proporcionados por los paquetes @c(encoding/json) y @c(encoding/xml). La
  reflexion es tambien esencial para el mecanismo de plantilla proporcionada por
  los paquetes @c(text/template) y @c(html/template) que vimos en la @l(#Seccion
  4.6). Sin embargo, es complejo razonar la reflexion y no es para uso casual,
  por lo que aunque estos paquetes se implementan mediante la reflexion, no
  exponen la reflexion en sus propias API.

# ** Section 12.1 <> Why Reflection?
** Seccion 12.1 <> ¿Por que la Reflexion?

#    Sometimes we need to write a function capable of dealing uniformly with
#    values of types that don’t satisfy a common interface, don’t have a known
#    representation, or don’t exist at the time we design the function—or even all
#    three.
   A veces necesitamos escribir una funcion capaz de tratar uniformemente con
   valores de tipos que no satisfacen una interfaz comun, no tienen una
   representacion conocida o no existen en el momento en que diseñamos la
   funcion–o incluso los tres.

#    A familiar example is the formatting logic within @c(fmt.Fprintf), which can
#    usefully print an arbitrary value of any type, even a user-defined one. Let’s
#    try to implement a function like it using what we know already. For
#    simplicity, our function will accept one argument and will return the result
#    as a string like @c(fmt.Sprint) does, so we’ll call it @c(Sprint).
   Un ejemplo familiar es la logica de formateo dentro de @c(fmt.Fprintf), que
   puede imprimir de manera util un valor arbitrario de cualquier tipo, incluso
   uno definido por el usuario. Tratemos de implementar una funcion como esta
   usando lo que ya sabemos. Para simplificar, nuestra funcion acepta un
   argumento y devuelve el resultado como una cadena como hace @c(fmt.Sprint),
   asi que vamos a llamarlo @c(Sprint).

#    We start with a type switch that tests whether the argument defines a
#    @c(String) method, and call it if so. We then add switch cases that test the
#    value’s dynamic type against each of the basic types—@c(string), @c(int),
#    @c(bool), and so on—and perform the appropriate formatting operation in each
#    case.
   Empezamos con un @c(switch) de tipo que pone a prueba si el argumento define
   una metodo @c(String), y lo llaman si es asi. A continuacion, agregamos casos
   que ponen a prueba el tipo dinamico del valor en cada uno de los tipos
   basicos–@c(string), @c(int), @c(bool), etc–y realice la operacion de formato
   adecuado en cada caso.

#    ..src > go
#      func Sprint(x interface{}) string {
#        type stringer interface {
#          String() string
#        }
#        switch x := x.(type) {
#        case stringer:
#          return x.String()
#        case string:
#          return x
#        case int:
#          return strconv.Itoa(x)
#          // ...similar cases for int16, uint32, and so on...
#        case bool:
#          if x {
#            return "true"
#          }
#          return "false"
#        default:
#          // array, chan, func, map, pointer, slice, struct
#          return "???"
#        }
#      }
#    < src..
   ..src > go
     func Sprint(x interface{}) string {
       type stringer interface {
         String() string
       }
       switch x := x.(type) {
       case stringer:
         return x.String()
       case string:
         return x
       case int:
         return strconv.Itoa(x)
         // ...similar cases for int16, uint32, and so on...
       case bool:
         if x {
           return "true"
         }
         return "false"
       default:
         // array, chan, func, map, pointer, slice, struct
         return "???"
       }
     }
   < src..

#    But how do we deal with other types, like @c([]float64),
#    @c(map[string][]string), and so on? We could add more cases, but the number
#    of such types is infinite. And what about named types, like @c(url.Values)?
#    Even if the type switch had a case for its underlying type
#    @c(map[string][]string), it wouldn’t match @c(url.Values) because the two
#    types are not identical, and the type switch cannot include a case for each
#    type like @c(url.Values) because that would require this library to depend
#    upon its clients.
   Pero, ¿como podemos hacer frente a otros tipos, como @c([]float64),
   @c(map[string][]string), y demas? Podriamos añadir mas casos, pero el numero
   de tales tipos es infinito. Y que pasa con los tipos con nombre, como
   @c(url.Values)? Incluso si el @c(switch) de tipo tenia un caso para su tipo
   subyacente @c(map[string][]string), no coincidira con con @c(url.Values)
   porque los dos tipos no son identicos, y el interruptor de tipo no puede
   incluir un caso para cada tipo como @c(url.Values) porque eso requeriria que
   esta libreria dependa de sus clientes.

#    Without a way to inspect the representation of values of unknown types, we
#    quickly get stuck.  What we need is reflection.
   Sin una manera de inspeccionar la representacion de valores de tipos
   desconocidos, rapidamente nos quedamos atascados. Lo que necesitamos es
   reflexion.

# ** Section 12.2 <> @c(reflect.Type) and @c(reflect.Value)
** Seccion 12.2 <> @c(reflect.Type) y @c(reflect.Value)

#    Reflection is provided by the @c(reflect) package. It defines two important
#    types, @c(Type) and @c(Value). A @c(Type) represents a Go type. It is an
#    interface with many methods for discriminating among types and inspecting
#    their components, like the fields of a struct or the parameters of a
#    function. The sole implementation of @c(reflect.Type) is the type descriptor
#    (@l(#Section 7.5<>§7.5)), the same entity that identifies the dynamic type of
#    an interface value.
   La reflexion es proporcionada por el paquete @c(reflect). Este define dos
   tipos importantes, @c(Type) y @c(Value). @c(Type) representa un tipo Go. Es
   una interfaz con muchos metodos para discriminar entre tipos e inspeccionar
   sus componentes, como los campos de una estructura o los parametros de una
   funcion. La unica aplicacion de @c(reflect.Type) es el descriptor de tipo
   (@l(#Seccion 7.5<>§7.5)), la misma entidad que identifica el tipo dinamico de
   un valor interfaz.

#    The @c(reflect.TypeOf) function accepts any @c(interface{}) and returns its
#    dynamic type as a @c(reflect.Type):
   la funcion @c(reflect.TypeOf) acepta cualquier @c(interface{}) y devuelve su
   tipo dinamico como @c(reflect.Type):

#    ..src > go
#      t := reflect.TypeOf(3)  // a reflect.Type
#      fmt.Println(t.String()) // "int"
#      fmt.Println(t)          // "int"
#    < src..
   ..src > go
     t := reflect.TypeOf(3)  // un reflect.Type
     fmt.Println(t.String()) // "int"
     fmt.Println(t)          // "int"
   < src..

#    The @c[TypeOf(3)] call above assigns the value 3 to the @c(interface{})
#    parameter. Recall from @l(#Section 7.5) that an assignment from a concrete
#    value to an interface type performs an implicit interface conversion, which
#    creates an interface value consisting of two components: its @e(dynamic type)
#    is the operand’s type (@c(int)) and its @e(dynamic value) is the operand’s
#    value (3).
   La llamada @c[TypeOf(3)] anterior asigna el valor 3 al parametro
   @c(interface{}). Recuerdese de la @l(#Seccion 7.5) que una asignacion de un
   valor concreto a un tipo de interfaz lleva a cabo una conversion de la
   interfaz implicita, que crea un valor interfaz que consta de dos componentes:
   su @e(tipo dinamico) es el tipo del operando (@c(int)) y su @e(valor
   dinamico) es el valor del operando (3).

#    Because @c(reflect.TypeOf) returns an interface value’s dynamic type, it
#    always returns a concrete type. So, for example, the code below prints
#    @"(@c(*os.File)), not @"(@c(*io.Writer))". Later, we will see that @c(reflect.Type)
#    is capable of representing interface types too.
   Ya que @c(reflect.TypeOf) regresa el tipo dinamico de un valor de interfaz,
   siempre devuelve un tipo concreto. Asi, por ejemplo, el codigo que aparce a
   continuacion imprime @"(@c(*os.File)), no @"(@c(*io.Writer)). Mas tarde,
   veremos que @c(reflect.Type) es capaz de representar tipos de interfaz
   tambien.

#    ..src > go
#      var w io.Writer = os.Stdout
#      fmt.Println(reflect.TypeOf(w)) // "*os.File"
#    < src..
   ..src > go
     var w io.Writer = os.Stdout
     fmt.Println(reflect.TypeOf(w)) // "*os.File"
   < src..

#    Notice that @c(reflect.Type) satisfies @c(fmt.Stringer). Because printing the
#    dynamic type of an interface value is useful for debugging and logging,
#    @c(fmt.Printf) provides a shorthand, @c(%T), that uses @c(reflect.TypeOf)
#    internally:
   Observe que @c(reflect.Type) satisface @c(fmt.Stringer). Como la impresion
   del tipo dinamico de un valor interfaz es util para depuracion y registro,
   @c(fmt.Printf) proporciona una abreviatura, @c(%T), que internamente utiliza
   @c(reflect.TypeOf):

#    ..src > go
#      fmt.Printf("%T\n", 3) // "int"
#    < src..
   ..src > go
     fmt.Printf("%T\n", 3) // "int"
   < src..

#    The other important type in the @c(reflect) package is @c(Value). A
#    @c(reflect.Value) can hold a value of any type. The @c(reflect.ValueOf)
#    function accepts any @c(interface{}) and returns a @c(reflect.Value)
#    containing the interface’s dynamic value. As with @c(reflect.TypeOf), the
#    results of @c(reflect.ValueOf) are always concrete, but a @c(reflect.Value)
#    can hold interface values too.
   El otro tipo importante en el paquete @c(reflect) es @c(Value). Un
   @c(reflect.Value) puede contener un valor de cualquier tipo. La funcion
   @c(reflect.ValueOf) acepta cualquier @c(interface{}) y devuelve un valor
   @c(reflect.Value) que contiene el valor dinamico de la interfaz. Al igual que
   con @c(reflect.TypeOf), los resultados de @c(reflect.ValueOf) son siempre
   concretos, pero un @c(reflect.Value) pueden contener valores de interfaz
   tambien.

#    ..src > go
#      v := reflect.ValueOf(3)  // a reflect.Value
#      fmt.Println(v)           // "3"
#      fmt.Printf("%v\n", v)    // "3"
#      fmt.Println(v.String())  // NOTE: "<int Value>"
#    < src..
   ..src > go
     v := reflect.ValueOf(3)  // un reflect.Value
     fmt.Println(v)           // "3"
     fmt.Printf("%v\n", v)    // "3"
     fmt.Println(v.String())  // NOTA: "<int Value>"
   < src..

#    Like @c(reflect.Type), @c(reflect.Value) also satisfies @c(fmt.Stringer), but
#    unless the @c(Value) holds a string, the result of the @c(String) method
#    reveals only the type. Instead, use the @c(fmt) package’s @c(%v) verb, which
#    treats @c(reflect.Values) specially.
   Al igual que @c(reflect.Type), @c(reflect.Value) tambien satisface
   @c(fmt.Stringer), pero a menos que @c(Value) contenga un string, el resultado
   del metodo @c(String) solo revela el tipo. En su lugar, utilice el verbo
   @c(%v) del paquete @c(fmt), que maneja @c(reflect.Values) especialmente.

#    Calling the @c(Type) method on a @c(Value) returns its type as a
#    @c(reflect.Type):
   Al llamar al metodo @c(Type) en un @c(Value) devuelve su tipo como
   @c(reflect.Type):

#    ..src > go
#      t := v.Type()           // a reflect.Type
#      fmt.Println(t.String()) // "int"
#    < src..
   ..src > go
     t := v.Type()           // un reflect.Type
     fmt.Println(t.String()) // "int"
   < src..

#    The inverse operation to @c(reflect.ValueOf) is the
#    @c(reflect.Value.Interface) method. It returns an @c(interface{}) holding the
#    same concrete value as the @c(reflect.Value):
   La operacion inversa de @c(reflect.ValueOf) es el motodo
   @c(reflect.Value.Interface). Devuelve una @c(interface{}) que contiene el
   mismo valor concreto que @c(reflect.Value):

#    ..src > go
#      v := reflect.ValueOf(3) // a reflect.Value
#      x := v.Interface()      // an interface{}
#      i := x.(int)            // an int
#      fmt.Printf("%d\n", i)   // "3"
#    < src..
   ..src > go
     v := reflect.ValueOf(3) // un reflect.Value
     x := v.Interface()      // un interface{}
     i := x.(int)            // un int
     fmt.Printf("%d\n", i)   // "3"
   < src..

#    A @c(reflect.Value) and an @c(interface{}) can both hold arbitrary
#    values. The difference is that an empty interface hides the representation
#    and intrinsic operations of the value it holds and exposes none of its
#    methods, so unless we know its dynamic type and use a type assertion to peer
#    inside it (as we did above), there is little we can do to the value
#    within. In contrast, a @c(Value) has many methods for inspecting its
#    contents, regardless of its type. Let’s use them for our second attempt at a
#    general formatting function, which we’ll call @c(format.Any).
   Un @c(reflect.Value) y una @c(interface{}) pueden ambos contener valores
   arbitrarios. La diferencia es que una interfaz vacia oculta la representacion
   y las operaciones intrinsecas del valor que contiene y no expone ninguno de
   sus metodos, de modo que a menos que conozcamos su tipo dinamico y usemos una
   asercion de tipo para mirar dentro (como lo hicimos anteriormente), hay Poco
   que podemos hacer con el valor. Por el contrario, un @c(Value) tiene muchos
   metodos para inspeccionar su contenido, independientemente de su tipo. Vamos
   a utilizarlos para nuestro segundo intento de una funcion de formateo
   general, que llamaremos @c(format.Any).

#    Instead of a type switch, we use @c(reflect.Value)’s @c(Kind) method to
#    discriminate the cases.  Although there are infinitely many types, there are
#    only a finite number of @c(kinds) of type: the basic types @c(Bool),
#    @c(String), and all the numbers; the aggregate types @c(Array) and
#    @c(Struct); the reference types @c(Chan), @c(Func), @c(Ptr), @c(Slice), and
#    @c(Map); @c(Interface) types; and finally @c(Invalid), meaning no value at
#    all. (The zero value of a @c(reflect.Value) has kind @c(Invalid).)
   En lugar de un switch de tipo, usaremos @c(reflect.Value) y su metodo
   @c(Kind) para discriminar los casos. Aunque hay un numero infinito de tipos,
   solo hay un numero finito de @c(kinds) de tipo: los tipos basicos @c(Bool),
   @c(String), y todos los numeros; los tipos agregados @c(Array) y @c(Struct);
   los tipos de referencia @c(Chan), @c(Func), @c(Ptr), @c(Slice), y @c(Map);
   los tipos @c(Interface); y, finalmente, @c(Invalid), es decir, sin valor
   alguno. (El valor cero de una @c(reflect.Value) tiene una tipo @c(Invalid).)

#    ..figure > @l(gopl.io/ch12/format/format.go<>gopl.io/ch12/format)
   ..figure > @l(gopl.io/ch12/format/format.go<>gopl.io/ch12/format)

#      ..src > go
#        package format
#
#        import (
#          "reflect"
#          "strconv"
#        )
#
#        // Any formats any value as a string.
#        func Any(value interface{}) string {
#          return formatAtom(reflect.ValueOf(value))
#        }
#
#        // formatAtom formats a value without inspecting its internal structure.
#        func formatAtom(v reflect.Value) string {
#          switch v.Kind() {
#          case reflect.Invalid:
#            return "invalid"
#          case reflect.Int, reflect.Int8, reflect.Int16,
#            reflect.Int32, reflect.Int64:
#            return strconv.FormatInt(v.Int(), 10)
#          case reflect.Uint, reflect.Uint8, reflect.Uint16,
#            reflect.Uint32, reflect.Uint64, reflect.Uintptr:
#            return strconv.FormatUint(v.Uint(), 10)
#          // ...floating-point and complex cases omitted for brevity...
#          case reflect.Bool:
#            return strconv.FormatBool(v.Bool())
#          case reflect.String:
#            return strconv.Quote(v.String())
#          case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
#            return v.Type().String() + " 0x" +
#              strconv.FormatUint(uint64(v.Pointer()), 16)
#          default: // reflect.Array, reflect.Struct, reflect.Interface
#            return v.Type().String() + " value"
#          }
#        }
#      < src..
     ..src > go
       package format

       import (
         "reflect"
         "strconv"
       )

       // Any formatea cualquier valor como un string.
       func Any(value interface{}) string {
         return formatAtom(reflect.ValueOf(value))
       }

       // formatAtom formatea un valor sin inspeccionar su estructura interna.
       func formatAtom(v reflect.Value) string {
         switch v.Kind() {
         case reflect.Invalid:
           return "invalid"
         case reflect.Int, reflect.Int8, reflect.Int16,
           reflect.Int32, reflect.Int64:
           return strconv.FormatInt(v.Int(), 10)
         case reflect.Uint, reflect.Uint8, reflect.Uint16,
           reflect.Uint32, reflect.Uint64, reflect.Uintptr:
           return strconv.FormatUint(v.Uint(), 10)
         // ...Casos de punto flotante y complejos omitidos por brevedad...
         case reflect.Bool:
           return strconv.FormatBool(v.Bool())
         case reflect.String:
           return strconv.Quote(v.String())
         case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
           return v.Type().String() + " 0x" +
             strconv.FormatUint(uint64(v.Pointer()), 16)
         default: // reflect.Array, reflect.Struct, reflect.Interface
           return v.Type().String() + " value"
         }
       }
     < src..


#    So far, our function treats each value as an indivisible thing with no
#    internal structure—hence @c(formatAtom). For aggregate types (structs and
#    arrays) and interfaces it prints only the @e(type) of the value, and for
#    reference types (channels, functions, pointers, slices, and maps), it prints
#    the type and the reference address in hexadecimal. This is less than ideal
#    but still a major improvement, and since @c(Kind) is concerned only with the
#    underlying representation, @c(format.Any) works for named types too. For
#    example:
   Hasta ahora, nuestra funcion maneja cada valor como una cosa indivisible, sin
   estructura interna–de ahi @c(formatAtom). Para los tipos de agregados
   (estructuras y matrices) y las interfaces se imprime unicamente el @e(tipo)
   del valor, y para los tipos de referencia (canales, funciones, punteros,
   slices, y mapas), se imprime el tipo y la direccion de referencia en
   hexadecimal. Esto es menos que ideal, pero sigue siendo una importante
   mejora, y ya que @c(Kind) se ocupa solo con la representacion subyacente,
   @c(format.Any) funciona tambien para los timpos con nombre. Por ejemplo:

#    ..src > go
#      var x int64 = 1
#      var d time.Duration = 1 * time.Nanosecond
#      fmt.Println(format.Any(x))                  // "1"
#      fmt.Println(format.Any(d))                  // "1"
#      fmt.Println(format.Any([]int64{x}))         // "[]int64 0x8202b87b0"
#      fmt.Println(format.Any([]time.Duration{d})) // "[]time.Duration 0x8202b87e0"
#    < src..
   ..src > go
     var x int64 = 1
     var d time.Duration = 1 * time.Nanosecond
     fmt.Println(format.Any(x))                  // "1"
     fmt.Println(format.Any(d))                  // "1"
     fmt.Println(format.Any([]int64{x}))         // "[]int64 0x8202b87b0"
     fmt.Println(format.Any([]time.Duration{d})) // "[]time.Duration 0x8202b87e0"
   < src..

# ** Section 12.3 <> @c(Display), a Recursive Value Printer
** Seccion 12.3 <> @c(Display), una Impresora Recursiva de Valor

#    Next we’ll take a look at how to improve the display of composite
#    types. Rather than try to copy @c(fmt.Sprint) exactly, we’ll build a
#    debugging utility function called @c(Display) that, given an arbitrarily
#    complex value @c(x), prints the complete structure of that value, labeling
#    each element with the path by which it was found. Let’s start with an
#    example.
   A continuacion veremos como mejorar la visualizacion de tipos compuestos. En
   lugar de tratar de copiar @c(fmt.Sprint) exactamente, vamos a construir una
   funcion de utilidad de depuracion llamada @c(Display) que, dado un valor
   @c(x) arbitrariamente complejo, imprime la estructura completa de ese valor,
   etiquetando cada elemento con el camino por el cual se encontro. Comencemos
   con un ejemplo.

#    ..src > go
#      e, _ := eval.Parse("sqrt(A / pi)")
#      Display("e", e)
#    < src..
   ..src > go
     e, _ := eval.Parse("sqrt(A / pi)")
     Display("e", e)
   < src..

#    In the call above, the argument to @c(Display) is a syntax tree from the
#    expression evaluator in @l(#Section 7.9). The output of @c(Display) is shown
#    below:
   En la llamada anterior, el argumento de @c(Display) es un arbol sintactico
   del evaluador de expresiones en la @l(#Seccion 7.9). La salida de @c(Display)
   se muestra a continuacion:

#    ..src > sh
#      Display e (eval.call):
#      e.fn = "sqrt"
#      e.args[0].type = eval.binary
#      e.args[0].value.op = 47
#      e.args[0].value.x.type = eval.Var
#      e.args[0].value.x.value = "A"
#      e.args[0].value.y.type = eval.Var
#      e.args[0].value.y.value = "pi"
#    < src..
   ..src > sh
     Display e (eval.call):
     e.fn = "sqrt"
     e.args[0].type = eval.binary
     e.args[0].value.op = 47
     e.args[0].value.x.type = eval.Var
     e.args[0].value.x.value = "A"
     e.args[0].value.y.type = eval.Var
     e.args[0].value.y.value = "pi"
   < src..

#    Where possible, you should avoid exposing reflection in the API of a
#    package. We’ll define an unexported function @c(display) to do the real work
#    of the recursion, and export @c(Display), a simple wrapper around it that
#    accepts an @c(interface{}) parameter:
   Cuando sea posible, debe evitar exponer la reflexion en la API de un
   paquete. Definiremos un funcion sin exportacion @c(display) para hacer el
   trabajo real de la recursividad, y la exportacion @c(Display), un simple
   envoltorio alrededor de el que acepta un parametro @c(interface{}):

#    ..figure > @l(gopl.io/ch12/display/display.go<>gopl.io/ch12/display)
   ..figure > @l(gopl.io/ch12/display/display.go<>gopl.io/ch12/display)

#      ..src > go
#        func Display(name string, x interface{}) {
#          fmt.Printf("Display %s (%T):\n", name, x)
#          display(name, reflect.ValueOf(x))
#        }
#      < src..
     ..src > go
       func Display(name string, x interface{}) {
         fmt.Printf("Display %s (%T):\n", name, x)
         display(name, reflect.ValueOf(x))
       }
     < src..


#    In @c(display), we’ll use the @c(formatAtom) function we defined earlier to
#    print elementary values—basic types, functions, and channels—but we’ll use
#    the methods of @c(reflect.Value) to recursively display each component of a
#    more complex type. As the recursion descends, the path string, which
#    initially describes the starting value (for instance, @"(@c(e))), will be
#    augmented to indicate how we reached the current value (for instance,
#    @"(@c(e.args[0].value))).
   En @c(display), usaremos la funcion @c(formatAtom) que definimos anteriormente
   para imprimir valores elementales–tipos basicos, funciones y canales–pero
   vamos a utilizar los metodos de @c(reflect.Value) para mostrar repetidamente cada
   componente de un tipo mas complejo. A medida que la recursion desciende, la cadena de
   ruta, que describe inicialmente el valor de partida (por ejemplo, @"(@c(e))),
   se incrementara para indicar como alcanzamos el valor actual (por
   ejemplo, @"(@c(e.args[0].value))).

#    Since we’re no longer pretending to implement @c(fmt.Sprint), we will use the
#    @c(fmt) package to keep our example short.
   Como ya no pretendemos implementar @c(fmt.Sprint), utilizaremos el paquete
   @c(fmt) para mantener nuestro ejemplo corto.

#    ..src > go
#      func display(path string, v reflect.Value) {
#        switch v.Kind() {
#        case reflect.Invalid:
#          fmt.Printf("%s = invalid\n", path)
#        case reflect.Slice, reflect.Array:
#          for i := 0; i < v.Len(); i++ {
#            display(fmt.Sprintf("%s[%d]", path, i), v.Index(i))
#          }
#        case reflect.Struct:
#          for i := 0; i < v.NumField(); i++ {
#            fieldPath := fmt.Sprintf("%s.%s", path, v.Type().Field(i).Name)
#            display(fieldPath, v.Field(i))
#          }
#        case reflect.Map:
#          for _, key := range v.MapKeys() {
#            display(fmt.Sprintf("%s[%s]", path,
#              formatAtom(key)), v.MapIndex(key))
#          }
#        case reflect.Ptr:
#          if v.IsNil() {
#            fmt.Printf("%s = nil\n", path)
#          } else {
#            display(fmt.Sprintf("(*%s)", path), v.Elem())
#          }
#        case reflect.Interface:
#          if v.IsNil() {
#            fmt.Printf("%s = nil\n", path)
#          } else {
#            fmt.Printf("%s.type = %s\n", path, v.Elem().Type())
#            display(path+".value", v.Elem())
#          }
#        default: // basic types, channels, funcs
#          fmt.Printf("%s = %s\n", path, formatAtom(v))
#        }
#      }
#    < src..
   ..src > go
     func display(path string, v reflect.Value) {
       switch v.Kind() {
       case reflect.Invalid:
         fmt.Printf("%s = invalid\n", path)
       case reflect.Slice, reflect.Array:
         for i := 0; i < v.Len(); i++ {
           display(fmt.Sprintf("%s[%d]", path, i), v.Index(i))
         }
       case reflect.Struct:
         for i := 0; i < v.NumField(); i++ {
           fieldPath := fmt.Sprintf("%s.%s", path, v.Type().Field(i).Name)
           display(fieldPath, v.Field(i))
         }
       case reflect.Map:
         for _, key := range v.MapKeys() {
           display(fmt.Sprintf("%s[%s]", path,
             formatAtom(key)), v.MapIndex(key))
         }
       case reflect.Ptr:
         if v.IsNil() {
           fmt.Printf("%s = nil\n", path)
         } else {
           display(fmt.Sprintf("(*%s)", path), v.Elem())
         }
       case reflect.Interface:
         if v.IsNil() {
           fmt.Printf("%s = nil\n", path)
         } else {
           fmt.Printf("%s.type = %s\n", path, v.Elem().Type())
           display(path+".value", v.Elem())
         }
       default: // basic types, channels, funcs
         fmt.Printf("%s = %s\n", path, formatAtom(v))
       }
     }
   < src..


#    Let’s discuss the cases in order.
   Vamos a discutir los casos en orden.

#    - Slices and arrays :: The logic is the same for both. The Len method returns
#      the number of elements of a slice or array value, and @c[Index(i)] retrieves
#      the element at index @c(i), also as a reflect.Value; it panics if @c(i) is
#      out of bounds. These are analogous to the built-in @c[len(a)] and @c(a[i])
#      operations on sequences. The @c(display) function recursively invokes itself
#      on each element of the sequence, appending the subscript notation @"(@c([i]))
#      to the path.
   - Slices y arreglos :: La logica es la misma para ambos. El metodo @c(Len)
     devuelve el numero de elementos de un valor slice o arreglo, y @c[Index(i)]
     recupera el elemento en el indice @c(i), tambien como un @c(reflect.Value);
     entra en panico si @c(i) esta fuera de limites. Esto es analoga al
     @c[len(a)] nativo y a la operacion en secuencias @c(a[i]). La funcion
     @c(display) se invoca a si misma recursivamente en cada elemento de la
     secuencia, añadiendo la notacion subindice @"(@c([i])) a la trayectoria.

#      Although @c(reflect.Value) has many methods, only a few are safe to call on
#      any given value.  For example, the Index method may be called on values of
#      kind @c(Slice), @c(Array), or @c(String), but panics for any other kind.
     Aunque @c(reflect.Value) tiene muchos metodos, solo unos pocos son seguros
     para llamar a cualquier valor dado. Por ejemplo, el metodo @c(Index) puede
     ser llamado en valores de tipo @c(Slice), @c(Array) o @c(String), pero
     entra en panico para cualquier otro tipo.

#    - Structs :: The @c(NumField) method reports the number of fields in the
#      struct, and @c[Field(i)] returns the value of the @m(i)-th field as a
#      @c(reflect.Value). The list of fields includes ones promoted from anonymous
#      fields. To append the field selector notation @"(@c(.f)) to the path, we must
#      obtain the @c(reflect.Type) of the struct and access the name of its @m(i)-th
#      field.
   - Estructuras :: El metodo @c(NumField) informa el numero de campos en la
     estructura, y @c[Field(i)] devuelve el valor del campo @c(i) como un
     @c(reflect.Value). La lista de campos incluye los promocionados desde
     campos anonimos. Para añadir la notacion de seleccion de campo @"(@c(.f)) a
     la ruta, debemos obtener el @c(reflect.Type) de la estructura y tener
     acceso al nombre de su campo @c(i).

#    - Maps :: The @c(MapKeys) method returns a slice of @c(reflect.Values), one
#      per map key. As usual when iterating over a map, the order is
#      undefined. @c[MapIndex(key)] returns the value corresponding to @c(key). We
#      append the subscript notation @"(@c([key])) to the path. (We’re cutting a
#      corner here. The type of a map key isn’t restricted to the types
#      @c(formatAtom) handles best; arrays, structs, and interfaces can also be
#      valid map keys. Extending this case to print the key in full is Exercise
#      12.1.)
   - Mapas :: El metodo @c(MapKeys) devuelve un slice de @c(reflect.Values), uno
     por cada clave del mapa. Como de costumbre cuando se itera sobre un mapa,
     el orden no esta definido. @c[MapIndex(key)] devuelve el valor
     correspondiente a @c(key). Añadimos la notacion de subindice @"(@c([key]))
     a la ruta. (Estamos cortando una esquina aqui el tipo de una clave del mapa
     no se limita a los tipos que @c(formatAtom) maneja mejor; arreglos,
     estructuras e interfaces tambien pueden ser claves validas de mapa.
     Extender este caso para imprimir la clave en su totalidad es el
     Ejercicio. 12.1.)

#    - Pointers :: The @c(Elem) method returns the variable pointed to by a
#      pointer, again as a @c(reflect.Value). This operation would be safe even if
#      the pointer value is @c(nil), in which case the result would have kind
#      @c(Invalid), but we use IsNil to detect nil pointers explicitly so we can
#      print a more appropriate message. We prefix the path with a @"(@c(*)) and
#      parenthesize it to avoid ambiguity.
   - Punteros :: El metodo @c(Elem) devuelve la variable a la que apunta un
     puntero, de nuevo como un @c(reflect.Value). Esta operacion seria segura
     incluso si el valor del puntero es @c(nil), en cuyo caso el resultado
     tendria tipo @c(Invalid), pero utilizamos @c(IsNil) para detectar punteros
     nulos de manera explicita por lo que podemos imprimir un mensaje mas
     apropiado. Prefijamos el camino con un @"(@c(*)) y un parentesis para
     evitar la ambigüedad.

#    - Interfaces :: Again, we use @c(IsNil) to test whether the interface is
#      nil, and if not, we retrieve its dynamic value using @c[v.Elem()] and print
#      its type and value.
   - Interfaces : Una vez mas, utilizamos @c(IsNil) para probar si la interfaz
     es nil, y si no, recuperamos su valor dinamico utilizando @c[v.Elem()) e
     imprimimos su tipo y valor.


#    Now that our @c(Display) function is complete, let’s put it to work. The
#    @c(Movie) type below is a slight variation on the one in @l(#Section 4.5):
   Ahora que nuestro funcion @c(Display) esta completa, vamos a ponerla a
   trabajar. El tipo @c(Movie) a continuacion es una ligera variacion del
   presente en la @l(#Seccion 4.5):

#    ..src > go
#      type Movie struct {
#        Title, Subtitle string
#        Year            int
#        Color           bool
#        Actor           map[string]string
#        Oscars          []string
#        Sequel          *string
#      }
#    < src..
   ..src > go
     type Movie struct {
       Title, Subtitle string
       Year            int
       Color           bool
       Actor           map[string]string
       Oscars          []string
       Sequel          *string
     }
   < src..

#    Let’s declare a value of this type and see what @c(Display) does with it:
   Vamos a declarar un valor de este tipo y ver lo que hace @c(Display) con el:

#    ..src > go
#      strangelove := Movie{
#        Title:    "Dr. Strangelove",
#        Subtitle: "How I Learned to Stop Worrying and Love the Bomb",
#        Year:     1964,
#        Color:    false,
#        Actor: map[string]string{
#          "Dr. Strangelove":            "Peter Sellers",
#          "Grp. Capt. Lionel Mandrake": "Peter Sellers",
#          "Pres. Merkin Muffley":       "Peter Sellers",
#          "Gen. Buck Turgidson":        "George C. Scott",
#          "Brig. Gen. Jack D. Ripper":  "Sterling Hayden",
#          `Maj. T.J. "King" Kong`:      "Slim Pickens",
#        },
#        Oscars: []string{
#          "Best Actor (Nomin.)",
#          "Best Adapted Screenplay (Nomin.)",
#          "Best Director (Nomin.)",
#          "Best Picture (Nomin.)",
#        },
#      }
#    < src..
   ..src > go
     strangelove := Movie{
       Title:    "Dr. Strangelove",
       Subtitle: "How I Learned to Stop Worrying and Love the Bomb",
       Year:     1964,
       Color:    false,
       Actor: map[string]string{
         "Dr. Strangelove":            "Peter Sellers",
         "Grp. Capt. Lionel Mandrake": "Peter Sellers",
         "Pres. Merkin Muffley":       "Peter Sellers",
         "Gen. Buck Turgidson":        "George C. Scott",
         "Brig. Gen. Jack D. Ripper":  "Sterling Hayden",
         `Maj. T.J. "King" Kong`:      "Slim Pickens",
       },
       Oscars: []string{
         "Best Actor (Nomin.)",
         "Best Adapted Screenplay (Nomin.)",
         "Best Director (Nomin.)",
         "Best Picture (Nomin.)",
       },
     }
   < src..

#    The call @c[Display("strangelove", strangelove)] prints:
   La llamada @c[Display("strangelove", strangelove)] imprime:

#    ..pre >
#      Display strangelove (display.Movie):
#      strangelove.Title = "Dr. Strangelove"
#      strangelove.Subtitle = "How I Learned to Stop Worrying and Love the Bomb"
#      strangelove.Year = 1964
#      strangelove.Color = false
#      strangelove.Actor["Gen. Buck Turgidson"] = "George C. Scott"
#      strangelove.Actor["Brig. Gen. Jack D. Ripper"] = "Sterling Hayden"
#      strangelove.Actor["Maj. T.J. \"King\" Kong"] = "Slim Pickens"
#      strangelove.Actor["Dr. Strangelove"] = "Peter Sellers"
#      strangelove.Actor["Grp. Capt. Lionel Mandrake"] = "Peter Sellers"
#      strangelove.Actor["Pres. Merkin Muffley"] = "Peter Sellers"
#      strangelove.Oscars[0] = "Best Actor (Nomin.)"
#      strangelove.Oscars[1] = "Best Adapted Screenplay (Nomin.)"
#      strangelove.Oscars[2] = "Best Director (Nomin.)"
#      strangelove.Oscars[3] = "Best Picture (Nomin.)"
#      strangelove.Sequel = nil
#    < pre..
   ..pre >
     Display strangelove (display.Movie):
     strangelove.Title = "Dr. Strangelove"
     strangelove.Subtitle = "How I Learned to Stop Worrying and Love the Bomb"
     strangelove.Year = 1964
     strangelove.Color = false
     strangelove.Actor["Gen. Buck Turgidson"] = "George C. Scott"
     strangelove.Actor["Brig. Gen. Jack D. Ripper"] = "Sterling Hayden"
     strangelove.Actor["Maj. T.J. \"King\" Kong"] = "Slim Pickens"
     strangelove.Actor["Dr. Strangelove"] = "Peter Sellers"
     strangelove.Actor["Grp. Capt. Lionel Mandrake"] = "Peter Sellers"
     strangelove.Actor["Pres. Merkin Muffley"] = "Peter Sellers"
     strangelove.Oscars[0] = "Best Actor (Nomin.)"
     strangelove.Oscars[1] = "Best Adapted Screenplay (Nomin.)"
     strangelove.Oscars[2] = "Best Director (Nomin.)"
     strangelove.Oscars[3] = "Best Picture (Nomin.)"
     strangelove.Sequel = nil
   < pre..

#    We can use @c(Display) to display the internals of library types, such as
#    @c(*os.File):
   Podemos utilizar @c(Display) para mostrar el funcionamiento interno de los
   tipos de librerias, como @c(*os.File):

#    ..pre >
#      Display("os.Stderr", os.Stderr)
#      // Output:
#      // Display os.Stderr (*os.File):
#      // (*(*os.Stderr).file).fd = 2
#      // (*(*os.Stderr).file).name = "/dev/stderr"
#      // (*(*os.Stderr).file).nepipe = 0
#    < pre..
   ..pre >
     Display("os.Stderr", os.Stderr)
     // Output:
     // Display os.Stderr (*os.File):
     // (*(*os.Stderr).file).fd = 2
     // (*(*os.Stderr).file).name = "/dev/stderr"
     // (*(*os.Stderr).file).nepipe = 0
   < pre..

#    Notice that even unexported fields are visible to reflection. Beware that the
#    particular output of this example may vary across platforms and may change
#    over time as libraries evolve. (Those fields are private for a reason!) We
#    can even apply @c(Display) to a @c(reflect.Value) and watch it traverse the
#    internal representation of the type descriptor for @c(*os.File). The output
#    of the call @c[Display("rV", reflect.ValueOf(os.Stderr))] is shown below,
#    though of course your mileage may vary:
   Observe que incluso los campos no exportados son visibles para la reflexion.
   Tenga en cuenta que la salida particular de este ejemplo puede variar entre
   plataformas y puede cambiar con el tiempo a medida que las librerias
   evolucionan. (Esos campos son privados por una razon!) Incluso podemos
   aplicar @c(Display) a un @c(reflect.Value) y verlo atravesar la
   representacion interna del descriptor de tipo de @c(*os.File). La salida de
   la llamada @c[Display("rV", reflect.ValueOf(os.Stderr))] se muestra a
   continuacion, aunque, por supuesto, su experiencia puede variar:

#    ..pre >
#      Display rV (reflect.Value):
#      (*rV.typ).size = 8
#      (*rV.typ).hash = 871609668
#      (*rV.typ).align = 8
#      (*rV.typ).fieldAlign = 8
#      (*rV.typ).kind = 22
#      (*(*rV.typ).string) = "*os.File"
#      (*(*(*rV.typ).uncommonType).methods[0].name) = "Chdir"
#      (*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string) = "func() error"
#      (*(*(*(*rV.typ).uncommonType).methods[0].typ).string) = "func(*os.File) error"
#      ...
#    < pre..
   ..pre >
     Display rV (reflect.Value):
     (*rV.typ).size = 8
     (*rV.typ).hash = 871609668
     (*rV.typ).align = 8
     (*rV.typ).fieldAlign = 8
     (*rV.typ).kind = 22
     (*(*rV.typ).string) = "*os.File"
     (*(*(*rV.typ).uncommonType).methods[0].name) = "Chdir"
     (*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string) = "func() error"
     (*(*(*(*rV.typ).uncommonType).methods[0].typ).string) = "func(*os.File) error"
     ...
   < pre..

#    Observe the difference between these two examples:
   Observe la diferencia entre estos dos ejemplos:

#    ..src > go
#      var i interface{} = 3
#      Display("i", i)
#      // Output:
#      // Display i (int):
#      // i = 3
#
#      Display("&i", &i)
#      // Output:
#      // Display &i (*interface {}):
#      // (*&i).type = int
#      // (*&i).value = 3
#    < src..
   ..src > go
     var i interface{} = 3
     Display("i", i)
     // Output:
     // Display i (int):
     // i = 3

     Display("&i", &i)
     // Output:
     // Display &i (*interface {}):
     // (*&i).type = int
     // (*&i).value = 3
   < src..

#    In the first example, @c(Display) calls @c[reflect.ValueOf(i)], which returns
#    a value of kind @c(Int).  As we mentioned in @l(#Section 12.2),
#    @c(reflect.ValueOf) always returns a Value of a concrete type since it
#    extracts the contents of an interface value.
   En el primer ejemplo, @c(Display) llama a @c[reflect.ValueOf(i)], que
   devuelve un valor de tipo @c(Int). Como mencionamos en la @l(#Seccion 12.2),
   @c(reflect.ValueOf) siempre devuelve un valor de un tipo concreto ya que
   extrae el contenido de un valor interfaz.

#    In the second example, @c(Display) calls @c[reflect.ValueOf(&i)], which
#    returns a pointer to @c(i), of kind @c(Ptr). The switch case for @c(Ptr)
#    calls @c(Elem) on this value, which returns a Value representing the
#    @e(variable) @c(i) itself, of kind @c(Interface). A @c(Value) obtained
#    indirectly, like this one, may represent any value at all, including
#    interfaces. The @c(display) function calls itself recursively and this time,
#    it prints separate components for the interface’s dynamic type and value.
   En el segundo ejemplo, @c(Display) llama a @c[reflect.ValueOf(&i)], que
   devuelve un puntero a @c(i), de tipo @c(Ptr). El caso del switch para @c(Ptr)
   llama a @c(Elem) en este valor, que devuelve un valor que representa la
   @e(variable) @c(i) en si, del tipo @c(Interface). Un @c(Value) obtenido
   indirectamente, como este, puede representar cualquier valor en absoluto,
   incluyendo interfaces. La funcion @c(display) se llama a si misma de forma
   recursiva y esta vez, imprime componentes separados para el tipo y valor
   dinamico de la interfaz.

#    As currently implemented, @c(Display) will never terminate if it encounters a
#    cycle in the object graph, such as this linked list that eats its own tail:
   Tal como se aplica actualmente, @c(Display) nunca terminara si encuentra un
   ciclo en el grafico del objeto, como esta lista enlazada que se come su
   propia cola:

#    ..src > go
#      // a struct that points to itself
#      type Cycle struct{ Value int; Tail *Cycle }
#      var c Cycle
#      c = Cycle{42, &c}
#      Display("c", c)
#    < src..
   ..src > go
     // une estructura que apunta a si misma
     type Cycle struct{ Value int; Tail *Cycle }
     var c Cycle
     c = Cycle{42, &c}
     Display("c", c)
   < src..

#    @c(Display) prints this ever-growing expansion:
   @c(Display) imprime esta expansion cada vez mayor:

#    ..src > go
#      Display c (display.Cycle):
#      c.Value = 42
#      (*c.Tail).Value = 42
#      (*(*c.Tail).Tail).Value = 42
#      (*(*(*c.Tail).Tail).Tail).Value = 42
#      ...ad infinitum...
#    < src..
   ..src > go
     Display c (display.Cycle):
     c.Value = 42
     (*c.Tail).Value = 42
     (*(*c.Tail).Tail).Value = 42
     (*(*(*c.Tail).Tail).Tail).Value = 42
     ...ad infinitum...
   < src..

#    Many Go programs contain at least some cyclic data. Making @c(Display) robust
#    against such cycles is tricky, requiring additional bookkeeping to record the
#    set of references that have been followed so far; it is costly too. A general
#    solution requires @c(unsafe) language features, as we will see in @l(#Section
#    13.3).
   Muchos programas Go contienen al menos algunos datos ciclicos. Hacer
   @c(Display) robusto frente a estos ciclos es complicado, requiriendo
   contabilidad adicional para registrar el conjunto de referencias que se han
   seguido hasta ahora; Es costoso tambien. Una solucion general requiere la
   caracteristicas @c(unsafe) del lenguaje, como veremos en la @l(#Seccion
   13.3).

#    Cycles pose less of a problem for @c(fmt.Sprint) because it rarely tries to
#    print the complete structure. For example, when it encounters a pointer, it
#    breaks the recursion by printing the pointer’s numeric value. It can get
#    stuck trying to print a slice or map that contains itself as an element, but
#    such rare cases do not warrant the considerable extra trouble of handling
#    cycles.
   Los ciclos plantean un problema menor para @c(fmt.Sprint), ya que rara vez se
   intenta imprimir la estructura completa. Por ejemplo, cuando encuentra un
   puntero, rompe la recursion imprimiendo el valor numerico del puntero. Puede
   quedar atrapado tratando de imprimir un slice o un mapa que se contiene como
   un elemento, pero estos casos raros no garantizan el considerable problema
   adicional de la manipulacion de ciclos.

#    @b(Exercise 12.1): Extend @c(Display) so that it can display maps whose keys
#    are structs or arrays.
   @b(Ejercicio 12.1): Ampliar @c(Display) para que pueda mostrar mapas cuyas claves
   son estructuras o matrices.

#    @b(Exercise 12.2): Make @c(display) safe to use on cyclic data structures by
#    bounding the number of steps it takes before abandoning the recursion. (In
#    @l(#Section 13.3), we’ll see another way to detect cycles.)
   @b(Ejercicio 12.2): Hacer @c(display) seguro de usar en estructuras de datos
   ciclicas limitando el numero de pasos necesarios antes de abandonar la
   recursividad. (En la @l(#Seccion 13.3), veremos otra forma de detectar
   ciclos).

# ** Section 12.4 <> Example: Encoding S-Expressions
** Seccion 12.4 <> Ejemplo: Codificacion de Expressions-S

#    @c(Display) is a debugging routine for displaying structured data, but it’s
#    not far short of being able to encode or @e(marshal) arbitrary Go objects as
#    messages in a portable notation suitable for inter-process communication.
   @c(Display) es una rutina de depuracion para la visualizacion de datos
   estructurados, pero no esta muy lejos de ser capaz de codificar u @e(ordenar)
   objetos Go arbitrarios como mensajes en una notacion portatil adecuada para
   la comunicacion entre procesos.

#    As we saw in @l(#Section 4.5), Go’s standard library supports a variety of
#    formats, including JSON, XML, and ASN.1. Another notation that is still
#    widely used is @e(S-expressions), the syntax of Lisp. Unlike the other
#    notations, S-expressions are not supported by the Go standard library, not
#    least because they have no universally accepted definition, despite several
#    attempts at standardization and the existence of many implementations.
   Como vimos en la @l(#Seccion 4.5), la libreria estandar de Go es compatible
   con una variedad de formatos, incluyendo JSON, XML y ASN.1. Otra indicacion
   de que todavia es ampliamente utilizado @e(expresiones-S), la sintaxis de
   Lisp. A diferencia de las otras notaciones, las expresiones-S no son
   compatibles con la libreria estandar de Go, no menos porque no tienen una
   definicion universalmente aceptada, a pesar de varios intentos de
   estandarizacion y la existencia de muchas implementaciones.

#    In this section, we’ll define a package that encodes arbitrary Go objects
#    using an S-expression notation that supports the following constructs:
   En esta seccion, definiremos un paquete que codifica objetos Go arbitrarios
   usando una notacion de expresiones-S que admita las siguientes construcciones:

#    | @c(42)      | integer                                             |
#    |-------------|-----------------------------------------------------|
#    | @c("hello") | string (with Go-style quotation)                    |
#    |-------------|-----------------------------------------------------|
#    | @c(foo)     | symbol (an unquoted name)                           |
#    |-------------|-----------------------------------------------------|
#    | @c[(1 2 3)] | list   (zero or more items enclosed in parentheses) |
   | @c(42)      | entero                                              |
   |-------------|-----------------------------------------------------|
   | @c("hello") | cadena  (con notacion en estilo Go)                 |
   |-------------|-----------------------------------------------------|
   | @c(foo)     | symbolo (un nombre sin cita)                        |
   |-------------|-----------------------------------------------------|
   | @c[(1 2 3)] | lista   (zero o mas elementos entre parentesis)     |

#    Booleans are traditionally encoded using the symbol @c(t) for true, and the
#    empty list @c[( )] or the symbol @c(nil) for false, but for simplicity, our
#    implementation ignores them. It also ignores channels and functions, since
#    their state is opaque to reflection. And it ignores real and complex
#    floating-point numbers and interfaces. Adding support for them is Exercise
#    12.3.
   Los booleanos tradicionalmente se codifican utilizando el simbolo @c(t) para
   la verdadero, y la lista vacia @c[()] o el simbolo @c(nil) para falso, pero
   por simplicidad, nuestra implementacion los ignora. Tambien ignora canales y
   funciones, ya que su estado es opaco a la reflexion. Y no hace caso de
   numeros reales y complejos de punto flotante e interfaces. Agregar soporte
   para ellos es el @l(#Ejercicio 12.3).

#    We’ll encode the types of Go using S-expressions as follows. Integers and
#    strings are encoded in the obvious way. Nil values are encoded as the symbol
#    @c(nil). Arrays and slices are encoded using list notation.
   Vamos a codificar los tipos de Go usando expresiones-S como sigue. Los
   enteros y las cadenas se codifican de la manera obvia. Los valores Nil se
   codifican como el simbolo @c(nil). Los arrays y slices se codifican
   utilizando la notacion de lista.

#    Structs are encoded as a list of field bindings, each field binding being a
#    two-element list whose first element (a symbol) is the field name and whose
#    second element is the field value. Maps too are encoded as a list of pairs,
#    with each pair being the key and value of one map entry. Traditionally,
#    S-expressions represent lists of key/value pairs using a single @e(cons) cell
#    @c[(key . value)] for each pair, rather than a two-element list, but to
#    simplify the decoding we’ll ignore dotted list notation.
   Las estructuras se codifican como una lista de campos enlazados, siendo cada
   enlace de campo una lista de dos elementos cuyo primer elemento (un simbolo)
   es el nombre del campo y cuyo segundo elemento es el valor del campo. Los
   mapas tambien se codifican como una lista de pares, siendo cada par la clave
   y el valor de una entrada de mapa. Tradicionalmente, las expresiones-S
   representan listas de pares clave/valor utilizando una sola celula @e(cons)
   @c[(key . value)] para cada par, en lugar de una lista de dos elementos, pero
   para simplificar la decodificacion ignoraremos la notacion de lista punteada.

#    Encoding is done by a single recursive function, @c(encode), shown below. Its
#    structure is essentially the same as that of @c(Display) in the previous
#    section:
   La codificacion se realiza por una sola funcion recursiva, @c(encode), que se
   muestra a continuacion. Su estructura es esencialmente la misma que la de
   @c(Display) en la seccion anterior:

#    ..figure > @l(gopl.io/ch12/sexpr/encode.go<>gopl.io/ch12/sexpr)
   ..figure > @l(gopl.io/ch12/sexpr/encode.go<>gopl.io/ch12/sexpr)

#      ..src > go
#        func encode(buf *bytes.Buffer, v reflect.Value) error {
#          switch v.Kind() {
#          case reflect.Invalid:
#            buf.WriteString("nil")
#
#          case reflect.Int, reflect.Int8, reflect.Int16,
#            reflect.Int32, reflect.Int64:
#            fmt.Fprintf(buf, "%d", v.Int())
#
#          case reflect.Uint, reflect.Uint8, reflect.Uint16,
#            reflect.Uint32, reflect.Uint64, reflect.Uintptr:
#            fmt.Fprintf(buf, "%d", v.Uint())
#
#          case reflect.String:
#            fmt.Fprintf(buf, "%q", v.String())
#
#          case reflect.Ptr:
#            return encode(buf, v.Elem())
#
#          case reflect.Array, reflect.Slice: // (value ...)
#            buf.WriteByte('(')
#            for i := 0; i < v.Len(); i++ {
#              if i > 0 {
#                buf.WriteByte(' ')
#              }
#              if err := encode(buf, v.Index(i)); err != nil {
#                return err
#              }
#            }
#            buf.WriteByte(')')
#
#          case reflect.Struct: // ((name value) ...)
#            buf.WriteByte('(')
#            for i := 0; i < v.NumField(); i++ {
#              if i > 0 {
#                buf.WriteByte(' ')
#              }
#              fmt.Fprintf(buf, "(%s ", v.Type().Field(i).Name)
#              if err := encode(buf, v.Field(i)); err != nil {
#                return err
#              }
#              buf.WriteByte(')')
#            }
#            buf.WriteByte(')')
#
#          case reflect.Map: // ((key value) ...)
#            buf.WriteByte('(')
#            for i, key := range v.MapKeys() {
#              if i > 0 {
#                buf.WriteByte(' ')
#              }
#              buf.WriteByte('(')
#              if err := encode(buf, key); err != nil {
#                return err
#              }
#              buf.WriteByte(' ')
#              if err := encode(buf, v.MapIndex(key)); err != nil {
#                return err
#              }
#              buf.WriteByte(')')
#            }
#            buf.WriteByte(')')
#
#          default: // float, complex, bool, chan, func, interface
#            return fmt.Errorf("unsupported type: %s", v.Type())
#          }
#          return nil
#        }
#      < src..
     ..src > go
       func encode(buf *bytes.Buffer, v reflect.Value) error {
         switch v.Kind() {
         case reflect.Invalid:
           buf.WriteString("nil")

         case reflect.Int, reflect.Int8, reflect.Int16,
           reflect.Int32, reflect.Int64:
           fmt.Fprintf(buf, "%d", v.Int())

         case reflect.Uint, reflect.Uint8, reflect.Uint16,
           reflect.Uint32, reflect.Uint64, reflect.Uintptr:
           fmt.Fprintf(buf, "%d", v.Uint())

         case reflect.String:
           fmt.Fprintf(buf, "%q", v.String())

         case reflect.Ptr:
           return encode(buf, v.Elem())

         case reflect.Array, reflect.Slice: // (value ...)
           buf.WriteByte('(')
           for i := 0; i < v.Len(); i++ {
             if i > 0 {
               buf.WriteByte(' ')
             }
             if err := encode(buf, v.Index(i)); err != nil {
               return err
             }
           }
           buf.WriteByte(')')

         case reflect.Struct: // ((name value) ...)
           buf.WriteByte('(')
           for i := 0; i < v.NumField(); i++ {
             if i > 0 {
               buf.WriteByte(' ')
             }
             fmt.Fprintf(buf, "(%s ", v.Type().Field(i).Name)
             if err := encode(buf, v.Field(i)); err != nil {
               return err
             }
             buf.WriteByte(')')
           }
           buf.WriteByte(')')

         case reflect.Map: // ((key value) ...)
           buf.WriteByte('(')
           for i, key := range v.MapKeys() {
             if i > 0 {
               buf.WriteByte(' ')
             }
             buf.WriteByte('(')
             if err := encode(buf, key); err != nil {
               return err
             }
             buf.WriteByte(' ')
             if err := encode(buf, v.MapIndex(key)); err != nil {
               return err
             }
             buf.WriteByte(')')
           }
           buf.WriteByte(')')

         default: // float, complex, bool, chan, func, interface
           return fmt.Errorf("unsupported type: %s", v.Type())
         }
         return nil
       }
     < src..


#    The @c(Marshal) function wraps the encoder in an API similar to those of the
#    other @c(encoding/...) packages:
   La funcion @c(Marshal) envuelve el codificador en una API similar a los de
   otros paquetes @c(encoding/...):

#    ..src > go
#      // Marshal encodes a Go value in S-expression form.
#      func Marshal(v interface{}) ([]byte, error) {
#        var buf bytes.Buffer
#        if err := encode(&buf, reflect.ValueOf(v)); err != nil {
#          return nil, err
#        }
#        return buf.Bytes(), nil
#      }
#    < src..
   ..src > go
     // Marshal codifica un valor Go en forma de expresion-S.
     func Marshal(v interface{}) ([]byte, error) {
       var buf bytes.Buffer
       if err := encode(&buf, reflect.ValueOf(v)); err != nil {
         return nil, err
       }
       return buf.Bytes(), nil
     }
   < src..

#    Here’s the output of @c(Marshal) applied to the @c(strangelove) variable from
#    @l(#Section 12.3):
   Aqui esta la salida que @c(Marshal) aplica a la variable @c(strangelove) de
   la @l(#Seccion 12.3):

#    ..src > lisp
#      ((Title "Dr. Strangelove") (Subtitle "How I Learned to Stop Worrying and Love the Bomb") (Year 1964) (Actor (("Grp. Capt. Lionel Mandrake" "Peter Sellers") ("Pres. Merkin Muffley" "Peter Sellers") ("Gen. Buck Turgidson" "George C. Scott") ("Brig. Gen. Jack D. Ripper" "Sterling Hayden") ("Maj. T.J. \"King\" Kong" "Slim Pickens") ("Dr. Strangelove" "Peter Sellers"))) (Oscars ("Best Actor (Nomin.)" "Best Adapted Screenplay (Nomin.)" "Best Director (Nomin.)" "Best Picture (Nomin.)")) (Sequel nil))
#    < src..
   ..src > lisp
     ((Title "Dr. Strangelove") (Subtitle "How I Learned to Stop Worrying and Love the Bomb") (Year 1964) (Actor (("Grp. Capt. Lionel Mandrake" "Peter Sellers") ("Pres. Merkin Muffley" "Peter Sellers") ("Gen. Buck Turgidson" "George C. Scott") ("Brig. Gen. Jack D. Ripper" "Sterling Hayden") ("Maj. T.J. \"King\" Kong" "Slim Pickens") ("Dr. Strangelove" "Peter Sellers"))) (Oscars ("Best Actor (Nomin.)" "Best Adapted Screenplay (Nomin.)" "Best Director (Nomin.)" "Best Picture (Nomin.)")) (Sequel nil))
   < src..

#    The whole output appears on one long line with minimal spaces, making it hard
#    to read.  Here’s the same output manually formatted according to S-expression
#    conventions. Writing a pretty-printer for S-expressions is left as a
#    (challenging) exercise; the download from @c(gopl.io) includes a simple
#    version.
   Toda la salida aparece en una linea larga con espacios minimos, por lo que es
   dificil de leer. Esta es la misma salida formateada manualmente de acuerdo
   con las convenciones de expresion-S. Escribir una bonita impresora para las
   expresiones-S se deja como un ejercicio (desafiante); la descarga de
   @c(gopl.io) incluye una version simple.

#    ..src > lisp
#      ((Title "Dr. Strangelove")
#       (Subtitle "How I Learned to Stop Worrying and Love the Bomb")
#       (Year 1964)
#       (Actor (("Grp. Capt. Lionel Mandrake" "Peter Sellers")
#               ("Pres. Merkin Muffley" "Peter Sellers")
#               ("Gen. Buck Turgidson" "George C. Scott")
#               ("Brig. Gen. Jack D. Ripper" "Sterling Hayden")
#               ("Maj. T.J. \"King\" Kong" "Slim Pickens")
#               ("Dr. Strangelove" "Peter Sellers")))
#       (Oscars ("Best Actor (Nomin.)"
#                "Best Adapted Screenplay (Nomin.)"
#                "Best Director (Nomin.)"
#                "Best Picture (Nomin.)"))
#       (Sequel nil))
#    < src..
   ..src > lisp
     ((Title "Dr. Strangelove")
      (Subtitle "How I Learned to Stop Worrying and Love the Bomb")
      (Year 1964)
      (Actor (("Grp. Capt. Lionel Mandrake" "Peter Sellers")
              ("Pres. Merkin Muffley" "Peter Sellers")
              ("Gen. Buck Turgidson" "George C. Scott")
              ("Brig. Gen. Jack D. Ripper" "Sterling Hayden")
              ("Maj. T.J. \"King\" Kong" "Slim Pickens")
              ("Dr. Strangelove" "Peter Sellers")))
      (Oscars ("Best Actor (Nomin.)"
               "Best Adapted Screenplay (Nomin.)"
               "Best Director (Nomin.)"
               "Best Picture (Nomin.)"))
      (Sequel nil))
   < src..

#    Like the @c(fmt.Print), @c(json.Marshal), and @c(Display) functions,
#    @c(sexpr.Marshal) will loop forever if called with cyclic data.
   Al igual las funciones @c(fmt.Print), @c(json.Marshal) y @c(Display),
   @c(sexpr.Marshal) entrara en un bucle infinito si es llamado con los datos
   ciclicos.

#    In @l(#Section 12.6), we’ll sketch out the implementation of the
#    corresponding S-expression decoding function, but before we get there, we’ll
#    first need to understand how reflection can be used to update program
#    variables.
   En la @l(#Seccion 12.6), esbozaremos la implementacion de la funcion de
   decodificacion de expreciones-S correspondiente, pero antes de llegar alli,
   primero debemos entender como se puede usar la reflexion para actualizar las
   variables del programa.

#    @b(Exercise 12.3): Implement the missing cases of the @c(encode)
#    function. Encode booleans as @c(t) and @c(nil), floating-point numbers using
#    Go’s notation, and complex numbers like @m(1+2i) as @c[#C(1.0
#    2.0)]. Interfaces can be encoded as a pair of a type name and a value, for
#    instance @c[("[]int" (1 2 3))], but beware that this notation is ambiguous:
#    the @c(reflect.Type.String) method may return the same string for different
#    types.
   @b(Ejercicio 12.3): Implementar los casos faltantes de la funcion @c(encode).
   Codifique booleanos como @c(t) y @c(nil), numeros de punto flotante
   utilizando la notacion de Go, y los numeros complejos como @m(1+2i) como
   @c[#C(1.0 2.0)]. Las interfaces se pueden codificar como un par de nombre de
   tipo y un valor, por ejemplo @c[("[]int" (1 2 3))], pero cuidado que esta
   notacion es ambigua: el metodo @c(reflect.Type.String) puede devolver la
   misma cadena para diferentes tipos.

#    @b(Exercise 12.4): Modify @c(encode) to pretty-print the S-expression in the
#    style shown above.
   @b(Ejercicio 12.4): Modifique @c(encode) para imprimir expresiones-S con el
   estilo mostrado anteriormente.

#    @b(Exercise 12.5): Adapt @c(encode) to emit JSON instead of S-expressions. Test
#    your encoder using the standard decoder, @c(json.Unmarshal).
   @b(Ejercicio 12.5): Adapte @c(encode) para producir JSON en lugar de
   expresiones-S. Pruebe su codificador utilizando el descodificador estandar,
   @c(json.Unmarshal).

#    @b(Exercise 12.6): Adapt @c(encode) so that, as an optimization, it does not
#    encode a field whose value is the zero value of its type.
   @b(Ejercicio 12.6): Adapte @c(encode) para que a manera de optimizacion, no
   codifique un campo cuyo valor es el valor cero de su tipo.

#    @b(Exercise 12.7): Create a streaming API for the S-expression decoder,
#    following the style of @c(json.Decoder) (@l(#Section 4.5<>§4.5)).
   @b(Ejercicio 12.7): Crear un API de streaming para el decodificador de
   expresiones-S, siguiendo el estilo de @c(json.Decoder) (@l(#Seccion
   4.5<>§4.5)).

# ** Section 12.5 <> Setting Variables with @c(reflect.Value)
** Seccion 12.5 <> Configurar Variables con @c(reflect.Value)

#    So far, reflection has only @e(interpreted) values in our program in various
#    ways. The point of this section, however, is to @e(change) them.
   Hasta el momento, la reflexion solo ha @e(interpretado) los valores en
   nuestro programa de diversas maneras. El punto de esta seccion, es
   @c(cambiarlos).

#    Recall that some Go expressions like @c(x), @c(x.f[1]), and @c(*p) denote
#    variables, but others like @c(x + 1) and @c[f(2)] do not. A variable is an
#    @e(addressable) storage location that contains a value, and its value may be
#    updated through that address.
   Recordemos que algunas expresiones van como @c(x), @c(x.f[1]), y @c(*p)
   denotan variables, pero otras como @c(x + 1) y @c[f(2)] no. Una variable es
   una ubicacion de almacenamiento @e(direccionable) que contiene un valor, y su
   valor puede ser actualizado a traves de esa direccion.

#    A similar distinction applies to @c(reflect.Values). Some are addressable;
#    others are not.  Consider the following declarations:
   Una distincion similar se aplica a @c(reflect.Values). Algunos son
   direccionables; Otros no lo son. Considere las siguientes declaraciones:

#    ..src > go
#      x := 2                     // value   type   variable?
#      a := reflect.ValueOf(2)    // 2       int    no
#      b := reflect.ValueOf(x)    // 2       int    no
#      c := reflect.ValueOf(&x)   // &x      *int   no
#      d := c.Elem()              // 2       int    yes (x)
#    < src..
   ..src > go
     x := 2                     // valor   tipo   variable?
     a := reflect.ValueOf(2)    // 2       int    no
     b := reflect.ValueOf(x)    // 2       int    no
     c := reflect.ValueOf(&x)   // &x      *int   no
     d := c.Elem()              // 2       int    si (x)
   < src..


#    The value within @c(a) is not addressable. It is merely a copy of the
#    integer 2. The same is true of @c(b). The value within @c(c) is also
#    non-addressable, being a copy of the pointer value @c(&x). In fact, no
#    @c(reflect.Value) returned by @c[reflect.ValueOf(x)] is addressable. But
#    @c(d), derived from @c(c) by dereferencing the pointer within it, refers to a
#    variable and is thus addressable. We can use this approach, calling
#    @c[reflect.ValueOf(&x).Elem()], to obtain an addressable @c(Value) for any
#    variable @c(x).
   El valor dentro de @c(a) no es direccionable. Se trata simplemente de una
   copia del entero 2. Lo mismo es cierto para @c(b). El valor dentro de @c(c)
   tambien es no direccionable, siendo una copia del valor de puntero @c(&x). De
   hecho, @c(reflect.Value) devuelto por @c[reflect.ValueOf(x)] no es
   direccionable. Pero @c(d), derivado de @c(c) mediante la desreferenciacion
   del puntero un su interior, se refiere a una variable y es, por tanto
   direccionable. Podemos utilizar este enfoque, llamando a
   @c[reflect.ValueOf(&x).Elem()], para obtener un @c(Value) direccionable de
   cualquier variable @c(x).

#    We can ask a @c(reflect.Value) whether it is addressable through its
#    @c(CanAddr) method:
   Podemos pregruntar a @c(reflect.Value) si es direccionable a traves de su
   metodo @c(CanAddr):

#    ..src > go
#      fmt.Println(a.CanAddr()) // "false"
#      fmt.Println(b.CanAddr()) // "false"
#      fmt.Println(c.CanAddr()) // "false"
#      fmt.Println(d.CanAddr()) // "true"
#    < src..
   ..src > go
     fmt.Println(a.CanAddr()) // "false"
     fmt.Println(b.CanAddr()) // "false"
     fmt.Println(c.CanAddr()) // "false"
     fmt.Println(d.CanAddr()) // "true"
   < src..

#    We obtain an addressable @c(reflect.Value) whenever we indirect through a
#    pointer, even if we started from a non-addressable @c(Value). All the usual
#    rules for addressability have analogs for reflection. For example, since the
#    slice indexing expression @c(e[i]) implicitly follows a pointer, it is
#    addressable even if the expression @c(e) is not. By analogy,
#    @c[reflect.ValueOf(e).Index(i)] refers to a variable, and is thus addressable
#    even if @c[reflect.ValueOf(e)] is not.
   Obtenemos un @c(reflect.Value) direccionable siempre indirectamente atravez
   de un puntero, incluso si partimos de un @c(Value) no-direccionable . Todas
   las reglas habituales de direccionabilidad tienen analogos para la
   reflexion. Por ejemplo, ya que la expresion de indexacion de un slice
   @c(e[i]) sigue implicitamente un puntero, es direccionable incluso si la
   expresion @c(e) no lo es. Por analogia, @c[reflect.ValueOf(e).Index(i)] se
   refiere a una variable, y por tanto es direccionable incluso si
   @c[reflect.ValueOf(e)] no lo es.

#    To recover the variable from an addressable @c(reflect.Value) requires three
#    steps. First, we call @c[Addr()], which returns a Value holding a pointer to
#    the variable. Next, we call @c[Interface()] on this @c(Value), which returns
#    an @c(interface{}) value containing the pointer. Finally, if we know the type
#    of the variable, we can use a type assertion to retrieve the contents of the
#    interface as an ordinary pointer. We can then update the variable through the
#    pointer:
   Para recuperar la variable de un @c(reflect.Value) direccionable requiere
   tres pasos. En primer lugar, llamamos a @c[Addr()], que devuelve un valor que
   contiene un puntero a la variable. Despues, llamamos a @c[Interface()] en
   este @c(Value), que devuelve un valor @c[interface{}] que contiene el
   puntero. Finalmente, si sabemos el tipo de la variable, podemos usar una
   asercion de tipo para recuperar el contenido de la interfaz como un puntero
   comun. A continuacion, podemos actualizar la variable a traves del puntero:

#    ..src > go
#      x := 2
#      d := reflect.ValueOf(&x).Elem()    // d refers to the variable x
#      px := d.Addr().Interface().(*int)  // px := &x
#      *px = 3                            // x = 3
#      fmt.Println(x)                     // "3"
#    < src..
   ..src > go
     x := 2
     d := reflect.ValueOf(&x).Elem()    // d referencia a la variable x
     px := d.Addr().Interface().(*int)  // px := &x
     *px = 3                            // x = 3
     fmt.Println(x)                     // "3"
   < src..

#    Or, we can update the variable referred to by an addressable
#    @c(reflect.Value) directly, without using a pointer, by calling the
#    @c(reflect.Value.Set) method:
   O bien, podemos actualizar la variable a la que hace referencia
   @c(reflect.Value) directamente, sin necesidad de utilizar un puntero,
   llamando al metodo @c(reflect.Value.Set):

#    ..src > go
#      d.Set(reflect.ValueOf(4))
#      fmt.Println(x) // "4"
#    < src..
   ..src > go
     d.Set(reflect.ValueOf(4))
     fmt.Println(x) // "4"
   < src..

#    The same checks for assignability that are ordinarily performed by the
#    compiler are done at run time by the @c(Set) methods. Above, the variable and
#    the value both have type @c(int), but if the variable had been an @c(int64),
#    the program would panic, so it’s crucial to make sure the value is assignable
#    to the type of the variable:
   Las mismas comprobaciones de asignabilidad que normalmente se realizan por el
   compilador se realizan en tiempo de ejecucion por los metodos
   @c[Set]. Arriba, la variable y el valor tienen el tipo @c(int), pero si la
   variable habia sido un @c(int64), el programa entrara en panico, por lo que
   es crucial asegurarse de que el valor sea asignable al tipo de la variable:

#    ..src > go
#      d.Set(reflect.ValueOf(int64(5))) // panic: int64 is not assignable to int
#    < src..
   ..src > go
     d.Set(reflect.ValueOf(int64(5))) // panico: int64 no es asignable a int
   < src..

#    And of course calling @c(Set) on a non-addressable @c(reflect.Value) panics
#    too:
   Y, por supuesto, llamando a @c(Set) sobre un @c(reflect.Value) no
   direccionable tambien entra en panico:

#    ..src > go
#      x := 2
#      b := reflect.ValueOf(x)
#      b.Set(reflect.ValueOf(3)) // panic: Set using unaddressable value
#    < src..
   ..src > go
     x := 2
     b := reflect.ValueOf(x)
     b.Set(reflect.ValueOf(3)) // panico: se utiliza Set con un valor no direccionable
   < src..

#    There are variants of @c(Set) specialized for certain groups of basic types:
#    @c(SetInt), @c(SetUint), @c(SetString), @c(SetFloat), and so on:
   Hay variantes de @c(Set) especializadas para ciertos grupos de tipos basicos:
   @c(SetInt), @c(SetUint), @c(SetString), @c(SetFloat), y demas:

#    ..src > go
#      d := reflect.ValueOf(&x).Elem()
#      d.SetInt(3)
#      fmt.Println(x) // "3"
#    < src..
   ..src > go
     d := reflect.ValueOf(&x).Elem()
     d.SetInt(3)
     fmt.Println(x) // "3"
   < src..

#    In some ways these methods are more forgiving. @c(SetInt), for example, will
#    succeed so long as the variable’s type is some kind of signed integer, or
#    even a named type whose underlying type is a signed integer, and if the value
#    is too large it will be quietly truncated to fit. But tread carefully:
#    calling @c(SetInt) on a @c(reflect.Value) that refers to an @c(interface{})
#    variable will panic, even though @c(Set) would succeed.
   En algunos aspectos, estos metodos son mas tolerantes. @c(SetInt), por
   ejemplo, tendra exito siempre y cuando el tipo de la variable sea algun tipo
   de entero con signo, o incluso un tipo con nombre cuyo tipo subyacente es un
   entero con signo, y si el valor es demasiado grande sera truncado en silencio
   para ajustarse. Pero pise con cuidado: llamar a @c(SetInt) en un
   @c(reflect.Value) que se refiere a una variable @c[interface{}] entrara en
   panico, aunque @c(Set) tendria exito.

#    ..src > go
#      x := 1
#      rx := reflect.ValueOf(&x).Elem()
#      rx.SetInt(2)                     // OK, x = 2
#      rx.Set(reflect.ValueOf(3))       // OK, x = 3
#      rx.SetString("hello")            // panic: string is not assignable to int
#      rx.Set(reflect.ValueOf("hello")) // panic: string is not assignable to int
#
#      var y interface{}
#      ry := reflect.ValueOf(&y).Elem()
#      ry.SetInt(2)                     // panic: SetInt called on interface Value
#      ry.Set(reflect.ValueOf(3))       // OK, y = int(3)
#      ry.SetString("hello")            // panic: SetString called on interface Value
#      ry.Set(reflect.ValueOf("hello")) // OK, y = "hello"
#    < src..
   ..src > go
     x := 1
     rx := reflect.ValueOf(&x).Elem()
     rx.SetInt(2)                     // OK, x = 2
     rx.Set(reflect.ValueOf(3))       // OK, x = 3
     rx.SetString("hello")            // panic: string no es asignable a int
     rx.Set(reflect.ValueOf("hello")) // panic: string no es asignable a int

     var y interface{}
     ry := reflect.ValueOf(&y).Elem()
     ry.SetInt(2)                     // panico: SetInt llamada con un Valoe interface
     ry.Set(reflect.ValueOf(3))       // OK, y = int(3)
     ry.SetString("hello")            // panico: SetString llamada en un Value interface
     ry.Set(reflect.ValueOf("hello")) // OK, y = "hello"
   < src..

#    When we applied @c(Display) to @c(os.Stdout), we found that reflection can
#    read the values of unexported struct fields that are inaccessible according
#    to the usual rules of the language, like the @c(fd int) field of an
#    @c(os.File) struct on a Unix-like platform. However, reflection cannot update
#    such values:
   Cuando aplicamos @c(Display) a @c(os.Stdout), encontramos que la reflexion
   puede leer los valores de los campos no exportados de estructuras que son
   inaccesibles segun las reglas usuales del lenguaje, como el campo @c(fd int)
   de una estructura @c(os.File) en una plataforma Unix. Sin embargo, la
   reflexion no puede actualizar estos valores:

#    ..src > go
#      stdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, an os.File var
#      fmt.Println(stdout.Type())                  // "os.File"
#      fd := stdout.FieldByName("fd")
#      fmt.Println(fd.Int()) // "1"
#      fd.SetInt(2)          // panic: unexported field
#    < src..
   ..src > go
     stdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, una variable os.File
     fmt.Println(stdout.Type())                  // "os.File"
     fd := stdout.FieldByName("fd")
     fmt.Println(fd.Int()) // "1"
     fd.SetInt(2)          // panico: capo sin exportar
   < src..

#    An addressable @c(reflect.Value) records whether it was obtained by
#    traversing an unexported struct field and, if so, disallows
#    modification. Consequently, @c(CanAddr) is not usually the right check to use
#    before setting a variable. The related method @c(CanSet) reports whether a
#    @c(reflect.Value) is addressable @e(and) settable:
   Un @c(reflect.Value) direccionable registra si se obtuvo al atravesar el
   campo sin exportar de una estructura y, si es asi, no permite la
   modificacion. En consecuencia, @c(CanAddr) no suele ser la comprobacion
   correcta a utilizar antes de establecer una variable. El metodo relacionado
   @c(CanSet) informa si un @c(reflect.Value) es direccionable @e(y) asignable:

#    ..src > go
#      fmt.Println(fd.CanAddr(), fd.CanSet()) // "true false"
#    < src..
   ..src > go
     fmt.Println(fd.CanAddr(), fd.CanSet()) // "true false"
   < src..

# ** Section 12.6 <> Example: Decoding S-Expressions
** Seccion 12.6 <> Ejemplo: Descodificar Expressions-S

#    For each @c(Marshal) function provided by the standard library’s
#    @c(encoding/...) packages, there is a corresponding @c(Unmarshal) function
#    that does decoding. For example, as we saw in @l(#Section 4.5), given a byte
#    slice containing JSON-encoded data for our @c(Movie) type (@l(#Section
#    12.3<>§12.3)), we can decode it like this:
   Por cada funcion @c(Marshal) proporcionada por los paquetes @c(encoding/...)
   de la libreria estandar, hay una funcion correspondiente @c(Unmarshal) que
   realiza la decodificacion. Por ejemplo, como vimos en la @l(#Seccion 4.5),
   dada un slice de bytes que contiene datos codificados JSON para nuestro tipo
   @c(Movie) (@l(#Seccion 12.3<>§12.3)), podemos decodificarla asi:

#    ..src > go
#      data := []byte{/* ... */}
#      var movie Movie
#      err := json.Unmarshal(data, &movie)
#    < src..
   ..src > go
     data := []byte{/* ... */}
     var movie Movie
     err := json.Unmarshal(data, &movie)
   < src..

#    The @c(Unmarshal) function uses reflection to modify the fields of the
#    existing @c(movie) variable, creating new maps, structs, and slices as
#    determined by the type @c(Movie) and the content of the incoming data.
   la funcion @c(Unmarshal) utiliza la reflexion para modificar los campos de la
   variable @c(movie) actual, creando nuevos mapas, estructuras, y las slices
   segun lo determinado por el tipo @c(Movie) y el contenido de los datos
   entrantes.

#    Let’s now implement a simple @c(Unmarshal) function for S-expressions,
#    analogous to the standard @c(json.Unmarshal) function used above, and the
#    inverse of our earlier @c(sexpr.Marshal). We must caution you that a robust
#    and general implementation requires substantially more code than will
#    comfortably fit in this example, which is already long, so we have taken many
#    shortcuts. We support only a limited subset of S-expressions and do not
#    handle errors gracefully. The code is intended to illustrate reflection, not
#    parsing.
   Ahora vamos a poner en practica una simple funcion @c(Unmarshal) para
   expresiones-S, analoga a la funcion estandar @c(json.Unmarshal) utilizada
   anteriormente, y la inversa de nuestra anterior @c(sexpr.Marshal). Debemos
   advertirle que una implementacion robusta y general requiere mucho mas codigo
   del que encajaria comodamente en este ejemplo, que ya es largo, asi que hemos
   tomado muchos atajos. Soportamos solo un subconjunto limitado de
   expresiones-S y no manejamos errores con gracia. El codigo pretende ilustrar
   la reflexion, no el analisis.

#    The lexer uses the @c(Scanner) type from the @c(text/scanner) package to
#    break an input stream into a sequence of tokens such as comments,
#    identifiers, string literals, and numeric literals.  The scanner’s @c(Scan)
#    method advances the scanner and returns the kind of the next token, which has
#    type @c(rune). Most tokens, like @c['('], consist of a single rune, but the
#    @c(text/scanner) package represents the kinds of the multi-character tokens
#    @c(Ident), @c(String), and @c(Int) using small negative values of type
#    @c(rune). Following a call to @c(Scan) that returns one of these kinds of
#    token, the scanner’s @c(TokenText) method returns the text of the token.
   El lexer utiliza el tipo @c(Scanner) del paquete @c(text/scanner) para romper
   una corriente de entrada en una secuencia de tokens como comentarios,
   identificadores, literales de cadena, y literales numericos. El metodo del
   @c(Scan) del escaner avanza el escaner y devuelve el tipo del siguiente
   token, que tiene el tipo @c(rune). La mayoria de los tokens, como @c['('],
   consisten en una sola runa, pero el paquete @c(text/scanner) representa el
   tipo de tokens de caracteres multiples @c(Ident), @c(String), e @c(Int)
   usando pequeños valores negativos del tipo @c(rune). Despues de una llamada a
   @c(Scan) que devuelve uno de estos tipos de token, el metodo @c(TokenText) de
   escaner devuelve el texto del token.

#    Since a typical parser may need to inspect the current token several times,
#    but the @c(Scan) method advances the scanner, we wrap the scanner in a helper
#    type called @c(lexer) that keeps track of the token most recently returned by
#    @c(Scan).
   Ya que un analizador tipico puede tener que inspeccionar el token actual
   varias veces, pero el metodo @c(Scan) avanza el escaner, envolvemos el
   escaner en un tipo auxiliar llamado @c(lexer) que realiza un seguimiento del
   token recientemente devuelto por @c(Scan).

#    ..figure > @l(gopl.io/ch12/sexpr/decode.go<>gopl.io/ch12/sexpr)
   ..figure > @l(gopl.io/ch12/sexpr/decode.go<>gopl.io/ch12/sexpr)

#      ..src > go
#        type lexer struct {
#          scan  scanner.Scanner
#          token rune // the current token
#        }
#
#        func (lex *lexer) next()        { lex.token = lex.scan.Scan() }
#        func (lex *lexer) text() string { return lex.scan.TokenText() }
#
#        func (lex *lexer) consume(want rune) {
#          if lex.token != want { // NOTE: Not an example of good error handling.
#            panic(fmt.Sprintf("got %q, want %q", lex.text(), want))
#          }
#          lex.next()
#        }
#      < src..
     ..src > go
       type lexer struct {
         scan  scanner.Scanner
         token rune // the current token
       }

       func (lex *lexer) next()        { lex.token = lex.scan.Scan() }
       func (lex *lexer) text() string { return lex.scan.TokenText() }

       func (lex *lexer) consume(want rune) {
         if lex.token != want { // NOTA: No es un ejemplo de buen manejo de errores.
           panic(fmt.Sprintf("got %q, want %q", lex.text(), want))
         }
         lex.next()
       }
     < src..


#    Now let’s turn to the parser. It consists of two principal functions. The
#    first of these, @c(read), reads the S-expression that starts with the current
#    token and updates the variable referred to by the addressable
#    @c(reflect.Value v).
   Ahora pasemos al analizador sintactico. Consiste en dos funciones
   principales. La primera, @c(read), lee la expresion-S que comienza con el
   token actual y actualiza la variable referida por el @c(reflect.Value v)
   direccionable.

#    ..src > go
#      func read(lex *lexer, v reflect.Value) {
#        switch lex.token {
#        case scanner.Ident:
#          // The only valid identifiers are
#          // "nil" and struct field names.
#          if lex.text() == "nil" {
#            v.Set(reflect.Zero(v.Type()))
#            lex.next()
#            return
#          }
#        case scanner.String:
#          s, _ := strconv.Unquote(lex.text()) // NOTE: ignoring errors
#          v.SetString(s)
#          lex.next()
#          return
#        case scanner.Int:
#          i, _ := strconv.Atoi(lex.text()) // NOTE: ignoring errors
#          v.SetInt(int64(i))
#          lex.next()
#          return
#        case '(':
#          lex.next()
#          readList(lex, v)
#          lex.next() // consume ')'
#          return
#        }
#        panic(fmt.Sprintf("unexpected token %q", lex.text()))
#      }
#    < src..
   ..src > go
     func read(lex *lexer, v reflect.Value) {
       switch lex.token {
       case scanner.Ident:
         // Los unicos identificadores validos son
         // "nil" y campos con nombre en estructuras.
         if lex.text() == "nil" {
           v.Set(reflect.Zero(v.Type()))
           lex.next()
           return
         }
       case scanner.String:
         s, _ := strconv.Unquote(lex.text()) // NOTA: ignorando errores
         v.SetString(s)
         lex.next()
         return
       case scanner.Int:
         i, _ := strconv.Atoi(lex.text()) // NOTA: ignorando errores
         v.SetInt(int64(i))
         lex.next()
         return
       case '(':
         lex.next()
         readList(lex, v)
         lex.next() // consume ')'
         return
       }
       panic(fmt.Sprintf("unexpected token %q", lex.text()))
     }
   < src..

#    Our S-expressions use identifiers for two distinct purposes, struct field
#    names and the @c(nil) value for a pointer. The @c(read) function only handles
#    the latter case. When it encounters the @c(scanner.Ident) @"(@c(nil)), it sets
#    @c(v) to the zero value of its type using the @c(reflect.Zero) function.  For
#    any other identifier, it reports an error. The @c(readList) function, which
#    we’ll see in a moment, handles identifiers used as struct field names.
   Nuestras expresiones-S utilizan identificadores para dos propositos
   distintos, nombres de campo en estructuras y el valor de un puntero
   @c(nil). La funcion @c(read) solo se ocupa de este ultimo caso. Cuando
   @c(scanner.Ident) se encuentra con @"(@c(nil)), establece @c(v) a el valor
   cero de su tipo usando la funcion @c(reflect.Zero). Para cualquier otro
   identificador, informa de un error. la funcion @c(readList), que veremos en
   un momento, maneja identificadores utilizados como nombres de campo
   estructura.

#    A @c['('] token indicates the start of a list. The second function,
#    @c(readList), decodes a list into a variable of composite type—a map, struct,
#    slice, or array—depending on what kind of Go variable we’re currently
#    populating. In each case, the loop keeps parsing items until it encounters
#    the matching close parenthesis, @c[')'], as detected by the @c(endList)
#    function.
   Un token @c['('] indica el comienzo de una lista. La segunda funcion,
   @c(readList), decodifica una lista en una variable de tipo compuesto–un mapa,
   estructura, slice, o arreglo–dependiendo el tipo de variable Go que estamos
   rellenando actualmente. En cada caso, el bucle mantiene el analisis de
   elementos hasta encontrar el parentesis de cierre correspondiente, @c[')'],
   detectado por la funcion @c(endList).

#    The interesting part is the recursion. The simplest case is an array. Until
#    the closing @c[')'] is seen, we use @c(Index) to obtain the variable for each
#    array element and make a recursive call to @c(read) to populate it. As in
#    many other error cases, if the input data causes the decoder to index beyond
#    the end of the array, the decoder panics. A similar approach is used for
#    slices, except we must create a new variable for each element, populate it,
#    then append it to the slice.
   La parte interesante es la recursion. El caso mas sencillo es un arreglo.
   Hasta que se ve el cierre @c[')'], utilizamos @c(Index) para obtener la
   variable para cada elemento del arreglo y hacer una llamada recursiva a
   @c(read) para rellenarla. Como en muchos otros casos de error, si los datos
   de entrada hacen que el decodificador se indexe mas alla del final del
   arreglo, el descodificador entrara en panico. Un metodo similar se utiliza
   para los slices, excepto que debemos crear una nueva variable para cada
   elemento, rellenarlo y, a continuacion, añadirlo a la porcion.

#    The loops for structs and maps must parse a @c[(key value)] sublist on each
#    iteration. For structs, the key is a symbol identifying the field. Analogous
#    to the case for arrays, we obtain the existing variable for the struct field
#    using @c(FieldByName) and make a recursive call to populate it. For maps, the
#    key may be of any type, and analogous to the case for slices, we create a new
#    variable, recursively populate it, and finally insert the new key/value pair
#    into the map.
   Los bucles de estructuras y mapas deben analizar una sublista @c[(key value)]
   en cada iteracion. Para las estructuras, la clave es un simbolo que
   identifica el campo. Analogo al caso de los arreglos, obtenemos la variable
   existente para el campo struct usando @c(FieldByName) y realizamos una
   llamada recursiva para llenarla. Para los mapas, la clave puede ser de
   cualquier tipo, y de forma analoga al caso de los slices, creamos una nueva
   variable, rellenandola de forma recursiva y finalmente insertamos el nuevo
   par clave/valor en el mapa.

#    ..src > go
#      func readList(lex *lexer, v reflect.Value) {
#        switch v.Kind() {
#        case reflect.Array: // (item ...)
#          for i := 0; !endList(lex); i++ {
#            read(lex, v.Index(i))
#          }
#
#        case reflect.Slice: // (item ...)
#          for !endList(lex) {
#            item := reflect.New(v.Type().Elem()).Elem()
#            read(lex, item)
#            v.Set(reflect.Append(v, item))
#          }
#
#        case reflect.Struct: // ((name value) ...)
#          for !endList(lex) {
#            lex.consume('(')
#            if lex.token != scanner.Ident {
#              panic(fmt.Sprintf("got token %q, want field name", lex.text()))
#            }
#            name := lex.text()
#            lex.next()
#            read(lex, v.FieldByName(name))
#            lex.consume(')')
#          }
#
#        case reflect.Map: // ((key value) ...)
#          v.Set(reflect.MakeMap(v.Type()))
#          for !endList(lex) {
#            lex.consume('(')
#            key := reflect.New(v.Type().Key()).Elem()
#            read(lex, key)
#            value := reflect.New(v.Type().Elem()).Elem()
#            read(lex, value)
#            v.SetMapIndex(key, value)
#            lex.consume(')')
#          }
#
#        default:
#          panic(fmt.Sprintf("cannot decode list into %v", v.Type()))
#        }
#      }
#
#      func endList(lex *lexer) bool {
#        switch lex.token {
#        case scanner.EOF:
#          panic("end of file")
#        case ')':
#          return true
#        }
#        return false
#      }
#    < src..
   ..src > go
     func readList(lex *lexer, v reflect.Value) {
       switch v.Kind() {
       case reflect.Array: // (item ...)
         for i := 0; !endList(lex); i++ {
           read(lex, v.Index(i))
         }

       case reflect.Slice: // (item ...)
         for !endList(lex) {
           item := reflect.New(v.Type().Elem()).Elem()
           read(lex, item)
           v.Set(reflect.Append(v, item))
         }

       case reflect.Struct: // ((name value) ...)
         for !endList(lex) {
           lex.consume('(')
           if lex.token != scanner.Ident {
             panic(fmt.Sprintf("got token %q, want field name", lex.text()))
           }
           name := lex.text()
           lex.next()
           read(lex, v.FieldByName(name))
           lex.consume(')')
         }

       case reflect.Map: // ((key value) ...)
         v.Set(reflect.MakeMap(v.Type()))
         for !endList(lex) {
           lex.consume('(')
           key := reflect.New(v.Type().Key()).Elem()
           read(lex, key)
           value := reflect.New(v.Type().Elem()).Elem()
           read(lex, value)
           v.SetMapIndex(key, value)
           lex.consume(')')
         }

       default:
         panic(fmt.Sprintf("cannot decode list into %v", v.Type()))
       }
     }

     func endList(lex *lexer) bool {
       switch lex.token {
       case scanner.EOF:
         panic("end of file")
       case ')':
         return true
       }
       return false
     }
   < src..

#    Finally, we wrap up the parser in an exported function @c(Unmarshal), shown
#    below, that hides some of the rough edges of the implementation. Errors
#    encountered during parsing result in a panic, so @c(Unmarshal) uses a
#    deferred call to recover from the panic (@l(#Section 5.10<>§5.10)) and return
#    an error message instead.
   Finalmente, terminamos el analizador en una funcion exportada @c(Unmarshal),
   que se muestra a continuacion, que esconde algunas de las asperezas de la
   aplicacion. Los errores encontrados durante el analisis dan lugar a un
   panico, por lo que @c(Unmarshal) utiliza una llamada diferida para
   recuperarse del panico (@l(#Seccion 5.10<>§5.10)) y devolvera un mensaje de
   error.

#    ..src > go
#      // Unmarshal parses S-expression data and populates the variable
#      // whose address is in the non-nil pointer out.
#      func Unmarshal(data []byte, out interface{}) (err error) {
#        lex := &lexer{scan: scanner.Scanner{Mode: scanner.GoTokens}}
#        lex.scan.Init(bytes.NewReader(data))
#        lex.next() // get the first token
#        defer func() {
#          // NOTE: this is not an example of ideal error handling.
#          if x := recover(); x != nil {
#            err = fmt.Errorf("error at %s: %v", lex.scan.Position, x)
#          }
#        }()
#        read(lex, reflect.ValueOf(out).Elem())
#        return nil
#      }
#    < src..
   ..src > go
     // Unmarshal analiza datos de expresiones-S y rellena la variable
     // cuya direccion esta en el puntero out no-nil.
     func Unmarshal(data []byte, out interface{}) (err error) {
       lex := &lexer{scan: scanner.Scanner{Mode: scanner.GoTokens}}
       lex.scan.Init(bytes.NewReader(data))
       lex.next() // obtiene el primer token
       defer func() {
         // NOTE: this is not an example of ideal error handling.
         if x := recover(); x != nil {
           err = fmt.Errorf("error at %s: %v", lex.scan.Position, x)
         }
       }()
       read(lex, reflect.ValueOf(out).Elem())
       return nil
     }
   < src..

#    A production-quality implementation should never panic for any input and
#    should report an informative error for every mishap, perhaps with a line
#    number or offset. Nonetheless, we hope this example conveys some idea of
#    what’s happening under the hood of the packages like @c(encoding/json), and
#    how you can use reflection to populate data structures.
   Una implementacion de calidad de produccion nunca debe entrar en panico para
   cualquier entrada y debe informar un error informativo para cada
   contratiempo, tal vez con un numero de linea o desplazamiento. No obstante,
   esperamos que este ejemplo transmita una idea de lo que esta sucediendo bajo
   el capo de paquetes como @c(encoding/json), y como se puede utilizar la
   reflexion para poblar las estructuras de datos.

#    @b(Exercise 12.8): The @c(sexpr.Unmarshal) function, like @c(json.Marshal),
#    requires the complete input in a byte slice before it can begin
#    decoding. Define a @c(sexpr.Decoder) type that, like @c(json.Decoder), allows
#    a sequence of values to be decoded from an @c(io.Reader). Change
#    @c(sexpr.Unmarshal) to use this new type.
   @b(Ejercicio 12.8): La funcion @c(sexpr.Unmarshal), como @c(json.Marshal),
   requiere la entrada completa en un slice de bytes antes de que pueda comenzar
   la decodificacion. Defina un tipo @c(sexpr.Decoder) que como
   @c(json.Decoder), permite que una secuencia de valores sea decodificada desde
   un @c(io.Reader). Cambiar @c(sexpr.Unmarshal) para utilizar este nuevo tipo.

#    @b(Exercise 12.9): Write a token-based API for decoding S-expressions,
#    following the style of @c(xml.Decoder) (@l(#Section 7.14<>§7.14)). You will
#    need five types of tokens: @c(Symbol), @c(String), @c(Int), @c(StartList),
#    and @c(EndList).
   @b(Ejercicio 12.9): Escriba una API basada en tokens para decodificar
   expresiones-S, siguiendo el estilo de @c(xml.Decoder) (@l(#Seccion
   7.14<>§7.14)). Necesitara cinco tipos de tokens: @c(Symbol), @c(String),
   @c(Int), @c(StartList) y @c(EndList).

#    @b(Exercise 12.10): Extend @c(sexpr.Unmarshal) to handle the booleans,
#    floating-point numbers, and interfaces encoded by your solution to Exercise
#    12.3. (Hint: to decode interfaces, you will need a mapping from the name of
#    each supported type to its @c(reflect.Type).)
   @b(Ejercicio 12.10): Extienda @c(sexpr.Unmarshal) para manejar booleanos,
   numeros de punto flotante, e interfaces codificadas con su solucion al
   Ejercicio 12.3. (Sugerencia: para decodificar interfaces, se necesitara una
   asignacion del nombre de cada tipo soportado a su @c(reflect.Type)).

# ** Section 12.7 <> Accessing Struct Field Tags
** Seccion 12.7 <> Accediendo a Etiquetas de Campo en Estructuras

#    In @l(#Section 4.5) we used struct @e(field tags) to modify the JSON encoding
#    of Go struct values. The @c(json) field tag lets us choose alternative field
#    names and suppress the output of empty fields. In this section, we’ll see how
#    to access field tags using reflection.
   En la @l(#Seccion 4.5) utilizamos @e(etiquetas de campo) de estructura para
   modificar la codificacion de valores JSON de estructuras Go. La etiqueta de
   campo @c(json) nos permite escoger nombres de campos alternativos y suprimir
   la salida de los campos vacios. En esta seccion, veremos como acceder a las
   etiquetas de campo mediante la reflexion.

#    In a web server, the first thing most HTTP handler functions do is extract
#    the request parameters into local variables. We’ll define a utility function,
#    @c(params.Unpack), that uses struct field tags to make writing HTTP handlers
#    (@l(#Section 7.7<>§7.7)) more convenient.
   En un servidor web, lo primero que hace la mayoria de las funciones del
   controlador HTTP es extraer los parametros de la peticion en variables
   locales. Vamos a definir una funcion de utilidad, @c(params.Unpack), que
   utiliza etiquetas de campos de estructura para que los manipuladores de la
   escritura HTTP (@l(#Seccion 7.7<>§7.7)) sean mas convenientes.

#    First, we’ll show how it’s used. The @c(search) function below is an HTTP
#    handler. It defines a variable called @c(data) of an anonymous struct type
#    whose fields correspond to the HTTP request parameters. The struct’s field
#    tags specify the parameter names, which are often short and cryptic since
#    space is precious in a URL. The @c(Unpack) function populates the struct from
#    the request so that the parameters can be accessed conveniently and with an
#    appropriate type.
   En primer lugar, vamos a mostrar como se utiliza. La funcion @c(search) a
   continuacion, es un controlador HTTP. Se define una variable llamada @c(data)
   de un tipo de estructura anonima cuyos campos corresponden a los parametros
   de la peticion HTTP. Las etiquetas de campo de la estructura especifican los
   nombres de los parametros, que a menudo son cortos y cripticos, ya que el
   espacio es precioso en una URL. la funcion @c(Unpack) llena la estructura del
   la solicitud, por lo que los parametros se puede acceder convenientemente y
   con un tipo apropiado.

#    ..figure > @l(gopl.io/ch12/search/main.go<>gopl.io/ch12/search)
   ..figure > @l(gopl.io/ch12/search/main.go<>gopl.io/ch12/search)

#      ..src > go
#        import "gopl.io/ch12/params"
#
#        // search implements the /search URL endpoint.
#        func search(resp http.ResponseWriter, req *http.Request) {
#          var data struct {
#            Labels     []string `http:"l"`
#            MaxResults int      `http:"max"`
#            Exact      bool     `http:"x"`
#          }
#          data.MaxResults = 10 // set default
#          if err := params.Unpack(req, &data); err != nil {
#            http.Error(resp, err.Error(), http.StatusBadRequest) // 400
#            return
#          }
#
#          // ...rest of handler...
#          fmt.Fprintf(resp, "Search: %+v\n", data)
#        }
#      < src..
     ..src > go
       import "gopl.io/ch12/params"

       // search implementa la busqueda del /punto-final de la URL.
       func search(resp http.ResponseWriter, req *http.Request) {
         var data struct {
           Labels     []string `http:"l"`
           MaxResults int      `http:"max"`
           Exact      bool     `http:"x"`
         }
         data.MaxResults = 10 // establece por defecto
         if err := params.Unpack(req, &data); err != nil {
           http.Error(resp, err.Error(), http.StatusBadRequest) // 400
           return
         }

         // ...resto del manejador...
         fmt.Fprintf(resp, "Search: %+v\n", data)
       }
     < src..


#    The @c(Unpack) function below does three things. First, it calls
#    @c[req.ParseForm()] to parse the request. Thereafter, @c(req.Form) contains
#    all the parameters, regardless of whether the HTTP client used the GET or the
#    POST request method.
   La funcion @c(Unpack) de abajo hace tres cosas. En primer lugar, llama
   @c[req.ParseForm()] para analizar la solicitud. Posteriormente, @c(req.Form)
   contiene todos los parametros, independientemente de si el cliente HTTP
   utiliza el metodo de solicitud GET o POST.

#    Next, @c(Unpack) builds a mapping from the @e(effective) name of each field
#    to the variable for that field. The effective name may differ from the actual
#    name if the field has a tag. The @c(Field) method of @c(reflect.Type) returns
#    a @c(reflect.StructField) that provides information about the type of each
#    field such as its name, type, and optional tag. The @c(Tag) field is a
#    @c(reflect.StructTag), which is a string type that provides a @c(Get) method
#    to parse and extract the substring for a particular key, such as
#    @c(http:"...") in this case.
   A continuacion, @c(Unpack) construye una correlacion del nombre @e(efectivo)
   de cada campo a la variable para ese campo. El nombre efectivo puede diferir
   del nombre real si el campo tiene una etiqueta. El metodo @c(Field) de
   @c(reflect.Type) devuelve un @c(reflect.StructField) que proporciona
   informacion sobre el tipo de cada campo, como su nombre, tipo, y la etiqueta
   opcional. El campo @c(Tag) es un @c(reflect.StructTag), que es un tipo de
   cadena que proporciona un metodo @c(Get) para analizar y extraer la subcadena
   de una clave particular, como @c(http:"...") en este caso.

#    ..figure > @l(gopl.io/ch12/params/params.go<>gopl.io/ch12/params)
   ..figure > @l(gopl.io/ch12/params/params.go<>gopl.io/ch12/params)

#      ..src > go
#        // Unpack populates the fields of the struct pointed to by ptr
#        // from the HTTP request parameters in req.
#        func Unpack(req *http.Request, ptr interface{}) error {
#          if err := req.ParseForm(); err != nil {
#            return err
#          }
#
#          // Build map of fields keyed by effective name.
#          fields := make(map[string]reflect.Value)
#          v := reflect.ValueOf(ptr).Elem() // the struct variable
#          for i := 0; i < v.NumField(); i++ {
#            fieldInfo := v.Type().Field(i) // a reflect.StructField
#            tag := fieldInfo.Tag           // a reflect.StructTag
#            name := tag.Get("http")
#            if name == "" {
#              name = strings.ToLower(fieldInfo.Name)
#            }
#            fields[name] = v.Field(i)
#          }
#
#          // Update struct field for each parameter in the request.
#          for name, values := range req.Form {
#            f := fields[name]
#            if !f.IsValid() {
#              continue // ignore unrecognized HTTP parameters
#            }
#            for _, value := range values {
#              if f.Kind() == reflect.Slice {
#                elem := reflect.New(f.Type().Elem()).Elem()
#                if err := populate(elem, value); err != nil {
#                  return fmt.Errorf("%s: %v", name, err)
#                }
#                f.Set(reflect.Append(f, elem))
#              } else {
#                if err := populate(f, value); err != nil {
#                  return fmt.Errorf("%s: %v", name, err)
#                }
#              }
#            }
#          }
#          return nil
#        }
#      < src..
     ..src > go
       // Unpack rellena los campos de la estructura apuntada por ptr
       // con los parametros de la solicitud HTTP en req.
       func Unpack(req *http.Request, ptr interface{}) error {
         if err := req.ParseForm(); err != nil {
           return err
         }

         // Construye un mapa de los campos marcados con un nombre efectivo.
         fields := make(map[string]reflect.Value)
         v := reflect.ValueOf(ptr).Elem() // the struct variable
         for i := 0; i < v.NumField(); i++ {
           fieldInfo := v.Type().Field(i) // un reflect.StructField
           tag := fieldInfo.Tag           // un reflect.StructTag
           name := tag.Get("http")
           if name == "" {
             name = strings.ToLower(fieldInfo.Name)
           }
           fields[name] = v.Field(i)
         }

         // Actualiza el campo de estructura para cada parametro en la solicitud
         for name, values := range req.Form {
           f := fields[name]
           if !f.IsValid() {
             continue // ingorar los parametros HTTP no reconocidos
           }
           for _, value := range values {
             if f.Kind() == reflect.Slice {
               elem := reflect.New(f.Type().Elem()).Elem()
               if err := populate(elem, value); err != nil {
                 return fmt.Errorf("%s: %v", name, err)
               }
               f.Set(reflect.Append(f, elem))
             } else {
               if err := populate(f, value); err != nil {
                 return fmt.Errorf("%s: %v", name, err)
               }
             }
           }
         }
         return nil
       }
     < src..


#    Finally, @c(Unpack) iterates over the name/value pairs of the HTTP parameters
#    and updates the corresponding struct fields. Recall that the same parameter
#    name may appear more than once. If this happens, and the field is a slice,
#    then all the values of that parameter are accumulated into the
#    slice. Otherwise, the field is repeatedly overwritten so that only the last
#    value has any effect.
   Finalmente, @c(Unpack) itera sobre los pares nombre/valor de los parametros
   HTTP y actualiza los campos de estructura correspondientes. Recuerde que el
   mismo nombre de parametro puede aparecer mas de una vez. Si esto sucede, y el
   campo es un slice, entonces todos los valores de ese parametro se acumulan en
   el slice. De lo contrario, el campo se sobrescribe repetidamente para que
   solo el ultimo valor tenga algun efecto.

#    The @c(populate) function takes care of setting a single field @c(v) (or a
#    single element of a slice field) from a parameter value. For now, it supports
#    only strings, signed integers, and booleans.  Supporting other types is left
#    as an exercise.
   la funcion @c(populate) se encarga de establecer un unico campo @c(v) (o un
   unico elemento de un campo de slice) a partir de un valor de parametro. Por
   ahora, solo admite cadenas, enteros con signo y booleanos. Soportar otros
   tipos se deja como un ejercicio.

#    ..src > go
#      func populate(v reflect.Value, value string) error {
#        switch v.Kind() {
#        case reflect.String:
#          v.SetString(value)
#
#        case reflect.Int:
#          i, err := strconv.ParseInt(value, 10, 64)
#          if err != nil {
#            return err
#          }
#          v.SetInt(i)
#
#        case reflect.Bool:
#          b, err := strconv.ParseBool(value)
#          if err != nil {
#            return err
#          }
#          v.SetBool(b)
#
#        default:
#          return fmt.Errorf("unsupported kind %s", v.Type())
#        }
#        return nil
#      }
#    < src..
   ..src > go
     func populate(v reflect.Value, value string) error {
       switch v.Kind() {
       case reflect.String:
         v.SetString(value)

       case reflect.Int:
         i, err := strconv.ParseInt(value, 10, 64)
         if err != nil {
           return err
         }
         v.SetInt(i)

       case reflect.Bool:
         b, err := strconv.ParseBool(value)
         if err != nil {
           return err
         }
         v.SetBool(b)

       default:
         return fmt.Errorf("unsupported kind %s", v.Type())
       }
       return nil
     }
   < src..

#    If we add the @c(server) handler to a web server, this might be a typical
#    session:
   Si añadimos el controlador @c(server) a un servidor web, esto podria ser una
   tipica sesion:

#    ..src > sh
#      $ go build gopl.io/ch12/search
#      $ ./search &
#      $ ./fetch 'http://localhost:12345/search'
#      Search: {Labels:[] MaxResults:10 Exact:false}
#      $ ./fetch 'http://localhost:12345/search?l=golang&l=programming'
#      Search: {Labels:[golang programming] MaxResults:10 Exact:false}
#      $ ./fetch 'http://localhost:12345/search?l=golang&l=programming&max=100'
#      Search: {Labels:[golang programming] MaxResults:100 Exact:false}
#      $ ./fetch 'http://localhost:12345/search?x=true&l=golang&l=programming'
#      Search: {Labels:[golang programming] MaxResults:10 Exact:true}
#      $ ./fetch 'http://localhost:12345/search?q=hello&x=123'
#      x: strconv.ParseBool: parsing "123": invalid syntax
#      $ ./fetch 'http://localhost:12345/search?q=hello&max=lots'
#      max: strconv.ParseInt: parsing "lots": invalid syntax
#    < src..
   ..src > sh
     $ go build gopl.io/ch12/search
     $ ./search &
     $ ./fetch 'http://localhost:12345/search'
     Search: {Labels:[] MaxResults:10 Exact:false}
     $ ./fetch 'http://localhost:12345/search?l=golang&l=programming'
     Search: {Labels:[golang programming] MaxResults:10 Exact:false}
     $ ./fetch 'http://localhost:12345/search?l=golang&l=programming&max=100'
     Search: {Labels:[golang programming] MaxResults:100 Exact:false}
     $ ./fetch 'http://localhost:12345/search?x=true&l=golang&l=programming'
     Search: {Labels:[golang programming] MaxResults:10 Exact:true}
     $ ./fetch 'http://localhost:12345/search?q=hello&x=123'
     x: strconv.ParseBool: parsing "123": invalid syntax
     $ ./fetch 'http://localhost:12345/search?q=hello&max=lots'
     max: strconv.ParseInt: parsing "lots": invalid syntax
   < src..

#    @b(Exercise 12.11): Write the corresponding @c(Pack) function. Given a struct
#    value, @c(Pack) should return a URL incorporating the parameter values from
#    the struct.
   @b(Ejercicio 12.11): Escribir la funcion correspondiente @c(Pack). Dado un
   valor de estructura, @c(Pack) debe devolver una direccion URL que incorpora
   los valores de los parametros de la estructura.

#    @b(Exercise 12.12): Extend the field tag notation to express parameter
#    validity requirements. For example, a string might need to be a valid email
#    address or credit-card number, and an integer might need to be a valid US ZIP
#    code. Modify @c(Unpack) to check these requirements.
   @b(Ejercicio 12.12): Extender la notacion de etiqueta de campo para expresar
   requisitos de validez de parametros. Por ejemplo, es posible que una cadena
   tenga que ser una direccion de correo electronico valida o un numero de
   tarjeta de credito, y un numero entero puede tener que ser un codigo postal
   valido de los Estados Unidos. Modifique @c(Unpack) para comprobar estos
   requisitos.

#    @b(Exercise 12.13): Modify the S-expression encoder (@l(#Section
#    12.4<>§12.4)) and decoder (@l(#Section 12.6<>§12.6)) so that they honor the
#    @c(sexpr:"...") field tag in a similar manner to @c(encoding/json)
#    (@l(#Section 4.5<>§4.5)).
   @b(Ejercicio 12.13): Modificar el codificador (@l(#Seccion 12.4<>§12.4)) y
   decodificador (@l(#Seccion 12.6<>§12.6)) de expresiones-S para que cumplan la
   etiqueta de campo @c(sexpr:"...") de una manera similar a @c(encoding/json)
   (@l(#Seccion 4.5<>§4.5)).

# ** Section 12.8 <> Displaying the Methods of a Type
** Seccion 12.8 <> Visualizando los Motodos de Type

#    Our final example of reflection uses @c(reflect.Type) to print the type of an
#    arbitrary value and enumerate its methods:
   Nuestro ultimo ejemplo de reflexion utiliza @c(reflect.Type) para imprimir el
   tipo de un valor arbitrario y enumerar sus metodos:

#    ..figure > @l(gopl.io/ch12/methods/methods.go<>gopl.io/ch12/methods)
   ..figure > @l(gopl.io/ch12/methods/methods.go<>gopl.io/ch12/methods)

#      ..src > go
#        // Print prints the method set of the value x.
#        func Print(x interface{}) {
#          v := reflect.ValueOf(x)
#          t := v.Type()
#          fmt.Printf("type %s\n", t)
#
#          for i := 0; i < v.NumMethod(); i++ {
#            methType := v.Method(i).Type()
#            fmt.Printf("func (%s) %s%s\n", t, t.Method(i).Name,
#              strings.TrimPrefix(methType.String(), "func"))
#          }
#        }
#      < src..
     ..src > go
       // Print imprime el conjunto de metodos del valor x.
       func Print(x interface{}) {
         v := reflect.ValueOf(x)
         t := v.Type()
         fmt.Printf("type %s\n", t)

         for i := 0; i < v.NumMethod(); i++ {
           methType := v.Method(i).Type()
           fmt.Printf("func (%s) %s%s\n", t, t.Method(i).Name,
             strings.TrimPrefix(methType.String(), "func"))
         }
       }
     < src..


#    Both @c(reflect.Type) and @c(reflect.Value) have a method called
#    @c(Method). Each @c[t.Method(i)] call returns an instance of
#    @c(reflect.Method), a struct type that describes the name and type of a
#    single method. Each @c[v.Method(i)] call returns a @c(reflect.Value)
#    representing a method value (@l(#Section 6.4<>§6.4)), that is, a method bound
#    to its receiver. Using the @c(reflect.Value.Call) method (which we don’t have
#    space to show here), it’s possible to call @c(Values) of kind @c(Func) like
#    this one, but this program needs only its @c(Type).
   Ambos @c(reflect.Type) y @c(reflect.Value) tienen un metodo llamado
   @c(Method). Cada llamada @c[t.Method(i)] devuelve una instancia de
   @c(reflect.Method), un tipo struct que describe el nombre y tipo de un unico
   metodo. Cada llamada @c[v.Method(i)] devuelve un @c(reflect.Value) que
   representa un valor metodo (@l(#Seccion 6.4<>§6.4)), es decir, un metodo
   vinculado a su receptor. Utilizando el metodo @c(reflect.Value.Call) (que no
   tenemos espacio para mostrar aqui), es posible llamar a @c(Values) de tipo
   @c(Func) como este, pero este programa solo necesita su @c(Type).

#    Here are the methods belonging to two types, @c(time.Duration) and
#    @c(*strings.Replacer):
   Estos son los metodos que pertenecen a dos tipos, @c(time.Duration) y
   @c(*strings.Replacer):

#    ..src > go
#      methods.Print(time.Hour)
#      // Output:
#      // type time.Duration
#      // func (time.Duration) Hours() float64
#      // func (time.Duration) Minutes() float64
#      // func (time.Duration) Nanoseconds() int64
#      // func (time.Duration) Seconds() float64
#      // func (time.Duration) String() string
#
#      methods.Print(new(strings.Replacer))
#      // Output:
#      // type *strings.Replacer
#      // func (*strings.Replacer) Replace(string) string
#      // func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
#    < src..
   ..src > go
     methods.Print(time.Hour)
     // Output:
     // type time.Duration
     // func (time.Duration) Hours() float64
     // func (time.Duration) Minutes() float64
     // func (time.Duration) Nanoseconds() int64
     // func (time.Duration) Seconds() float64
     // func (time.Duration) String() string

     methods.Print(new(strings.Replacer))
     // Output:
     // type *strings.Replacer
     // func (*strings.Replacer) Replace(string) string
     // func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
   < src..

# ** Section 12.9 <> A Word of Caution
** Seccion 12.9 <> Una Palabra de Precaucion

#    There is a lot more to the reflection API than we have space to show, but the
#    preceding examples give an idea of what is possible. Reflection is a powerful
#    and expressive tool, but it should be used with care, for three reasons.
   Hay mucho mas sobre la API de reflexion que el espacio que tenemos para
   mostror, pero los ejemplos anteriores dan una idea de lo que es posible. La
   reflexion es una herramienta poderosa y expresiva, pero debe ser usada con
   cuidado, por tres razones.

#    The first reason is that reflection-based code can be fragile. For every
#    mistake that would cause a compiler to report a type error, there is a
#    corresponding way to misuse reflection, but whereas the compiler reports the
#    mistake at build time, a reflection error is reported during execution as a
#    panic, possibly long after the program was written or even long after it has
#    started running.
   La primera razon es que el codigo basado en reflexion puede ser fragil. Para
   cada error que podria hacer que un compilador informe un error de tipo, hay
   una forma correspondiente de usar incorrectamente la reflexion, pero mientras
   que el compilador informa del error en el tiempo de construccion, un error de
   reflexion se informa durante la ejecucion como un panico, posiblemente mucho
   despues heber escrito el programa o incluso mucho despues de que ha comenzado
   su ejecucion.

#    If the @c(readList) function (@l(#Section 12.6<>§12.6)), for example, should
#    read a string from the input while populating a variable of type @c(int), the
#    call to @c(reflect.Value.SetString) will panic. Most programs that use
#    reflection have similar hazards, and considerable care is required to keep
#    track of the type, addressability, and settability of each @c(reflect.Value).
   Si la funcion @c(readList) (@l(#Seccion 12.6<>§12.6)), por ejemplo, debe leer
   una cadena de la entrada al rellenar una variable de tipo @c(int), la llamada
   a @c(reflect.Value.SetString) entrara en panico. La mayoria de los programas
   que utilizan la reflexion tienen riesgos similares, y se requiere mucho
   cuidado para realizar un seguimiento del tipo, capacidad de direccionamiento,
   y asignabilidad de cada @c(reflect.Value).

#    The best way to avoid this fragility is to ensure that the use of reflection
#    is fully encapsulated within your package and, if possible, avoid
#    @c(reflect.Value) in favor of specific types in your package’s API, to
#    restrict inputs to legal values. If this is not possible, perform additional
#    dynamic checks before each risky operation. As an example from the standard
#    library, when @c(fmt.Printf) applies a verb to an inappropriate operand, it
#    does not panic mysteriously but prints an informative error message. The
#    program still has a bug, but it is easier to diagnose.
   La mejor manera de evitar esta fragilidad es asegurar que el uso de la
   reflexion esta totalmente encapsulado dentro de su paquete y, si es posible,
   evitar @c(reflect.Value) en favor de tipos especificos en la API de su
   paquete, para restringir las entradas a valores legales. Si esto no es
   posible, realice comprobaciones dinamicas adicionales antes de cada operacion
   riesgosa. A modo de ejemplo en la libreria estandar, cuando @c(fmt.Printf)
   aplica un verbo a un operando inadecuado, no entra misteriosamente en panico,
   por que imprime un mensaje de error informativo. El programa aun tiene un
   error, pero es mas facil de diagnosticar.

#    ..src > go
#      fmt.Printf("%d %s\n", "hello", 42) // "%!d(string=hello) %!s(int=42)"
#    < src..
   ..src > go
     fmt.Printf("%d %s\n", "hello", 42) // "%!d(string=hello) %!s(int=42)"
   < src..

#    Reflection also reduces the safety and accuracy of automated refactoring and
#    analysis tools, because they can’t determine or rely on type information.
   La reflexion tambien reduce la seguridad y la precision de las herramientas
   automatizadas de refactorizacion y analisis, ya que no pueden determinar o
   confiar en la informacion de tipo.

#    The second reason to avoid reflection is that since types serve as a form of
#    documentation and the operations of reflection cannot be subject to static
#    type checking, heavily reflective code is often hard to understand. Always
#    carefully document the expected types and other invariants of functions that
#    accept an @c(interface{}) or a @c(reflect.Value).
   La segunda razon para evitar la reflexion es que como los tipos sirven como
   una forma de documentacion y las operaciones de reflexion no pueden estar
   sujetas a la verificacion de tipo estatico, el codigo altamente reflexivo es
   a menudo dificil de entender. Siempre documente cuidadosamente los tipos
   esperados y otros invariantes de las funciones que aceptan una
   @c(interface{}) o @c(reflect.Value).

#    The third reason is that reflection-based functions may be one or two orders
#    of magnitude slower than code specialized for a particular type. In a typical
#    program, the majority of functions are not relevant to the overall
#    performance, so it’s fine to use reflection when it makes the program
#    clearer. Testing is a particularly good fit for reflection since most tests
#    use small data sets. But for functions on the critical path, reflection is
#    best avoided.
   La tercera razon es que las funciones basadas en la reflexion pueden ser de
   uno o dos ordenes de magnitud mas lentas que el codigo especializado para un
   tipo particular. En un programa tipico, la mayoria de las funciones no son
   relevantes para el rendimiento general, por lo que es bueno usar la reflexion
   cuando haga mas claro el programa. Las pruebas son particularmente adecuadas
   para la reflexion ya que la mayoria de las pruebas utilizan conjuntos de
   datos pequeños. Pero para las funciones en rutas criticas, es mejor evitar la
   reflexion.

# * Chapter 13 <> Low-Level Programming
* Capitulo 13 <> Programacion de Bajo Nivel

#   The design of Go guarantees a number of safety properties that limit the ways
#   in which a Go program can @"(go wrong.) During compilation, type checking
#   detects most attempts to apply an operation to a value that is inappropriate
#   for its type, for instance, subtracting one string from another. Strict rules
#   for type conversions prevent direct access to the internals of built-in types
#   like strings, maps, slices, and channels.
  El diseño de Go garantiza una serie de propiedades de seguridad que limitan
  las formas en que un programa Go puede @"(ir mal). Durante la compilacion, la
  comprobacion de tipo detecta la mayoria de los intentos de aplicar una
  operacion a un valor inadecuado para su tipo, por ejemplo, restando una cadena
  de otra. Las estrictas reglas para las conversiones de tipos impiden el acceso
  directo a los tipos nativos como cadenas, mapas, slices y canales.

#   For errors that cannot be detected statically, such as out-of-bounds array
#   accesses or nil pointer dereferences, dynamic checks ensure that the program
#   immediately terminates with an informative error whenever a forbidden
#   operation occurs. Automatic memory management (garbage collection) eliminates
#   @"(use after free) bugs, as well as most memory leaks.
  Para errores que no se pueden detectar de forma estatica, como accesos a un
  arreglo fuera de limites o desreferencias de puntero nulo, las comprobaciones
  dinamicas aseguran que el programa termina inmediatamente con un error
  informativo siempre que se produce una operacion prohibida. La gestion
  automatica de memoria (recoleccion de basura) elimina errores de @"(uso
  posterior), asi como la mayoria de las perdidas de memoria.

#   Many implementation details are inaccessible to Go programs. There is no way
#   to discover the memory layout of an aggregate type like a struct, or the
#   machine code for a function, or the identity of the operating system thread on
#   which the current goroutine is running.  Indeed, the Go scheduler freely moves
#   goroutines from one thread to another. A pointer identifies a variable without
#   revealing the variable’s numeric address. Addresses may change as the garbage
#   collector moves variables; pointers are transparently updated.
  Muchos detalles de la implementacion son inaccesibles para los programas de
  Go. No hay manera de descubrir el diseño de memoria de un tipo agregado como
  una estructura, o el codigo maquina para una funcion, o la identidad del hilo
  del sistema operativo en el que se esta ejecutando la actual gorutina. De
  hecho, el planificador de Go mueve libremente las gorutas de un hilo a
  otro. Un puntero identifica una variable sin revelar la direccion numerica de
  la variable. Las direcciones pueden cambiar a medida que el recolector de
  basura mueve las variables; Los punteros se actualizan de forma transparente.

#   Together, these features make Go programs, especially failing ones, more
#   predictable and less mysterious than programs in C, the quintessential
#   low-level language. By hiding the underlying details, they also make Go
#   programs highly portable, since the language semantics are largely independent
#   of any particular compiler, operating system, or CPU architecture. (Not
#   entirely independent: some details leak through, such as the word size of the
#   processor, the order of evaluation of certain expressions, and the set of
#   implementation restrictions imposed by the compiler.)
  Juntas, estas caracteristicas hacen que los programas de Go, especialmente los
  que fallan, sean mas predecibles y menos misteriosos que los programas en C,
  la quienta escencia de los lenguajes de bajo nivel. Al ocultar los detalles
  subyacentes, tambien hace que los programas Go sean altamente portatiles, ya
  que la semantica del lenguaje es en gran medida independiente de cualquier
  compilador, sistema operativo o arquitectura de la CPU en particular. (No es
  totalmente independiente: algunos detalles se filtran, como el tamaño de la
  palabra del procesador, el orden de evaluacion de ciertas expresiones y el
  conjunto de restricciones de implementacion impuestas por el compilador).

#   Occasionally, we may choose to forfeit some of these helpful guarantees to
#   achieve the highest possible performance, to interoperate with libraries
#   written in other languages, or to implement a function that cannot be
#   expressed in pure Go.
  Ocasionalmente, podemos optar por renunciar a algunas de estas garantias
  utiles para lograr el maximo rendimiento posible, para interoperar con
  librerias escritas en otros lenguajes o para implementar una funcion que no
  puede expresarse en Go puro.

#   In this chapter, we’ll see how the @c(unsafe) package lets us step outside the
#   usual rules, and how to use the @$(cgo) tool to create Go bindings for C
#   libraries and operating system calls.
  En este capitulo, vamos a ver como el paquete @c(unsafe) nos permite saltar
  las reglas habituales, y como utilizar la herramienta @$(cgo) para crear
  enlaces Go para librerias de C y llamadas al sistema operativo.

#   The approaches described in this chapter should not be used
#   frivolously. Without careful attention to detail, they may cause the kinds of
#   unpredictable, inscrutable, non-local failures with which C programmers are
#   unhappily acquainted. Use of @c(unsafe) also voids Go’s warranty of
#   compatibility with future releases, since, whether intended or inadvertent, it
#   is easy to depend on unspecified implementation details that may change
#   unexpectedly.
  Los enfoques descritos en este capitulo no deben utilizarse frivolamente. Sin
  la atencion cuidadosa a los detalles, pueden causar el tipo de fracasos
  impredecibles, inescrutables, no locales con los cuales los programadores de C
  son infelizmente familiarizados. El uso de @c(unsafe) tambien anula la
  garantia de la compatibilidad de Go con versiones futuras, ya que, ya sea
  intencional o no, es facil depender de detalles de implementacion no
  especificados que pueden cambiar de forma inesperada.

#   The @c(unsafe) package is rather magical. Although it appears to be a regular
#   package and is imported in the usual way, it is actually implemented by the
#   compiler. It provides access to a number of built-in language features that
#   are not ordinarily available because they expose details of Go’s memory
#   layout. Presenting these features as a separate package makes the rare
#   occasions on which they are needed more conspicuous. Also, some environments
#   may restrict the use of the @c(unsafe) package for security reasons.
  El paquete @c(unsafe) es bastante magico. Aunque parece ser un paquete regular
  y se importa de la manera habitual, es realmente implementado por el
  compilador. Proporciona acceso a una serie de caracteristicas nativas de
  lenguaje que normalmente no estan disponibles porque exponen detalles del
  diseño de memoria de Go. La presentacion de estas caracteristicas como un
  paquete por separado hace que las raras ocasiones en que se necesita mas
  conspicuo. Ademas, algunos entornos pueden restringir el uso del paquete
  @c(unsafe) por razones de seguridad.

#   Package @c(unsafe) is used extensively within low-level packages like
#   @c(runtime), @c(os), @c(syscall), and @c(net) that interact with the operating
#   system, but is almost never needed by ordinary programs.
  El paquete @c(unsafe) se utiliza ampliamente en paquetes de bajo nivel como
  @c(runtime), @c(os), @c(syscall), y @c(net) que interactuan con el sistema
  operativo, pero casi nunca es necesario en programas ordinarios.

# ** Section 13.1 <> @c(unsafe.Sizeof), @c(Alignof), and @c(Offsetof)
** Seccion 13.1 <> @c(unsafe.Sizeof), @c(Alignof), y @c(Offsetof)

#    The @c(unsafe.Sizeof) function reports the size in bytes of the
#    representation of its operand, which may be an expression of any type; the
#    expression is not evaluated. A call to @c(Sizeof) is a constant expression of
#    type @c(uintptr), so the result may be used as the dimension of an array
#    type, or to compute other constants.
   la funcion @c(unsafe.Sizeof) informa el tamaño en bytes de la representacion
   de su operando, que puede ser una expresion de cualquier tipo; La expresion
   no se evalua. Una llamada a @c(Sizeof) es una expresion constante de tipo
   @c(uintptr), por lo que el resultado puede ser utilizado como la dimension de
   un tipo de matriz, o para calcular otras constantes.

#    ..src > go
#      import "unsafe"
#      fmt.Println(unsafe.Sizeof(float64(0))) // "8"
#    < src..
   ..src > go
     import "unsafe"
     fmt.Println(unsafe.Sizeof(float64(0))) // "8"
   < src..

#    @c(Sizeof) reports only the size of the fixed part of each data structure,
#    like the pointer and length of a string, but not indirect parts like the
#    contents of the string. Typical sizes for all nonaggregate Go types are shown
#    below, though the exact sizes may vary by toolchain. For portability, we’ve
#    given the sizes of reference types (or types containing references) in terms
#    of words, where a word is 4 bytes on a 32-bit platform and 8 bytes on a
#    64-bit platform.
   @c(Sizeof) informa solo el tamaño de la parte fija de cada estructura de
   datos, como el puntero y longitud de una cadena, pero no partes indirectas
   como el contenido de la cadena. Los tamaños tipicos para todos los tipos Go
   no agregados se muestran a continuacion, aunque los tamaños exactos pueden
   variar segun la cadena de herramientas. Para la portabilidad, hemos dado los
   tamaños de los tipos de referencia (o tipos que contienen referencias) en
   terminos de palabras, donde una palabra es 4 bytes en una plataforma de 32
   bits y 8 bytes en una plataforma de 64 bits.

#    Computers load and store values from memory most efficiently when those
#    values are properly @e(aligned). For example, the address of a value of a
#    two-byte type such as @c(int16) should be an even number, the address of a
#    four-byte value such as a rune should be a multiple of four, and the address
#    of an eight-byte value such as a @c(float64), @c(uint64), or 64-bit pointer
#    should be a multiple of eight. Alignment requirements of higher multiples are
#    unusual, even for larger data types such as @c(complex128).
   Las computadoras cargan y almacenan los valores de memoria mas efecientemente
   cuando esos valores estan correctamente @e(alineados). Por ejemplo, la
   direccion de un valor de un tipo de dos bytes como @c(int16) debe ser un
   numero par, la direccion de un valor de cuatro bytes como una runa debe ser
   un multiplo de cuatro, y la direccion de un valor de ocho bytes como un
   @c(float64), @c(uint64), o un puntero de 64 bits debe ser un multiplo de
   ocho. Los requisitos de alineacion de multiplos mayores son inusuales,
   incluso para los tipos de datos mas grandes como @c(complex128).

#    For this reason, the size of a value of an aggregate type (a struct or array)
#    is at least the sum of the sizes of its fields or elements but may be greater
#    due to the presence of @"(holes.) Holes are unused spaces added by the
#    compiler to ensure that the following field or element is properly aligned
#    relative to the start of the struct or array.
   Por esta razon, el tamaño de un valor de un tipo agregado (una estructura o
   arreglo) es al menos la suma de los tamaños de sus campos o elementos, pero
   puede ser mayor debido a la presencia de @"(agujeros). Los agujeros son
   espacios no utilizados añadidos por el compilador para asegurar que el
   siguiente campo o elemento este correctamente alineado con respecto al inicio
   de la estructura o arreglo.

#    | Type                                                          | Size                                                  |
#    |===============================================================|=======================================================|
#    | @c(bool)                                                      | 1 byte                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(int)@m(N), @c(uint)@m(N), @c(float)@m(N), @c(complex)@m(N) | @m(N) / 8 bytes (for example, f@c(loat64) is 8 bytes) |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(int), @c(uint), @c(uintptr)                                | 1 word                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(*T)                                                        | 1 word                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(string)                                                    | 2 words (data, len)                                   |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c([]T)                                                       | 3 words (data, len, cap)                              |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(map)                                                       | 1 word                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(func)                                                      | 1 word                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(chan)                                                      | 1 word                                                |
#    |---------------------------------------------------------------|-------------------------------------------------------|
#    | @c(interface)                                                 | 2 words (type, value)                                 |
   | Type                                                          | Size                                                  |
   |===============================================================|=======================================================|
   | @c(bool)                                                      | 1 byte                                                |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(int)@m(N), @c(uint)@m(N), @c(float)@m(N), @c(complex)@m(N) | @m(N) / 8 bytes (por ejemplo, f@c(loat64) es 8 bytes) |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(int), @c(uint), @c(uintptr)                                | 1 palabra                                             |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(*T)                                                        | 1 palabra                                             |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(string)                                                    | 2 palabras (data, len)                                |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c([]T)                                                       | 3 palabras (data, len, cap)                           |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(map)                                                       | 1 palabra                                             |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(func)                                                      | 1 palabra                                             |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(chan)                                                      | 1 palabra                                             |
   |---------------------------------------------------------------|-------------------------------------------------------|
   | @c(interface)                                                 | 2 palabras (type, value)                              |


#    The language specification does not guarantee that the order in which fields
#    are declared is the order in which they are laid out in memory, so in theory
#    a compiler is free to rearrange them, although as we write this, none do. If
#    the types of a struct’s fields are of different sizes, it may be more
#    space-efficient to declare the fields in an order that packs them as tightly
#    as possible. The three structs below have the same fields, but the first
#    requires up to 50% more memory than the other two:
   La especificacion del lenguaje no garantiza que el orden en que se declaran
   los campos es el orden en el que se exponen en la memoria, por lo que en
   teoria un compilador es libre de reordenarlos, aunque al escribir esto,
   ninguno lo hace. Si los tipos de campos de una estructura son de diferentes
   tamaños, puede ser mas eficiente en el espacio declarar los campos en un
   orden que los empaqueta tan firmemente como sea posible. Las tres estructuras
   abajo tienen los mismos campos, pero la primera requiere hasta un 50% mas de
   memoria que las otras dos:

#    ..src > go
#                                        // 64-bit    32-bit
#      struct{ bool; float64; int16 }    // 3 words   4 words
#      struct{ float64; int16; bool }    // 2 words   3 words
#      struct{ bool; int16; float64 }    // 2 words   3 words
#    < src..
   ..src > go
                                       // 64-bit       32-bit
     struct{ bool; float64; int16 }    // 3 palabras   4 palabras
     struct{ float64; int16; bool }    // 2 palabras   3 palabras
     struct{ bool; int16; float64 }    // 2 palabras   3 palabras
   < src..

#    The details of the alignment algorithm are beyond the scope of this book, and
#    it’s certainly not worth worrying about every struct, but efficient packing
#    may make frequently allocated data structures more compact and therefore
#    faster.
   Los detalles del algoritmo de alineacion estan mas alla del alcance de este
   libro, y ciertamente no vale la pena preocuparse por cada estructura, pero un
   enpaque eficiente puede hacer que las estructuras de datos asignadas
   frecuentemente sean mas compactas y por lo tanto mas rapidas.

#    The @c(unsafe.Alignof) function reports the required alignment of its
#    argument’s type. Like @c(Sizeof), it may be applied to an expression of any
#    type, and it yields a constant. Typically, boolean and numeric types are
#    aligned to their size (up to a maximum of 8 bytes) and all other types are
#    word-aligned.
   La funcion @c(unsafe.Alignof) informa la alineacion requerida del tipo de su
   argumento. Al igual que @c(Sizeof), se puede aplicar a una expresion de
   cualquier tipo, y produce una constante. Normalmente, los tipos booleanos y
   numericos estan alineados con su tamaño (hasta un maximo de 8 bytes) y todos
   los demas tipos estan alineados con palabras.

#    The @c(unsafe.Offsetof) function, whose operand must be a field selector
#    @c(x.f), computes the offset of field @c(f) relative to the start of its
#    enclosing struct @c(x), accounting for holes, if any.
   La funcion @c(unsafe.Offsetof), cuyo operando debe ser un selector de campo
   @c(x.f), calcula el desplazamiento del campo de @c(f) con respecto al
   comienzo de su estructura contenedora @c(x), representando los agujeros, si
   los hay.

#    Figure 13.1 shows a struct variable @c(x) and its memory layout on typical
#    32- and 64-bit Go implementations. The gray regions are holes.
   La Figura 13.1 muestra una variable de estructura @c(x) y su disposicion de
   memoria tipica en de 32 y 64 bits en implementaciones Go. Las regiones grises
   son agujeros.

#    ..src > go
#      var x struct {
#        a bool
#        b int16
#        c []int
#      }
#    < src..
   ..src > go
     var x struct {
       a bool
       b int16
       c []int
     }
   < src..

#    ..figure > Figure 13.1. Holes in a struct.
   ..figure > Figura 13.1. Agujeros en una estructura.

#      ..img  > img/Figure-13.1.jpg
     ..img  > img/Figure-13.1.jpg


#    The table below shows the results of applying the three @c(unsafe) functions
#    to @c(x) itself and to each of its three fields:
   La siguiente tabla muestra los resultados de aplicar las tres funcion
   @c(unsafe) al mismo @c(x) y a cada uno de sus tres campos:

#    - Typical 32-bit platform ::
   - Plataforma tipica de 32 bits ::

#      ..pre >
#        Sizeof(x)   = 16  Alignof(x)   = 4
#        Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
#        Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
#        Sizeof(x.c) = 12  Alignof(x.c) = 4  Offsetof(x.c) = 4
     ..pre >
       Sizeof(x)   = 16  Alignof(x)   = 4
       Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
       Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
       Sizeof(x.c) = 12  Alignof(x.c) = 4  Offsetof(x.c) = 4

#    - Typical 64-bit platform ::
   - Plataforma tipica de 64 bits ::

#      ..pre >
#        Sizeof(x)   = 32  Alignof(x)   = 8
#        Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
#        Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
#        Sizeof(x.c) = 24  Alignof(x.c) = 8  Offsetof(x.c) = 8
     ..pre >
       Sizeof(x)   = 32  Alignof(x)   = 8
       Sizeof(x.a) =  1  Alignof(x.a) = 1  Offsetof(x.a) = 0
       Sizeof(x.b) =  2  Alignof(x.b) = 2  Offsetof(x.b) = 2
       Sizeof(x.c) = 24  Alignof(x.c) = 8  Offsetof(x.c) = 8

#    Despite their names, these functions are not in fact unsafe, and they may be
#    helpful for understanding the layout of raw memory in a program when
#    optimizing for space.
   A pesar de sus nombres, estas funciones en realidad no son inseguras, y
   pueden ser utiles para entender el diseño de la memoria en bruto en un
   programa al optimizar el espacio.

# ** Section 13.2 <> @c(unsafe.Pointer)
** Seccion 13.2 <> @c(unsafe.Pointer)

#    Most pointer types are written @c(*T), meaning @"(a pointer to a variable of
#    type @c(T).) The @c(unsafe.Pointer) type is a special kind of pointer that
#    can hold the address of any variable. Of course, we can’t indirect through an
#    @c(unsafe.Pointer) using @c(*p) because we don’t know what type that
#    expression should have. Like ordinary pointers, @c(unsafe.Pointers) are
#    comparable and may be compared with @c(nil), which is the zero value of the
#    type.
   La mayoria de los tipos de puntero se escriben @c(*T), es decir, @"(un
   puntero a una variable de tipo @c(T)). El tipo @c(unsafe.Pointer) es un tipo
   especial de puntero que puede contener la direccion de cualquier variable.
   Por supuesto, no podemos aplicar indireccion a traves de un
   @c(unsafe.Pointer) usando @c(*p), porque no sabemos que tipo de expresion que
   debe tener. Como los punteros ordinarios, @c(unsafe.Pointers) es comparable y
   pueden compararse con @c(nil), que es el valor cero del tipo.

#    An ordinary @c(*T) pointer may be converted to an @c(unsafe.Pointer), and an
#    @c(unsafe.Pointer) may be converted back to an ordinary pointer, not
#    necessarily of the same type @c(*T). By converting a @c(*float64) pointer to
#    a @c(*uint64), for instance, we can inspect the bit pattern of a
#    floating-point variable:
   Un puentor @c(*T) ordinario puede convertirse en un @c(unsafe.Pointer), y un
   @c(unsafe.Pointer) convertirse de nuevo a un puntero ordinario, no
   necesariamente del mismo tipo @c(*T). Por ejemplo, al convertir un puntero
   @c(*float64) en un @c(*uint64), podemos inspeccionar el patron de bits de una
   variable de punto flotante:

#    ..src > go
#      package math
#
#      func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) }
#
#      fmt.Printf("%#016x\n", Float64bits(1.0)) // "0x3ff0000000000000"
#    < src..
   ..src > go
     package math

     func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) }

     fmt.Printf("%#016x\n", Float64bits(1.0)) // "0x3ff0000000000000"
   < src..

#    Through the resulting pointer, we can update the bit pattern too. This is
#    harmless for a floating-point variable since any bit pattern is legal, but in
#    general, @c(unsafe.Pointer) conversions let us write arbitrary values to
#    memory and thus subvert the type system.
   A traves del puntero resultante, podemos actualizar el patron de bits
   tambien. Esto es inofensivo para una variable de punto flotante, ya que
   cualquier patron de bits es legal, pero en general, las conversiones
   @c(unsafe.Pointer) nos permiter escribir valores arbitrarios en memoria y asi
   subvertir el sistema de tipos.

#    An @c(unsafe.Pointer) may also be converted to a @c(uintptr) that holds the
#    pointer’s numeric value, letting us perform arithmetic on addresses. (Recall
#    from @l(#Chapter 3) that a @c(uintptr) is an unsigned integer wide enough to
#    represent an address.) This conversion too may be applied in reverse, but
#    again, converting from a @c(uintptr) to an @c(unsafe.Pointer) may subvert the
#    type system since not all numbers are valid addresses.
   Un @c(unsafe.Pointer) tambien se puede convertir en un @c(uintptr) que
   mantiene el valor numerico del puntero, dejandonos realizar aritmetica de
   direcciones. (Recuerde del @l(#Capitulo 3) que un @c(uintptr) es un entero
   sin signo lo suficientemente ancho como para representar una direccion.) Esta
   conversion tambien se puede aplicar a la inversa, pero de nuevo, la
   conversion de un @c(uintptr) a un @c(unsafe.Pointer) puede subvertir el
   sistema de tipos ya que no todos los numeros son direcciones validas.

#    Many @c(unsafe.Pointer) values are thus intermediaries for converting
#    ordinary pointers to raw numeric addresses and back again. The example below
#    takes the address of variable @c(x), adds the offset of its @c(b) field,
#    converts the resulting address to @c(*int16), and through that pointer
#    updates @c(x.b):
   Muchos valores @c(unsafe.Pointer) son, por tanto, intermediarios para
   convertir punteros ordinarios en direcciones numericas brutas y viceversa. El
   ejemplo a continuacion toma la direccion de la variable @c(x), añade el
   desplazamiento de su campo @c(b), convierte la direccion resultante en
   @c(*int16), y por medio este puntero actualiza @c(x.b):

#    ..figure > @l(gopl.io/ch13/unsafeptr/main.go<>gopl.io/ch13/unsafeptr)
   ..figure > @l(gopl.io/ch13/unsafeptr/main.go<>gopl.io/ch13/unsafeptr)

#      ..src > go
#        var x struct {
#          a bool
#          b int16
#          c []int
#        }
#
#        // equivalent to pb := &x.b
#        pb := (*int16)(unsafe.Pointer(
#          uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
#        *pb = 42
#
#        fmt.Println(x.b) // "42"
#      < src..
     ..src > go
       var x struct {
         a bool
         b int16
         c []int
       }

       // equivalente a pb := &x.b
       pb := (*int16)(unsafe.Pointer(
         uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
       *pb = 42

       fmt.Println(x.b) // "42"
     < src..


#    Although the syntax is cumbersome—perhaps no bad thing since these features
#    should be used sparingly—do not be tempted to introduce temporary variables
#    of type @c(uintptr) to break the lines. This code is incorrect:
   Aunque la sintaxis es engorrosa–quiza no es malo, ya que estas
   caracteristicas deben utilizarse con moderacion–no se sienta tentado a
   introducir variables temporales de tipo @c(uintptr) para romper las
   lineas. Este codigo es incorrecto:

#    ..src > go
#      // NOTE: subtly incorrect!
#      tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
#      pb := (*int16)(unsafe.Pointer(tmp))
#      *pb = 42
#    < src..
   ..src > go
     // NOTA: sutilmente incorreto!
     tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
     pb := (*int16)(unsafe.Pointer(tmp))
     *pb = 42
   < src..

#    The reason is very subtle. Some garbage collectors move variables around in
#    memory to reduce fragmentation or bookkeeping. Garbage collectors of this
#    kind are known as @e(moving GCs). When a variable is moved, all pointers that
#    hold the address of the old location must be updated to point to the new
#    one. From the perspective of the garbage collector, an @c(unsafe.Pointer) is
#    a pointer and thus its value must change as the variable moves, but a
#    @c(uintptr) is just a number so its value must not change. The incorrect code
#    above @e(hides a pointer) from the garbage collector in the non-pointer
#    variable @c(tmp). By the time the second statement executes, the variable
#    @c(x) could have moved and the number in @c(tmp) would no longer be the
#    address @c(&x.b). The third statement clobbers an arbitrary memory location
#    with the value 42.
   La razon es muy sutil. Algunos recolectores de basura mueven las variables en
   la memoria para reducir la fragmentacion o la contabilidad. Los recolectores
   de basura de este tipo lo conocen como @e(mover GCs). Cuando se mueve una
   variable, todos los punteros que contienen la direccion de la antigua
   ubicacion deben actualizarse para apuntar a la nueva. Desde la perspectiva
   del colector de basura, un @c(unsafe.Pointer) es un puntero y por lo tanto su
   valor debe cambiar a medida que se mueve la variable, pero un @c(uintptr) es
   solo un numero por lo que su valor no debe cambiar. El codigo anterior es
   incorrecta por que @e(oculta un puentero) del recolector de basura en la
   variable no puntero @c(tmp). En el momento que la segunda instruccion se
   ejecuta, la variable @c(x) podria haberse movido y el numero de @c(tmp) ya no
   seria la direccion @c(&x.b). La tercera declaracion ataca una ubicacion de
   memoria arbitraria con el valor 42.

#    There are myriad pathological variations on this theme. After this statement
#    has executed:
   Hay un sin sinnumero de variaciones patologicas sobre este tema. Despues de
   que esta declaracion se ha ejecutado:

#    ..src > go
#      pT := uintptr(unsafe.Pointer(new(T))) // NOTE: wrong!
#    < src..
   ..src > go
     pT := uintptr(unsafe.Pointer(new(T))) // NOTA: incorrecto!
   < src..

#    there are no pointers that refer to the variable created by @c(new), so the
#    garbage collector is entitled to recycle its storage when this statement
#    completes, after which @c(pT) contains the address where the variable was but
#    is no longer.
   no hay punteros que referencien la variable creado por @c(new), por lo que el
   recolector de basura tiene derecho a reciclar su almacenamiento cuando esta
   declaracion se complete, despues de lo cual @c(pT) contiene la direccion
   donde estaba la variable, pero ya no.

#    No current Go implementation uses a moving garbage collector (though future
#    implementations might), but this is no reason for complacency : current
#    versions of Go do move @e(some) variables around in memory. Recall from
#    @l(#Section 5.2) that goroutine stacks grow as needed.  When this happens,
#    all variables on the old stack may be relocated to a new, larger stack, so we
#    cannot rely on the numeric value of a variable’s address remaining unchanged
#    throughout its lifetime.
   Ninguna implementacion actual de Go utiliza un recolector de basura en
   movimiento (aunque futuras implementaciones podrian), pero esto no es motivo
   de complacencia: las versiones actuales de Go hacer mover @e(algunas)
   variables en la memoria. Recuerde de la @l(#Seccion 5.2) que las pilas de
   gorutina crecen segun sea necesario. Cuando esto sucede, todas las variables
   de la pila antigua pueden ser reubicadas en una nueva pila mas grande, por lo
   que no podemos confiar en que el valor numerico de la direccion de una
   variable permanezca invariable durante toda su vida util.

#    At the time of writing, there is little clear guidance on what Go programmers
#    may rely upon after an @c(unsafe.Pointer) to @c(uintptr) conversion (see Go
#    issue 7192), so we strongly recommend that you assume the bare minimum. Treat
#    all @c(uintptr) values as if they contain the @e(former) address of a
#    variable, and minimize the number of operations between converting an
#    @c(unsafe.Pointer) to a @c(uintptr) and using that @c(uintptr). In our first
#    example above, the three operations—conversion to a @c(uintptr), addition of
#    the field offset, conversion back—all appeared within a single expression.
   En el momento de escribir esto, hay poco clara orientacion sobre lo que los
   programadores Go pueden esperar despues de una convercion @c(unsafe.Pointer)
   a @c(uintptr) (en el repositorio vea el asunto 7192), por lo que recomendamos
   encarecidamente que asuma el minimo necesario. Trate todos los valores
   @c(uintptr) como si almacenaran la @e(antigua) direccion de una variable, y
   minimice el numero de operaciones entre la conversion de un @c(unsafe.Pointer)
   a un @c(uintptr) y el uso de ese @c(uintptr). En nuestro primer ejemplo
   anterior, las tres operaciones–la conversion a un @c(uintptr), la suma la
   compensacion de campo, y la conversion de nuevo–aparecieron dentro de una
   sola expresion.

#    When calling a library function that returns a @c(uintptr), such as those
#    below from the @c(reflect) package, the result should be immediately
#    converted to an @c(unsafe.Pointer) to ensure that it continues to point to
#    the same variable.
   Cuando se llama a una funcion de libreria que devuelve un @c(uintptr), como
   las que se muestran a continuacion del paquete @c(reflect), el resultado debe
   ser convertido inmediatamente a un @c(unsafe.Pointer) para asegurarse de que
   sigue apuntando a la misma variable.

#    ..src > go
#      package reflect
#      func (Value) Pointer() uintptr
#      func (Value) UnsafeAddr() uintptr
#      func (Value) InterfaceData() [2]uintptr // (index 1)
#    < src..
   ..src > go
     package reflect
     func (Value) Pointer() uintptr
     func (Value) UnsafeAddr() uintptr
     func (Value) InterfaceData() [2]uintptr // (index 1)
   < src..

# ** Section 13.3 <> Example: Deep Equivalence
** Seccion 13.3 <> Ejemplo: Equivalencia profunda

#    The @c(DeepEqual) function from the @c(reflect) package reports whether two
#    values are @"(deeply) equal. @c(DeepEqual) compares basic values as if by the
#    built-in @c(==) operator; for composite values, it traverses them
#    recursively, comparing corresponding elements. Because it works for any pair
#    of values, even ones that are not comparable with @c(==), it finds widespread
#    use in tests.  The following test uses @c(DeepEqual) to compare two
#    @c([]string) values:
   La funcion @c(DeepEqual) del paquete @c(reflect) informa si dos valores son
   @"(profundamente) iguales. @c(DeepEqual) compara los valores basicos como si
   fuera el operador @c(==); para los valores compuestos, los recorre
   recursivamente, comparando los elementos correspondientes. Debido a que
   funciona para cualquier par de valores, incluso los que no son comparables
   con @c(==), este encuentra un uso amplio en pruebas. La siguiente prueba
   utiliza @c(DeepEqual) para comparar dos valores @c([]string):

#    ..src > go
#      func TestSplit(t *testing.T) {
#        got := strings.Split("a:b:c", ":")
#        want := []string{"a", "b", "c"};
#        if !reflect.DeepEqual(got, want) { /* ... */ }
#      }
#    < src..
   ..src > go
     func TestSplit(t *testing.T) {
       got := strings.Split("a:b:c", ":")
       want := []string{"a", "b", "c"};
       if !reflect.DeepEqual(got, want) { /* ... */ }
     }
   < src..

#    Although @c(DeepEqual) is convenient, its distinctions can seem arbitrary. For
#    example, it doesn’t consider a nil map equal to a non-nil empty map, nor a
#    nil slice equal to a non-nil empty one:
   Aunque @c(DeepEqual) es conveniente, sus distinciones pueden parecer
   arbitrarias. Por ejemplo, no considera un mapa nil igual a un mapa vacio
   no-nil, ni un slice nil igual a uno vacio no-nil:

#    ..src > go
#      var a, b []string = nil, []string{}
#      fmt.Println(reflect.DeepEqual(a, b)) // "false"
#
#      var c, d map[string]int = nil, make(map[string]int)
#      fmt.Println(reflect.DeepEqual(c, d)) // "false"
#    < src..
   ..src > go
     var a, b []string = nil, []string{}
     fmt.Println(reflect.DeepEqual(a, b)) // "false"

     var c, d map[string]int = nil, make(map[string]int)
     fmt.Println(reflect.DeepEqual(c, d)) // "false"
   < src..

#    In this section we’ll define a function Equal that compares arbitrary
#    values. Like @c(DeepEqual), it compares slices and maps based on their
#    elements, but unlike @c(DeepEqual), it considers a nil slice (or map) equal
#    to a non-nil empty one. The basic recursion over the arguments can be done
#    with reflection, using a similar approach to the @c(Display) program we saw
#    in @l(#Section 12.3).  As usual, we define an unexported function, @c(equal),
#    for the recursion. Don’t worry about the @c(seen) parameter just yet. For
#    each pair of values @c(x) and @c(y) to be compared, @c(equal) checks that
#    both (or neither) are valid and checks that they have the same type. The
#    result of the function is defined as a set of switch cases that compare two
#    values of the same type. For reasons of space, we’ve omitted several cases
#    since the pattern should be familiar by now.
   En esta seccion vamos a definir una funcion @c(Equal) que compara valores
   arbitrarios. Al igual que @c(DeepEqual), compara slices y mapas en base a sus
   elementos, pero a diferencia de @c(DeepEqual), considera una slice nil (o
   mapa) igual a uno no-nil vacio. La recursion basica sobre los argumentos se
   puede hacer con reflexion, usando un enfoque similar a @c(Display) del
   programa que vimos en la @l(#Seccion 12.3). Como de costumbre, definimos una
   funcion no exportada, @c(equal), para la recursion.  Por el momento no se
   preocupe por el parametro @c(seen). Para cada par de valores @c(x) y @c(y) a
   comparar, @c(equal) verifica que ambos (o ninguno) son validos y comprueba
   que tienen el mismo tipo. El resultado de la funcion se define como un
   conjunto de casos de conmutacion que comparan dos valores del mismo tipo. Por
   motivos de espacio, hemos omitido varios casos, ya que el patron debe ser
   familiar por ahora.

#    ..figure > @l(gopl.io/ch13/equal/equal.go<>gopl.io/ch13/equal)
   ..figure > @l(gopl.io/ch13/equal/equal.go<>gopl.io/ch13/equal)

#      ..src > go
#        func equal(x, y reflect.Value, seen map[comparison]bool) bool {
#          if !x.IsValid() || !y.IsValid() {
#            return x.IsValid() == y.IsValid()
#          }
#          if x.Type() != y.Type() {
#            return false
#          }
#
#          // ...cycle check omitted (shown later)...
#
#          switch x.Kind() {
#          case reflect.Bool:
#            return x.Bool() == y.Bool()
#
#          case reflect.String:
#            return x.String() == y.String()
#
#          // ...numeric cases omitted for brevity...
#
#          case reflect.Chan, reflect.UnsafePointer, reflect.Func:
#            return x.Pointer() == y.Pointer()
#
#          case reflect.Ptr, reflect.Interface:
#            return equal(x.Elem(), y.Elem(), seen)
#
#          case reflect.Array, reflect.Slice:
#            if x.Len() != y.Len() {
#              return false
#            }
#            for i := 0; i < x.Len(); i++ {
#              if !equal(x.Index(i), y.Index(i), seen) {
#                return false
#              }
#            }
#            return true
#
#          // ...struct and map cases omitted for brevity...
#          }
#          panic("unreachable")
#        }
#      < src..
     ..src > go
       func equal(x, y reflect.Value, seen map[comparison]bool) bool {
         if !x.IsValid() || !y.IsValid() {
           return x.IsValid() == y.IsValid()
         }
         if x.Type() != y.Type() {
           return false
         }

         // ...ciclo de verificacion omitido (mostrado mas adelante)...

         switch x.Kind() {
         case reflect.Bool:
           return x.Bool() == y.Bool()

         case reflect.String:
           return x.String() == y.String()

         // ...casos numericos omitidos por brevedad...

         case reflect.Chan, reflect.UnsafePointer, reflect.Func:
           return x.Pointer() == y.Pointer()

         case reflect.Ptr, reflect.Interface:
           return equal(x.Elem(), y.Elem(), seen)

         case reflect.Array, reflect.Slice:
           if x.Len() != y.Len() {
             return false
           }
           for i := 0; i < x.Len(); i++ {
             if !equal(x.Index(i), y.Index(i), seen) {
               return false
             }
           }
           return true

         // ...struct and map cases omitted for brevity...
         }
         panic("unreachable")
       }
     < src..


#    As usual, we don’t expose the use of reflection in the API, so the exported
#    function @c(Equal) must call @c(reflect.ValueOf) on its arguments:
   Como de costumbre, no exponemos el uso de la reflexion en la API, por lo que
   la funcion exportada @c(Equal) debe llamarla con @c(reflect.ValueOf) en sus
   argumentos:

#    ..src > go
#      // Equal reports whether x and y are deeply equal.
#      func Equal(x, y interface{}) bool {
#        seen := make(map[comparison]bool)
#        return equal(reflect.ValueOf(x), reflect.ValueOf(y), seen)
#      }
#
#      type comparison struct {
#        x, y unsafe.Pointer
#        t
#        reflect.Type
#      }
#    < src..
   ..src > go
     // Equal informa si x e y son profundamente iguales.
     func Equal(x, y interface{}) bool {
       seen := make(map[comparison]bool)
       return equal(reflect.ValueOf(x), reflect.ValueOf(y), seen)
     }

     type comparison struct {
       x, y unsafe.Pointer
       t
       reflect.Type
     }
   < src..

#    To ensure that the algorithm terminates even for cyclic data structures, it
#    must record which pairs of variables it has already compared and avoid
#    comparing them a second time. @c(Equal) allocates a set of @c(comparison)
#    structs, each holding the address of two variables (represented as
#    @c(unsafe.Pointer) values) and the type of the comparison. We need to record
#    the type in addition to the addresses because different variables can have
#    the same address. For example, if @c(x) and @c(y) are both arrays, @c(x) and
#    @c(x[0]) have the same address, as do @c(y) and @c(y[0]), and it is important
#    to distinguish whether we have compared @c(x) and @c(y) or @c(x[0]) and
#    @c(y[0]).
   Para asegurar que el algoritmo termina incluso para estructuras de datos
   ciclicas, debe registrar que pares de variables ya ha comparado y evitar
   compararlas una segunda vez. @c(Equal) asigna un conjunto de comparison
   estructuras, cada uno con la direccion de dos variables (representado como
   valores @c(unsafe.Pointer)) y el tipo de comparacion. Necesitamos registrar
   el tipo ademas de las direcciones porque las diferentes variables pueden
   tener la misma direccion. Por ejemplo, si @c(x) y @c(y) son ambos arreglos,
   @c(x) y @c(x[0]) tienen la misma direccion, como lo hacen @c(y) e @c(y[0]), y
   es importante distinguir si hemos comparado @c(x) y @c(y) o @c(x[0]) y
   @c(y[0]).

#    Once @c(equal) has established that its arguments have the same type, and
#    before it executes the switch, it checks whether it is comparing two
#    variables it has already seen and, if so, terminates the recursion.
   Una vez equal ha establecido que sus argumentos tienen el mismo tipo, y antes
   de que ejecute el switch, se comprueba si se esta comparando dos variables
   que ya ha visto y, si es asi, termina la recursion.

#    ..src > go
#      // cycle check
#      if x.CanAddr() && y.CanAddr() {
#        xptr := unsafe.Pointer(x.UnsafeAddr())
#        yptr := unsafe.Pointer(y.UnsafeAddr())
#        if xptr == yptr {
#          return true // identical references
#        }
#        c := comparison{xptr, yptr, x.Type()}
#        if seen[c] {
#          return true // already seen
#        }
#        seen[c] = true
#      }
#    < src..
   ..src > go
     // verificacion de ciclo
     if x.CanAddr() && y.CanAddr() {
       xptr := unsafe.Pointer(x.UnsafeAddr())
       yptr := unsafe.Pointer(y.UnsafeAddr())
       if xptr == yptr {
         return true // referencias identicas
       }
       c := comparison{xptr, yptr, x.Type()}
       if seen[c] {
         return true // ya visto
       }
       seen[c] = true
     }
   < src..

#    Here’s our @c(Equal) function in action:
   Aqui esta nuestra funcion @c(Equal) en accion:

#    ..src > go
#      fmt.Println(Equal([]int{1, 2, 3}, []int{1, 2, 3}))        // "true"
#      fmt.Println(Equal([]string{"foo"}, []string{"bar"}))      // "false"
#      fmt.Println(Equal([]string(nil), []string{}))             // "true"
#      fmt.Println(Equal(map[string]int(nil), map[string]int{})) // "true"
#    < src..
   ..src > go
     fmt.Println(Equal([]int{1, 2, 3}, []int{1, 2, 3}))        // "true"
     fmt.Println(Equal([]string{"foo"}, []string{"bar"}))      // "false"
     fmt.Println(Equal([]string(nil), []string{}))             // "true"
     fmt.Println(Equal(map[string]int(nil), map[string]int{})) // "true"
   < src..

#    It even works on cyclic inputs similar to the one that caused the @c(Display)
#    function from @l(#Section 12.3) to get stuck in a loop:
   Incluso funciona en entradas ciclicas similares a la que hizo que la funcion
   @c(Display) de la @l(#Seccion 12.3) quedara atascada en un bucle:

#    ..src > go
#      // Circular linked lists a -> b -> a and c -> c.
#      type link struct {
#        value string
#        tail *link
#      }
#      a, b, c := &link{value: "a"}, &link{value: "b"}, &link{value: "c"}
#      a.tail, b.tail, c.tail = b, a, c
#      fmt.Println(Equal(a, a)) // "true"
#      fmt.Println(Equal(b, b)) // "true"
#      fmt.Println(Equal(c, c)) // "true"
#      fmt.Println(Equal(a, b)) // "false"
#      fmt.Println(Equal(a, c)) // "false"
#    < src..
   ..src > go
     // Lista circular enlazada a -> b -> a and c -> c.
     type link struct {
       value string
       tail *link
     }
     a, b, c := &link{value: "a"}, &link{value: "b"}, &link{value: "c"}
     a.tail, b.tail, c.tail = b, a, c
     fmt.Println(Equal(a, a)) // "true"
     fmt.Println(Equal(b, b)) // "true"
     fmt.Println(Equal(c, c)) // "true"
     fmt.Println(Equal(a, b)) // "false"
     fmt.Println(Equal(a, c)) // "false"
   < src..

#    @b(Exercise 13.1): Define a deep comparison function that considers numbers
#    (of any type) equal if they differ by less than one part in a billion.
   @b(Ejercicio 13.1): Definir una funcion de comparacion de profundidad que
   tome en cuenta los numeros (de cualquier tipo) igual si difieren en menos de
   una parte en mil millones.

#    @b(Exercise 13.2): Write a function that reports whether its argument is a
#    cyclic data structure.
   @b(Ejercicio 13.2): Escribir una funcion que informa si su argumento es una
   estructura de datos ciclica.

# ** Section 13.4 <> Calling C Code with @$(cgo)
** Seccion 13.4 <> Llamar Codigo C con @$(cgo)

#    A Go program might need to use a hardware driver implemented in C, query an
#    embedded database implemented in C++, or use some linear algebra routines
#    implemented in Fortran. C has long been the lingua franca of programming, so
#    many packages intended for widespread use export a C-compatible API,
#    regardless of the language of their implementation.
   Un programa Go puede necesitar utilizar un controlador de hardware
   implementado en C, consultar una base de datos enbebida implementada en C++ o
   utilizar algunas rutinas de algebra lineal implementadas en Fortran. C ha
   sido durante mucho tiempo la lingua franca de la programacion, por lo que
   muchos paquetes destinados a un uso generalizado exportan una API compatible
   con C, independientemente del lenguaje de su implementacion.

#    In this section, we’ll build a simple data compression program that uses
#    @$(cgo), a tool that creates Go bindings for C functions. Such tools are
#    called @e(foreign-function interfaces) (FFIs), and @$(cgo) is not the only
#    one for Go programs. SWIG (@l(http://swig.org/<>swig.org)) is another; it
#    provides more complex features for integrating with C++ classes, but we won’t
#    show it here.
   En esta seccion, vamos a construir un simple programa de compresion de datos
   que utiliza @$(cgo), una herramienta que crea enlaces de Go para funciones C.
   Estas herramientas se llaman @e(interfaces de funcion externa) (FFIs), y
   @$(cgo) no es el unico para los programas Go. SWIG
   (@l(http://swig.org/<>swig.org)) es otro; Proporciona caracteristicas mas
   complejas para integrarse con las clases de C++, pero no lo mostraremos aqui.

#    The @c(compress/...) subtree of the standard library provides compressors and
#    decompressors for popular compression algorithms, including LZW (used by the
#    Unix @$(compress) command) and DEFLATE (used by the GNU @$(gzip)
#    command). The APIs of these packages vary slightly in details, but they all
#    provide a wrapper for an @c(io.Writer) that compresses the data written to
#    it, and a wrapper for an @c(io.Reader) that decompresses the data read from
#    it. For example:
   El subarbol @c(compress/...) de la libreria estandar proporciona compresores
   y descompresores de los algoritmos de compresion mas populares, incluyendo
   LZW (usado por el comando Unix @$(compress)) y DEFLATE (usado por el comando
   GNU @$(gzip)). Las APIs de estos paquetes varian ligeramente en detalles,
   pero todos ellos proporcionan un envoltorio para un io.Writer que comprime
   los datos escritos en ellos, y un envoltorio para un io.Reader que
   descomprime los datos leidos de estos. Por ejemplo:

#    ..src > go
#      package gzip // compress/gzip
#
#      func NewWriter(w io.Writer) io.WriteCloser
#      func NewReader(r io.Reader) (io.ReadCloser, error)
#    < src..
   ..src > go
     package gzip // compress/gzip

     func NewWriter(w io.Writer) io.WriteCloser
     func NewReader(r io.Reader) (io.ReadCloser, error)
   < src..

#    The bzip2 algorithm, which is based on the elegant Burrows-Wheeler transform,
#    runs slower than gzip but yields significantly better compression. The
#    @c(compress/bzip2) package provides a decompressor for bzip2, but at the
#    moment the package provides no compressor. Building one from scratch is a
#    substantial undertaking, but there is a well-documented and high-performance
#    open-source C implementation, the @c(libbzip2) package from
#    @l(http://bzip.org/<>bzip.org).
   El algoritmo bzip2, que se basa en la elegante transformacion de
   Burrows-Wheeler, corre mas lento que gzip pero produce una compresion
   significativamente mejor. El paquete @c(compress/bzip2) proporciona un
   descompresor para bzip2, pero en este momento el paquete no proporciona
   ningun compresor. La construccion de uno desde cero es una tarea sustancial,
   pero hay una implementacion en C de codigo abierto bien documentada con alto
   rendimiento, el paquete @c(libbzip2) desde @l(http://bzip.org/<>bzip.org).

#    If the C library were small, we would just port it to pure Go, and if its
#    performance were not critical for our purposes, we would be better off
#    invoking a C program as a helper subprocess using the @c(os/exec)
#    package. It’s when you need to use a complex, performance-critical library
#    with a narrow C API that it may make sense to wrap it using @$(cgo). For the
#    rest of this chapter, we’ll work through an example.
   Si la libreria de C fuera pequeña, simplemente la portariamos a Go puro, y si
   su rendimiento no fuera critico para nuestros propositos, estariamos mejor
   invocando un programa en C como un subproceso de ayuda utilizando el paquete
   @c(os/exec). Es cuando se necesita utilizar una libreria compleja, de
   rendimiento critico con un API C compacto que puede tener sentido envolverla
   usando @$(cgo). El resto de este capitulo, trabajaremos con un ejemplo.

#    From the @c(libbzip2) C package, we need the @c(bz_stream) struct type, which
#    holds the input and output buffers, and three C functions:
#    @c(BZ2_bzCompressInit), which allocates the stream’s buffers;
#    @c(BZ2_bzCompress), which compresses data from the input buffer to the output
#    buffer; and @c(BZ2_bzCompressEnd), which releases the buffers. (Don’t worry
#    about the mechanics of the @c(libbzip2) package; the purpose of this example
#    is to show how the parts fit together.)
   Desde el paquete C @c(libbzip2), necesitamos el tipo de estructura
   @c(bz_stream), que contiene los buferes de entrada y salida, y tres funciones
   de C: @c(BZ2_bzCompressInit), que asigna buffers del flujo;
   @c(BZ2_bzCompress), que comprime los datos de bufer d entrada al bufer de
   salida; y @c(BZ2_bzCompressEnd), que libera los bufferes. (No se preocupe por
   la mecanica del paquete @c(libbzip2), el proposito de este ejemplo es mostrar
   como las piezas encajan entre si.)

#    We’ll call the @c(BZ2_bzCompressInit) and @c(BZ2_bzCompressEnd) C functions
#    directly from Go, but for @c(BZ2_bzCompress), we’ll define a wrapper function
#    in C, to show how it’s done. The C source file below lives alongside the Go
#    code in our package:
   Vamos a llamar a las funciones @c(BZ2_bzCompressInit) y @c(BZ2_bzCompressEnd)
   C directamente desde Go, pero para @c(BZ2_bzCompress), vamos a definir una
   funcion de envoltorio en C, para mostrar como se hace. El archivo de codigo
   fuente C vive al lado del codigo Go en nuestro paquete:

#    ..figure > @l(gopl.io/ch13/bzip/bzip2.c<>gopl.io/ch13/bzip)
   ..figure > @l(gopl.io/ch13/bzip/bzip2.c<>gopl.io/ch13/bzip)

#      ..src > go
#        /* This file is gopl.io/ch13/bzip/bzip2.c,         */
#        /* a simple wrapper for libbzip2 suitable for cgo. */
#        #include <bzlib.h>
#
#        int bz2compress(bz_stream *s, int action,
#                        char *in, unsigned *inlen, char *out, unsigned *outlen) {
#          s->next_in = in;
#          s->avail_in = *inlen;
#          s->next_out = out;
#          s->avail_out = *outlen;
#          int r = BZ2_bzCompress(s, action);
#          *inlen -= s->avail_in;
#          *outlen -= s->avail_out;
#          s->next_in = s->next_out = NULL;
#          return r;
#        }
#      < src..
     ..src > go
       /* Este archivo es gopl.io/ch13/bzip/bzip2.c,            */
       /* un simple envoltorio para libbzip2 adecuado para cgo. */
       #include <bzlib.h>

       int bz2compress(bz_stream *s, int action,
                       char *in, unsigned *inlen, char *out, unsigned *outlen) {
         s->next_in = in;
         s->avail_in = *inlen;
         s->next_out = out;
         s->avail_out = *outlen;
         int r = BZ2_bzCompress(s, action);
         *inlen -= s->avail_in;
         *outlen -= s->avail_out;
         s->next_in = s->next_out = NULL;
         return r;
       }
     < src..


#    Now let’s turn to the Go code, the first part of which is shown below. The
#    @c(import "C") declaration is special. There is no package @c(C), but this
#    import causes @$(go build) to preprocess the file using the @$(cgo) tool
#    before the Go compiler sees it.
   Ahora veamos el codigo Go, cuya primera parte se muestra a continuacion. La
   declaracion @c(import "C") es especial. No hay ningun paquete C, pero esta
   importacion hace que @$(go build) preprocese el archivo con la herramienta
   @$(cgo) antes de que el compilador Go lo vea.

#    ..src > go
#      // Package bzip provides a writer that uses bzip2 compression (bzip.org).
#      package bzip
#
#      /*
#      #cgo CFLAGS: -I/usr/include
#      #cgo LDFLAGS: -L/usr/lib -lbz2
#      #include <bzlib.h>
#      int bz2compress(bz_stream *s, int action,
#                      char *in, unsigned *inlen, char *out, unsigned *outlen);
#      */
#      import "C"
#
#      import (
#        "io"
#        "unsafe"
#      )
#
#      type writer struct {
#        w      io.Writer // underlying output stream
#        stream *C.bz_stream
#        outbuf [64 * 1024]byte
#      }
#
#      // NewWriter returns a writer for bzip2-compressed streams.
#      func NewWriter(out io.Writer) io.WriteCloser {
#        const (
#          blockSize = 9
#          verbosity = 0
#          workFactor = 30
#        )
#        w := &writer{w: out, stream: new(C.bz_stream)}
#        C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)
#        return w
#      }
#    < src..
   ..src > go
     // El paquete bzip proporciona un escritor que utiliza compresion bzip2 (bzip.org).
     package bzip

     /*
     #cgo CFLAGS: -I/usr/include
     #cgo LDFLAGS: -L/usr/lib -lbz2
     #include <bzlib.h>
     int bz2compress(bz_stream *s, int action,
                     char *in, unsigned *inlen, char *out, unsigned *outlen);
     */
     import "C"

     import (
       "io"
       "unsafe"
     )

     type writer struct {
       w      io.Writer // underlying output stream
       stream *C.bz_stream
       outbuf [64 * 1024]byte
     }

     // NewWriter devuelve un escritor para flujos bzip2 comprimidos.
     func NewWriter(out io.Writer) io.WriteCloser {
       const (
         blockSize = 9
         verbosity = 0
         workFactor = 30
       )
       w := &writer{w: out, stream: new(C.bz_stream)}
       C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)
       return w
     }
   < src..

#    During preprocessing, @$(cgo) generates a temporary package that contains Go
#    declarations corresponding to all the C functions and types used by the file,
#    such as @c(C.bz_stream) and @c(C.BZ2_bzCompressInit). The @$(cgo) tool
#    discovers these types by invoking the C compiler in a special way on the
#    contents of the comment that precedes the import declaration.
   Durante el preprocesamiento, @$(cgo) genera un paquete temporal que contiene
   declaraciones Go correspondientes a todas las funciones de C y los tipos
   utilizados por el archivo, como @c(C.bz_stream) y @c(C.BZ2_bzCompressInit).
   La herramienta @$(cgo) descubre este tipo invocando el compilador de C de una
   manera especial sobre el contenido del comentario que precede a la
   declaracion de importacion.

#    The comment may also contain @c(#cgo) directives that specify extra options
#    to the C toolchain. The @c(CFLAGS) and @c(LDFLAGS) values contribute extra
#    arguments to the compiler and linker commands so that they can locate the
#    @c(bzlib.h) header file and the @f(libbz2.a) archive library. The example
#    assumes that these are installed beneath @f(/usr) on your system. You may
#    need to alter or delete these flags for your installation.  NewWriter makes a
#    call to the C function BZ2_bzCompressInit to initialize the buffers for the
#    stream. The writer type includes another buffer that will be used to drain
#    the decompressor’s output buffer.
   El comentario tambien puede contener directivas @c(#cgo) que especifican
   opciones adicionales a la cadena de herramientas C. Los valores @c(CFLAGS) y
   @c(LDFLAGS) aportan argumentos adicionales a los comandos de compilacion y
   enlace para que puedan localizar el archivo de cabecera @c(bzlib.h) y la
   libreria de archivo @c(libbz2.a). El ejemplo supone que estos se instalan
   debajo de @c(/usr) en su sistema. Es posible que necesite modificar o
   eliminar estos indicadores para su instalacion. @c(NewWriter) realiza una
   llamada a la funcion C @c(BZ2_bzCompressInit) para inicializar los buferes de
   la secuencia. El tipo de escritor incluye otro bufer que se utilizara para
   drenar el bufer de salida del descompresor.

#    The @c(Write) method, shown below, feeds the uncompressed @c(data) to the
#    compressor, calling the function @c(bz2compress) in a loop until all the data
#    has been consumed. Observe that the Go program may access C types like
#    @c(bz_stream), @c(char), and @c(uint), C functions like @c(bz2compress), and
#    even object-like C preprocessor macros such as @c(BZ_RUN), all through the
#    @c(C.x) notation. The @c(C.uint) type is distinct from Go’s @c(uint) type,
#    even if both have the same width.
   El metodo @c(Write), se muestra a continuacion, alimenta el compresor con
   @c(data), llamando a la funcion @c(bz2compress) en un bucle hasta que todos
   los datos se ha consumido. Observe que el programa Go puede acceder tipos C
   como @c(bz_stream), @c(char), y @c(uint), funciones de C como
   @c(bz2compress), e incluso macros del preprocesador C como a objetos como
   @c(BZ_RUN), todo a traves de la notacion @c(C.x). El tipo @c(C.uint) es
   distinto del tipo @c(uint) de Go, incluso si ambos tienen el mismo tamaño.

#    ..src > go
#      func (w *writer) Write(data []byte) (int, error) {
#        if w.stream == nil {
#          panic("closed")
#        }
#        var total int // uncompressed bytes written
#
#        for len(data) > 0 {
#          inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf))
#          C.bz2compress(w.stream, C.BZ_RUN,
#            (*C.char)(unsafe.Pointer(&data[0])), &inlen,
#            (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen)
#          total += int(inlen)
#          data = data[inlen:]
#          if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {
#            return total, err
#          }
#        }
#        return total, nil
#      }
#    < src..
   ..src > go
     func (w *writer) Write(data []byte) (int, error) {
       if w.stream == nil {
         panic("closed")
       }
       var total int // bytes escritos sin comprimir

       for len(data) > 0 {
         inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf))
         C.bz2compress(w.stream, C.BZ_RUN,
           (*C.char)(unsafe.Pointer(&data[0])), &inlen,
           (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen)
         total += int(inlen)
         data = data[inlen:]
         if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {
           return total, err
         }
       }
       return total, nil
     }
   < src..

#    Each iteration of the loop passes @c(bz2compress) the address and length of
#    the remaining portion of @c(data), and the address and capacity of
#    @c(w.outbuf). The two length variables are passed by their addresses, not
#    their values, so that the C function can update them to indicate how much
#    uncompressed data was consumed and how much compressed data was
#    produced. Each chunk of compressed data is then written to the underlying
#    @c(io.Writer).
   Cada iteracion del bucle @c(bz2compress) pasa la direccion y longitud de la
   porcion restante de la variable @c(data), y la direccion y capacidad de
   @c(w.outbuf). Las dos variables de longitud son pasadas por sus direcciones,
   no por sus valores, por lo que la funcion C puede actualizarlas para indicar
   la cantidad de datos sin comprimir que se consumio y la cantidad de datos
   comprimidos producidos. Cada trozo de datos comprimido se escribe en el
   @c(io.Writer) subyacente.

#    The @c(Close) method has a similar structure to @c(Write), using a loop to
#    flush out any remaining compressed data from the stream’s output buffer.
   El metodo @c(Close) tiene una estructura similar a @c(Write), utilizando un
   bucle para eliminar cualquier resto de datos comprimidos del bufer de salida
   del flujo.

#    ..src > go
#      // Close flushes the compressed data and closes the stream.
#      // It does not close the underlying io.Writer.
#      func (w *writer) Close() error {
#        if w.stream == nil {
#          panic("closed")
#        }
#        defer func() {
#          C.BZ2_bzCompressEnd(w.stream)
#          w.stream = nil
#        }()
#        for {
#          inlen, outlen := C.uint(0), C.uint(cap(w.outbuf))
#          r := C.bz2compress(w.stream, C.BZ_FINISH, nil, &inlen,
#            (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen)
#          if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {
#            return err
#          }
#          if r == C.BZ_STREAM_END {
#            return nil
#          }
#        }
#      }
#    < src..
   ..src > go
     // Cierra los datos comprimidos y cierra el flujo.
     // No cierra el io.Writer subyacente.
     func (w *writer) Close() error {
       if w.stream == nil {
         panic("closed")
       }
       defer func() {
         C.BZ2_bzCompressEnd(w.stream)
         w.stream = nil
       }()
       for {
         inlen, outlen := C.uint(0), C.uint(cap(w.outbuf))
         r := C.bz2compress(w.stream, C.BZ_FINISH, nil, &inlen,
           (*C.char)(unsafe.Pointer(&w.outbuf)), &outlen)
         if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {
           return err
         }
         if r == C.BZ_STREAM_END {
           return nil
         }
       }
     }
   < src..

#    Upon completion, @c(Close) calls @c(C.BZ2_bzCompressEnd) to release the
#    stream buffers, using @c(defer) to ensure that this happens on all return
#    paths. At this point the @c(w.stream) pointer is no longer safe to
#    dereference. To be defensive, we set it to @c(nil), and add explicit nil
#    checks to each method, so that the program panics if the user mistakenly
#    calls a method after @c(Close).
   Al finalizar, @c(Close) llama a @c(C.BZ2_bzCompressEnd) para liberar los
   buferes de flujo, utilizando @c(defer) para asegurar que esto sucede en todas
   las rutas de retorno. En este punto el puntero @c(w.stream) ya no es seguro
   de deferenciar. Para estar a la defensiva, lo ponemos a @c(nil), y agregamos
   chequeos explicitos de nil en cada metodo, por lo que el programa entra en
   panico si el usuario llama por error un metodo despues de @c(Close).

#    Not only is @c(writer) not concurrency-safe, but concurrent calls to
#    @c(Close) and @c(Write) could cause the program to crash in C code. Fixing this
#    is Exercise 13.3.
   No solo @c(writer) no es concurrentemente seguro, sino que las concurrentes a
   @c(Close) y @c(Write) podria hacer que el programa se bloquee en el codigo
   C. Correjir esto es el Ejercicio 13.3.

#    The program below, @c(bzipper), is a bzip2 compressor command that uses our
#    new package. It behaves like the @$(bzip2) command present on many Unix
#    systems.
   El siguiente programa, @c(bzipper), es un comando @c(bzip2) compresor que
   utiliza nuestro nuevo paquete. Se comporta como el comando @$(bzip2) presente
   en muchos sistemas Unix.

#    ..figure > @l(gopl.io/ch13/bzipper/main.go<>gopl.io/ch13/bzipper)
   ..figure > @l(gopl.io/ch13/bzipper/main.go<>gopl.io/ch13/bzipper)

#      ..src > go
#        // Bzipper reads input, bzip2-compresses it, and writes it out.
#        package main
#
#        import (
#          "io"
#          "log"
#          "os"
#
#          "gopl.io/ch13/bzip"
#        )
#
#        func main() {
#          w := bzip.NewWriter(os.Stdout)
#          if _, err := io.Copy(w, os.Stdin); err != nil {
#            log.Fatalf("bzipper: %v\n", err)
#          }
#          if err := w.Close(); err != nil {
#            log.Fatalf("bzipper: close: %v\n", err)
#          }
#        }
#      < src..
     ..src > go
       // Bzipper lee la entrada, lo comprime como bzip2, y lo escribe en la salida.
       package main

       import (
         "io"
         "log"
         "os"

         "gopl.io/ch13/bzip"
       )

       func main() {
         w := bzip.NewWriter(os.Stdout)
         if _, err := io.Copy(w, os.Stdin); err != nil {
           log.Fatalf("bzipper: %v\n", err)
         }
         if err := w.Close(); err != nil {
           log.Fatalf("bzipper: close: %v\n", err)
         }
       }
     < src..


#    In the session below, we use @$(bzipper) to compress
#    @c(/usr/share/dict/words), the system dictionary, from 938,848 bytes to
#    335,405 bytes—about a third of its original size—then uncompress it with the
#    system @$(bunzip2) command. The SHA256 hash is the same before and after,
#    giving us confidence that the compressor is working correctly. (If you don’t
#    have @$(sha256sum) on your system, use your solution to Exercise 4.2.)
   En la sesion a continuacion, utilizamos @$(bzipper) para comprimir
   @c(/usr/share/dict/words) el diccionario del sistema, de 938,848 bytes a
   335,405 bytes–aproximadamente de un tercio de su tamaño original–luego lo
   descomprimimos con el comando del sistema @$(bunzip2). El hash SHA256 es el
   mismo antes y despues, dandonos confianza de que el compresor esta
   funcionando correctamente. (Si usted no tiene @$(sha256sum) en su sistema,
   utilice su solucion al Ejercicio 4.2.)

#    ..src > sh
#      $ go build gopl.io/ch13/bzipper
#      $ wc -c < /usr/share/dict/words
#      938848
#      $ sha256sum < /usr/share/dict/words
#      126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed $ ./bzipper < /usr/share/dict/words | wc -c
#      335405
#      $ ./bzipper < /usr/share/dict/words | bunzip2 | sha256sum
#      126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -
#    < src..
   ..src > sh
     $ go build gopl.io/ch13/bzipper
     $ wc -c < /usr/share/dict/words
     938848
     $ sha256sum < /usr/share/dict/words
     126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed $ ./bzipper < /usr/share/dict/words | wc -c
     335405
     $ ./bzipper < /usr/share/dict/words | bunzip2 | sha256sum
     126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -
   < src..

#    We’ve demonstrated linking a C library into a Go program. Going in the other
#    direction, it’s also possible to compile a Go program as a static archive
#    that can be linked into a C program or as a shared library that can be
#    dynamically loaded by a C program. We’ve only scratched the surface of
#    @$(cgo) here, and there is much more to say about memory management,
#    pointers, callbacks, signal handling, strings, @c(errno), finalizers, and the
#    relationship between goroutines and operating system threads, much of it very
#    subtle. In particular, the rules for correctly passing pointers from Go to C
#    or vice versa are complex, for reasons similar to those we discussed in
#    @l(#Section 13.2), and not yet authoritatively specified. For further
#    reading, start with @l(https://golang.org/cmd/cgo).
   Hemos demostrado la vinculacion de una libreria C con un programa Go. Yendo
   en la otra direccion, tambien es posible compilar un programa Go como un
   archivo estatico que se puede vincular en un programa C o como una libreria
   compartida que puede cargarse dinamicamente por un programa C. Solo hemos
   arañado la superficie de @$(cgo), y hay mucho mas que decir acerca de la
   gestion de memoria, punteros, devoluciones de llamada, el manejo de señales,
   cadenas, @c(errno), finalizadores, y la relacion entre gorutinas y los hilos
   del sistema operativo, gran parte de ello muy sutil. En particular, las
   reglas para pasar correctamente punteros de Go a C o viceversa son complejas,
   por razones similares a las que discutimos en la @l(#Seccion 13.2), y aun no
   autoritariamente especificadas. Para mas informacion, comience con
   @l(https://golang.org/cmd/cgo).

#    @b(Exercise 13.3): Use @c(sync.Mutex) to make @c(bzip2.writer) safe for
#    concurrent use by multiple goroutines.
   @b(Ejercicio 13.3): Utilice @c(sync.Mutex) para hacer @c(bzip2.writer) seguro
   para el uso concurrente por multiples gorutinas.

#    @b(Exercise 13.4): Depending on C libraries has its drawbacks. Provide an
#    alternative pure-Go implementation of @c(bzip.NewWriter) that uses the
#    @c(os/exec) package to run @c(/bin/bzip2) as a subprocess.
   @b(Ejercicio 13.4): Depender de librerias C tiene sus inconvenientes.
   Proporcione una implementacion alternativa en puro Go de @c(bzip.NewWriter)
   que utilice el paquete @c(os/exec) para ejecutar @c(/bin/bzip2) como un
   subproceso.

# ** Section 13.5 <> Another Word of Caution
** Seccion 13.5 <> Otra Palabra de Precaucion

#    We ended the previous chapter with a warning about the downsides of the
#    reflection interface. That warning applies with even more force to the @c(unsafe)
#    package described in this chapter.
   Terminamos el capitulo anterior con una advertencia sobre las desventajas de
   la interfaz de reflexion. Esa advertencia se aplica incluso con mas fuerza al
   paquete @c(unsafe) descrito en este capitulo.

#    High-level languages insulate programs and programmers not only from the
#    arcane specifics of individual computer instruction sets, but from dependence
#    on irrelevancies like where in memory a variable lives, how big a data type
#    is, the details of structure layout, and a host of other implementation
#    details. Because of that insulating layer, it’s possible to write programs
#    that are safe and robust and that will run on any operating system without
#    change.
   Los lenguajes de alto nivel aislan a los programas y programadores no solo de
   los detalles arcanos de los conjuntos de instrucciones individuales de
   computadora, sino de la dependencia de las irrelevancias, como en la memoria
   en la que vive una variable, el tamaño del tipo de datos, y otros detalles de
   implementacion del anfitrion. Debido a esa capa aislante, es posible escribir
   programas que son seguros y robustos y que se ejecutaran en cualquier sistema
   operativo sin cambios.

#    The @c(unsafe) package lets programmers reach through the insulation to use
#    some crucial but otherwise inaccessible feature, or perhaps to achieve higher
#    performance. The cost is usually to portability and safety, so one uses
#    @c(unsafe) at one’s peril. Our advice on how and when to use @c(unsafe)
#    parallels Knuth’s comments on premature optimization, which we quoted in
#    @l(#Section 11.5). Most programmers will never need to use @c(unsafe) at
#    all. Nevertheless, there will occasionally be situations where some critical
#    piece of code can be best written using @c(unsafe).  If careful study and
#    measurement indicates that @c(unsafe) really is the best approach, restrict
#    it to as small a region as possible, so that most of the program is oblivious
#    to its use.
   El paquete @c(unsafe) permite a los programadores cruzar a traves del
   aislamiento para utilizar alguna caracteristica crucial, pero de otro modo
   inaccesibles, o tal vez para lograr un mayor rendimiento. El costo suele ser
   la portabilidad y la seguridad. Nuestro consejo sobre como y cuando usar
   @c(unsafe) son paralelos a los comentarios de Knuth para la optimizacion
   prematura, que hemos citado en la @l(#Seccion 11.5). La mayoria de los
   programadores nunca necesitaran utilizar @c(unsafe) en absoluto. Sin embargo,
   ocasionalmente habra situaciones en las que algun fragmento critica de codigo
   puede ser escrito mejor usando @c(unsafe). Si el estudio y la medicion
   cuidadosa indican que @c(unsafe) realmente es el mejor enfoque, restrinja el
   fragmento lo mayor posible, para que la mayor parte del programa ignore su
   uso.

#    For now, put the last two chapters in the back of your mind. Write some
#    substantial Go programs. Avoid @c(reflect) and @c(unsafe); come back to these
#    chapters only if you must.
   Por ahora, ponga los dos ultimos capitulos en la parte de atras de su mente.
   Escriba algunos programas importantes en Go. Evite @c(reflect) y @c(unsafe);
   Vuelva a estos capitulos solamente si usted debe.

#    Meanwhile, happy Go programming. We hope you enjoy writing Go as much as we do.
   Mientras tanto, Feliz programacion con Go. Esperamos que disfrutes
   escribiendo en Go tanto como nosotros.
